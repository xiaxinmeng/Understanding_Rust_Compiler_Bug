{"sha": "eb931c0d9e0877e573622253ae5b05563841037b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViOTMxYzBkOWUwODc3ZTU3MzYyMjI1M2FlNWIwNTU2Mzg0MTAzN2I=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-12T21:18:14Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-12T21:18:14Z"}, "message": "Merge #505\n\n505: Inherent methods r=matklad a=flodiebold\n\nThis adds resolution, type checking and completion for inherent methods.\r\n\r\nThe main open question here is the caching, I think. I'm not sure whether we should be caching method resolutions in a more fine grained way (currently we just build a hash map of types -> impl blocks, and iterate through all potential impl blocks when looking for a method).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "653ef81450a4d39c5b46f98c97c23fa8586dd7f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/653ef81450a4d39c5b46f98c97c23fa8586dd7f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb931c0d9e0877e573622253ae5b05563841037b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb931c0d9e0877e573622253ae5b05563841037b", "html_url": "https://github.com/rust-lang/rust/commit/eb931c0d9e0877e573622253ae5b05563841037b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb931c0d9e0877e573622253ae5b05563841037b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "e56072bfa3e5af69a4c293a38de6e1350ada3573", "url": "https://api.github.com/repos/rust-lang/rust/commits/e56072bfa3e5af69a4c293a38de6e1350ada3573", "html_url": "https://github.com/rust-lang/rust/commit/e56072bfa3e5af69a4c293a38de6e1350ada3573"}, {"sha": "1ed7fbfc1badd2c2a42b4dc2feb1b4bf7835d3ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed7fbfc1badd2c2a42b4dc2feb1b4bf7835d3ef", "html_url": "https://github.com/rust-lang/rust/commit/1ed7fbfc1badd2c2a42b4dc2feb1b4bf7835d3ef"}], "stats": {"total": 445, "additions": 398, "deletions": 47}, "files": [{"sha": "91b23559475b26e14106099a936c7d517ce6e4bf", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -113,6 +113,11 @@ impl Module {\n         self.child_impl(db, name)\n     }\n \n+    /// Iterates over all child modules.\n+    pub fn children(&self, db: &impl HirDatabase) -> Cancelable<impl Iterator<Item = Module>> {\n+        self.children_impl(db)\n+    }\n+\n     /// Finds a parent module.\n     pub fn parent(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         self.parent_impl(db)\n@@ -268,22 +273,31 @@ pub use crate::code_model_impl::function::ScopeEntryWithSyntax;\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FnSignature {\n     pub(crate) name: Name,\n-    pub(crate) args: Vec<TypeRef>,\n+    pub(crate) params: Vec<TypeRef>,\n     pub(crate) ret_type: TypeRef,\n+    /// True if the first param is `self`. This is relevant to decide whether this\n+    /// can be called as a method.\n+    pub(crate) has_self_param: bool,\n }\n \n impl FnSignature {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n \n-    pub fn args(&self) -> &[TypeRef] {\n-        &self.args\n+    pub fn params(&self) -> &[TypeRef] {\n+        &self.params\n     }\n \n     pub fn ret_type(&self) -> &TypeRef {\n         &self.ret_type\n     }\n+\n+    /// True if the first arg is `self`. This is relevant to decide whether this\n+    /// can be called as a method.\n+    pub fn has_self_param(&self) -> bool {\n+        self.has_self_param\n+    }\n }\n \n impl Function {"}, {"sha": "8d6b7fc19fbff84f231b138b3c813e0005d07a9a", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -42,7 +42,8 @@ impl FnSignature {\n             .name()\n             .map(|n| n.as_name())\n             .unwrap_or_else(Name::missing);\n-        let mut args = Vec::new();\n+        let mut params = Vec::new();\n+        let mut has_self_param = false;\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let self_type = if let Some(type_ref) = self_param.type_ref() {\n@@ -59,11 +60,12 @@ impl FnSignature {\n                         }\n                     }\n                 };\n-                args.push(self_type);\n+                params.push(self_type);\n+                has_self_param = true;\n             }\n             for param in param_list.params() {\n                 let type_ref = TypeRef::from_ast_opt(param.type_ref());\n-                args.push(type_ref);\n+                params.push(type_ref);\n             }\n         }\n         let ret_type = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n@@ -73,8 +75,9 @@ impl FnSignature {\n         };\n         let sig = FnSignature {\n             name,\n-            args,\n+            params,\n             ret_type,\n+            has_self_param,\n         };\n         Arc::new(sig)\n     }"}, {"sha": "7d938c0dd1eeace1936e1d3083255d5b9684af19", "filename": "crates/ra_hir/src/code_model_impl/function/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction%2Fscope.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -43,7 +43,7 @@ impl FnScopes {\n             scope_for: FxHashMap::default(),\n         };\n         let root = scopes.root_scope();\n-        scopes.add_params_bindings(root, body.args());\n+        scopes.add_params_bindings(root, body.params());\n         compute_expr_scopes(body.body_expr(), &body, &mut scopes, root);\n         scopes\n     }"}, {"sha": "775dd6709f9184774270cb3e381e369215ff460c", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -95,6 +95,21 @@ impl Module {\n         Module::from_module_id(db, loc.source_root_id, child_id).map(Some)\n     }\n \n+    /// Iterates over all child modules.\n+    pub fn children_impl(&self, db: &impl HirDatabase) -> Cancelable<impl Iterator<Item = Module>> {\n+        // FIXME this should be implementable without collecting into a vec, but\n+        // it's kind of hard since the iterator needs to keep a reference to the\n+        // module tree.\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let children = loc\n+            .module_id\n+            .children(&module_tree)\n+            .map(|(_, module_id)| Module::from_module_id(db, loc.source_root_id, module_id))\n+            .collect::<Cancelable<Vec<_>>>()?;\n+        Ok(children.into_iter())\n+    }\n+\n     pub fn parent_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;"}, {"sha": "fd6336dd8c9788c2f20477d3d33e52d73209641b", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -5,13 +5,13 @@ use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, Cancelable};\n \n use crate::{\n     DefLoc, DefId, MacroCallLoc, MacroCallId, Name, HirFileId,\n-    SourceFileItems, SourceItemId,\n+    SourceFileItems, SourceItemId, Crate,\n     query_definitions,\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n     module_tree::{ModuleId, ModuleTree},\n     nameres::{ItemMap, InputModuleItems},\n-    ty::{InferenceResult, Ty},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n };\n@@ -102,6 +102,11 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::impl_block::impls_in_module;\n     }\n \n+    fn impls_in_crate(krate: Crate) -> Cancelable<Arc<CrateImplBlocks>> {\n+        type ImplsInCrateQuery;\n+        use fn crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query;\n+    }\n+\n     fn body_hir(def_id: DefId) -> Cancelable<Arc<crate::expr::Body>> {\n         type BodyHirQuery;\n         use fn crate::expr::body_hir;"}, {"sha": "67e123e4dcaae501df4d02aa0dfd87a88155f2a4", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -18,13 +18,13 @@ impl_arena_id!(ExprId);\n pub struct Body {\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n-    /// The patterns for the function's arguments. While the argument types are\n+    /// The patterns for the function's parameters. While the parameter types are\n     /// part of the function signature, the patterns are not (they don't change\n     /// the external type of the function).\n     ///\n     /// If this `Body` is for the body of a constant, this will just be\n     /// empty.\n-    args: Vec<PatId>,\n+    params: Vec<PatId>,\n     /// The `ExprId` of the actual body expression.\n     body_expr: ExprId,\n }\n@@ -44,8 +44,8 @@ pub struct BodySyntaxMapping {\n }\n \n impl Body {\n-    pub fn args(&self) -> &[PatId] {\n-        &self.args\n+    pub fn params(&self) -> &[PatId] {\n+        &self.params\n     }\n \n     pub fn body_expr(&self) -> ExprId {\n@@ -699,11 +699,11 @@ impl ExprCollector {\n         }\n     }\n \n-    fn into_body_syntax_mapping(self, args: Vec<PatId>, body_expr: ExprId) -> BodySyntaxMapping {\n+    fn into_body_syntax_mapping(self, params: Vec<PatId>, body_expr: ExprId) -> BodySyntaxMapping {\n         let body = Body {\n             exprs: self.exprs,\n             pats: self.pats,\n-            args,\n+            params,\n             body_expr,\n         };\n         BodySyntaxMapping {\n@@ -719,8 +719,8 @@ impl ExprCollector {\n pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n     let mut collector = ExprCollector::new();\n \n-    let args = if let Some(param_list) = node.param_list() {\n-        let mut args = Vec::new();\n+    let params = if let Some(param_list) = node.param_list() {\n+        let mut params = Vec::new();\n \n         if let Some(self_param) = param_list.self_param() {\n             let self_param = LocalSyntaxPtr::new(\n@@ -729,13 +729,13 @@ pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n                     .expect(\"self param without self keyword\")\n                     .syntax(),\n             );\n-            let arg = collector.alloc_pat(\n+            let param = collector.alloc_pat(\n                 Pat::Bind {\n                     name: Name::self_param(),\n                 },\n                 self_param,\n             );\n-            args.push(arg);\n+            params.push(param);\n         }\n \n         for param in param_list.params() {\n@@ -744,15 +744,15 @@ pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n             } else {\n                 continue;\n             };\n-            args.push(collector.collect_pat(pat));\n+            params.push(collector.collect_pat(pat));\n         }\n-        args\n+        params\n     } else {\n         Vec::new()\n     };\n \n     let body = collector.collect_block_opt(node.body());\n-    collector.into_body_syntax_mapping(args, body)\n+    collector.into_body_syntax_mapping(params, body)\n }\n \n pub(crate) fn body_syntax_mapping("}, {"sha": "d0b08630810eaa9b7591e3b9abf1505279bdda7e", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -33,20 +33,27 @@ impl ImplBlock {\n         })\n     }\n \n+    pub(crate) fn from_id(module_impl_blocks: Arc<ModuleImplBlocks>, impl_id: ImplId) -> ImplBlock {\n+        ImplBlock {\n+            module_impl_blocks,\n+            impl_id,\n+        }\n+    }\n+\n     fn impl_data(&self) -> &ImplData {\n         &self.module_impl_blocks.impls[self.impl_id]\n     }\n \n     pub fn target_trait(&self) -> Option<&TypeRef> {\n-        self.impl_data().target_trait.as_ref()\n+        self.impl_data().target_trait()\n     }\n \n     pub fn target_type(&self) -> &TypeRef {\n-        &self.impl_data().target_type\n+        self.impl_data().target_type()\n     }\n \n     pub fn items(&self) -> &[ImplItem] {\n-        &self.impl_data().items\n+        self.impl_data().items()\n     }\n }\n \n@@ -64,7 +71,7 @@ impl ImplData {\n         module: &Module,\n         node: &ast::ImplBlock,\n     ) -> Self {\n-        let target_trait = node.target_type().map(TypeRef::from_ast);\n+        let target_trait = node.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n         let module_loc = module.def_id.loc(db);\n         let items = if let Some(item_list) = node.item_list() {\n@@ -103,6 +110,18 @@ impl ImplData {\n             items,\n         }\n     }\n+\n+    pub fn target_trait(&self) -> Option<&TypeRef> {\n+        self.target_trait.as_ref()\n+    }\n+\n+    pub fn target_type(&self) -> &TypeRef {\n+        &self.target_type\n+    }\n+\n+    pub fn items(&self) -> &[ImplItem] {\n+        &self.items\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -133,11 +152,9 @@ impl_arena_id!(ImplId);\n /// This way, we avoid having to do this process for the whole crate whenever\n /// a file is changed; as long as the impl blocks in the file don't change,\n /// we don't need to do the second step again.\n-///\n-/// (The second step does not yet exist.)\n #[derive(Debug, PartialEq, Eq)]\n pub struct ModuleImplBlocks {\n-    impls: Arena<ImplId, ImplData>,\n+    pub(crate) impls: Arena<ImplId, ImplData>,\n     impls_by_def: FxHashMap<DefId, ImplId>,\n }\n \n@@ -153,7 +170,10 @@ impl ModuleImplBlocks {\n         let (file_id, module_source) = module.definition_source(db)?;\n         let node = match &module_source {\n             ModuleSource::SourceFile(node) => node.syntax(),\n-            ModuleSource::Module(node) => node.syntax(),\n+            ModuleSource::Module(node) => node\n+                .item_list()\n+                .expect(\"inline module should have item list\")\n+                .syntax(),\n         };\n \n         let source_file_items = db.file_items(file_id.into());"}, {"sha": "9371c5a0dec3aedc02f501e6bb37d37238ea913a", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -235,6 +235,7 @@ salsa::database_storage! {\n             fn enum_data() for db::EnumDataQuery;\n             fn enum_variant_data() for db::EnumVariantDataQuery;\n             fn impls_in_module() for db::ImplsInModuleQuery;\n+            fn impls_in_crate() for db::ImplsInCrateQuery;\n             fn body_hir() for db::BodyHirQuery;\n             fn body_syntax_mapping() for db::BodySyntaxMappingQuery;\n             fn fn_signature() for db::FnSignatureQuery;"}, {"sha": "5d5568d69a0abfe5f3e636ee21dbf560b204efb5", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -17,6 +17,7 @@ mod autoderef;\n mod primitive;\n #[cfg(test)]\n mod tests;\n+pub(crate) mod method_resolution;\n \n use std::borrow::Cow;\n use std::ops::Index;\n@@ -431,7 +432,7 @@ fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     let impl_block = f.impl_block(db)?;\n     // TODO we ignore type parameters for now\n     let input = signature\n-        .args()\n+        .params()\n         .iter()\n         .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), tr))\n         .collect::<Cancelable<Vec<_>>>()?;\n@@ -875,7 +876,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none())?;\n-                let (arg_tys, ret_ty) = match &callee_ty {\n+                let (param_tys, ret_ty) = match &callee_ty {\n                     Ty::FnPtr(sig) => (&sig.input[..], sig.output.clone()),\n                     _ => {\n                         // not callable\n@@ -886,19 +887,43 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 for (i, arg) in args.iter().enumerate() {\n                     self.infer_expr(\n                         *arg,\n-                        &Expectation::has_type(arg_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n+                        &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n                     )?;\n                 }\n                 ret_ty\n             }\n-            Expr::MethodCall { receiver, args, .. } => {\n-                let _receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n-                // TODO resolve method...\n-                for (_i, arg) in args.iter().enumerate() {\n-                    // TODO unify / expect argument type\n-                    self.infer_expr(*arg, &Expectation::none())?;\n+            Expr::MethodCall {\n+                receiver,\n+                args,\n+                method_name,\n+            } => {\n+                let receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n+                let resolved = receiver_ty.clone().lookup_method(self.db, method_name)?;\n+                let method_ty = match resolved {\n+                    Some(def_id) => self.db.type_for_def(def_id)?,\n+                    None => Ty::Unknown,\n+                };\n+                let method_ty = self.insert_type_vars(method_ty);\n+                let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n+                    Ty::FnPtr(sig) => {\n+                        if sig.input.len() > 0 {\n+                            (&sig.input[0], &sig.input[1..], sig.output.clone())\n+                        } else {\n+                            (&Ty::Unknown, &[][..], sig.output.clone())\n+                        }\n+                    }\n+                    _ => (&Ty::Unknown, &[][..], Ty::Unknown),\n+                };\n+                // TODO we would have to apply the autoderef/autoref steps here\n+                // to get the correct receiver type to unify...\n+                self.unify(expected_receiver_ty, &receiver_ty);\n+                for (i, arg) in args.iter().enumerate() {\n+                    self.infer_expr(\n+                        *arg,\n+                        &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n+                    )?;\n                 }\n-                Ty::Unknown\n+                ret_ty\n             }\n             Expr::Match { expr, arms } => {\n                 let _ty = self.infer_expr(*expr, &Expectation::none())?;\n@@ -1068,7 +1093,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn collect_fn_signature(&mut self, signature: &FnSignature) -> Cancelable<()> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        for (type_ref, pat) in signature.args().iter().zip(body.args()) {\n+        for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n             let ty = self.make_ty(type_ref)?;\n             let ty = self.insert_type_vars(ty);\n             self.write_pat_ty(*pat, ty);"}, {"sha": "7c3839388391bae3487e73b6a8d9b30c86f48381", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -0,0 +1,164 @@\n+//! This module is concerned with finding methods that a given type provides.\n+//! For details about how this works in rustc, see the method lookup page in the\n+//! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)\n+//! and the corresponding code mostly in librustc_typeck/check/method/probe.rs.\n+use std::sync::Arc;\n+\n+use rustc_hash::FxHashMap;\n+\n+use ra_db::{Cancelable, SourceRootId};\n+\n+use crate::{HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function, impl_block::{ImplId, ImplBlock, ImplItem}};\n+use super::Ty;\n+\n+/// This is used as a key for indexing impls.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum TyFingerprint {\n+    Adt(DefId),\n+    // we'll also want to index impls for primitive types etc.\n+}\n+\n+impl TyFingerprint {\n+    /// Creates a TyFingerprint for looking up an impl. Only certain types can\n+    /// have impls: if we have some `struct S`, we can have an `impl S`, but not\n+    /// `impl &S`. Hence, this will return `None` for reference types and such.\n+    fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n+        match ty {\n+            Ty::Adt { def_id, .. } => Some(TyFingerprint::Adt(*def_id)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct CrateImplBlocks {\n+    /// To make sense of the ModuleIds, we need the source root.\n+    source_root_id: SourceRootId,\n+    impls: FxHashMap<TyFingerprint, Vec<(ModuleId, ImplId)>>,\n+}\n+\n+impl CrateImplBlocks {\n+    pub fn lookup_impl_blocks<'a>(\n+        &'a self,\n+        db: &'a impl HirDatabase,\n+        ty: &Ty,\n+    ) -> impl Iterator<Item = Cancelable<ImplBlock>> + 'a {\n+        let fingerprint = TyFingerprint::for_impl(ty);\n+        fingerprint\n+            .and_then(|f| self.impls.get(&f))\n+            .into_iter()\n+            .flat_map(|i| i.iter())\n+            .map(move |(module_id, impl_id)| {\n+                let module_impl_blocks = db.impls_in_module(self.source_root_id, *module_id)?;\n+                Ok(ImplBlock::from_id(module_impl_blocks, *impl_id))\n+            })\n+    }\n+\n+    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n+        let module_id = module.def_id.loc(db).module_id;\n+        let module_impl_blocks = db.impls_in_module(self.source_root_id, module_id)?;\n+\n+        for (impl_id, impl_data) in module_impl_blocks.impls.iter() {\n+            let impl_block = ImplBlock::from_id(Arc::clone(&module_impl_blocks), impl_id);\n+\n+            if let Some(_target_trait) = impl_data.target_trait() {\n+                // ignore for now\n+            } else {\n+                let target_ty =\n+                    Ty::from_hir(db, &module, Some(&impl_block), impl_data.target_type())?;\n+                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n+                    self.impls\n+                        .entry(target_ty_fp)\n+                        .or_insert_with(Vec::new)\n+                        .push((module_id, impl_id));\n+                }\n+            }\n+        }\n+\n+        for child in module.children(db)? {\n+            self.collect_recursive(db, child)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    pub(crate) fn impls_in_crate_query(\n+        db: &impl HirDatabase,\n+        krate: Crate,\n+    ) -> Cancelable<Arc<CrateImplBlocks>> {\n+        let crate_graph = db.crate_graph();\n+        let file_id = crate_graph.crate_root(krate.crate_id);\n+        let source_root_id = db.file_source_root(file_id);\n+        let mut crate_impl_blocks = CrateImplBlocks {\n+            source_root_id,\n+            impls: FxHashMap::default(),\n+        };\n+        if let Some(module) = krate.root_module(db)? {\n+            crate_impl_blocks.collect_recursive(db, module)?;\n+        }\n+        Ok(Arc::new(crate_impl_blocks))\n+    }\n+}\n+\n+fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Cancelable<Option<Crate>> {\n+    match ty {\n+        Ty::Adt { def_id, .. } => def_id.krate(db),\n+        _ => Ok(None),\n+    }\n+}\n+\n+impl Ty {\n+    // TODO: cache this as a query?\n+    // - if so, what signature? (TyFingerprint, Name)?\n+    // - or maybe cache all names and def_ids of methods per fingerprint?\n+    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<DefId>> {\n+        self.iterate_methods(db, |f| {\n+            let sig = f.signature(db);\n+            if sig.name() == name && sig.has_self_param() {\n+                Ok(Some(f.def_id()))\n+            } else {\n+                Ok(None)\n+            }\n+        })\n+    }\n+\n+    // This would be nicer if it just returned an iterator, but that's really\n+    // complicated with all the cancelable operations\n+    pub fn iterate_methods<T>(\n+        self,\n+        db: &impl HirDatabase,\n+        mut callback: impl FnMut(Function) -> Cancelable<Option<T>>,\n+    ) -> Cancelable<Option<T>> {\n+        // For method calls, rust first does any number of autoderef, and then one\n+        // autoref (i.e. when the method takes &self or &mut self). We just ignore\n+        // the autoref currently -- when we find a method matching the given name,\n+        // we assume it fits.\n+\n+        // Also note that when we've got a receiver like &S, even if the method we\n+        // find in the end takes &self, we still do the autoderef step (just as\n+        // rustc does an autoderef and then autoref again).\n+\n+        for derefed_ty in self.autoderef(db) {\n+            let krate = match def_crate(db, &derefed_ty)? {\n+                Some(krate) => krate,\n+                None => continue,\n+            };\n+            let impls = db.impls_in_crate(krate)?;\n+\n+            for impl_block in impls.lookup_impl_blocks(db, &derefed_ty) {\n+                let impl_block = impl_block?;\n+                for item in impl_block.items() {\n+                    match item {\n+                        ImplItem::Method(f) => {\n+                            if let Some(result) = callback(f.clone())? {\n+                                return Ok(Some(result));\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+        Ok(None)\n+    }\n+}"}, {"sha": "1c31294410dc9c73776ffaf3961059e949ca7ee8", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -242,6 +242,32 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_inherent_method() {\n+    check_inference(\n+        r#\"\n+struct A;\n+\n+impl A {\n+    fn foo(self, x: u32) -> i32 {}\n+}\n+\n+mod b {\n+    impl super::A {\n+        fn bar(&self, x: u64) -> i64 {}\n+    }\n+}\n+\n+fn test(a: A) {\n+    a.foo(1);\n+    (&a).bar(1);\n+    a.bar(1);\n+}\n+\"#,\n+        \"inherent_method.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "6e6f70357a7e49cbb832d8d9e70072cbd26007bf", "filename": "crates/ra_hir/src/ty/tests/data/inherent_method.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Finherent_method.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Finherent_method.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Finherent_method.txt?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -0,0 +1,18 @@\n+[32; 36) 'self': A\n+[38; 39) 'x': u32\n+[53; 55) '{}': ()\n+[103; 107) 'self': &A\n+[109; 110) 'x': u64\n+[124; 126) '{}': ()\n+[144; 145) 'a': A\n+[150; 198) '{     ...(1); }': ()\n+[156; 157) 'a': A\n+[156; 164) 'a.foo(1)': i32\n+[162; 163) '1': u32\n+[170; 181) '(&a).bar(1)': i64\n+[171; 173) '&a': &A\n+[172; 173) 'a': A\n+[179; 180) '1': u64\n+[187; 188) 'a': A\n+[187; 195) 'a.bar(1)': i64\n+[193; 194) '1': u64"}, {"sha": "37985b398177c5fb42cc90d7e42247152a5e7e63", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -17,8 +17,9 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Ca\n     };\n     let receiver_ty = infer_result[expr].clone();\n     if !ctx.is_call {\n-        complete_fields(acc, ctx, receiver_ty)?;\n+        complete_fields(acc, ctx, receiver_ty.clone())?;\n     }\n+    complete_methods(acc, ctx, receiver_ty)?;\n     Ok(())\n }\n \n@@ -55,6 +56,24 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n     Ok(())\n }\n \n+fn complete_methods(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    receiver: Ty,\n+) -> Cancelable<()> {\n+    receiver.iterate_methods(ctx.db, |func| {\n+        let sig = func.signature(ctx.db);\n+        if sig.has_self_param() {\n+            CompletionItem::new(CompletionKind::Reference, sig.name().to_string())\n+                .from_function(ctx, func)\n+                .kind(CompletionItemKind::Method)\n+                .add_to(acc);\n+        }\n+        Ok(None::<()>)\n+    })?;\n+    Ok(())\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::completion::*;\n@@ -87,7 +106,8 @@ mod tests {\n                 }\n             }\n             \",\n-            r#\"the_field \"(u32,)\"\"#,\n+            r#\"the_field \"(u32,)\"\n+               foo \"foo($0)\"\"#,\n         );\n     }\n \n@@ -102,7 +122,8 @@ mod tests {\n                 }\n             }\n             \",\n-            r#\"the_field \"(u32, i32)\"\"#,\n+            r#\"the_field \"(u32, i32)\"\n+               foo \"foo($0)\"\"#,\n         );\n     }\n \n@@ -118,4 +139,36 @@ mod tests {\n             r#\"\"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_method_completion() {\n+        check_ref_completion(\n+            r\"\n+            struct A {}\n+            impl A {\n+                fn the_method(&self) {}\n+            }\n+            fn foo(a: A) {\n+               a.<|>\n+            }\n+            \",\n+            r#\"the_method \"the_method($0)\"\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_no_non_self_method() {\n+        check_ref_completion(\n+            r\"\n+            struct A {}\n+            impl A {\n+                fn the_method() {}\n+            }\n+            fn foo(a: A) {\n+               a.<|>\n+            }\n+            \",\n+            r#\"\"#,\n+        );\n+    }\n }"}, {"sha": "b75d65de3e7be4bc15ecd4a8450a3f9a91853b9a", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -37,6 +37,7 @@ pub enum CompletionItemKind {\n     Const,\n     Trait,\n     TypeAlias,\n+    Method,\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -183,10 +184,14 @@ impl Builder {\n         self\n     }\n \n-    fn from_function(mut self, ctx: &CompletionContext, function: hir::Function) -> Builder {\n+    pub(super) fn from_function(\n+        mut self,\n+        ctx: &CompletionContext,\n+        function: hir::Function,\n+    ) -> Builder {\n         // If not an import, add parenthesis automatically.\n         if ctx.use_item_syntax.is_none() && !ctx.is_call {\n-            if function.signature(ctx.db).args().is_empty() {\n+            if function.signature(ctx.db).params().is_empty() {\n                 self.snippet = Some(format!(\"{}()$0\", self.label));\n             } else {\n                 self.snippet = Some(format!(\"{}($0)\", self.label));"}, {"sha": "60f84675d4bc1c66bea4855c6508ac152d2113f5", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -124,6 +124,7 @@ salsa::database_storage! {\n             fn enum_data() for hir::db::EnumDataQuery;\n             fn enum_variant_data() for hir::db::EnumVariantDataQuery;\n             fn impls_in_module() for hir::db::ImplsInModuleQuery;\n+            fn impls_in_crate() for hir::db::ImplsInCrateQuery;\n             fn body_hir() for hir::db::BodyHirQuery;\n             fn body_syntax_mapping() for hir::db::BodySyntaxMappingQuery;\n             fn fn_signature() for hir::db::FnSignatureQuery;"}, {"sha": "22b8e9221bf225a4e561d5a51f229ea9747d2c34", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb931c0d9e0877e573622253ae5b05563841037b/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=eb931c0d9e0877e573622253ae5b05563841037b", "patch": "@@ -69,6 +69,7 @@ impl Conv for CompletionItemKind {\n             CompletionItemKind::TypeAlias => Struct,\n             CompletionItemKind::Const => Constant,\n             CompletionItemKind::Static => Value,\n+            CompletionItemKind::Method => Method,\n         }\n     }\n }"}]}