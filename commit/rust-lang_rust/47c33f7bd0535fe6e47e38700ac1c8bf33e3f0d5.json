{"sha": "47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YzMzZjdiZDA1MzVmZTZlNDdlMzg3MDBhYzFjOGJmMzNlM2YwZDU=", "commit": {"author": {"name": "James Cowgill", "email": "jcowgill@debian.org", "date": "2018-02-14T12:48:04Z"}, "committer": {"name": "James Cowgill", "email": "jcowgill@debian.org", "date": "2018-02-14T14:39:55Z"}, "message": "rustc_trans: adjust mips64 abi to use new CastTarget", "tree": {"sha": "7d5969bb9f5ee63dea918ffbadbf9b908b7293ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d5969bb9f5ee63dea918ffbadbf9b908b7293ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5", "html_url": "https://github.com/rust-lang/rust/commit/47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5/comments", "author": {"login": "jcowgill", "id": 1226825, "node_id": "MDQ6VXNlcjEyMjY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1226825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcowgill", "html_url": "https://github.com/jcowgill", "followers_url": "https://api.github.com/users/jcowgill/followers", "following_url": "https://api.github.com/users/jcowgill/following{/other_user}", "gists_url": "https://api.github.com/users/jcowgill/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcowgill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcowgill/subscriptions", "organizations_url": "https://api.github.com/users/jcowgill/orgs", "repos_url": "https://api.github.com/users/jcowgill/repos", "events_url": "https://api.github.com/users/jcowgill/events{/privacy}", "received_events_url": "https://api.github.com/users/jcowgill/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcowgill", "id": 1226825, "node_id": "MDQ6VXNlcjEyMjY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1226825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcowgill", "html_url": "https://github.com/jcowgill", "followers_url": "https://api.github.com/users/jcowgill/followers", "following_url": "https://api.github.com/users/jcowgill/following{/other_user}", "gists_url": "https://api.github.com/users/jcowgill/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcowgill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcowgill/subscriptions", "organizations_url": "https://api.github.com/users/jcowgill/orgs", "repos_url": "https://api.github.com/users/jcowgill/repos", "events_url": "https://api.github.com/users/jcowgill/events{/privacy}", "received_events_url": "https://api.github.com/users/jcowgill/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2", "html_url": "https://github.com/rust-lang/rust/commit/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2"}], "stats": {"total": 24, "additions": 15, "deletions": 9}, "files": [{"sha": "94bf53cee1edbd67b90885dccc28d44ecb482268", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5", "patch": "@@ -73,7 +73,7 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n             } else if ret.layout.fields.count() == 2 {\n                 if let Some(reg0) = float_reg(cx, ret, 0) {\n                     if let Some(reg1) = float_reg(cx, ret, 1) {\n-                        ret.cast_to(CastTarget::Pair(reg0, reg1));\n+                        ret.cast_to(CastTarget::pair(reg0, reg1));\n                         return;\n                     }\n                 }\n@@ -98,7 +98,7 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n \n     let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n-    let mut prefix = [RegKind::Integer; 8];\n+    let mut prefix = [None; 8];\n     let mut prefix_index = 0;\n \n     match arg.layout.fields {\n@@ -123,15 +123,20 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                 if let layout::Abi::Scalar(ref scalar) = field.abi {\n                     if let layout::F64 = scalar.value {\n                         if offset.is_abi_aligned(dl.f64_align) {\n-                            // Skip over enough integers to cover [last_offset, offset)\n+                            // Insert enough integers to cover [last_offset, offset)\n                             assert!(last_offset.is_abi_aligned(dl.f64_align));\n-                            prefix_index += ((offset - last_offset).bits() / 64) as usize;\n+                            for _ in 0..((offset - last_offset).bits() / 64)\n+                                .min((prefix.len() - prefix_index) as u64) {\n \n-                            if prefix_index >= prefix.len() {\n+                                prefix[prefix_index] = Some(RegKind::Integer);\n+                                prefix_index += 1;\n+                            }\n+\n+                            if prefix_index == prefix.len() {\n                                 break;\n                             }\n \n-                            prefix[prefix_index] = RegKind::Float;\n+                            prefix[prefix_index] = Some(RegKind::Float);\n                             prefix_index += 1;\n                             last_offset = offset + Reg::f64().size;\n                         }\n@@ -142,10 +147,11 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n     };\n \n     // Extract first 8 chunks as the prefix\n-    arg.cast_to(CastTarget::ChunkedPrefix {\n+    let rest_size = size - Size::from_bytes(8) * prefix_index as u64;\n+    arg.cast_to(CastTarget {\n         prefix: prefix,\n-        chunk: Size::from_bytes(8),\n-        total: size\n+        prefix_chunk: Size::from_bytes(8),\n+        rest: Uniform { unit: Reg::i64(), total: rest_size }\n     });\n }\n "}]}