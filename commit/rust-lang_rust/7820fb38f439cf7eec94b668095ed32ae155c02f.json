{"sha": "7820fb38f439cf7eec94b668095ed32ae155c02f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MjBmYjM4ZjQzOWNmN2VlYzk0YjY2ODA5NWVkMzJhZTE1NWMwMmY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-12T12:45:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-12T13:01:01Z"}, "message": "don't distinguish Create and Write events in VFS", "tree": {"sha": "7544c935fd8a3e0fa49ecebd3a684ddac4fed685", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7544c935fd8a3e0fa49ecebd3a684ddac4fed685"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7820fb38f439cf7eec94b668095ed32ae155c02f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7820fb38f439cf7eec94b668095ed32ae155c02f", "html_url": "https://github.com/rust-lang/rust/commit/7820fb38f439cf7eec94b668095ed32ae155c02f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7820fb38f439cf7eec94b668095ed32ae155c02f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19718ea109eae2f933ce3464c73879c09f9bdbe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/19718ea109eae2f933ce3464c73879c09f9bdbe2", "html_url": "https://github.com/rust-lang/rust/commit/19718ea109eae2f933ce3464c73879c09f9bdbe2"}], "stats": {"total": 80, "additions": 42, "deletions": 38}, "files": [{"sha": "dc0b84d5a57b4260096978a59b9c7c01aeffc8a5", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb38f439cf7eec94b668095ed32ae155c02f/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb38f439cf7eec94b668095ed32ae155c02f/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=7820fb38f439cf7eec94b668095ed32ae155c02f", "patch": "@@ -17,14 +17,28 @@ pub(crate) enum Task {\n     AddRoot { root: VfsRoot, config: Arc<RootConfig> },\n }\n \n+/// `TaskResult` transfers files read on the IO thread to the VFS on the main\n+/// thread.\n #[derive(Debug)]\n pub enum TaskResult {\n+    /// Emitted when we've recursively scanned a source root during the initial\n+    /// load.\n     BulkLoadRoot { root: VfsRoot, files: Vec<(RelativePathBuf, String)> },\n-    AddSingleFile { root: VfsRoot, path: RelativePathBuf, text: String },\n-    ChangeSingleFile { root: VfsRoot, path: RelativePathBuf, text: String },\n-    RemoveSingleFile { root: VfsRoot, path: RelativePathBuf },\n+    /// Emitted when we've noticed that a single file has changed.\n+    ///\n+    /// Note that this by design does not distinguish between\n+    /// create/delete/write events, and instead specifies the *current* state of\n+    /// the file. The idea is to guarantee that in the quiescent state the sum\n+    /// of all results equals to the current state of the file system, while\n+    /// allowing to skip intermediate events in non-quiescent states.\n+    SingleFile { root: VfsRoot, path: RelativePathBuf, text: Option<String> },\n }\n \n+/// The kind of raw notification we've received from the notify library.\n+///\n+/// Note that these are not necessary 100% precise (for example we might receive\n+/// `Create` instead of `Write`, see #734), but we try do distinguish `Create`s\n+/// to implement recursive watching of directories.\n #[derive(Debug)]\n enum ChangeKind {\n     Create,\n@@ -45,7 +59,7 @@ impl Worker {\n         // explained by the following concerns:\n         //    * we need to burn a thread translating from notify's mpsc to\n         //      crossbeam_channel.\n-        //    * we want to read all files from a single thread, to gurantee that\n+        //    * we want to read all files from a single thread, to guarantee that\n         //      we always get fresher versions and never go back in time.\n         //    * we want to tear down everything neatly during shutdown.\n         let (worker, worker_handle) = thread_worker::spawn(\n@@ -63,7 +77,7 @@ impl Worker {\n                 let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n                     .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n                     .ok();\n-                // Start a silly thread to tranform between two channels\n+                // Start a silly thread to transform between two channels\n                 let thread = thread::spawn(move || {\n                     notify_receiver\n                         .into_iter()\n@@ -98,7 +112,7 @@ impl Worker {\n                 }\n                 // Stopped the watcher\n                 drop(watcher.take());\n-                // Drain pending events: we are not inrerested in them anyways!\n+                // Drain pending events: we are not interested in them anyways!\n                 watcher_receiver.into_iter().for_each(|_| ());\n \n                 let res = thread.join();\n@@ -199,23 +213,16 @@ fn handle_change(\n             }\n             paths\n                 .into_iter()\n-                .filter_map(|rel_path| {\n+                .try_for_each(|rel_path| {\n                     let abs_path = rel_path.to_path(&config.root);\n-                    let text = read_to_string(&abs_path)?;\n-                    Some((rel_path, text))\n-                })\n-                .try_for_each(|(path, text)| {\n-                    sender.send(TaskResult::AddSingleFile { root, path, text })\n+                    let text = read_to_string(&abs_path);\n+                    sender.send(TaskResult::SingleFile { root, path: rel_path, text })\n                 })\n                 .unwrap()\n         }\n-        ChangeKind::Write => {\n-            if let Some(text) = read_to_string(&path) {\n-                sender.send(TaskResult::ChangeSingleFile { root, path: rel_path, text }).unwrap();\n-            }\n-        }\n-        ChangeKind::Remove => {\n-            sender.send(TaskResult::RemoveSingleFile { root, path: rel_path }).unwrap()\n+        ChangeKind::Write | ChangeKind::Remove => {\n+            let text = read_to_string(&path);\n+            sender.send(TaskResult::SingleFile { root, path: rel_path, text }).unwrap();\n         }\n     }\n }"}, {"sha": "5d98d905c97e2c795695c136740d7c7266ae3181", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb38f439cf7eec94b668095ed32ae155c02f/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb38f439cf7eec94b668095ed32ae155c02f/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=7820fb38f439cf7eec94b668095ed32ae155c02f", "patch": "@@ -37,8 +37,8 @@ impl_arena_id!(VfsRoot);\n \n /// Describes the contents of a single source root.\n ///\n-/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` whihc\n-/// specifes the source root or as a function whihc takes a `PathBuf` and\n+/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` which\n+/// specifies the source root or as a function which takes a `PathBuf` and\n /// returns `true` iff path belongs to the source root\n pub(crate) struct RootConfig {\n     root: PathBuf,\n@@ -60,7 +60,7 @@ impl RootConfig {\n     fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootConfig {\n         RootConfig { root, excluded_dirs }\n     }\n-    /// Cheks if root contains a path and returns a root-relative path.\n+    /// Checks if root contains a path and returns a root-relative path.\n     pub(crate) fn contains(&self, path: &Path) -> Option<RelativePathBuf> {\n         // First, check excluded dirs\n         if self.excluded_dirs.iter().any(|it| path.starts_with(it)) {\n@@ -210,7 +210,7 @@ impl Vfs {\n         match task {\n             TaskResult::BulkLoadRoot { root, files } => {\n                 let mut cur_files = Vec::new();\n-                // While we were scanning the root in the backgound, a file might have\n+                // While we were scanning the root in the background, a file might have\n                 // been open in the editor, so we need to account for that.\n                 let exising = self.root2files[root]\n                     .iter()\n@@ -230,21 +230,18 @@ impl Vfs {\n                 let change = VfsChange::AddRoot { root, files: cur_files };\n                 self.pending_changes.push(change);\n             }\n-            TaskResult::AddSingleFile { root, path, text } => {\n-                if self.find_file(root, &path).is_none() {\n-                    self.do_add_file(root, path, text, false);\n-                }\n-            }\n-            TaskResult::ChangeSingleFile { root, path, text } => {\n-                if let Some(file) = self.find_file(root, &path) {\n-                    self.do_change_file(file, text, false);\n-                } else {\n-                    self.do_add_file(root, path, text, false);\n-                }\n-            }\n-            TaskResult::RemoveSingleFile { root, path } => {\n-                if let Some(file) = self.find_file(root, &path) {\n-                    self.do_remove_file(root, path, file, false);\n+            TaskResult::SingleFile { root, path, text } => {\n+                match (self.find_file(root, &path), text) {\n+                    (Some(file), None) => {\n+                        self.do_remove_file(root, path, file, false);\n+                    }\n+                    (None, Some(text)) => {\n+                        self.do_add_file(root, path, text, false);\n+                    }\n+                    (Some(file), Some(text)) => {\n+                        self.do_change_file(file, text, false);\n+                    }\n+                    (None, None) => (),\n                 }\n             }\n         }"}]}