{"sha": "ec0c029a7ed9ac34bec716193e51b15d29965b0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMGMwMjlhN2VkOWFjMzRiZWM3MTYxOTNlNTFiMTVkMjk5NjViMGU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-24T21:38:23Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-24T21:40:00Z"}, "message": "Split EBML module into a reader and a writer module\n\nMinor refactoring, no review.\n\nCloses #2739", "tree": {"sha": "f014c5482f1faf04b912f2f08423fe1c070aa8ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f014c5482f1faf04b912f2f08423fe1c070aa8ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec0c029a7ed9ac34bec716193e51b15d29965b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec0c029a7ed9ac34bec716193e51b15d29965b0e", "html_url": "https://github.com/rust-lang/rust/commit/ec0c029a7ed9ac34bec716193e51b15d29965b0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec0c029a7ed9ac34bec716193e51b15d29965b0e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "236fd32f0a6647997a68dc729460a1030fdc74cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/236fd32f0a6647997a68dc729460a1030fdc74cb", "html_url": "https://github.com/rust-lang/rust/commit/236fd32f0a6647997a68dc729460a1030fdc74cb"}], "stats": {"total": 1302, "additions": 660, "deletions": 642}, "files": [{"sha": "293a138789fd382fa5f00081325dda26c76133ea", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=ec0c029a7ed9ac34bec716193e51b15d29965b0e", "patch": "@@ -1,6 +1,7 @@\n // Searching for information from the cstore\n \n use std::ebml;\n+use Reader = std::ebml::Reader;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_map;\n@@ -181,7 +182,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                   def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n-    let all_items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n+    let all_items = Reader::get_doc(Reader::Doc(cdata.data), tag_items);\n     debug!(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),"}, {"sha": "ec100b2e3d6c91424a03e0c1732420755849968e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 104, "deletions": 101, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ec0c029a7ed9ac34bec716193e51b15d29965b0e", "patch": "@@ -4,6 +4,7 @@ use std::ebml;\n use std::map;\n use std::map::HashMap;\n use std::serialization::deserialize;\n+use Reader = ebml::Reader;\n use io::WriterUtil;\n use dvec::DVec;\n use syntax::{ast, ast_util};\n@@ -73,17 +74,17 @@ export translate_def_id;\n \n fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n    Option<ebml::Doc> {\n-    let index = ebml::get_doc(d, tag_index);\n-    let table = ebml::get_doc(index, tag_index_table);\n+    let index = Reader::get_doc(d, tag_index);\n+    let table = Reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n     let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n-    let tagged_doc = ebml::doc_at(d.data, pos);\n+    let tagged_doc = Reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n-    for ebml::tagged_docs(tagged_doc.doc, belt) |elt| {\n+    for Reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::view(*elt.data, elt.start + 4u, elt.end)) {\n-            return Some(ebml::doc_at(d.data, pos).doc);\n+            return Some(Reader::doc_at(d.data, pos).doc);\n         }\n     };\n     None\n@@ -108,7 +109,7 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n-    let items = ebml::get_doc(ebml::Doc(data), tag_items);\n+    let items = Reader::get_doc(Reader::Doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n        None => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n        Some(d) => d\n@@ -156,8 +157,8 @@ impl Family : cmp::Eq {\n }\n \n fn item_family(item: ebml::Doc) -> Family {\n-    let fam = ebml::get_doc(item, tag_items_data_item_family);\n-    match ebml::doc_as_u8(fam) as char {\n+    let fam = Reader::get_doc(item, tag_items_data_item_family);\n+    match Reader::doc_as_u8(fam) as char {\n       'c' => Const,\n       'f' => Fn,\n       'u' => UnsafeFn,\n@@ -183,20 +184,20 @@ fn item_family(item: ebml::Doc) -> Family {\n }\n \n fn item_method_sort(item: ebml::Doc) -> char {\n-    for ebml::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n-        return str::from_bytes(ebml::doc_data(doc))[0] as char;\n+    for Reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n+        return str::from_bytes(Reader::doc_data(doc))[0] as char;\n     }\n     return 'r';\n }\n \n fn item_symbol(item: ebml::Doc) -> ~str {\n-    let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    return str::from_bytes(ebml::doc_data(sym));\n+    let sym = Reader::get_doc(item, tag_items_data_item_symbol);\n+    return str::from_bytes(Reader::doc_data(sym));\n }\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n-    for ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        return Some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n+    for Reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n+        return Some(Reader::with_doc_data(did, |d| parse_def_id(d)));\n     }\n     None\n }\n@@ -214,13 +215,13 @@ fn item_reqd_and_translated_parent_item(cnum: ast::crate_num,\n }\n \n fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n-    let tagdoc = ebml::get_doc(d, tag_def_id);\n-    return translate_def_id(cdata, ebml::with_doc_data(tagdoc,\n+    let tagdoc = Reader::get_doc(d, tag_def_id);\n+    return translate_def_id(cdata, Reader::with_doc_data(tagdoc,\n                                                     |d| parse_def_id(d)));\n }\n \n fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n-    for ebml::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n+    for Reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n         }\n@@ -230,24 +231,24 @@ fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n     // Use maybe_get_doc in case it's a method\n     option::map_default(\n-        &ebml::maybe_get_doc(d, tag_class_mut),\n+        &Reader::maybe_get_doc(d, tag_class_mut),\n         ast::class_immutable,\n         |d| {\n-            match ebml::doc_as_u8(*d) as char {\n+            match Reader::doc_as_u8(*d) as char {\n               'm' => ast::class_mutable,\n               _   => ast::class_immutable\n             }\n         })\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n-    do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n-        int::parse_bytes(ebml::doc_data(val_doc), 10u)\n+    do option::chain(Reader::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n+        int::parse_bytes(Reader::doc_data(val_doc), 10u)\n     }\n }\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n-    let tp = ebml::get_doc(doc, tag_items_data_item_type);\n+    let tp = Reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, |did| {\n         translate_def_id(cdata, did)\n     })\n@@ -263,7 +264,7 @@ fn item_type(item_id: ast::def_id, item: ebml::Doc,\n \n fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n     let mut results = ~[];\n-    for ebml::tagged_docs(item, tag_impl_trait) |ity| {\n+    for Reader::tagged_docs(item, tag_impl_trait) |ity| {\n         results.push(doc_type(ity, tcx, cdata));\n     };\n     results\n@@ -272,7 +273,7 @@ fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    for ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n+    for Reader::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, |did| {\n             translate_def_id(cdata, did)\n         });\n@@ -282,41 +283,41 @@ fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n }\n \n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n-    ebml::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        deserialize(&ebml::Deserializer(*doc))\n+    Reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n+        deserialize(&Reader::Deserializer(*doc))\n     })\n }\n \n fn item_ty_param_count(item: ebml::Doc) -> uint {\n     let mut n = 0u;\n-    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n+    Reader::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n                       |_p| { n += 1u; true } );\n     n\n }\n \n fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    for ebml::tagged_docs(item, v) |p| {\n-        let ext = ebml::with_doc_data(p, |d| parse_def_id(d));\n+    for Reader::tagged_docs(item, v) |p| {\n+        let ext = Reader::with_doc_data(p, |d| parse_def_id(d));\n         ids.push({crate: cdata.cnum, node: ext.node});\n     };\n     return ids;\n }\n \n fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n-    let path_doc = ebml::get_doc(item_doc, tag_path);\n+    let path_doc = Reader::get_doc(item_doc, tag_path);\n \n-    let len_doc = ebml::get_doc(path_doc, tag_path_len);\n-    let len = ebml::doc_as_u32(len_doc) as uint;\n+    let len_doc = Reader::get_doc(path_doc, tag_path_len);\n+    let len = Reader::doc_as_u32(len_doc) as uint;\n \n     let mut result = vec::with_capacity(len);\n-    for ebml::docs(path_doc) |tag, elt_doc| {\n+    for Reader::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n-            let str = ebml::doc_as_str(elt_doc);\n+            let str = Reader::doc_as_str(elt_doc);\n             result.push(ast_map::path_mod(intr.intern(@str)));\n         } else if tag == tag_path_elt_name {\n-            let str = ebml::doc_as_str(elt_doc);\n+            let str = Reader::doc_as_str(elt_doc);\n             result.push(ast_map::path_name(intr.intern(@str)));\n         } else {\n             // ignore tag_path_len element\n@@ -327,8 +328,8 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n }\n \n fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n-    let name = ebml::get_doc(item, tag_paths_data_name);\n-    intr.intern(@str::from_bytes(ebml::doc_data(name)))\n+    let name = Reader::get_doc(item, tag_paths_data_name);\n+    intr.intern(@str::from_bytes(Reader::doc_data(name)))\n }\n \n fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n@@ -406,27 +407,28 @@ fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n \n fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n-    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n+    let items = Reader::get_doc(Reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n-    for ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n-        let m_did = ebml::with_doc_data(mid, |d| parse_def_id(d));\n-        if item_name(intr, find_item(m_did.node, items)) == name {\n-            found = Some(translate_def_id(cdata, m_did));\n+    for Reader::tagged_docs(find_item(id, items), tag_item_impl_method)\n+        |mid| {\n+            let m_did = Reader::with_doc_data(mid, |d| parse_def_id(d));\n+            if item_name(intr, find_item(m_did.node, items)) == name {\n+                found = Some(translate_def_id(cdata, m_did));\n+            }\n         }\n-    }\n     found.get()\n }\n \n fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                     name: ast::ident) -> ast::def_id {\n-    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n+    let items = Reader::get_doc(Reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n       Some(it) => it,\n       None => fail (fmt!(\"get_class_method: class id not found \\\n                               when looking up method %s\", *intr.get(name)))\n     };\n-    for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n+    for Reader::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = item_def_id(mid, cdata);\n         if item_name(intr, mid) == name {\n             found = Some(m_did);\n@@ -440,16 +442,16 @@ fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n }\n \n fn class_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n-    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n+    let items = Reader::get_doc(Reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n             Some(it) => it,\n             None     => fail (fmt!(\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id))\n     };\n-    for ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n-         let doc1 = ebml::get_doc(doc, tag_def_id);\n-         let did = ebml::with_doc_data(doc1, |d| parse_def_id(d));\n+    for Reader::tagged_docs(cls_items, tag_item_dtor) |doc| {\n+         let doc1 = Reader::get_doc(doc, tag_def_id);\n+         let did = Reader::with_doc_data(doc1, |d| parse_def_id(d));\n          found = Some(translate_def_id(cdata, did));\n     };\n     found\n@@ -493,14 +495,14 @@ fn path_entry(path_string: ~str, def_like: def_like) -> path_entry {\n fn each_path(intr: @ident_interner, cdata: cmd,\n              get_crate_data: GetCrateDataCb,\n              f: fn(path_entry) -> bool) {\n-    let root = ebml::Doc(cdata.data);\n-    let items = ebml::get_doc(root, tag_items);\n-    let items_data = ebml::get_doc(items, tag_items_data);\n+    let root = Reader::Doc(cdata.data);\n+    let items = Reader::get_doc(root, tag_items);\n+    let items_data = Reader::get_doc(items, tag_items_data);\n \n     let mut broken = false;\n \n     // First, go through all the explicit items.\n-    for ebml::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n+    for Reader::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n         if !broken {\n             let path = ast_map::path_to_str_with_sep(\n                 item_path(intr, item_doc), ~\"::\", intr);\n@@ -523,16 +525,17 @@ fn each_path(intr: @ident_interner, cdata: cmd,\n             for each_reexport(item_doc) |reexport_doc| {\n                 if !broken {\n                     let def_id_doc =\n-                        ebml::get_doc(reexport_doc,\n+                        Reader::get_doc(reexport_doc,\n                             tag_items_data_item_reexport_def_id);\n                     let def_id =\n-                        ebml::with_doc_data(def_id_doc, |d| parse_def_id(d));\n+                        Reader::with_doc_data(def_id_doc,\n+                                              |d| parse_def_id(d));\n                     let def_id = translate_def_id(cdata, def_id);\n \n                     let reexport_name_doc =\n-                        ebml::get_doc(reexport_doc,\n+                        Reader::get_doc(reexport_doc,\n                                       tag_items_data_item_reexport_name);\n-                    let reexport_name = ebml::doc_as_str(reexport_name_doc);\n+                    let reexport_name = Reader::doc_as_str(reexport_name_doc);\n \n                     let reexport_path;\n                     if path == ~\"\" {\n@@ -546,8 +549,8 @@ fn each_path(intr: @ident_interner, cdata: cmd,\n                         items\n                     } else {\n                         let crate_data = get_crate_data(def_id.crate);\n-                        let root = ebml::Doc(crate_data.data);\n-                        ebml::get_doc(root, tag_items)\n+                        let root = Reader::Doc(crate_data.data);\n+                        Reader::get_doc(root, tag_items)\n                     };\n \n                     // Get the item.\n@@ -621,7 +624,7 @@ fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                      tcx: ty::ctxt) -> ~[ty::variant_info] {\n     let data = cdata.data;\n-    let items = ebml::get_doc(ebml::Doc(data), tag_items);\n+    let items = Reader::get_doc(Reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[ty::variant_info] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n@@ -670,8 +673,8 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n         }\n     }\n \n-    let self_type_doc = ebml::get_doc(item, tag_item_trait_method_self_ty);\n-    let string = ebml::doc_as_str(self_type_doc);\n+    let self_type_doc = Reader::get_doc(item, tag_item_trait_method_self_ty);\n+    let string = Reader::doc_as_str(self_type_doc);\n \n     let self_ty_kind = string[0];\n     match self_ty_kind as char {\n@@ -690,8 +693,8 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n                      base_tps: uint) -> ~[@method_info] {\n     let mut rslt = ~[];\n-    for ebml::tagged_docs(item, tag_item_impl_method) |doc| {\n-        let m_did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n+    for Reader::tagged_docs(item, tag_item_impl_method) |doc| {\n+        let m_did = Reader::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         let self_ty = get_self_ty(mth_item);\n         rslt.push(@{did: translate_def_id(cdata, m_did),\n@@ -710,8 +713,8 @@ fn get_impls_for_mod(intr: @ident_interner, cdata: cmd,\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n-    for ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n-        let did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n+    for Reader::tagged_docs(mod_item, tag_mod_impl) |doc| {\n+        let did = Reader::with_doc_data(doc, |d| parse_def_id(d));\n         let local_did = translate_def_id(cdata, did);\n         debug!(\"(get impls for mod) getting did %? for '%?'\",\n                local_did, name);\n@@ -738,7 +741,7 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n+    for Reader::tagged_docs(item, tag_item_trait_method) |mth| {\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n@@ -764,7 +767,7 @@ fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n \n-    for ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n+    for Reader::tagged_docs(item, tag_item_trait_method) |mth| {\n         if item_method_sort(mth) != 'p' { loop; }\n \n         let did = item_def_id(mth, cdata);\n@@ -800,7 +803,7 @@ fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n     let results = dvec::DVec();\n     let item_doc = lookup_item(id, cdata.data);\n-    for ebml::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n+    for Reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n         results.push(doc_type(trait_doc, tcx, cdata));\n     }\n     return dvec::unwrap(move results);\n@@ -819,7 +822,7 @@ fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n     }\n \n     let resulting_methods = @DVec();\n-    for ebml::tagged_docs(item, tag_item_trait_method) |method| {\n+    for Reader::tagged_docs(item, tag_item_trait_method) |method| {\n         resulting_methods.push(\n             (item_name(intr, method), get_self_ty(method)));\n     }\n@@ -834,8 +837,8 @@ fn get_type_name_if_impl(intr: @ident_interner,\n         return None;\n     }\n \n-    for ebml::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n-        return Some(intr.intern(@str::from_bytes(ebml::doc_data(doc))));\n+    for Reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n+        return Some(intr.intern(@str::from_bytes(Reader::doc_data(doc))));\n     }\n \n     return None;\n@@ -851,13 +854,13 @@ fn get_static_methods_if_impl(intr: @ident_interner,\n     }\n \n     // If this impl has a trait ref, don't consider it.\n-    for ebml::tagged_docs(item, tag_impl_trait) |_doc| {\n+    for Reader::tagged_docs(item, tag_impl_trait) |_doc| {\n         return None;\n     }\n \n     let impl_method_ids = DVec();\n-    for ebml::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n-        impl_method_ids.push(parse_def_id(ebml::doc_data(impl_method_doc)));\n+    for Reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n+        impl_method_ids.push(parse_def_id(Reader::doc_data(impl_method_doc)));\n     }\n \n     let static_impl_methods = DVec();\n@@ -892,8 +895,8 @@ fn get_item_attrs(cdata: cmd,\n                   f: fn(~[@ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n-    for ebml::tagged_docs(item, tag_attributes) |attributes| {\n-        for ebml::tagged_docs(attributes, tag_attribute) |attribute| {\n+    for Reader::tagged_docs(item, tag_attributes) |attributes| {\n+        for Reader::tagged_docs(attributes, tag_attribute) |attribute| {\n             f(get_meta_items(attribute));\n         }\n     }\n@@ -905,7 +908,7 @@ fn get_class_members(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for ebml::tagged_docs(item, tag_item_field) |an_item| {\n+    for Reader::tagged_docs(item, tag_item_field) |an_item| {\n        let f = item_family(an_item);\n        if p(f) {\n           let name = item_name(intr, an_item);\n@@ -946,7 +949,7 @@ fn family_names_type(fam: Family) -> bool {\n }\n \n fn read_path(d: ebml::Doc) -> {path: ~str, pos: uint} {\n-    let desc = ebml::doc_data(d);\n+    let desc = Reader::doc_data(d);\n     let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n@@ -989,23 +992,23 @@ fn item_family_to_str(fam: Family) -> ~str {\n \n fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n-    for ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n-        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(ebml::doc_data(nd));\n+    for Reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n+        let nd = Reader::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::from_bytes(Reader::doc_data(nd));\n         items.push(attr::mk_word_item(n));\n     };\n-    for ebml::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n-        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::from_bytes(ebml::doc_data(nd));\n-        let v = str::from_bytes(ebml::doc_data(vd));\n+    for Reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n+        let nd = Reader::get_doc(meta_item_doc, tag_meta_item_name);\n+        let vd = Reader::get_doc(meta_item_doc, tag_meta_item_value);\n+        let n = str::from_bytes(Reader::doc_data(nd));\n+        let v = str::from_bytes(Reader::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n     };\n-    for ebml::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n-        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(ebml::doc_data(nd));\n+    for Reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n+        let nd = Reader::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::from_bytes(Reader::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n     };\n@@ -1014,9 +1017,9 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n \n fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n-    match ebml::maybe_get_doc(md, tag_attributes) {\n+    match Reader::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n-        for ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n+        for Reader::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -1052,21 +1055,21 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: ~str,\n }\n \n fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n-    return get_attributes(ebml::Doc(data));\n+    return get_attributes(Reader::Doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n                   vers: ~str, hash: ~str};\n \n fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n-    let cratedoc = ebml::Doc(data);\n-    let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n+    let cratedoc = Reader::Doc(data);\n+    let depsdoc = Reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n-        str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n+        str::from_bytes(Reader::doc_data(Reader::get_doc(doc, tag_)))\n     }\n-    for ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n+    for Reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push({cnum: crate_num,\n                   name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n@@ -1089,9 +1092,9 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: io::Writer) {\n }\n \n fn get_crate_hash(data: @~[u8]) -> ~str {\n-    let cratedoc = ebml::Doc(data);\n-    let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n-    return str::from_bytes(ebml::doc_data(hashdoc));\n+    let cratedoc = Reader::Doc(data);\n+    let hashdoc = Reader::get_doc(cratedoc, tag_crate_hash);\n+    return str::from_bytes(Reader::doc_data(hashdoc));\n }\n \n fn get_crate_vers(data: @~[u8]) -> ~str {\n@@ -1147,7 +1150,7 @@ fn get_crate_module_paths(intr: @ident_interner, cdata: cmd,\n fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                        out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n-    let md = ebml::Doc(bytes);\n+    let md = Reader::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(intr, bytes, out);\n }"}, {"sha": "e1d5fd77f99db4ae72e01877560c03fb531b1b55", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ec0c029a7ed9ac34bec716193e51b15d29965b0e", "patch": "@@ -5,7 +5,7 @@ use util::ppaux::ty_to_str;\n use std::{ebml, map};\n use std::map::HashMap;\n use io::WriterUtil;\n-use ebml::Serializer;\n+use Writer = ebml::Writer;\n use syntax::ast::*;\n use syntax::print::pprust;\n use syntax::{ast_util, visit};\n@@ -40,7 +40,7 @@ export encode_def_id;\n type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n \n type encode_inlined_item = fn@(ecx: @encode_ctxt,\n-                               ebml_w: ebml::Serializer,\n+                               ebml_w: Writer::Serializer,\n                                path: ast_map::path,\n                                ii: ast::inlined_item);\n \n@@ -86,21 +86,21 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n-fn encode_name(ecx: @encode_ctxt, ebml_w: ebml::Serializer, name: ident) {\n+fn encode_name(ecx: @encode_ctxt, ebml_w: Writer::Serializer, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_def_id(ebml_w: ebml::Serializer, id: def_id) {\n+fn encode_def_id(ebml_w: Writer::Serializer, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_region_param(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n     for opt_rp.each |rp| {\n@@ -110,7 +110,7 @@ fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     }\n }\n \n-fn encode_mutability(ebml_w: ebml::Serializer, mt: class_mutability) {\n+fn encode_mutability(ebml_w: Writer::Serializer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n         let val = match mt {\n           class_immutable => 'a',\n@@ -122,7 +122,7 @@ fn encode_mutability(ebml_w: ebml::Serializer, mt: class_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::Serializer, path: &[ident],\n+fn add_to_index(ecx: @encode_ctxt, ebml_w: Writer::Serializer, path: &[ident],\n                 index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n@@ -133,7 +133,7 @@ fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::Serializer, path: &[ident],\n          pos: ebml_w.writer.tell()});\n }\n \n-fn encode_trait_ref(ebml_w: ebml::Serializer, ecx: @encode_ctxt,\n+fn encode_trait_ref(ebml_w: Writer::Serializer, ecx: @encode_ctxt,\n                     t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n@@ -142,15 +142,15 @@ fn encode_trait_ref(ebml_w: ebml::Serializer, ecx: @encode_ctxt,\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: ebml::Serializer, c: char) {\n+fn encode_family(ebml_w: Writer::Serializer, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: ebml::Serializer, ecx: @encode_ctxt,\n+fn encode_ty_type_param_bounds(ebml_w: Writer::Serializer, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n@@ -164,21 +164,21 @@ fn encode_ty_type_param_bounds(ebml_w: ebml::Serializer, ecx: @encode_ctxt,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: ebml::Serializer, ecx: @encode_ctxt,\n+fn encode_type_param_bounds(ebml_w: Writer::Serializer, ecx: @encode_ctxt,\n                             params: ~[ty_param]) {\n     let ty_param_bounds =\n         @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n \n-fn encode_variant_id(ebml_w: ebml::Serializer, vid: def_id) {\n+fn encode_variant_id(ebml_w: Writer::Serializer, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-fn write_type(ecx: @encode_ctxt, ebml_w: ebml::Serializer, typ: ty::t) {\n+fn write_type(ecx: @encode_ctxt, ebml_w: Writer::Serializer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n           ds: def_to_str,\n@@ -188,7 +188,7 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::Serializer, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn write_vstore(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                 vstore: ty::vstore) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n@@ -199,13 +199,13 @@ fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::Serializer, typ: ty::t) {\n+fn encode_type(ecx: @encode_ctxt, ebml_w: Writer::Serializer, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::Serializer, id: node_id) {\n+fn encode_symbol(ecx: @encode_ctxt, ebml_w: Writer::Serializer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n       Some(x) => x,\n@@ -218,27 +218,27 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::Serializer, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_discriminant(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val,10u)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: ebml::Serializer, id: def_id) {\n+fn encode_parent_item(ebml_w: Writer::Serializer, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                             id: node_id, variants: ~[variant],\n                             path: ast_map::path, index: @mut ~[entry<int>],\n                             ty_params: ~[ty_param]) {\n@@ -275,9 +275,9 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     }\n }\n \n-fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_path(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                path: ast_map::path, name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -296,8 +296,9 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::Serializer, md: _mod,\n-                       id: node_id, path: ast_map::path, name: ident) {\n+fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n+                       md: _mod, id: node_id, path: ast_map::path,\n+                       name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n@@ -354,15 +355,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::Serializer, md: _mod,\n     ebml_w.end_tag();\n }\n \n-fn encode_visibility(ebml_w: ebml::Serializer, visibility: visibility) {\n+fn encode_visibility(ebml_w: Writer::Serializer, visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n         private => 'j',\n         inherited => 'N'\n     });\n }\n \n-fn encode_self_type(ebml_w: ebml::Serializer, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: Writer::Serializer, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -394,14 +395,14 @@ fn encode_self_type(ebml_w: ebml::Serializer, self_type: ast::self_ty_) {\n     ebml_w.end_tag();\n }\n \n-fn encode_method_sort(ebml_w: ebml::Serializer, sort: char) {\n+fn encode_method_sort(ebml_w: Writer::Serializer, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                          id: node_id, path: ast_map::path,\n                          class_tps: ~[ty_param],\n                          fields: ~[@struct_field],\n@@ -457,7 +458,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                         id: node_id, ident: ident, path: ast_map::path,\n                         item: Option<inlined_item>, tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n@@ -482,7 +483,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n@@ -537,7 +538,7 @@ fn should_inline(attrs: ~[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                         item: @item, index: @mut ~[entry<int>],\n                         path: ast_map::path) {\n \n@@ -550,7 +551,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n-    fn add_to_index_(item: @item, ebml_w: ebml::Serializer,\n+    fn add_to_index_(item: @item, ebml_w: Writer::Serializer,\n                      index: @mut ~[entry<int>]) {\n         index.push({val: item.id, pos: ebml_w.writer.tell()});\n     }\n@@ -835,7 +836,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path, abi: foreign_abi) {\n@@ -868,7 +869,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                          crate: @crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n@@ -923,7 +924,7 @@ fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: ebml::Serializer, buckets: ~[@~[entry<T>]],\n+fn encode_index<T>(ebml_w: Writer::Serializer, buckets: ~[@~[entry<T>]],\n                    write_fn: fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n@@ -958,7 +959,7 @@ fn write_int(writer: io::Writer, &&n: int) {\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: ebml::Serializer, mi: meta_item) {\n+fn encode_meta_item(ebml_w: Writer::Serializer, mi: meta_item) {\n     match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -995,7 +996,7 @@ fn encode_meta_item(ebml_w: ebml::Serializer, mi: meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: ebml::Serializer, attrs: ~[attribute]) {\n+fn encode_attributes(ebml_w: Writer::Serializer, attrs: ~[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1056,7 +1057,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                      cstore: cstore::CStore) {\n \n     fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::CStore)\n@@ -1102,7 +1103,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n+fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1117,7 +1118,7 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: ebml::Serializer, hash: ~str) {\n+fn encode_hash(ebml_w: Writer::Serializer, hash: ~str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1155,7 +1156,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n         type_abbrevs: ty::new_ty_hash()\n      });\n \n-    let ebml_w = ebml::Serializer(wr as io::Writer);\n+    let ebml_w = Writer::Serializer(wr as io::Writer);\n \n     encode_hash(ebml_w, ecx.link_meta.extras_hash);\n "}, {"sha": "64aaef99ef6b1646baed5fc29cac88d467a15999", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ec0c029a7ed9ac34bec716193e51b15d29965b0e", "patch": "@@ -8,7 +8,10 @@ use syntax::ast_map;\n use syntax::ast_util;\n use syntax::codemap::span;\n use std::ebml;\n-use std::ebml::{Serializer, get_doc};\n+use Writer = std::ebml::Writer;\n+use Reader = std::ebml::Reader;\n+use Reader::get_doc;\n+use Writer::Serializer;\n use std::map::HashMap;\n use std::serialization;\n use std::serialization::{Serializable,\n@@ -73,7 +76,7 @@ trait tr {\n // Top-level methods.\n \n fn encode_inlined_item(ecx: @e::encode_ctxt,\n-                       ebml_w: ebml::Serializer,\n+                       ebml_w: Writer::Serializer,\n                        path: ast_map::path,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n@@ -106,7 +109,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n       Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n-        let ast_dsr = &ebml::Deserializer(ast_doc);\n+        let ast_dsr = &Reader::Deserializer(ast_doc);\n         let from_id_range = deserialize(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = extended_decode_ctxt_(@{dcx: dcx,\n@@ -217,7 +220,7 @@ impl<D: serialization::Deserializer> D: def_id_deserializer_helpers {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: ebml::Serializer, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: Writer::Serializer, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         item.serialize(&ebml_w)\n     }\n@@ -272,7 +275,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n \n fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = &ebml::Deserializer(chi_doc);\n+    let d = &Reader::Deserializer(chi_doc);\n     deserialize(d)\n }\n \n@@ -312,12 +315,12 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: ebml::Serializer, def: ast::def) {\n+fn encode_def(ebml_w: Writer::Serializer, def: ast::def) {\n     def.serialize(&ebml_w)\n }\n \n fn decode_def(xcx: extended_decode_ctxt, doc: ebml::Doc) -> ast::def {\n-    let dsr = &ebml::Deserializer(doc);\n+    let dsr = &Reader::Deserializer(doc);\n     let def: ast::def = deserialize(dsr);\n     def.tr(xcx)\n }\n@@ -405,15 +408,15 @@ impl ty::bound_region: tr {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: ebml::Serializer, fv: @freevar_entry) {\n+fn encode_freevar_entry(ebml_w: Writer::Serializer, fv: @freevar_entry) {\n     (*fv).serialize(&ebml_w)\n }\n \n trait ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry;\n }\n \n-impl ebml::Deserializer: ebml_deserializer_helper {\n+impl Reader::Deserializer: ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n         let fv: freevar_entry = deserialize(&self);\n         fv.tr(xcx)\n@@ -434,7 +437,7 @@ trait read_method_map_entry_helper {\n }\n \n fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n-                              ebml_w: ebml::Serializer,\n+                              ebml_w: Writer::Serializer,\n                               mme: method_map_entry) {\n     do ebml_w.emit_rec {\n         do ebml_w.emit_field(~\"self_arg\", 0u) {\n@@ -446,7 +449,7 @@ fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n     }\n }\n \n-impl ebml::Deserializer: read_method_map_entry_helper {\n+impl Reader::Deserializer: read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n         do self.read_rec {\n             {self_arg:\n@@ -485,7 +488,7 @@ impl method_origin: tr {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::encode_ctxt,\n-                     ebml_w: ebml::Serializer,\n+                     ebml_w: Writer::Serializer,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic serialization of\n     // ty::t doesn't work, and there is no way (atm) to have\n@@ -497,7 +500,7 @@ fn encode_vtable_res(ecx: @e::encode_ctxt,\n }\n \n fn encode_vtable_origin(ecx: @e::encode_ctxt,\n-                      ebml_w: ebml::Serializer,\n+                      ebml_w: Writer::Serializer,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n         match vtable_origin {\n@@ -544,7 +547,7 @@ trait vtable_deserialization_helpers {\n     fn read_vtable_origin(xcx: extended_decode_ctxt) -> typeck::vtable_origin;\n }\n \n-impl ebml::Deserializer: vtable_deserialization_helpers {\n+impl Reader::Deserializer: vtable_deserialization_helpers {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n@@ -621,7 +624,7 @@ trait ebml_writer_helpers {\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n }\n \n-impl ebml::Serializer: ebml_writer_helpers {\n+impl Writer::Serializer: ebml_writer_helpers {\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n         do self.emit_opaque {\n             e::write_type(ecx, self, ty)\n@@ -674,7 +677,7 @@ trait write_tag_and_id {\n     fn id(id: ast::node_id);\n }\n \n-impl ebml::Serializer: write_tag_and_id {\n+impl Writer::Serializer: write_tag_and_id {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n@@ -686,7 +689,7 @@ impl ebml::Serializer: write_tag_and_id {\n \n fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: ebml::Serializer,\n+                             ebml_w: Writer::Serializer,\n                              ii: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n         ast_util::visit_ids_for_inlined_item(\n@@ -702,7 +705,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n \n fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: ebml::Serializer,\n+                             ebml_w: Writer::Serializer,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n@@ -835,9 +838,9 @@ trait doc_decoder_helpers {\n }\n \n impl ebml::Doc: doc_decoder_helpers {\n-    fn as_int() -> int { ebml::doc_as_u64(self) as int }\n+    fn as_int() -> int { Reader::doc_as_u64(self) as int }\n     fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc> {\n-        ebml::maybe_get_doc(self, tag as uint)\n+        Reader::maybe_get_doc(self, tag as uint)\n     }\n }\n \n@@ -850,7 +853,7 @@ trait ebml_deserializer_decoder_helpers {\n                                 -> ty::ty_param_bounds_and_ty;\n }\n \n-impl ebml::Deserializer: ebml_deserializer_decoder_helpers {\n+impl Reader::Deserializer: ebml_deserializer_decoder_helpers {\n \n     fn read_arg(xcx: extended_decode_ctxt) -> ty::arg {\n         do self.read_opaque |doc| {\n@@ -908,7 +911,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table as uint];\n-    for ebml::docs(tbl_doc) |tag, entry_doc| {\n+    for Reader::docs(tbl_doc) |tag, entry_doc| {\n         let id0 = entry_doc[c::tag_table_id as uint].as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -922,7 +925,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.tcx.legacy_boxed_traits.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val as uint];\n-            let val_dsr = &ebml::Deserializer(val_doc);\n+            let val_dsr = &Reader::Deserializer(val_doc);\n             if tag == (c::tag_table_def as uint) {\n                 let def = decode_def(xcx, val_doc);\n                 dcx.tcx.def_map.insert(id, def);\n@@ -975,7 +978,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: ebml::Serializer, item: @ast::item) {\n+fn encode_item_ast(ebml_w: Writer::Serializer, item: @ast::item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         (*item).serialize(&ebml_w)\n     }\n@@ -984,7 +987,7 @@ fn encode_item_ast(ebml_w: ebml::Serializer, item: @ast::item) {\n #[cfg(test)]\n fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = &ebml::Deserializer(chi_doc);\n+    let d = &Reader::Deserializer(chi_doc);\n     @deserialize(d)\n }\n \n@@ -1011,10 +1014,10 @@ fn mk_ctxt() -> fake_ext_ctxt {\n #[cfg(test)]\n fn roundtrip(in_item: @ast::item) {\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = ebml::Serializer(wr);\n+        let ebml_w = Writer::Serializer(wr);\n         encode_item_ast(ebml_w, in_item);\n     };\n-    let ebml_doc = ebml::Doc(@bytes);\n+    let ebml_doc = Reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n \n     let exp_str = do io::with_str_writer |w| {"}, {"sha": "2d413b404c545f17fbcc2cb03adba775fac3d9ed", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 474, "deletions": 466, "changes": 940, "blob_url": "https://github.com/rust-lang/rust/blob/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=ec0c029a7ed9ac34bec716193e51b15d29965b0e", "patch": "@@ -5,6 +5,7 @@ use serialization;\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n \n+// Common data structures\n struct EbmlTag {\n     id: uint,\n     size: uint,\n@@ -16,10 +17,6 @@ struct EbmlState {\n     data_pos: uint,\n }\n \n-// FIXME (#2739): When we have module renaming, make \"reader\" and \"writer\"\n-// separate modules within this file.\n-\n-// ebml reading\n struct Doc {\n     data: @~[u8],\n     start: uint,\n@@ -31,592 +28,603 @@ struct TaggedDoc {\n     doc: Doc,\n }\n \n-impl Doc: ops::Index<uint,Doc> {\n-    pure fn index(tag: uint) -> Doc {\n-        unsafe {\n-            get_doc(self, tag)\n-        }\n-    }\n-}\n+enum EbmlSerializerTag {\n+    EsUint, EsU64, EsU32, EsU16, EsU8,\n+    EsInt, EsI64, EsI32, EsI16, EsI8,\n+    EsBool,\n+    EsStr,\n+    EsF64, EsF32, EsFloat,\n+    EsEnum, EsEnumVid, EsEnumBody,\n+    EsVec, EsVecLen, EsVecElt,\n \n-fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n-    let a = data[start];\n-    if a & 0x80u8 != 0u8 {\n-        return {val: (a & 0x7fu8) as uint, next: start + 1u};\n-    }\n-    if a & 0x40u8 != 0u8 {\n-        return {val: ((a & 0x3fu8) as uint) << 8u |\n-                 (data[start + 1u] as uint),\n-             next: start + 2u};\n-    } else if a & 0x20u8 != 0u8 {\n-        return {val: ((a & 0x1fu8) as uint) << 16u |\n-                 (data[start + 1u] as uint) << 8u |\n-                 (data[start + 2u] as uint),\n-             next: start + 3u};\n-    } else if a & 0x10u8 != 0u8 {\n-        return {val: ((a & 0x0fu8) as uint) << 24u |\n-                 (data[start + 1u] as uint) << 16u |\n-                 (data[start + 2u] as uint) << 8u |\n-                 (data[start + 3u] as uint),\n-             next: start + 4u};\n-    } else { error!(\"vint too big\"); fail; }\n-}\n+    EsOpaque,\n \n-pub fn Doc(data: @~[u8]) -> Doc {\n-    Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n+    EsLabel // Used only when debugging\n }\n+// --------------------------------------\n+\n+pub mod Reader {\n+\n+    // ebml reading\n \n-pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n-    let elt_tag = vuint_at(*data, start);\n-    let elt_size = vuint_at(*data, elt_tag.next);\n-    let end = elt_size.next + elt_size.val;\n-    TaggedDoc {\n-        tag: elt_tag.val,\n-        doc: Doc { data: data, start: elt_size.next, end: end }\n+    impl Doc: ops::Index<uint,Doc> {\n+        pure fn index(tag: uint) -> Doc {\n+            unsafe {\n+                get_doc(self, tag)\n+            }\n+        }\n     }\n-}\n \n-pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n-            return Some(Doc { data: d.data, start: elt_size.next, end: pos });\n+    fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n+        let a = data[start];\n+        if a & 0x80u8 != 0u8 {\n+            return {val: (a & 0x7fu8) as uint, next: start + 1u};\n+        }\n+        if a & 0x40u8 != 0u8 {\n+            return {val: ((a & 0x3fu8) as uint) << 8u |\n+                        (data[start + 1u] as uint),\n+                    next: start + 2u};\n+        } else if a & 0x20u8 != 0u8 {\n+            return {val: ((a & 0x1fu8) as uint) << 16u |\n+                        (data[start + 1u] as uint) << 8u |\n+                        (data[start + 2u] as uint),\n+                    next: start + 3u};\n+        } else if a & 0x10u8 != 0u8 {\n+            return {val: ((a & 0x0fu8) as uint) << 24u |\n+                        (data[start + 1u] as uint) << 16u |\n+                        (data[start + 2u] as uint) << 8u |\n+                        (data[start + 3u] as uint),\n+                    next: start + 4u};\n+        } else { error!(\"vint too big\"); fail; }\n+    }\n+\n+    pub fn Doc(data: @~[u8]) -> Doc {\n+        Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n+    }\n+\n+    pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n+        let elt_tag = vuint_at(*data, start);\n+        let elt_size = vuint_at(*data, elt_tag.next);\n+        let end = elt_size.next + elt_size.val;\n+        TaggedDoc {\n+            tag: elt_tag.val,\n+            doc: Doc { data: data, start: elt_size.next, end: end }\n         }\n     }\n-    None\n-}\n \n-pub fn get_doc(d: Doc, tg: uint) -> Doc {\n-    match maybe_get_doc(d, tg) {\n-      Some(d) => d,\n-      None => {\n-        error!(\"failed to find block with tag %u\", tg);\n-        fail;\n-      }\n+    pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            if elt_tag.val == tg {\n+                return Some(Doc { data: d.data, start: elt_size.next, end: pos });\n+            }\n+        }\n+        None\n     }\n-}\n \n-pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n-        if !it(elt_tag.val, doc) {\n-            break;\n+    pub fn get_doc(d: Doc, tg: uint) -> Doc {\n+        match maybe_get_doc(d, tg) {\n+            Some(d) => d,\n+            None => {\n+                error!(\"failed to find block with tag %u\", tg);\n+                fail;\n+            }\n         }\n     }\n-}\n \n-pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n+    pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n             let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n-            if !it(doc) {\n+            if !it(elt_tag.val, doc) {\n                 break;\n             }\n         }\n     }\n-}\n-\n-pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n-\n-pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n-    f(vec::view(*d.data, d.start, d.end))\n-}\n-\n-pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n-\n-pub fn doc_as_u8(d: Doc) -> u8 {\n-    assert d.end == d.start + 1u;\n-    (*d.data)[d.start]\n-}\n-\n-pub fn doc_as_u16(d: Doc) -> u16 {\n-    assert d.end == d.start + 2u;\n-    io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n-}\n-\n-pub fn doc_as_u32(d: Doc) -> u32 {\n-    assert d.end == d.start + 4u;\n-    io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n-}\n \n-pub fn doc_as_u64(d: Doc) -> u64 {\n-    assert d.end == d.start + 8u;\n-    io::u64_from_be_bytes(*d.data, d.start, 8u)\n-}\n-\n-pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n+    pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            if elt_tag.val == tg {\n+                let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+                if !it(doc) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n \n-// ebml writing\n-struct Serializer {\n-    writer: io::Writer,\n-    priv mut size_positions: ~[uint],\n-}\n+    pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n-fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n-    match size {\n-      1u => w.write(&[0x80u8 | (n as u8)]),\n-      2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n-      3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n-                      n as u8]),\n-      4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n-                      (n >> 8_u) as u8, n as u8]),\n-      _ => fail fmt!(\"vint to write too big: %?\", n)\n-    };\n-}\n+    pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n+        f(vec::view(*d.data, d.start, d.end))\n+    }\n \n-fn write_vuint(w: io::Writer, n: uint) {\n-    if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n-    if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n-    if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n-    if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-    fail fmt!(\"vint to write too big: %?\", n);\n-}\n+    pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n-pub fn Serializer(w: io::Writer) -> Serializer {\n-    let size_positions: ~[uint] = ~[];\n-    Serializer { writer: w, mut size_positions: size_positions }\n-}\n+    pub fn doc_as_u8(d: Doc) -> u8 {\n+        assert d.end == d.start + 1u;\n+        (*d.data)[d.start]\n+    }\n \n-// FIXME (#2741): Provide a function to write the standard ebml header.\n-impl Serializer {\n-    fn start_tag(tag_id: uint) {\n-        debug!(\"Start tag %u\", tag_id);\n+    pub fn doc_as_u16(d: Doc) -> u16 {\n+        assert d.end == d.start + 2u;\n+        io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n+    }\n \n-        // Write the enum ID:\n-        write_vuint(self.writer, tag_id);\n+    pub fn doc_as_u32(d: Doc) -> u32 {\n+        assert d.end == d.start + 4u;\n+        io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n+    }\n \n-        // Write a placeholder four-byte size.\n-        self.size_positions.push(self.writer.tell());\n-        let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-        self.writer.write(zeroes);\n+    pub fn doc_as_u64(d: Doc) -> u64 {\n+        assert d.end == d.start + 8u;\n+        io::u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n-    fn end_tag() {\n-        let last_size_pos = self.size_positions.pop();\n-        let cur_pos = self.writer.tell();\n-        self.writer.seek(last_size_pos as int, io::SeekSet);\n-        let size = (cur_pos - last_size_pos - 4u);\n-        write_sized_vuint(self.writer, size, 4u);\n-        self.writer.seek(cur_pos as int, io::SeekSet);\n+    pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n+    pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n+    pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n+    pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n-        debug!(\"End tag (size = %u)\", size);\n-    }\n \n-    fn wr_tag(tag_id: uint, blk: fn()) {\n-        self.start_tag(tag_id);\n-        blk();\n-        self.end_tag();\n+    struct Deserializer {\n+        priv mut parent: Doc,\n+        priv mut pos: uint,\n     }\n \n-    fn wr_tagged_bytes(tag_id: uint, b: &[u8]) {\n-        write_vuint(self.writer, tag_id);\n-        write_vuint(self.writer, vec::len(b));\n-        self.writer.write(b);\n+    pub fn Deserializer(d: Doc) -> Deserializer {\n+        Deserializer { mut parent: d, mut pos: d.start }\n     }\n \n-    fn wr_tagged_u64(tag_id: uint, v: u64) {\n-        do io::u64_to_be_bytes(v, 8u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n+    priv impl Deserializer {\n+        fn _check_label(lbl: &str) {\n+            if self.pos < self.parent.end {\n+                let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                    doc_at(self.parent.data, self.pos);\n+\n+                if r_tag == (EsLabel as uint) {\n+                    self.pos = r_doc.end;\n+                    let str = doc_as_str(r_doc);\n+                    if lbl != str {\n+                        fail fmt!(\"Expected label %s but found %s\", lbl, str);\n+                    }\n+                }\n+            }\n         }\n-    }\n \n-    fn wr_tagged_u32(tag_id: uint, v: u32) {\n-        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n+        fn next_doc(exp_tag: EbmlSerializerTag) -> Doc {\n+            debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n+            if self.pos >= self.parent.end {\n+                fail ~\"no more documents in current node!\";\n+            }\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                doc_at(self.parent.data, self.pos);\n+            debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+                   copy self.parent.start, copy self.parent.end,\n+                   copy self.pos, r_tag, r_doc.start, r_doc.end);\n+            if r_tag != (exp_tag as uint) {\n+                fail fmt!(\"expected EBML doc with tag %? but found tag %?\",\n+                          exp_tag, r_tag);\n+            }\n+            if r_doc.end > self.parent.end {\n+                fail fmt!(\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n+                          r_doc.end, self.parent.end);\n+            }\n+            self.pos = r_doc.end;\n+            r_doc\n         }\n-    }\n \n-    fn wr_tagged_u16(tag_id: uint, v: u16) {\n-        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n+        fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n+            let old_parent = self.parent;\n+            let old_pos = self.pos;\n+            self.parent = d;\n+            self.pos = d.start;\n+            let r = f();\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            move r\n         }\n-    }\n \n-    fn wr_tagged_u8(tag_id: uint, v: u8) {\n-        self.wr_tagged_bytes(tag_id, &[v]);\n+        fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n+            let r = doc_as_u32(self.next_doc(exp_tag));\n+            debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n+            r as uint\n+        }\n     }\n \n-    fn wr_tagged_i64(tag_id: uint, v: i64) {\n-        do io::u64_to_be_bytes(v as u64, 8u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n+    impl Deserializer {\n+        fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n+            do self.push_doc(self.next_doc(EsOpaque)) {\n+                op(copy self.parent)\n+            }\n         }\n     }\n \n-    fn wr_tagged_i32(tag_id: uint, v: i32) {\n-        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n+    impl Deserializer: serialization::Deserializer {\n+        fn read_nil(&self) -> () { () }\n+\n+        fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n+        fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n+        fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n+        fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n+        fn read_uint(&self) -> uint {\n+            let v = doc_as_u64(self.next_doc(EsUint));\n+            if v > (core::uint::max_value as u64) {\n+                fail fmt!(\"uint %? too large for this architecture\", v);\n+            }\n+            v as uint\n         }\n-    }\n \n-    fn wr_tagged_i16(tag_id: uint, v: i16) {\n-        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n+        fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n+        fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n+        fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n+        fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n+        fn read_int(&self) -> int {\n+            let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n+            if v > (int::max_value as i64) || v < (int::min_value as i64) {\n+                fail fmt!(\"int %? out of range for this architecture\", v);\n+            }\n+            v as int\n         }\n-    }\n \n-    fn wr_tagged_i8(tag_id: uint, v: i8) {\n-        self.wr_tagged_bytes(tag_id, &[v as u8]);\n-    }\n+        fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool)) as bool }\n \n-    fn wr_tagged_str(tag_id: uint, v: &str) {\n-        str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n-    }\n+        fn read_f64(&self) -> f64 { fail ~\"read_f64()\"; }\n+        fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n+        fn read_float(&self) -> float { fail ~\"read_float()\"; }\n \n-    fn wr_bytes(b: &[u8]) {\n-        debug!(\"Write %u bytes\", vec::len(b));\n-        self.writer.write(b);\n-    }\n+        fn read_char(&self) -> char { fail ~\"read_char()\"; }\n \n-    fn wr_str(s: &str) {\n-        debug!(\"Write str: %?\", s);\n-        self.writer.write(str::to_bytes(s));\n-    }\n-}\n+        fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+        fn read_managed_str(&self) -> @str { fail ~\"read_managed_str()\"; }\n \n-// FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n-// efficiently encode sizes; this is a fixed point iteration\n+        // Compound types:\n+        fn read_owned<T>(&self, f: fn() -> T) -> T {\n+            debug!(\"read_owned()\");\n+            f()\n+        }\n \n-// Set to true to generate more debugging in EBML serialization.\n-// Totally lame approach.\n-const debug: bool = false;\n+        fn read_managed<T>(&self, f: fn() -> T) -> T {\n+            debug!(\"read_managed()\");\n+            f()\n+        }\n \n-enum EbmlSerializerTag {\n-    EsUint, EsU64, EsU32, EsU16, EsU8,\n-    EsInt, EsI64, EsI32, EsI16, EsI8,\n-    EsBool,\n-    EsStr,\n-    EsF64, EsF32, EsFloat,\n-    EsEnum, EsEnumVid, EsEnumBody,\n-    EsVec, EsVecLen, EsVecElt,\n+        fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n+            debug!(\"read_enum(%s)\", name);\n+            self._check_label(name);\n+            self.push_doc(self.next_doc(EsEnum), f)\n+        }\n \n-    EsOpaque,\n+        fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n+            debug!(\"read_enum_variant()\");\n+            let idx = self._next_uint(EsEnumVid);\n+            debug!(\"  idx=%u\", idx);\n+            do self.push_doc(self.next_doc(EsEnumBody)) {\n+                f(idx)\n+            }\n+        }\n \n-    EsLabel // Used only when debugging\n-}\n+        fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n+            debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+            f()\n+        }\n \n-priv impl Serializer {\n-    // used internally to emit things like the vector length and so on\n-    fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n-        assert v <= 0xFFFF_FFFF_u;\n-        self.wr_tagged_u32(t as uint, v as u32);\n-    }\n+        fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+            debug!(\"read_owned_vec()\");\n+            do self.push_doc(self.next_doc(EsVec)) {\n+                let len = self._next_uint(EsVecLen);\n+                debug!(\"  len=%u\", len);\n+                f(len)\n+            }\n+        }\n \n-    fn _emit_label(label: &str) {\n-        // There are various strings that we have access to, such as\n-        // the name of a record field, which do not actually appear in\n-        // the serialized EBML (normally).  This is just for\n-        // efficiency.  When debugging, though, we can emit such\n-        // labels and then they will be checked by deserializer to\n-        // try and check failures more quickly.\n-        if debug { self.wr_tagged_str(EsLabel as uint, label) }\n-    }\n-}\n+        fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+            debug!(\"read_managed_vec()\");\n+            do self.push_doc(self.next_doc(EsVec)) {\n+                let len = self._next_uint(EsVecLen);\n+                debug!(\"  len=%u\", len);\n+                f(len)\n+            }\n+        }\n+\n+        fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+            debug!(\"read_vec_elt(idx=%u)\", idx);\n+            self.push_doc(self.next_doc(EsVecElt), f)\n+        }\n \n-impl Serializer {\n-    fn emit_opaque(&self, f: fn()) {\n-        do self.wr_tag(EsOpaque as uint) {\n+        fn read_rec<T>(&self, f: fn() -> T) -> T {\n+            debug!(\"read_rec()\");\n             f()\n         }\n-    }\n-}\n \n-impl Serializer: serialization::Serializer {\n-    fn emit_nil(&self) {}\n+        fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T {\n+            debug!(\"read_struct(name=%s)\", name);\n+            f()\n+        }\n \n-    fn emit_uint(&self, v: uint) {\n-        self.wr_tagged_u64(EsUint as uint, v as u64);\n-    }\n-    fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n-    fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n-    fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n-    fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n+        fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+            debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n+            self._check_label(name);\n+            f()\n+        }\n \n-    fn emit_int(&self, v: int) {\n-        self.wr_tagged_i64(EsInt as uint, v as i64);\n-    }\n-    fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n-    fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n-    fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n-    fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n+        fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+            debug!(\"read_tup(len=%u)\", len);\n+            f()\n+        }\n \n-    fn emit_bool(&self, v: bool) {\n-        self.wr_tagged_u8(EsBool as uint, v as u8)\n+        fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+            debug!(\"read_tup_elt(idx=%u)\", idx);\n+            f()\n+        }\n     }\n \n-    // FIXME (#2742): implement these\n-    fn emit_f64(&self, _v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n-    fn emit_f32(&self, _v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n-    fn emit_float(&self, _v: float) {\n-        fail ~\"Unimplemented: serializing a float\";\n-    }\n+}\n \n-    fn emit_char(&self, _v: char) {\n-        fail ~\"Unimplemented: serializing a char\";\n+pub mod Writer {\n+\n+    // ebml writing\n+    struct Serializer {\n+        writer: io::Writer,\n+        priv mut size_positions: ~[uint],\n     }\n \n-    fn emit_borrowed_str(&self, v: &str) {\n-        self.wr_tagged_str(EsStr as uint, v)\n+    fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n+        match size {\n+            1u => w.write(&[0x80u8 | (n as u8)]),\n+            2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n+            3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+                            n as u8]),\n+            4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+                            (n >> 8_u) as u8, n as u8]),\n+            _ => fail fmt!(\"vint to write too big: %?\", n)\n+        };\n     }\n \n-    fn emit_owned_str(&self, v: &str) {\n-        self.emit_borrowed_str(v)\n+    fn write_vuint(w: io::Writer, n: uint) {\n+        if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n+        if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n+        if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n+        if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n+        fail fmt!(\"vint to write too big: %?\", n);\n     }\n \n-    fn emit_managed_str(&self, v: &str) {\n-        self.emit_borrowed_str(v)\n+    pub fn Serializer(w: io::Writer) -> Serializer {\n+        let size_positions: ~[uint] = ~[];\n+        Serializer { writer: w, mut size_positions: size_positions }\n     }\n \n-    fn emit_borrowed(&self, f: fn()) { f() }\n-    fn emit_owned(&self, f: fn()) { f() }\n-    fn emit_managed(&self, f: fn()) { f() }\n+    // FIXME (#2741): Provide a function to write the standard ebml header.\n+    impl Serializer {\n+        fn start_tag(tag_id: uint) {\n+            debug!(\"Start tag %u\", tag_id);\n \n-    fn emit_enum(&self, name: &str, f: fn()) {\n-        self._emit_label(name);\n-        self.wr_tag(EsEnum as uint, f)\n-    }\n-    fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n-                         f: fn()) {\n-        self._emit_tagged_uint(EsEnumVid, v_id);\n-        self.wr_tag(EsEnumBody as uint, f)\n-    }\n-    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n+            // Write the enum ID:\n+            write_vuint(self.writer, tag_id);\n \n-    fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n-        do self.wr_tag(EsVec as uint) {\n-            self._emit_tagged_uint(EsVecLen, len);\n-            f()\n+            // Write a placeholder four-byte size.\n+            self.size_positions.push(self.writer.tell());\n+            let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n+            self.writer.write(zeroes);\n         }\n-    }\n \n-    fn emit_owned_vec(&self, len: uint, f: fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n+        fn end_tag() {\n+            let last_size_pos = self.size_positions.pop();\n+            let cur_pos = self.writer.tell();\n+            self.writer.seek(last_size_pos as int, io::SeekSet);\n+            let size = (cur_pos - last_size_pos - 4u);\n+            write_sized_vuint(self.writer, size, 4u);\n+            self.writer.seek(cur_pos as int, io::SeekSet);\n \n-    fn emit_managed_vec(&self, len: uint, f: fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n+            debug!(\"End tag (size = %u)\", size);\n+        }\n \n-    fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n-        self.wr_tag(EsVecElt as uint, f)\n-    }\n+        fn wr_tag(tag_id: uint, blk: fn()) {\n+            self.start_tag(tag_id);\n+            blk();\n+            self.end_tag();\n+        }\n \n-    fn emit_rec(&self, f: fn()) { f() }\n-    fn emit_struct(&self, _name: &str, f: fn()) { f() }\n-    fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n-        self._emit_label(name);\n-        f()\n-    }\n+        fn wr_tagged_bytes(tag_id: uint, b: &[u8]) {\n+            write_vuint(self.writer, tag_id);\n+            write_vuint(self.writer, vec::len(b));\n+            self.writer.write(b);\n+        }\n \n-    fn emit_tup(&self, _len: uint, f: fn()) { f() }\n-    fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n-}\n+        fn wr_tagged_u64(tag_id: uint, v: u64) {\n+            do io::u64_to_be_bytes(v, 8u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n \n-struct Deserializer {\n-    priv mut parent: Doc,\n-    priv mut pos: uint,\n-}\n+        fn wr_tagged_u32(tag_id: uint, v: u32) {\n+            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n \n-pub fn Deserializer(d: Doc) -> Deserializer {\n-    Deserializer { mut parent: d, mut pos: d.start }\n-}\n+        fn wr_tagged_u16(tag_id: uint, v: u16) {\n+            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n \n-priv impl Deserializer {\n-    fn _check_label(lbl: &str) {\n-        if self.pos < self.parent.end {\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                doc_at(self.parent.data, self.pos);\n+        fn wr_tagged_u8(tag_id: uint, v: u8) {\n+            self.wr_tagged_bytes(tag_id, &[v]);\n+        }\n \n-            if r_tag == (EsLabel as uint) {\n-                self.pos = r_doc.end;\n-                let str = doc_as_str(r_doc);\n-                if lbl != str {\n-                    fail fmt!(\"Expected label %s but found %s\", lbl, str);\n-                }\n+        fn wr_tagged_i64(tag_id: uint, v: i64) {\n+            do io::u64_to_be_bytes(v as u64, 8u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n-    }\n \n-    fn next_doc(exp_tag: EbmlSerializerTag) -> Doc {\n-        debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n-        if self.pos >= self.parent.end {\n-            fail ~\"no more documents in current node!\";\n-        }\n-        let TaggedDoc { tag: r_tag, doc: r_doc } =\n-            doc_at(self.parent.data, self.pos);\n-        debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n-               copy self.parent.start, copy self.parent.end,\n-               copy self.pos, r_tag, r_doc.start, r_doc.end);\n-        if r_tag != (exp_tag as uint) {\n-            fail fmt!(\"expected EMBL doc with tag %? but found tag %?\",\n-                      exp_tag, r_tag);\n-        }\n-        if r_doc.end > self.parent.end {\n-            fail fmt!(\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n-                      r_doc.end, self.parent.end);\n-        }\n-        self.pos = r_doc.end;\n-        r_doc\n-    }\n+        fn wr_tagged_i32(tag_id: uint, v: i32) {\n+            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n \n-    fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n-        let old_parent = self.parent;\n-        let old_pos = self.pos;\n-        self.parent = d;\n-        self.pos = d.start;\n-        let r = f();\n-        self.parent = old_parent;\n-        self.pos = old_pos;\n-        move r\n-    }\n+        fn wr_tagged_i16(tag_id: uint, v: i16) {\n+            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            }\n+        }\n \n-    fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n-        let r = doc_as_u32(self.next_doc(exp_tag));\n-        debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n-        r as uint\n-    }\n-}\n+        fn wr_tagged_i8(tag_id: uint, v: i8) {\n+            self.wr_tagged_bytes(tag_id, &[v as u8]);\n+        }\n+\n+        fn wr_tagged_str(tag_id: uint, v: &str) {\n+            str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n+        }\n+\n+        fn wr_bytes(b: &[u8]) {\n+            debug!(\"Write %u bytes\", vec::len(b));\n+            self.writer.write(b);\n+        }\n \n-impl Deserializer {\n-    fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n-        do self.push_doc(self.next_doc(EsOpaque)) {\n-            op(copy self.parent)\n+        fn wr_str(s: &str) {\n+            debug!(\"Write str: %?\", s);\n+            self.writer.write(str::to_bytes(s));\n         }\n     }\n-}\n \n-impl Deserializer: serialization::Deserializer {\n-    fn read_nil(&self) -> () { () }\n+    // FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n+    // efficiently encode sizes; this is a fixed point iteration\n+\n+    // Set to true to generate more debugging in EBML serialization.\n+    // Totally lame approach.\n+    const debug: bool = false;\n+\n+    priv impl Serializer {\n+        // used internally to emit things like the vector length and so on\n+        fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n+            assert v <= 0xFFFF_FFFF_u;\n+            self.wr_tagged_u32(t as uint, v as u32);\n+        }\n \n-    fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n-    fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n-    fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n-    fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n-    fn read_uint(&self) -> uint {\n-        let v = doc_as_u64(self.next_doc(EsUint));\n-        if v > (core::uint::max_value as u64) {\n-            fail fmt!(\"uint %? too large for this architecture\", v);\n+        fn _emit_label(label: &str) {\n+            // There are various strings that we have access to, such as\n+            // the name of a record field, which do not actually appear in\n+            // the serialized EBML (normally).  This is just for\n+            // efficiency.  When debugging, though, we can emit such\n+            // labels and then they will be checked by deserializer to\n+            // try and check failures more quickly.\n+            if debug { self.wr_tagged_str(EsLabel as uint, label) }\n         }\n-        v as uint\n     }\n \n-    fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n-    fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n-    fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n-    fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n-    fn read_int(&self) -> int {\n-        let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n-        if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-            fail fmt!(\"int %? out of range for this architecture\", v);\n+    impl Serializer {\n+        fn emit_opaque(&self, f: fn()) {\n+            do self.wr_tag(EsOpaque as uint) {\n+                f()\n+            }\n         }\n-        v as int\n     }\n \n-    fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool)) as bool }\n+    impl Serializer: serialization::Serializer {\n+        fn emit_nil(&self) {}\n \n-    fn read_f64(&self) -> f64 { fail ~\"read_f64()\"; }\n-    fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n-    fn read_float(&self) -> float { fail ~\"read_float()\"; }\n+        fn emit_uint(&self, v: uint) {\n+            self.wr_tagged_u64(EsUint as uint, v as u64);\n+        }\n+        fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n+        fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n+        fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n+        fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n \n-    fn read_char(&self) -> char { fail ~\"read_char()\"; }\n+        fn emit_int(&self, v: int) {\n+            self.wr_tagged_i64(EsInt as uint, v as i64);\n+        }\n+        fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n+        fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n+        fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n+        fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n \n-    fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n-    fn read_managed_str(&self) -> @str { fail ~\"read_managed_str()\"; }\n+        fn emit_bool(&self, v: bool) {\n+            self.wr_tagged_u8(EsBool as uint, v as u8)\n+        }\n \n-    // Compound types:\n-    fn read_owned<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_owned()\");\n-        f()\n-    }\n+        // FIXME (#2742): implement these\n+        fn emit_f64(&self, _v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n+        fn emit_f32(&self, _v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n+        fn emit_float(&self, _v: float) {\n+            fail ~\"Unimplemented: serializing a float\";\n+        }\n \n-    fn read_managed<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_managed()\");\n-        f()\n-    }\n+        fn emit_char(&self, _v: char) {\n+            fail ~\"Unimplemented: serializing a char\";\n+        }\n \n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n-        debug!(\"read_enum(%s)\", name);\n-        self._check_label(name);\n-        self.push_doc(self.next_doc(EsEnum), f)\n-    }\n+        fn emit_borrowed_str(&self, v: &str) {\n+            self.wr_tagged_str(EsStr as uint, v)\n+        }\n \n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_enum_variant()\");\n-        let idx = self._next_uint(EsEnumVid);\n-        debug!(\"  idx=%u\", idx);\n-        do self.push_doc(self.next_doc(EsEnumBody)) {\n-            f(idx)\n+        fn emit_owned_str(&self, v: &str) {\n+            self.emit_borrowed_str(v)\n         }\n-    }\n \n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        f()\n-    }\n+        fn emit_managed_str(&self, v: &str) {\n+            self.emit_borrowed_str(v)\n+        }\n+\n+        fn emit_borrowed(&self, f: fn()) { f() }\n+        fn emit_owned(&self, f: fn()) { f() }\n+        fn emit_managed(&self, f: fn()) { f() }\n \n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_owned_vec()\");\n-        do self.push_doc(self.next_doc(EsVec)) {\n-            let len = self._next_uint(EsVecLen);\n-            debug!(\"  len=%u\", len);\n-            f(len)\n+        fn emit_enum(&self, name: &str, f: fn()) {\n+            self._emit_label(name);\n+            self.wr_tag(EsEnum as uint, f)\n         }\n-    }\n+        fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n+                             f: fn()) {\n+            self._emit_tagged_uint(EsEnumVid, v_id);\n+            self.wr_tag(EsEnumBody as uint, f)\n+        }\n+        fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n \n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_managed_vec()\");\n-        do self.push_doc(self.next_doc(EsVec)) {\n-            let len = self._next_uint(EsVecLen);\n-            debug!(\"  len=%u\", len);\n-            f(len)\n+        fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n+            do self.wr_tag(EsVec as uint) {\n+                self._emit_tagged_uint(EsVecLen, len);\n+                f()\n+            }\n         }\n-    }\n \n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_vec_elt(idx=%u)\", idx);\n-        self.push_doc(self.next_doc(EsVecElt), f)\n-    }\n+        fn emit_owned_vec(&self, len: uint, f: fn()) {\n+            self.emit_borrowed_vec(len, f)\n+        }\n \n-    fn read_rec<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_rec()\");\n-        f()\n-    }\n+        fn emit_managed_vec(&self, len: uint, f: fn()) {\n+            self.emit_borrowed_vec(len, f)\n+        }\n \n-    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T {\n-        debug!(\"read_struct(name=%s)\", name);\n-        f()\n-    }\n+        fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n+            self.wr_tag(EsVecElt as uint, f)\n+        }\n \n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n-        self._check_label(name);\n-        f()\n-    }\n+        fn emit_rec(&self, f: fn()) { f() }\n+        fn emit_struct(&self, _name: &str, f: fn()) { f() }\n+        fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n+            self._emit_label(name);\n+            f()\n+        }\n \n-    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup(len=%u)\", len);\n-        f()\n+        fn emit_tup(&self, _len: uint, f: fn()) { f() }\n+        fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n     }\n \n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup_elt(idx=%u)\", idx);\n-        f()\n-    }\n }\n-\n // ___________________________________________________________________________\n // Testing\n \n@@ -627,11 +635,11 @@ mod tests {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == %?\", v);\n             let bytes = do io::with_bytes_writer |wr| {\n-                let ebml_w = Serializer(wr);\n+                let ebml_w = Writer::Serializer(wr);\n                 v.serialize(&ebml_w)\n             };\n-            let ebml_doc = Doc(@bytes);\n-            let deser = Deserializer(ebml_doc);\n+            let ebml_doc = Reader::Doc(@bytes);\n+            let deser = Reader::Deserializer(ebml_doc);\n             let v1 = serialization::deserialize(&deser);\n             debug!(\"v1 == %?\", v1);\n             assert v == v1;"}, {"sha": "dde409a16921a1cf5f91cffabb130c37a21f1304", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0c029a7ed9ac34bec716193e51b15d29965b0e/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=ec0c029a7ed9ac34bec716193e51b15d29965b0e", "patch": "@@ -5,6 +5,8 @@ extern mod std;\n \n use cmp::Eq;\n use std::ebml;\n+use EBReader = std::ebml::Reader;\n+use EBWriter = std::ebml::Writer;\n use io::Writer;\n use std::serialization::{Serializable, Deserializable, deserialize};\n use std::prettyprint;\n@@ -22,15 +24,15 @@ fn test_prettyprint<A: Serializable<prettyprint::Serializer>>(\n \n fn test_ebml<A:\n     Eq\n-    Serializable<ebml::Serializer>\n-    Deserializable<ebml::Deserializer>\n+    Serializable<EBWriter::Serializer>\n+    Deserializable<EBReader::Deserializer>\n >(a1: &A) {\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = &ebml::Serializer(wr);\n+        let ebml_w = &EBWriter::Serializer(wr);\n         a1.serialize(ebml_w)\n     };\n-    let d = ebml::Doc(@bytes);\n-    let a2: A = deserialize(&ebml::Deserializer(d));\n+    let d = EBReader::Doc(@bytes);\n+    let a2: A = deserialize(&EBReader::Deserializer(d));\n     assert *a1 == a2;\n }\n "}]}