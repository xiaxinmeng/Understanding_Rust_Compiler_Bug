{"sha": "d9d10c1628faea4b2b55a1d31b7ba7075edba018", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZDEwYzE2MjhmYWVhNGIyYjU1YTFkMzFiN2JhNzA3NWVkYmEwMTg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-08-21T10:48:33Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-09-25T12:02:34Z"}, "message": "Make mir-borrowck more closely match (draft) NLL RFC.\n\nIn particular:\n\n * introduce the shallow/deep distinction for read/write accesses\n\n * use the notions of prefixes, shallow prefixes, and supporting prefixes\n   rather than trying to recreate the restricted sets from ast-borrowck.\n\n * Add shallow reads of Discriminant and ArrayLength, and treat them\n   as artificial fields when doing prefix traversals.", "tree": {"sha": "bfe1f317408f3bccd1f01fdb21537dfa5f9a41d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfe1f317408f3bccd1f01fdb21537dfa5f9a41d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9d10c1628faea4b2b55a1d31b7ba7075edba018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d10c1628faea4b2b55a1d31b7ba7075edba018", "html_url": "https://github.com/rust-lang/rust/commit/d9d10c1628faea4b2b55a1d31b7ba7075edba018", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9d10c1628faea4b2b55a1d31b7ba7075edba018/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4c32b24bd757975b693fbbb46320503d6415f55", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c32b24bd757975b693fbbb46320503d6415f55", "html_url": "https://github.com/rust-lang/rust/commit/c4c32b24bd757975b693fbbb46320503d6415f55"}], "stats": {"total": 420, "additions": 339, "deletions": 81}, "files": [{"sha": "3ea6cb9ce6e17ff0bf2318ec171c8f9d5ad183b4", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 339, "deletions": 81, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/d9d10c1628faea4b2b55a1d31b7ba7075edba018/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d10c1628faea4b2b55a1d31b7ba7075edba018/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=d9d10c1628faea4b2b55a1d31b7ba7075edba018", "patch": "@@ -173,14 +173,23 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n         let span = stmt.source_info.span;\n         match stmt.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n+                // NOTE: NLL RFC calls for *shallow* write; using Deep\n+                // for short-term compat w/ AST-borrowck. Also, switch\n+                // to shallow requires to dataflow: \"if this is an\n+                // assignment `lv = <rvalue>`, then any loan for some\n+                // path P of which `lv` is a prefix is killed.\"\n                 self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n-                                   (lhs, span), JustWrite, flow_state);\n+                                   (lhs, span), Deep, JustWrite, flow_state);\n+\n                 self.consume_rvalue(ContextKind::AssignRhs.new(location),\n                                     (rhs, span), location, flow_state);\n             }\n             StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n                 self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n-                                   (lvalue, span), JustWrite, flow_state);\n+                                   (lvalue, span),\n+                                   Shallow(Some(ArtificialField::Discriminant)),\n+                                   JustWrite,\n+                                   flow_state);\n             }\n             StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 for (o, output) in asm.outputs.iter().zip(outputs) {\n@@ -192,6 +201,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                     } else {\n                         self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n                                            (output, span),\n+                                           Deep,\n                                            if o.is_rw { WriteAndRead } else { JustWrite },\n                                            flow_state);\n                     }\n@@ -209,15 +219,15 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n             StatementKind::Nop |\n             StatementKind::Validate(..) |\n             StatementKind::StorageLive(..) => {\n-                // ignored by borrowck\n+                // `Nop`, `Validate`, and `StorageLive` are irrelevant\n+                // to borrow check.\n             }\n \n             StatementKind::StorageDead(local) => {\n-                // causes non-drop values to be dropped.\n-                self.consume_lvalue(ContextKind::StorageDead.new(location),\n-                                    ConsumeKind::Consume,\n-                                    (&Lvalue::Local(local), span),\n-                                    flow_state)\n+                self.access_lvalue(ContextKind::StorageDead.new(location),\n+                                   (&Lvalue::Local(local), span),\n+                                   (Shallow(None), Write(WriteKind::StorageDead)),\n+                                   flow_state);\n             }\n         }\n     }\n@@ -246,7 +256,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                                              target: _,\n                                              unwind: _ } => {\n                 self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n-                                   (drop_lvalue, span), JustWrite, flow_state);\n+                                   (drop_lvalue, span),\n+                                   Deep,\n+                                   JustWrite,\n+                                   flow_state);\n                 self.consume_operand(ContextKind::DropAndReplace.new(loc),\n                                      ConsumeKind::Drop,\n                                      (new_value, span), flow_state);\n@@ -262,7 +275,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                 }\n                 if let Some((ref dest, _/*bb*/)) = *destination {\n                     self.mutate_lvalue(ContextKind::CallDest.new(loc),\n-                                       (dest, span), JustWrite, flow_state);\n+                                       (dest, span),\n+                                       Deep,\n+                                       JustWrite,\n+                                       flow_state);\n                 }\n             }\n             TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n@@ -309,29 +325,121 @@ enum ConsumeKind { Drop, Consume }\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum Control { Continue, Break }\n \n+use self::ShallowOrDeep::{Shallow, Deep};\n+use self::ReadOrWrite::{Read, Write};\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ArtificialField {\n+    Discriminant,\n+    ArrayLength,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ShallowOrDeep {\n+    /// From the RFC: \"A *shallow* access means that the immediate\n+    /// fields reached at LV are accessed, but references or pointers\n+    /// found within are not dereferenced. Right now, the only access\n+    /// that is shallow is an assignment like `x = ...;`, which would\n+    /// be a *shallow write* of `x`.\"\n+    Shallow(Option<ArtificialField>),\n+\n+    /// From the RFC: \"A *deep* access means that all data reachable\n+    /// through the given lvalue may be invalidated or accesses by\n+    /// this action.\"\n+    Deep,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ReadOrWrite {\n+    /// From the RFC: \"A *read* means that the existing data may be\n+    /// read, but will not be changed.\"\n+    Read(ReadKind),\n+\n+    /// From the RFC: \"A *write* means that the data may be mutated to\n+    /// new values or otherwise invalidated (for example, it could be\n+    /// de-initialized, as in a move operation).\n+    Write(WriteKind),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ReadKind {\n+    Borrow(BorrowKind),\n+    Copy,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum WriteKind {\n+    StorageDead,\n+    MutableBorrow(BorrowKind),\n+    Mutate,\n+    Move,\n+}\n+\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn access_lvalue(&mut self,\n+                     context: Context,\n+                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     kind: (ShallowOrDeep, ReadOrWrite),\n+                     flow_state: &InProgress<'b, 'gcx>) {\n+        // FIXME: also need to check permissions (e.g. reject mut\n+        // borrow of immutable ref, moves through non-`Box`-ref)\n+        let (sd, rw) = kind;\n+        self.each_borrow_involving_path(\n+            context, (sd, lvalue_span.0), flow_state, |this, _index, borrow| {\n+                match (rw, borrow.kind) {\n+                    (Read(_), BorrowKind::Shared) => {\n+                        Control::Continue\n+                    }\n+                    (Read(kind), BorrowKind::Unique) |\n+                    (Read(kind), BorrowKind::Mut) => {\n+                        match kind {\n+                            ReadKind::Copy =>\n+                                this.report_use_while_mutably_borrowed(\n+                                    context, lvalue_span, borrow),\n+                            ReadKind::Borrow(bk) =>\n+                                this.report_conflicting_borrow(\n+                                    context, lvalue_span,\n+                                    (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n+                        }\n+                        Control::Break\n+                    }\n+                    (Write(kind), _) => {\n+                        match kind {\n+                            WriteKind::MutableBorrow(bk) =>\n+                                this.report_conflicting_borrow(\n+                                    context, lvalue_span,\n+                                    (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n+                            WriteKind::StorageDead |\n+                            WriteKind::Mutate =>\n+                                this.report_illegal_mutation_of_borrowed(\n+                                    context, lvalue_span),\n+                            WriteKind::Move =>\n+                                this.report_move_out_while_borrowed(\n+                                    context, lvalue_span, borrow),\n+                        }\n+                        Control::Break\n+                    }\n+                }\n+            });\n+    }\n+\n     fn mutate_lvalue(&mut self,\n                      context: Context,\n                      lvalue_span: (&Lvalue<'gcx>, Span),\n+                     kind: ShallowOrDeep,\n                      mode: MutateMode,\n                      flow_state: &InProgress<'b, 'gcx>) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n-                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, \"update\", lvalue_span, flow_state);\n             }\n             MutateMode::JustWrite => {\n                 self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n             }\n         }\n \n-        // check we don't invalidate any outstanding loans\n-        self.each_borrow_involving_path(context,\n-                                        lvalue_span.0, flow_state, |this, _index, _data| {\n-                                            this.report_illegal_mutation_of_borrowed(context,\n-                                                                                     lvalue_span);\n-                                            Control::Break\n-                                        });\n+        self.access_lvalue(context, lvalue_span, (kind, Write(WriteKind::Mutate)), flow_state);\n \n         // check for reassignments to immutable local variables\n         self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n@@ -340,11 +448,17 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn consume_rvalue(&mut self,\n                       context: Context,\n                       (rvalue, span): (&Rvalue<'gcx>, Span),\n-                      location: Location,\n+                      _location: Location,\n                       flow_state: &InProgress<'b, 'gcx>) {\n         match *rvalue {\n             Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n-                self.borrow(context, location, bk, (lvalue, span), flow_state)\n+                let access_kind = match bk {\n+                    BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n+                    BorrowKind::Unique |\n+                    BorrowKind::Mut => (Deep, Write(WriteKind::MutableBorrow(bk))),\n+                };\n+                self.access_lvalue(context, (lvalue, span), access_kind, flow_state);\n+                self.check_if_path_is_moved(context, \"borrow\", (lvalue, span), flow_state);\n             }\n \n             Rvalue::Use(ref operand) |\n@@ -356,8 +470,14 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n             Rvalue::Len(ref lvalue) |\n             Rvalue::Discriminant(ref lvalue) => {\n-                // len(_)/discriminant(_) merely read, not consume.\n-                self.check_if_path_is_moved(context, (lvalue, span), flow_state);\n+                let af = match *rvalue {\n+                    Rvalue::Len(..) => ArtificialField::ArrayLength,\n+                    Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n+                    _ => unreachable!(),\n+                };\n+                self.access_lvalue(\n+                    context, (lvalue, span), (Shallow(Some(af)), Read(ReadKind::Copy)), flow_state);\n+                self.check_if_path_is_moved(context, \"use\", (lvalue, span), flow_state);\n             }\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n@@ -388,8 +508,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                        (operand, span): (&Operand<'gcx>, Span),\n                        flow_state: &InProgress<'b, 'gcx>) {\n         match *operand {\n-            Operand::Consume(ref lvalue) =>\n-                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state),\n+            Operand::Consume(ref lvalue) => {\n+                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state)\n+            }\n             Operand::Constant(_) => {}\n         }\n     }\n@@ -405,26 +526,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n         if moves_by_default {\n             // move of lvalue: check if this is move of already borrowed path\n-            self.each_borrow_involving_path(\n-                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n-                    if !borrow.compatible_with(BorrowKind::Mut) {\n-                        this.report_move_out_while_borrowed(context, lvalue_span, borrow);\n-                        Control::Break\n-                    } else {\n-                        Control::Continue\n-                    }\n-                });\n+            self.access_lvalue(context, lvalue_span, (Deep, Write(WriteKind::Move)), flow_state);\n         } else {\n             // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n-            self.each_borrow_involving_path(\n-                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n-                    if !borrow.compatible_with(BorrowKind::Shared) {\n-                        this.report_use_while_mutably_borrowed(context, lvalue_span, borrow);\n-                        Control::Break\n-                    } else {\n-                        Control::Continue\n-                    }\n-                });\n+            self.access_lvalue(context, lvalue_span, (Deep, Read(ReadKind::Copy)), flow_state);\n         }\n \n         // Finally, check if path was already moved.\n@@ -435,11 +540,12 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                 // skip this check in that case).\n             }\n             ConsumeKind::Consume => {\n-                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, \"use\", lvalue_span, flow_state);\n             }\n         }\n     }\n \n+    #[cfg(not_anymore)]\n     fn borrow(&mut self,\n               context: Context,\n               location: Location,\n@@ -494,6 +600,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n+                              desired_action: &str,\n                               lvalue_span: (&Lvalue<'gcx>, Span),\n                               flow_state: &InProgress<'b, 'gcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n@@ -505,7 +612,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n             if maybe_uninits.curr_state.contains(&mpi) {\n                 // find and report move(s) that could cause this to be uninitialized\n-                self.report_use_of_moved(context, lvalue_span);\n+                self.report_use_of_moved(context, desired_action, lvalue_span);\n             } else {\n                 // sanity check: initialized on *some* path, right?\n                 assert!(flow_state.inits.curr_state.contains(&mpi));\n@@ -572,8 +679,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                     // check_loans.rs first maps\n                                     // `base` to its base_path.\n \n-                                    self.check_if_path_is_moved(context,\n-                                                                (base, span), flow_state);\n+                                    self.check_if_path_is_moved(\n+                                        context, \"assignment\", (base, span), flow_state);\n \n                                     // (base initialized; no need to\n                                     // recur further)\n@@ -591,6 +698,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         }\n     }\n \n+    #[cfg(not_anymore)]\n     fn check_for_conflicting_loans(&mut self,\n                                    context: Context,\n                                    _location: Location,\n@@ -651,11 +759,13 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n-                                     lvalue: &Lvalue<'gcx>,\n+                                     access_lvalue: (ShallowOrDeep, &Lvalue<'gcx>),\n                                      flow_state: &InProgress<'b, 'gcx>,\n                                      mut op: F)\n         where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n     {\n+        let (access, lvalue) = access_lvalue;\n+\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n         // its base_path.\n \n@@ -664,47 +774,189 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        for i in flow_state.borrows.elems_incoming() {\n-            // FIXME: check_loans.rs filtered this to \"in scope\"\n-            // loans; i.e. it took a scope S and checked that each\n-            // restriction's kill_scope was a superscope of S.\n+        'next_borrow: for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n-            for restricted in self.restrictions(&borrowed.lvalue) {\n-                if restricted == lvalue {\n+\n+            // Is `lvalue` (or a prefix of it) already borrowed? If\n+            // so, that's relevant.\n+            //\n+            // FIXME: Differs from AST-borrowck; includes drive-by fix\n+            // to #38899. Will probably need back-compat mode flag.\n+            for accessed_prefix in self.prefixes(lvalue, PrefixSet::All) {\n+                if *accessed_prefix == borrowed.lvalue {\n+                    // FIXME: pass in prefix here too? And/or enum\n+                    // describing case we are in?\n                     let ctrl = op(self, i, borrowed);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n-        }\n \n-        // check for loans (not restrictions) on any base path.\n-        // e.g. Rejects `{ let x = &mut a.b; let y = a.b.c; }`,\n-        // since that moves out of borrowed path `a.b`.\n-        //\n-        // Limiting to loans (not restrictions) keeps this one\n-        // working: `{ let x = &mut a.b; let y = a.c; }`\n-        let mut cursor = lvalue;\n-        loop {\n-            // FIXME: check_loans.rs invoked `op` *before* cursor\n-            // shift here.  Might just work (and even avoid redundant\n-            // errors?) given code above?  But for now, I want to try\n-            // doing what I think is more \"natural\" check.\n-            for i in flow_state.borrows.elems_incoming() {\n-                let borrowed = &data[i];\n-                if borrowed.lvalue == *cursor {\n+            // Is `lvalue` a prefix (modulo access type) of the\n+            // `borrowed.lvalue`? If so, that's relevant.\n+\n+            let prefix_kind = match access {\n+                Shallow(Some(ArtificialField::Discriminant)) |\n+                Shallow(Some(ArtificialField::ArrayLength)) => {\n+                    // The discriminant and array length are like\n+                    // additional fields on the type; they do not\n+                    // overlap any existing data there. Furthermore,\n+                    // they cannot actually be a prefix of any\n+                    // borrowed lvalue (at least in MIR as it is\n+                    // currently.)\n+                    continue 'next_borrow;\n+                }\n+                Shallow(None) => PrefixSet::Shallow,\n+                Deep => PrefixSet::Supporting,\n+            };\n+\n+            for borrowed_prefix in self.prefixes(&borrowed.lvalue, prefix_kind) {\n+                if borrowed_prefix == lvalue {\n+                    // FIXME: pass in prefix here too? And/or enum\n+                    // describing case we are in?\n                     let ctrl = op(self, i, borrowed);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n+        }\n+    }\n+}\n+\n+use self::prefixes::PrefixSet;\n \n-            match *cursor {\n-                Lvalue::Local(_) | Lvalue::Static(_) => break,\n-                Lvalue::Projection(ref proj) => cursor = &proj.base,\n+/// From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n+/// lvalue are formed by stripping away fields and derefs, except that\n+/// we stop when we reach the deref of a shared reference. [...] \"\n+///\n+/// \"Shallow prefixes are found by stripping away fields, but stop at\n+/// any dereference. So: writing a path like `a` is illegal if `a.b`\n+/// is borrowed. But: writing `a` is legal if `*a` is borrowed,\n+/// whether or not `a` is a shared or mutable reference. [...] \"\n+mod prefixes {\n+    use super::{MirBorrowckCtxt};\n+\n+    use rustc::hir;\n+    use rustc::ty::{self, TyCtxt};\n+    use rustc::mir::{Lvalue, Mir, ProjectionElem};\n+\n+    pub(super) struct Prefixes<'c, 'tcx: 'c> {\n+        mir: &'c Mir<'tcx>,\n+        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n+        kind: PrefixSet,\n+        next: Option<&'c Lvalue<'tcx>>,\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+    pub(super) enum PrefixSet {\n+        All,\n+        Shallow,\n+        Supporting,\n+    }\n+\n+    impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        pub(super) fn prefixes<'d>(&self,\n+                                   lvalue: &'d Lvalue<'gcx>,\n+                                   kind: PrefixSet)\n+                                   -> Prefixes<'d, 'gcx> where 'b: 'd\n+        {\n+            Prefixes { next: Some(lvalue), kind, mir: self.mir, tcx: self.tcx }\n+        }\n+    }\n+\n+    impl<'c, 'tcx> Iterator for Prefixes<'c, 'tcx> {\n+        type Item = &'c Lvalue<'tcx>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            let mut cursor = match self.next {\n+                None => return None,\n+                Some(lvalue) => lvalue,\n+            };\n+\n+            // Post-processing `lvalue`: Enqueue any remaining\n+            // work. Also, `lvalue` may not be a prefix itself, but\n+            // may hold one further down (e.g. we never return\n+            // downcasts here, but may return a base of a downcast).\n+\n+            'cursor: loop {\n+                let proj = match *cursor {\n+                    Lvalue::Local(_) | // search yielded this leaf\n+                    Lvalue::Static(_) => {\n+                        self.next = None;\n+                        return Some(cursor);\n+                    }\n+\n+                    Lvalue::Projection(ref proj) => proj,\n+                };\n+\n+                match proj.elem {\n+                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                        // FIXME: add union handling\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n+                    ProjectionElem::Downcast(..) |\n+                    ProjectionElem::Subslice { .. } |\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Index(_) => {\n+                        cursor = &proj.base;\n+                        continue 'cursor;\n+                    }\n+                    ProjectionElem::Deref => {\n+                        // (handled below)\n+                    }\n+                }\n+\n+                assert_eq!(proj.elem, ProjectionElem::Deref);\n+\n+                match self.kind {\n+                    PrefixSet::Shallow => {\n+                        // shallow prefixes are found by stripping away\n+                        // fields, but stop at *any* dereference.\n+                        // So we can just stop the traversal now.\n+                        self.next = None;\n+                        return Some(cursor);\n+                    }\n+                    PrefixSet::All => {\n+                        // all prefixes: just blindly enqueue the base\n+                        // of the projection\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n+                    PrefixSet::Supporting => {\n+                        // fall through!\n+                    }\n+                }\n+\n+                assert_eq!(self.kind, PrefixSet::Supporting);\n+                // supporting prefixes: strip away fields and\n+                // derefs, except we stop at the deref of a shared\n+                // reference.\n+\n+                let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                match ty.sty {\n+                    ty::TyRawPtr(_) |\n+                    ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                        // don't continue traversing over derefs of raw pointers or shared borrows.\n+                        self.next = None;\n+                        return Some(cursor);\n+                    }\n+\n+                    ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n+\n+                    ty::TyAdt(..) if ty.is_box() => {\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n+\n+                    _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                }\n             }\n         }\n     }\n-}\n+    }\n \n+#[cfg(not_anymore)]\n mod restrictions {\n     use super::MirBorrowckCtxt;\n \n@@ -724,7 +976,7 @@ mod restrictions {\n                                        -> Restrictions<'d, 'gcx> where 'b: 'd\n         {\n             let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n-            Restrictions { lvalue_stack: lvalue_stack, mir: self.mir, tcx: self.tcx }\n+            Restrictions { lvalue_stack, mir: self.mir, tcx: self.tcx }\n         }\n \n         fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n@@ -895,9 +1147,10 @@ mod restrictions {\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn report_use_of_moved(&mut self,\n                            _context: Context,\n+                           desired_action: &str,\n                            (lvalue, span): (&Lvalue, Span)) {\n         self.tcx.cannot_act_on_uninitialized_variable(span,\n-                                                      \"use\",\n+                                                      desired_action,\n                                                       &self.describe_lvalue(lvalue),\n                                                       Origin::Mir)\n                 .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n@@ -939,14 +1192,16 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn report_conflicting_borrow(&mut self,\n                                  _context: Context,\n                                  (lvalue, span): (&Lvalue, Span),\n-                                 loan1: &BorrowData,\n-                                 loan2: &BorrowData) {\n+                                 loan1: (&Lvalue, BorrowKind),\n+                                 loan2: (&Lvalue, BorrowKind)) {\n+        let (loan1_lvalue, loan1_kind) = loan1;\n+        let (loan2_lvalue, loan2_kind) = loan2;\n         // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n-        assert_eq!(loan1.lvalue, loan2.lvalue);\n+        assert_eq!(loan1_lvalue, loan2_lvalue);\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let mut err = match (loan1.kind, \"immutable\", \"mutable\",\n-                             loan2.kind, \"immutable\", \"mutable\") {\n+        let mut err = match (loan1_kind, \"immutable\", \"mutable\",\n+                             loan2_kind, \"immutable\", \"mutable\") {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n             (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) =>\n                 self.tcx.cannot_reborrow_already_borrowed(\n@@ -1065,6 +1320,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     // FIXME: needs to be able to express errors analogous to check_loans.rs\n+    #[cfg(not_anymore)]\n     fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n         if loan1.compatible_with(loan2.kind) { return false; }\n \n@@ -1129,8 +1385,8 @@ enum ContextKind {\n     CallOperand,\n     CallDest,\n     Assert,\n-    StorageDead,\n     Yield,\n+    StorageDead,\n }\n \n impl ContextKind {\n@@ -1262,6 +1518,7 @@ impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n         self.curr_state.subtract(&self.stmt_kill);\n     }\n \n+    #[allow(dead_code)]\n     fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n         let univ = self.base_results.sets().bits_per_block();\n         self.stmt_gen.elems(univ)\n@@ -1274,6 +1531,7 @@ impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n }\n \n impl<'tcx> BorrowData<'tcx> {\n+    #[allow(dead_code)]\n     fn compatible_with(&self, bk: BorrowKind) -> bool {\n         match (self.kind, bk) {\n             (BorrowKind::Shared, BorrowKind::Shared) => true,"}]}