{"sha": "70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYzVhMGZiZjc4NGQ2YTg5YjFjMmM1MGY5ZmU4MzA5M2JkMjFhYmM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-08T18:35:15Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T14:44:47Z"}, "message": "libsyntax: Introduce an `InternedString` type to reduce `@str` in the\ncompiler and use it for attributes", "tree": {"sha": "c0d73d05918545051a9e1d10f5496ee588df3693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0d73d05918545051a9e1d10f5496ee588df3693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "html_url": "https://github.com/rust-lang/rust/commit/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d494198bbb9701b6336febcf9d0ceb39e4b7975", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d494198bbb9701b6336febcf9d0ceb39e4b7975", "html_url": "https://github.com/rust-lang/rust/commit/1d494198bbb9701b6336febcf9d0ceb39e4b7975"}], "stats": {"total": 490, "additions": 336, "deletions": 154}, "files": [{"sha": "2b552aff717c7fc1272c7ec9130d5f0cabcea019", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -44,6 +44,7 @@ use syntax::codemap;\n use syntax::diagnostic;\n use syntax::ext::base::CrateLoader;\n use syntax::parse;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::print::{pp, pprust};\n use syntax;\n@@ -90,22 +91,23 @@ pub fn default_configuration(sess: Session) ->\n     };\n \n     let fam = match sess.targ_cfg.os {\n-        abi::OsWin32 => @\"windows\",\n-        _ => @\"unix\"\n+        abi::OsWin32 => InternedString::new(\"windows\"),\n+        _ => InternedString::new(\"unix\")\n     };\n \n     let mk = attr::mk_name_value_item_str;\n     return ~[ // Target bindings.\n-         attr::mk_word_item(fam),\n-         mk(@\"target_os\", tos),\n-         mk(@\"target_family\", fam),\n-         mk(@\"target_arch\", arch),\n-         mk(@\"target_endian\", end),\n-         mk(@\"target_word_size\", wordsz),\n+         attr::mk_word_item(fam.clone()),\n+         mk(InternedString::new(\"target_os\"), tos),\n+         mk(InternedString::new(\"target_family\"), fam.get().to_managed()),\n+         mk(InternedString::new(\"target_arch\"), arch),\n+         mk(InternedString::new(\"target_endian\"), end),\n+         mk(InternedString::new(\"target_word_size\"), wordsz),\n     ];\n }\n \n-pub fn append_configuration(cfg: &mut ast::CrateConfig, name: @str) {\n+pub fn append_configuration(cfg: &mut ast::CrateConfig,\n+                            name: InternedString) {\n     if !cfg.iter().any(|mi| mi.name() == name) {\n         cfg.push(attr::mk_word_item(name))\n     }\n@@ -118,9 +120,15 @@ pub fn build_configuration(sess: Session) ->\n     let default_cfg = default_configuration(sess);\n     let mut user_cfg = sess.opts.cfg.clone();\n     // If the user wants a test runner, then add the test cfg\n-    if sess.opts.test { append_configuration(&mut user_cfg, @\"test\") }\n+    if sess.opts.test {\n+        append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n+    }\n     // If the user requested GC, then add the GC cfg\n-    append_configuration(&mut user_cfg, if sess.opts.gc { @\"gc\" } else { @\"nogc\" });\n+    append_configuration(&mut user_cfg, if sess.opts.gc {\n+        InternedString::new(\"gc\")\n+    } else {\n+        InternedString::new(\"nogc\")\n+    });\n     return vec::append(user_cfg, default_cfg);\n }\n "}, {"sha": "57bc9c32cbdd1d63240cc8e1a4863efff5869ea9", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -435,7 +435,7 @@ pub fn collect_outputs(session: &Session,\n     }\n     let mut base = session.opts.outputs.clone();\n     let mut iter = attrs.iter().filter_map(|a| {\n-        if \"crate_type\" == a.name() {\n+        if a.name().equiv(&(\"crate_type\")) {\n             match a.value_str() {\n                 Some(n) if \"rlib\" == n => Some(OutputRlib),\n                 Some(n) if \"dylib\" == n => Some(OutputDylib),"}, {"sha": "7903ce00dc312be1e78e210b617e13568eabdbce", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -135,7 +135,7 @@ impl Visitor<()> for Context {\n \n     fn visit_item(&mut self, i: &ast::Item, _:()) {\n         for attr in i.attrs.iter() {\n-            if \"thread_local\" == attr.name() {\n+            if attr.name().equiv(&(\"thread_local\")) {\n                 self.gate_feature(\"thread_local\", i.span,\n                                   \"`#[thread_local]` is an experimental feature, and does not \\\n                                   currently handle destructors. There is no corresponding \\\n@@ -258,7 +258,9 @@ pub fn check_crate(sess: Session, crate: &ast::Crate) {\n     };\n \n     for attr in crate.attrs.iter() {\n-        if \"feature\" != attr.name() { continue }\n+        if !attr.name().equiv(&(\"feature\")) {\n+            continue\n+        }\n \n         match attr.meta_item_list() {\n             None => {\n@@ -268,14 +270,16 @@ pub fn check_crate(sess: Session, crate: &ast::Crate) {\n             Some(list) => {\n                 for &mi in list.iter() {\n                     let name = match mi.node {\n-                        ast::MetaWord(word) => word,\n+                        ast::MetaWord(ref word) => (*word).clone(),\n                         _ => {\n-                            sess.span_err(mi.span, \"malformed feature, expected \\\n-                                                    just one word\");\n+                            sess.span_err(mi.span,\n+                                          \"malformed feature, expected just \\\n+                                           one word\");\n                             continue\n                         }\n                     };\n-                    match KNOWN_FEATURES.iter().find(|& &(n, _)| n == name) {\n+                    match KNOWN_FEATURES.iter()\n+                                        .find(|& &(n, _)| name.equiv(&n)) {\n                         Some(&(name, Active)) => { cx.features.push(name); }\n                         Some(&(_, Removed)) => {\n                             sess.span_err(mi.span, \"feature has been removed\");"}, {"sha": "b32568abeb1f780572e23061200c4364990374b8", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -27,6 +27,7 @@ use syntax::ext::base::ExtCtxt;\n use syntax::fold::Folder;\n use syntax::fold;\n use syntax::opt_vec;\n+use syntax::parse::token::InternedString;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::util::small_vector::SmallVector;\n@@ -132,7 +133,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             if !cx.sess.building_library.get() {\n                 @ast::Item {\n                     attrs: item.attrs.iter().filter_map(|attr| {\n-                        if \"main\" != attr.name() {\n+                        if attr.name().equiv(&(\"main\")) {\n                             Some(*attr)\n                         } else {\n                             None\n@@ -248,7 +249,7 @@ fn is_bench_fn(i: @ast::Item) -> bool {\n fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n-        \"ignore\" == attr.name() && match attr.meta_item_list() {\n+        attr.name().equiv(&(\"ignore\")) && match attr.meta_item_list() {\n             Some(ref cfgs) => attr::test_cfg(cx.config, cfgs.iter().map(|x| *x)),\n             None => true\n         }\n@@ -330,8 +331,9 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n     let item_ = ast::ItemMod(testmod);\n \n     // This attribute tells resolve to let us call unexported functions\n+    let resolve_unexported_str = InternedString::new(\"!resolve_unexported\");\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n+        attr::mk_attr(attr::mk_word_item(resolve_unexported_str));\n \n     let item = ast::Item {\n         ident: cx.sess.ident_of(\"__test\"),"}, {"sha": "4670757b5c38a6da08025aac29ffe31190d2fc25", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -124,7 +124,7 @@ struct Env {\n fn visit_crate(e: &Env, c: &ast::Crate) {\n     let cstore = e.sess.cstore;\n \n-    for a in c.attrs.iter().filter(|m| \"link_args\" == m.name()) {\n+    for a in c.attrs.iter().filter(|m| m.name().equiv(&(\"link_args\"))) {\n         match a.value_str() {\n           Some(ref linkarg) => {\n             cstore.add_used_link_args(*linkarg);\n@@ -206,7 +206,11 @@ fn visit_item(e: &Env, i: &ast::Item) {\n             // First, add all of the custom link_args attributes\n             let cstore = e.sess.cstore;\n             let link_args = i.attrs.iter()\n-                .filter_map(|at| if \"link_args\" == at.name() {Some(at)} else {None})\n+                .filter_map(|at| if at.name().equiv(&(\"link_args\")) {\n+                    Some(at)\n+                } else {\n+                    None\n+                })\n                 .to_owned_vec();\n             for m in link_args.iter() {\n                 match m.value_str() {\n@@ -220,13 +224,17 @@ fn visit_item(e: &Env, i: &ast::Item) {\n             // Next, process all of the #[link(..)]-style arguments\n             let cstore = e.sess.cstore;\n             let link_args = i.attrs.iter()\n-                .filter_map(|at| if \"link\" == at.name() {Some(at)} else {None})\n+                .filter_map(|at| if at.name().equiv(&(\"link\")) {\n+                    Some(at)\n+                } else {\n+                    None\n+                })\n                 .to_owned_vec();\n             for m in link_args.iter() {\n                 match m.meta_item_list() {\n                     Some(items) => {\n                         let kind = items.iter().find(|k| {\n-                            \"kind\" == k.name()\n+                            k.name().equiv(&(\"kind\"))\n                         }).and_then(|a| a.value_str());\n                         let kind = match kind {\n                             Some(k) => {\n@@ -249,7 +257,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                             None => cstore::NativeUnknown\n                         };\n                         let n = items.iter().find(|n| {\n-                            \"name\" == n.name()\n+                            n.name().equiv(&(\"name\"))\n                         }).and_then(|a| a.value_str());\n                         let n = match n {\n                             Some(n) => n,"}, {"sha": "ef6bb30cb515fe0cbcaf42366d16ab503663bb85", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -1042,14 +1042,14 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     let mut items: ~[@ast::MetaItem] = ~[];\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = nd.as_str_slice().to_managed();\n+        let n = token::intern_and_get_ident(nd.as_str_slice());\n         items.push(attr::mk_word_item(n));\n         true\n     });\n     reader::tagged_docs(md, tag_meta_item_name_value, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = nd.as_str_slice().to_managed();\n+        let n = token::intern_and_get_ident(nd.as_str_slice());\n         let v = vd.as_str_slice().to_managed();\n         // FIXME (#623): Should be able to decode MetaNameValue variants,\n         // but currently the encoder just drops them\n@@ -1058,7 +1058,7 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     });\n     reader::tagged_docs(md, tag_meta_item_list, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = nd.as_str_slice().to_managed();\n+        let n = token::intern_and_get_ident(nd.as_str_slice());\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n         true"}, {"sha": "94a4639975c2d92a75f2378a5f8632166c1f244e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -21,29 +21,28 @@ use middle::ty;\n use middle::typeck;\n use middle;\n \n+use extra::serialize::Encodable;\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::hashmap::{HashMap, HashSet};\n use std::io::MemWriter;\n use std::str;\n use std::vec;\n-\n-use extra::serialize::Encodable;\n-\n use syntax::abi::AbiSet;\n use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::*;\n-use syntax::attr;\n+use syntax::ast_util;\n use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n use syntax::codemap;\n use syntax::diagnostic::SpanHandler;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token::special_idents;\n-use syntax::ast_util;\n+use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n-use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n@@ -1507,19 +1506,19 @@ fn write_i64(writer: &mut MemWriter, &n: &i64) {\n \n fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n     match mi.node {\n-      MetaWord(name) => {\n+      MetaWord(ref name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(name.as_bytes());\n+        ebml_w.writer.write(name.get().as_bytes());\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n-      MetaNameValue(name, value) => {\n+      MetaNameValue(ref name, value) => {\n         match value.node {\n           LitStr(value, _) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(name.as_bytes());\n+            ebml_w.writer.write(name.get().as_bytes());\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n             ebml_w.writer.write(value.as_bytes());\n@@ -1529,10 +1528,10 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      MetaList(name, ref items) => {\n+      MetaList(ref name, ref items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(name.as_bytes());\n+        ebml_w.writer.write(name.get().as_bytes());\n         ebml_w.end_tag();\n         for inner_item in items.iter() {\n             encode_meta_item(ebml_w, *inner_item);\n@@ -1563,13 +1562,13 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n         attr::mk_attr(\n             attr::mk_name_value_item_str(\n-                @\"crate_id\",\n+                InternedString::new(\"crate_id\"),\n                 ecx.link_meta.crateid.to_str().to_managed()))\n     }\n \n     let mut attrs = ~[];\n     for attr in crate.attrs.iter() {\n-        if \"crate_id\" != attr.name()  {\n+        if !attr.name().equiv(&(\"crate_id\")) {\n             attrs.push(*attr);\n         }\n     }"}, {"sha": "34f8bad96660f04c7f3766a8d9c1e868ad9b6518", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -185,7 +185,7 @@ impl LanguageItemCollector {\n pub fn extract(attrs: &[ast::Attribute]) -> Option<@str> {\n     for attribute in attrs.iter() {\n         match attribute.name_str_pair() {\n-            Some((key, value)) if \"lang\" == key => {\n+            Some((ref key, value)) if key.equiv(&(\"lang\")) => {\n                 return Some(value);\n             }\n             Some(..) | None => {}"}, {"sha": "3dfa186e4a95b8fb0bf319dc013030a62eab809d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -34,18 +34,17 @@\n //! Context itself, span_lint should be used instead of add_lint.\n \n use driver::session;\n+use metadata::csearch;\n use middle::dead::DEAD_CODE_LINT_STR;\n+use middle::pat_util;\n use middle::privacy;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::ty;\n+use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n+use middle::typeck::infer;\n use middle::typeck;\n-use middle::pat_util;\n-use metadata::csearch;\n-use util::ppaux::{ty_to_str};\n use std::to_str::ToStr;\n-\n-use middle::typeck::infer;\n-use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n+use util::ppaux::{ty_to_str};\n \n use std::cmp;\n use std::hashmap::HashMap;\n@@ -59,13 +58,14 @@ use std::u64;\n use std::u8;\n use extra::smallintmap::SmallIntMap;\n use syntax::ast_map;\n-use syntax::attr;\n+use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::{AttrMetaMethods, AttributeMethods};\n+use syntax::attr;\n use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token;\n-use syntax::{ast, ast_util, visit};\n-use syntax::ast_util::IdVisitingOperation;\n use syntax::visit::Visitor;\n+use syntax::{ast, ast_util, visit};\n \n #[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub enum Lint {\n@@ -540,10 +540,16 @@ impl<'a> Context<'a> {\n         });\n \n         let old_is_doc_hidden = self.is_doc_hidden;\n-        self.is_doc_hidden = self.is_doc_hidden ||\n-            attrs.iter().any(|attr| (\"doc\" == attr.name() && match attr.meta_item_list()\n-                                     { None => false,\n-                                       Some(l) => attr::contains_name(l, \"hidden\") }));\n+        self.is_doc_hidden =\n+            self.is_doc_hidden ||\n+            attrs.iter()\n+                 .any(|attr| {\n+                     attr.name().equiv(&(\"doc\")) &&\n+                     match attr.meta_item_list() {\n+                         None => false,\n+                         Some(l) => attr::contains_name(l, \"hidden\")\n+                     }\n+                 });\n \n         f(self);\n \n@@ -569,12 +575,12 @@ impl<'a> Context<'a> {\n // Return true if that's the case. Otherwise return false.\n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::Attribute],\n-                 f: |@ast::MetaItem, level, @str| -> bool)\n+                 f: |@ast::MetaItem, level, InternedString| -> bool)\n                  -> bool {\n     let xs = [allow, warn, deny, forbid];\n     for &level in xs.iter() {\n         let level_name = level_to_str(level);\n-        for attr in attrs.iter().filter(|m| level_name == m.name()) {\n+        for attr in attrs.iter().filter(|m| m.name().equiv(&level_name)) {\n             let meta = attr.node.value;\n             let metas = match meta.node {\n                 ast::MetaList(_, ref metas) => metas,\n@@ -585,8 +591,8 @@ pub fn each_lint(sess: session::Session,\n             };\n             for meta in metas.iter() {\n                 match meta.node {\n-                    ast::MetaWord(lintname) => {\n-                        if !f(*meta, level, lintname) {\n+                    ast::MetaWord(ref lintname) => {\n+                        if !f(*meta, level, (*lintname).clone()) {\n                             return false;\n                         }\n                     }\n@@ -1314,7 +1320,7 @@ fn check_missing_doc_attrs(cx: &Context,\n \n     let has_doc = attrs.iter().any(|a| {\n         match a.node.value.node {\n-            ast::MetaNameValue(ref name, _) if \"doc\" == *name => true,\n+            ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n             _ => false\n         }\n     });"}, {"sha": "ba9dea28cbc9fcb324ac8400170914cfa34cf88e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -4165,7 +4165,7 @@ pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n     let mut found = false;\n     each_attr(tcx, did, |item| {\n-        if attr == item.name() {\n+        if item.name().equiv(&attr) {\n             found = true;\n             false\n         } else {"}, {"sha": "564fb465c024a4030e640abc60380000094fdc9b", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -20,6 +20,8 @@ use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttributeMethods;\n use syntax::codemap::Pos;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n \n use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n@@ -223,9 +225,13 @@ pub enum Attribute {\n impl Clean<Attribute> for ast::MetaItem {\n     fn clean(&self) -> Attribute {\n         match self.node {\n-            ast::MetaWord(s) => Word(s.to_owned()),\n-            ast::MetaList(ref s, ref l) => List(s.to_owned(), l.clean()),\n-            ast::MetaNameValue(s, ref v) => NameValue(s.to_owned(), lit_to_str(v))\n+            ast::MetaWord(ref s) => Word(s.get().to_owned()),\n+            ast::MetaList(ref s, ref l) => {\n+                List(s.get().to_owned(), l.clean())\n+            }\n+            ast::MetaNameValue(ref s, ref v) => {\n+                NameValue(s.get().to_owned(), lit_to_str(v))\n+            }\n         }\n     }\n }\n@@ -238,10 +244,11 @@ impl Clean<Attribute> for ast::Attribute {\n \n // This is a rough approximation that gets us what we want.\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n-    fn name(&self) -> @str {\n+    fn name(&self) -> InternedString {\n         match **self {\n-            Word(ref n) | List(ref n, _) | NameValue(ref n, _) =>\n-                n.to_managed()\n+            Word(ref n) | List(ref n, _) | NameValue(ref n, _) => {\n+                token::intern_and_get_ident(*n)\n+            }\n         }\n     }\n \n@@ -252,7 +259,7 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n         }\n     }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n-    fn name_str_pair(&self) -> Option<(@str, @str)> { None }\n+    fn name_str_pair(&self) -> Option<(InternedString, @str)> { None }\n }\n \n #[deriving(Clone, Encodable, Decodable)]"}, {"sha": "0e2d6c972ae60df0fe6283ca0cd866c45f5860ac", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -15,6 +15,7 @@ use rustc::middle::privacy;\n \n use syntax::ast;\n use syntax::diagnostic;\n+use syntax::parse::token;\n use syntax::parse;\n use syntax;\n \n@@ -71,7 +72,8 @@ fn get_ast_and_resolve(cpath: &Path,\n \n     let mut cfg = build_configuration(sess);\n     for cfg_ in cfgs.move_iter() {\n-        cfg.push(@dummy_spanned(ast::MetaWord(cfg_.to_managed())));\n+        let cfg_ = token::intern_and_get_ident(cfg_);\n+        cfg.push(@dummy_spanned(ast::MetaWord(cfg_)));\n     }\n \n     let crate = phase_1_parse_input(sess, cfg.clone(), &input);"}, {"sha": "3f1762009bc17296c7b00acf174721965c45aa1f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -30,6 +30,7 @@ use syntax::ext::base::{ExtCtxt, MacroCrate};\n use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n use syntax::fold::Folder;\n+use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n use syntax::util::small_vector::SmallVector;\n use syntax::crateid::CrateId;\n@@ -77,7 +78,7 @@ fn fold_mod(m: &ast::Mod, fold: &mut CrateSetup) -> ast::Mod {\n     fn strip_main(item: @ast::Item) -> @ast::Item {\n         @ast::Item {\n             attrs: item.attrs.iter().filter_map(|attr| {\n-                if \"main\" != attr.name() {\n+                if !attr.name().equiv(&(\"main\")) {\n                     Some(*attr)\n                 } else {\n                     None\n@@ -101,13 +102,15 @@ fn fold_item(item: @ast::Item, fold: &mut CrateSetup)\n     let mut had_pkg_do = false;\n \n     for attr in item.attrs.iter() {\n-        if \"pkg_do\" == attr.name() {\n+        if attr.name().equiv(&(\"pkg_do\")) {\n             had_pkg_do = true;\n             match attr.node.value.node {\n                 ast::MetaList(_, ref mis) => {\n                     for mi in mis.iter() {\n                         match mi.node {\n-                            ast::MetaWord(cmd) => cmds.push(cmd.to_owned()),\n+                            ast::MetaWord(ref cmd) => {\n+                                cmds.push(cmd.get().to_owned())\n+                            }\n                             _ => {}\n                         };\n                     }\n@@ -314,7 +317,8 @@ pub fn compile_input(context: &BuildContext,\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let crateid_attr =\n-            attr::mk_name_value_item_str(@\"crate_id\", crate_id.to_str().to_managed());\n+            attr::mk_name_value_item_str(InternedString::new(\"crate_id\"),\n+                                         crate_id.to_str().to_managed());\n \n         debug!(\"crateid attr: {:?}\", crateid_attr);\n         crate.attrs.push(attr::mk_attr(crateid_attr));"}, {"sha": "f7e474f666c0d16dfcaa5fbaaf5f48eb611d5a4e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -14,7 +14,8 @@ use codemap::{Span, Spanned, DUMMY_SP};\n use abi::AbiSet;\n use ast_util;\n use opt_vec::OptVec;\n-use parse::token::{interner_get, str_to_ident, special_idents};\n+use parse::token::{InternedString, interner_get, special_idents};\n+use parse::token::{str_to_ident};\n \n use std::cell::RefCell;\n use std::hashmap::HashMap;\n@@ -295,9 +296,9 @@ pub type MetaItem = Spanned<MetaItem_>;\n \n #[deriving(Clone, Encodable, Decodable, IterBytes)]\n pub enum MetaItem_ {\n-    MetaWord(@str),\n-    MetaList(@str, ~[@MetaItem]),\n-    MetaNameValue(@str, Lit),\n+    MetaWord(InternedString),\n+    MetaList(InternedString, ~[@MetaItem]),\n+    MetaNameValue(InternedString, Lit),\n }\n \n // can't be derived because the MetaList requires an unordered comparison"}, {"sha": "6c6f47bae8a7e239233ce9a2932cfff2351938dd", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -16,18 +16,19 @@ use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::SpanHandler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use parse::token::InternedString;\n use crateid::CrateId;\n \n use std::hashmap::HashSet;\n \n pub trait AttrMetaMethods {\n-    // This could be changed to `fn check_name(&self, name: @str) ->\n+    // This could be changed to `fn check_name(&self, name: InternedString) ->\n     // bool` which would facilitate a side table recording which\n     // attributes/meta items are used/unused.\n \n     /// Retrieve the name of the meta item, e.g. foo in #[foo],\n     /// #[foo=\"bar\"] and #[foo(bar)]\n-    fn name(&self) -> @str;\n+    fn name(&self) -> InternedString;\n \n     /**\n      * Gets the string value if self is a MetaNameValue variant\n@@ -41,24 +42,26 @@ pub trait AttrMetaMethods {\n      * If the meta item is a name-value type with a string value then returns\n      * a tuple containing the name and string value, otherwise `None`\n      */\n-    fn name_str_pair(&self) -> Option<(@str, @str)>;\n+    fn name_str_pair(&self) -> Option<(InternedString, @str)>;\n }\n \n impl AttrMetaMethods for Attribute {\n-    fn name(&self) -> @str { self.meta().name() }\n+    fn name(&self) -> InternedString { self.meta().name() }\n     fn value_str(&self) -> Option<@str> { self.meta().value_str() }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n         self.node.value.meta_item_list()\n     }\n-    fn name_str_pair(&self) -> Option<(@str, @str)> { self.meta().name_str_pair() }\n+    fn name_str_pair(&self) -> Option<(InternedString, @str)> {\n+        self.meta().name_str_pair()\n+    }\n }\n \n impl AttrMetaMethods for MetaItem {\n-    fn name(&self) -> @str {\n+    fn name(&self) -> InternedString {\n         match self.node {\n-            MetaWord(n) => n,\n-            MetaNameValue(n, _) => n,\n-            MetaList(n, _) => n\n+            MetaWord(ref n) => (*n).clone(),\n+            MetaNameValue(ref n, _) => (*n).clone(),\n+            MetaList(ref n, _) => (*n).clone(),\n         }\n     }\n \n@@ -81,19 +84,21 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn name_str_pair(&self) -> Option<(@str, @str)> {\n+    fn name_str_pair(&self) -> Option<(InternedString, @str)> {\n         self.value_str().map(|s| (self.name(), s))\n     }\n }\n \n // Annoying, but required to get test_cfg to work\n impl AttrMetaMethods for @MetaItem {\n-    fn name(&self) -> @str { (**self).name() }\n+    fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<@str> { (**self).value_str() }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n         (**self).meta_item_list()\n     }\n-    fn name_str_pair(&self) -> Option<(@str, @str)> { (**self).name_str_pair() }\n+    fn name_str_pair(&self) -> Option<(InternedString, @str)> {\n+        (**self).name_str_pair()\n+    }\n }\n \n \n@@ -114,7 +119,7 @@ impl AttributeMethods for Attribute {\n     fn desugar_doc(&self) -> Attribute {\n         if self.node.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n-            let meta = mk_name_value_item_str(@\"doc\",\n+            let meta = mk_name_value_item_str(InternedString::new(\"doc\"),\n                                               strip_doc_comment_decoration(comment).to_managed());\n             mk_attr(meta)\n         } else {\n@@ -125,20 +130,22 @@ impl AttributeMethods for Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: @str, value: @str) -> @MetaItem {\n+pub fn mk_name_value_item_str(name: InternedString, value: @str)\n+                              -> @MetaItem {\n     let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n     mk_name_value_item(name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: @str, value: ast::Lit) -> @MetaItem {\n+pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n+                          -> @MetaItem {\n     @dummy_spanned(MetaNameValue(name, value))\n }\n \n-pub fn mk_list_item(name: @str, items: ~[@MetaItem]) -> @MetaItem {\n+pub fn mk_list_item(name: InternedString, items: ~[@MetaItem]) -> @MetaItem {\n     @dummy_spanned(MetaList(name, items))\n }\n \n-pub fn mk_word_item(name: @str) -> @MetaItem {\n+pub fn mk_word_item(name: InternedString) -> @MetaItem {\n     @dummy_spanned(MetaWord(name))\n }\n \n@@ -155,7 +162,8 @@ pub fn mk_sugared_doc_attr(text: @str, lo: BytePos, hi: BytePos) -> Attribute {\n     let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n     let attr = Attribute_ {\n         style: style,\n-        value: @spanned(lo, hi, MetaNameValue(@\"doc\", lit)),\n+        value: @spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n+                                              lit)),\n         is_sugared_doc: true\n     };\n     spanned(lo, hi, attr)\n@@ -178,20 +186,22 @@ pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n     debug!(\"attr::contains_name (name={})\", name);\n     metas.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n-        name == item.name()\n+        item.name().equiv(&name)\n     })\n }\n \n pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n                                  -> Option<@str> {\n     attrs.iter()\n-        .find(|at| name == at.name())\n+        .find(|at| at.name().equiv(&name))\n         .and_then(|at| at.value_str())\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<@str> {\n-    items.rev_iter().find(|mi| name == mi.name()).and_then(|i| i.value_str())\n+    items.rev_iter()\n+         .find(|mi| mi.name().equiv(&name))\n+         .and_then(|i| i.value_str())\n }\n \n /* Higher-level applications */\n@@ -201,16 +211,16 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n     // human-readable strings.\n     let mut v = items.iter()\n         .map(|&mi| (mi.name(), mi))\n-        .collect::<~[(@str, @MetaItem)]>();\n+        .collect::<~[(InternedString, @MetaItem)]>();\n \n-    v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n+    v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n     // There doesn't seem to be a more optimal way to do this\n     v.move_iter().map(|(_, m)| {\n         match m.node {\n-            MetaList(n, ref mis) => {\n+            MetaList(ref n, ref mis) => {\n                 @Spanned {\n-                    node: MetaList(n, sort_meta_items(*mis)),\n+                    node: MetaList((*n).clone(), sort_meta_items(*mis)),\n                     .. /*bad*/ (*m).clone()\n                 }\n             }\n@@ -225,7 +235,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n  */\n pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n     let mut result = ~[];\n-    for attr in attrs.iter().filter(|at| \"link\" == at.name()) {\n+    for attr in attrs.iter().filter(|at| at.name().equiv(&(\"link\"))) {\n         match attr.meta().node {\n             MetaList(_, ref items) => result.push_all(*items),\n             _ => ()\n@@ -254,8 +264,8 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     attrs.iter().fold(InlineNone, |ia,attr| {\n         match attr.node.value.node {\n-          MetaWord(n) if \"inline\" == n => InlineHint,\n-          MetaList(n, ref items) if \"inline\" == n => {\n+          MetaWord(ref n) if n.equiv(&(\"inline\")) => InlineHint,\n+          MetaList(ref n, ref items) if n.equiv(&(\"inline\")) => {\n             if contains_name(*items, \"always\") {\n                 InlineAlways\n             } else if contains_name(*items, \"never\") {\n@@ -284,7 +294,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n     // this doesn't work.\n     let some_cfg_matches = metas.any(|mi| {\n         debug!(\"testing name: {}\", mi.name());\n-        if \"cfg\" == mi.name() { // it is a #[cfg()] attribute\n+        if mi.name().equiv(&(\"cfg\")) { // it is a #[cfg()] attribute\n             debug!(\"is cfg\");\n             no_cfgs = false;\n              // only #[cfg(...)] ones are understood.\n@@ -294,7 +304,8 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n                     cfg_meta.iter().all(|cfg_mi| {\n                         debug!(\"cfg({}[...])\", cfg_mi.name());\n                         match cfg_mi.node {\n-                            ast::MetaList(s, ref not_cfgs) if \"not\" == s => {\n+                            ast::MetaList(ref s, ref not_cfgs)\n+                            if s.equiv(&(\"not\")) => {\n                                 debug!(\"not!\");\n                                 // inside #[cfg(not(...))], so these need to all\n                                 // not match.\n@@ -337,7 +348,7 @@ pub enum StabilityLevel {\n /// Find the first stability attribute. `None` if none exists.\n pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It) -> Option<Stability> {\n     for m in metas {\n-        let level = match m.name().as_slice() {\n+        let level = match m.name().get() {\n             \"deprecated\" => Deprecated,\n             \"experimental\" => Experimental,\n             \"unstable\" => Unstable,\n@@ -360,7 +371,7 @@ pub fn require_unique_names(diagnostic: @SpanHandler, metas: &[@MetaItem]) {\n     for meta in metas.iter() {\n         let name = meta.name();\n \n-        if !set.insert(name) {\n+        if !set.insert(name.clone()) {\n             diagnostic.span_fatal(meta.span,\n                                   format!(\"duplicate meta item `{}`\", name));\n         }\n@@ -384,14 +395,14 @@ pub fn find_repr_attr(diagnostic: @SpanHandler, attr: @ast::MetaItem, acc: ReprA\n     -> ReprAttr {\n     let mut acc = acc;\n     match attr.node {\n-        ast::MetaList(s, ref items) if \"repr\" == s => {\n+        ast::MetaList(ref s, ref items) if s.equiv(&(\"repr\")) => {\n             for item in items.iter() {\n                 match item.node {\n-                    ast::MetaWord(word) => {\n-                        let hint = match word.as_slice() {\n+                    ast::MetaWord(ref word) => {\n+                        let hint = match word.get() {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n                             \"C\" => ReprExtern,\n-                            _ => match int_type_of_word(word) {\n+                            _ => match int_type_of_word(word.get()) {\n                                 Some(ity) => ReprInt(item.span, ity),\n                                 None => {\n                                     // Not a word we recognize"}, {"sha": "884bd831ce8cd1dd9f7a6c3516beb6898a03b6fe", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -228,9 +228,17 @@ pub trait AstBuilder {\n \n     fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: @str) -> @ast::MetaItem;\n-    fn meta_list(&self, sp: Span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem;\n-    fn meta_name_value(&self, sp: Span, name: @str, value: ast::Lit_) -> @ast::MetaItem;\n+    fn meta_word(&self, sp: Span, w: InternedString) -> @ast::MetaItem;\n+    fn meta_list(&self,\n+                 sp: Span,\n+                 name: InternedString,\n+                 mis: ~[@ast::MetaItem])\n+                 -> @ast::MetaItem;\n+    fn meta_name_value(&self,\n+                       sp: Span,\n+                       name: InternedString,\n+                       value: ast::Lit_)\n+                       -> @ast::MetaItem;\n \n     fn view_use(&self, sp: Span,\n                 vis: ast::Visibility, vp: ~[@ast::ViewPath]) -> ast::ViewItem;\n@@ -866,13 +874,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn meta_word(&self, sp: Span, w: @str) -> @ast::MetaItem {\n+    fn meta_word(&self, sp: Span, w: InternedString) -> @ast::MetaItem {\n         @respan(sp, ast::MetaWord(w))\n     }\n-    fn meta_list(&self, sp: Span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem {\n+    fn meta_list(&self,\n+                 sp: Span,\n+                 name: InternedString,\n+                 mis: ~[@ast::MetaItem])\n+                 -> @ast::MetaItem {\n         @respan(sp, ast::MetaList(name, mis))\n     }\n-    fn meta_name_value(&self, sp: Span, name: @str, value: ast::Lit_) -> @ast::MetaItem {\n+    fn meta_name_value(&self,\n+                       sp: Span,\n+                       name: InternedString,\n+                       value: ast::Lit_)\n+                       -> @ast::MetaItem {\n         @respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n     }\n "}, {"sha": "295c456c9d0bc316e085fe9949bd2dfdae8c1ffa", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -21,9 +21,10 @@ use ext::base;\n use ext::build::AstBuilder;\n use attr;\n use attr::*;\n-use parse;\n-use parse::token;\n use parse::attr::ParserAttr;\n+use parse::token::InternedString;\n+use parse::token;\n+use parse;\n \n pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n@@ -39,7 +40,7 @@ pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::M\n     }\n \n     // test_cfg searches for meta items looking like `cfg(foo, ...)`\n-    let in_cfg = &[cx.meta_list(sp, @\"cfg\", cfgs)];\n+    let in_cfg = &[cx.meta_list(sp, InternedString::new(\"cfg\"), cfgs)];\n \n     let matches_cfg = attr::test_cfg(cx.cfg(), in_cfg.iter().map(|&x| x));\n     let e = cx.expr_bool(sp, matches_cfg);"}, {"sha": "20a515692e12219b0bfab8593f30a1cc8e188ebc", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -184,6 +184,7 @@ use ext::build::AstBuilder;\n use codemap;\n use codemap::Span;\n use opt_vec;\n+use parse::token::InternedString;\n \n use std::vec;\n \n@@ -396,7 +397,7 @@ impl<'a> TraitDef<'a> {\n         let doc_attr = cx.attribute(\n             self.span,\n             cx.meta_name_value(self.span,\n-                               @\"doc\",\n+                               InternedString::new(\"doc\"),\n                                ast::LitStr(@\"Automatically derived.\", ast::CookedStr)));\n         cx.item(\n             self.span,\n@@ -567,7 +568,14 @@ impl<'a> MethodDef<'a> {\n         let body_block = trait_.cx.block_expr(body);\n \n         let attrs = if self.inline {\n-            ~[trait_.cx.attribute(trait_.span, trait_.cx.meta_word(trait_.span, @\"inline\"))]\n+            ~[\n+                trait_.cx\n+                      .attribute(trait_.span,\n+                                 trait_.cx\n+                                       .meta_word(trait_.span,\n+                                                  InternedString::new(\n+                                                      \"inline\")))\n+            ]\n         } else {\n             ~[]\n         };"}, {"sha": "9c487146639bb2fc380303305d1f0d7f104dd17b", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -75,12 +75,12 @@ pub fn expand_meta_deriving(cx: &ExtCtxt,\n         MetaList(_, ref titems) => {\n             titems.rev_iter().fold(in_items, |in_items, &titem| {\n                 match titem.node {\n-                    MetaNameValue(tname, _) |\n-                    MetaList(tname, _) |\n-                    MetaWord(tname) => {\n+                    MetaNameValue(ref tname, _) |\n+                    MetaList(ref tname, _) |\n+                    MetaWord(ref tname) => {\n                         macro_rules! expand(($func:path) => ($func(cx, titem.span,\n                                                                    titem, in_items)));\n-                        match tname.as_slice() {\n+                        match tname.get() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n                             \"DeepClone\" => expand!(clone::expand_deriving_deep_clone),\n "}, {"sha": "d98a549725cde2fcb11a3bedc3a0eb6b515f96ea", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -221,12 +221,12 @@ pub fn expand_mod_items(module_: &ast::Mod, fld: &mut MacroExpander) -> ast::Mod\n         item.attrs.rev_iter().fold(~[*item], |items, attr| {\n             let mname = attr.name();\n \n-            match fld.extsbox.find(&intern(mname)) {\n+            match fld.extsbox.find(&intern(mname.get())) {\n               Some(&ItemDecorator(dec_fn)) => {\n                   fld.cx.bt_push(ExpnInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n-                          name: mname,\n+                          name: mname.get().to_managed(),\n                           format: MacroAttribute,\n                           span: None\n                       }"}, {"sha": "5730d435c150e4a19316fdd6e6a5641383691e00", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -14,9 +14,10 @@ use codemap::{Span, respan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n-use rsparse = parse;\n-use parse::token;\n use opt_vec;\n+use parse::token::InternedString;\n+use parse::token;\n+use rsparse = parse;\n use std::fmt::parse;\n use std::hashmap::{HashMap, HashSet};\n use std::vec;\n@@ -333,13 +334,18 @@ impl<'a> Context<'a> {\n     fn static_attrs(&self) -> ~[ast::Attribute] {\n         // Flag statics as `address_insignificant` so LLVM can merge duplicate\n         // globals as much as possible (which we're generating a whole lot of).\n-        let unnamed = self.ecx.meta_word(self.fmtsp, @\"address_insignificant\");\n+        let unnamed = self.ecx\n+                          .meta_word(self.fmtsp,\n+                                     InternedString::new(\n+                                         \"address_insignificant\"));\n         let unnamed = self.ecx.attribute(self.fmtsp, unnamed);\n \n         // Do not warn format string as dead code\n-        let dead_code = self.ecx.meta_word(self.fmtsp, @\"dead_code\");\n+        let dead_code = self.ecx.meta_word(self.fmtsp,\n+                                           InternedString::new(\"dead_code\"));\n         let allow_dead_code = self.ecx.meta_list(self.fmtsp,\n-                                                 @\"allow\", ~[dead_code]);\n+                                                 InternedString::new(\"allow\"),\n+                                                 ~[dead_code]);\n         let allow_dead_code = self.ecx.attribute(self.fmtsp, allow_dead_code);\n         return ~[unnamed, allow_dead_code];\n     }"}, {"sha": "c2d54a4f368c828d40dc7b1c3347e49806bed23b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -321,15 +321,12 @@ fn fold_meta_item_<T: Folder>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n     @Spanned {\n         node:\n             match mi.node {\n-                MetaWord(id) => MetaWord(id),\n-                MetaList(id, ref mis) => {\n+                MetaWord(ref id) => MetaWord((*id).clone()),\n+                MetaList(ref id, ref mis) => {\n                     let fold_meta_item = |x| fold_meta_item_(x, fld);\n-                    MetaList(\n-                        id,\n-                        mis.map(|e| fold_meta_item(*e))\n-                    )\n+                    MetaList((*id).clone(), mis.map(|e| fold_meta_item(*e)))\n                 }\n-                MetaNameValue(id, s) => MetaNameValue(id, s)\n+                MetaNameValue(ref id, s) => MetaNameValue((*id).clone(), s)\n             },\n         span: fld.new_span(mi.span) }\n }"}, {"sha": "bc9f7e4b19535870b75ce6cbf38b1c0c28247890", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -157,7 +157,7 @@ impl ParserAttr for Parser {\n     fn parse_meta_item(&mut self) -> @ast::MetaItem {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n-        let name = self.id_to_str(ident);\n+        let name = self.id_to_interned_str(ident);\n         match self.token {\n             token::EQ => {\n                 self.bump();"}, {"sha": "93264f5a6c68d239198651a385648378da13738b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -71,10 +71,10 @@ use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n use parse::lexer::Reader;\n use parse::lexer::TokenAndSpan;\n use parse::obsolete::*;\n-use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident};\n-use parse::token::{is_ident_or_path};\n-use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents};\n-use parse::token::{token_to_binop};\n+use parse::token::{INTERPOLATED, InternedString, can_begin_expr, get_ident};\n+use parse::token::{get_ident_interner, ident_to_str, is_ident};\n+use parse::token::{is_ident_or_path, is_plain_ident, keywords};\n+use parse::token::{special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n use opt_vec;\n@@ -806,6 +806,10 @@ impl Parser {\n         get_ident_interner().get(id.name)\n     }\n \n+    pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n+        get_ident(id.name)\n+    }\n+\n     // Is the current token one of the keywords that signals a bare function\n     // type?\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {"}, {"sha": "97b9b4d53a4357a590539faf0b5efcf598b94ff1", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -15,8 +15,10 @@ use parse::token;\n use util::interner::StrInterner;\n use util::interner;\n \n+use extra::serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::cast;\n use std::char;\n+use std::fmt;\n use std::local_data;\n \n #[allow(non_camel_case_types)]\n@@ -525,13 +527,98 @@ pub fn get_ident_interner() -> @IdentInterner {\n     }\n }\n \n+/// Represents a string stored in the task-local interner. Because the\n+/// interner lives for the life of the task, this can be safely treated as an\n+/// immortal string, as long as it never crosses between tasks.\n+///\n+/// XXX(pcwalton): You must be careful about what you do in the destructors of\n+/// objects stored in TLS, because they may run after the interner is\n+/// destroyed. In particular, they must not access string contents. This can\n+/// be fixed in the future by just leaking all strings until task death\n+/// somehow.\n+#[no_send]\n+#[deriving(Clone, Eq, IterBytes, TotalEq, TotalOrd)]\n+pub struct InternedString {\n+    priv string: @str,\n+}\n+\n+#[unsafe_destructor]\n+impl Drop for InternedString {\n+    fn drop(&mut self) {\n+        // No-op just to make this not implicitly copyable.\n+    }\n+}\n+\n+impl InternedString {\n+    #[inline]\n+    pub fn new(string: &'static str) -> InternedString {\n+        InternedString {\n+            string: string.to_managed(),\n+        }\n+    }\n+\n+    // NB: Do not make this public. We are trying to remove `@str`.\n+    #[inline]\n+    fn new_from_at_str(string: @str) -> InternedString {\n+        InternedString {\n+            string: string,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get<'a>(&'a self) -> &'a str {\n+        self.string.as_slice()\n+    }\n+}\n+\n+impl fmt::Default for InternedString {\n+    fn fmt(obj: &InternedString, f: &mut fmt::Formatter) {\n+        write!(f.buf, \"{}\", obj.string);\n+    }\n+}\n+\n+impl<'a> Equiv<&'a str> for InternedString {\n+    fn equiv(&self, other: & &'a str) -> bool {\n+        (*other) == self.string.as_slice()\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for InternedString {\n+    fn decode(d: &mut D) -> InternedString {\n+        let interner = get_ident_interner();\n+        get_ident(interner.intern(d.read_str()))\n+    }\n+}\n+\n+impl<E:Encoder> Encodable<E> for InternedString {\n+    fn encode(&self, e: &mut E) {\n+        e.emit_str(self.string)\n+    }\n+}\n+\n+/// Returns the string contents of an identifier, using the task-local\n+/// interner.\n+#[inline]\n+pub fn get_ident(idx: Name) -> InternedString {\n+    let interner = get_ident_interner();\n+    InternedString::new_from_at_str(interner.get(idx))\n+}\n+\n+/// Interns and returns the string contents of an identifier, using the\n+/// task-local interner.\n+#[inline]\n+pub fn intern_and_get_ident(s: &str) -> InternedString {\n+    get_ident(intern(s))\n+}\n+\n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n pub fn mk_fake_ident_interner() -> @IdentInterner {\n     @interner::StrInterner::new()\n }\n \n // maps a string to its interned representation\n+#[inline]\n pub fn intern(str : &str) -> Name {\n     let interner = get_ident_interner();\n     interner.intern(str)"}, {"sha": "89d8173f7e76f8d76ab337134f5cf63346e0050b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -1930,14 +1930,14 @@ pub fn print_generics(s: &mut State, generics: &ast::Generics) {\n pub fn print_meta_item(s: &mut State, item: &ast::MetaItem) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::MetaWord(name) => word(&mut s.s, name),\n-      ast::MetaNameValue(name, value) => {\n-        word_space(s, name);\n+      ast::MetaWord(ref name) => word(&mut s.s, name.get()),\n+      ast::MetaNameValue(ref name, value) => {\n+        word_space(s, name.get());\n         word_space(s, \"=\");\n         print_literal(s, &value);\n       }\n-      ast::MetaList(name, ref items) => {\n-        word(&mut s.s, name);\n+      ast::MetaList(ref name, ref items) => {\n+        word(&mut s.s, name.get());\n         popen(s);\n         commasep(s,\n                  Consistent,"}, {"sha": "c0fe19ede0130dfbef21ea1d65b874b5788f5a5f", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "patch": "@@ -14,6 +14,7 @@\n \n use ast::Name;\n \n+use std::cast;\n use std::cell::RefCell;\n use std::cmp::Equiv;\n use std::hashmap::HashMap;\n@@ -151,6 +152,16 @@ impl StrInterner {\n         vect.get()[idx]\n     }\n \n+    /// Returns this string with lifetime tied to the interner. Since\n+    /// strings may never be removed from the interner, this is safe.\n+    pub fn get_ref<'a>(&'a self, idx: Name) -> &'a str {\n+        let vect = self.vect.borrow();\n+        let s: &str = vect.get()[idx];\n+        unsafe {\n+            cast::transmute(s)\n+        }\n+    }\n+\n     pub fn len(&self) -> uint {\n         let vect = self.vect.borrow();\n         vect.get().len()"}]}