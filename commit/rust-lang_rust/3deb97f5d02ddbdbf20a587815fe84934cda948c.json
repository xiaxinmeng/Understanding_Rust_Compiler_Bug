{"sha": "3deb97f5d02ddbdbf20a587815fe84934cda948c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZWI5N2Y1ZDAyZGRiZGJmMjBhNTg3ODE1ZmU4NDkzNGNkYTk0OGM=", "commit": {"author": {"name": "Josh Stone", "email": "cuviper@gmail.com", "date": "2014-12-10T06:06:52Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-12-20T14:10:04Z"}, "message": "bitv: Fix all() for nbits that are multiples of u32::BITS\n\nThe old logic would be ok with *either* 0 or all 1s in the last word,\nbecause it didn't compute a proper mask for the case where nbits is an\nexact multiple of u32::BITS.\n\nAdd mask_for_bits() to compute this properly, and use it in all().  Add\nall/none assertions to most of the tests.  Note in particular, the all-zero\nbitv in test_32_elements() was incorrectly all()==true before this patch.", "tree": {"sha": "b74e83efd28a5a494e7d272aaddef319fd9e79dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b74e83efd28a5a494e7d272aaddef319fd9e79dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3deb97f5d02ddbdbf20a587815fe84934cda948c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3deb97f5d02ddbdbf20a587815fe84934cda948c", "html_url": "https://github.com/rust-lang/rust/commit/3deb97f5d02ddbdbf20a587815fe84934cda948c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3deb97f5d02ddbdbf20a587815fe84934cda948c/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f194de95d00fe540d848cc9a7d3e049ce3684ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f194de95d00fe540d848cc9a7d3e049ce3684ab", "html_url": "https://github.com/rust-lang/rust/commit/8f194de95d00fe540d848cc9a7d3e049ce3684ab"}], "stats": {"total": 51, "additions": 43, "deletions": 8}, "files": [{"sha": "5cf5183d25d5e4daab2e708fa4dc1e1f7aa11b39", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3deb97f5d02ddbdbf20a587815fe84934cda948c/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3deb97f5d02ddbdbf20a587815fe84934cda948c/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=3deb97f5d02ddbdbf20a587815fe84934cda948c", "patch": "@@ -174,6 +174,12 @@ fn blocks_for_bits(bits: uint) -> uint {\n \n }\n \n+/// Computes the bitmask for the final word of the vector\n+fn mask_for_bits(bits: uint) -> u32 {\n+    // Note especially that a perfect multiple of u32::BITS should mask all 1s.\n+    !0u32 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n+}\n+\n impl Bitv {\n     /// Applies the given operation to the blocks of self and other, and sets self to\n     /// be the result.\n@@ -526,7 +532,7 @@ impl Bitv {\n             last_word = elem;\n             tmp == !0u32\n         // and then check the last one has enough ones\n-        }) && (last_word == ((1 << self.nbits % u32::BITS) - 1) || last_word == !0u32)\n+        }) && (last_word == mask_for_bits(self.nbits))\n     }\n \n     /// Returns an iterator over the elements of the vector in order.\n@@ -788,15 +794,15 @@ impl Bitv {\n         let new_nblocks = blocks_for_bits(new_nbits);\n         let full_value = if value { !0 } else { 0 };\n \n-        // Correct the old tail word\n+        // Correct the old tail word, setting or clearing formerly unused bits\n         let old_last_word = blocks_for_bits(self.nbits) - 1;\n         if self.nbits % u32::BITS > 0 {\n-            let overhang = self.nbits % u32::BITS; // # of already-used bits\n-            let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110..0\n+            let mask = mask_for_bits(self.nbits);\n             if value {\n-                self.storage[old_last_word] |= mask;\n+                self.storage[old_last_word] |= !mask;\n             } else {\n-                self.storage[old_last_word] &= !mask;\n+                // Extra bits are already supposed to be zero by invariant, but play it safe...\n+                self.storage[old_last_word] &= mask;\n             }\n         }\n \n@@ -1808,14 +1814,17 @@ mod tests {\n         let act = Bitv::new();\n         let exp = Vec::from_elem(0u, false);\n         assert!(act.eq_vec(exp.as_slice()));\n+        assert!(act.none() && act.all());\n     }\n \n     #[test]\n     fn test_1_element() {\n         let mut act = Bitv::from_elem(1u, false);\n         assert!(act.eq_vec(&[false]));\n+        assert!(act.none() && !act.all());\n         act = Bitv::from_elem(1u, true);\n         assert!(act.eq_vec(&[true]));\n+        assert!(!act.none() && act.all());\n     }\n \n     #[test]\n@@ -1824,6 +1833,7 @@ mod tests {\n         b.set(0, true);\n         b.set(1, false);\n         assert_eq!(b.to_string(), \"10\");\n+        assert!(!b.none() && !b.all());\n     }\n \n     #[test]\n@@ -1834,10 +1844,12 @@ mod tests {\n         act = Bitv::from_elem(10u, false);\n         assert!((act.eq_vec(\n                     &[false, false, false, false, false, false, false, false, false, false])));\n+        assert!(act.none() && !act.all());\n         // all 1\n \n         act = Bitv::from_elem(10u, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n+        assert!(!act.none() && act.all());\n         // mixed\n \n         act = Bitv::from_elem(10u, false);\n@@ -1847,6 +1859,7 @@ mod tests {\n         act.set(3u, true);\n         act.set(4u, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(10u, false);\n@@ -1856,6 +1869,7 @@ mod tests {\n         act.set(8u, true);\n         act.set(9u, true);\n         assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(10u, false);\n@@ -1864,6 +1878,7 @@ mod tests {\n         act.set(6u, true);\n         act.set(9u, true);\n         assert!((act.eq_vec(&[true, false, false, true, false, false, true, false, false, true])));\n+        assert!(!act.none() && !act.all());\n     }\n \n     #[test]\n@@ -1876,13 +1891,15 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n+        assert!(act.none() && !act.all());\n         // all 1\n \n         act = Bitv::from_elem(31u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true]));\n+        assert!(!act.none() && act.all());\n         // mixed\n \n         act = Bitv::from_elem(31u, false);\n@@ -1898,6 +1915,7 @@ mod tests {\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(31u, false);\n@@ -1913,6 +1931,7 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(31u, false);\n@@ -1927,6 +1946,7 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(31u, false);\n@@ -1937,6 +1957,7 @@ mod tests {\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n                   false, false, false, false, false, false, true]));\n+        assert!(!act.none() && !act.all());\n     }\n \n     #[test]\n@@ -1949,13 +1970,15 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false]));\n+        assert!(act.none() && !act.all());\n         // all 1\n \n         act = Bitv::from_elem(32u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true]));\n+        assert!(!act.none() && act.all());\n         // mixed\n \n         act = Bitv::from_elem(32u, false);\n@@ -1971,6 +1994,7 @@ mod tests {\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(32u, false);\n@@ -1986,6 +2010,7 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(32u, false);\n@@ -2001,6 +2026,7 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true, true]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(32u, false);\n@@ -2012,6 +2038,7 @@ mod tests {\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n                   false, false, false, false, false, false, true, true]));\n+        assert!(!act.none() && !act.all());\n     }\n \n     #[test]\n@@ -2024,13 +2051,15 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false]));\n+        assert!(act.none() && !act.all());\n         // all 1\n \n         act = Bitv::from_elem(33u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true]));\n+        assert!(!act.none() && act.all());\n         // mixed\n \n         act = Bitv::from_elem(33u, false);\n@@ -2046,6 +2075,7 @@ mod tests {\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(33u, false);\n@@ -2061,6 +2091,7 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(33u, false);\n@@ -2076,6 +2107,7 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true, true, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n         act = Bitv::from_elem(33u, false);\n@@ -2088,6 +2120,7 @@ mod tests {\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n                   false, false, false, false, false, false, true, true, true]));\n+        assert!(!act.none() && !act.all());\n     }\n \n     #[test]\n@@ -2234,15 +2267,17 @@ mod tests {\n     #[test]\n     fn test_small_clear() {\n         let mut b = Bitv::from_elem(14, true);\n+        assert!(!b.none() && b.all());\n         b.clear();\n-        assert!(b.none());\n+        assert!(b.none() && !b.all());\n     }\n \n     #[test]\n     fn test_big_clear() {\n         let mut b = Bitv::from_elem(140, true);\n+        assert!(!b.none() && b.all());\n         b.clear();\n-        assert!(b.none());\n+        assert!(b.none() && !b.all());\n     }\n \n     #[test]"}]}