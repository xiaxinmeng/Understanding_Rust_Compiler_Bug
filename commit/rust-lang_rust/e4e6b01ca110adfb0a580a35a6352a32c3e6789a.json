{"sha": "e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZTZiMDFjYTExMGFkZmIwYTU4MGEzNWE2MzUyYTMyYzNlNjc4OWE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-29T11:17:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-29T11:17:52Z"}, "message": "Rollup merge of #63867 - petrochenkov:dhelpers, r=matthewjasper\n\nresolve: Block expansion of a derive container until all its derives are resolved\n\nSo, it turns out there's one more reason to block expansion of a `#[derive]` container until all the derives inside it are resolved, beside `Copy` (https://github.com/rust-lang/rust/pull/63248).\n\nThe set of derive helper attributes registered by derives in the container also has to be known before the derives themselves are expanded, otherwise it may be too late (see https://github.com/rust-lang/rust/pull/63468#issuecomment-524550872 and the `#[stable_hasher]`-related test failures in https://github.com/rust-lang/rust/pull/63468).\n\nSo, we stop our attempts to unblock the container earlier, as soon as the `Copy` status is known, and just block until all its derives are resolved.\nAfter all the derives are resolved we immediately go and process their helper attributes in the item, without delaying it until expansion of the individual derives.\n\nUnblocks https://github.com/rust-lang/rust/pull/63468\nr? @matthewjasper (as a reviewer of https://github.com/rust-lang/rust/pull/63248)\ncc @c410-f3r", "tree": {"sha": "daa05b4a15291c134972dfbb0165728ae41a09ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daa05b4a15291c134972dfbb0165728ae41a09ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdZ7RgCRBK7hj4Ov3rIwAAdHIIALBmUzgMceIitPOshv9NGtHh\nRpmnc3Oh4BFmAEy4eufVrEOhyZASD9DMqSNIOD9PAPOsiiHd3Xyuk6bVSDvbYdOM\nenDfwGM4db7u8ftJyo2XYe+/z064f3LkJW/aqyBwcsgNlRp2eghpx9wCrwTL00L8\n67FBGMtEtHjwVAs2B9bsnPC6N8JRAy4ZjI7R102C7gBF34dSDylabzOFNsjXZZr/\nabiWjo8ZSFWlapVIWI1dlqhFvzAvRWEZKm+zP0G6EuDZ0UFUvy+Sab9WooGUBeLJ\n2lZi3FXQjMRhwBWeVmFcLrVGXRbh1YyIkzCwczcFi0QIxkAkW9uVLTVBV1ff39Y=\n=3bnr\n-----END PGP SIGNATURE-----\n", "payload": "tree daa05b4a15291c134972dfbb0165728ae41a09ff\nparent 85ed538d6988c6c82aea8750b306cb793e874294\nparent ec45b87957c4158934fc3f5a821594ad0686ea4e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567077472 +0200\ncommitter GitHub <noreply@github.com> 1567077472 +0200\n\nRollup merge of #63867 - petrochenkov:dhelpers, r=matthewjasper\n\nresolve: Block expansion of a derive container until all its derives are resolved\n\nSo, it turns out there's one more reason to block expansion of a `#[derive]` container until all the derives inside it are resolved, beside `Copy` (https://github.com/rust-lang/rust/pull/63248).\n\nThe set of derive helper attributes registered by derives in the container also has to be known before the derives themselves are expanded, otherwise it may be too late (see https://github.com/rust-lang/rust/pull/63468#issuecomment-524550872 and the `#[stable_hasher]`-related test failures in https://github.com/rust-lang/rust/pull/63468).\n\nSo, we stop our attempts to unblock the container earlier, as soon as the `Copy` status is known, and just block until all its derives are resolved.\nAfter all the derives are resolved we immediately go and process their helper attributes in the item, without delaying it until expansion of the individual derives.\n\nUnblocks https://github.com/rust-lang/rust/pull/63468\nr? @matthewjasper (as a reviewer of https://github.com/rust-lang/rust/pull/63248)\ncc @c410-f3r\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "html_url": "https://github.com/rust-lang/rust/commit/e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ed538d6988c6c82aea8750b306cb793e874294", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ed538d6988c6c82aea8750b306cb793e874294", "html_url": "https://github.com/rust-lang/rust/commit/85ed538d6988c6c82aea8750b306cb793e874294"}, {"sha": "ec45b87957c4158934fc3f5a821594ad0686ea4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec45b87957c4158934fc3f5a821594ad0686ea4e", "html_url": "https://github.com/rust-lang/rust/commit/ec45b87957c4158934fc3f5a821594ad0686ea4e"}], "stats": {"total": 348, "additions": 195, "deletions": 153}, "files": [{"sha": "cdee14d07fb4d42271e6752decf117a760c8265e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -527,9 +527,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n                 (\n                     trait_name,\n-                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                        client, attrs: helper_attrs.clone()\n-                    })),\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive { client })),\n                     helper_attrs,\n                 )\n             }"}, {"sha": "7224bd74230b399c2619fd42986f6011164b53ca", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -13,7 +13,7 @@ use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n-use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n+use syntax::ext::base::{self, InvocationRes, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n@@ -142,7 +142,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro_invocation(\n         &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n-    ) -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n+    ) -> Result<InvocationRes, Indeterminate> {\n         let invoc_id = invoc.expansion_data.id;\n         let parent_scope = match self.invocation_parent_scopes.get(&invoc_id) {\n             Some(parent_scope) => *parent_scope,\n@@ -165,25 +165,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Derive { ref path, .. } =>\n                 (path, MacroKind::Derive, &[][..], false),\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n-                // Block expansion of derives in the container until we know whether one of them\n-                // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n-                // it's not a `Copy` and we don't need to do anything, or it's a `Copy` and it\n-                // will automatically knows about itself.\n-                let mut result = Ok(None);\n-                if derives.len() > 1 {\n-                    for path in derives {\n-                        match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      &parent_scope, true, force) {\n-                            Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n-                                self.add_derives(invoc_id, SpecialDerives::COPY);\n-                                return Ok(None);\n-                            }\n-                            Err(Determinacy::Undetermined) => result = Err(Indeterminate),\n-                            _ => {}\n-                        }\n-                    }\n+                // Block expansion of the container until we resolve all derives in it.\n+                // This is required for two reasons:\n+                // - Derive helper attributes are in scope for the item to which the `#[derive]`\n+                //   is applied, so they have to be produced by the container's expansion rather\n+                //   than by individual derives.\n+                // - Derives in the container need to know whether one of them is a built-in `Copy`.\n+                // FIXME: Try to avoid repeated resolutions for derives here and in expansion.\n+                let mut exts = Vec::new();\n+                for path in derives {\n+                    exts.push(match self.resolve_macro_path(\n+                        path, Some(MacroKind::Derive), &parent_scope, true, force\n+                    ) {\n+                        Ok((Some(ext), _)) => ext,\n+                        Ok(_) | Err(Determinacy::Determined) => self.dummy_ext(MacroKind::Derive),\n+                        Err(Determinacy::Undetermined) => return Err(Indeterminate),\n+                    })\n                 }\n-                return result;\n+                return Ok(InvocationRes::DeriveContainer(exts));\n             }\n         };\n \n@@ -203,7 +202,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n         }\n \n-        Ok(Some(ext))\n+        Ok(InvocationRes::Single(ext))\n     }\n \n     fn check_unused_macros(&self) {"}, {"sha": "5d68983d7cb66647515c195cda7b9cb3a50d0b4e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -11,6 +11,7 @@ use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n use crate::{ThinVec, MACRO_ARGUMENTS};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n+use crate::visit::Visitor;\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n@@ -72,6 +73,17 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n+        match self {\n+            Annotatable::Item(item) => visitor.visit_item(item),\n+            Annotatable::TraitItem(trait_item) => visitor.visit_trait_item(trait_item),\n+            Annotatable::ImplItem(impl_item) => visitor.visit_impl_item(impl_item),\n+            Annotatable::ForeignItem(foreign_item) => visitor.visit_foreign_item(foreign_item),\n+            Annotatable::Stmt(stmt) => visitor.visit_stmt(stmt),\n+            Annotatable::Expr(expr) => visitor.visit_expr(expr),\n+        }\n+    }\n+\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -700,6 +712,12 @@ impl SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n+/// Result of resolving a macro invocation.\n+pub enum InvocationRes {\n+    Single(Lrc<SyntaxExtension>),\n+    DeriveContainer(Vec<Lrc<SyntaxExtension>>),\n+}\n+\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n@@ -727,7 +745,7 @@ pub trait Resolver {\n \n     fn resolve_macro_invocation(\n         &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n-    ) -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n+    ) -> Result<InvocationRes, Indeterminate>;\n \n     fn check_unused_macros(&self);\n "}, {"sha": "7b4a516744642075301dec2c73e4cb21aacb85e6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 66, "deletions": 48, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -4,7 +4,7 @@ use crate::attr::{self, HasAttrs};\n use crate::source_map::respan;\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n-use crate::ext::proc_macro::collect_derives;\n+use crate::ext::proc_macro::{collect_derives, MarkAttrs};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -307,10 +307,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let eager_expansion_root =\n                 if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n-            let ext = match self.cx.resolver.resolve_macro_invocation(\n+            let res = match self.cx.resolver.resolve_macro_invocation(\n                 &invoc, eager_expansion_root, force\n             ) {\n-                Ok(ext) => ext,\n+                Ok(res) => res,\n                 Err(Indeterminate) => {\n                     undetermined_invocations.push(invoc);\n                     continue\n@@ -322,54 +322,72 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n             // FIXME(jseyfried): Refactor out the following logic\n-            let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n-                let fragment = self.expand_invoc(invoc, &ext.kind);\n-                self.collect_invocations(fragment, &[])\n-            } else if let InvocationKind::DeriveContainer { derives: traits, item } = invoc.kind {\n-                if !item.derive_allowed() {\n-                    let attr = attr::find_by_name(item.attrs(), sym::derive)\n-                        .expect(\"`derive` attribute should exist\");\n-                    let span = attr.span;\n-                    let mut err = self.cx.mut_span_err(span,\n-                                                        \"`derive` may only be applied to \\\n-                                                        structs, enums and unions\");\n-                    if let ast::AttrStyle::Inner = attr.style {\n-                        let trait_list = traits.iter()\n-                            .map(|t| t.to_string()).collect::<Vec<_>>();\n-                        let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                        err.span_suggestion(\n-                            span, \"try an outer attribute\", suggestion,\n-                            // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                            Applicability::MaybeIncorrect\n-                        );\n-                    }\n-                    err.emit();\n+            let (expanded_fragment, new_invocations) = match res {\n+                InvocationRes::Single(ext) => {\n+                    let fragment = self.expand_invoc(invoc, &ext.kind);\n+                    self.collect_invocations(fragment, &[])\n                 }\n+                InvocationRes::DeriveContainer(exts) => {\n+                    let (derives, item) = match invoc.kind {\n+                        InvocationKind::DeriveContainer { derives, item } => (derives, item),\n+                        _ => unreachable!(),\n+                    };\n+                    if !item.derive_allowed() {\n+                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n+                            .expect(\"`derive` attribute should exist\");\n+                        let span = attr.span;\n+                        let mut err = self.cx.mut_span_err(span,\n+                            \"`derive` may only be applied to structs, enums and unions\");\n+                        if let ast::AttrStyle::Inner = attr.style {\n+                            let trait_list = derives.iter()\n+                                .map(|t| t.to_string()).collect::<Vec<_>>();\n+                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+                            err.span_suggestion(\n+                                span, \"try an outer attribute\", suggestion,\n+                                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n+                                Applicability::MaybeIncorrect\n+                            );\n+                        }\n+                        err.emit();\n+                    }\n \n-                let mut item = self.fully_configure(item);\n-                item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derive_placeholders =\n-                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n-\n-                derive_placeholders.reserve(traits.len());\n-                invocations.reserve(traits.len());\n-                for path in traits {\n-                    let expn_id = ExpnId::fresh(None);\n-                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                    invocations.push(Invocation {\n-                        kind: InvocationKind::Derive { path, item: item.clone() },\n-                        fragment_kind: invoc.fragment_kind,\n-                        expansion_data: ExpansionData {\n-                            id: expn_id,\n-                            ..invoc.expansion_data.clone()\n-                        },\n-                    });\n+                    let mut item = self.fully_configure(item);\n+                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n+                    let mut helper_attrs = Vec::new();\n+                    let mut has_copy = false;\n+                    for ext in exts {\n+                        helper_attrs.extend(&ext.helper_attrs);\n+                        has_copy |= ext.is_derive_copy;\n+                    }\n+                    // Mark derive helpers inside this item as known and used.\n+                    // FIXME: This is a hack, derive helpers should be integrated with regular name\n+                    // resolution instead. For example, helpers introduced by a derive container\n+                    // can be in scope for all code produced by that container's expansion.\n+                    item.visit_with(&mut MarkAttrs(&helper_attrs));\n+                    if has_copy {\n+                        self.cx.resolver.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n+                    }\n+\n+                    let derive_placeholders =\n+                        all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n+                    derive_placeholders.reserve(derives.len());\n+                    invocations.reserve(derives.len());\n+                    for path in derives {\n+                        let expn_id = ExpnId::fresh(None);\n+                        derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n+                        invocations.push(Invocation {\n+                            kind: InvocationKind::Derive { path, item: item.clone() },\n+                            fragment_kind: invoc.fragment_kind,\n+                            expansion_data: ExpansionData {\n+                                id: expn_id,\n+                                ..invoc.expansion_data.clone()\n+                            },\n+                        });\n+                    }\n+                    let fragment = invoc.fragment_kind\n+                        .expect_from_annotatables(::std::iter::once(item));\n+                    self.collect_invocations(fragment, derive_placeholders)\n                 }\n-                let fragment = invoc.fragment_kind\n-                    .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derive_placeholders)\n-            } else {\n-                unreachable!()\n             };\n \n             if expanded_fragments.len() < depth {"}, {"sha": "4a44c9a9f1f312d7e690a37780dfea2ebb76a02e", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -78,7 +78,6 @@ pub struct ProcMacroDerive {\n     pub client: proc_macro::bridge::client::Client<\n         fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n     >,\n-    pub attrs: Vec<ast::Name>,\n }\n \n impl MultiItemModifier for ProcMacroDerive {\n@@ -111,9 +110,6 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         }\n \n-        // Mark attributes as known, and used.\n-        MarkAttrs(&self.attrs).visit_item(&item);\n-\n         let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n         let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n \n@@ -164,7 +160,7 @@ impl MultiItemModifier for ProcMacroDerive {\n     }\n }\n \n-struct MarkAttrs<'a>(&'a [ast::Name]);\n+crate struct MarkAttrs<'a>(crate &'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {"}, {"sha": "b18df3511817db7400d45c8e70fd84eb7546880b", "filename": "src/test/ui/derives/deriving-bounds.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -1,15 +1,3 @@\n-error: cannot find derive macro `Send` in this scope\n-  --> $DIR/deriving-bounds.rs:1:10\n-   |\n-LL | #[derive(Send)]\n-   |          ^^^^\n-   |\n-note: unsafe traits like `Send` should be implemented explicitly\n-  --> $DIR/deriving-bounds.rs:1:10\n-   |\n-LL | #[derive(Send)]\n-   |          ^^^^\n-\n error: cannot find derive macro `Sync` in this scope\n   --> $DIR/deriving-bounds.rs:5:10\n    |\n@@ -22,5 +10,17 @@ note: unsafe traits like `Sync` should be implemented explicitly\n LL | #[derive(Sync)]\n    |          ^^^^\n \n+error: cannot find derive macro `Send` in this scope\n+  --> $DIR/deriving-bounds.rs:1:10\n+   |\n+LL | #[derive(Send)]\n+   |          ^^^^\n+   |\n+note: unsafe traits like `Send` should be implemented explicitly\n+  --> $DIR/deriving-bounds.rs:1:10\n+   |\n+LL | #[derive(Send)]\n+   |          ^^^^\n+\n error: aborting due to 2 previous errors\n "}, {"sha": "f14591c85e62e3a16bbf2ed6e4af74ab02bec521", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -1,5 +1,5 @@\n error: cannot find derive macro `x3300` in this scope\n-  --> $DIR/issue-43106-gating-of-derive-2.rs:4:14\n+  --> $DIR/issue-43106-gating-of-derive-2.rs:12:14\n    |\n LL |     #[derive(x3300)]\n    |              ^^^^^\n@@ -11,7 +11,7 @@ LL |     #[derive(x3300)]\n    |              ^^^^^\n \n error: cannot find derive macro `x3300` in this scope\n-  --> $DIR/issue-43106-gating-of-derive-2.rs:12:14\n+  --> $DIR/issue-43106-gating-of-derive-2.rs:4:14\n    |\n LL |     #[derive(x3300)]\n    |              ^^^^^"}, {"sha": "c5d9e0db4d389a7acae0dc43eb38e2018ed33662", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -1,9 +1,6 @@\n // `#![derive]` raises errors when it occurs at contexts other than ADT\n // definitions.\n \n-#![derive(Debug)]\n-//~^ ERROR `derive` may only be applied to structs, enums and unions\n-\n #[derive(Debug)]\n //~^ ERROR `derive` may only be applied to structs, enums and unions\n mod derive {"}, {"sha": "db29a2bddd35c5b7a62c0d2a1962f5fb6eaa4064", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -1,38 +1,32 @@\n error: `derive` may only be applied to structs, enums and unions\n   --> $DIR/issue-43106-gating-of-derive.rs:4:1\n    |\n-LL | #![derive(Debug)]\n-   | ^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug)]`\n-\n-error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:7:1\n-   |\n LL | #[derive(Debug)]\n    | ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:10:17\n+  --> $DIR/issue-43106-gating-of-derive.rs:7:17\n    |\n LL |     mod inner { #![derive(Debug)] }\n    |                 ^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug)]`\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:13:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:10:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:26:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:23:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:30:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:27:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "1102f3c4640a188a3b0adb5785b4a11cc25cdb60", "filename": "src/test/ui/issues/issue-36617.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -1,3 +1,4 @@\n #![derive(Copy)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+                 //~| ERROR cannot determine resolution for the derive macro `Copy`\n \n fn main() {}"}, {"sha": "b5db98f306bd32e10e3e6dc6a04a80e1dd92a14b", "filename": "src/test/ui/issues/issue-36617.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -4,5 +4,13 @@ error: `derive` may only be applied to structs, enums and unions\n LL | #![derive(Copy)]\n    | ^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Copy)]`\n \n-error: aborting due to previous error\n+error: cannot determine resolution for the derive macro `Copy`\n+  --> $DIR/issue-36617.rs:1:11\n+   |\n+LL | #![derive(Copy)]\n+   |           ^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "243cf685e8145649517c8ec07247a751f956867a", "filename": "src/test/ui/proc-macro/derive-helper-configured.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -0,0 +1,18 @@\n+// Derive helpers are resolved successfully inside `cfg_attr`.\n+\n+// check-pass\n+// compile-flats:--cfg TRUE\n+// aux-build:test-macros.rs\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[cfg_attr(TRUE, empty_helper)]\n+#[derive(Empty)]\n+#[cfg_attr(TRUE, empty_helper)]\n+struct S {\n+    #[cfg_attr(TRUE, empty_helper)]\n+    field: u8,\n+}\n+\n+fn main() {}"}, {"sha": "21af4093a037de46f187556cfdd07ff63ad53d33", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -19,7 +19,8 @@ struct S {\n         struct U;\n \n         mod inner {\n-            #[empty_helper] //~ ERROR cannot find attribute macro `empty_helper` in this scope\n+            // FIXME No ambiguity, attributes in non-macro positions are not resolved properly\n+            #[empty_helper]\n             struct V;\n         }\n "}, {"sha": "2ba517ce29ee743520506c0507dcbb58bfa6dd12", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -1,9 +1,3 @@\n-error: cannot find attribute macro `empty_helper` in this scope\n-  --> $DIR/derive-helper-shadowing.rs:22:15\n-   |\n-LL |             #[empty_helper]\n-   |               ^^^^^^^^^^^^\n-\n error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/derive-helper-shadowing.rs:8:3\n    |\n@@ -22,6 +16,6 @@ LL | use test_macros::empty_attr as empty_helper;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "2a5f2b883813d48f71777fb6798be15ce5d0001a", "filename": "src/test/ui/proc-macro/resolve-error.stderr", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4e6b01ca110adfb0a580a35a6352a32c3e6789a/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr?ref=e4e6b01ca110adfb0a580a35a6352a32c3e6789a", "patch": "@@ -1,62 +1,62 @@\n-error: cannot find derive macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:22:10\n-   |\n-LL | #[derive(FooWithLongNan)]\n-   |          ^^^^^^^^^^^^^^ help: a derive macro with a similar name exists: `FooWithLongName`\n-\n-error: cannot find attribute macro `attr_proc_macra` in this scope\n-  --> $DIR/resolve-error.rs:27:3\n+error: cannot find macro `bang_proc_macrp!` in this scope\n+  --> $DIR/resolve-error.rs:56:5\n    |\n-LL | #[attr_proc_macra]\n-   |   ^^^^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `attr_proc_macro`\n+LL |     bang_proc_macrp!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `bang_proc_macro`\n \n-error: cannot find attribute macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:31:3\n+error: cannot find macro `Dlona!` in this scope\n+  --> $DIR/resolve-error.rs:53:5\n    |\n-LL | #[FooWithLongNan]\n-   |   ^^^^^^^^^^^^^^\n+LL |     Dlona!();\n+   |     ^^^^^\n \n-error: cannot find derive macro `Dlone` in this scope\n-  --> $DIR/resolve-error.rs:34:10\n+error: cannot find macro `attr_proc_macra!` in this scope\n+  --> $DIR/resolve-error.rs:50:5\n    |\n-LL | #[derive(Dlone)]\n-   |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n+LL |     attr_proc_macra!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `attr_proc_mac`\n \n-error: cannot find derive macro `Dlona` in this scope\n-  --> $DIR/resolve-error.rs:38:10\n+error: cannot find macro `FooWithLongNama!` in this scope\n+  --> $DIR/resolve-error.rs:47:5\n    |\n-LL | #[derive(Dlona)]\n-   |          ^^^^^ help: a derive macro with a similar name exists: `Clona`\n+LL |     FooWithLongNama!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `FooWithLongNam`\n \n error: cannot find derive macro `attr_proc_macra` in this scope\n   --> $DIR/resolve-error.rs:42:10\n    |\n LL | #[derive(attr_proc_macra)]\n    |          ^^^^^^^^^^^^^^^\n \n-error: cannot find macro `FooWithLongNama!` in this scope\n-  --> $DIR/resolve-error.rs:47:5\n+error: cannot find derive macro `Dlona` in this scope\n+  --> $DIR/resolve-error.rs:38:10\n    |\n-LL |     FooWithLongNama!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `FooWithLongNam`\n+LL | #[derive(Dlona)]\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clona`\n \n-error: cannot find macro `attr_proc_macra!` in this scope\n-  --> $DIR/resolve-error.rs:50:5\n+error: cannot find derive macro `Dlone` in this scope\n+  --> $DIR/resolve-error.rs:34:10\n    |\n-LL |     attr_proc_macra!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `attr_proc_mac`\n+LL | #[derive(Dlone)]\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n \n-error: cannot find macro `Dlona!` in this scope\n-  --> $DIR/resolve-error.rs:53:5\n+error: cannot find attribute macro `FooWithLongNan` in this scope\n+  --> $DIR/resolve-error.rs:31:3\n    |\n-LL |     Dlona!();\n-   |     ^^^^^\n+LL | #[FooWithLongNan]\n+   |   ^^^^^^^^^^^^^^\n \n-error: cannot find macro `bang_proc_macrp!` in this scope\n-  --> $DIR/resolve-error.rs:56:5\n+error: cannot find attribute macro `attr_proc_macra` in this scope\n+  --> $DIR/resolve-error.rs:27:3\n    |\n-LL |     bang_proc_macrp!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `bang_proc_macro`\n+LL | #[attr_proc_macra]\n+   |   ^^^^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `attr_proc_macro`\n+\n+error: cannot find derive macro `FooWithLongNan` in this scope\n+  --> $DIR/resolve-error.rs:22:10\n+   |\n+LL | #[derive(FooWithLongNan)]\n+   |          ^^^^^^^^^^^^^^ help: a derive macro with a similar name exists: `FooWithLongName`\n \n error: aborting due to 10 previous errors\n "}]}