{"sha": "2574f31b9b71cd2b37002dbfc9a818c3cc805498", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NzRmMzFiOWI3MWNkMmIzNzAwMmRiZmM5YTgxOGMzY2M4MDU0OTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-29T18:40:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-30T18:07:28Z"}, "message": "save the subobligations as well", "tree": {"sha": "5cf8af12f124c85aa05b5d454a357c1e412fcc76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cf8af12f124c85aa05b5d454a357c1e412fcc76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2574f31b9b71cd2b37002dbfc9a818c3cc805498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2574f31b9b71cd2b37002dbfc9a818c3cc805498", "html_url": "https://github.com/rust-lang/rust/commit/2574f31b9b71cd2b37002dbfc9a818c3cc805498", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2574f31b9b71cd2b37002dbfc9a818c3cc805498/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "url": "https://api.github.com/repos/rust-lang/rust/commits/477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "html_url": "https://github.com/rust-lang/rust/commit/477e9f01714b6dffa1fb75e95b890d7abc2fcc52"}], "stats": {"total": 92, "additions": 86, "deletions": 6}, "files": [{"sha": "7cce9c398bb44cfa16c8feb3e2c6239b9c723c5a", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2574f31b9b71cd2b37002dbfc9a818c3cc805498/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2574f31b9b71cd2b37002dbfc9a818c3cc805498/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=2574f31b9b71cd2b37002dbfc9a818c3cc805498", "patch": "@@ -462,13 +462,19 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n         Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n-            // If we find the value in the cache, then the obligations\n-            // have already been returned from the previous entry (and\n-            // should therefore have been honored).\n+            // If we find the value in the cache, then return it along\n+            // with the obligations that went along with it. Note\n+            // that, when using a fulfillment context, these\n+            // obligations could in principle be ignored: they have\n+            // already been registered when the cache entry was\n+            // created (and hence the new ones will quickly be\n+            // discarded as duplicated). But when doing trait\n+            // evaluation this is not the case, and dropping the trait\n+            // evaluations can causes ICEs (e.g. #43132).\n             debug!(\"opt_normalize_projection_type: \\\n                     found normalized ty `{:?}`\",\n                    ty);\n-            return Some(NormalizedTy { value: ty, obligations: vec![] });\n+            return Some(ty);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -1326,7 +1332,7 @@ enum ProjectionCacheEntry<'tcx> {\n     InProgress,\n     Ambiguous,\n     Error,\n-    NormalizedTy(Ty<'tcx>),\n+    NormalizedTy(NormalizedTy<'tcx>),\n }\n \n // NB: intentionally not Clone\n@@ -1374,7 +1380,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n     fn complete(&mut self, key: ty::ProjectionTy<'tcx>, value: &NormalizedTy<'tcx>) {\n         debug!(\"ProjectionCacheEntry::complete: adding cache entry: key={:?}, value={:?}\",\n                key, value);\n-        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.value));\n+        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.clone()));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n "}, {"sha": "64b3b092b89360f0cc033388becd05400a8ba4e8", "filename": "src/test/run-pass/issue-43132.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2574f31b9b71cd2b37002dbfc9a818c3cc805498/src%2Ftest%2Frun-pass%2Fissue-43132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2574f31b9b71cd2b37002dbfc9a818c3cc805498/src%2Ftest%2Frun-pass%2Fissue-43132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43132.rs?ref=2574f31b9b71cd2b37002dbfc9a818c3cc805498", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+fn main() {\n+}\n+\n+fn foo() {\n+    let b = mk::<\n+        Forward<(Box<Future<Error = u32>>,)>,\n+    >();\n+    b.map_err(|_| ()).join();\n+}\n+\n+fn mk<T>() -> T {\n+    loop {}\n+}\n+\n+impl<I: Future<Error = E>, E> Future for (I,) {\n+    type Error = E;\n+}\n+\n+struct Forward<T: Future> {\n+    _a: T,\n+}\n+\n+impl<T: Future> Future for Forward<T>\n+where\n+    T::Error: From<u32>,\n+{\n+    type Error = T::Error;\n+}\n+\n+trait Future {\n+    type Error;\n+\n+    fn map_err<F, E>(self, _: F) -> (Self, F)\n+    where\n+        F: FnOnce(Self::Error) -> E,\n+        Self: Sized,\n+    {\n+        loop {}\n+    }\n+\n+    fn join(self) -> (MaybeDone<Self>, ())\n+    where\n+        Self: Sized,\n+    {\n+        loop {}\n+    }\n+}\n+\n+impl<S: ?Sized + Future> Future for Box<S> {\n+    type Error = S::Error;\n+}\n+\n+enum MaybeDone<A: Future> {\n+    _Done(A::Error),\n+}\n+\n+impl<U, A: Future, F> Future for (A, F)\n+where\n+    F: FnOnce(A::Error) -> U,\n+{\n+    type Error = U;\n+}"}]}