{"sha": "914e750c9ead9a80e6514c08388cce11380cb949", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNGU3NTBjOWVhZDlhODBlNjUxNGMwODM4OGNjZTExMzgwY2I5NDk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-09T09:09:25Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: further simplification", "tree": {"sha": "03440186c6bbd6537b28cdcccd5e9f0a271e4fb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03440186c6bbd6537b28cdcccd5e9f0a271e4fb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/914e750c9ead9a80e6514c08388cce11380cb949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/914e750c9ead9a80e6514c08388cce11380cb949", "html_url": "https://github.com/rust-lang/rust/commit/914e750c9ead9a80e6514c08388cce11380cb949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/914e750c9ead9a80e6514c08388cce11380cb949/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e8b086e8b1b318be3164e89d16e5e19d16cc59", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e8b086e8b1b318be3164e89d16e5e19d16cc59", "html_url": "https://github.com/rust-lang/rust/commit/38e8b086e8b1b318be3164e89d16e5e19d16cc59"}], "stats": {"total": 78, "additions": 32, "deletions": 46}, "files": [{"sha": "a407fdda112d1bef34982d67b47ddd034ff72225", "filename": "src/chains.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/914e750c9ead9a80e6514c08388cce11380cb949/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914e750c9ead9a80e6514c08388cce11380cb949/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=914e750c9ead9a80e6514c08388cce11380cb949", "patch": "@@ -161,11 +161,7 @@ fn rewrite_chain_block(mut chain: Chain, context: &RewriteContext, shape: Shape)\n         shape.block_indent(context.config.tab_spaces())\n     }.with_max_width(context.config);\n \n-    let extend = if !parent_rewrite_contains_newline && is_continuable(&chain.parent.expr) {\n-        is_small_parent\n-    } else {\n-        parent_is_block\n-    };\n+    let extend = parent_is_block || (is_small_parent && !parent_rewrite_contains_newline && is_continuable(&chain.parent.expr));\n \n     let first_child_shape = if extend {\n         let offset = trimmed_last_line_width(&parent_rewrite) + chain.parent.tries;\n@@ -351,7 +347,6 @@ fn rewrite_chain_visual(mut chain: Chain, context: &RewriteContext, shape: Shape\n         .rewrite(context, parent_shape)\n         .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n-    let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n \n     let other_child_shape = shape.visual_indent(0).with_max_width(context.config);\n \n@@ -382,16 +377,7 @@ fn rewrite_chain_visual(mut chain: Chain, context: &RewriteContext, shape: Shape\n     }\n \n     // Total of all items excluding the last.\n-    let extend_last_subexpr = if is_small_parent {\n-        rewrites.len() == 1 && last_line_extendable(&rewrites[0])\n-    } else {\n-        rewrites.is_empty() && last_line_extendable(&parent_rewrite)\n-    };\n-    let almost_total = if extend_last_subexpr {\n-        last_line_width(&parent_rewrite)\n-    } else {\n-        rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len()\n-    } + last.tries;\n+    let almost_total = rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len() + last.tries;\n     let one_line_budget = if rewrites.is_empty() {\n         shape.width\n     } else {\n@@ -436,38 +422,48 @@ fn rewrite_chain_visual(mut chain: Chain, context: &RewriteContext, shape: Shape\n     // })\n     // ```\n \n-    let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexpr {\n+    let mut last_subexpr_str = None;\n+    let mut fits_single_line = false;\n+\n+    if all_in_one_line {\n         // First we try to 'overflow' the last child and see if it looks better than using\n         // vertical layout.\n-        parent_shape.offset_left(almost_total).map(|shape| {\n+        if let Some(shape) = parent_shape.offset_left(almost_total) {\n             if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n                 // We allow overflowing here only if both of the following conditions match:\n                 // 1. The entire chain fits in a single line except the last child.\n                 // 2. `last_child_str.lines().count() >= 5`.\n                 let line_count = rw.lines().count();\n-                let fits_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n-                if fits_single_line && line_count >= 5 {\n-                    (Some(rw), true)\n+                let could_fit_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n+                if could_fit_single_line && line_count >= 5 {\n+                    last_subexpr_str = Some(rw);\n+                    fits_single_line = true;\n                 } else {\n                     // We could not know whether overflowing is better than using vertical layout,\n                     // just by looking at the overflowed rewrite. Now we rewrite the last child\n                     // on its own line, and compare two rewrites to choose which is better.\n                     match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n-                        Some(ref new_rw) if !fits_single_line => (Some(new_rw.clone()), false),\n+                        Some(ref new_rw) if !could_fit_single_line => {\n+                            last_subexpr_str = Some(new_rw.clone());\n+                        }\n                         Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n-                            (Some(rw), fits_single_line)\n+                            last_subexpr_str = Some(rw);\n+                            fits_single_line = could_fit_single_line;\n+                        }\n+                        new_rw @ Some(..) => {\n+                            last_subexpr_str = new_rw;\n+                        }\n+                        _ => {\n+                            last_subexpr_str = Some(rw);\n+                            fits_single_line = could_fit_single_line;\n                         }\n-                        new_rw @ Some(..) => (new_rw, false),\n-                        _ => (Some(rw), fits_single_line),\n                     }\n                 }\n-            } else {\n-                (rewrite_chain_subexpr(&last.expr, context, last_shape), false)\n             }\n-        })?\n-    } else {\n-        (rewrite_chain_subexpr(&last.expr, context, last_shape), false)\n-    };\n+        }\n+    } \n+\n+    last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n     rewrites.push(last_subexpr_str?);\n \n     let connector = if fits_single_line && !parent_rewrite_contains_newline {\n@@ -481,21 +477,11 @@ fn rewrite_chain_visual(mut chain: Chain, context: &RewriteContext, shape: Shape\n         other_child_shape.indent.to_string_with_newline(context.config)\n     };\n \n-    let result = if is_small_parent && rewrites.len() > 1 {\n-        format!(\n-            \"{}{}{}\",\n-            parent_rewrite,\n-            rewrites[0],\n-            join_rewrites_vis(&rewrites[1..], &connector),\n-        )\n-    } else {\n-        format!(\n-            \"{}{}\",\n-            parent_rewrite,\n-            join_rewrites_vis(&rewrites, &connector),\n-        )\n-    };\n-    let result = format!(\"{}{}\", result, \"?\".repeat(last.tries));\n+    let result = format!(\"{}{}{}\",\n+        parent_rewrite,\n+        join_rewrites_vis(&rewrites, &connector),\n+        \"?\".repeat(last.tries),\n+    );\n     wrap_str(result, context.config.max_width(), shape)\n }\n "}]}