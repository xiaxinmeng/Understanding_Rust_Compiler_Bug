{"sha": "190f0deac83174de23ff21f980ab514c90e0e59e", "node_id": "C_kwDOAAsO6NoAKDE5MGYwZGVhYzgzMTc0ZGUyM2ZmMjFmOTgwYWI1MTRjOTBlMGU1OWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-04T13:07:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-04T13:07:26Z"}, "message": "Auto merge of #8450 - Jarcho:unsafe_blocks_8449, r=giraffate\n\nRework `undocumented_unsafe_blocks`\n\nfixes: #8264\nfixes: #8449\n\nOne thing came up while working on this. Currently comments on the same line are supported like so:\n\n```rust\n/* SAFETY: reason */ unsafe {}\n```\n\nIs this worth supporting at all? Anything other than a couple of words doesn't really fit well.\n\nedit: [zulip topic](https://rust-lang.zulipchat.com/#narrow/stream/257328-clippy/topic/.60undocumented_unsafe_blocks.60.20same.20line.20comment)\n\nchangelog: Don't lint `undocumented_unsafe_blocks` when the unsafe block comes from a proc-macro.\nchangelog: Don't lint `undocumented_unsafe_blocks` when the preceding line has a safety comment and the unsafe block is a sub-expression.", "tree": {"sha": "06e50a0aaee1ff8d5d35c4d6fd1b7f3e224b481d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06e50a0aaee1ff8d5d35c4d6fd1b7f3e224b481d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/190f0deac83174de23ff21f980ab514c90e0e59e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/190f0deac83174de23ff21f980ab514c90e0e59e", "html_url": "https://github.com/rust-lang/rust/commit/190f0deac83174de23ff21f980ab514c90e0e59e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/190f0deac83174de23ff21f980ab514c90e0e59e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cec8b30fac2c13504de7e7f950bd36c497858b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cec8b30fac2c13504de7e7f950bd36c497858b1", "html_url": "https://github.com/rust-lang/rust/commit/1cec8b30fac2c13504de7e7f950bd36c497858b1"}, {"sha": "17c8bee95a43cf9c39ec766cdaa8c6219f4126dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/17c8bee95a43cf9c39ec766cdaa8c6219f4126dd", "html_url": "https://github.com/rust-lang/rust/commit/17c8bee95a43cf9c39ec766cdaa8c6219f4126dd"}], "stats": {"total": 539, "additions": 277, "deletions": 262}, "files": [{"sha": "8dab039f24fe73fd1bde7951bff6125eb2cadd3c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/190f0deac83174de23ff21f980ab514c90e0e59e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190f0deac83174de23ff21f980ab514c90e0e59e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=190f0deac83174de23ff21f980ab514c90e0e59e", "patch": "@@ -1,5 +1,6 @@\n // error-pattern:cargo-clippy\n \n+#![feature(array_windows)]\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n@@ -849,7 +850,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             enable_raw_pointer_heuristic_for_send,\n         ))\n     });\n-    store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks::default()));\n+    store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks));\n     store.register_late_pass(|| Box::new(match_str_case_mismatch::MatchStrCaseMismatch));\n     store.register_late_pass(move || Box::new(format_args::FormatArgs));\n     store.register_late_pass(|| Box::new(trailing_empty_array::TrailingEmptyArray));"}, {"sha": "c0947685fa1d58de4ca1083c97b995f713a61153", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 142, "deletions": 167, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/190f0deac83174de23ff21f980ab514c90e0e59e/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190f0deac83174de23ff21f980ab514c90e0e59e/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=190f0deac83174de23ff21f980ab514c90e0e59e", "patch": "@@ -1,23 +1,38 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::is_lint_allowed;\n-use clippy_utils::source::{indent_of, reindent_multiline, snippet};\n-use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, HirId, Local, UnsafeSource};\n-use rustc_lexer::TokenKind;\n-use rustc_lint::{LateContext, LateLintPass};\n+use clippy_utils::source::walk_span_to_context;\n+use rustc_hir::{Block, BlockCheckMode, UnsafeSource};\n+use rustc_lexer::{tokenize, TokenKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::TyCtxt;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{BytePos, Span};\n-use std::borrow::Cow;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{BytePos, Pos, SyntaxContext};\n+use std::rc::Rc;\n \n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for `unsafe` blocks without a `// SAFETY: ` comment\n     /// explaining why the unsafe operations performed inside\n     /// the block are safe.\n     ///\n+    /// Note the comment must appear on the line(s) preceding the unsafe block\n+    /// with nothing appearing in between. The following is ok:\n+    /// ```ignore\n+    /// foo(\n+    ///     // SAFETY:\n+    ///     // This is a valid safety comment\n+    ///     unsafe { *x }\n+    /// )\n+    /// ```\n+    /// But neither of these are:\n+    /// ```ignore\n+    /// // SAFETY:\n+    /// // This is not a valid safety comment\n+    /// foo(\n+    ///     /* SAFETY: Neither is this */ unsafe { *x },\n+    /// );\n+    /// ```\n+    ///\n     /// ### Why is this bad?\n     /// Undocumented unsafe blocks can make it difficult to\n     /// read and maintain code, as well as uncover unsoundness\n@@ -44,179 +59,139 @@ declare_clippy_lint! {\n     \"creating an unsafe block without explaining why it is safe\"\n }\n \n-impl_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS]);\n-\n-#[derive(Default)]\n-pub struct UndocumentedUnsafeBlocks {\n-    pub local_level: u32,\n-    pub local_span: Option<Span>,\n-    // The local was already checked for an overall safety comment\n-    // There is no need to continue checking the blocks in the local\n-    pub local_checked: bool,\n-    // Since we can only check the blocks from expanded macros\n-    // We have to omit the suggestion due to the actual definition\n-    // Not being available to us\n-    pub macro_expansion: bool,\n-}\n+declare_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS]);\n \n impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n     fn check_block(&mut self, cx: &LateContext<'_>, block: &'_ Block<'_>) {\n-        if_chain! {\n-            if !self.local_checked;\n-            if !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id);\n-            if !in_external_macro(cx.tcx.sess, block.span);\n-            if let BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) = block.rules;\n-            if let Some(enclosing_scope_hir_id) = cx.tcx.hir().get_enclosing_scope(block.hir_id);\n-            if self.block_has_safety_comment(cx.tcx, enclosing_scope_hir_id, block.span) == Some(false);\n-            then {\n-                let mut span = block.span;\n-\n-                if let Some(local_span) = self.local_span {\n-                    span = local_span;\n-\n-                    let result = self.block_has_safety_comment(cx.tcx, enclosing_scope_hir_id, span);\n+        if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n+            && !in_external_macro(cx.tcx.sess, block.span)\n+            && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id)\n+            && !is_unsafe_from_proc_macro(cx, block)\n+            && !block_has_safety_comment(cx, block)\n+        {\n+            let source_map = cx.tcx.sess.source_map();\n+            let span = if source_map.is_multiline(block.span) {\n+                source_map.span_until_char(block.span, '\\n')\n+            } else {\n+                block.span\n+            };\n \n-                    if result.unwrap_or(true) {\n-                        self.local_checked = true;\n-                        return;\n-                    }\n-                }\n-\n-                self.lint(cx, span);\n-            }\n-        }\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext<'_>, local: &'_ Local<'_>) {\n-        if_chain! {\n-            if !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, local.hir_id);\n-            if !in_external_macro(cx.tcx.sess, local.span);\n-            if let Some(init) = local.init;\n-            then {\n-                self.visit_expr(init);\n-\n-                if self.local_level > 0 {\n-                    self.local_span = Some(local.span);\n-                }\n-            }\n+            span_lint_and_help(\n+                cx,\n+                UNDOCUMENTED_UNSAFE_BLOCKS,\n+                span,\n+                \"unsafe block missing a safety comment\",\n+                None,\n+                \"consider adding a safety comment on the preceding line\",\n+            );\n         }\n     }\n+}\n \n-    fn check_block_post(&mut self, _: &LateContext<'_>, _: &'_ Block<'_>) {\n-        self.local_level = self.local_level.saturating_sub(1);\n-\n-        if self.local_level == 0 {\n-            self.local_checked = false;\n-            self.local_span = None;\n-        }\n-    }\n+fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n+    let source_map = cx.sess().source_map();\n+    let file_pos = source_map.lookup_byte_offset(block.span.lo());\n+    file_pos\n+        .sf\n+        .src\n+        .as_deref()\n+        .and_then(|src| src.get(file_pos.pos.to_usize()..))\n+        .map_or(true, |src| !src.starts_with(\"unsafe\"))\n }\n \n-impl<'v> Visitor<'v> for UndocumentedUnsafeBlocks {\n-    fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n-        match ex.kind {\n-            ExprKind::Block(_, _) => self.local_level = self.local_level.saturating_add(1),\n-            _ => walk_expr(self, ex),\n+/// Checks if the lines immediately preceding the block contain a safety comment.\n+fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n+    // This intentionally ignores text before the start of a function so something like:\n+    // ```\n+    //     // SAFETY: reason\n+    //     fn foo() { unsafe { .. } }\n+    // ```\n+    // won't work. This is to avoid dealing with where such a comment should be place relative to\n+    // attributes and doc comments.\n+\n+    let source_map = cx.sess().source_map();\n+    let ctxt = block.span.ctxt();\n+    if ctxt != SyntaxContext::root() {\n+        // From a macro expansion. Get the text from the start of the macro declaration to start of the unsafe block.\n+        //     macro_rules! foo { () => { stuff }; (x) => { unsafe { stuff } }; }\n+        //     ^--------------------------------------------^\n+        if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n+            && let Ok(macro_line) = source_map.lookup_line(ctxt.outer_expn_data().def_site.lo())\n+            && Rc::ptr_eq(&unsafe_line.sf, &macro_line.sf)\n+            && let Some(src) = unsafe_line.sf.src.as_deref()\n+        {\n+            macro_line.line < unsafe_line.line && text_has_safety_comment(\n+                src,\n+                &unsafe_line.sf.lines[macro_line.line + 1..=unsafe_line.line],\n+                unsafe_line.sf.start_pos.to_usize(),\n+            )\n+        } else {\n+            // Problem getting source text. Pretend a comment was found.\n+            true\n         }\n+    } else if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n+        && let Some(body) = cx.enclosing_body\n+        && let Some(body_span) = walk_span_to_context(cx.tcx.hir().body(body).value.span, SyntaxContext::root())\n+        && let Ok(body_line) = source_map.lookup_line(body_span.lo())\n+        && Rc::ptr_eq(&unsafe_line.sf, &body_line.sf)\n+        && let Some(src) = unsafe_line.sf.src.as_deref()\n+    {\n+        // Get the text from the start of function body to the unsafe block.\n+        //     fn foo() { some_stuff; unsafe { stuff }; other_stuff; }\n+        //              ^-------------^\n+        body_line.line < unsafe_line.line && text_has_safety_comment(\n+            src,\n+            &unsafe_line.sf.lines[body_line.line + 1..=unsafe_line.line],\n+            unsafe_line.sf.start_pos.to_usize(),\n+        )\n+    } else {\n+        // Problem getting source text. Pretend a comment was found.\n+        true\n     }\n }\n \n-impl UndocumentedUnsafeBlocks {\n-    fn block_has_safety_comment(&mut self, tcx: TyCtxt<'_>, enclosing_hir_id: HirId, block_span: Span) -> Option<bool> {\n-        let map = tcx.hir();\n-        let source_map = tcx.sess.source_map();\n-\n-        let enclosing_scope_span = map.opt_span(enclosing_hir_id)?;\n-\n-        let between_span = if block_span.from_expansion() {\n-            self.macro_expansion = true;\n-            enclosing_scope_span.with_hi(block_span.hi()).source_callsite()\n-        } else {\n-            self.macro_expansion = false;\n-            enclosing_scope_span.to(block_span).source_callsite()\n-        };\n-\n-        let file_name = source_map.span_to_filename(between_span);\n-        let source_file = source_map.get_source_file(&file_name)?;\n-\n-        let lex_start = (between_span.lo().0 - source_file.start_pos.0 + 1) as usize;\n-        let lex_end = (between_span.hi().0 - source_file.start_pos.0) as usize;\n-        let src_str = source_file.src.as_ref()?[lex_start..lex_end].to_string();\n-\n-        let source_start_pos = source_file.start_pos.0 as usize + lex_start;\n-\n-        let mut pos = 0;\n-        let mut comment = false;\n-\n-        for token in rustc_lexer::tokenize(&src_str) {\n-            match token.kind {\n-                TokenKind::LineComment { doc_style: None }\n-                | TokenKind::BlockComment {\n-                    doc_style: None,\n-                    terminated: true,\n-                } => {\n-                    let comment_str = src_str[pos + 2..pos + token.len].to_ascii_uppercase();\n-\n-                    if comment_str.contains(\"SAFETY:\") {\n-                        comment = true;\n-                    }\n-                },\n-                // We need to add all whitespace to `pos` before checking the comment's line number\n-                TokenKind::Whitespace => {},\n-                _ => {\n-                    if comment {\n-                        // Get the line number of the \"comment\" (really wherever the trailing whitespace ended)\n-                        let comment_line_num = source_file\n-                            .lookup_file_pos(BytePos((source_start_pos + pos).try_into().unwrap()))\n-                            .0;\n-                        // Find the block/local's line number\n-                        let block_line_num = tcx.sess.source_map().lookup_char_pos(block_span.lo()).line;\n-\n-                        // Check the comment is immediately followed by the block/local\n-                        if block_line_num == comment_line_num + 1 || block_line_num == comment_line_num {\n-                            return Some(true);\n-                        }\n-\n-                        comment = false;\n-                    }\n-                },\n+/// Checks if the given text has a safety comment for the immediately proceeding line.\n+fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) -> bool {\n+    let mut lines = line_starts\n+        .array_windows::<2>()\n+        .rev()\n+        .map_while(|[start, end]| {\n+            src.get(start.to_usize() - offset..end.to_usize() - offset)\n+                .map(|text| (start.to_usize(), text.trim_start()))\n+        })\n+        .filter(|(_, text)| !text.is_empty());\n+\n+    let Some((line_start, line)) = lines.next() else {\n+        return false;\n+    };\n+    // Check for a sequence of line comments.\n+    if line.starts_with(\"//\") {\n+        let mut line = line;\n+        loop {\n+            if line.to_ascii_uppercase().contains(\"SAFETY:\") {\n+                return true;\n+            }\n+            match lines.next() {\n+                Some((_, x)) if x.starts_with(\"//\") => line = x,\n+                _ => return false,\n             }\n-\n-            pos += token.len;\n         }\n-\n-        Some(false)\n     }\n-\n-    fn lint(&self, cx: &LateContext<'_>, mut span: Span) {\n-        let source_map = cx.tcx.sess.source_map();\n-\n-        if source_map.is_multiline(span) {\n-            span = source_map.span_until_char(span, '\\n');\n+    // No line comments; look for the start of a block comment.\n+    // This will only find them if they are at the start of a line.\n+    let (mut line_start, mut line) = (line_start, line);\n+    loop {\n+        if line.starts_with(\"/*\") {\n+            let src = src[line_start..line_starts.last().unwrap().to_usize()].trim_start();\n+            let mut tokens = tokenize(src);\n+            return src[..tokens.next().unwrap().len]\n+                .to_ascii_uppercase()\n+                .contains(\"SAFETY:\")\n+                && tokens.all(|t| t.kind == TokenKind::Whitespace);\n         }\n-\n-        if self.macro_expansion {\n-            span_lint_and_help(\n-                cx,\n-                UNDOCUMENTED_UNSAFE_BLOCKS,\n-                span,\n-                \"unsafe block in macro expansion missing a safety comment\",\n-                None,\n-                \"consider adding a safety comment in the macro definition\",\n-            );\n-        } else {\n-            let block_indent = indent_of(cx, span);\n-            let suggestion = format!(\"// SAFETY: ...\\n{}\", snippet(cx, span, \"..\"));\n-\n-            span_lint_and_sugg(\n-                cx,\n-                UNDOCUMENTED_UNSAFE_BLOCKS,\n-                span,\n-                \"unsafe block missing a safety comment\",\n-                \"consider adding a safety comment\",\n-                reindent_multiline(Cow::Borrowed(&suggestion), true, block_indent).to_string(),\n-                Applicability::HasPlaceholders,\n-            );\n+        match lines.next() {\n+            Some(x) => (line_start, line) = x,\n+            None => return false,\n         }\n     }\n }"}, {"sha": "3c40f77469b8207bcf2d8e4ae7e22751e3f9bbc8", "filename": "tests/ui/auxiliary/proc_macro_unsafe.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/190f0deac83174de23ff21f980ab514c90e0e59e/tests%2Fui%2Fauxiliary%2Fproc_macro_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190f0deac83174de23ff21f980ab514c90e0e59e/tests%2Fui%2Fauxiliary%2Fproc_macro_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_unsafe.rs?ref=190f0deac83174de23ff21f980ab514c90e0e59e", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: --emit=link\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{Delimiter, Group, Ident, TokenStream, TokenTree};\n+\n+#[proc_macro]\n+pub fn unsafe_block(input: TokenStream) -> TokenStream {\n+    let span = input.into_iter().next().unwrap().span();\n+    TokenStream::from_iter([TokenTree::Ident(Ident::new(\"unsafe\", span)), {\n+        let mut group = Group::new(Delimiter::Brace, TokenStream::new());\n+        group.set_span(span);\n+        TokenTree::Group(group)\n+    }])\n+}"}, {"sha": "1a33e647588f19ea3c6c678285c23ae9e483b57c", "filename": "tests/ui/crashes/ice-7868.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/190f0deac83174de23ff21f980ab514c90e0e59e/tests%2Fui%2Fcrashes%2Fice-7868.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/190f0deac83174de23ff21f980ab514c90e0e59e/tests%2Fui%2Fcrashes%2Fice-7868.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7868.stderr?ref=190f0deac83174de23ff21f980ab514c90e0e59e", "patch": "@@ -5,11 +5,7 @@ LL |     unsafe { 0 };\n    |     ^^^^^^^^^^^^\n    |\n    = note: `-D clippy::undocumented-unsafe-blocks` implied by `-D warnings`\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL ~     unsafe { 0 };\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n error: aborting due to previous error\n "}, {"sha": "afa337c45f41766033abe0d1d85b2694f7fa11f6", "filename": "tests/ui/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/190f0deac83174de23ff21f980ab514c90e0e59e/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190f0deac83174de23ff21f980ab514c90e0e59e/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=190f0deac83174de23ff21f980ab514c90e0e59e", "patch": "@@ -1,5 +1,9 @@\n+// aux-build:proc_macro_unsafe.rs\n+\n #![warn(clippy::undocumented_unsafe_blocks)]\n \n+extern crate proc_macro_unsafe;\n+\n // Valid comments\n \n fn nested_local() {\n@@ -89,11 +93,6 @@ fn block_comment_newlines() {\n     unsafe {}\n }\n \n-#[rustfmt::skip]\n-fn inline_block_comment() {\n-    /* Safety: */unsafe {}\n-}\n-\n fn block_comment_with_extras() {\n     /* This is a description\n      * SAFETY:\n@@ -209,8 +208,54 @@ fn local_nest() {\n     let _ = [(42, unsafe {}, unsafe {}), (52, unsafe {}, unsafe {})];\n }\n \n+fn in_fn_call(x: *const u32) {\n+    fn f(x: u32) {}\n+\n+    // Safety: reason\n+    f(unsafe { *x });\n+}\n+\n+fn multi_in_fn_call(x: *const u32) {\n+    fn f(x: u32, y: u32) {}\n+\n+    // Safety: reason\n+    f(unsafe { *x }, unsafe { *x });\n+}\n+\n+fn in_multiline_fn_call(x: *const u32) {\n+    fn f(x: u32, y: u32) {}\n+\n+    f(\n+        // Safety: reason\n+        unsafe { *x },\n+        0,\n+    );\n+}\n+\n+fn in_macro_call(x: *const u32) {\n+    // Safety: reason\n+    println!(\"{}\", unsafe { *x });\n+}\n+\n+fn in_multiline_macro_call(x: *const u32) {\n+    println!(\n+        \"{}\",\n+        // Safety: reason\n+        unsafe { *x },\n+    );\n+}\n+\n+fn from_proc_macro() {\n+    proc_macro_unsafe::unsafe_block!(token);\n+}\n+\n // Invalid comments\n \n+#[rustfmt::skip]\n+fn inline_block_comment() {\n+    /* Safety: */ unsafe {}\n+}\n+\n fn no_comment() {\n     unsafe {}\n }"}, {"sha": "856a07fd31685e3170eba2ff3baf47221494cf01", "filename": "tests/ui/undocumented_unsafe_blocks.stderr", "status": "modified", "additions": 64, "deletions": 84, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/190f0deac83174de23ff21f980ab514c90e0e59e/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/190f0deac83174de23ff21f980ab514c90e0e59e/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=190f0deac83174de23ff21f980ab514c90e0e59e", "patch": "@@ -1,171 +1,151 @@\n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:215:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:256:19\n+   |\n+LL |     /* Safety: */ unsafe {}\n+   |                   ^^^^^^^^^\n+   |\n+   = note: `-D clippy::undocumented-unsafe-blocks` implied by `-D warnings`\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:260:5\n    |\n LL |     unsafe {}\n    |     ^^^^^^^^^\n    |\n-   = note: `-D clippy::undocumented-unsafe-blocks` implied by `-D warnings`\n-help: consider adding a safety comment\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:264:14\n    |\n-LL ~     // SAFETY: ...\n-LL +     unsafe {}\n+LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+   |              ^^^^^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:219:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:264:29\n    |\n LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^^^^^^^^^^^^^\n    |\n-help: consider adding a safety comment\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:264:48\n    |\n-LL ~     // SAFETY: ...\n-LL +     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+   |                                                ^^^^^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:223:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:268:18\n    |\n LL |     let _ = (42, unsafe {}, \"test\", unsafe {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^\n    |\n-help: consider adding a safety comment\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:268:37\n    |\n-LL ~     // SAFETY: ...\n-LL +     let _ = (42, unsafe {}, \"test\", unsafe {});\n+LL |     let _ = (42, unsafe {}, \"test\", unsafe {});\n+   |                                     ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:227:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:272:14\n    |\n LL |     let _ = *unsafe { &42 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = *unsafe { &42 };\n+   |              ^^^^^^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:232:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:277:19\n    |\n LL |     let _ = match unsafe {} {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = match unsafe {} {\n+   |                   ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:238:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:283:14\n    |\n LL |     let _ = &unsafe {};\n-   |     ^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = &unsafe {};\n+   |              ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:242:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:287:14\n    |\n LL |     let _ = [unsafe {}; 5];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = [unsafe {}; 5];\n+   |              ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:246:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:291:13\n    |\n LL |     let _ = unsafe {};\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = unsafe {};\n+   |             ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:256:8\n+  --> $DIR/undocumented_unsafe_blocks.rs:301:8\n    |\n LL |     t!(unsafe {});\n    |        ^^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     t!(// SAFETY: ...\n-LL ~     unsafe {});\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n-error: unsafe block in macro expansion missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:262:13\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:307:13\n    |\n LL |             unsafe {}\n    |             ^^^^^^^^^\n ...\n LL |     t!();\n    |     ---- in this macro invocation\n    |\n-   = help: consider adding a safety comment in the macro definition\n+   = help: consider adding a safety comment on the preceding line\n    = note: this error originates in the macro `t` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:270:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:315:5\n    |\n LL |     unsafe {} // SAFETY:\n    |     ^^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL ~     unsafe {} // SAFETY:\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:274:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:319:5\n    |\n LL |     unsafe {\n    |     ^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     unsafe {\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:284:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:329:5\n    |\n LL |     unsafe {};\n    |     ^^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL ~     unsafe {};\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:288:20\n+  --> $DIR/undocumented_unsafe_blocks.rs:333:20\n    |\n LL |     println!(\"{}\", unsafe { String::from_utf8_unchecked(vec![]) });\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     println!(\"{}\", // SAFETY: ...\n-LL ~     unsafe { String::from_utf8_unchecked(vec![]) });\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 18 previous errors\n "}]}