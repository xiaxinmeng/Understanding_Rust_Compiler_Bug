{"sha": "10120cce0f7b395b13e57a72e7c57b34d0ed4d64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMTIwY2NlMGY3YjM5NWIxM2U1N2E3MmU3YzU3YjM0ZDBlZDRkNjQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-25T15:40:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-25T15:45:29Z"}, "message": "typeck: Take more care to pass down expected types\n\nThis helps with prototype inference and avoids some 'must be known\nin this context' errors.", "tree": {"sha": "638ab13a4dc8b797eda1cb3d891ef9ea8dbde046", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/638ab13a4dc8b797eda1cb3d891ef9ea8dbde046"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10120cce0f7b395b13e57a72e7c57b34d0ed4d64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10120cce0f7b395b13e57a72e7c57b34d0ed4d64", "html_url": "https://github.com/rust-lang/rust/commit/10120cce0f7b395b13e57a72e7c57b34d0ed4d64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10120cce0f7b395b13e57a72e7c57b34d0ed4d64/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b71535cf9809df1097edd9f05e807840fa3337c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b71535cf9809df1097edd9f05e807840fa3337c", "html_url": "https://github.com/rust-lang/rust/commit/2b71535cf9809df1097edd9f05e807840fa3337c"}], "stats": {"total": 148, "additions": 98, "deletions": 50}, "files": [{"sha": "fd82061844f821ba62a31539eeb6a31a50737a11", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 86, "deletions": 50, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/10120cce0f7b395b13e57a72e7c57b34d0ed4d64/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10120cce0f7b395b13e57a72e7c57b34d0ed4d64/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=10120cce0f7b395b13e57a72e7c57b34d0ed4d64", "patch": "@@ -2371,15 +2371,16 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n     }\n }\n \n-fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n-    ret check_expr_with_unifier(fcx, expr, ty::mk_nil(fcx.ccx.tcx)) {||\n-        /* do not take any action on unify */\n-    };\n+fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n+    check_expr(fcx, expr, some(expected))\n }\n \n-fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n+fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n+              expected: option<ty::t>) -> bool {\n     ret check_expr_with_unifier(fcx, expr, expected) {||\n-        demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n+        for expected.each {|t|\n+            demand::suptype(fcx, expr.span, t, fcx.expr_ty(expr));\n+        }\n     };\n }\n \n@@ -2790,7 +2791,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n \n fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expr: @ast::expr,\n-                           expected: ty::t,\n+                           expected: option<ty::t>,\n                            unifier: fn()) -> bool {\n \n     #debug(\">> typechecking expr %d (%s)\",\n@@ -2861,7 +2862,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     };\n                     if is_block == check_blocks {\n                         let arg_ty = arg_tys[i];\n-                        bot |= check_expr_with_unifier(fcx, a, arg_ty) {||\n+                        bot |= check_expr_with_unifier(\n+                            fcx, a, some(arg_ty)) {||\n                             demand::assign(fcx, a.span, arg_ty, a);\n                         };\n                     }\n@@ -2881,7 +2883,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     // A generic function for checking assignment expressions\n     fn check_assignment(fcx: @fn_ctxt, _sp: span, lhs: @ast::expr,\n                         rhs: @ast::expr, id: ast::node_id) -> bool {\n-        let mut bot = check_expr(fcx, lhs);\n+        let mut bot = check_expr(fcx, lhs, none);\n         bot |= check_expr_with(fcx, rhs, fcx.expr_ty(lhs));\n         fcx.write_ty(id, ty::mk_nil(fcx.ccx.tcx));\n         ret bot;\n@@ -2891,7 +2893,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n                   f: @ast::expr, args: [@ast::expr]) -> bool {\n \n-        let mut bot = check_expr(fcx, f);\n+        let mut bot = check_expr(fcx, f, none);\n         let fn_ty = fcx.expr_ty(f);\n \n         // Call the generic checker.\n@@ -2992,7 +2994,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                    lhs: @ast::expr,\n                    rhs: @ast::expr) -> bool {\n         let tcx = fcx.ccx.tcx;\n-        let lhs_bot = check_expr(fcx, lhs);\n+        let lhs_bot = check_expr(fcx, lhs, none);\n         let lhs_t = fcx.expr_ty(lhs);\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n         ret alt (op, ty::get(lhs_t).struct) {\n@@ -3015,7 +3017,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           (_, _) if ty::type_is_integral(lhs_t) &&\n           ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type\n-            let rhs_bot = check_expr(fcx, rhs);\n+            let rhs_bot = check_expr(fcx, rhs, none);\n             let rhs_t = fcx.expr_ty(rhs);\n             require_integral(fcx, rhs.span, rhs_t);\n             fcx.write_ty(expr.id, lhs_t);\n@@ -3063,7 +3065,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n           _ {}\n         }\n-        check_expr(fcx, rhs);\n+        check_expr(fcx, rhs, none);\n         tcx.sess.span_err(\n             ex.span, \"binary operation \" + ast_util::binop_to_str(op) +\n             \" cannot be applied to type `\" +\n@@ -3083,6 +3085,19 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n         }\n     }\n+    fn unpack_expected<O: copy>(fcx: @fn_ctxt, expected: option<ty::t>,\n+                                unpack: fn(ty::sty) -> option<O>)\n+        -> option<O> {\n+        alt expected {\n+          some(t) {\n+            alt infer::resolve_shallow(fcx.infcx, t, true) {\n+              result::ok(t) { unpack(ty::get(t).struct) }\n+              _ { none }\n+            }\n+          }\n+          _ { none }\n+        }\n+    }\n \n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n@@ -3147,7 +3162,19 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_nil(expr.id);\n       }\n       ast::expr_unary(unop, oper) {\n-        bot = check_expr(fcx, oper);\n+        let exp_inner = unpack_expected(fcx, expected) {|sty|\n+            alt unop {\n+              ast::box(_) | ast::uniq(_) {\n+                alt sty {\n+                  ty::ty_box(mt) | ty::ty_uniq(mt) { some(mt.ty) }\n+                  _ { none }\n+                }\n+              }\n+              ast::not | ast::neg { some(expected.get()) }\n+              ast::deref { none }\n+            }\n+        };\n+        bot = check_expr(fcx, oper, exp_inner);\n         let mut oper_t = fcx.expr_ty(oper);\n         alt unop {\n           ast::box(mutbl) {\n@@ -3202,12 +3229,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, oper_t);\n       }\n       ast::expr_addr_of(mutbl, oper) {\n-        bot = check_expr(fcx, oper);\n-        let mut oper_t = fcx.expr_ty(oper);\n-\n+        bot = check_expr(fcx, oper, unpack_expected(fcx, expected) {|ty|\n+            alt ty { ty::ty_rptr(_, mt) { some(mt.ty) } _ { none } }\n+        });\n         let region = region_of(fcx, oper);\n-        let tm = { ty: oper_t, mutbl: mutbl };\n-        oper_t = ty::mk_rptr(tcx, region, tm);\n+        let tm = { ty: fcx.expr_ty(oper), mutbl: mutbl };\n+        let oper_t = ty::mk_rptr(tcx, region, tm);\n         fcx.write_ty(id, oper_t);\n       }\n       ast::expr_path(pth) {\n@@ -3255,7 +3282,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_log(_, lv, e) {\n         bot = check_expr_with(fcx, lv, ty::mk_mach_uint(tcx, ast::ty_u32));\n         // Note: this does not always execute, so do not propagate bot:\n-        check_expr(fcx, e);\n+        check_expr(fcx, e, none);\n         fcx.write_nil(id);\n       }\n       ast::expr_check(_, e) {\n@@ -3272,7 +3299,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_nil(id);\n       }\n       ast::expr_copy(a) {\n-        bot = check_expr_with(fcx, a, expected);\n+        bot = check_expr(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_move(lhs, rhs) {\n@@ -3348,26 +3375,22 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_fn_block(decl, body) {\n         // Take the prototype from the expected type, but default to block:\n-        let proto = alt ty::get(expected).struct {\n-          ty::ty_fn({proto, _}) { proto }\n-          _ { ast::proto_box }\n-        };\n-        #debug(\"checking expr_fn_block %s expected=%s\",\n-               expr_to_str(expr),\n-               ty_to_str(tcx, expected));\n+        let proto = unpack_expected(fcx, expected, {|sty|\n+            alt sty { ty::ty_fn({proto, _}) { some(proto) } _ { none } }\n+        }).get_default(ast::proto_box);\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n                                    false, unifier);\n       }\n       ast::expr_loop_body(b) {\n-        let rty = structurally_resolved_type(fcx, expr.span, expected);\n-        let (inner_ty, proto) = alt check ty::get(rty).struct {\n+        let expected_sty = unpack_expected(fcx, expected, {|x|some(x)}).get();\n+        let (inner_ty, proto) = alt expected_sty {\n           ty::ty_fn(fty) {\n             alt infer::mk_subty(fcx.infcx, fty.output, ty::mk_bool(tcx)) {\n               result::ok(_) {}\n               result::err(err) {\n                 tcx.sess.span_fatal(\n-                    expr.span, #fmt(\"a loop function's last argument should \\\n-                                     return `bool`, not `%s`\",\n+                    expr.span, #fmt(\"a loop function's last argument \\\n+                                     should return `bool`, not `%s`\",\n                                     ty_to_str(tcx, fty.output)));\n               }\n             }\n@@ -3406,7 +3429,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n-        bot = check_expr(fcx, f);\n+        bot = check_expr(fcx, f, none);\n \n         let {fty, bot: ccob_bot} = {\n             let fn_ty = fcx.expr_ty(f);\n@@ -3465,7 +3488,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = check_call(fcx, expr.span, expr.id, f, args);\n       }\n       ast::expr_cast(e, t) {\n-        bot = check_expr(fcx, e);\n+        bot = check_expr(fcx, e, none);\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n@@ -3506,18 +3529,29 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_tup(elts) {\n         let mut elt_ts = [];\n         vec::reserve(elt_ts, vec::len(elts));\n-        for elts.each {|e|\n-            check_expr(fcx, e);\n+        let flds = unpack_expected(fcx, expected) {|sty|\n+            alt sty { ty::ty_tup(flds) { some(flds) } _ { none } }\n+        };\n+        for elts.eachi {|i, e|\n+            check_expr(fcx, e, flds.map {|fs| fs[i]});\n             let ety = fcx.expr_ty(e);\n             elt_ts += [ety];\n         }\n         let typ = ty::mk_tup(tcx, elt_ts);\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_rec(fields, base) {\n-        option::iter(base) {|b| check_expr(fcx, b); }\n+        option::iter(base) {|b| check_expr(fcx, b, expected); }\n+        let expected = if expected == none && base != none {\n+            some(fcx.expr_ty(base.get()))\n+        } else { expected };\n+        let flds = unpack_expected(fcx, expected) {|sty|\n+            alt sty { ty::ty_rec(flds) { some(flds) } _ { none } }\n+        };\n         let fields_t = vec::map(fields, {|f|\n-            bot |= check_expr(fcx, f.node.expr);\n+            bot |= check_expr(fcx, f.node.expr, flds.chain {|flds|\n+                vec::find(flds) {|tf| tf.ident == f.node.ident}\n+            }.map {|tf| tf.mt.ty});\n             let expr_t = fcx.expr_ty(f.node.expr);\n             let expr_mt = {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n@@ -3531,7 +3565,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fcx.write_ty(id, typ);\n           }\n           some(bexpr) {\n-            bot |= check_expr(fcx, bexpr);\n             let bexpr_t = fcx.expr_ty(bexpr);\n             let mut base_fields: [field] = [];\n             alt structure_of(fcx, expr.span, bexpr_t) {\n@@ -3560,7 +3593,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n       }\n       ast::expr_field(base, field, tys) {\n-        bot |= check_expr(fcx, base);\n+        bot |= check_expr(fcx, base, none);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n         let base_t = do_autoderef(fcx, expr.span, expr_t);\n@@ -3638,10 +3671,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n       }\n       ast::expr_index(base, idx) {\n-        bot |= check_expr(fcx, base);\n+        bot |= check_expr(fcx, base, none);\n         let raw_base_t = fcx.expr_ty(base);\n         let base_t = do_autoderef(fcx, expr.span, raw_base_t);\n-        bot |= check_expr(fcx, idx);\n+        bot |= check_expr(fcx, idx, none);\n         let idx_t = fcx.expr_ty(idx);\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_evec(mt, _) |\n@@ -3671,8 +3704,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n       }\n       ast::expr_new(p, alloc_id, v) {\n-        bot |= check_expr(fcx, p);\n-        bot |= check_expr(fcx, v);\n+        bot |= check_expr(fcx, p, none);\n+        bot |= check_expr(fcx, v, none);\n \n         let p_ty = fcx.expr_ty(p);\n \n@@ -3728,7 +3761,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     #debug(\"type of expr %s is %s, expected is %s\",\n            syntax::print::pprust::expr_to_str(expr),\n            ty_to_str(tcx, fcx.expr_ty(expr)),\n-           ty_to_str(tcx, expected));\n+           alt expected {\n+               some(t) { ty_to_str(tcx, t) }\n+               _ { \"empty\" }\n+           });\n \n     unifier();\n \n@@ -3739,7 +3775,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.ccx.tcx.sess.span_err(sp, \"mismatched types: expected \\\n-                                       `integer` but found `\"\n+                                       integral type but found `\"\n                                   + fcx.ty_to_str(t) + \"`\");\n     }\n }\n@@ -3796,7 +3832,7 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n       }\n       ast::stmt_semi(expr, id) {\n         node_id = id;\n-        bot = check_expr(fcx, expr);\n+        bot = check_expr(fcx, expr, none);\n       }\n     }\n     fcx.write_nil(node_id);\n@@ -3841,7 +3877,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n         if bot && !warned {\n             fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n         }\n-        bot |= check_expr(fcx, e);\n+        bot |= check_expr(fcx, e, none);\n         let ety = fcx.expr_ty(e);\n         fcx.write_ty(blk.node.id, ety);\n       }\n@@ -3870,7 +3906,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n           node_types: smallintmap::mk(),\n           node_type_substs: map::int_hash(),\n           ccx: ccx};\n-    check_expr(fcx, e);\n+    check_expr(fcx, e, none);\n     let cty = fcx.expr_ty(e);\n     let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n     demand::suptype(fcx, e.span, declty, cty);\n@@ -3915,7 +3951,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     for vs.each {|v|\n         alt v.node.disr_expr {\n           some(e) {\n-            check_expr(fcx, e);\n+            check_expr(fcx, e, none);\n             let cty = fcx.expr_ty(e);\n             let declty = ty::mk_int(ccx.tcx);\n             demand::suptype(fcx, e.span, declty, cty);"}, {"sha": "20a224a7fa7a7f7e4efd28e6f43a5e53e89d6ce4", "filename": "src/test/run-pass/infer-with-expected.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10120cce0f7b395b13e57a72e7c57b34d0ed4d64/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10120cce0f7b395b13e57a72e7c57b34d0ed4d64/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs?ref=10120cce0f7b395b13e57a72e7c57b34d0ed4d64", "patch": "@@ -0,0 +1,12 @@\n+// Tests the passing down of expected types through boxing and\n+// wrapping in a record or tuple. (The a.x would complain about 'this\n+// type must be known in this context' if the passing down doesn't\n+// happen.)\n+\n+fn eat_tup(_r: ~@(int, fn@({x: int, y: int}) -> int)) {}\n+fn eat_rec(_r: @~{a: int, b: fn@({x: int, y: int}) -> int}) {}\n+\n+fn main() {\n+    eat_tup(~@(10, {|a| a.x}));\n+    eat_rec(@~{a: 10, b: {|a| a.x}});\n+}"}]}