{"sha": "148b5939542514910236e8c55ea06212afff29f2", "node_id": "C_kwDOAAsO6NoAKDE0OGI1OTM5NTQyNTE0OTEwMjM2ZThjNTVlYTA2MjEyYWZmZjI5ZjI", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-03-18T12:33:40Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-03-30T09:23:58Z"}, "message": "get clippy to compile again", "tree": {"sha": "4cfa802aeafa90932ec4c1b0441f33a5e5fd4ddc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cfa802aeafa90932ec4c1b0441f33a5e5fd4ddc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/148b5939542514910236e8c55ea06212afff29f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/148b5939542514910236e8c55ea06212afff29f2", "html_url": "https://github.com/rust-lang/rust/commit/148b5939542514910236e8c55ea06212afff29f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/148b5939542514910236e8c55ea06212afff29f2/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3535a1549691cd9d9ba5c4733077cf0266ba358", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3535a1549691cd9d9ba5c4733077cf0266ba358", "html_url": "https://github.com/rust-lang/rust/commit/b3535a1549691cd9d9ba5c4733077cf0266ba358"}], "stats": {"total": 85, "additions": 26, "deletions": 59}, "files": [{"sha": "ae4158662d46459c26419250fe5a2cd62cece2cb", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/148b5939542514910236e8c55ea06212afff29f2/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148b5939542514910236e8c55ea06212afff29f2/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=148b5939542514910236e8c55ea06212afff29f2", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::{higher, peel_blocks_with_stmt, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -82,14 +82,6 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n \n                 // Get the variable name\n                 let var_name = ares_path.segments[0].ident.name.as_str();\n-                const INT_TYPES: [LangItem; 5] = [\n-                    LangItem::I8,\n-                    LangItem::I16,\n-                    LangItem::I32,\n-                    LangItem::I64,\n-                    LangItem::Isize\n-                ];\n-\n                 match cond_num_val.kind {\n                     ExprKind::Lit(ref cond_lit) => {\n                         // Check if the constant is zero\n@@ -105,8 +97,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             if name.ident.as_str() == \"MIN\";\n                             if let Some(const_id) = cx.typeck_results().type_dependent_def_id(cond_num_val.hir_id);\n                             if let Some(impl_id) = cx.tcx.impl_of_method(const_id);\n-                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n-                            if int_ids.any(|int_id| int_id == impl_id);\n+                            if let None = cx.tcx.impl_trait_ref(impl_id); // An inherent impl\n+                            if cx.tcx.type_of(impl_id).is_integral();\n                             then {\n                                 print_lint_and_sugg(cx, var_name, expr)\n                             }\n@@ -118,8 +110,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             if name.ident.as_str() == \"min_value\";\n                             if let Some(func_id) = cx.typeck_results().type_dependent_def_id(func.hir_id);\n                             if let Some(impl_id) = cx.tcx.impl_of_method(func_id);\n-                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n-                            if int_ids.any(|int_id| int_id == impl_id);\n+                            if let None = cx.tcx.impl_trait_ref(impl_id); // An inherent impl\n+                            if cx.tcx.type_of(impl_id).is_integral();\n                             then {\n                                 print_lint_and_sugg(cx, var_name, expr)\n                             }"}, {"sha": "c98cdfbca434e9dd9bfbdcede516e322be519e97", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/148b5939542514910236e8c55ea06212afff29f2/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148b5939542514910236e8c55ea06212afff29f2/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=148b5939542514910236e8c55ea06212afff29f2", "patch": "@@ -49,10 +49,11 @@ pub fn is_clone_like(cx: &LateContext<'_>, method_name: &str, method_def_id: hir\n         \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n         \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n         \"to_vec\" => {\n-            cx.tcx\n-                .impl_of_method(method_def_id)\n-                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n-                == Some(true)\n+            cx.tcx.impl_of_method(method_def_id)\n+                .filter(|&impl_did| {\n+                    cx.tcx.type_of(impl_did).is_slice() && cx.tcx.impl_trait_ref(impl_did).is_none()\n+                })\n+                .is_some()\n         },\n         _ => false,\n     }"}, {"sha": "55567d8625e529dfc541d3bf937284c130a9e516", "filename": "clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/148b5939542514910236e8c55ea06212afff29f2/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148b5939542514910236e8c55ea06212afff29f2/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=148b5939542514910236e8c55ea06212afff29f2", "patch": "@@ -12,13 +12,13 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n         if count <= 1;\n         if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n-        let lang_items = cx.tcx.lang_items();\n-        if lang_items.slice_impl() == Some(impl_id) || lang_items.str_impl() == Some(impl_id);\n+        if cx.tcx.impl_trait_ref(impl_id).is_none();\n+        let self_ty = cx.tcx.type_of(impl_id);\n+        if self_ty.is_slice() || self_ty.is_str();\n         then {\n             // Ignore empty slice and string literals when used with a literal count.\n             if matches!(self_arg.kind, ExprKind::Array([]))\n                 || matches!(self_arg.kind, ExprKind::Lit(Spanned { node: LitKind::Str(s, _), .. }) if s.is_empty())\n-\n             {\n                 return;\n             }\n@@ -28,7 +28,7 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n                 \"the resulting iterator will always return `None`\")\n             } else {\n                 (format!(\"`{}` called with `1` split\", method_name),\n-                if lang_items.slice_impl() == Some(impl_id) {\n+                if self_ty.is_slice() {\n                     \"the resulting iterator will always return the entire slice followed by `None`\"\n                 } else {\n                     \"the resulting iterator will always return the entire string followed by `None`\""}, {"sha": "9d4313827f7c6afa048b68d70c1dc3d46ba2e6a1", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/148b5939542514910236e8c55ea06212afff29f2/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148b5939542514910236e8c55ea06212afff29f2/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=148b5939542514910236e8c55ea06212afff29f2", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::{self, AssocItems, AssocKind, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n@@ -308,7 +308,6 @@ struct PtrArg<'tcx> {\n     method_renames: &'static [(&'static str, &'static str)],\n     ref_prefix: RefPrefix,\n     deref_ty: DerefTy<'tcx>,\n-    deref_assoc_items: Option<(DefId, &'tcx AssocItems<'tcx>)>,\n }\n impl PtrArg<'_> {\n     fn build_msg(&self) -> String {\n@@ -411,7 +410,7 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                 if params.get(i).map_or(true, |p| !is_lint_allowed(cx, PTR_ARG, p.hir_id));\n \n                 then {\n-                    let (method_renames, deref_ty, deref_impl_id) = match cx.tcx.get_diagnostic_name(adt.did()) {\n+                    let (method_renames, deref_ty) = match cx.tcx.get_diagnostic_name(adt.did()) {\n                         Some(sym::Vec) => (\n                             [(\"clone\", \".to_owned()\")].as_slice(),\n                             DerefTy::Slice(\n@@ -424,17 +423,14 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                                     }),\n                                 substs.type_at(0),\n                             ),\n-                            cx.tcx.lang_items().slice_impl()\n                         ),\n                         Some(sym::String) => (\n                             [(\"clone\", \".to_owned()\"), (\"as_str\", \"\")].as_slice(),\n                             DerefTy::Str,\n-                            cx.tcx.lang_items().str_impl()\n                         ),\n                         Some(sym::PathBuf) => (\n                             [(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")].as_slice(),\n                             DerefTy::Path,\n-                            None,\n                         ),\n                         Some(sym::Cow) if mutability == Mutability::Not => {\n                             let ty_name = name.args\n@@ -470,7 +466,6 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                             mutability,\n                         },\n                         deref_ty,\n-                        deref_assoc_items: deref_impl_id.map(|id| (id, cx.tcx.associated_items(id))),\n                     });\n                 }\n             }\n@@ -607,14 +602,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             // If the types match check for methods which exist on both types. e.g. `Vec::len` and\n                             // `slice::len`\n                             ty::Adt(def, _)\n-                                if def.did() == args.ty_did\n-                                    && (i != 0\n-                                        || self.cx.tcx.trait_of_item(id).is_some()\n-                                        || !args.deref_assoc_items.map_or(false, |(id, items)| {\n-                                            items\n-                                                .find_by_name_and_kind(self.cx.tcx, name.ident, AssocKind::Fn, id)\n-                                                .is_some()\n-                                        })) =>\n+                                if def.did() == args.ty_did =>\n                             {\n                                 set_skip_flag();\n                             },"}, {"sha": "b55075943b29a1f733182a907c6a280e72d5b67d", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/148b5939542514910236e8c55ea06212afff29f2/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148b5939542514910236e8c55ea06212afff29f2/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=148b5939542514910236e8c55ea06212afff29f2", "patch": "@@ -77,9 +77,9 @@ use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, lang_items, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr,\n+    def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr,\n     ExprKind, FnDecl, ForeignItem, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local,\n-    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, Target,\n+    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind,\n     TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n@@ -479,12 +479,10 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n             _ => None,\n         }\n     }\n-    fn find_primitive(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n-        if let Some(&(index, Target::Impl)) = lang_items::ITEM_REFS.get(&Symbol::intern(name)) {\n-            tcx.lang_items().items()[index]\n-        } else {\n-            None\n-        }\n+    fn find_primitive(_tcx: TyCtxt<'_>, _name: &str) -> Option<DefId> {\n+        // FIXME: Deal with this without relying on lang items or by only\n+        // looking at a single impl.\n+        None\n     }\n     fn find_crate(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n         tcx.crates(())"}, {"sha": "f8086bd2e4d042126e3ace5feab5f2c8d955a2fc", "filename": "tests/ui-toml/toml_disallowed_methods/conf_disallowed_methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/148b5939542514910236e8c55ea06212afff29f2/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148b5939542514910236e8c55ea06212afff29f2/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs?ref=148b5939542514910236e8c55ea06212afff29f2", "patch": "@@ -10,8 +10,8 @@ fn main() {\n     let mut a = vec![1, 2, 3, 4];\n     a.iter().sum::<i32>();\n \n-    a.sort_unstable();\n+    a.sort_unstable(); // FIXME: Warn here\n \n-    let _ = 2.0f32.clamp(3.0f32, 4.0f32);\n+    let _ = 2.0f32.clamp(3.0f32, 4.0f32); // FIXME: Warn here\n     let _ = 2.0f64.clamp(3.0f64, 4.0f64);\n }"}, {"sha": "999ead10d51829dae9d73903f9cd2c92df6bb4be", "filename": "tests/ui-toml/toml_disallowed_methods/conf_disallowed_methods.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/148b5939542514910236e8c55ea06212afff29f2/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/148b5939542514910236e8c55ea06212afff29f2/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr?ref=148b5939542514910236e8c55ea06212afff29f2", "patch": "@@ -20,17 +20,5 @@ error: use of a disallowed method `std::iter::Iterator::sum`\n LL |     a.iter().sum::<i32>();\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of a disallowed method `slice::sort_unstable`\n-  --> $DIR/conf_disallowed_methods.rs:13:5\n-   |\n-LL |     a.sort_unstable();\n-   |     ^^^^^^^^^^^^^^^^^\n-\n-error: use of a disallowed method `f32::clamp`\n-  --> $DIR/conf_disallowed_methods.rs:15:13\n-   |\n-LL |     let _ = 2.0f32.clamp(3.0f32, 4.0f32);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n "}]}