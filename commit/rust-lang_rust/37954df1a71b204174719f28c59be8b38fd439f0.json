{"sha": "37954df1a71b204174719f28c59be8b38fd439f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3OTU0ZGYxYTcxYjIwNDE3NDcxOWYyOGM1OWJlOGIzOGZkNDM5ZjA=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-09T08:22:08Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-04-24T17:51:25Z"}, "message": "doc: some HirIdification", "tree": {"sha": "906b8e9a4d64adfe074cf8066773b86ad31499dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/906b8e9a4d64adfe074cf8066773b86ad31499dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37954df1a71b204174719f28c59be8b38fd439f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37954df1a71b204174719f28c59be8b38fd439f0", "html_url": "https://github.com/rust-lang/rust/commit/37954df1a71b204174719f28c59be8b38fd439f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37954df1a71b204174719f28c59be8b38fd439f0/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b71107912de76a1092b1a0a18ca70922c1b4be5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b71107912de76a1092b1a0a18ca70922c1b4be5e", "html_url": "https://github.com/rust-lang/rust/commit/b71107912de76a1092b1a0a18ca70922c1b4be5e"}], "stats": {"total": 53, "additions": 23, "deletions": 30}, "files": [{"sha": "0f19512d47a809263c9c12ace9be7e125875b312", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37954df1a71b204174719f28c59be8b38fd439f0/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37954df1a71b204174719f28c59be8b38fd439f0/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=37954df1a71b204174719f28c59be8b38fd439f0", "patch": "@@ -166,15 +166,6 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like the function of the same name on the HIR map, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n-        if self.all_fake_def_ids.borrow().contains(&def_id) {\n-            None\n-        } else {\n-            self.tcx.hir().as_local_node_id(def_id)\n-        }\n-    }\n-\n-    // FIXME(@ljedrz): remove the NodeId variant\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None"}, {"sha": "7202f7c2669fe242442ce3555f7f55beff1a1169", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37954df1a71b204174719f28c59be8b38fd439f0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37954df1a71b204174719f28c59be8b38fd439f0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=37954df1a71b204174719f28c59be8b38fd439f0", "patch": "@@ -38,7 +38,7 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n-    mod_ids: Vec<ast::NodeId>,\n+    mod_ids: Vec<hir::HirId>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -55,7 +55,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                path_str: &str,\n                ns: Namespace,\n                current_item: &Option<String>,\n-               parent_id: Option<ast::NodeId>)\n+               parent_id: Option<hir::HirId>)\n         -> Result<(Def, Option<String>), ()>\n     {\n         let cx = self.cx;\n@@ -64,8 +64,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // path.\n         if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n             // FIXME: `with_scope` requires the `NodeId` of a module.\n+            let node_id = cx.tcx.hir().hir_to_node_id(id);\n             let result = cx.enter_resolver(|resolver| {\n-                resolver.with_scope(id, |resolver| {\n+                resolver.with_scope(node_id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns == ValueNS)\n                 })\n             });\n@@ -127,7 +128,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             }\n \n             // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let ty = cx.enter_resolver(|resolver| resolver.with_scope(id, |resolver| {\n+            let node_id = cx.tcx.hir().hir_to_node_id(id);\n+            let ty = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             }))?;\n             match ty.def {\n@@ -215,11 +217,11 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         };\n \n         // FIXME: get the resolver to work with non-local resolve scopes.\n-        let parent_node = self.cx.as_local_node_id(item.def_id).and_then(|node_id| {\n+        let parent_node = self.cx.as_local_hir_id(item.def_id).and_then(|hir_id| {\n             // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n             // current `resolve()` implementation.\n-            match self.cx.tcx.hir().get_module_parent_node(node_id) {\n-                id if id != node_id => Some(id),\n+            match self.cx.tcx.hir().get_module_parent_node(hir_id) {\n+                id if id != hir_id => Some(id),\n                 _ => None,\n             }\n         });\n@@ -238,9 +240,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 } else {\n                     match parent_node.or(self.mod_ids.last().cloned()) {\n-                        Some(parent) if parent != ast::CRATE_NODE_ID => {\n+                        Some(parent) if parent != hir::CRATE_HIR_ID => {\n                             // FIXME: can we pull the parent module's name from elsewhere?\n-                            Some(self.cx.tcx.hir().name(parent).to_string())\n+                            Some(self.cx.tcx.hir().name_by_hir_id(parent).to_string())\n                         }\n                         _ => None,\n                     }\n@@ -257,7 +259,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         };\n \n         if item.is_mod() && item.attrs.inner_docs {\n-            self.mod_ids.push(self.cx.tcx.hir().hir_to_node_id(item_hir_id.unwrap()));\n+            self.mod_ids.push(item_hir_id.unwrap());\n         }\n \n         let cx = self.cx;\n@@ -391,7 +393,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         }\n \n         if item.is_mod() && !item.attrs.inner_docs {\n-            self.mod_ids.push(self.cx.tcx.hir().hir_to_node_id(item_hir_id.unwrap()));\n+            self.mod_ids.push(item_hir_id.unwrap());\n         }\n \n         if item.is_mod() {"}, {"sha": "badf37c96710361d1cd316574a0862e50ed9fc2b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37954df1a71b204174719f28c59be8b38fd439f0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37954df1a71b204174719f28c59be8b38fd439f0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=37954df1a71b204174719f28c59be8b38fd439f0", "patch": "@@ -31,7 +31,7 @@ pub struct RustdocVisitor<'a, 'tcx> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'tcx>,\n-    view_item_stack: FxHashSet<ast::NodeId>,\n+    view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n@@ -44,7 +44,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     ) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n-        stack.insert(ast::CRATE_NODE_ID);\n+        stack.insert(hir::CRATE_HIR_ID);\n         RustdocVisitor {\n             module: Module::new(None),\n             attrs: hir::HirVec::new(),\n@@ -271,13 +271,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                           om: &mut Module,\n                           please_inline: bool) -> bool {\n \n-        fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: ast::NodeId) -> bool {\n+        fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.hir().attrs(node).lists(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.hir().attrs_by_hir_id(node).lists(\"doc\").has_word(\"hidden\") {\n                     return true;\n                 }\n-                if node == ast::CRATE_NODE_ID {\n+                if node == hir::CRATE_HIR_ID {\n                     break;\n                 }\n             }\n@@ -326,21 +326,21 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false\n         }\n \n-        let def_node_id = match tcx.hir().as_local_node_id(def_did) {\n+        let def_hir_id = match tcx.hir().as_local_hir_id(def_did) {\n             Some(n) => n, None => return false\n         };\n \n         let is_private = !self.cx.renderinfo.borrow().access_levels.is_public(def_did);\n-        let is_hidden = inherits_doc_hidden(self.cx, def_node_id);\n+        let is_hidden = inherits_doc_hidden(self.cx, def_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false\n         }\n \n-        if !self.view_item_stack.insert(def_node_id) { return false }\n+        if !self.view_item_stack.insert(def_hir_id) { return false }\n \n-        let ret = match tcx.hir().get(def_node_id) {\n+        let ret = match tcx.hir().get_by_hir_id(def_hir_id) {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n@@ -373,7 +373,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        self.view_item_stack.remove(&def_node_id);\n+        self.view_item_stack.remove(&def_hir_id);\n         ret\n     }\n "}]}