{"sha": "12de1e8985016865ed6baa2262865336bbfdaa75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZGUxZTg5ODUwMTY4NjVlZDZiYWEyMjYyODY1MzM2YmJmZGFhNzU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-05T17:27:48Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-08T22:47:11Z"}, "message": "Do not collect tokens for doc comments", "tree": {"sha": "0e45f3f1f9640b9a99a44e089648dd26ee06822b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e45f3f1f9640b9a99a44e089648dd26ee06822b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12de1e8985016865ed6baa2262865336bbfdaa75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12de1e8985016865ed6baa2262865336bbfdaa75", "html_url": "https://github.com/rust-lang/rust/commit/12de1e8985016865ed6baa2262865336bbfdaa75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12de1e8985016865ed6baa2262865336bbfdaa75/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "html_url": "https://github.com/rust-lang/rust/commit/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1"}], "stats": {"total": 301, "additions": 140, "deletions": 161}, "files": [{"sha": "6961905038ffa34224182877364c252c60d0af44", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -2439,13 +2439,12 @@ pub struct Attribute {\n     /// or the construct this attribute is contained within (inner).\n     pub style: AttrStyle,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrKind {\n     /// A normal attribute.\n-    Normal(AttrItem),\n+    Normal(AttrItem, Option<LazyTokenStream>),\n \n     /// A doc comment (e.g. `/// ...`, `//! ...`, `/** ... */`, `/*! ... */`).\n     /// Doc attributes (e.g. `#[doc=\"...\"]`) are represented with the `Normal`"}, {"sha": "5c0c8df2e020b85829fa70ed6541f9d1e9184a53", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -8,7 +8,7 @@ use crate::ast::{Path, PathSegment};\n use crate::mut_visit::visit_clobber;\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Token};\n-use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n+use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream, TokenTree, TreeAndSpacing};\n \n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::{BytePos, Spanned};\n@@ -120,15 +120,15 @@ impl NestedMetaItem {\n impl Attribute {\n     pub fn has_name(&self, name: Symbol) -> bool {\n         match self.kind {\n-            AttrKind::Normal(ref item) => item.path == name,\n+            AttrKind::Normal(ref item, _) => item.path == name,\n             AttrKind::DocComment(..) => false,\n         }\n     }\n \n     /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n         match self.kind {\n-            AttrKind::Normal(ref item) => {\n+            AttrKind::Normal(ref item, _) => {\n                 if item.path.segments.len() == 1 {\n                     Some(item.path.segments[0].ident)\n                 } else {\n@@ -144,14 +144,14 @@ impl Attribute {\n \n     pub fn value_str(&self) -> Option<Symbol> {\n         match self.kind {\n-            AttrKind::Normal(ref item) => item.meta(self.span).and_then(|meta| meta.value_str()),\n+            AttrKind::Normal(ref item, _) => item.meta(self.span).and_then(|meta| meta.value_str()),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n         match self.kind {\n-            AttrKind::Normal(ref item) => match item.meta(self.span) {\n+            AttrKind::Normal(ref item, _) => match item.meta(self.span) {\n                 Some(MetaItem { kind: MetaItemKind::List(list), .. }) => Some(list),\n                 _ => None,\n             },\n@@ -160,7 +160,7 @@ impl Attribute {\n     }\n \n     pub fn is_word(&self) -> bool {\n-        if let AttrKind::Normal(item) = &self.kind {\n+        if let AttrKind::Normal(item, _) = &self.kind {\n             matches!(item.args, MacArgs::Empty)\n         } else {\n             false\n@@ -246,15 +246,15 @@ impl AttrItem {\n impl Attribute {\n     pub fn is_doc_comment(&self) -> bool {\n         match self.kind {\n-            AttrKind::Normal(_) => false,\n+            AttrKind::Normal(..) => false,\n             AttrKind::DocComment(..) => true,\n         }\n     }\n \n     pub fn doc_str(&self) -> Option<Symbol> {\n         match self.kind {\n             AttrKind::DocComment(.., data) => Some(data),\n-            AttrKind::Normal(ref item) if item.path == sym::doc => {\n+            AttrKind::Normal(ref item, _) if item.path == sym::doc => {\n                 item.meta(self.span).and_then(|meta| meta.value_str())\n             }\n             _ => None,\n@@ -263,25 +263,37 @@ impl Attribute {\n \n     pub fn get_normal_item(&self) -> &AttrItem {\n         match self.kind {\n-            AttrKind::Normal(ref item) => item,\n+            AttrKind::Normal(ref item, _) => item,\n             AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n         }\n     }\n \n     pub fn unwrap_normal_item(self) -> AttrItem {\n         match self.kind {\n-            AttrKind::Normal(item) => item,\n+            AttrKind::Normal(item, _) => item,\n             AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n         }\n     }\n \n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n         match self.kind {\n-            AttrKind::Normal(ref item) => item.meta(self.span),\n+            AttrKind::Normal(ref item, _) => item.meta(self.span),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n+\n+    pub fn tokens(&self) -> TokenStream {\n+        match self.kind {\n+            AttrKind::Normal(_, ref tokens) => tokens\n+                .as_ref()\n+                .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n+                .create_token_stream(),\n+            AttrKind::DocComment(comment_kind, data) => TokenStream::from(TokenTree::Token(\n+                Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n+            )),\n+        }\n+    }\n }\n \n /* Constructors */\n@@ -321,11 +333,16 @@ crate fn mk_attr_id() -> AttrId {\n }\n \n pub fn mk_attr(style: AttrStyle, path: Path, args: MacArgs, span: Span) -> Attribute {\n-    mk_attr_from_item(style, AttrItem { path, args, tokens: None }, span)\n+    mk_attr_from_item(AttrItem { path, args, tokens: None }, None, style, span)\n }\n \n-pub fn mk_attr_from_item(style: AttrStyle, item: AttrItem, span: Span) -> Attribute {\n-    Attribute { kind: AttrKind::Normal(item), id: mk_attr_id(), style, span, tokens: None }\n+pub fn mk_attr_from_item(\n+    item: AttrItem,\n+    tokens: Option<LazyTokenStream>,\n+    style: AttrStyle,\n+    span: Span,\n+) -> Attribute {\n+    Attribute { kind: AttrKind::Normal(item, tokens), id: mk_attr_id(), style, span }\n }\n \n /// Returns an inner attribute with the given value and span.\n@@ -344,13 +361,7 @@ pub fn mk_doc_comment(\n     data: Symbol,\n     span: Span,\n ) -> Attribute {\n-    Attribute {\n-        kind: AttrKind::DocComment(comment_kind, data),\n-        id: mk_attr_id(),\n-        style,\n-        span,\n-        tokens: None,\n-    }\n+    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: mk_attr_id(), style, span }\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {"}, {"sha": "91ba069cf600c58dabd61ec99186803cb27d975f", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -589,17 +589,17 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n-    let Attribute { kind, id: _, style: _, span, tokens } = attr;\n+    let Attribute { kind, id: _, style: _, span } = attr;\n     match kind {\n-        AttrKind::Normal(AttrItem { path, args, tokens }) => {\n+        AttrKind::Normal(AttrItem { path, args, tokens }, attr_tokens) => {\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n+            visit_lazy_tts(attr_tokens, vis);\n         }\n         AttrKind::DocComment(..) => {}\n     }\n     vis.visit_span(span);\n-    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {"}, {"sha": "6f65c0a1efc2db01d9d1779c5214f3f49cd8712b", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -886,7 +886,7 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n     match attr.kind {\n-        AttrKind::Normal(ref item) => walk_mac_args(visitor, &item.args),\n+        AttrKind::Normal(ref item, ref _tokens) => walk_mac_args(visitor, &item.args),\n         AttrKind::DocComment(..) => {}\n     }\n }"}, {"sha": "9a5fd2307d52dfc963a893e407d3e55433c7b04c", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -966,17 +966,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n+        // Tokens are also not needed after macro expansion and parsing.\n         let kind = match attr.kind {\n-            AttrKind::Normal(ref item) => AttrKind::Normal(AttrItem {\n-                path: item.path.clone(),\n-                args: self.lower_mac_args(&item.args),\n-                tokens: None,\n-            }),\n+            AttrKind::Normal(ref item, _) => AttrKind::Normal(\n+                AttrItem {\n+                    path: item.path.clone(),\n+                    args: self.lower_mac_args(&item.args),\n+                    tokens: None,\n+                },\n+                None,\n+            ),\n             AttrKind::DocComment(comment_kind, data) => AttrKind::DocComment(comment_kind, data),\n         };\n \n-        // Tokens aren't needed after macro expansion and parsing\n-        Attribute { kind, id: attr.id, style: attr.style, span: attr.span, tokens: None }\n+        Attribute { kind, id: attr.id, style: attr.style, span: attr.span }\n     }\n \n     fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {"}, {"sha": "a64014f5acbb828b0e2f8550975c4926b0b66184", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -426,7 +426,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n         self.maybe_print_comment(attr.span.lo());\n         match attr.kind {\n-            ast::AttrKind::Normal(ref item) => {\n+            ast::AttrKind::Normal(ref item, _) => {\n                 match attr.style {\n                     ast::AttrStyle::Inner => self.word(\"#![\"),\n                     ast::AttrStyle::Outer => self.word(\"#[\"),"}, {"sha": "c2239a2f6592492ff0d9304495e8489b1c6e31e6", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -291,8 +291,7 @@ impl<'a> StripUnconfigured<'a> {\n         expanded_attrs\n             .into_iter()\n             .flat_map(|(item, span)| {\n-                let orig_tokens =\n-                    attr.tokens.as_ref().unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", attr));\n+                let orig_tokens = attr.tokens();\n \n                 // We are taking an attribute of the form `#[cfg_attr(pred, attr)]`\n                 // and producing an attribute of the form `#[attr]`. We\n@@ -302,7 +301,7 @@ impl<'a> StripUnconfigured<'a> {\n \n                 // Use the `#` in `#[cfg_attr(pred, attr)]` as the `#` token\n                 // for `attr` when we expand it to `#[attr]`\n-                let pound_token = orig_tokens.create_token_stream().trees().next().unwrap();\n+                let pound_token = orig_tokens.trees().next().unwrap();\n                 if !matches!(pound_token, TokenTree::Token(Token { kind: TokenKind::Pound, .. })) {\n                     panic!(\"Bad tokens for attribute {:?}\", attr);\n                 }\n@@ -316,13 +315,12 @@ impl<'a> StripUnconfigured<'a> {\n                         .unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", item))\n                         .create_token_stream(),\n                 );\n-\n-                let mut attr = attr::mk_attr_from_item(attr.style, item, span);\n-                attr.tokens = Some(LazyTokenStream::new(TokenStream::new(vec![\n+                let tokens = Some(LazyTokenStream::new(TokenStream::new(vec![\n                     (pound_token, Spacing::Alone),\n                     (bracket_group, Spacing::Alone),\n                 ])));\n-                self.process_cfg_attr(attr)\n+\n+                self.process_cfg_attr(attr::mk_attr_from_item(item, tokens, attr.style, span))\n             })\n             .collect()\n     }"}, {"sha": "e06d81d49d16d1afb9f4697437374ce9923e70a7", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -1778,15 +1778,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n             let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n             *at = ast::Attribute {\n-                kind: ast::AttrKind::Normal(AttrItem {\n-                    path: meta.path,\n-                    args: meta.kind.mac_args(meta.span),\n-                    tokens: None,\n-                }),\n+                kind: ast::AttrKind::Normal(\n+                    AttrItem { path: meta.path, args: meta.kind.mac_args(meta.span), tokens: None },\n+                    None,\n+                ),\n                 span: at.span,\n                 id: at.id,\n                 style: at.style,\n-                tokens: None,\n             };\n         } else {\n             noop_visit_attribute(at, self)"}, {"sha": "bfbe15749ee1c8ca2f42e272a74fb707ef8a9fb2", "filename": "compiler/rustc_middle/src/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -40,8 +40,8 @@ impl<'ctx> rustc_ast::HashStableContext for StableHashingContext<'ctx> {\n         debug_assert!(!attr.ident().map_or(false, |ident| self.is_ignored_attr(ident.name)));\n         debug_assert!(!attr.is_doc_comment());\n \n-        let ast::Attribute { kind, id: _, style, span, tokens } = attr;\n-        if let ast::AttrKind::Normal(item) = kind {\n+        let ast::Attribute { kind, id: _, style, span } = attr;\n+        if let ast::AttrKind::Normal(item, tokens) = kind {\n             item.hash_stable(self, hasher);\n             style.hash_stable(self, hasher);\n             span.hash_stable(self, hasher);"}, {"sha": "f125a12147af5cf04149a4c98d4ea85d60e72e97", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -616,12 +616,7 @@ fn prepend_attrs(\n         if attr.style == ast::AttrStyle::Inner {\n             return None;\n         }\n-        builder.push(\n-            attr.tokens\n-                .as_ref()\n-                .unwrap_or_else(|| panic!(\"Attribute {:?} is missing tokens!\", attr))\n-                .create_token_stream(),\n-        );\n+        builder.push(attr.tokens());\n     }\n     builder.push(tokens);\n     Some(builder.build())"}, {"sha": "3738fbaeac84ffaeccd00bb6cfd14cdee0d3d0e2", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 74, "deletions": 99, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -30,52 +30,44 @@ impl<'a> Parser<'a> {\n         let mut just_parsed_doc_comment = false;\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\", self.token);\n-            let (attr, tokens) = if self.check(&token::Pound) {\n-                self.collect_tokens(|this| {\n-                    let inner_error_reason = if just_parsed_doc_comment {\n-                        \"an inner attribute is not permitted following an outer doc comment\"\n-                    } else if !attrs.is_empty() {\n-                        \"an inner attribute is not permitted following an outer attribute\"\n-                    } else {\n-                        DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n-                    };\n-                    let inner_parse_policy = InnerAttrPolicy::Forbidden {\n-                        reason: inner_error_reason,\n-                        saw_doc_comment: just_parsed_doc_comment,\n-                        prev_attr_sp: attrs.last().map(|a| a.span),\n-                    };\n-                    let attr = this.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n-                    just_parsed_doc_comment = false;\n-                    Ok(Some(attr))\n-                })?\n+            let attr = if self.check(&token::Pound) {\n+                let inner_error_reason = if just_parsed_doc_comment {\n+                    \"an inner attribute is not permitted following an outer doc comment\"\n+                } else if !attrs.is_empty() {\n+                    \"an inner attribute is not permitted following an outer attribute\"\n+                } else {\n+                    DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n+                };\n+                let inner_parse_policy = InnerAttrPolicy::Forbidden {\n+                    reason: inner_error_reason,\n+                    saw_doc_comment: just_parsed_doc_comment,\n+                    prev_attr_sp: attrs.last().map(|a| a.span),\n+                };\n+                just_parsed_doc_comment = false;\n+                Some(self.parse_attribute(inner_parse_policy)?)\n             } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n-                self.collect_tokens(|this| {\n-                    let attr =\n-                        attr::mk_doc_comment(comment_kind, attr_style, data, this.token.span);\n-                    if attr.style != ast::AttrStyle::Outer {\n-                        this.sess\n-                            .span_diagnostic\n-                            .struct_span_err_with_code(\n-                                this.token.span,\n-                                \"expected outer doc comment\",\n-                                error_code!(E0753),\n-                            )\n-                            .note(\n-                                \"inner doc comments like this (starting with \\\n-                                 `//!` or `/*!`) can only appear before items\",\n-                            )\n-                            .emit();\n-                    }\n-                    this.bump();\n-                    just_parsed_doc_comment = true;\n-                    Ok(Some(attr))\n-                })?\n+                if attr_style != ast::AttrStyle::Outer {\n+                    self.sess\n+                        .span_diagnostic\n+                        .struct_span_err_with_code(\n+                            self.token.span,\n+                            \"expected outer doc comment\",\n+                            error_code!(E0753),\n+                        )\n+                        .note(\n+                            \"inner doc comments like this (starting with \\\n+                         `//!` or `/*!`) can only appear before items\",\n+                        )\n+                        .emit();\n+                }\n+                self.bump();\n+                just_parsed_doc_comment = true;\n+                Some(attr::mk_doc_comment(comment_kind, attr_style, data, self.prev_token.span))\n             } else {\n-                (None, None)\n+                None\n             };\n \n-            if let Some(mut attr) = attr {\n-                attr.tokens = tokens;\n+            if let Some(attr) = attr {\n                 attrs.push(attr);\n             } else {\n                 break;\n@@ -85,49 +77,43 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `attribute = # ! [ meta_item ]`.\n-    ///\n-    /// If `permit_inner` is `true`, then a leading `!` indicates an inner\n-    /// attribute.\n-    pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<'a, ast::Attribute> {\n-        debug!(\"parse_attribute: permit_inner={:?} self.token={:?}\", permit_inner, self.token);\n-        let inner_parse_policy =\n-            if permit_inner { InnerAttrPolicy::Permitted } else { DEFAULT_INNER_ATTR_FORBIDDEN };\n-        self.parse_attribute_with_inner_parse_policy(inner_parse_policy)\n-    }\n-\n-    /// The same as `parse_attribute`, except it takes in an `InnerAttrPolicy`\n-    /// that prescribes how to handle inner attributes.\n-    fn parse_attribute_with_inner_parse_policy(\n+    /// `inner_parse_policy` prescribes how to handle inner attributes.\n+    fn parse_attribute(\n         &mut self,\n         inner_parse_policy: InnerAttrPolicy<'_>,\n     ) -> PResult<'a, ast::Attribute> {\n         debug!(\n-            \"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n+            \"parse_attribute: inner_parse_policy={:?} self.token={:?}\",\n             inner_parse_policy, self.token\n         );\n         let lo = self.token.span;\n-        let (span, item, style) = if self.eat(&token::Pound) {\n-            let style =\n-                if self.eat(&token::Not) { ast::AttrStyle::Inner } else { ast::AttrStyle::Outer };\n-\n-            self.expect(&token::OpenDelim(token::Bracket))?;\n-            let item = self.parse_attr_item(false)?;\n-            self.expect(&token::CloseDelim(token::Bracket))?;\n-            let attr_sp = lo.to(self.prev_token.span);\n-\n-            // Emit error if inner attribute is encountered and forbidden.\n-            if style == ast::AttrStyle::Inner {\n-                self.error_on_forbidden_inner_attr(attr_sp, inner_parse_policy);\n-            }\n+        let ((item, style, span), tokens) = self.collect_tokens(|this| {\n+            if this.eat(&token::Pound) {\n+                let style = if this.eat(&token::Not) {\n+                    ast::AttrStyle::Inner\n+                } else {\n+                    ast::AttrStyle::Outer\n+                };\n \n-            (attr_sp, item, style)\n-        } else {\n-            let token_str = pprust::token_to_string(&self.token);\n-            let msg = &format!(\"expected `#`, found `{}`\", token_str);\n-            return Err(self.struct_span_err(self.token.span, msg));\n-        };\n+                this.expect(&token::OpenDelim(token::Bracket))?;\n+                let item = this.parse_attr_item(false)?;\n+                this.expect(&token::CloseDelim(token::Bracket))?;\n+                let attr_sp = lo.to(this.prev_token.span);\n \n-        Ok(attr::mk_attr_from_item(style, item, span))\n+                // Emit error if inner attribute is encountered and forbidden.\n+                if style == ast::AttrStyle::Inner {\n+                    this.error_on_forbidden_inner_attr(attr_sp, inner_parse_policy);\n+                }\n+\n+                Ok((item, style, attr_sp))\n+            } else {\n+                let token_str = pprust::token_to_string(&this.token);\n+                let msg = &format!(\"expected `#`, found `{}`\", token_str);\n+                Err(this.struct_span_err(this.token.span, msg))\n+            }\n+        })?;\n+\n+        Ok(attr::mk_attr_from_item(item, tokens, style, span))\n     }\n \n     pub(super) fn error_on_forbidden_inner_attr(&self, attr_sp: Span, policy: InnerAttrPolicy<'_>) {\n@@ -196,30 +182,19 @@ impl<'a> Parser<'a> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n             // Only try to parse if it is an inner attribute (has `!`).\n-            let (attr, tokens) =\n-                if self.check(&token::Pound) && self.look_ahead(1, |t| t == &token::Not) {\n-                    self.collect_tokens(|this| {\n-                        let attr = this.parse_attribute(true)?;\n-                        assert_eq!(attr.style, ast::AttrStyle::Inner);\n-                        Ok(Some(attr))\n-                    })?\n-                } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n-                    self.collect_tokens(|this| {\n-                        // We need to get the position of this token before we bump.\n-                        let attr =\n-                            attr::mk_doc_comment(comment_kind, attr_style, data, this.token.span);\n-                        if attr.style == ast::AttrStyle::Inner {\n-                            this.bump();\n-                            Ok(Some(attr))\n-                        } else {\n-                            Ok(None)\n-                        }\n-                    })?\n+            let attr = if self.check(&token::Pound) && self.look_ahead(1, |t| t == &token::Not) {\n+                Some(self.parse_attribute(InnerAttrPolicy::Permitted)?)\n+            } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n+                if attr_style == ast::AttrStyle::Inner {\n+                    self.bump();\n+                    Some(attr::mk_doc_comment(comment_kind, attr_style, data, self.prev_token.span))\n                 } else {\n-                    (None, None)\n-                };\n-            if let Some(mut attr) = attr {\n-                attr.tokens = tokens;\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n+            if let Some(attr) = attr {\n                 attrs.push(attr);\n             } else {\n                 break;"}, {"sha": "b19cfc4d5c31a8d56a04d6c4469f3e857644e1c4", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"tokens\":null}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "65d6cd475ccf9692e5b6844843153b2b1a8a606c", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"tokens\":null}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "55904a0ec0a84131da7e6a1685a2879b806be232", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -588,7 +588,7 @@ impl EarlyLintPass for EarlyAttributes {\n \n fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::Item) {\n     for attr in &item.attrs {\n-        let attr_item = if let AttrKind::Normal(ref attr) = attr.kind {\n+        let attr_item = if let AttrKind::Normal(ref attr, _) = attr.kind {\n             attr\n         } else {\n             return;"}, {"sha": "b68e33f101d2b6d15c5b577ae2d6e46483ade234", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -509,7 +509,7 @@ pub fn eq_attr(l: &Attribute, r: &Attribute) -> bool {\n     l.style == r.style\n         && match (&l.kind, &r.kind) {\n             (DocComment(l1, l2), DocComment(r1, r2)) => l1 == r1 && l2 == r2,\n-            (Normal(l), Normal(r)) => eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args),\n+            (Normal(l, _), Normal(r, _)) => eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args),\n             _ => false,\n         }\n }"}, {"sha": "e6d41341a55f3bbd5666eee9963afc849dec97cb", "filename": "src/tools/clippy/clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -57,7 +57,7 @@ pub fn get_attr<'a>(\n     name: &'static str,\n ) -> impl Iterator<Item = &'a ast::Attribute> {\n     attrs.iter().filter(move |attr| {\n-        let attr = if let ast::AttrKind::Normal(ref attr) = attr.kind {\n+        let attr = if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n             attr\n         } else {\n             return false;"}, {"sha": "0d43fd0392eb262cacf4ecc3d1a80adc28ebbc2d", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12de1e8985016865ed6baa2262865336bbfdaa75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=12de1e8985016865ed6baa2262865336bbfdaa75", "patch": "@@ -1349,7 +1349,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n \n pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n     krate.item.attrs.iter().any(|attr| {\n-        if let ast::AttrKind::Normal(ref attr) = attr.kind {\n+        if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n             attr.path == symbol::sym::no_std\n         } else {\n             false"}]}