{"sha": "b031899dac6ad5847cc2f5551766a567657f095d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMzE4OTlkYWM2YWQ1ODQ3Y2MyZjU1NTE3NjZhNTY3NjU3ZjA5NWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-14T11:10:09Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-14T11:12:55Z"}, "message": "Compress match checking tests", "tree": {"sha": "47fc103c4e5a1b330b6f6c74388f21602e660cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47fc103c4e5a1b330b6f6c74388f21602e660cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b031899dac6ad5847cc2f5551766a567657f095d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b031899dac6ad5847cc2f5551766a567657f095d", "html_url": "https://github.com/rust-lang/rust/commit/b031899dac6ad5847cc2f5551766a567657f095d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b031899dac6ad5847cc2f5551766a567657f095d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af6984f6a6fad56f24345c03d018ac29549b169d", "url": "https://api.github.com/repos/rust-lang/rust/commits/af6984f6a6fad56f24345c03d018ac29549b169d", "html_url": "https://github.com/rust-lang/rust/commit/af6984f6a6fad56f24345c03d018ac29549b169d"}], "stats": {"total": 1587, "additions": 419, "deletions": 1168}, "files": [{"sha": "3016ca3bd5839294392992aa0f75cab3282bdef3", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b031899dac6ad5847cc2f5551766a567657f095d/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b031899dac6ad5847cc2f5551766a567657f095d/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=b031899dac6ad5847cc2f5551766a567657f095d", "patch": "@@ -261,8 +261,11 @@ fn check_diagnostics(ra_fixture: &str) {\n         // FXIME: macros...\n         let file_id = d.source().file_id.original_file(&db);\n         let range = d.syntax_node(&db).text_range();\n-        actual.entry(file_id).or_default().push((range, d.message().to_owned()));\n+        // FIXME: support multi-line messages in annotations\n+        let message = d.message().lines().next().unwrap().to_owned();\n+        actual.entry(file_id).or_default().push((range, message));\n     });\n+    actual.values_mut().for_each(|diags| diags.sort_by_key(|it| it.0.start()));\n \n     assert_eq!(annotations, actual);\n }"}, {"sha": "ba48b51b5ea85538ccc3c6bbb0fccf6666143e85", "filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 412, "deletions": 1149, "changes": 1561, "blob_url": "https://github.com/rust-lang/rust/blob/b031899dac6ad5847cc2f5551766a567657f095d/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b031899dac6ad5847cc2f5551766a567657f095d/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=b031899dac6ad5847cc2f5551766a567657f095d", "patch": "@@ -41,9 +41,9 @@\n //! ```ignore\n //! // x: (Option<bool>, Result<()>)\n //! match x {\n-//!     (Some(true), _) => {}\n-//!     (None, Err(())) => {}\n-//!     (None, Err(_)) => {}\n+//!     (Some(true), _) => (),\n+//!     (None, Err(())) => (),\n+//!     (None, Err(_)) => (),\n //! }\n //! ```\n //!\n@@ -837,1203 +837,499 @@ fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: Enum\n \n #[cfg(test)]\n mod tests {\n-    use insta::assert_snapshot;\n-    use ra_db::fixture::WithFixture;\n-\n-    use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n-\n-    fn check_diagnostic_message(ra_fixture: &str) -> String {\n-        TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().0\n-    }\n-\n-    fn check_diagnostic(ra_fixture: &str) {\n-        let diagnostic_count =\n-            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n-\n-        assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n-    }\n-\n-    fn check_no_diagnostic(ra_fixture: &str) {\n-        let (s, diagnostic_count) =\n-            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>();\n-\n-        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one: {}\", s);\n-    }\n-\n-    #[test]\n-    fn empty_tuple_no_arms_diagnostic_message() {\n-        assert_snapshot!(\n-            check_diagnostic_message(r\"\n-                fn test_fn() {\n-                    match () {\n-                    }\n-                }\n-            \"),\n-            @\"\\\"()\\\": Missing match arm\\n\"\n-        );\n-    }\n-\n-    #[test]\n-    fn empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn empty_tuple_wild() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                    _ => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    use crate::diagnostics::check_diagnostics;\n \n     #[test]\n-    fn empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                    () => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (()) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match () { }\n+        //^^ Missing match arm\n+   match (()) { }\n+       //^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (()) {\n-                    (()) => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_two_empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match ((), ()) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_two_empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match ((), ()) {\n-                    ((), ()) => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                    true => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                    true => {}\n-                    false => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, true) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                    (true, false) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_wilds() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (false, _) => {},\n-                    (true, false) => {},\n-                    (_, true) => {},\n-                }\n-            }\n-        \",\n+    match () { _ => (), }\n+    match () { () => (), }\n+    match (()) { (()) => (), }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_bools_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, true) => {},\n-                    (true, false) => {},\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn tuple_of_two_empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match ((), ()) { }\n+        //^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_bools_binding_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, _x) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_binding_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, _x) => {},\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                }\n-            }\n-        \",\n+    match ((), ()) { ((), ()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn boolean() {\n+        check_diagnostics(\n+            r#\"\n+fn test_main() {\n+    match false { }\n+        //^^^^^ Missing match arm\n+    match false { true => (), }\n+        //^^^^^ Missing match arm\n+    match (false, true) {}\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) { (true, true) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) {\n+        //^^^^^^^^^^^^^ Missing match arm\n+        (false, true) => (),\n+        (false, false) => (),\n+        (true, false) => (),\n+    }\n+    match (false, true) { (true, _x) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+\n+    match false { true => (), false => (), }\n+    match (false, true) {\n+        (false, _) => (),\n+        (true, false) => (),\n+        (_, true) => (),\n+    }\n+    match (false, true) {\n+        (true, true) => (),\n+        (true, false) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true) {\n+        (true, _x) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true, false) {\n+        (false, ..) => (),\n+        (true, ..) => (),\n+    }\n+    match (false, true, false) {\n+        (.., false) => (),\n+        (.., true) => (),\n+    }\n+    match (false, true, false) { (..) => (), }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (false, ..) => {},\n-                    (true, ..) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn tuple_of_tuple_and_bools() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, ((), false)) {}\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, ((), true)) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, _) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (.., false) => {},\n-                    (.., true) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, ((), true)) => (),\n+        (false, ((), false)) => (),\n     }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (..) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, _) => (),\n     }\n-\n-    #[test]\n-    fn tuple_of_tuple_and_bools_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_tuple_and_bools_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enums() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B, }\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                    (true, ((), false)) => {},\n-                    (false, ((), true)) => {},\n-                    (false, ((), false)) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+fn main() {\n+    match Either::A { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B { Either::A => (), }\n+        //^^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_wildcard_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, _) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match &Either::B {\n+        //^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n     }\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_wildcard_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                    (true, ((), false)) => {},\n-                    (false, _) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A => (), Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                }\n-            }\n-        \",\n-        );\n+    match &Either::B {\n+        Either::A => (), Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A => {},\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_containing_bool() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B }\n \n-    #[test]\n-    fn enum_ref_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match &Either::B {\n-                    Either::A => {},\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::B { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true) => (), Either::B => ()\n     }\n \n-    #[test]\n-    fn enum_ref_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match &Either::B {\n-                    Either::A => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A(true) => (),\n+        Either::A(false) => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_containing_bool_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::B => (),\n+        _ => (),\n     }\n-\n-    #[test]\n-    fn enum_containing_bool_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A(_) => (),\n+        Either::B => (),\n     }\n \n-    #[test]\n-    fn enum_containing_bool_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true) => (),\n-                    Either::A(false) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n+}\n+        \"#,\n         );\n     }\n \n     #[test]\n-    fn enum_containing_bool_with_wild_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::B => (),\n-                    _ => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_different_sizes() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n \n-    #[test]\n-    fn enum_containing_bool_with_wild_2_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(_) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::A(false) {\n+        //^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A(_) => (),\n+        Either::B(false, _) => (),\n     }\n \n-    #[test]\n-    fn enum_different_sizes_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(_) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::A(false) {\n+        Either::A(_) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n     }\n-\n-    #[test]\n-    fn enum_different_sizes_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(_) => (),\n-                    Either::B(true, _) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::A(false) {\n+        Either::A(true) | Either::A(false) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n     }\n-\n-    #[test]\n-    fn or_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(true) | Either::A(false) => (),\n-                    Either::B(true, _) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn tuple_of_enum_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            enum Either2 {\n-                C,\n-                D,\n-            }\n-            fn test_fn() {\n-                match (Either::A(false), Either2::C) {\n-                    (Either::A(true), _) | (Either::A(false), _) => (),\n-                    (Either::B(true, _), Either2::C) => (),\n-                    (Either::B(false, _), Either2::C) => (),\n-                    (Either::B(_, _), Either2::D) => (),\n-                }\n-            }\n-        \",\n-        );\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match (Either::A(false), Either2::C) {\n+        (Either::A(true), _) | (Either::A(false), _) => (),\n+        (Either::B(true, _), Either2::C) => (),\n+        (Either::B(false, _), Either2::C) => (),\n+        (Either::B(_, _), Either2::D) => (),\n     }\n-\n-    #[test]\n-    fn mismatched_types() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            enum Either2 {\n-                C,\n-                D,\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                    Either2::C => (),\n-                    Either2::D => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn mismatched_types_with_different_arity() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (true, false) {\n-                    (true, false, true) => (),\n-                    (true) => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn malformed_match_arm_tuple_missing_pattern() {\n+    fn mismatched_types() {\n         // Match statements with arms that don't match the\n         // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (0) {\n-                    () => (),\n-                }\n-            }\n-        \",\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match Either::A {\n+        Either2::C => (),\n+        Either2::D => (),\n+    }\n+    match (true, false) {\n+        (true, false, true) => (),\n+        (true) => (),\n+    }\n+    match (0) { () => () }\n+    match Unresolved::Bar { Unresolved::Baz => () }\n+}\n+        \"#,\n         );\n     }\n \n     #[test]\n     fn malformed_match_arm_tuple_enum_missing_pattern() {\n         // We are testing to be sure we don't panic here when the match\n         // arm `Either::B` is missing its pattern.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B(u32),\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                    Either::A => (),\n-                    Either::B() => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B(u32) }\n \n-    #[test]\n-    fn enum_not_in_scope() {\n-        // The enum is not in scope so we don't perform exhaustiveness\n-        // checking, but we want to be sure we don't panic here (and\n-        // we don't create a diagnostic).\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match Foo::Bar {\n-                    Foo::Baz => (),\n-                }\n-            }\n-        \",\n+fn main() {\n+    match Either::A {\n+        Either::A => (),\n+        Either::B() => (),\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn expr_diverges() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n \n-    #[test]\n-    fn expr_loop_with_break() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop { break Foo::A } {\n-                    Either::A => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n+fn main() {\n+    match loop {} {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+    match loop {} {\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn expr_partially_diverges() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either<T> {\n-                A(T),\n-                B,\n-            }\n-            fn foo() -> Either<!> {\n-                Either::B\n-            }\n-            fn test_fn() -> u32 {\n-                match foo() {\n-                    Either::A(val) => val,\n-                    Either::B => 0,\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either<T> { A(T), B }\n \n-    #[test]\n-    fn enum_record_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                }\n-            }\n-        \",\n-        );\n+fn foo() -> Either<!> { Either::B }\n+fn main() -> u32 {\n+    match foo() {\n+        Either::A(val) => val,\n+        Either::B => 0,\n     }\n-\n-    #[test]\n-    fn enum_record_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true } => (),\n-                    Either::A { foo: false } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A { foo: bool }, B }\n \n-    #[test]\n-    fn enum_record_missing_field_no_diagnostic() {\n-        // When `Either::A` is missing a struct member, we don't want\n-        // to fire the missing match arm diagnostic. This should fire\n-        // some other diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::A { foo: true };\n+    match a { }\n+        //^ Missing match arm\n+    match a { Either::A { foo: true } => () }\n+        //^ Missing match arm\n+    match a {\n+        Either::A { } => (),\n+                //^^^ Missing structure fields:\n+        Either::B => (),\n     }\n+    match a {\n+        //^ Missing match arm\n+        Either::A { } => (),\n+    }           //^^^ Missing structure fields:\n \n-    #[test]\n-    fn enum_record_missing_field_missing_match_arm() {\n-        // Even though `Either::A` is missing fields, we still want to fire\n-        // the missing arm diagnostic here, since we know `Either::B` is missing.\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { } => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: true } => (),\n+        Either::A { foo: false } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_no_diagnostic_wild() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: _ } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: _ } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_fields_out_of_order_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: () },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { bar: (), foo: false } => (),\n-                    Either::A { foo: true, bar: () } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_fields_out_of_order_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: () },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { bar: (), foo: false } => (),\n-                    Either::A { foo: true, bar: () } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record_fields_out_of_order() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: () },\n+    B,\n+}\n \n-    #[test]\n-    fn enum_record_ellipsis_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A { foo: true, .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::A { foo: true, bar: () };\n+    match a {\n+        //^ Missing match arm\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n     }\n \n-    #[test]\n-    fn enum_record_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true, .. } => (),\n-                    Either::A { foo: false, .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_ellipsis_all_fields_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { .. } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_ellipsis_all_fields_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: bool },\n+    B,\n+}\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(false, .., true) => {},\n-                    Either::A(false, .., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::B;\n+    match a {\n+        //^ Missing match arm\n+        Either::A { foo: true, .. } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis_2_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(.., true) => {},\n-                    Either::A(.., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        //^ Missing match arm\n+        Either::A { .. } => (),\n     }\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(false, .., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: true, .. } => (),\n+        Either::A { foo: false, .. } => (),\n+        Either::B => (),\n     }\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_2_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(.., true) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { .. } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_tuple_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(..) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_never() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Never {}\n+    fn enum_tuple_partial_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A(bool, bool, bool, bool),\n+    B,\n+}\n \n-            fn test_fn(never: Never) {\n-                match never {}\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::B => (),\n+    }\n+\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., true) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::A(.., false) => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn type_never() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn(never: !) {\n-                match never {}\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_never_ref() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Never {}\n+    fn never() {\n+        check_diagnostics(\n+            r#\"\n+enum Never {}\n \n-            fn test_fn(never: &Never) {\n-                match never {}\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_diverges_missing_arm() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                }\n-            }\n-        \",\n+fn enum_(never: Never) {\n+    match never {}\n+}\n+fn enum_ref(never: &Never) {\n+    match never {}\n+}\n+fn bang(never: !) {\n+    match never {}\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn or_pattern_panic() {\n-        check_no_diagnostic(\n-            r\"\n-            pub enum Category {\n-                Infinity,\n-                Zero,\n-            }\n+        check_diagnostics(\n+            r#\"\n+pub enum Category { Infinity, Zero }\n \n-            fn panic(a: Category, b: Category) {\n-                match (a, b) {\n-                    (Category::Zero | Category::Infinity, _) => {}\n-                    (_, Category::Zero | Category::Infinity) => {}\n-                }\n-            }\n-        \",\n-        );\n+fn panic(a: Category, b: Category) {\n+    match (a, b) {\n+        (Category::Zero | Category::Infinity, _) => (),\n+        (_, Category::Zero | Category::Infinity) => (),\n     }\n \n-    #[test]\n-    fn or_pattern_panic_2() {\n-        // FIXME: This is a false positive, but the code used to cause a panic in the match checker,\n-        // so this acts as a regression test for that.\n-        check_diagnostic(\n-            r\"\n-            pub enum Category {\n-                Infinity,\n-                Zero,\n-            }\n-\n-            fn panic(a: Category, b: Category) {\n-                match (a, b) {\n-                    (Category::Infinity, Category::Infinity) | (Category::Zero, Category::Zero) => {}\n-\n-                    (Category::Infinity | Category::Zero, _) => {}\n-                }\n-            }\n-        \",\n+    // FIXME: This is a false positive, but the code used to cause a panic in the match checker,\n+    // so this acts as a regression test for that.\n+    match (a, b) {\n+        //^^^^^^ Missing match arm\n+        (Category::Infinity, Category::Infinity) | (Category::Zero, Category::Zero) => (),\n+        (Category::Infinity | Category::Zero, _) => (),\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -2051,105 +1347,72 @@ mod tests {\n \n         #[test]\n         fn integers() {\n-            // This is a false negative.\n             // We don't currently check integer exhaustiveness.\n-            check_no_diagnostic(\n-                r\"\n-            fn test_fn() {\n-                match 5 {\n-                    10 => (),\n-                    11..20 => (),\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match 5 {\n+        10 => (),\n+        11..20 => (),\n+    }\n+}\n+\"#,\n             );\n         }\n \n         #[test]\n         fn internal_or() {\n-            // This is a false negative.\n             // We do not currently handle patterns with internal `or`s.\n-            check_no_diagnostic(\n-                r\"\n-            fn test_fn() {\n-                enum Either {\n-                    A(bool),\n-                    B,\n-                }\n-                match Either::B {\n-                    Either::A(true | false) => (),\n-                }\n-            }\n-        \",\n-            );\n-        }\n-\n-        #[test]\n-        fn expr_loop_missing_arm() {\n-            // This is a false negative.\n-            // We currently infer the type of `loop { break Foo::A }` to `!`, which\n-            // causes us to skip the diagnostic since `Either::A` doesn't type check\n-            // with `!`.\n-            check_diagnostic(\n-                r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop { break Foo::A } {\n-                    Either::A => (),\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    enum Either { A(bool), B }\n+    match Either::B {\n+        Either::A(true | false) => (),\n+    }\n+}\n+\"#,\n             );\n         }\n \n         #[test]\n         fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-            // This is a false negative.\n             // We don't currently handle tuple patterns with ellipsis.\n-            check_no_diagnostic(\n-                r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (false, ..) => {},\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (false, true, false) {\n+        (false, ..) => (),\n+    }\n+}\n+\"#,\n             );\n         }\n \n         #[test]\n         fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-            // This is a false negative.\n             // We don't currently handle tuple patterns with ellipsis.\n-            check_no_diagnostic(\n-                r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (.., false) => {},\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (false, true, false) {\n+        (.., false) => (),\n+    }\n+}\n+\"#,\n             );\n         }\n \n         #[test]\n         fn struct_missing_arm() {\n-            // This is a false negative.\n             // We don't currently handle structs.\n-            check_no_diagnostic(\n-                r\"\n-            struct Foo {\n-                a: bool,\n-            }\n-            fn test_fn(f: Foo) {\n-                match f {\n-                    Foo { a: true } => {},\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+struct Foo { a: bool }\n+fn main(f: Foo) {\n+    match f { Foo { a: true } => () }\n+}\n+\"#,\n             );\n         }\n     }"}, {"sha": "fb8723fb78f4c26634c4b2f9e42cb824bba91d9d", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b031899dac6ad5847cc2f5551766a567657f095d/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b031899dac6ad5847cc2f5551766a567657f095d/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=b031899dac6ad5847cc2f5551766a567657f095d", "patch": "@@ -82,7 +82,7 @@ impl FileLoader for TestDB {\n }\n \n impl TestDB {\n-    pub fn module_for_file(&self, file_id: FileId) -> ModuleId {\n+    pub(crate) fn module_for_file(&self, file_id: FileId) -> ModuleId {\n         for &krate in self.relevant_crates(file_id).iter() {\n             let crate_def_map = self.crate_def_map(krate);\n             for (local_id, data) in crate_def_map.modules.iter() {\n@@ -124,7 +124,7 @@ impl TestDB {\n         }\n     }\n \n-    pub fn diagnostics(&self) -> (String, u32) {\n+    pub(crate) fn diagnostics(&self) -> (String, u32) {\n         let mut buf = String::new();\n         let mut count = 0;\n         self.diag(|d| {\n@@ -134,22 +134,7 @@ impl TestDB {\n         (buf, count)\n     }\n \n-    /// Like `diagnostics`, but filtered for a single diagnostic.\n-    pub fn diagnostic<D: Diagnostic>(&self) -> (String, u32) {\n-        let mut buf = String::new();\n-        let mut count = 0;\n-        self.diag(|d| {\n-            // We want to filter diagnostics by the particular one we are testing for, to\n-            // avoid surprising results in tests.\n-            if d.downcast_ref::<D>().is_some() {\n-                format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-                count += 1;\n-            };\n-        });\n-        (buf, count)\n-    }\n-\n-    pub fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n+    pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n         let mut files = Vec::new();\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {"}]}