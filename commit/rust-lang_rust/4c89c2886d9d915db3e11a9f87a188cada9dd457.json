{"sha": "4c89c2886d9d915db3e11a9f87a188cada9dd457", "node_id": "C_kwDOAAsO6NoAKDRjODljMjg4NmQ5ZDkxNWRiM2UxMWE5Zjg3YTE4OGNhZGE5ZGQ0NTc", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-19T19:35:09Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-20T12:01:04Z"}, "message": "Clean up highlight `<span>` merge code", "tree": {"sha": "a9144ff21d6186c184e83c76499f26f2b7242a09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9144ff21d6186c184e83c76499f26f2b7242a09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c89c2886d9d915db3e11a9f87a188cada9dd457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c89c2886d9d915db3e11a9f87a188cada9dd457", "html_url": "https://github.com/rust-lang/rust/commit/4c89c2886d9d915db3e11a9f87a188cada9dd457", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c89c2886d9d915db3e11a9f87a188cada9dd457/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5b5d867d5954c2a843f6a3db338ea86fafd66b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b5d867d5954c2a843f6a3db338ea86fafd66b1", "html_url": "https://github.com/rust-lang/rust/commit/f5b5d867d5954c2a843f6a3db338ea86fafd66b1"}], "stats": {"total": 239, "additions": 118, "deletions": 121}, "files": [{"sha": "4a12d74ddef5a5844dd89255ed451eee1f43e7af", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 118, "deletions": 121, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/4c89c2886d9d915db3e11a9f87a188cada9dd457/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c89c2886d9d915db3e11a9f87a188cada9dd457/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=4c89c2886d9d915db3e11a9f87a188cada9dd457", "patch": "@@ -111,65 +111,6 @@ fn write_header(out: &mut Buffer, class: &str, extra_content: Option<Buffer>) {\n     write!(out, \"<code>\");\n }\n \n-/// Write all the pending elements sharing a same (or at mergeable) `Class`.\n-///\n-/// If there is a \"parent\" (if a `EnterSpan` event was encountered) and the parent can be merged\n-/// with the elements' class, then we simply write the elements since the `ExitSpan` event will\n-/// close the tag.\n-///\n-/// Otherwise, if there is only one pending element, we let the `string` function handle both\n-/// opening and closing the tag, otherwise we do it into this function.\n-fn write_pending_elems(\n-    out: &mut Buffer,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n-    pending_elems: &mut Vec<(&str, Option<Class>)>,\n-    current_class: &mut Option<Class>,\n-    closing_tags: &[(&str, Class)],\n-) {\n-    if pending_elems.is_empty() {\n-        return;\n-    }\n-    let mut done = false;\n-    if let Some((_, parent_class)) = closing_tags.last() {\n-        if can_merge(*current_class, Some(*parent_class), \"\") {\n-            for (text, class) in pending_elems.iter() {\n-                string(out, Escape(text), *class, &href_context, false);\n-            }\n-            done = true;\n-        }\n-    }\n-    if !done {\n-        // We only want to \"open\" the tag ourselves if we have more than one pending and if the current\n-        // parent tag is not the same as our pending content.\n-        let open_tag_ourselves = pending_elems.len() > 1 && current_class.is_some();\n-        let close_tag = if open_tag_ourselves {\n-            enter_span(out, current_class.unwrap(), &href_context)\n-        } else {\n-            \"\"\n-        };\n-        for (text, class) in pending_elems.iter() {\n-            string(out, Escape(text), *class, &href_context, !open_tag_ourselves);\n-        }\n-        if open_tag_ourselves {\n-            exit_span(out, close_tag);\n-        }\n-    }\n-    pending_elems.clear();\n-    *current_class = None;\n-}\n-\n-fn handle_exit_span(\n-    out: &mut Buffer,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n-    pending_elems: &mut Vec<(&str, Option<Class>)>,\n-    closing_tags: &mut Vec<(&str, Class)>,\n-) {\n-    let class = closing_tags.last().expect(\"ExitSpan without EnterSpan\").1;\n-    // We flush everything just in case...\n-    write_pending_elems(out, href_context, pending_elems, &mut Some(class), closing_tags);\n-    exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0);\n-}\n-\n /// Check if two `Class` can be merged together. In the following rules, \"unclassified\" means `None`\n /// basically (since it's `Option<Class>`). The following rules apply:\n ///\n@@ -187,6 +128,87 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n     }\n }\n \n+/// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n+/// the various functions (which became its methods).\n+struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    out: &'a mut Buffer,\n+    /// It contains the closing tag and the associated `Class`.\n+    closing_tags: Vec<(&'static str, Class)>,\n+    /// This is used because we don't automatically generate the closing tag on `ExitSpan` in\n+    /// case an `EnterSpan` event with the same class follows.\n+    pending_exit_span: Option<Class>,\n+    /// `current_class` and `pending_elems` are used to group HTML elements with same `class`\n+    /// attributes to reduce the DOM size.\n+    current_class: Option<Class>,\n+    /// We need to keep the `Class` for each element because it could contain a `Span` which is\n+    /// used to generate links.\n+    pending_elems: Vec<(&'b str, Option<Class>)>,\n+    href_context: Option<HrefContext<'c, 'd, 'e>>,\n+}\n+\n+impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    fn handle_exit_span(&mut self) {\n+        // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n+        // being used in `write_pending_elems`.\n+        let class = self.closing_tags.last().expect(\"ExitSpan without EnterSpan\").1;\n+        // We flush everything just in case...\n+        self.write_pending_elems(Some(class));\n+\n+        exit_span(self.out, self.closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0);\n+        self.pending_exit_span = None;\n+    }\n+\n+    /// Write all the pending elements sharing a same (or at mergeable) `Class`.\n+    ///\n+    /// If there is a \"parent\" (if a `EnterSpan` event was encountered) and the parent can be merged\n+    /// with the elements' class, then we simply write the elements since the `ExitSpan` event will\n+    /// close the tag.\n+    ///\n+    /// Otherwise, if there is only one pending element, we let the `string` function handle both\n+    /// opening and closing the tag, otherwise we do it into this function.\n+    ///\n+    /// It returns `true` if `current_class` must be set to `None` afterwards.\n+    fn write_pending_elems(&mut self, current_class: Option<Class>) -> bool {\n+        if self.pending_elems.is_empty() {\n+            return false;\n+        }\n+        if let Some((_, parent_class)) = self.closing_tags.last() &&\n+            can_merge(current_class, Some(*parent_class), \"\")\n+        {\n+            for (text, class) in self.pending_elems.iter() {\n+                string(self.out, Escape(text), *class, &self.href_context, false);\n+            }\n+        } else {\n+            // We only want to \"open\" the tag ourselves if we have more than one pending and if the\n+            // current parent tag is not the same as our pending content.\n+            let close_tag = if self.pending_elems.len() > 1 && current_class.is_some() {\n+                Some(enter_span(self.out, current_class.unwrap(), &self.href_context))\n+            } else {\n+                None\n+            };\n+            for (text, class) in self.pending_elems.iter() {\n+                string(self.out, Escape(text), *class, &self.href_context, close_tag.is_none());\n+            }\n+            if let Some(close_tag) = close_tag {\n+                exit_span(self.out, close_tag);\n+            }\n+        }\n+        self.pending_elems.clear();\n+        true\n+    }\n+}\n+\n+impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    /// When leaving, we need to flush all pending data to not have missing content.\n+    fn drop(&mut self) {\n+        if self.pending_exit_span.is_some() {\n+            self.handle_exit_span();\n+        } else {\n+            self.write_pending_elems(self.current_class);\n+        }\n+    }\n+}\n+\n /// Convert the given `src` source code into HTML by adding classes for highlighting.\n ///\n /// This code is used to render code blocks (in the documentation) as well as the source code pages.\n@@ -206,97 +228,72 @@ fn write_code(\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    // It contains the closing tag and the associated `Class`.\n-    let mut closing_tags: Vec<(&'static str, Class)> = Vec::new();\n-    // This is used because we don't automatically generate the closing tag on `ExitSpan` in\n-    // case an `EnterSpan` event with the same class follows.\n-    let mut pending_exit_span: Option<Class> = None;\n-    // The following two variables are used to group HTML elements with same `class` attributes\n-    // to reduce the DOM size.\n-    let mut current_class: Option<Class> = None;\n-    // We need to keep the `Class` for each element because it could contain a `Span` which is\n-    // used to generate links.\n-    let mut pending_elems: Vec<(&str, Option<Class>)> = Vec::new();\n+    let mut token_handler = TokenHandler {\n+        out,\n+        closing_tags: Vec::new(),\n+        pending_exit_span: None,\n+        current_class: None,\n+        pending_elems: Vec::new(),\n+        href_context,\n+    };\n \n     Classifier::new(\n         &src,\n-        href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n+        token_handler.href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n         decoration_info,\n     )\n     .highlight(&mut |highlight| {\n         match highlight {\n             Highlight::Token { text, class } => {\n                 // If we received a `ExitSpan` event and then have a non-compatible `Class`, we\n                 // need to close the `<span>`.\n-                if let Some(pending) = pending_exit_span &&\n+                let need_current_class_update = if let Some(pending) = token_handler.pending_exit_span &&\n                     !can_merge(Some(pending), class, text) {\n-                        handle_exit_span(\n-                            out,\n-                            &href_context,\n-                            &mut pending_elems,\n-                            &mut closing_tags,\n-                        );\n-                        pending_exit_span = None;\n-                        current_class = class.map(Class::dummy);\n+                        token_handler.handle_exit_span();\n+                        true\n                 // If the two `Class` are different, time to flush the current content and start\n                 // a new one.\n-                } else if !can_merge(current_class, class, text) {\n-                    write_pending_elems(\n-                        out,\n-                        &href_context,\n-                        &mut pending_elems,\n-                        &mut current_class,\n-                        &closing_tags,\n-                    );\n-                    current_class = class.map(Class::dummy);\n-                } else if current_class.is_none() {\n-                    current_class = class.map(Class::dummy);\n+                } else if !can_merge(token_handler.current_class, class, text) {\n+                    token_handler.write_pending_elems(token_handler.current_class);\n+                    true\n+                } else {\n+                    token_handler.current_class.is_none()\n+                };\n+\n+                if need_current_class_update {\n+                    token_handler.current_class = class.map(Class::dummy);\n                 }\n-                pending_elems.push((text, class));\n+                token_handler.pending_elems.push((text, class));\n             }\n             Highlight::EnterSpan { class } => {\n                 let mut should_add = true;\n-                if pending_exit_span.is_some() {\n-                    if !can_merge(Some(class), pending_exit_span, \"\") {\n-                        handle_exit_span(out, &href_context, &mut pending_elems, &mut closing_tags);\n-                    } else {\n+                if let Some(pending_exit_span) = token_handler.pending_exit_span {\n+                    if class.is_equal_to(pending_exit_span) {\n                         should_add = false;\n+                    } else {\n+                        token_handler.handle_exit_span();\n                     }\n                 } else {\n                     // We flush everything just in case...\n-                    write_pending_elems(\n-                        out,\n-                        &href_context,\n-                        &mut pending_elems,\n-                        &mut current_class,\n-                        &closing_tags,\n-                    );\n+                    if token_handler.write_pending_elems(token_handler.current_class) {\n+                        token_handler.current_class = None;\n+                    }\n                 }\n-                current_class = None;\n-                pending_exit_span = None;\n                 if should_add {\n-                    let closing_tag = enter_span(out, class, &href_context);\n-                    closing_tags.push((closing_tag, class));\n+                    let closing_tag = enter_span(token_handler.out, class, &token_handler.href_context);\n+                    token_handler.closing_tags.push((closing_tag, class));\n                 }\n+\n+                token_handler.current_class = None;\n+                token_handler.pending_exit_span = None;\n             }\n             Highlight::ExitSpan => {\n-                current_class = None;\n-                pending_exit_span =\n-                    Some(closing_tags.last().as_ref().expect(\"ExitSpan without EnterSpan\").1);\n+                token_handler.current_class = None;\n+                token_handler.pending_exit_span =\n+                    Some(token_handler.closing_tags.last().as_ref().expect(\"ExitSpan without EnterSpan\").1);\n             }\n         };\n     });\n-    if pending_exit_span.is_some() {\n-        handle_exit_span(out, &href_context, &mut pending_elems, &mut closing_tags);\n-    } else {\n-        write_pending_elems(\n-            out,\n-            &href_context,\n-            &mut pending_elems,\n-            &mut current_class,\n-            &closing_tags,\n-        );\n-    }\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {"}]}