{"sha": "6e88e96ccf1ca7621e6177d729a69625838db1c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlODhlOTZjY2YxY2E3NjIxZTYxNzdkNzI5YTY5NjI1ODM4ZGIxYzg=", "commit": {"author": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2019-07-13T15:16:57Z"}, "committer": {"name": "Ashley Mannix", "email": "kodraus@hey.com", "date": "2020-11-08T02:01:48Z"}, "message": "Support repr(simd) on ADTs containing a single array field\n\nThis PR allows using `#[repr(simd)]` on ADTs containing a\nsingle array field:\n\n```rust\n #[repr(simd)] struct S0([f32; 4]);\n #[repr(simd)] struct S1<const N: usize>([f32; N]);\n #[repr(simd)] struct S2<T, const N: usize>([T; N]);\n```\n\nThis should allow experimenting with portable packed SIMD\nabstractions on nightly that make use of const generics.", "tree": {"sha": "2c40921ebb7710ac9d5de81fb6ccccfb8e47169c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c40921ebb7710ac9d5de81fb6ccccfb8e47169c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e88e96ccf1ca7621e6177d729a69625838db1c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e88e96ccf1ca7621e6177d729a69625838db1c8", "html_url": "https://github.com/rust-lang/rust/commit/6e88e96ccf1ca7621e6177d729a69625838db1c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e88e96ccf1ca7621e6177d729a69625838db1c8/comments", "author": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d78d1d02761b906038ba4d54c5f3427f920f5fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d78d1d02761b906038ba4d54c5f3427f920f5fb", "html_url": "https://github.com/rust-lang/rust/commit/9d78d1d02761b906038ba4d54c5f3427f920f5fb"}], "stats": {"total": 587, "additions": 427, "deletions": 160}, "files": [{"sha": "2ea7d7ac2d822c3e4f715c0c6c10c26bffb102a7", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 72, "deletions": 50, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -740,6 +740,23 @@ fn generic_simd_intrinsic(\n     llret_ty: &'ll Type,\n     span: Span,\n ) -> Result<&'ll Value, ()> {\n+    // Given a SIMD vector type `x` return the element type and the number of\n+    // elements in the vector.\n+    fn simd_ty_and_len(bx: &Builder<'a, 'll, 'tcx>, simd_ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n+        let ty = if let ty::Adt(_def, _substs) = simd_ty.kind() {\n+            let f0_ty = bx.layout_of(simd_ty).field(bx, 0).ty;\n+            if let ty::Array(element_ty, _) = f0_ty.kind() { element_ty } else { f0_ty }\n+        } else {\n+            bug!(\"should only be called with a SIMD type\")\n+        };\n+        let count = if let abi::Abi::Vector { count, .. } = bx.layout_of(simd_ty).abi {\n+            count\n+        } else {\n+            bug!(\"should only be called with a SIMD type\")\n+        };\n+        (ty, count)\n+    }\n+\n     // macros for error handling:\n     macro_rules! emit_error {\n         ($msg: tt) => {\n@@ -792,7 +809,7 @@ fn generic_simd_intrinsic(\n             _ => return_error!(\"`{}` is not an integral type\", in_ty),\n         };\n         require_simd!(arg_tys[1], \"argument\");\n-        let v_len = arg_tys[1].simd_size(tcx);\n+        let (_, v_len) = simd_ty_and_len(bx, arg_tys[1]);\n         require!(\n             // Allow masks for vectors with fewer than 8 elements to be\n             // represented with a u8 or i8.\n@@ -812,8 +829,6 @@ fn generic_simd_intrinsic(\n     // every intrinsic below takes a SIMD vector as its first argument\n     require_simd!(arg_tys[0], \"input\");\n     let in_ty = arg_tys[0];\n-    let in_elem = arg_tys[0].simd_type(tcx);\n-    let in_len = arg_tys[0].simd_size(tcx);\n \n     let comparison = match name {\n         sym::simd_eq => Some(hir::BinOpKind::Eq),\n@@ -825,14 +840,15 @@ fn generic_simd_intrinsic(\n         _ => None,\n     };\n \n+    let (in_elem, in_len) = simd_ty_and_len(bx, arg_tys[0]);\n     if let Some(cmp_op) = comparison {\n         require_simd!(ret_ty, \"return\");\n \n-        let out_len = ret_ty.simd_size(tcx);\n+        let (out_ty, out_len) = simd_ty_and_len(bx, ret_ty);\n         require!(\n             in_len == out_len,\n             \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n+             found `{}` with length {}\",\n             in_len,\n             in_ty,\n             ret_ty,\n@@ -842,7 +858,7 @@ fn generic_simd_intrinsic(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n             \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n             ret_ty,\n-            ret_ty.simd_type(tcx)\n+            out_ty\n         );\n \n         return Ok(compare_simd_types(\n@@ -862,7 +878,7 @@ fn generic_simd_intrinsic(\n \n         require_simd!(ret_ty, \"return\");\n \n-        let out_len = ret_ty.simd_size(tcx);\n+        let (out_ty, out_len) = simd_ty_and_len(bx, ret_ty);\n         require!(\n             out_len == n,\n             \"expected return type of length {}, found `{}` with length {}\",\n@@ -871,13 +887,13 @@ fn generic_simd_intrinsic(\n             out_len\n         );\n         require!(\n-            in_elem == ret_ty.simd_type(tcx),\n+            in_elem == out_ty,\n             \"expected return element type `{}` (element of input `{}`), \\\n-                  found `{}` with element type `{}`\",\n+             found `{}` with element type `{}`\",\n             in_elem,\n             in_ty,\n             ret_ty,\n-            ret_ty.simd_type(tcx)\n+            out_ty\n         );\n \n         let total_len = u128::from(in_len) * 2;\n@@ -946,7 +962,7 @@ fn generic_simd_intrinsic(\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n         require_simd!(arg_tys[1], \"argument\");\n-        let v_len = arg_tys[1].simd_size(tcx);\n+        let (_, v_len) = simd_ty_and_len(bx, arg_tys[1]);\n         require!(\n             m_len == v_len,\n             \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n@@ -1171,25 +1187,27 @@ fn generic_simd_intrinsic(\n         require_simd!(ret_ty, \"return\");\n \n         // Of the same length:\n+        let (_, out_len) = simd_ty_and_len(bx, arg_tys[1]);\n+        let (_, out_len2) = simd_ty_and_len(bx, arg_tys[2]);\n         require!(\n-            in_len == arg_tys[1].simd_size(tcx),\n+            in_len == out_len,\n             \"expected {} argument with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n+             found `{}` with length {}\",\n             \"second\",\n             in_len,\n             in_ty,\n             arg_tys[1],\n-            arg_tys[1].simd_size(tcx)\n+            out_len\n         );\n         require!(\n-            in_len == arg_tys[2].simd_size(tcx),\n+            in_len == out_len2,\n             \"expected {} argument with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n+             found `{}` with length {}\",\n             \"third\",\n             in_len,\n             in_ty,\n             arg_tys[2],\n-            arg_tys[2].simd_size(tcx)\n+            out_len2\n         );\n \n         // The return type must match the first argument type\n@@ -1213,39 +1231,40 @@ fn generic_simd_intrinsic(\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n-        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind() {\n-            ty::RawPtr(p) if p.ty == in_elem => {\n-                (ptr_count(arg_tys[1].simd_type(tcx)), non_ptr(arg_tys[1].simd_type(tcx)))\n-            }\n+        let (element_ty0, _) = simd_ty_and_len(bx, arg_tys[0]);\n+        let (element_ty1, _) = simd_ty_and_len(bx, arg_tys[1]);\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem => (ptr_count(element_ty1), non_ptr(element_ty1)),\n             _ => {\n                 require!(\n                     false,\n                     \"expected element type `{}` of second argument `{}` \\\n-                                 to be a pointer to the element type `{}` of the first \\\n-                                 argument `{}`, found `{}` != `*_ {}`\",\n-                    arg_tys[1].simd_type(tcx),\n+                        to be a pointer to the element type `{}` of the first \\\n+                        argument `{}`, found `{}` != `*_ {}`\",\n+                    element_ty1,\n                     arg_tys[1],\n                     in_elem,\n                     in_ty,\n-                    arg_tys[1].simd_type(tcx),\n+                    element_ty1,\n                     in_elem\n                 );\n                 unreachable!();\n             }\n         };\n         assert!(pointer_count > 0);\n-        assert_eq!(pointer_count - 1, ptr_count(arg_tys[0].simd_type(tcx)));\n-        assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n \n         // The element type of the third argument must be a signed integer type of any width:\n-        match arg_tys[2].simd_type(tcx).kind() {\n+        let (element_ty2, _) = simd_ty_and_len(bx, arg_tys[2]);\n+        match element_ty2.kind() {\n             ty::Int(_) => (),\n             _ => {\n                 require!(\n                     false,\n                     \"expected element type `{}` of third argument `{}` \\\n                                  to be a signed integer type\",\n-                    arg_tys[2].simd_type(tcx),\n+                    element_ty2,\n                     arg_tys[2]\n                 );\n             }\n@@ -1297,25 +1316,27 @@ fn generic_simd_intrinsic(\n         require_simd!(arg_tys[2], \"third\");\n \n         // Of the same length:\n+        let (_, element_len1) = simd_ty_and_len(bx, arg_tys[1]);\n+        let (_, element_len2) = simd_ty_and_len(bx, arg_tys[2]);\n         require!(\n-            in_len == arg_tys[1].simd_size(tcx),\n+            in_len == element_len1,\n             \"expected {} argument with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n+            found `{}` with length {}\",\n             \"second\",\n             in_len,\n             in_ty,\n             arg_tys[1],\n-            arg_tys[1].simd_size(tcx)\n+            element_len1\n         );\n         require!(\n-            in_len == arg_tys[2].simd_size(tcx),\n+            in_len == element_len2,\n             \"expected {} argument with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n+            found `{}` with length {}\",\n             \"third\",\n             in_len,\n             in_ty,\n             arg_tys[2],\n-            arg_tys[2].simd_size(tcx)\n+            element_len2\n         );\n \n         // This counts how many pointers\n@@ -1336,39 +1357,42 @@ fn generic_simd_intrinsic(\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n-        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind() {\n+        let (element_ty0, _element_len0) = simd_ty_and_len(bx, arg_tys[0]);\n+        let (element_ty1, _element_len1) = simd_ty_and_len(bx, arg_tys[1]);\n+        let (element_ty2, _element_len2) = simd_ty_and_len(bx, arg_tys[2]);\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n             ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n-                (ptr_count(arg_tys[1].simd_type(tcx)), non_ptr(arg_tys[1].simd_type(tcx)))\n+                (ptr_count(element_ty1), non_ptr(element_ty1))\n             }\n             _ => {\n                 require!(\n                     false,\n                     \"expected element type `{}` of second argument `{}` \\\n-                                 to be a pointer to the element type `{}` of the first \\\n-                                 argument `{}`, found `{}` != `*mut {}`\",\n-                    arg_tys[1].simd_type(tcx),\n+                        to be a pointer to the element type `{}` of the first \\\n+                        argument `{}`, found `{}` != `*mut {}`\",\n+                    element_ty1,\n                     arg_tys[1],\n                     in_elem,\n                     in_ty,\n-                    arg_tys[1].simd_type(tcx),\n+                    element_ty1,\n                     in_elem\n                 );\n                 unreachable!();\n             }\n         };\n         assert!(pointer_count > 0);\n-        assert_eq!(pointer_count - 1, ptr_count(arg_tys[0].simd_type(tcx)));\n-        assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n \n         // The element type of the third argument must be a signed integer type of any width:\n-        match arg_tys[2].simd_type(tcx).kind() {\n+        match element_ty2.kind() {\n             ty::Int(_) => (),\n             _ => {\n                 require!(\n                     false,\n                     \"expected element type `{}` of third argument `{}` \\\n-                                 to be a signed integer type\",\n-                    arg_tys[2].simd_type(tcx),\n+                         be a signed integer type\",\n+                    element_ty2,\n                     arg_tys[2]\n                 );\n             }\n@@ -1565,7 +1589,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n     if name == sym::simd_cast {\n         require_simd!(ret_ty, \"return\");\n-        let out_len = ret_ty.simd_size(tcx);\n+        let (out_elem, out_len) = simd_ty_and_len(bx, ret_ty);\n         require!(\n             in_len == out_len,\n             \"expected return type with length {} (same as input type `{}`), \\\n@@ -1576,8 +1600,6 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             out_len\n         );\n         // casting cares about nominal type, not just structural type\n-        let out_elem = ret_ty.simd_type(tcx);\n-\n         if in_elem == out_elem {\n             return Ok(args[0].immediate());\n         }\n@@ -1693,7 +1715,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 return_error!(\n                     \"expected element type `{}` of vector type `{}` \\\n                      to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_type(tcx),\n+                    simd_ty_and_len(bx, arg_tys[0]).0,\n                     arg_tys[0]\n                 );\n             }"}, {"sha": "b0e2469019ab62061ece85b10deb24baa6e31c7e", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 91, "deletions": 18, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -631,30 +631,106 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             // SIMD vector types.\n-            ty::Adt(def, ..) if def.repr.simd() => {\n-                let element = self.layout_of(ty.simd_type(tcx))?;\n-                let count = ty.simd_size(tcx);\n-                assert!(count > 0);\n-                let scalar = match element.abi {\n-                    Abi::Scalar(ref scalar) => scalar.clone(),\n-                    _ => {\n+            ty::Adt(def, substs) if def.repr.simd() => {\n+                // Supported SIMD vectors are homogeneous ADTs with at least one field:\n+                //\n+                // * #[repr(simd)] struct S(T, T, T, T);\n+                // * #[repr(simd)] struct S { x: T, y: T, z: T, w: T }\n+                // * #[repr(simd)] struct S([T; 4])\n+                //\n+                // where T is a primitive scalar (integer/float/pointer).\n+\n+                // SIMD vectors with zero fields are not supported.\n+                // (should be caught by typeck)\n+                if def.non_enum_variant().fields.is_empty() {\n+                    tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` of zero length\", ty));\n+                }\n+\n+                // Type of the first ADT field:\n+                let f0_ty = def.non_enum_variant().fields[0].ty(tcx, substs);\n+\n+                // Heterogeneous SIMD vectors are not supported:\n+                // (should be caught by typeck)\n+                for fi in &def.non_enum_variant().fields {\n+                    if fi.ty(tcx, substs) != f0_ty {\n+                        tcx.sess.fatal(&format!(\"monomorphising heterogeneous SIMD type `{}`\", ty));\n+                    }\n+                }\n+\n+                // The element type and number of elements of the SIMD vector\n+                // are obtained from:\n+                //\n+                // * the element type and length of the single array field, if\n+                // the first field is of array type, or\n+                //\n+                // * the homogenous field type and the number of fields.\n+                let (e_ty, e_len, is_array) = if let ty::Array(e_ty, _) = f0_ty.kind() {\n+                    // First ADT field is an array:\n+\n+                    // SIMD vectors with multiple array fields are not supported:\n+                    // (should be caught by typeck)\n+                    if def.non_enum_variant().fields.len() != 1 {\n                         tcx.sess.fatal(&format!(\n-                            \"monomorphising SIMD type `{}` with \\\n-                                                 a non-machine element type `{}`\",\n-                            ty, element.ty\n+                            \"monomorphising SIMD type `{}` with more than one array field\",\n+                            ty\n                         ));\n                     }\n+\n+                    // Extract the number of elements from the layout of the array field:\n+                    let len = if let Ok(TyAndLayout {\n+                        layout: Layout { fields: FieldsShape::Array { count, .. }, .. },\n+                        ..\n+                    }) = self.layout_of(f0_ty)\n+                    {\n+                        count\n+                    } else {\n+                        return Err(LayoutError::Unknown(ty));\n+                    };\n+\n+                    (*e_ty, *len, true)\n+                } else {\n+                    // First ADT field is not an array:\n+                    (f0_ty, def.non_enum_variant().fields.len() as _, false)\n                 };\n-                let size =\n-                    element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow(ty))?;\n+\n+                // SIMD vectors of zero length are not supported.\n+                //\n+                // Can't be caught in typeck if the array length is generic.\n+                if e_len == 0 {\n+                    tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` of zero length\", ty));\n+                }\n+\n+                // Compute the ABI of the element type:\n+                let e_ly = self.layout_of(e_ty)?;\n+                let e_abi = if let Abi::Scalar(ref scalar) = e_ly.abi {\n+                    scalar.clone()\n+                } else {\n+                    // This error isn't caught in typeck, e.g., if\n+                    // the element type of the vector is generic.\n+                    tcx.sess.fatal(&format!(\n+                        \"monomorphising SIMD type `{}` with a non-primitive-scalar \\\n+                        (integer/float/pointer) element type `{}`\",\n+                        ty, e_ty\n+                    ))\n+                };\n+\n+                // Compute the size and alignment of the vector:\n+                let size = e_ly.size.checked_mul(e_len, dl).ok_or(LayoutError::SizeOverflow(ty))?;\n                 let align = dl.vector_align(size);\n                 let size = size.align_to(align.abi);\n \n+                // Compute the placement of the vector fields:\n+                let fields = if is_array {\n+                    FieldsShape::Arbitrary { offsets: vec![Size::ZERO], memory_index: vec![0] }\n+                } else {\n+                    FieldsShape::Array { stride: e_ly.size, count: e_len }\n+                };\n+\n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n-                    fields: FieldsShape::Array { stride: element.size, count },\n-                    abi: Abi::Vector { element: scalar, count },\n-                    largest_niche: element.largest_niche.clone(),\n+                    fields,\n+                    abi: Abi::Vector { element: e_abi, count: e_len },\n+                    largest_niche: e_ly.largest_niche.clone(),\n                     size,\n                     align,\n                 })\n@@ -2121,9 +2197,6 @@ where\n \n             ty::Tuple(tys) => tys[i].expect_ty(),\n \n-            // SIMD vector types.\n-            ty::Adt(def, ..) if def.repr.simd() => this.ty.simd_type(tcx),\n-\n             // ADTs.\n             ty::Adt(def, substs) => {\n                 match this.variants {"}, {"sha": "8202d0f0ef169f8fc5743212d52936c45c21201b", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1959,22 +1959,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn simd_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self.kind() {\n-            Adt(def, substs) => def.non_enum_variant().fields[0].ty(tcx, substs),\n-            _ => bug!(\"`simd_type` called on invalid type\"),\n-        }\n-    }\n-\n-    pub fn simd_size(&self, _tcx: TyCtxt<'tcx>) -> u64 {\n-        // Parameter currently unused, but probably needed in the future to\n-        // allow `#[repr(simd)] struct Simd<T, const N: usize>([T; N]);`.\n-        match self.kind() {\n-            Adt(def, _) => def.non_enum_variant().fields.len() as u64,\n-            _ => bug!(\"`simd_size` called on invalid type\"),\n-        }\n-    }\n-\n     pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {"}, {"sha": "4605238b0a1f1b8b5311c3d140d462947e7142b3", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1065,12 +1065,14 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n             match e.kind() {\n                 ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n                 _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }\n+                ty::Array(ty, _c) if ty.is_machine() => { /* struct([f32; 4]) */ }\n                 _ => {\n                     struct_span_err!(\n                         tcx.sess,\n                         sp,\n                         E0077,\n-                        \"SIMD vector element type should be machine type\"\n+                        \"SIMD vector element type should be a \\\n+                         primitive scalar (integer/float/pointer) type\"\n                     )\n                     .emit();\n                     return;"}, {"sha": "3dba044d376e8fbe31bcfa28bb1ddbcdf87c8d9f", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-generic-extract-insert.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-extract-insert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-extract-insert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-extract-insert.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -0,0 +1,47 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics, const_generics)]\n+#![allow(non_camel_case_types, incomplete_features)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct M(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct S<const N: usize>([f32; N]);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_extract<T, U>(x: T, idx: u32) -> U;\n+    fn simd_insert<T, U>(x: T, idx: u32, b: U) -> T;\n+}\n+\n+// CHECK-LABEL: @extract_m\n+#[no_mangle]\n+pub unsafe fn extract_m(v: M, i: u32) -> f32  {\n+    // CHECK: extractelement <4 x float> %0, i32 %i\n+    simd_extract(v, i)\n+}\n+\n+// CHECK-LABEL: @extract_s\n+#[no_mangle]\n+pub unsafe fn extract_s(v: S<4>, i: u32) -> f32  {\n+    // CHECK: extractelement <4 x float> %0, i32 %i\n+    simd_extract(v, i)\n+}\n+\n+// CHECK-LABEL: @insert_m\n+#[no_mangle]\n+pub unsafe fn insert_m(v: M, i: u32, j: f32) -> M  {\n+    // CHECK: insertelement <4 x float> %1, float %j, i32 %i\n+    simd_insert(v, i, j)\n+}\n+\n+// CHECK-LABEL: @insert_s\n+#[no_mangle]\n+pub unsafe fn insert_s(v: S<4>, i: u32, j: f32) -> S<4>  {\n+    // CHECK: insertelement <4 x float> %1, float %j, i32 %i\n+    simd_insert(v, i, j)\n+}"}, {"sha": "23098e7f64945b8bfd093a15b74d60a067c39e40", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-transmute-array.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -0,0 +1,44 @@\n+// ignore-tidy-linelength\n+// compile-flags: -C no-prepopulate-passes\n+// min-llvm-version 8.0\n+\n+#![crate_type = \"lib\"]\n+\n+#![allow(non_camel_case_types, incomplete_features)]\n+#![feature(repr_simd, platform_intrinsics, const_generics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct S<const N: usize>([f32; N]);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct T([f32; 4]);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct U(f32, f32, f32, f32);\n+\n+// CHECK-LABEL: @build_array_s\n+#[no_mangle]\n+pub fn build_array_s(x: [f32; 4]) -> S<4> {\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %3, i64 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %6, i64 16, i1 false)\n+    S::<4>(x)\n+}\n+\n+// CHECK-LABEL: @build_array_t\n+#[no_mangle]\n+pub fn build_array_t(x: [f32; 4]) -> T {\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %3, i64 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %6, i64 16, i1 false)\n+    T(x)\n+}\n+\n+// CHECK-LABEL: @build_array_u\n+#[no_mangle]\n+pub fn build_array_u(x: [f32; 4]) -> U {\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %3, i64 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %6, i64 16, i1 false)\n+    unsafe { std::mem::transmute(x) }\n+}"}, {"sha": "1938a9a272a16a6f9895521bef8a9497f47e6cbb", "filename": "src/test/ui/error-codes/E0077.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Ferror-codes%2FE0077.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Ferror-codes%2FE0077.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0077.stderr?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1,4 +1,4 @@\n-error[E0077]: SIMD vector element type should be machine type\n+error[E0077]: SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n   --> $DIR/E0077.rs:4:1\n    |\n LL | struct Bad(String);"}, {"sha": "0275f0ce4c159042c74dc2795c059d623ada90ec", "filename": "src/test/ui/simd-type-generic-monomorphisation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd-type-generic-monomorphisation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd-type-generic-monomorphisation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-type-generic-monomorphisation.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -2,7 +2,9 @@\n \n #![feature(repr_simd, platform_intrinsics)]\n \n-// error-pattern:monomorphising SIMD type `Simd2<X>` with a non-machine element type `X`\n+// ignore-tidy-linelength\n+\n+// error-pattern:monomorphising SIMD type `Simd2<X>` with a non-primitive-scalar (integer/float/pointer) element type `X`\n \n struct X(Vec<i32>);\n #[repr(simd)]"}, {"sha": "7f23893ac853645391cc109cb1ce71822c297c65", "filename": "src/test/ui/simd-type-generic-monomorphisation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd-type-generic-monomorphisation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd-type-generic-monomorphisation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-type-generic-monomorphisation.stderr?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1,4 +1,4 @@\n-error: monomorphising SIMD type `Simd2<X>` with a non-machine element type `X`\n+error: monomorphising SIMD type `Simd2<X>` with a non-primitive-scalar (integer/float/pointer) element type `X`\n \n error: aborting due to previous error\n "}, {"sha": "a320df85138e55c0ea3515fb57de6a30ceacfea1", "filename": "src/test/ui/simd-type.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-type.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1,10 +1,20 @@\n #![feature(repr_simd)]\n #![allow(non_camel_case_types)]\n \n+// ignore-tidy-linelength\n+\n #[repr(simd)]\n struct empty; //~ ERROR SIMD vector cannot be empty\n \n #[repr(simd)]\n struct i64f64(i64, f64); //~ ERROR SIMD vector should be homogeneous\n \n+struct Foo;\n+\n+#[repr(simd)]\n+struct FooV(Foo, Foo); //~ ERROR SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n+\n+#[repr(simd)]\n+struct FooV2([Foo; 2]); //~ ERROR SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n+\n fn main() {}"}, {"sha": "23004c785918c910649e175306a7d6de6a23d1e5", "filename": "src/test/ui/simd-type.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-type.stderr?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1,16 +1,28 @@\n error[E0075]: SIMD vector cannot be empty\n-  --> $DIR/simd-type.rs:5:1\n+  --> $DIR/simd-type.rs:7:1\n    |\n LL | struct empty;\n    | ^^^^^^^^^^^^^\n \n error[E0076]: SIMD vector should be homogeneous\n-  --> $DIR/simd-type.rs:8:1\n+  --> $DIR/simd-type.rs:10:1\n    |\n LL | struct i64f64(i64, f64);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ SIMD elements must have the same type\n \n-error: aborting due to 2 previous errors\n+error[E0077]: SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n+  --> $DIR/simd-type.rs:15:1\n+   |\n+LL | struct FooV(Foo, Foo);\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0077]: SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n+  --> $DIR/simd-type.rs:18:1\n+   |\n+LL | struct FooV2([Foo; 2]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0075, E0076.\n+Some errors have detailed explanations: E0075, E0076, E0077.\n For more information about an error, try `rustc --explain E0075`."}, {"sha": "c84988cffb423291ae576f3cd68cbe14a9b98fc8", "filename": "src/test/ui/simd/simd-array-type.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd%2Fsimd-array-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd%2Fsimd-array-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-array-type.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -0,0 +1,44 @@\n+// run-pass\n+#![allow(dead_code, incomplete_features)]\n+\n+// pretty-expanded FIXME #23616\n+\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+#![feature(const_generics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct S([i32; 4]);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct T<const N: usize>([i32; N]);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_insert<T, E>(x: T, idx: u32, y: E) -> T;\n+    fn simd_extract<T, E>(x: T, idx: u32) -> E;\n+}\n+\n+pub fn main() {\n+    let mut s = S([0; 4]);\n+\n+    unsafe {\n+        for i in 0_i32..4 {\n+            s = simd_insert(s, i as u32, i);\n+        }\n+        for i in 0_i32..4 {\n+            assert_eq!(i, simd_extract(s, i as u32));\n+        }\n+    }\n+\n+    let mut t = T::<4>([0; 4]);\n+    unsafe {\n+        for i in 0_i32..4 {\n+            t = simd_insert(t, i as u32, i);\n+        }\n+        for i in 0_i32..4 {\n+            assert_eq!(i, simd_extract(t, i as u32));\n+        }\n+    }\n+}"}, {"sha": "9877e37dfb2ec941346a79ced3da952b0d27e615", "filename": "src/test/ui/simd/simd-generics.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd%2Fsimd-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd%2Fsimd-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-generics.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1,16 +1,18 @@\n // run-pass\n-#![allow(non_camel_case_types)]\n-\n-\n-\n-#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types, incomplete_features)]\n+#![feature(repr_simd, platform_intrinsics, const_generics)]\n \n use std::ops;\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n struct f32x4(f32, f32, f32, f32);\n \n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct S<const N: usize>([f32; N]);\n+\n+\n extern \"platform-intrinsic\" {\n     fn simd_add<T>(x: T, y: T) -> T;\n }\n@@ -27,7 +29,16 @@ impl ops::Add for f32x4 {\n     }\n }\n \n-pub fn main() {\n+impl ops::Add for S<4> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        unsafe {simd_add(self, rhs)}\n+    }\n+}\n+\n+\n+pub fn main() { unsafe {\n     let lr = f32x4(1.0f32, 2.0f32, 3.0f32, 4.0f32);\n \n     // lame-o\n@@ -36,4 +47,11 @@ pub fn main() {\n     assert_eq!(y, 4.0f32);\n     assert_eq!(z, 6.0f32);\n     assert_eq!(w, 8.0f32);\n-}\n+\n+    let lr2 = S::<4>([1.0f32, 2.0f32, 3.0f32, 4.0f32]);\n+    let [x, y, z, w] = add(lr2, lr2).0;\n+    assert_eq!(x, 2.0f32);\n+    assert_eq!(y, 4.0f32);\n+    assert_eq!(z, 6.0f32);\n+    assert_eq!(w, 8.0f32);\n+}}"}, {"sha": "30a4fc11368d6b929d5fda1061fd4e98de7cb378", "filename": "src/test/ui/simd/simd-intrinsic-generic-arithmetic-saturating.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic-saturating.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1,16 +1,16 @@\n // run-pass\n // ignore-emscripten\n \n-#![allow(non_camel_case_types)]\n-#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types, incomplete_features)]\n+#![feature(repr_simd, platform_intrinsics, const_generics)]\n \n #[repr(simd)]\n #[derive(Copy, Clone, PartialEq, Debug)]\n struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n #[repr(simd)]\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+#[derive(Copy, Clone)]\n+struct I32<const N: usize>([i32; N]);\n \n extern \"platform-intrinsic\" {\n     fn simd_saturating_add<T>(x: T, y: T) -> T;\n@@ -51,41 +51,41 @@ fn main() {\n         const MIN: i32 = i32::MIN;\n         const MAX: i32 = i32::MAX;\n \n-        let a = i32x4(1, 2, 3, 4);\n-        let b = i32x4(2, 4, 6, 8);\n-        let c = i32x4(-1, -2, -3, -4);\n-        let d = i32x4(-2, -4, -6, -8);\n+        let a = I32::<4>([1, 2, 3, 4]);\n+        let b = I32::<4>([2, 4, 6, 8]);\n+        let c = I32::<4>([-1, -2, -3, -4]);\n+        let d = I32::<4>([-2, -4, -6, -8]);\n \n-        let max = i32x4(MAX, MAX, MAX, MAX);\n-        let max1 = i32x4(MAX - 1, MAX - 1, MAX - 1, MAX - 1);\n-        let min = i32x4(MIN, MIN, MIN, MIN);\n-        let min1 = i32x4(MIN + 1, MIN + 1, MIN + 1, MIN + 1);\n+        let max = I32::<4>([MAX, MAX, MAX, MAX]);\n+        let max1 = I32::<4>([MAX - 1, MAX - 1, MAX - 1, MAX - 1]);\n+        let min = I32::<4>([MIN, MIN, MIN, MIN]);\n+        let min1 = I32::<4>([MIN + 1, MIN + 1, MIN + 1, MIN + 1]);\n \n-        let z = i32x4(0, 0, 0, 0);\n+        let z = I32::<4>([0, 0, 0, 0]);\n \n         unsafe {\n-            assert_eq!(simd_saturating_add(z, z), z);\n-            assert_eq!(simd_saturating_add(z, a), a);\n-            assert_eq!(simd_saturating_add(b, z), b);\n-            assert_eq!(simd_saturating_add(a, a), b);\n-            assert_eq!(simd_saturating_add(a, max), max);\n-            assert_eq!(simd_saturating_add(max, b), max);\n-            assert_eq!(simd_saturating_add(max1, a), max);\n-            assert_eq!(simd_saturating_add(min1, z), min1);\n-            assert_eq!(simd_saturating_add(min, z), min);\n-            assert_eq!(simd_saturating_add(min1, c), min);\n-            assert_eq!(simd_saturating_add(min, c), min);\n-            assert_eq!(simd_saturating_add(min1, d), min);\n-            assert_eq!(simd_saturating_add(min, d), min);\n+            assert_eq!(simd_saturating_add(z, z).0, z.0);\n+            assert_eq!(simd_saturating_add(z, a).0, a.0);\n+            assert_eq!(simd_saturating_add(b, z).0, b.0);\n+            assert_eq!(simd_saturating_add(a, a).0, b.0);\n+            assert_eq!(simd_saturating_add(a, max).0, max.0);\n+            assert_eq!(simd_saturating_add(max, b).0, max.0);\n+            assert_eq!(simd_saturating_add(max1, a).0, max.0);\n+            assert_eq!(simd_saturating_add(min1, z).0, min1.0);\n+            assert_eq!(simd_saturating_add(min, z).0, min.0);\n+            assert_eq!(simd_saturating_add(min1, c).0, min.0);\n+            assert_eq!(simd_saturating_add(min, c).0, min.0);\n+            assert_eq!(simd_saturating_add(min1, d).0, min.0);\n+            assert_eq!(simd_saturating_add(min, d).0, min.0);\n \n-            assert_eq!(simd_saturating_sub(b, z), b);\n-            assert_eq!(simd_saturating_sub(b, a), a);\n-            assert_eq!(simd_saturating_sub(a, a), z);\n-            assert_eq!(simd_saturating_sub(a, b), c);\n-            assert_eq!(simd_saturating_sub(z, max), min1);\n-            assert_eq!(simd_saturating_sub(min1, z), min1);\n-            assert_eq!(simd_saturating_sub(min1, a), min);\n-            assert_eq!(simd_saturating_sub(min1, b), min);\n+            assert_eq!(simd_saturating_sub(b, z).0, b.0);\n+            assert_eq!(simd_saturating_sub(b, a).0, a.0);\n+            assert_eq!(simd_saturating_sub(a, a).0, z.0);\n+            assert_eq!(simd_saturating_sub(a, b).0, c.0);\n+            assert_eq!(simd_saturating_sub(z, max).0, min1.0);\n+            assert_eq!(simd_saturating_sub(min1, z).0, min1.0);\n+            assert_eq!(simd_saturating_sub(min1, a).0, min.0);\n+            assert_eq!(simd_saturating_sub(min1, b).0, min.0);\n         }\n     }\n }"}, {"sha": "83f11c6abdbf0d59cf11fa9f79887978e6bfc22e", "filename": "src/test/ui/simd/simd-intrinsic-generic-arithmetic.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e88e96ccf1ca7621e6177d729a69625838db1c8/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic.rs?ref=6e88e96ccf1ca7621e6177d729a69625838db1c8", "patch": "@@ -1,17 +1,17 @@\n // run-pass\n-#![allow(non_camel_case_types)]\n+#![allow(non_camel_case_types, incomplete_features)]\n \n // ignore-emscripten FIXME(#45351) hits an LLVM assert\n \n-#![feature(repr_simd, platform_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics, const_generics)]\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n-struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+struct U32<const N: usize>([u32; N]);\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -25,6 +25,15 @@ macro_rules! all_eq {\n     }}\n }\n \n+macro_rules! all_eq_ {\n+    ($a: expr, $b: expr) => {{\n+        let a = $a;\n+        let b = $b;\n+        assert!(a.0 == b.0);\n+    }}\n+}\n+\n+\n extern \"platform-intrinsic\" {\n     fn simd_add<T>(x: T, y: T) -> T;\n     fn simd_sub<T>(x: T, y: T) -> T;\n@@ -40,81 +49,81 @@ extern \"platform-intrinsic\" {\n \n fn main() {\n     let x1 = i32x4(1, 2, 3, 4);\n-    let y1 = u32x4(1, 2, 3, 4);\n+    let y1 = U32::<4>([1, 2, 3, 4]);\n     let z1 = f32x4(1.0, 2.0, 3.0, 4.0);\n     let x2 = i32x4(2, 3, 4, 5);\n-    let y2 = u32x4(2, 3, 4, 5);\n+    let y2 = U32::<4>([2, 3, 4, 5]);\n     let z2 = f32x4(2.0, 3.0, 4.0, 5.0);\n \n     unsafe {\n         all_eq!(simd_add(x1, x2), i32x4(3, 5, 7, 9));\n         all_eq!(simd_add(x2, x1), i32x4(3, 5, 7, 9));\n-        all_eq!(simd_add(y1, y2), u32x4(3, 5, 7, 9));\n-        all_eq!(simd_add(y2, y1), u32x4(3, 5, 7, 9));\n+        all_eq_!(simd_add(y1, y2), U32::<4>([3, 5, 7, 9]));\n+        all_eq_!(simd_add(y2, y1), U32::<4>([3, 5, 7, 9]));\n         all_eq!(simd_add(z1, z2), f32x4(3.0, 5.0, 7.0, 9.0));\n         all_eq!(simd_add(z2, z1), f32x4(3.0, 5.0, 7.0, 9.0));\n \n         all_eq!(simd_mul(x1, x2), i32x4(2, 6, 12, 20));\n         all_eq!(simd_mul(x2, x1), i32x4(2, 6, 12, 20));\n-        all_eq!(simd_mul(y1, y2), u32x4(2, 6, 12, 20));\n-        all_eq!(simd_mul(y2, y1), u32x4(2, 6, 12, 20));\n+        all_eq_!(simd_mul(y1, y2), U32::<4>([2, 6, 12, 20]));\n+        all_eq_!(simd_mul(y2, y1), U32::<4>([2, 6, 12, 20]));\n         all_eq!(simd_mul(z1, z2), f32x4(2.0, 6.0, 12.0, 20.0));\n         all_eq!(simd_mul(z2, z1), f32x4(2.0, 6.0, 12.0, 20.0));\n \n         all_eq!(simd_sub(x2, x1), i32x4(1, 1, 1, 1));\n         all_eq!(simd_sub(x1, x2), i32x4(-1, -1, -1, -1));\n-        all_eq!(simd_sub(y2, y1), u32x4(1, 1, 1, 1));\n-        all_eq!(simd_sub(y1, y2), u32x4(!0, !0, !0, !0));\n+        all_eq_!(simd_sub(y2, y1), U32::<4>([1, 1, 1, 1]));\n+        all_eq_!(simd_sub(y1, y2), U32::<4>([!0, !0, !0, !0]));\n         all_eq!(simd_sub(z2, z1), f32x4(1.0, 1.0, 1.0, 1.0));\n         all_eq!(simd_sub(z1, z2), f32x4(-1.0, -1.0, -1.0, -1.0));\n \n         all_eq!(simd_div(x1, x1), i32x4(1, 1, 1, 1));\n         all_eq!(simd_div(i32x4(2, 4, 6, 8), i32x4(2, 2, 2, 2)), x1);\n-        all_eq!(simd_div(y1, y1), u32x4(1, 1, 1, 1));\n-        all_eq!(simd_div(u32x4(2, 4, 6, 8), u32x4(2, 2, 2, 2)), y1);\n+        all_eq_!(simd_div(y1, y1), U32::<4>([1, 1, 1, 1]));\n+        all_eq_!(simd_div(U32::<4>([2, 4, 6, 8]), U32::<4>([2, 2, 2, 2])), y1);\n         all_eq!(simd_div(z1, z1), f32x4(1.0, 1.0, 1.0, 1.0));\n         all_eq!(simd_div(z1, z2), f32x4(1.0/2.0, 2.0/3.0, 3.0/4.0, 4.0/5.0));\n         all_eq!(simd_div(z2, z1), f32x4(2.0/1.0, 3.0/2.0, 4.0/3.0, 5.0/4.0));\n \n         all_eq!(simd_rem(x1, x1), i32x4(0, 0, 0, 0));\n         all_eq!(simd_rem(x2, x1), i32x4(0, 1, 1, 1));\n-        all_eq!(simd_rem(y1, y1), u32x4(0, 0, 0, 0));\n-        all_eq!(simd_rem(y2, y1), u32x4(0, 1, 1, 1));\n+        all_eq_!(simd_rem(y1, y1), U32::<4>([0, 0, 0, 0]));\n+        all_eq_!(simd_rem(y2, y1), U32::<4>([0, 1, 1, 1]));\n         all_eq!(simd_rem(z1, z1), f32x4(0.0, 0.0, 0.0, 0.0));\n         all_eq!(simd_rem(z1, z2), z1);\n         all_eq!(simd_rem(z2, z1), f32x4(0.0, 1.0, 1.0, 1.0));\n \n         all_eq!(simd_shl(x1, x2), i32x4(1 << 2, 2 << 3, 3 << 4, 4 << 5));\n         all_eq!(simd_shl(x2, x1), i32x4(2 << 1, 3 << 2, 4 << 3, 5 << 4));\n-        all_eq!(simd_shl(y1, y2), u32x4(1 << 2, 2 << 3, 3 << 4, 4 << 5));\n-        all_eq!(simd_shl(y2, y1), u32x4(2 << 1, 3 << 2, 4 << 3, 5 << 4));\n+        all_eq_!(simd_shl(y1, y2), U32::<4>([1 << 2, 2 << 3, 3 << 4, 4 << 5]));\n+        all_eq_!(simd_shl(y2, y1), U32::<4>([2 << 1, 3 << 2, 4 << 3, 5 << 4]));\n \n         // test right-shift by assuming left-shift is correct\n         all_eq!(simd_shr(simd_shl(x1, x2), x2), x1);\n         all_eq!(simd_shr(simd_shl(x2, x1), x1), x2);\n-        all_eq!(simd_shr(simd_shl(y1, y2), y2), y1);\n-        all_eq!(simd_shr(simd_shl(y2, y1), y1), y2);\n+        all_eq_!(simd_shr(simd_shl(y1, y2), y2), y1);\n+        all_eq_!(simd_shr(simd_shl(y2, y1), y1), y2);\n \n         // ensure we get logical vs. arithmetic shifts correct\n         let (a, b, c, d) = (-12, -123, -1234, -12345);\n         all_eq!(simd_shr(i32x4(a, b, c, d), x1), i32x4(a >> 1, b >> 2, c >> 3, d >> 4));\n-        all_eq!(simd_shr(u32x4(a as u32, b as u32, c as u32, d as u32), y1),\n-                u32x4((a as u32) >> 1, (b as u32) >> 2, (c as u32) >> 3, (d as u32) >> 4));\n+        all_eq_!(simd_shr(U32::<4>([a as u32, b as u32, c as u32, d as u32]), y1),\n+                U32::<4>([(a as u32) >> 1, (b as u32) >> 2, (c as u32) >> 3, (d as u32) >> 4]));\n \n         all_eq!(simd_and(x1, x2), i32x4(0, 2, 0, 4));\n         all_eq!(simd_and(x2, x1), i32x4(0, 2, 0, 4));\n-        all_eq!(simd_and(y1, y2), u32x4(0, 2, 0, 4));\n-        all_eq!(simd_and(y2, y1), u32x4(0, 2, 0, 4));\n+        all_eq_!(simd_and(y1, y2), U32::<4>([0, 2, 0, 4]));\n+        all_eq_!(simd_and(y2, y1), U32::<4>([0, 2, 0, 4]));\n \n         all_eq!(simd_or(x1, x2), i32x4(3, 3, 7, 5));\n         all_eq!(simd_or(x2, x1), i32x4(3, 3, 7, 5));\n-        all_eq!(simd_or(y1, y2), u32x4(3, 3, 7, 5));\n-        all_eq!(simd_or(y2, y1), u32x4(3, 3, 7, 5));\n+        all_eq_!(simd_or(y1, y2), U32::<4>([3, 3, 7, 5]));\n+        all_eq_!(simd_or(y2, y1), U32::<4>([3, 3, 7, 5]));\n \n         all_eq!(simd_xor(x1, x2), i32x4(3, 1, 7, 1));\n         all_eq!(simd_xor(x2, x1), i32x4(3, 1, 7, 1));\n-        all_eq!(simd_xor(y1, y2), u32x4(3, 1, 7, 1));\n-        all_eq!(simd_xor(y2, y1), u32x4(3, 1, 7, 1));\n+        all_eq_!(simd_xor(y1, y2), U32::<4>([3, 1, 7, 1]));\n+        all_eq_!(simd_xor(y2, y1), U32::<4>([3, 1, 7, 1]));\n \n     }\n }"}]}