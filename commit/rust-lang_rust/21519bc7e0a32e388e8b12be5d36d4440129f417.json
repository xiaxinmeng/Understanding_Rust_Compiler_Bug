{"sha": "21519bc7e0a32e388e8b12be5d36d4440129f417", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNTE5YmM3ZTBhMzJlMzg4ZThiMTJiZTVkMzZkNDQ0MDEyOWY0MTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-28T05:20:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-28T20:27:45Z"}, "message": "demode vec", "tree": {"sha": "bcdd50c7816a21a5d5422c114e722df1a5dcc65d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcdd50c7816a21a5d5422c114e722df1a5dcc65d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21519bc7e0a32e388e8b12be5d36d4440129f417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21519bc7e0a32e388e8b12be5d36d4440129f417", "html_url": "https://github.com/rust-lang/rust/commit/21519bc7e0a32e388e8b12be5d36d4440129f417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21519bc7e0a32e388e8b12be5d36d4440129f417/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c15dd6d8217a166cfd0d364a434771803123432", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c15dd6d8217a166cfd0d364a434771803123432", "html_url": "https://github.com/rust-lang/rust/commit/6c15dd6d8217a166cfd0d364a434771803123432"}], "stats": {"total": 1005, "additions": 541, "deletions": 464}, "files": [{"sha": "6136652c873289d647d72ac2bd55b9c7f3bf5ba8", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -527,7 +527,7 @@ fn load_one_source_package(src: @Source, p: &json::Object) {\n         Some(json::List(js)) => {\n           for js.each |j| {\n                 match *j {\n-                    json::String(j) => vec::grow(tags, 1u, j),\n+                    json::String(ref j) => tags.grow(1u, j),\n                     _ => ()\n                 }\n             }"}, {"sha": "ff695f64088f2fa40b59bde47c0e14c897513d9a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -503,10 +503,7 @@ fn make_run_args(config: config, _props: test_props, testfile: &Path) ->\n \n fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n     fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n-        fn flt(&&s: ~str) -> Option<~str> {\n-          if !str::is_whitespace(s) { option::Some(s) } else { option::None }\n-        }\n-        vec::filter_map(v, flt)\n+        vec::filter(v, |s| !str::is_whitespace(*s))\n     }\n \n     match argstr {"}, {"sha": "ace96c389efe6d94e252652ba39ea1d4924ee192", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -229,7 +229,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n                          filename: &Path, cx: context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n-                                  |a| safe_to_use_expr(a, cx.mode) );\n+                                  |a| safe_to_use_expr(*a, cx.mode) );\n     check_variants_T(crate, codemap, filename, ~\"expr\",\n                      extra_exprs + stolen.exprs, pprust::expr_to_str,\n                      replace_expr_in_crate, cx);"}, {"sha": "0bdf5caec0ce7b9fcb13fe94ccde022115500154", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -99,7 +99,7 @@ pub pure fn from_elem<T>(+data: T) -> DList<T> {\n \n pub fn from_vec<T: Copy>(+vec: &[T]) -> DList<T> {\n     do vec::foldl(DList(), vec) |list,data| {\n-        list.push(data); // Iterating left-to-right -- add newly to the tail.\n+        list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n     }\n }"}, {"sha": "d360eab3c8a29f76946be965eea7c2bc114e38f4", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -157,7 +157,7 @@ impl<A> DVec<A> {\n     fn pop() -> A {\n         do self.check_out |v| {\n             let mut v <- v;\n-            let result = vec::pop(v);\n+            let result = v.pop();\n             self.give_back(move v);\n             move result\n         }\n@@ -187,7 +187,7 @@ impl<A> DVec<A> {\n     fn shift() -> A {\n         do self.check_out |v| {\n             let mut v = move v;\n-            let result = vec::shift(v);\n+            let result = v.shift();\n             self.give_back(move v);\n             move result\n         }\n@@ -305,10 +305,10 @@ impl<A: Copy> DVec<A> {\n      * growing the vector if necessary.  New elements will be initialized\n      * with `initval`\n      */\n-    fn grow_set_elt(idx: uint, initval: A, +val: A) {\n+    fn grow_set_elt(idx: uint, initval: &A, +val: A) {\n         do self.swap |v| {\n             let mut v = move v;\n-            vec::grow_set(v, idx, initval, val);\n+            v.grow_set(idx, initval, val);\n             move v\n         }\n     }"}, {"sha": "098e82f5fad7ad58498545b4b015d3cd08578103", "filename": "src/libcore/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -140,7 +140,7 @@ pub fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n     // turn digits into string\n     // using stack of digits\n     while fractionalParts.is_not_empty() {\n-        let mut adjusted_digit = carry + vec::pop(fractionalParts);\n+        let mut adjusted_digit = carry + fractionalParts.pop();\n \n         if adjusted_digit == 10 {\n             carry = 1;"}, {"sha": "667aaaf7b0e9451a5820e30169e344beb884b60b", "filename": "src/libcore/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -64,11 +64,11 @@ trait ReaderUtil {\n impl<T: Reader> T : ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8] {\n         let mut buf = vec::with_capacity(len);\n-        unsafe { vec::raw::set_len(buf, len); }\n+        unsafe { vec::raw::set_len(&mut buf, len); }\n \n         let count = self.read(buf, len);\n \n-        unsafe { vec::raw::set_len(buf, count); }\n+        unsafe { vec::raw::set_len(&mut buf, count); }\n         move buf\n     }\n     fn read_line() -> ~str {\n@@ -695,7 +695,7 @@ impl BytesWriter: Writer {\n \n             let count = uint::max(buf_len, self.pos + v_len);\n             vec::reserve(&mut buf, count);\n-            unsafe { vec::raw::set_len(buf, count); }\n+            unsafe { vec::raw::set_len(&mut buf, count); }\n \n             {\n                 let view = vec::mut_view(buf, self.pos, count);"}, {"sha": "644cef42b41d71ea205f9cc82f6c8bebd0d1ae1a", "filename": "src/libcore/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -582,7 +582,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n     fn star(p: &Path) -> Path { p.push(\"*\") }\n \n     do rustrt::rust_list_files(star(p).to_str()).filter |filename| {\n-        filename != ~\".\" && filename != ~\"..\"\n+        *filename != ~\".\" && *filename != ~\"..\"\n     }\n }\n \n@@ -857,10 +857,10 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, ~\"VALUE\");\n-        assert !vec::contains(e, (copy n, ~\"VALUE\"));\n+        assert !vec::contains(e, &(copy n, ~\"VALUE\"));\n \n         e = env();\n-        assert vec::contains(e, (n, ~\"VALUE\"));\n+        assert vec::contains(e, &(n, ~\"VALUE\"));\n     }\n \n     #[test]"}, {"sha": "1afcc7ba09d57efbb6317dc4524f1a206a0ed46e", "filename": "src/libcore/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -221,7 +221,7 @@ impl PosixPath : GenericPath {\n     pure fn pop() -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unsafe { vec::pop(cs); }\n+            unsafe { cs.pop(); }\n         }\n         return PosixPath { components: move cs, ..self }\n     }\n@@ -415,7 +415,7 @@ impl WindowsPath : GenericPath {\n     pure fn pop() -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unsafe { vec::pop(cs); }\n+            unsafe { cs.pop(); }\n         }\n         return WindowsPath { components: move cs, ..self }\n     }\n@@ -437,7 +437,7 @@ pub pure fn normalize(components: &[~str]) -> ~[~str] {\n                 if *c == ~\".\" && components.len() > 1 { loop; }\n                 if *c == ~\"\" { loop; }\n                 if *c == ~\"..\" && cs.len() != 0 {\n-                    vec::pop(cs);\n+                    cs.pop();\n                     loop;\n                 }\n                 cs.push(copy *c);"}, {"sha": "7a4d15ac4fe8d8c8b964d2eec0d2863603aa4b3a", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -704,7 +704,7 @@ pub fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n     let mut remaining <- endpoints;\n-    let port = vec::swap_remove(remaining, ready);\n+    let port = remaining.swap_remove(ready);\n     let result = try_recv(move port);\n     (ready, move result, move remaining)\n }\n@@ -1067,7 +1067,7 @@ impl<T: Send> PortSet<T> : Recv<T> {\n                 }\n                 None => {\n                     // Remove this port.\n-                    let _ = vec::swap_remove(ports, i);\n+                    let _ = ports.swap_remove(i);\n                 }\n             }\n         }"}, {"sha": "7f1f1e4b34552cd195c3ce80205bdae1fad64c96", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -127,7 +127,7 @@ pub unsafe fn memset<T>(dst: *mut T, c: int, count: uint) {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n+pub pure fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -137,7 +137,7 @@ pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n+pub pure fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -147,7 +147,7 @@ pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n+pub pure fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n "}, {"sha": "a932a6133c5fe729fb52ea5603b5010bd432cc48", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -450,7 +450,7 @@ Section: Transforming strings\n  */\n pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n     let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n-    vec::raw::set_len(v, len(s));\n+    vec::raw::set_len(&mut v, len(s));\n     move v\n }\n \n@@ -1945,7 +1945,7 @@ fn reserve_at_least(s: &const ~str, n: uint) {\n  */\n pure fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n-        let vcap = vec::capacity(*buf);\n+        let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n         vcap - 1u\n     }\n@@ -2008,7 +2008,7 @@ mod raw {\n         vec::as_mut_buf(v, |vbuf, _len| {\n             ptr::memcpy(vbuf, buf as *u8, len)\n         });\n-        vec::raw::set_len(v, len);\n+        vec::raw::set_len(&mut v, len);\n         v.push(0u8);\n \n         assert is_utf8(v);\n@@ -2065,7 +2065,7 @@ mod raw {\n                     let src = ptr::offset(sbuf, begin);\n                     ptr::memcpy(vbuf, src, end - begin);\n                 }\n-                vec::raw::set_len(v, end - begin);\n+                vec::raw::set_len(&mut v, end - begin);\n                 v.push(0u8);\n                 ::cast::transmute(move v)\n             }"}, {"sha": "50f55383167fe6e4da96128e14405efebc2354c1", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -35,35 +35,44 @@ impl<T: Copy, U: Copy> (T, U): TupleOps<T,U> {\n }\n \n trait ExtendedTupleOps<A,B> {\n-    fn zip() -> ~[(A, B)];\n-    fn map<C>(f: &fn(A, B) -> C) -> ~[C];\n+    fn zip(&self) -> ~[(A, B)];\n+    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n }\n \n impl<A: Copy, B: Copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n-\n-    fn zip() -> ~[(A, B)] {\n-        let (a, b) = self;\n-        vec::zip_slice(a, b)\n+    fn zip(&self) -> ~[(A, B)] {\n+        match *self {\n+            (ref a, ref b) => {\n+                vec::zip_slice(*a, *b)\n+            }\n+        }\n     }\n \n-    fn map<C>(f: &fn(A, B) -> C) -> ~[C] {\n-        let (a, b) = self;\n-        vec::map2(a, b, f)\n+    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n+        match *self {\n+            (ref a, ref b) => {\n+                vec::map2(*a, *b, f)\n+            }\n+        }\n     }\n }\n \n impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n \n-    fn zip() -> ~[(A, B)] {\n-        // FIXME #2543: Bad copy\n-        let (a, b) = copy self;\n-        vec::zip(move a, move b)\n+    fn zip(&self) -> ~[(A, B)] {\n+        match *self {\n+            (ref a, ref b) => {\n+                vec::zip_slice(*a, *b)\n+            }\n+        }\n     }\n \n-    fn map<C>(f: &fn(A, B) -> C) -> ~[C] {\n-        // FIXME #2543: Bad copy\n-        let (a, b) = copy self;\n-        vec::map2(a, b, f)\n+    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n+        match *self {\n+            (ref a, ref b) => {\n+                vec::map2(*a, *b, f)\n+            }\n+        }\n     }\n }\n "}, {"sha": "914434c9d46a2965239c1a85e97098aa1e5ac3cd", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 301, "deletions": 229, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -1,5 +1,9 @@\n //! Vectors\n \n+#[warn(deprecated_mode)];\n+#[warn(deprecated_pattern)];\n+#[warn(non_camel_case_types)];\n+\n use cmp::{Eq, Ord};\n use option::{Some, None};\n use ptr::addr_of;\n@@ -140,7 +144,7 @@ pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n  */\n fn reserve<T>(+v: &mut ~[T], +n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n-    if capacity(*v) < n {\n+    if capacity(v) < n {\n         unsafe {\n             let ptr: **raw::VecRepr = cast::transmute(v);\n             rustrt::vec_reserve_shared(sys::get_type_desc::<T>(),\n@@ -170,16 +174,16 @@ fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pure fn capacity<T>(&&v: ~[const T]) -> uint {\n+pure fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+        let repr: **raw::VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n \n /// Returns the length of a vector\n #[inline(always)]\n-pure fn len<T>(&&v: &[const T]) -> uint {\n+pure fn len<T>(v: &[const T]) -> uint {\n     as_const_buf(v, |_p, len| len)\n }\n \n@@ -190,11 +194,18 @@ pure fn len<T>(&&v: &[const T]) -> uint {\n  * to the value returned by the function `op`.\n  */\n pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n-    let mut v = with_capacity(n_elts);\n-    let mut i: uint = 0u;\n-    while i < n_elts unsafe { raw::set(v, i, op(i)); i += 1u; }\n-    unsafe { raw::set_len(v, n_elts); }\n-    move v\n+    unsafe {\n+        let mut v = with_capacity(n_elts);\n+        do as_mut_buf(v) |p, _len| {\n+            let mut i: uint = 0u;\n+            while i < n_elts {\n+                rusti::move_val_init(*ptr::mut_offset(p, i), op(i));\n+                i += 1u;\n+            }\n+        }\n+        raw::set_len(&mut v, n_elts);\n+        return move v;\n+    }\n }\n \n /**\n@@ -203,14 +214,8 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n-    let mut v = with_capacity(n_elts);\n-    let mut i: uint = 0u;\n-    unsafe { // because unsafe::set is unsafe\n-        while i < n_elts { raw::set(v, i, t); i += 1u; }\n-        unsafe { raw::set_len(v, n_elts); }\n-    }\n-    move v\n+pure fn from_elem<T: Copy>(n_elts: uint, +t: T) -> ~[T] {\n+    from_fn(n_elts, |_i| copy t)\n }\n \n /// Creates a new unique vector with the same contents as the slice\n@@ -378,7 +383,7 @@ pure fn const_view<T>(v: &r/[const T], start: uint,\n }\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n-fn split<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n+fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -401,7 +406,7 @@ fn split<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n  * Split the vector `v` by applying each element against the predicate `f` up\n  * to `n` times.\n  */\n-fn splitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n+fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -427,7 +432,7 @@ fn splitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f`.\n  */\n-fn rsplit<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n+fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -451,7 +456,7 @@ fn rsplit<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f` up to `n times.\n  */\n-fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n+fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -477,12 +482,12 @@ fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n // Mutators\n \n /// Removes the first element from a vector and return it\n-fn shift<T>(&v: ~[T]) -> T {\n-    let ln = len::<T>(v);\n+fn shift<T>(v: &mut ~[T]) -> T {\n+    let ln = v.len();\n     assert (ln > 0);\n \n     let mut vv = ~[];\n-    v <-> vv;\n+    *v <-> vv;\n \n     unsafe {\n         let mut rr;\n@@ -495,52 +500,45 @@ fn shift<T>(&v: ~[T]) -> T {\n                 v.push(move r);\n             }\n         }\n-        raw::set_len(vv, 0);\n+        raw::set_len(&mut vv, 0);\n \n         move rr\n     }\n }\n \n /// Prepend an element to the vector\n-fn unshift<T>(&v: ~[T], +x: T) {\n+fn unshift<T>(v: &mut ~[T], +x: T) {\n     let mut vv = ~[move x];\n-    v <-> vv;\n-    while len(vv) > 0 {\n-        v.push(shift(vv));\n-    }\n+    *v <-> vv;\n+    v.push_all_move(vv);\n }\n \n fn consume<T>(+v: ~[T], f: fn(uint, +v: T)) unsafe {\n+    let mut v = move v; // FIXME(#3488)\n+\n     do as_imm_buf(v) |p, ln| {\n         for uint::range(0, ln) |i| {\n             let x <- *ptr::offset(p, i);\n             f(i, move x);\n         }\n     }\n \n-    raw::set_len(v, 0);\n+    raw::set_len(&mut v, 0);\n }\n \n-fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +v: T)) unsafe {\n-    do as_imm_buf(v) |p, ln| {\n-        for uint::range(0, ln) |i| {\n-            let x <- *ptr::offset(p, i);\n-            f(i, move x);\n-        }\n-    }\n-\n-    raw::set_len(v, 0);\n+fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +v: T)) {\n+    consume(vec::from_mut(v), f)\n }\n \n /// Remove the last element from a vector and return it\n-fn pop<T>(&v: ~[const T]) -> T {\n-    let ln = len(v);\n+fn pop<T>(v: &mut ~[T]) -> T {\n+    let ln = v.len();\n     if ln == 0 {\n         fail ~\"sorry, cannot vec::pop an empty vector\"\n     }\n-    let valptr = ptr::mut_addr_of(v[ln - 1u]);\n+    let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n     unsafe {\n-        let val <- *valptr;\n+        let val = move *valptr;\n         raw::set_len(v, ln - 1u);\n         move val\n     }\n@@ -552,21 +550,15 @@ fn pop<T>(&v: ~[const T]) -> T {\n  *\n  * Fails if index >= length.\n  */\n-fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n-    let ln = len(v);\n+fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n+    let ln = v.len();\n     if index >= ln {\n         fail fmt!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n     }\n-    let lastptr = ptr::mut_addr_of(v[ln - 1]);\n-    unsafe {\n-        let mut val <- *lastptr;\n-        if index < ln - 1 {\n-            let valptr = ptr::mut_addr_of(v[index]);\n-            *valptr <-> val;\n-        }\n-        raw::set_len(v, ln - 1);\n-        move val\n+    if index < ln - 1 {\n+        v[index] <-> v[ln - 1];\n     }\n+    vec::pop(v)\n }\n \n /// Append an element to a vector\n@@ -611,7 +603,8 @@ fn push_all<T: Copy>(+v: &mut ~[T], rhs: &[const T]) {\n }\n \n #[inline(always)]\n-fn push_all_move<T>(v: &mut ~[T], -rhs: ~[const T]) {\n+fn push_all_move<T>(v: &mut ~[T], +rhs: ~[T]) {\n+    let mut rhs = move rhs; // FIXME(#3488)\n     reserve(v, v.len() + rhs.len());\n     unsafe {\n         do as_imm_buf(rhs) |p, len| {\n@@ -620,13 +613,13 @@ fn push_all_move<T>(v: &mut ~[T], -rhs: ~[const T]) {\n                 push(v, move x);\n             }\n         }\n-        raw::set_len(rhs, 0);\n+        raw::set_len(&mut rhs, 0);\n     }\n }\n \n /// Shorten a vector, dropping excess elements.\n-fn truncate<T>(&v: ~[const T], newlen: uint) {\n-    do as_imm_buf(v) |p, oldlen| {\n+fn truncate<T>(v: &mut ~[T], newlen: uint) {\n+    do as_imm_buf(*v) |p, oldlen| {\n         assert(newlen <= oldlen);\n         unsafe {\n             // This loop is optimized out for non-drop types.\n@@ -642,10 +635,10 @@ fn truncate<T>(&v: ~[const T], newlen: uint) {\n  * Remove consecutive repeated elements from a vector; if the vector is\n  * sorted, this removes all duplicates.\n  */\n-fn dedup<T: Eq>(&v: ~[const T]) unsafe {\n+fn dedup<T: Eq>(v: &mut ~[T]) unsafe {\n     if v.len() < 1 { return; }\n     let mut last_written = 0, next_to_read = 1;\n-    do as_const_buf(v) |p, ln| {\n+    do as_const_buf(*v) |p, ln| {\n         // We have a mutable reference to v, so we can make arbitrary changes.\n         // (cf. push and pop)\n         let p = p as *mut T;\n@@ -704,12 +697,12 @@ pure fn append_mut<T: Copy>(+lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n  * * n - The number of elements to add\n  * * initval - The value for the new elements\n  */\n-fn grow<T: Copy>(&v: ~[T], n: uint, initval: T) {\n-    reserve_at_least(&mut v, len(v) + n);\n+fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n+    reserve_at_least(v, v.len() + n);\n     let mut i: uint = 0u;\n \n     while i < n {\n-        v.push(initval);\n+        v.push(*initval);\n         i += 1u;\n     }\n }\n@@ -727,8 +720,8 @@ fn grow<T: Copy>(&v: ~[T], n: uint, initval: T) {\n  * * init_op - A function to call to retreive each appended element's\n  *             value\n  */\n-fn grow_fn<T>(&v: ~[T], n: uint, op: iter::InitOp<T>) {\n-    reserve_at_least(&mut v, len(v) + n);\n+fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n+    reserve_at_least(v, v.len() + n);\n     let mut i: uint = 0u;\n     while i < n {\n         v.push(op(i));\n@@ -744,15 +737,16 @@ fn grow_fn<T>(&v: ~[T], n: uint, op: iter::InitOp<T>) {\n  * of the vector, expands the vector by replicating `initval` to fill the\n  * intervening space.\n  */\n-fn grow_set<T: Copy>(&v: ~[T], index: uint, initval: T, val: T) {\n-    if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n-    v[index] = val;\n+fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, +val: T) {\n+    let l = v.len();\n+    if index >= l { grow(v, index - l + 1u, initval); }\n+    v[index] = move val;\n }\n \n // Functional utilities\n \n /// Apply a function to each element of a vector and return the results\n-pure fn map<T, U>(v: &[T], f: fn(v: &T) -> U) -> ~[U] {\n+pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n     for each(v) |elem| {\n         unsafe {\n@@ -771,7 +765,7 @@ fn map_consume<T, U>(+v: ~[T], f: fn(+v: T) -> U) -> ~[U] {\n }\n \n /// Apply a function to each element of a vector and return the results\n-pure fn mapi<T, U>(v: &[T], f: fn(uint, v: &T) -> U) -> ~[U] {\n+pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n     let mut i = 0;\n     do map(v) |e| {\n         i += 1;\n@@ -783,21 +777,21 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, v: &T) -> U) -> ~[U] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n+pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) |elem| { unsafe{ result.push_all_move(f(*elem)); } }\n+    for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n     move result\n }\n \n /// Apply a function to each pair of elements and return the results\n pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n-                                  f: fn(T, U) -> V) -> ~[V] {\n+                                  f: fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n     let mut u: ~[V] = ~[];\n     let mut i = 0u;\n     while i < v0_len {\n-        unsafe { u.push(f(copy v0[i], copy v1[i])) };\n+        unsafe { u.push(f(&v0[i], &v1[i])) };\n         i += 1u;\n     }\n     move u\n@@ -809,11 +803,11 @@ pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n  * If function `f` returns `none` then that element is excluded from\n  * the resulting vector.\n  */\n-pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n+pure fn filter_map<T, U: Copy>(v: &[T], f: fn(t: &T) -> Option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        match f(*elem) {\n+        match f(elem) {\n           None => {/* no-op */ }\n           Some(result_elem) => unsafe { result.push(result_elem); }\n         }\n@@ -828,10 +822,10 @@ pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n+pure fn filter<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        if f(*elem) { unsafe { result.push(*elem); } }\n+        if f(elem) { unsafe { result.push(*elem); } }\n     }\n     move result\n }\n@@ -848,30 +842,32 @@ pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pure fn connect<T: Copy>(v: &[~[T]], sep: T) -> ~[T] {\n+pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n-        if first { first = false; } else { unsafe { r.push(sep); } }\n+        if first { first = false; } else { unsafe { r.push(*sep); } }\n         unsafe { r.push_all(*inner) };\n     }\n     move r\n }\n \n /// Reduce a vector from left to right\n-pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n+pure fn foldl<T: Copy, U>(+z: T, v: &[U], p: fn(+t: T, u: &U) -> T) -> T {\n     let mut accum = z;\n     for each(v) |elt| {\n-        accum = p(accum, *elt);\n+        // it should be possible to move accum in, but the liveness analysis\n+        // is not smart enough.\n+        accum = p(accum, elt);\n     }\n     return accum;\n }\n \n /// Reduce a vector from right to left\n-pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n+pure fn foldr<T, U: Copy>(v: &[T], +z: U, p: fn(t: &T, +u: U) -> U) -> U {\n     let mut accum = z;\n     for rev_each(v) |elt| {\n-        accum = p(*elt, accum);\n+        accum = p(elt, accum);\n     }\n     return accum;\n }\n@@ -881,8 +877,8 @@ pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n  *\n  * If the vector contains no elements then false is returned.\n  */\n-pure fn any<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) |elem| { if f(*elem) { return true; } }\n+pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+    for each(v) |elem| { if f(elem) { return true; } }\n     return false;\n }\n \n@@ -892,12 +888,12 @@ pure fn any<T>(v: &[T], f: fn(T) -> bool) -> bool {\n  * If the vectors contains no elements then false is returned.\n  */\n pure fn any2<T, U>(v0: &[T], v1: &[U],\n-                   f: fn(T, U) -> bool) -> bool {\n+                   f: fn(a: &T, b: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n     let mut i = 0u;\n     while i < v0_len && i < v1_len {\n-        if f(v0[i], v1[i]) { return true; };\n+        if f(&v0[i], &v1[i]) { return true; };\n         i += 1u;\n     }\n     return false;\n@@ -908,8 +904,8 @@ pure fn any2<T, U>(v0: &[T], v1: &[U],\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) |elem| { if !f(*elem) { return false; } }\n+pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+    for each(v) |elem| { if !f(elem) { return false; } }\n     return true;\n }\n \n@@ -918,8 +914,8 @@ pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n-    for eachi(v) |i, elem| { if !f(i, *elem) { return false; } }\n+pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n+    for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n     return true;\n }\n \n@@ -929,24 +925,24 @@ pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n  * If the vectors are not the same size then false is returned.\n  */\n pure fn all2<T, U>(v0: &[T], v1: &[U],\n-                   f: fn(T, U) -> bool) -> bool {\n+                   f: fn(t: &T, u: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { return false; }\n     let mut i = 0u;\n-    while i < v0_len { if !f(v0[i], v1[i]) { return false; }; i += 1u; }\n+    while i < v0_len { if !f(&v0[i], &v1[i]) { return false; }; i += 1u; }\n     return true;\n }\n \n /// Return true if a vector contains an element with the given value\n-pure fn contains<T: Eq>(v: &[T], x: T) -> bool {\n-    for each(v) |elt| { if x == *elt { return true; } }\n+pure fn contains<T: Eq>(v: &[T], x: &T) -> bool {\n+    for each(v) |elt| { if *x == *elt { return true; } }\n     return false;\n }\n \n /// Returns the number of elements that are equal to a given value\n-pure fn count<T: Eq>(v: &[T], x: T) -> uint {\n+pure fn count<T: Eq>(v: &[T], x: &T) -> uint {\n     let mut cnt = 0u;\n-    for each(v) |elt| { if x == *elt { cnt += 1u; } }\n+    for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n     return cnt;\n }\n \n@@ -957,7 +953,7 @@ pure fn count<T: Eq>(v: &[T], x: T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn find<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n+pure fn find<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -969,7 +965,7 @@ pure fn find<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n-                      f: fn(T) -> bool) -> Option<T> {\n+                      f: fn(t: &T) -> bool) -> Option<T> {\n     position_between(v, start, end, f).map(|i| v[*i])\n }\n \n@@ -980,7 +976,7 @@ pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rfind<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n+pure fn rfind<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -989,16 +985,16 @@ pure fn rfind<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  *\n  * Apply function `f` to each element of `v` in reverse order within the range\n  * [`start`, `end`). When function `f` returns true then an option containing\n- * the element is returned. If `f` matches no elements then none is returned.\n+ * the element is returned. If `f` matches no elements then none is return.\n  */\n pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n-                               f: fn(T) -> bool) -> Option<T> {\n+                               f: fn(t: &T) -> bool) -> Option<T> {\n     rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n /// Find the first index containing a matching value\n-pure fn position_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n-    position(v, |y| x == y)\n+pure fn position_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n+    position(v, |y| *x == *y)\n }\n \n /**\n@@ -1008,7 +1004,7 @@ pure fn position_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n  * then an option containing the index is returned. If `f` matches no elements\n  * then none is returned.\n  */\n-pure fn position<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n+pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -1020,17 +1016,17 @@ pure fn position<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n  * the index is returned. If `f` matches no elements then none is returned.\n  */\n pure fn position_between<T>(v: &[T], start: uint, end: uint,\n-                            f: fn(T) -> bool) -> Option<uint> {\n+                            f: fn(t: &T) -> bool) -> Option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = start;\n-    while i < end { if f(v[i]) { return Some::<uint>(i); } i += 1u; }\n+    while i < end { if f(&v[i]) { return Some::<uint>(i); } i += 1u; }\n     return None;\n }\n \n /// Find the last index containing a matching value\n-pure fn rposition_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n-    rposition(v, |y| x == y)\n+pure fn rposition_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n+    rposition(v, |y| *x == *y)\n }\n \n /**\n@@ -1040,7 +1036,7 @@ pure fn rposition_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n  * `f` returns true then an option containing the index is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rposition<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n+pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -1053,12 +1049,12 @@ pure fn rposition<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n  * returned.\n  */\n pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n-                             f: fn(T) -> bool) -> Option<uint> {\n+                             f: fn(t: &T) -> bool) -> Option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = end;\n     while i > start {\n-        if f(v[i - 1u]) { return Some::<uint>(i - 1u); }\n+        if f(&v[i - 1u]) { return Some::<uint>(i - 1u); }\n         i -= 1u;\n     }\n     return None;\n@@ -1122,12 +1118,13 @@ pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n  * Returns a vector of tuples, where the i-th tuple contains contains the\n  * i-th elements from each of the input vectors.\n  */\n-pure fn zip<T, U>(+v: ~[const T], +u: ~[const U]) -> ~[(T, U)] {\n-    let mut v = move v, u = move u, i = len(v);\n+pure fn zip<T, U>(+v: ~[T], +u: ~[U]) -> ~[(T, U)] {\n+    let mut v = move v, u = move u; // FIXME(#3488)\n+    let mut i = len(v);\n     assert i == len(u);\n     let mut w = with_capacity(i);\n     while i > 0 {\n-        unsafe { w.push((pop(v),pop(u))); }\n+        unsafe { w.push((v.pop(),u.pop())); }\n         i -= 1;\n     }\n     unsafe { reverse(w); }\n@@ -1269,10 +1266,10 @@ pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n+fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T)) {\n     assert len(v1) == len(v2);\n     for uint::range(0u, len(v1)) |i| {\n-        f(v1[i], v2[i])\n+        f(&v1[i], &v2[i])\n     }\n }\n \n@@ -1286,20 +1283,24 @@ fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pure fn permute<T: Copy>(v: &[const T], put: fn(~[T])) {\n+pure fn each_permutation<T: Copy>(+v: &[T], put: fn(ts: &[T]) -> bool) {\n     let ln = len(v);\n-    if ln == 0u {\n-        put(~[]);\n+    if ln <= 1 {\n+        put(v);\n     } else {\n+        // This does not seem like the most efficient implementation.  You\n+        // could make far fewer copies if you put your mind to it.\n         let mut i = 0u;\n         while i < ln {\n             let elt = v[i];\n             let mut rest = slice(v, 0u, i);\n             unsafe {\n                 rest.push_all(const_view(v, i+1u, ln));\n-                permute(rest, |permutation| {\n-                    put(append(~[elt], permutation))\n-                })\n+                for each_permutation(rest) |permutation| {\n+                    if !put(append(~[elt], permutation)) {\n+                        return;\n+                    }\n+                }\n             }\n             i += 1u;\n         }\n@@ -1528,20 +1529,20 @@ impl<T: Copy> &[const T]: CopyableVector<T> {\n \n trait ImmutableVector<T> {\n     pure fn view(start: uint, end: uint) -> &self/[T];\n-    pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U;\n-    pure fn map<U>(f: fn(v: &T) -> U) -> ~[U];\n-    pure fn mapi<U>(f: fn(uint, v: &T) -> U) -> ~[U];\n+    pure fn foldr<U: Copy>(z: U, p: fn(t: &T, +u: U) -> U) -> U;\n+    pure fn map<U>(f: fn(t: &T) -> U) -> ~[U];\n+    pure fn mapi<U>(f: fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n-    pure fn alli(f: fn(uint, T) -> bool) -> bool;\n-    pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U];\n-    pure fn filter_map<U: Copy>(f: fn(T) -> Option<U>) -> ~[U];\n+    pure fn alli(f: fn(uint, t: &T) -> bool) -> bool;\n+    pure fn flat_map<U>(f: fn(t: &T) -> ~[U]) -> ~[U];\n+    pure fn filter_map<U: Copy>(f: fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n trait ImmutableEqVector<T: Eq> {\n-    pure fn position(f: fn(T) -> bool) -> Option<uint>;\n-    pure fn position_elem(x: T) -> Option<uint>;\n-    pure fn rposition(f: fn(T) -> bool) -> Option<uint>;\n-    pure fn rposition_elem(x: T) -> Option<uint>;\n+    pure fn position(f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn position_elem(t: &T) -> Option<uint>;\n+    pure fn rposition(f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn rposition_elem(t: &T) -> Option<uint>;\n }\n \n /// Extension methods for vectors\n@@ -1552,15 +1553,17 @@ impl<T> &[T]: ImmutableVector<T> {\n     }\n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n+    pure fn foldr<U: Copy>(z: U, p: fn(t: &T, +u: U) -> U) -> U {\n+        foldr(self, z, p)\n+    }\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n-    pure fn map<U>(f: fn(v: &T) -> U) -> ~[U] { map(self, f) }\n+    pure fn map<U>(f: fn(t: &T) -> U) -> ~[U] { map(self, f) }\n     /**\n      * Apply a function to the index and value of each element in the vector\n      * and return the results\n      */\n-    pure fn mapi<U>(f: fn(uint, v: &T) -> U) -> ~[U] {\n+    pure fn mapi<U>(f: fn(uint, t: &T) -> U) -> ~[U] {\n         mapi(self, f)\n     }\n \n@@ -1580,23 +1583,25 @@ impl<T> &[T]: ImmutableVector<T> {\n      *\n      *     If the vector is empty, true is returned.\n      */\n-    pure fn alli(f: fn(uint, T) -> bool) -> bool {\n+    pure fn alli(f: fn(uint, t: &T) -> bool) -> bool {\n         alli(self, f)\n     }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n     #[inline]\n-    pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U] { flat_map(self, f) }\n+    pure fn flat_map<U>(f: fn(t: &T) -> ~[U]) -> ~[U] {\n+        flat_map(self, f)\n+    }\n     /**\n      * Apply a function to each element of a vector and return the results\n      *\n      * If function `f` returns `none` then that element is excluded from\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_map<U: Copy>(f: fn(T) -> Option<U>) -> ~[U] {\n+    pure fn filter_map<U: Copy>(f: fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_map(self, f)\n     }\n }\n@@ -1610,10 +1615,16 @@ impl<T: Eq> &[T]: ImmutableEqVector<T> {\n      * elements then none is returned.\n      */\n     #[inline]\n-    pure fn position(f: fn(T) -> bool) -> Option<uint> { position(self, f) }\n+    pure fn position(f: fn(t: &T) -> bool) -> Option<uint> {\n+        position(self, f)\n+    }\n+\n     /// Find the first index containing a matching value\n     #[inline]\n-    pure fn position_elem(x: T) -> Option<uint> { position_elem(self, x) }\n+    pure fn position_elem(x: &T) -> Option<uint> {\n+        position_elem(self, x)\n+    }\n+\n     /**\n      * Find the last index matching some predicate\n      *\n@@ -1622,15 +1633,21 @@ impl<T: Eq> &[T]: ImmutableEqVector<T> {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rposition(f: fn(T) -> bool) -> Option<uint> { rposition(self, f) }\n+    pure fn rposition(f: fn(t: &T) -> bool) -> Option<uint> {\n+        rposition(self, f)\n+    }\n+\n     /// Find the last index containing a matching value\n     #[inline]\n-    pure fn rposition_elem(x: T) -> Option<uint> { rposition_elem(self, x) }\n+    pure fn rposition_elem(t: &T) -> Option<uint> {\n+        rposition_elem(self, t)\n+    }\n }\n \n trait ImmutableCopyableVector<T> {\n-    pure fn filter(f: fn(T) -> bool) -> ~[T];\n-    pure fn rfind(f: fn(T) -> bool) -> Option<T>;\n+    pure fn filter(f: fn(t: &T) -> bool) -> ~[T];\n+\n+    pure fn rfind(f: fn(t: &T) -> bool) -> Option<T>;\n }\n \n /// Extension methods for vectors\n@@ -1643,7 +1660,10 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n      * containing only those elements for which `f` returned true.\n      */\n     #[inline]\n-    pure fn filter(f: fn(T) -> bool) -> ~[T] { filter(self, f) }\n+    pure fn filter(f: fn(t: &T) -> bool) -> ~[T] {\n+        filter(self, f)\n+    }\n+\n     /**\n      * Search for the last element that matches a given predicate\n      *\n@@ -1652,32 +1672,82 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rfind(f: fn(T) -> bool) -> Option<T> { rfind(self, f) }\n+    pure fn rfind(f: fn(t: &T) -> bool) -> Option<T> { rfind(self, f) }\n }\n \n trait MutableVector<T> {\n     fn push(&mut self, +t: T);\n-    fn push_all_move(&mut self, -rhs: ~[const T]);\n+    fn push_all_move(&mut self, +rhs: ~[T]);\n+    fn pop(&mut self) -> T;\n+    fn shift(&mut self) -> T;\n+    fn unshift(&mut self, +x: T);\n+    fn swap_remove(&mut self, index: uint) -> T;\n+    fn truncate(&mut self, newlen: uint);\n }\n \n trait MutableCopyableVector<T: Copy> {\n     fn push_all(&mut self, rhs: &[const T]);\n+    fn grow(&mut self, n: uint, initval: &T);\n+    fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n+    fn grow_set(&mut self, index: uint, initval: &T, +val: T);\n+}\n+\n+trait MutableEqVector<T: Eq> {\n+    fn dedup(&mut self);\n }\n \n impl<T> ~[T]: MutableVector<T> {\n     fn push(&mut self, +t: T) {\n         push(self, move t);\n     }\n \n-    fn push_all_move(&mut self, -rhs: ~[const T]) {\n+    fn push_all_move(&mut self, +rhs: ~[T]) {\n         push_all_move(self, move rhs);\n     }\n+\n+    fn pop(&mut self) -> T {\n+        pop(self)\n+    }\n+\n+    fn shift(&mut self) -> T {\n+        shift(self)\n+    }\n+\n+    fn unshift(&mut self, +x: T) {\n+        unshift(self, x)\n+    }\n+\n+    fn swap_remove(&mut self, index: uint) -> T {\n+        swap_remove(self, index)\n+    }\n+\n+    fn truncate(&mut self, newlen: uint) {\n+        truncate(self, newlen);\n+    }\n }\n \n impl<T: Copy> ~[T]: MutableCopyableVector<T> {\n     fn push_all(&mut self, rhs: &[const T]) {\n         push_all(self, rhs);\n     }\n+\n+    fn grow(&mut self, n: uint, initval: &T) {\n+        grow(self, n, initval);\n+    }\n+\n+    fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>) {\n+        grow_fn(self, n, op);\n+    }\n+\n+    fn grow_set(&mut self, index: uint, initval: &T, +val: T) {\n+        grow_set(self, index, initval, val);\n+    }\n+}\n+\n+impl<T: Eq> ~[T]: MutableEqVector<T> {\n+    fn dedup(&mut self) {\n+        dedup(self)\n+    }\n }\n \n /// Unsafe operations\n@@ -1714,7 +1784,7 @@ mod raw {\n     #[inline(always)]\n     unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n-        set_len(dst, elts);\n+        set_len(&mut dst, elts);\n         as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n         move dst\n     }\n@@ -1727,8 +1797,8 @@ mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline(always)]\n-    unsafe fn set_len<T>(&&v: ~[const T], new_len: uint) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+    unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n+        let repr: **VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n@@ -1742,22 +1812,22 @@ mod raw {\n      * would also make any pointers to it invalid.\n      */\n     #[inline(always)]\n-    unsafe fn to_ptr<T>(v: &[T]) -> *T {\n-        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n+    unsafe fn to_ptr<T>(+v: &[T]) -> *T {\n+        let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of((**repr).data));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    unsafe fn to_const_ptr<T>(v: &[const T]) -> *const T {\n-        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n+    unsafe fn to_const_ptr<T>(+v: &[const T]) -> *const T {\n+        let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of((**repr).data));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n-        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n+    unsafe fn to_mut_ptr<T>(+v: &[mut T]) -> *mut T {\n+        let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of((**repr).data));\n     }\n \n@@ -1782,10 +1852,12 @@ mod raw {\n     }\n \n     /**\n-     * Unchecked vector index assignment.\n+     * Unchecked vector index assignment.  Does not drop the\n+     * old value and hence is only suitable when the vector\n+     * is newly allocated.\n      */\n     #[inline(always)]\n-    unsafe fn set<T>(v: &[mut T], i: uint, +val: T) {\n+    unsafe fn init_elem<T>(v: &[mut T], i: uint, +val: T) {\n         let mut box = Some(move val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n@@ -1963,17 +2035,17 @@ mod tests {\n \n     fn square_ref(n: &uint) -> uint { return square(*n); }\n \n-    pure fn is_three(&&n: uint) -> bool { return n == 3u; }\n+    pure fn is_three(n: &uint) -> bool { return *n == 3u; }\n \n-    pure fn is_odd(&&n: uint) -> bool { return n % 2u == 1u; }\n+    pure fn is_odd(n: &uint) -> bool { return *n % 2u == 1u; }\n \n-    pure fn is_equal(&&x: uint, &&y:uint) -> bool { return x == y; }\n+    pure fn is_equal(x: &uint, y:&uint) -> bool { return *x == *y; }\n \n-    fn square_if_odd(&&n: uint) -> Option<uint> {\n-        return if n % 2u == 1u { Some(n * n) } else { None };\n+    fn square_if_odd(n: &uint) -> Option<uint> {\n+        return if *n % 2u == 1u { Some(*n * *n) } else { None };\n     }\n \n-    fn add(&&x: uint, &&y: uint) -> uint { return x + y; }\n+    fn add(+x: uint, y: &uint) -> uint { return x + *y; }\n \n     #[test]\n     fn test_unsafe_ptrs() {\n@@ -2103,15 +2175,15 @@ mod tests {\n     fn test_pop() {\n         // Test on-stack pop.\n         let mut v = ~[1, 2, 3];\n-        let mut e = pop(v);\n+        let mut e = v.pop();\n         assert (len(v) == 2u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n         assert (e == 3);\n \n         // Test on-heap pop.\n         v = ~[1, 2, 3, 4, 5];\n-        e = pop(v);\n+        e = v.pop();\n         assert (len(v) == 4u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n@@ -2123,11 +2195,11 @@ mod tests {\n     #[test]\n     fn test_swap_remove() {\n         let mut v = ~[1, 2, 3, 4, 5];\n-        let mut e = swap_remove(v, 0);\n+        let mut e = v.swap_remove(0);\n         assert (len(v) == 4);\n         assert e == 1;\n         assert (v[0] == 5);\n-        e = swap_remove(v, 3);\n+        e = v.swap_remove(3);\n         assert (len(v) == 3);\n         assert e == 4;\n         assert (v[0] == 5);\n@@ -2140,11 +2212,11 @@ mod tests {\n         // Tests that we don't accidentally run destructors twice.\n         let mut v = ~[::private::exclusive(()), ::private::exclusive(()),\n                       ::private::exclusive(())];\n-        let mut _e = swap_remove(v, 0);\n+        let mut _e = v.swap_remove(0);\n         assert (len(v) == 2);\n-        _e = swap_remove(v, 1);\n+        _e = v.swap_remove(1);\n         assert (len(v) == 1);\n-        _e = swap_remove(v, 0);\n+        _e = v.swap_remove(0);\n         assert (len(v) == 0);\n     }\n \n@@ -2167,13 +2239,13 @@ mod tests {\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = ~[];\n-        grow(v, 2u, 1);\n+        v.grow(2u, &1);\n         assert (len(v) == 2u);\n         assert (v[0] == 1);\n         assert (v[1] == 1);\n \n         // Test on-heap grow().\n-        grow(v, 3u, 2);\n+        v.grow(3u, &2);\n         assert (len(v) == 5u);\n         assert (v[0] == 1);\n         assert (v[1] == 1);\n@@ -2185,7 +2257,7 @@ mod tests {\n     #[test]\n     fn test_grow_fn() {\n         let mut v = ~[];\n-        grow_fn(v, 3u, square);\n+        v.grow_fn(3u, square);\n         assert (len(v) == 3u);\n         assert (v[0] == 0u);\n         assert (v[1] == 1u);\n@@ -2195,7 +2267,7 @@ mod tests {\n     #[test]\n     fn test_grow_set() {\n         let mut v = ~[1, 2, 3];\n-        grow_set(v, 4u, 4, 5);\n+        v.grow_set(4u, &4, 5);\n         assert (len(v) == 5u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n@@ -2207,7 +2279,7 @@ mod tests {\n     #[test]\n     fn test_truncate() {\n         let mut v = ~[@6,@5,@4];\n-        truncate(v, 1);\n+        v.truncate(1);\n         assert(v.len() == 1);\n         assert(*(v[0]) == 6);\n         // If the unsafe block didn't drop things properly, we blow up here.\n@@ -2217,7 +2289,7 @@ mod tests {\n     fn test_dedup() {\n         fn case(-a: ~[uint], -b: ~[uint]) {\n             let mut v = a;\n-            dedup(v);\n+            v.dedup();\n             assert(v == b);\n         }\n         case(~[], ~[]);\n@@ -2233,11 +2305,11 @@ mod tests {\n     #[test]\n     fn test_dedup_unique() {\n         let mut v0 = ~[~1, ~1, ~2, ~3];\n-        dedup(v0);\n+        v0.dedup();\n         let mut v1 = ~[~1, ~2, ~2, ~3];\n-        dedup(v1);\n+        v1.dedup();\n         let mut v2 = ~[~1, ~2, ~3, ~3];\n-        dedup(v2);\n+        v2.dedup();\n         /*\n          * If the ~pointers were leaked or otherwise misused, valgrind and/or\n          * rustrt should raise errors.\n@@ -2247,11 +2319,11 @@ mod tests {\n     #[test]\n     fn test_dedup_shared() {\n         let mut v0 = ~[@1, @1, @2, @3];\n-        dedup(v0);\n+        v0.dedup();\n         let mut v1 = ~[@1, @2, @2, @3];\n-        dedup(v1);\n+        v1.dedup();\n         let mut v2 = ~[@1, @2, @3, @3];\n-        dedup(v2);\n+        v2.dedup();\n         /*\n          * If the @pointers were leaked or otherwise misused, valgrind and/or\n          * rustrt should raise errors.\n@@ -2281,7 +2353,7 @@ mod tests {\n \n     #[test]\n     fn test_map2() {\n-        fn times(&&x: int, &&y: int) -> int { return x * y; }\n+        fn times(x: &int, y: &int) -> int { return *x * *y; }\n         let f = times;\n         let v0 = ~[1, 2, 3, 4, 5];\n         let v1 = ~[5, 4, 3, 2, 1];\n@@ -2307,9 +2379,9 @@ mod tests {\n         assert (w[1] == 9u);\n         assert (w[2] == 25u);\n \n-        fn halve(&&i: int) -> Option<int> {\n-            if i % 2 == 0 {\n-                return option::Some::<int>(i / 2);\n+        fn halve(i: &int) -> Option<int> {\n+            if *i % 2 == 0 {\n+                return option::Some::<int>(*i / 2);\n             } else { return option::None::<int>; }\n         }\n         fn halve_for_sure(i: &int) -> int { return *i / 2; }\n@@ -2345,8 +2417,8 @@ mod tests {\n \n     #[test]\n     fn test_foldl2() {\n-        fn sub(&&a: int, &&b: int) -> int {\n-            a - b\n+        fn sub(+a: int, b: &int) -> int {\n+            a - *b\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldl(0, v, sub);\n@@ -2355,8 +2427,8 @@ mod tests {\n \n     #[test]\n     fn test_foldr() {\n-        fn sub(&&a: int, &&b: int) -> int {\n-            a - b\n+        fn sub(a: &int, +b: int) -> int {\n+            *a - b\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldr(v, 0, sub);\n@@ -2419,23 +2491,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_permute() {\n+    fn test_each_permutation() {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        permute(~[], |v| results.push(copy v));\n+        for each_permutation(~[]) |v| { results.push(from_slice(v)); }\n         assert results == ~[~[]];\n \n         results = ~[];\n-        permute(~[7], |v| results.push(copy v));\n+        for each_permutation(~[7]) |v| { results.push(from_slice(v)); }\n         assert results == ~[~[7]];\n \n         results = ~[];\n-        permute(~[1,1], |v| results.push(copy v));\n+        for each_permutation(~[1,1]) |v| { results.push(from_slice(v)); }\n         assert results == ~[~[1,1],~[1,1]];\n \n         results = ~[];\n-        permute(~[5,2,0], |v| results.push(copy v));\n+        for each_permutation(~[5,2,0]) |v| { results.push(from_slice(v)); }\n         assert results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]];\n     }\n@@ -2487,19 +2559,19 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert position_elem(~[], 1).is_none();\n+        assert position_elem(~[], &1).is_none();\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        assert position_elem(v1, 1) == Some(0u);\n-        assert position_elem(v1, 2) == Some(1u);\n-        assert position_elem(v1, 5) == Some(5u);\n-        assert position_elem(v1, 4).is_none();\n+        assert position_elem(v1, &1) == Some(0u);\n+        assert position_elem(v1, &2) == Some(1u);\n+        assert position_elem(v1, &5) == Some(5u);\n+        assert position_elem(v1, &4).is_none();\n     }\n \n     #[test]\n     fn test_position() {\n-        fn less_than_three(&&i: int) -> bool { return i < 3; }\n-        fn is_eighteen(&&i: int) -> bool { return i == 18; }\n+        fn less_than_three(i: &int) -> bool { return *i < 3; }\n+        fn is_eighteen(i: &int) -> bool { return *i == 18; }\n \n         assert position(~[], less_than_three).is_none();\n \n@@ -2512,7 +2584,7 @@ mod tests {\n     fn test_position_between() {\n         assert position_between(~[], 0u, 0u, f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert position_between(v, 0u, 0u, f).is_none();\n@@ -2540,8 +2612,8 @@ mod tests {\n     fn test_find() {\n         assert find(~[], f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert find(v, f) == Some((1, 'b'));\n@@ -2552,7 +2624,7 @@ mod tests {\n     fn test_find_between() {\n         assert find_between(~[], 0u, 0u, f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert find_between(v, 0u, 0u, f).is_none();\n@@ -2580,8 +2652,8 @@ mod tests {\n     fn test_rposition() {\n         assert find(~[], f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert position(v, f) == Some(1u);\n@@ -2592,7 +2664,7 @@ mod tests {\n     fn test_rposition_between() {\n         assert rposition_between(~[], 0u, 0u, f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert rposition_between(v, 0u, 0u, f).is_none();\n@@ -2620,8 +2692,8 @@ mod tests {\n     fn test_rfind() {\n         assert rfind(~[], f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert rfind(v, f) == Some((3, 'b'));\n@@ -2632,7 +2704,7 @@ mod tests {\n     fn test_rfind_between() {\n         assert rfind_between(~[], 0u, 0u, f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert rfind_between(v, 0u, 0u, f).is_none();\n@@ -2692,7 +2764,7 @@ mod tests {\n \n     #[test]\n     fn test_split() {\n-        fn f(&&x: int) -> bool { x == 3 }\n+        fn f(x: &int) -> bool { *x == 3 }\n \n         assert split(~[], f) == ~[];\n         assert split(~[1, 2], f) == ~[~[1, 2]];\n@@ -2703,7 +2775,7 @@ mod tests {\n \n     #[test]\n     fn test_splitn() {\n-        fn f(&&x: int) -> bool { x == 3 }\n+        fn f(x: &int) -> bool { *x == 3 }\n \n         assert splitn(~[], 1u, f) == ~[];\n         assert splitn(~[1, 2], 1u, f) == ~[~[1, 2]];\n@@ -2715,7 +2787,7 @@ mod tests {\n \n     #[test]\n     fn test_rsplit() {\n-        fn f(&&x: int) -> bool { x == 3 }\n+        fn f(x: &int) -> bool { *x == 3 }\n \n         assert rsplit(~[], f) == ~[];\n         assert rsplit(~[1, 2], f) == ~[~[1, 2]];\n@@ -2725,7 +2797,7 @@ mod tests {\n \n     #[test]\n     fn test_rsplitn() {\n-        fn f(&&x: int) -> bool { x == 3 }\n+        fn f(x: &int) -> bool { *x == 3 }\n \n         assert rsplitn(~[], 1u, f) == ~[];\n         assert rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]];\n@@ -2748,9 +2820,9 @@ mod tests {\n \n     #[test]\n     fn test_connect() {\n-        assert connect(~[], 0) == ~[];\n-        assert connect(~[~[1], ~[2, 3]], 0) == ~[1, 0, 2, 3];\n-        assert connect(~[~[1], ~[2], ~[3]], 0) == ~[1, 0, 2, 0, 3];\n+        assert connect(~[], &0) == ~[];\n+        assert connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3];\n+        assert connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3];\n     }\n \n     #[test]\n@@ -2796,18 +2868,18 @@ mod tests {\n     #[test]\n     fn test_unshift() {\n         let mut x = ~[1, 2, 3];\n-        unshift(x, 0);\n+        x.unshift(0);\n         assert x == ~[0, 1, 2, 3];\n     }\n \n     #[test]\n     fn test_capacity() {\n         let mut v = ~[0u64];\n         reserve(&mut v, 10u);\n-        assert capacity(v) == 10u;\n+        assert capacity(&v) == 10u;\n         let mut v = ~[0u32];\n         reserve(&mut v, 10u);\n-        assert capacity(v) == 10u;\n+        assert capacity(&v) == 10u;\n     }\n \n     #[test]\n@@ -3012,7 +3084,7 @@ mod tests {\n     #[should_fail]\n     fn test_grow_fn_fail() {\n         let mut v = ~[];\n-        do grow_fn(v, 100) |i| {\n+        do v.grow_fn(100) |i| {\n             if i == 50 {\n                 fail\n             }\n@@ -3318,7 +3390,7 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do permute(v) |_elt| {\n+        for each_permutation(v) |_elt| {\n             if i == 2 {\n                 fail\n             }"}, {"sha": "59de3631118a76345abe8164dd3bc2f9f5e9acab", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -217,7 +217,7 @@ impl Writer {\n     }\n \n     fn end_tag() {\n-        let last_size_pos = vec::pop::<uint>(self.size_positions);\n+        let last_size_pos = self.size_positions.pop();\n         let cur_pos = self.writer.tell();\n         self.writer.seek(last_size_pos as int, io::SeekSet);\n         let size = (cur_pos - last_size_pos - 4u);"}, {"sha": "21a7d7817c9c2420b77bbec7d96bd25b1839ecec", "filename": "src/libstd/ebml2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -226,7 +226,7 @@ impl Serializer {\n     }\n \n     fn end_tag() {\n-        let last_size_pos = vec::pop::<uint>(self.size_positions);\n+        let last_size_pos = self.size_positions.pop();\n         let cur_pos = self.writer.tell();\n         self.writer.seek(last_size_pos as int, io::SeekSet);\n         let size = (cur_pos - last_size_pos - 4u);"}, {"sha": "a04eadb77329433081d104fbe8e667bffe1d70c0", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -428,9 +428,8 @@ fn opt_maybe_str(+mm: Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n     return match vals[0] {\n-      Val(copy s) =>\n-      Some::<~str>(s),\n-      _ => None::<~str>\n+        Val(copy s) => Some(s),\n+        _ => None\n     };\n }\n "}, {"sha": "247c13396d0ea067478816820d1c4a6aec5e4843", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -696,7 +696,7 @@ priv impl Deserializer {\n \n     fn pop(&self) -> &self/Json {\n         if self.stack.len() == 0 { self.stack.push(&self.json); }\n-        vec::pop(self.stack)\n+        self.stack.pop()\n     }\n }\n "}, {"sha": "2a7019f5a582d3dc16e693cd2536efbaae9fa69b", "filename": "src/libstd/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -13,7 +13,7 @@ enum List<T> {\n \n /// Cregate a list from a vector\n fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n-    vec::foldr(v, @Nil::<T>, |h, t| @Cons(h, t))\n+    vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n }\n \n /**"}, {"sha": "5b2ea0a84a617675f41154c80def16afc86eab13", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -163,7 +163,7 @@ mod v4 {\n         if vec::len(parts) != 4u {\n                 result::Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n                 }\n-        else if vec::contains(parts, 256u) {\n+        else if vec::contains(parts, &256u) {\n                 result::Err(fmt!(\"invalid octal in addr '%s'\", ip))\n                 }\n         else {"}, {"sha": "699fec961c48fd720b272efa8d2c22a756696944", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -800,7 +800,7 @@ impl TcpSocketBuf: io::Reader {\n         if self.read(bytes, 1u) == 0 { fail } else { bytes[0] as int }\n     }\n     fn unread_byte(amt: int) {\n-        vec::unshift((*(self.data)).buf, amt as u8);\n+        self.data.buf.unshift(amt as u8);\n     }\n     fn eof() -> bool {\n         false // noop"}, {"sha": "9cfcd8c2acbcee18e88d1223905aebe5d177b35e", "filename": "src/libstd/par.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -123,17 +123,17 @@ pub fn alli<A: Copy Send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n     do vec::all(map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n-                f(i + base, x)\n+                f(i + base, *x)\n             })\n         }\n-    })) |x| { x }\n+    })) |x| { *x }\n }\n \n /// Returns true if the function holds for any elements in the vector.\n pub fn any<A: Copy Send>(xs: ~[A], f: fn~(A) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n-            vec::any(slice, |x| f(x))\n+            vec::any(slice, |x| f(*x))\n         }\n-    })) |x| { x }\n+    })) |x| { *x }\n }"}, {"sha": "1100485e7f1105f0a75c475c74d83d32dd48874c", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -30,7 +30,7 @@ fn mk<T: Copy>() -> SmallIntMap<T> {\n #[inline(always)]\n fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, +val: T) {\n     //io::println(fmt!(\"%?\", key));\n-    self.v.grow_set_elt(key, None, Some(val));\n+    self.v.grow_set_elt(key, &None, Some(val));\n }\n \n /**"}, {"sha": "691f0e840e6b542d6896f30c90183781c747a421", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -358,7 +358,7 @@ fn filter_tests(opts: &TestOpts,\n             } else { return option::None; }\n         }\n \n-        vec::filter_map(filtered, |x| filter_fn(&x, filter_str))\n+        vec::filter_map(filtered, |x| filter_fn(x, filter_str))\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -374,7 +374,7 @@ fn filter_tests(opts: &TestOpts,\n             } else { return option::None; }\n         };\n \n-        vec::filter_map(filtered, |x| filter(&x))\n+        vec::filter_map(filtered, |x| filter(x))\n     };\n \n     // Sort the tests alphabetically"}, {"sha": "d05c6eadaf6a31fc23c26615b99ab43e9fcfdf15", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -278,7 +278,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n       _ => cx.path.push(path_name(i.ident))\n     }\n     visit::visit_item(i, cx, v);\n-    vec::pop(cx.path);\n+    cx.path.pop();\n }\n \n fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,"}, {"sha": "2431947184d25be05f108e36ec0d268faa7fd2bc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -275,14 +275,14 @@ fn ident_to_path(s: span, +i: ident) -> @path {\n       rp: None, types: ~[]}\n }\n \n-pure fn is_unguarded(&&a: arm) -> bool {\n+pure fn is_unguarded(a: &arm) -> bool {\n     match a.guard {\n       None => true,\n       _    => false\n     }\n }\n \n-pure fn unguarded_pat(a: arm) -> Option<~[@pat]> {\n+pure fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n     if is_unguarded(a) { Some(/* FIXME (#2543) */ copy a.pats) } else { None }\n }\n "}, {"sha": "d08edd7af1d07fd7ea174db5454d4d9b74284404", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -163,9 +163,9 @@ fn get_name_value_str_pair(item: @ast::meta_item) -> Option<(~str, ~str)> {\n fn find_attrs_by_name(attrs: ~[ast::attribute], name: ~str) ->\n    ~[ast::attribute] {\n     let filter = (\n-        fn@(a: ast::attribute) -> Option<ast::attribute> {\n-            if get_attr_name(a) == name {\n-                option::Some(a)\n+        fn@(a: &ast::attribute) -> Option<ast::attribute> {\n+            if get_attr_name(*a) == name {\n+                option::Some(*a)\n             } else { option::None }\n         }\n     );\n@@ -175,9 +175,9 @@ fn find_attrs_by_name(attrs: ~[ast::attribute], name: ~str) ->\n /// Searcha list of meta items and return only those with a specific name\n fn find_meta_items_by_name(metas: ~[@ast::meta_item], name: ~str) ->\n    ~[@ast::meta_item] {\n-    let filter = fn@(&&m: @ast::meta_item) -> Option<@ast::meta_item> {\n-        if get_meta_item_name(m) == name {\n-            option::Some(m)\n+    let filter = fn@(m: &@ast::meta_item) -> Option<@ast::meta_item> {\n+        if get_meta_item_name(*m) == name {\n+            option::Some(*m)\n         } else { option::None }\n     };\n     return vec::filter_map(metas, filter);\n@@ -289,8 +289,8 @@ fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n    ~[@ast::meta_item] {\n \n     return vec::filter_map(items, |item| {\n-        if get_meta_item_name(item) != name {\n-            option::Some(/* FIXME (#2543) */ copy item)\n+        if get_meta_item_name(*item) != name {\n+            option::Some(/* FIXME (#2543) */ copy *item)\n         } else {\n             option::None\n         }"}, {"sha": "fa14d3b5e994d5c364e66280c60f0834ae7232a6", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -90,8 +90,8 @@ fn expand(cx: ext_ctxt,\n           span: span,\n           _mitem: ast::meta_item,\n           in_items: ~[@ast::item]) -> ~[@ast::item] {\n-    fn not_auto_serialize(a: ast::attribute) -> bool {\n-        attr::get_attr_name(a) != ~\"auto_serialize\"\n+    fn not_auto_serialize(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) != ~\"auto_serialize\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n@@ -102,12 +102,12 @@ fn expand(cx: ext_ctxt,\n     do vec::flat_map(in_items) |in_item| {\n         match in_item.node {\n           ast::item_ty(ty, tps) => {\n-            vec::append(~[filter_attrs(in_item)],\n+            vec::append(~[filter_attrs(*in_item)],\n                         ty_fns(cx, in_item.ident, ty, tps))\n           }\n \n           ast::item_enum(enum_definition, tps) => {\n-            vec::append(~[filter_attrs(in_item)],\n+            vec::append(~[filter_attrs(*in_item)],\n                         enum_fns(cx, in_item.ident,\n                                  in_item.span, enum_definition.variants, tps))\n           }\n@@ -116,7 +116,7 @@ fn expand(cx: ext_ctxt,\n             cx.span_err(span, ~\"#[auto_serialize] can only be \\\n                                applied to type and enum \\\n                                definitions\");\n-            ~[in_item]\n+            ~[*in_item]\n           }\n         }\n     }"}, {"sha": "099ba67713fc6edb3c74e9c71faaa94e1f600193", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -75,8 +75,8 @@ fn expand(cx: ext_ctxt,\n           span: span,\n           _mitem: ast::meta_item,\n           in_items: ~[@ast::item]) -> ~[@ast::item] {\n-    fn not_auto_serialize2(a: ast::attribute) -> bool {\n-        attr::get_attr_name(a) != ~\"auto_serialize2\"\n+    fn not_auto_serialize2(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) != ~\"auto_serialize2\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n@@ -88,27 +88,27 @@ fn expand(cx: ext_ctxt,\n         match item.node {\n             ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n                 ~[\n-                    filter_attrs(item),\n+                    filter_attrs(*item),\n                     mk_rec_impl(cx, item.span, item.ident, fields, tps),\n                 ]\n             },\n             ast::item_class(@{ fields, _}, tps) => {\n                 ~[\n-                    filter_attrs(item),\n+                    filter_attrs(*item),\n                     mk_struct_impl(cx, item.span, item.ident, fields, tps),\n                 ]\n             },\n             ast::item_enum(enum_def, tps) => {\n                 ~[\n-                    filter_attrs(item),\n+                    filter_attrs(*item),\n                     mk_enum_impl(cx, item.span, item.ident, enum_def, tps),\n                 ]\n             },\n             _ => {\n                 cx.span_err(span, ~\"#[auto_serialize2] can only be applied \\\n                                     to structs, record types, and enum \\\n                                     definitions\");\n-                ~[item]\n+                ~[*item]\n             }\n         }\n     }"}, {"sha": "5f4d86b98606994272d77957f0a3375816342c36", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -161,7 +161,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn print_backtrace() { }\n         fn backtrace() -> expn_info { self.backtrace }\n         fn mod_push(i: ast::ident) { self.mod_path.push(i); }\n-        fn mod_pop() { vec::pop(self.mod_path); }\n+        fn mod_pop() { self.mod_path.pop(); }\n         fn mod_path() -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(ei: codemap::expn_info_) {\n             match ei {"}, {"sha": "22e2cfcde6b5113dba31df4fc23fe86c76e2cde6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -144,7 +144,7 @@ fn expand_mod_items(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n     // decorated with \"item decorators\", then use that function to transform\n     // the item into a new set of items.\n     let new_items = do vec::flat_map(module_.items) |item| {\n-        do vec::foldr(item.attrs, ~[item]) |attr, items| {\n+        do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n             let mname = match attr.node.value.node {\n               ast::meta_word(n) => n,\n               ast::meta_name_value(n, _) => n,\n@@ -160,7 +160,7 @@ fn expand_mod_items(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n         }\n     };\n \n-    return {items: new_items,.. module_};\n+    return {items: new_items, ..module_};\n }\n \n "}, {"sha": "b9b1484ce5a3ff7649e3f56f418081f50b677a11", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -47,7 +47,7 @@ impl message: gen_send {\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n \n             let args_ast = (arg_names, tys).map(\n-                |n, t| cx.arg_mode(n, t, ast::by_copy)\n+                |n, t| cx.arg_mode(*n, *t, ast::by_copy)\n             );\n \n             let pipe_ty = cx.ty_path_ast_builder(\n@@ -129,7 +129,7 @@ impl message: gen_send {\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n                 let args_ast = (arg_names, tys).map(\n-                    |n, t| cx.arg_mode(cx.ident_of(n), t, ast::by_copy)\n+                    |n, t| cx.arg_mode(cx.ident_of(*n), *t, ast::by_copy)\n                 );\n \n                 let args_ast = vec::append("}, {"sha": "e16e1c55349970cf007feca47fae7e72d887a96d", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -307,7 +307,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                 while idx < rc {\n                     idx_path.push(idx);\n                     res.push(recur(repeat_me)); // whew!\n-                    vec::pop(*idx_path);\n+                    idx_path.pop();\n                     idx += 1u;\n                 }\n               }"}, {"sha": "16e3454ca2c45fbf46cc83ae8fc667cc3bafbd4f", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -219,7 +219,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n \n         /* we append new items to this while we go */\n         while cur_eis.len() > 0u { /* for each Earley Item */\n-            let mut ei = vec::pop(cur_eis);\n+            let mut ei = cur_eis.pop();\n \n             let idx = ei.idx;\n             let len = ei.elts.len();\n@@ -350,13 +350,13 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n             } else if (next_eis.len() > 0u) {\n                 /* Now process the next token */\n                 while(next_eis.len() > 0u) {\n-                    cur_eis.push(vec::pop(next_eis));\n+                    cur_eis.push(next_eis.pop());\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n                 let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n \n-                let ei = vec::pop(bb_eis);\n+                let ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal("}, {"sha": "a8a41cca6cbd7dcbdf7e34e1ae46cbb05d14b52b", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -82,13 +82,13 @@ pure fn dup_tt_reader(&&r: tt_reader) -> tt_reader {\n \n pure fn lookup_cur_matched_by_matched(r: tt_reader,\n                                       start: @named_match) -> @named_match {\n-    pure fn red(&&ad: @named_match, &&idx: uint) -> @named_match {\n+    pure fn red(+ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n           matched_nonterminal(_) => {\n             // end of the line; duplicate henceforth\n             ad\n           }\n-          matched_seq(ads, _) => ads[idx]\n+          matched_seq(ads, _) => ads[*idx]\n         }\n     }\n     vec::foldl(start, r.repeat_idx, red)\n@@ -122,8 +122,8 @@ fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n     }\n     match t {\n       tt_delim(tts) | tt_seq(_, tts, _, _) => {\n-        vec::foldl(lis_unconstrained, tts, {|lis, tt|\n-            lis_merge(lis, lockstep_iter_size(tt, r), r) })\n+        vec::foldl(lis_unconstrained, tts, |lis, tt|\n+            lis_merge(lis, lockstep_iter_size(*tt, r), r))\n       }\n       tt_tok(*) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {\n@@ -148,7 +148,8 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n               }\n               tt_frame_up(Some(tt_f)) => {\n                 if r.cur.dotdotdoted {\n-                    vec::pop(r.repeat_idx); vec::pop(r.repeat_len);\n+                    r.repeat_idx.pop();\n+                    r.repeat_len.pop();\n                 }\n \n                 r.cur = tt_f;"}, {"sha": "088df01985ee981217dc7c740fdd62e1fa4d135c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -552,7 +552,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n     return {view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n-         items: vec::filter_map(m.items, |x| fld.fold_item(x))};\n+         items: vec::filter_map(m.items, |x| fld.fold_item(*x))};\n }\n \n fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {"}, {"sha": "240c9f34c81429cbf39440b044722dc2e099596d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -1111,7 +1111,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_call(func, args, has_block) => {\n         let mut base_args = args;\n         let blk = if has_block {\n-            let blk_arg = vec::pop(base_args);\n+            let blk_arg = base_args.pop();\n             match blk_arg.node {\n               ast::expr_loop_body(_) => { head(s, ~\"for\"); }\n               ast::expr_do_body(_) => { head(s, ~\"do\"); }"}, {"sha": "8b1202e632e59db97fc3cc45f1c837264bfe15f1", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -122,7 +122,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     logging::console_off();\n \n     let mut args = args;\n-    let binary = vec::shift(args);\n+    let binary = args.shift();\n \n     if vec::len(args) == 0u { usage(binary); return; }\n "}, {"sha": "4577b54fb5c7610fc3563f34187fddf9ab53c73f", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -50,13 +50,12 @@ fn filter_view_item(cx: ctxt, &&view_item: @ast::view_item\n \n fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n    ast::_mod {\n-    let item_filter = |a| filter_item(cx, a);\n-    let filtered_items = vec::filter_map(m.items, item_filter);\n-    let view_item_filter = |a| filter_view_item(cx, a);\n-    let filtered_view_items = vec::filter_map(m.view_items, view_item_filter);\n+    let filtered_items = vec::filter_map(m.items, |a| filter_item(cx, *a));\n+    let filtered_view_items = vec::filter_map(m.view_items,\n+                                              |a| filter_view_item(cx, *a));\n     return {\n         view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n-        items: vec::filter_map(filtered_items, |x| fld.fold_item(x))\n+        items: vec::filter_map(filtered_items, |x| fld.fold_item(*x))\n     };\n }\n \n@@ -69,11 +68,10 @@ fn filter_foreign_item(cx: ctxt, &&item: @ast::foreign_item) ->\n \n fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n                    fld: fold::ast_fold) -> ast::foreign_mod {\n-    let item_filter = |a| filter_foreign_item(cx, a);\n-    let filtered_items = vec::filter_map(nm.items, item_filter);\n-    let view_item_filter = |a| filter_view_item(cx, a);\n-    let filtered_view_items = vec::filter_map(\n-        nm.view_items, view_item_filter);\n+    let filtered_items = vec::filter_map(nm.items,\n+                                         |a| filter_foreign_item(cx, *a));\n+    let filtered_view_items = vec::filter_map(nm.view_items,\n+                                              |a| filter_view_item(cx, *a));\n     return {\n         sort: nm.sort,\n         view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n@@ -100,8 +98,7 @@ fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n \n fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n-    let filter = |a| filter_stmt(cx, a);\n-    let filtered_stmts = vec::filter_map(b.stmts, filter);\n+    let filtered_stmts = vec::filter_map(b.stmts, |a| filter_stmt(cx, *a));\n     return {view_items: b.view_items,\n          stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n          expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n@@ -136,7 +133,7 @@ fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[@ast::meta_item]) -> bool {\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n     let cfg_metas = vec::concat(vec::filter_map(cfg_metas,\n-        |&&i| attr::get_meta_item_list(i) ));\n+        |i| attr::get_meta_item_list(*i)));\n \n     let has_cfg_metas = vec::len(cfg_metas) > 0u;\n     if !has_cfg_metas { return true; }"}, {"sha": "952d7b9ab7937cba3657501c917f6f22a1dba2ee", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -81,8 +81,8 @@ fn fold_mod(cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     }\n \n     let mod_nomain =\n-        {view_items: m.view_items, items: vec::filter_map(m.items,\n-                                                          |i| nomain(cx, i))};\n+        {view_items: m.view_items,\n+         items: vec::filter_map(m.items, |i| nomain(cx, *i))};\n     return fold::noop_fold_mod(mod_nomain, fld);\n }\n \n@@ -122,7 +122,7 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n     }\n \n     let res = fold::noop_fold_item(i, fld);\n-    vec::pop(cx.path);\n+    cx.path.pop();\n     return res;\n }\n \n@@ -152,7 +152,7 @@ fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, ~\"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n-        |&&i| attr::get_meta_item_list(i) ));\n+        |i| attr::get_meta_item_list(*i)));\n     return if vec::is_not_empty(ignoreitems) {\n         config::metas_in_cfg(cx.crate.node.config, cfg_metas)\n     } else {"}, {"sha": "483f7ea06a99a71f0a2549b19f2fcfc52b6c61c1", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -114,7 +114,7 @@ fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n }\n \n fn add_used_crate_file(cstore: cstore, lib: &Path) {\n-    if !vec::contains(p(cstore).used_crate_files, copy *lib) {\n+    if !vec::contains(p(cstore).used_crate_files, lib) {\n         p(cstore).used_crate_files.push(copy *lib);\n     }\n }\n@@ -126,7 +126,7 @@ fn get_used_crate_files(cstore: cstore) -> ~[Path] {\n fn add_used_library(cstore: cstore, lib: ~str) -> bool {\n     assert lib != ~\"\";\n \n-    if vec::contains(p(cstore).used_libraries, lib) { return false; }\n+    if vec::contains(p(cstore).used_libraries, &lib) { return false; }\n     p(cstore).used_libraries.push(lib);\n     return true;\n }"}, {"sha": "0e6bc2aee15a8b3e6d6309f2dd2595917874a107", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -980,7 +980,7 @@ fn get_crate_module_paths(intr: @ident_interner, cdata: cmd)\n         res.push((did, path));\n     }\n     return do vec::filter(res) |x| {\n-        let (_, xp) = x;\n+        let (_, xp) = *x;\n         mods.contains_key(xp)\n     }\n }"}, {"sha": "b2469718140f89e0768d31c35c3f9a93d54ecf12", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -527,7 +527,7 @@ impl check_loan_ctxt {\n         do vec::iter2(args, arg_tys) |arg, arg_ty| {\n             match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n                 ast::by_move => {\n-                    self.check_move_out(arg);\n+                    self.check_move_out(*arg);\n                 }\n                 ast::by_mutbl_ref | ast::by_ref |\n                 ast::by_copy | ast::by_val => {"}, {"sha": "85eae29529f61b6702ad64f8bc8a3c925c5b22c4", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -116,11 +116,11 @@ fn req_loans_in_expr(ex: @ast::expr,\n         do vec::iter2(args, arg_tys) |arg, arg_ty| {\n             match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n               ast::by_mutbl_ref => {\n-                let arg_cmt = self.bccx.cat_expr(arg);\n+                let arg_cmt = self.bccx.cat_expr(*arg);\n                 self.guarantee_valid(arg_cmt, m_mutbl, scope_r);\n               }\n               ast::by_ref => {\n-                let arg_cmt = self.bccx.cat_expr(arg);\n+                let arg_cmt = self.bccx.cat_expr(*arg);\n                 self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n               }\n               ast::by_val => {"}, {"sha": "efbeb490db9fabd6b0fd346fc2f2193cc6959101", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -195,7 +195,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n             }\n           }\n           Some(ctor) => {\n-            match is_useful(tcx, vec::filter_map(m, |r| default(tcx, r) ),\n+            match is_useful(tcx, vec::filter_map(m, |r| default(tcx, *r) ),\n                           vec::tail(v)) {\n               useful_ => useful(left_ty, ctor),\n               u => u\n@@ -212,7 +212,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n \n fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: ~[@pat], ctor: ctor,\n                           arity: uint, lty: ty::t) -> useful {\n-    let ms = vec::filter_map(m, |r| specialize(tcx, r, ctor, arity, lty) );\n+    let ms = vec::filter_map(m, |r| specialize(tcx, *r, ctor, arity, lty) );\n     let could_be_useful = is_useful(\n         tcx, ms, specialize(tcx, v, ctor, arity, lty).get());\n     match could_be_useful {\n@@ -269,7 +269,9 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n         let mut found = ~[];\n         for m.each |r| {\n             do option::iter(&pat_ctor_id(tcx, r[0])) |id| {\n-                if !vec::contains(found, *id) { found.push(*id); }\n+                if !vec::contains(found, id) {\n+                    found.push(*id);\n+                }\n             }\n         }\n         let variants = ty::enum_variants(tcx, eid);"}, {"sha": "5def18cacc31d60d08434613250bafb725691253", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -41,7 +41,7 @@ enum constness {\n }\n \n fn join(a: constness, b: constness) -> constness {\n-    match (a,b) {\n+    match (a, b) {\n       (integral_const, integral_const) => integral_const,\n       (integral_const, general_const)\n       | (general_const, integral_const)\n@@ -51,7 +51,7 @@ fn join(a: constness, b: constness) -> constness {\n }\n \n fn join_all(cs: &[constness]) -> constness {\n-    vec::foldl(integral_const, cs, join)\n+    vec::foldl(integral_const, cs, |a, b| join(a, *b))\n }\n \n fn classify(e: @expr,"}, {"sha": "b1323d7fc9327d1dc047ef514e22f4988f38bbd7", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -273,7 +273,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                       *bounds, (*bounds).len());\n         }\n         do vec::iter2(*ts, *bounds) |ty, bound| {\n-            check_bounds(cx, id_to_use, e.span, ty, bound)\n+            check_bounds(cx, id_to_use, e.span, *ty, *bound)\n         }\n     }\n \n@@ -377,7 +377,7 @@ fn check_ty(aty: @ty, cx: ctx, v: visit::vt<ctx>) {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(id));\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n             do vec::iter2(*ts, *bounds) |ty, bound| {\n-                check_bounds(cx, aty.id, aty.span, ty, bound)\n+                check_bounds(cx, aty.id, aty.span, *ty, *bound)\n             }\n         }\n       }"}, {"sha": "689f69f1ad0252dc29605289da5060d7a096238e", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -955,7 +955,7 @@ impl Liveness {\n     fn propagate_through_block(blk: blk, succ: LiveNode) -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n         do blk.node.stmts.foldr(succ) |stmt, succ| {\n-            self.propagate_through_stmt(stmt, succ)\n+            self.propagate_through_stmt(*stmt, succ)\n         }\n     }\n \n@@ -975,7 +975,7 @@ impl Liveness {\n         match decl.node {\n           decl_local(locals) => {\n             do locals.foldr(succ) |local, succ| {\n-                self.propagate_through_local(local, succ)\n+                self.propagate_through_local(*local, succ)\n             }\n           }\n           decl_item(_) => {\n@@ -1007,7 +1007,7 @@ impl Liveness {\n     fn propagate_through_exprs(exprs: ~[@expr],\n                                succ: LiveNode) -> LiveNode {\n         do exprs.foldr(succ) |expr, succ| {\n-            self.propagate_through_expr(expr, succ)\n+            self.propagate_through_expr(*expr, succ)\n         }\n     }\n \n@@ -1575,7 +1575,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n             match ty::resolved_mode(self.tcx, arg_ty.mode) {\n                 by_val | by_copy | by_ref | by_mutbl_ref => {}\n                 by_move => {\n-                    self.check_move_from_expr(arg_expr, vt);\n+                    self.check_move_from_expr(*arg_expr, vt);\n                 }\n             }\n         }"}, {"sha": "fc66b5dc7a1715e93815883ab7391ceec07f710a", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -1560,7 +1560,7 @@ impl Resolver {\n                     path_entry.def_like);\n \n             let mut pieces = split_str(path_entry.path_string, ~\"::\");\n-            let final_ident_str = pop(pieces);\n+            let final_ident_str = pieces.pop();\n             let final_ident = self.session.ident_of(final_ident_str);\n \n             // Find the module we need, creating modules along the way if we"}, {"sha": "6450e48486cf5b3f024aea7da95db16c56d63c49", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -581,7 +581,7 @@ fn collect_record_or_struct_fields(m: &[@Match], col: uint) -> ~[ast::ident] {\n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pats.each |field_pat| {\n             let field_ident = field_pat.ident;\n-            if !vec::any(*idents, |x| x == field_ident) {\n+            if !vec::any(*idents, |x| *x == field_ident) {\n                 idents.push(field_ident);\n             }\n         }"}, {"sha": "70231357003b61a101ba3777208e522dae1a795b", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -57,7 +57,7 @@ struct icx_popper {\n     ccx: @crate_ctxt,\n     drop {\n       if self.ccx.sess.count_llvm_insns() {\n-          vec::pop(*(self.ccx.stats.llvm_insn_ctxt));\n+          self.ccx.stats.llvm_insn_ctxt.pop();\n       }\n     }\n }"}, {"sha": "907146be4fdf94eb8d44569b1b84fd39e372ac0c", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -402,7 +402,7 @@ fn revoke_clean(cx: block, val: ValueRef) {\n     do in_scope_cx(cx) |info| {\n         let cleanup_pos = vec::position(\n             info.cleanups,\n-            |cu| match cu {\n+            |cu| match *cu {\n                 clean_temp(v, _, _) if v == val => true,\n                 _ => false\n             });"}, {"sha": "68ebf5fa18960cbe4cee2caa70960b1f1f40d68c", "filename": "src/rustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -158,7 +158,7 @@ fn trans_log(log_ex: @ast::expr,\n     let modpath = vec::append(\n         ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))],\n         vec::filter(bcx.fcx.path, |e|\n-            match e { path_mod(_) => true, _ => false }\n+            match *e { path_mod(_) => true, _ => false }\n         ));\n     let modname = path_str(ccx.sess, modpath);\n "}, {"sha": "74dadd2cab49820d704c97de11c8c4a7a6cd9c30", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -92,7 +92,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             Double => 8,\n             Struct => {\n               do vec::foldl(0, struct_tys(ty)) |a, t| {\n-                  uint::max(a, ty_align(t))\n+                  uint::max(a, ty_align(*t))\n               }\n             }\n             Array => {\n@@ -113,7 +113,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             Double => 8,\n             Struct => {\n               do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                    s + ty_size(t)\n+                    s + ty_size(*t)\n                 }\n             }\n             Array => {"}, {"sha": "cd8cffa297a6409f122ef9c25bb26f1a5514c1e4", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -33,7 +33,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, Some(param_uses));\n     if vec::any(hash_id.params,\n-                |p| match p { mono_precise(_, _) => false, _ => true }) {\n+                |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n     }\n \n@@ -243,7 +243,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n         let mut i = 0u;\n         vec::map2(*bounds, substs, |bounds, subst| {\n             let mut v = ~[];\n-            for vec::each(*bounds) |bound| {\n+            for bounds.each |bound| {\n                 match *bound {\n                   ty::bound_trait(_) => {\n                     v.push(meth::vtable_id(ccx, vts[i]));\n@@ -252,7 +252,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                   _ => ()\n                 }\n             }\n-            (subst, if v.len() > 0u { Some(v) } else { None })\n+            (*subst, if v.len() > 0u { Some(v) } else { None })\n         })\n       }\n       None => {\n@@ -262,12 +262,12 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n     let param_ids = match param_uses {\n       Some(uses) => {\n         vec::map2(precise_param_ids, uses, |id, uses| {\n-            match id {\n+            match *id {\n                 (a, b@Some(_)) => mono_precise(a, b),\n                 (subst, None) => {\n-                    if uses == 0u {\n+                    if *uses == 0u {\n                         mono_any\n-                    } else if uses == type_use::use_repr &&\n+                    } else if *uses == type_use::use_repr &&\n                         !ty::type_needs_drop(ccx.tcx, subst)\n                     {\n                         let llty = type_of::type_of(ccx, subst);"}, {"sha": "f0d67b92339e085bcc70868566aaa057b7dac68a", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -206,7 +206,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(e.id));\n             vec::iter2(type_uses_for(cx.ccx, id, ts.len()), *ts,\n                        |uses, subst| {\n-                           type_needs(cx, uses, subst)\n+                           type_needs(cx, *uses, *subst)\n                        })\n         }\n       }\n@@ -239,7 +239,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n               typeck::method_static(did) => {\n                 do cx.ccx.tcx.node_type_substs.find(e.id).iter |ts| {\n                     do vec::iter2(type_uses_for(cx.ccx, did, ts.len()), *ts)\n-                        |uses, subst| { type_needs(cx, uses, subst)}\n+                        |uses, subst| { type_needs(cx, *uses, *subst)}\n                 }\n               }\n               typeck::method_param({param_num: param, _}) => {"}, {"sha": "397a1cd6aa1d21719676842bc4e62302737fb73f", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -2238,23 +2238,23 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false\n           }\n \n-          ty_class(did, _) if vec::contains(*seen, did) => {\n+          ty_class(ref did, _) if vec::contains(*seen, did) => {\n             false\n           }\n \n           ty_class(did, ref substs) => {\n               seen.push(did);\n               let r = vec::any(class_items_as_fields(cx, did, substs),\n                                |f| type_requires(cx, seen, r_ty, f.mt.ty));\n-              vec::pop(*seen);\n+              seen.pop();\n             r\n           }\n \n           ty_tup(ts) => {\n-            vec::any(ts, |t| type_requires(cx, seen, r_ty, t))\n+            vec::any(ts, |t| type_requires(cx, seen, r_ty, *t))\n           }\n \n-          ty_enum(did, _) if vec::contains(*seen, did) => {\n+          ty_enum(ref did, _) if vec::contains(*seen, did) => {\n             false\n           }\n \n@@ -2263,11 +2263,11 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 let vs = enum_variants(cx, did);\n                 let r = vec::len(*vs) > 0u && vec::all(*vs, |variant| {\n                     vec::any(variant.args, |aty| {\n-                        let sty = subst(cx, substs, aty);\n+                        let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)\n                     })\n                 });\n-                vec::pop(*seen);\n+                seen.pop();\n                 r\n             }\n         };\n@@ -3063,7 +3063,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n     if !type_needs_infer(rt) { return; }\n \n     // Occurs check!\n-    if vec::contains(vars_in_type(rt), vid) {\n+    if vec::contains(vars_in_type(rt), &vid) {\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die."}, {"sha": "a1cfb91ebdc34d65715f9ccdd1b660d34be8fa4d", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -309,7 +309,7 @@ fn check_fn(ccx: @crate_ctxt,\n         fcx.write_ty(info.self_id, info.self_ty);\n     }\n     do vec::iter2(decl.inputs, arg_tys) |input, arg| {\n-        fcx.write_ty(input.id, arg);\n+        fcx.write_ty(input.id, *arg);\n     }\n \n     // If we don't have any enclosing function scope, it is time to\n@@ -352,7 +352,7 @@ fn check_fn(ccx: @crate_ctxt,\n \n         // Add formal parameters.\n         do vec::iter2(arg_tys, decl.inputs) |arg_ty, input| {\n-            assign(input.ty.span, input.id, Some(arg_ty));\n+            assign(input.ty.span, input.id, Some(*arg_ty));\n             debug!(\"Argument %s is assigned to %s\",\n                    tcx.sess.str_of(input.ident),\n                    fcx.inh.locals.get(input.id).to_str());\n@@ -807,7 +807,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n                     _ => ()\n                 }\n             }\n-            ty::ty_enum(did, _) => {\n+            ty::ty_enum(ref did, _) => {\n                 // Watch out for a type like `enum t = @t`.  Such a\n                 // type would otherwise infinitely auto-deref.  Only\n                 // autoderef loops during typeck (basically, this one\n@@ -818,7 +818,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n                 if vec::contains(enum_dids, did) {\n                     return (t1, autoderefs);\n                 }\n-                enum_dids.push(did);\n+                enum_dids.push(*did);\n             }\n             _ => { /*ok*/ }\n         }\n@@ -2294,7 +2294,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n               }\n               _ => ()\n             }\n-            if vec::contains(*disr_vals, *disr_val) {\n+            if vec::contains(*disr_vals, &*disr_val) {\n                 ccx.tcx.sess.span_err(v.span,\n                                       ~\"discriminator value already exists\");\n             }"}, {"sha": "ace045ec4a702003a48cba74a49ae033eb430d8c", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -165,7 +165,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n \n             do subpats.iter() |pats| {\n                 do vec::iter2(*pats, arg_types) |subpat, arg_ty| {\n-                  check_pat(pcx, subpat, arg_ty);\n+                  check_pat(pcx, *subpat, *arg_ty);\n                 }\n             };\n         } else if subpats_len > 0u {"}, {"sha": "06f466f74d56db94c1917cb1310952a6c6660d42", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -23,7 +23,7 @@ use util::common::indenter;\n \n fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n-        vec::any(*bs, |b| {\n+        bs.any(|b| {\n             match b { ty::bound_trait(_) => true, _ => false }\n         })\n     })\n@@ -393,7 +393,7 @@ fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n     match ty::get(trait_ty).sty {\n      ty::ty_trait(_, substs, _) => {\n         vec::iter2(substs.tps, trait_tys,\n-                   |a, b| demand::suptype(fcx, expr.span, a, b));\n+                   |a, b| demand::suptype(fcx, expr.span, *a, *b));\n       }\n      _ => tcx.sess.impossible_case(expr.span, \"connect_trait_tps: \\\n             don't know how to handle a non-trait ty\")"}, {"sha": "18e29981af30d054cec4afd9da6b32a5b65ea88c", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -725,7 +725,7 @@ fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n fn compute_bounds(ccx: @crate_ctxt,\n                   ast_bounds: @~[ast::ty_param_bound]) -> ty::param_bounds {\n     @do vec::flat_map(*ast_bounds) |b| {\n-        match b {\n+        match *b {\n           ast::bound_send => ~[ty::bound_send],\n           ast::bound_copy => ~[ty::bound_copy],\n           ast::bound_const => ~[ty::bound_const],"}, {"sha": "e5aa0debfe17d2869df9d52c369e6ab29353f094", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -507,7 +507,7 @@ fn rollback_to<V:Copy vid, T:Copy>(\n     vb: &vals_and_bindings<V, T>, len: uint) {\n \n     while vb.bindings.len() != len {\n-        let (vid, old_v) = vec::pop(vb.bindings);\n+        let (vid, old_v) = vb.bindings.pop();\n         vb.vals.insert(vid.to_uint(), old_v);\n     }\n }"}, {"sha": "c86850e19d258046d0cb0b795e7c3ad6da39e0ff", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -1192,7 +1192,7 @@ impl RegionVarBindings {\n         set.insert(*orig_node_idx, ());\n         let mut result = ~[];\n         while !vec::is_empty(stack) {\n-            let node_idx = vec::pop(stack);\n+            let node_idx = stack.pop();\n             for self.each_edge(graph, node_idx, dir) |edge| {\n                 match edge.constraint {\n                   ConstrainVarSubVar(from_vid, to_vid) => {"}, {"sha": "2a851a5f7bb26994927e895b10d995e11340a09b", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -170,7 +170,7 @@ impl resolve_state {\n     }\n \n     fn resolve_ty_var(vid: TyVid) -> ty::t {\n-        if vec::contains(self.v_seen, vid) {\n+        if vec::contains(self.v_seen, &vid) {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n         } else {\n@@ -197,7 +197,7 @@ impl resolve_state {\n                 ty::mk_var(tcx, vid)\n               }\n             };\n-            vec::pop(self.v_seen);\n+            self.v_seen.pop();\n             return t1;\n         }\n     }"}, {"sha": "71a32dc112f8a6e9cbdb0369ca369d6c12512db2", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -236,7 +236,7 @@ fn merge_method_attrs(\n \n         {\n             desc: desc,\n-            .. doc\n+            ..*doc\n         }\n     }\n }"}, {"sha": "d601d6d92d1e3b16f024e441fce2f1d40271cb95", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -228,8 +228,8 @@ fn maybe_find_pandoc(\n     };\n \n     let pandoc = do vec::find(possible_pandocs) |pandoc| {\n-        let output = program_output(pandoc, ~[~\"--version\"]);\n-        debug!(\"testing pandoc cmd %s: %?\", pandoc, output);\n+        let output = program_output(*pandoc, ~[~\"--version\"]);\n+        debug!(\"testing pandoc cmd %s: %?\", *pandoc, output);\n         output.status == 0\n     };\n "}, {"sha": "3fcce7db6c4bc2741af47a2d5674fdd7ebe10ccb", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -165,7 +165,7 @@ fn paragraphs(s: ~str) -> ~[~str] {\n     let paras = do vec::foldl(~[], lines) |paras, line| {\n         let mut res = paras;\n \n-        if str::is_whitespace(line) {\n+        if str::is_whitespace(*line) {\n             whitespace_lines += 1;\n         } else {\n             if whitespace_lines > 0 {\n@@ -178,9 +178,9 @@ fn paragraphs(s: ~str) -> ~[~str] {\n             whitespace_lines = 0;\n \n             accum = if str::is_empty(accum) {\n-                line\n+                *line\n             } else {\n-                accum + ~\"\\n\" + line\n+                accum + ~\"\\n\" + *line\n             }\n         }\n "}, {"sha": "0764d9e2432687cb7cd3d5de53d905d961d4fce6", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -378,7 +378,7 @@ impl IndexEntry : cmp::Eq {\n impl Doc {\n     fn CrateDoc() -> CrateDoc {\n         option::get(&vec::foldl(None, self.pages, |_m, page| {\n-            match page {\n+            match *page {\n               doc::CratePage(doc) => Some(doc),\n               _ => None\n             }\n@@ -395,7 +395,7 @@ impl ModDoc {\n \n     fn mods() -> ~[ModDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n               ModTag(ModDoc) => Some(ModDoc),\n               _ => None\n             }\n@@ -404,7 +404,7 @@ impl ModDoc {\n \n     fn nmods() -> ~[NmodDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n               NmodTag(nModDoc) => Some(nModDoc),\n               _ => None\n             }\n@@ -413,7 +413,7 @@ impl ModDoc {\n \n     fn fns() -> ~[FnDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n               FnTag(FnDoc) => Some(FnDoc),\n               _ => None\n             }\n@@ -422,7 +422,7 @@ impl ModDoc {\n \n     fn consts() -> ~[ConstDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n               ConstTag(ConstDoc) => Some(ConstDoc),\n               _ => None\n             }\n@@ -431,7 +431,7 @@ impl ModDoc {\n \n     fn enums() -> ~[EnumDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n               EnumTag(EnumDoc) => Some(EnumDoc),\n               _ => None\n             }\n@@ -440,7 +440,7 @@ impl ModDoc {\n \n     fn traits() -> ~[TraitDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n               TraitTag(TraitDoc) => Some(TraitDoc),\n               _ => None\n             }\n@@ -449,7 +449,7 @@ impl ModDoc {\n \n     fn impls() -> ~[ImplDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n               ImplTag(ImplDoc) => Some(ImplDoc),\n               _ => None\n             }\n@@ -458,7 +458,7 @@ impl ModDoc {\n \n     fn types() -> ~[TyDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n               TyTag(TyDoc) => Some(TyDoc),\n               _ => None\n             }\n@@ -467,7 +467,7 @@ impl ModDoc {\n \n     fn structs() -> ~[StructDoc] {\n         do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n+            match *itemtag {\n                 StructTag(StructDoc) => Some(StructDoc),\n                 _ => None\n             }\n@@ -490,7 +490,7 @@ impl ~[Page]: PageUtils {\n \n     fn mods() -> ~[ModDoc] {\n         do vec::filter_map(self) |page| {\n-            match page {\n+            match *page {\n               ItemPage(ModTag(ModDoc)) => Some(ModDoc),\n               _ => None\n             }\n@@ -499,7 +499,7 @@ impl ~[Page]: PageUtils {\n \n     fn nmods() -> ~[NmodDoc] {\n         do vec::filter_map(self) |page| {\n-            match page {\n+            match *page {\n               ItemPage(NmodTag(nModDoc)) => Some(nModDoc),\n               _ => None\n             }\n@@ -508,7 +508,7 @@ impl ~[Page]: PageUtils {\n \n     fn fns() -> ~[FnDoc] {\n         do vec::filter_map(self) |page| {\n-            match page {\n+            match *page {\n               ItemPage(FnTag(FnDoc)) => Some(FnDoc),\n               _ => None\n             }\n@@ -517,7 +517,7 @@ impl ~[Page]: PageUtils {\n \n     fn consts() -> ~[ConstDoc] {\n         do vec::filter_map(self) |page| {\n-            match page {\n+            match *page {\n               ItemPage(ConstTag(ConstDoc)) => Some(ConstDoc),\n               _ => None\n             }\n@@ -526,7 +526,7 @@ impl ~[Page]: PageUtils {\n \n     fn enums() -> ~[EnumDoc] {\n         do vec::filter_map(self) |page| {\n-            match page {\n+            match *page {\n               ItemPage(EnumTag(EnumDoc)) => Some(EnumDoc),\n               _ => None\n             }\n@@ -535,7 +535,7 @@ impl ~[Page]: PageUtils {\n \n     fn traits() -> ~[TraitDoc] {\n         do vec::filter_map(self) |page| {\n-            match page {\n+            match *page {\n               ItemPage(TraitTag(TraitDoc)) => Some(TraitDoc),\n               _ => None\n             }\n@@ -544,7 +544,7 @@ impl ~[Page]: PageUtils {\n \n     fn impls() -> ~[ImplDoc] {\n         do vec::filter_map(self) |page| {\n-            match page {\n+            match *page {\n               ItemPage(ImplTag(ImplDoc)) => Some(ImplDoc),\n               _ => None\n             }\n@@ -553,7 +553,7 @@ impl ~[Page]: PageUtils {\n \n     fn types() -> ~[TyDoc] {\n         do vec::filter_map(self) |page| {\n-            match page {\n+            match *page {\n               ItemPage(TyTag(TyDoc)) => Some(TyDoc),\n               _ => None\n             }"}, {"sha": "ad3f679a97cb5886ec39fd5eda89f27ccf5ca94c", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -105,7 +105,7 @@ fn fold_mod(\n fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n     doc::ModDoc_({\n         items: do vec::filter(doc.items) |item| {\n-            match item {\n+            match *item {\n               doc::ModTag(_) => false,\n               doc::NmodTag(_) => false,\n               _ => true"}, {"sha": "f6a241fdac8488924b9042f90199b6fe16be1957", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -45,7 +45,7 @@ fn fold_mod(fold: fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n \n     if !is_topmod { fold.ctxt.path.push(doc.name()); }\n     let doc = fold::default_any_fold_mod(fold, doc);\n-    if !is_topmod { vec::pop(fold.ctxt.path); }\n+    if !is_topmod { fold.ctxt.path.pop(); }\n \n     doc::ModDoc_({\n         item: fold.fold_item(fold, doc.item),\n@@ -56,7 +56,7 @@ fn fold_mod(fold: fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n fn fold_nmod(fold: fold::Fold<Ctxt>, doc: doc::NmodDoc) -> doc::NmodDoc {\n     fold.ctxt.path.push(doc.name());\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n-    vec::pop(fold.ctxt.path);\n+    fold.ctxt.path.pop();\n \n     {\n         item: fold.fold_item(fold, doc.item),"}, {"sha": "5e2d141318a753014e102c96d3a9470a1fbe4e59", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -177,7 +177,7 @@ fn get_method_sig(\n             node: ast::item_trait(_, _, methods), _\n           }, _) => {\n             match vec::find(methods, |method| {\n-                match method {\n+                match *method {\n                   ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n                   ast::provided(m) => to_str(m.ident) == method_name,\n                 }"}, {"sha": "aa31892d46640b885830782b9a8064b7215b8d2b", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -29,7 +29,7 @@ fn unindent(s: ~str) -> ~str {\n         let ignore_previous_indents =\n             saw_first_line &&\n             !saw_second_line &&\n-            !str::is_whitespace(line);\n+            !str::is_whitespace(*line);\n \n         let min_indent = if ignore_previous_indents {\n             uint::max_value\n@@ -41,12 +41,12 @@ fn unindent(s: ~str) -> ~str {\n             saw_second_line = true;\n         }\n \n-        if str::is_whitespace(line) {\n+        if str::is_whitespace(*line) {\n             min_indent\n         } else {\n             saw_first_line = true;\n             let mut spaces = 0;\n-            do str::all(line) |char| {\n+            do str::all(*line) |char| {\n                 // Only comparing against space because I wouldn't\n                 // know what to do with mixed whitespace chars\n                 if char == ' ' {"}, {"sha": "cf44d478356282b54d966224dfc451dbd7c9117e", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -47,7 +47,7 @@ fn shift_push() {\n     let mut v2 = ~[];\n \n     while v1.len() > 0 {\n-        v2.push(vec::shift(v1));\n+        v2.push(v1.shift());\n     }\n }\n "}, {"sha": "10b38f2572cd32e98c2c103c636c92ab524bd21f", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -97,7 +97,7 @@ fn gen_search_keys(graph: graph, n: uint) -> ~[node_id] {\n         let k = r.gen_uint_range(0u, graph.len());\n \n         if graph[k].len() > 0u && vec::any(graph[k], |i| {\n-            i != k as node_id\n+            *i != k as node_id\n         }) {\n             map::set_add(keys, k as node_id);\n         }\n@@ -160,8 +160,8 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         }\n     };\n \n-    fn is_gray(c: color) -> bool {\n-        match c {\n+    fn is_gray(c: &color) -> bool {\n+        match *c {\n           gray(_) => { true }\n           _ => { false }\n         }\n@@ -183,7 +183,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n                 let mut color = white;\n \n                 do neighbors.each() |k| {\n-                    if is_gray(colors[*k]) {\n+                    if is_gray(&colors[*k]) {\n                         color = gray(*k);\n                         false\n                     }\n@@ -314,7 +314,7 @@ fn validate(edges: ~[(node_id, node_id)],\n         }\n         else {\n             while parent != root {\n-                if vec::contains(path, parent) {\n+                if vec::contains(path, &parent) {\n                     status = false;\n                 }\n \n@@ -336,8 +336,8 @@ fn validate(edges: ~[(node_id, node_id)],\n     log(info, ~\"Verifying tree edges...\");\n \n     let status = do tree.alli() |k, parent| {\n-        if parent != root && parent != -1i64 {\n-            level[parent] == level[k] - 1\n+        if *parent != root && *parent != -1i64 {\n+            level[*parent] == level[k] - 1\n         }\n         else {\n             true"}, {"sha": "ec144b78a10ae8e117862ab4305c24a683b7be98", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -27,7 +27,7 @@ fn recv(p: &pipe) -> uint {\n         while vec::is_empty(*state) {\n             cond.wait();\n         }\n-        vec::pop(*state)\n+        state.pop()\n     }\n }\n "}, {"sha": "1b857b6caeb80abaf50b1212a96668711182df54", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -27,7 +27,7 @@ fn recv(p: &pipe) -> uint {\n         while vec::is_empty(*state) {\n             cond.wait();\n         }\n-        vec::pop(*state)\n+        state.pop()\n     }\n }\n "}, {"sha": "15154ab5a4ecc5badc4993e9a266fa15aec05d92", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -2,7 +2,7 @@\n fn compute1() -> float {\n     let v = ~[0f, 1f, 2f, 3f];\n \n-    do vec::foldl(0f, v) |x, y| { x + y } - 10f\n+    do vec::foldl(0f, v) |x, y| { x + *y } - 10f\n     //~^ ERROR mismatched types: expected `()`\n }\n "}, {"sha": "276862ce106708630c1a7893a4d81823e25ce8a4", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -7,7 +7,7 @@ fn broken() -> int {\n         y += ~[&mut z]; //~ ERROR illegal borrow\n         x += 1;\n     }\n-    vec::foldl(0, y, |v, p| v + *p )\n+    vec::foldl(0, y, |v, p| v + **p )\n }\n \n fn main() { }\n\\ No newline at end of file"}, {"sha": "bab28a06934d6a32bf2cbbf7482d393c952a3a98", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Trailing expressions don't require parentheses:\n-    let y = do vec::foldl(0f, v) |x, y| { x + y } + 10f;\n+    let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n \n     assert y == 15f;\n }"}, {"sha": "1121cc4dd2f3331f595415574c504890b8d2dd4d", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -1,20 +1,20 @@\n fn w_semi(v: ~[int]) -> int {\n     // the semicolon causes compiler not to\n     // complain about the ignored return value:\n-    do vec::foldl(0, v) |x,y| { x+y };\n+    do vec::foldl(0, v) |x,y| { x+*y };\n     -10\n }\n \n fn w_paren1(v: ~[int]) -> int {\n-    (do vec::foldl(0, v) |x,y| { x+y }) - 10\n+    (do vec::foldl(0, v) |x,y| { x+*y }) - 10\n }\n \n fn w_paren2(v: ~[int]) -> int {\n-    (do vec::foldl(0, v) |x,y| { x+y} - 10)\n+    (do vec::foldl(0, v) |x,y| { x+*y} - 10)\n }\n \n fn w_ret(v: ~[int]) -> int {\n-    return do vec::foldl(0, v) |x,y| { x+y } - 10;\n+    return do vec::foldl(0, v) |x,y| { x+*y } - 10;\n }\n \n fn main() {"}, {"sha": "0f77a0e0816fd89795d1a221f433081117dffec6", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -8,28 +8,28 @@ fn main() {\n     }\n \n     // Usable at all:\n-    let mut any_negative = do vec::any(v) |e| { float::is_negative(e) };\n+    let mut any_negative = do vec::any(v) |e| { float::is_negative(*e) };\n     assert any_negative;\n \n     // Higher precedence than assignments:\n-    any_negative = do vec::any(v) |e| { float::is_negative(e) };\n+    any_negative = do vec::any(v) |e| { float::is_negative(*e) };\n     assert any_negative;\n \n     // Higher precedence than unary operations:\n     let abs_v = do vec::map(v) |e| { float::abs(*e) };\n-    assert do vec::all(abs_v) |e| { float::is_nonnegative(e) };\n-    assert !do vec::any(abs_v) |e| { float::is_negative(e) };\n+    assert do vec::all(abs_v) |e| { float::is_nonnegative(*e) };\n+    assert !do vec::any(abs_v) |e| { float::is_negative(*e) };\n \n     // Usable in funny statement-like forms:\n-    if !do vec::any(v) |e| { float::is_positive(e) } {\n+    if !do vec::any(v) |e| { float::is_positive(*e) } {\n         assert false;\n     }\n-    match do vec::all(v) |e| { float::is_negative(e) } {\n+    match do vec::all(v) |e| { float::is_negative(*e) } {\n         true => { fail ~\"incorrect answer.\"; }\n         false => { }\n     }\n     match 3 {\n-      _ if do vec::any(v) |e| { float::is_negative(e) } => {\n+      _ if do vec::any(v) |e| { float::is_negative(*e) } => {\n       }\n       _ => {\n         fail ~\"wrong answer.\";\n@@ -38,15 +38,15 @@ fn main() {\n \n \n     // Lower precedence than binary operations:\n-    let w = do vec::foldl(0f, v) |x, y| { x + y } + 10f;\n-    let y = do vec::foldl(0f, v) |x, y| { x + y } + 10f;\n-    let z = 10f + do vec::foldl(0f, v) |x, y| { x + y };\n+    let w = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n+    let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n+    let z = 10f + do vec::foldl(0f, v) |x, y| { x + *y };\n     assert w == y;\n     assert y == z;\n \n     // In the tail of a block\n     let w =\n-        if true { do vec::any(abs_v) |e| { float::is_nonnegative(e) } }\n+        if true { do vec::any(abs_v) |e| { float::is_nonnegative(*e) } }\n       else { false };\n     assert w;\n }"}, {"sha": "d270800de11e01e11bb5662b1a689361874d88d4", "filename": "src/test/run-pass/block-vec-map2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let v =\n         vec::map2(~[1, 2, 3, 4, 5],\n                   ~[true, false, false, true, true],\n-                  |i, b| if b { -i } else { i } );\n+                  |i, b| if *b { -(*i) } else { *i } );\n     log(error, v);\n     assert (v == ~[-1, 2, 3, -4, -5]);\n }"}, {"sha": "4e7e978cf5567b933a949d701ae4b149a2f83861", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21519bc7e0a32e388e8b12be5d36d4440129f417/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=21519bc7e0a32e388e8b12be5d36d4440129f417", "patch": "@@ -43,10 +43,10 @@ fn ret_deep() -> ~str {\n fn main() {\n     let mut last = 0;\n     for vec::all(~[1, 2, 3, 4, 5, 6, 7]) |e| {\n-        last = e;\n-        if e == 5 { break; }\n-        if e % 2 == 1 { loop; }\n-        assert e % 2 == 0;\n+        last = *e;\n+        if *e == 5 { break; }\n+        if *e % 2 == 1 { loop; }\n+        assert *e % 2 == 0;\n     };\n     assert last == 5;\n "}]}