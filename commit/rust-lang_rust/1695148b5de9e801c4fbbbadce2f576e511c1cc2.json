{"sha": "1695148b5de9e801c4fbbbadce2f576e511c1cc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OTUxNDhiNWRlOWU4MDFjNGZiYmJhZGNlMmY1NzZlNTExYzFjYzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-20T21:54:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-20T21:54:40Z"}, "message": "rustdoc: Refactor reexport_pass", "tree": {"sha": "249f37b1c95d631fb5e0f2991794230eb38658f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/249f37b1c95d631fb5e0f2991794230eb38658f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1695148b5de9e801c4fbbbadce2f576e511c1cc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1695148b5de9e801c4fbbbadce2f576e511c1cc2", "html_url": "https://github.com/rust-lang/rust/commit/1695148b5de9e801c4fbbbadce2f576e511c1cc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1695148b5de9e801c4fbbbadce2f576e511c1cc2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "651aeea96139d5f973410bc3405593c759c3f938", "url": "https://api.github.com/repos/rust-lang/rust/commits/651aeea96139d5f973410bc3405593c759c3f938", "html_url": "https://github.com/rust-lang/rust/commit/651aeea96139d5f973410bc3405593c759c3f938"}], "stats": {"total": 116, "additions": 50, "deletions": 66}, "files": [{"sha": "f711e7d76280d9f249705725b3600c73a37ac5e0", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 50, "deletions": 66, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/1695148b5de9e801c4fbbbadce2f576e511c1cc2/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1695148b5de9e801c4fbbbadce2f576e511c1cc2/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=1695148b5de9e801c4fbbbadce2f576e511c1cc2", "patch": "@@ -9,6 +9,7 @@ import rustc::util::common;\n import rustc::middle::ast_map;\n import rustc::syntax::visit;\n import rustc::syntax::codemap;\n+import rustc::middle::resolve;\n \n export mk_pass;\n \n@@ -98,50 +99,10 @@ fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n \n fn find_reexport_impls(ctxt: astsrv::ctxt) -> [ast::def_id] {\n     let defs = @mut [];\n-    let visitor = @{\n-        visit_mod: bind visit_mod(ctxt, defs, _, _, _)\n-        with *visit::default_simple_visitor()\n-    };\n-    let visitor = visit::mk_simple_visitor(visitor);\n-    visit::visit_crate(*ctxt.ast, (), visitor);\n-    ret *defs;\n-\n-    fn visit_mod(\n-        ctxt: astsrv::ctxt,\n-        defs: @mut [ast::def_id],\n-        m: ast::_mod,\n-        _sp: codemap::span,\n-        mod_id: ast::node_id\n-    ) {\n-        let all_impls = all_impls(m);\n-        alt check ctxt.impl_map.get(mod_id) {\n-          list::cons(impls, @list::nil) {\n-            for i in *impls {\n-                // This impl is not an item in the current mod\n-                if !all_impls.contains_key(i.did) {\n-                    // Ignore external impls because I don't\n-                    // know what to do with them yet\n-                    if i.did.crate == ast::local_crate {\n-                        *defs += [i.did]\n-                    }\n-                }\n-            }\n-          }\n-        }\n+    for_each_reexported_impl(ctxt) {|_mod_id, i|\n+        *defs += [i.did]\n     }\n-}\n-\n-fn all_impls(m: ast::_mod) -> map::set<ast::def_id> {\n-    let all_impls = common::new_def_hash();\n-    for item in m.items {\n-        alt item.node {\n-          ast::item_impl(_, _, _, _) {\n-            all_impls.insert(ast_util::local_def(item.id), ());\n-          }\n-          _ { }\n-        }\n-    }\n-    ret all_impls;\n+    ret *defs;\n }\n \n fn build_reexport_def_map(\n@@ -264,18 +225,46 @@ fn find_reexport_impl_docs(\n     def_map: def_map\n ) -> [(str, (str, doc::itemtag))] {\n     let docs = @mut [];\n+\n+    for_each_reexported_impl(ctxt) {|mod_id, i|\n+        let path = alt ctxt.ast_map.find(mod_id) {\n+          some(ast_map::node_item(item, path)) {\n+            let path = ast_map::path_to_str(*path);\n+            if str::is_empty(path) {\n+                item.ident\n+            } else {\n+                path + \"::\" + item.ident\n+            }\n+          }\n+          _ {\n+            assert mod_id == ast::crate_node_id;\n+            \"\"\n+          }\n+        };\n+        let ident = i.ident;\n+        let doc = alt check def_map.find(i.did) {\n+          some(doc) { doc }\n+        };\n+        *docs += [(path, (ident, doc))];\n+    }\n+\n+    ret *docs;\n+}\n+\n+fn for_each_reexported_impl(\n+    ctxt: astsrv::ctxt,\n+    f: fn@(ast::node_id, resolve::_impl)\n+) {\n     let visitor = @{\n-        visit_mod: bind visit_mod(ctxt, def_map, docs, _, _, _)\n+        visit_mod: bind visit_mod(ctxt, f, _, _, _)\n         with *visit::default_simple_visitor()\n     };\n     let visitor = visit::mk_simple_visitor(visitor);\n     visit::visit_crate(*ctxt.ast, (), visitor);\n-    ret *docs;\n \n     fn visit_mod(\n         ctxt: astsrv::ctxt,\n-        def_map: def_map,\n-        docs: @mut [(str, (str, doc::itemtag))],\n+        f: fn@(ast::node_id, resolve::_impl),\n         m: ast::_mod,\n         _sp: codemap::span,\n         mod_id: ast::node_id\n@@ -289,25 +278,7 @@ fn find_reexport_impl_docs(\n                     // Ignore external impls because I don't\n                     // know what to do with them yet\n                     if i.did.crate == ast::local_crate {\n-                        let path = alt ctxt.ast_map.find(mod_id) {\n-                          some(ast_map::node_item(item, path)) {\n-                            let path = ast_map::path_to_str(*path);\n-                            if str::is_empty(path) {\n-                                item.ident\n-                            } else {\n-                                path + \"::\" + item.ident\n-                            }\n-                          }\n-                          _ {\n-                            assert mod_id == ast::crate_node_id;\n-                            \"\"\n-                          }\n-                        };\n-                        let ident = i.ident;\n-                        let doc = alt check def_map.find(i.did) {\n-                          some(doc) { doc }\n-                        };\n-                        *docs += [(path, (ident, doc))];\n+                        f(mod_id, *i);\n                     }\n                 }\n             }\n@@ -316,6 +287,19 @@ fn find_reexport_impl_docs(\n     }\n }\n \n+fn all_impls(m: ast::_mod) -> map::set<ast::def_id> {\n+    let all_impls = common::new_def_hash();\n+    for item in m.items {\n+        alt item.node {\n+          ast::item_impl(_, _, _, _) {\n+            all_impls.insert(ast_util::local_def(item.id), ());\n+          }\n+          _ { }\n+        }\n+    }\n+    ret all_impls;\n+}\n+\n fn merge_reexports(\n     doc: doc::doc,\n     path_map: path_map"}]}