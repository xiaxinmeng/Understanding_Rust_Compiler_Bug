{"sha": "2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMjE2MGIwMjZkN2EyYjJkMTNjM2EyYjRkNmFhMDczYWIzZmY0M2Y=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-11T18:14:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T06:22:15Z"}, "message": "core: Update all tests for fmt movement", "tree": {"sha": "e4bebf36fa24fe0fe4dd6846291c59520ef1be28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4bebf36fa24fe0fe4dd6846291c59520ef1be28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "html_url": "https://github.com/rust-lang/rust/commit/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d12a136b2247ab5cf5b32e44a890b3a871c0ce90", "url": "https://api.github.com/repos/rust-lang/rust/commits/d12a136b2247ab5cf5b32e44a890b3a871c0ce90", "html_url": "https://github.com/rust-lang/rust/commit/d12a136b2247ab5cf5b32e44a890b3a871c0ce90"}], "stats": {"total": 440, "additions": 278, "deletions": 162}, "files": [{"sha": "695c0420e2b109ad0e2e0c1cbd6110da7ac3e59f", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -41,15 +41,15 @@ impl FromStr for Mode {\n impl fmt::Show for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let msg = match *self {\n-          CompileFail => \"compile-fail\",\n-          RunFail => \"run-fail\",\n-          RunPass => \"run-pass\",\n-          Pretty => \"pretty\",\n-          DebugInfoGdb => \"debuginfo-gdb\",\n-          DebugInfoLldb => \"debuginfo-lldb\",\n-          Codegen => \"codegen\",\n+            CompileFail => \"compile-fail\",\n+            RunFail => \"run-fail\",\n+            RunPass => \"run-pass\",\n+            Pretty => \"pretty\",\n+            DebugInfoGdb => \"debuginfo-gdb\",\n+            DebugInfoLldb => \"debuginfo-lldb\",\n+            Codegen => \"codegen\",\n         };\n-        write!(f.buf, \"{}\", msg)\n+        msg.fmt(f)\n     }\n }\n "}, {"sha": "61c1193e515973f939e9daf8ede42269079de50b", "filename": "src/libcore/any.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -166,12 +166,12 @@ mod tests {\n \n         match a.as_ref::<uint>() {\n             Some(&5) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match a.as_ref::<Test>() {\n             None => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n     }\n \n@@ -189,35 +189,35 @@ mod tests {\n                 assert_eq!(*x, 5u);\n                 *x = 612;\n             }\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match b_r.as_mut::<uint>() {\n             Some(x) => {\n                 assert_eq!(*x, 7u);\n                 *x = 413;\n             }\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match a_r.as_mut::<Test>() {\n             None => (),\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match b_r.as_mut::<Test>() {\n             None => (),\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match a_r.as_mut::<uint>() {\n             Some(&612) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match b_r.as_mut::<uint>() {\n             Some(&413) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n     }\n \n@@ -229,11 +229,11 @@ mod tests {\n         let b = box Test as Box<Any>;\n \n         match a.move::<uint>() {\n-            Ok(a) => { assert_eq!(a, box 8u); }\n+            Ok(a) => { assert!(a == box 8u); }\n             Err(..) => fail!()\n         }\n         match b.move::<Test>() {\n-            Ok(a) => { assert_eq!(a, box Test); }\n+            Ok(a) => { assert!(a == box Test); }\n             Err(..) => fail!()\n         }\n \n@@ -246,13 +246,14 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let a = box 8u as Box<::realcore::any::Any>;\n-        let b = box Test as Box<::realcore::any::Any>;\n-        assert_eq!(format!(\"{}\", a), \"Box<Any>\".to_owned());\n-        assert_eq!(format!(\"{}\", b), \"Box<Any>\".to_owned());\n-\n-        let a = &8u as &::realcore::any::Any;\n-        let b = &Test as &::realcore::any::Any;\n+        use realstd::to_str::ToStr;\n+        let a = box 8u as Box<::realstd::any::Any>;\n+        let b = box Test as Box<::realstd::any::Any>;\n+        assert_eq!(a.to_str(), \"Box<Any>\".to_owned());\n+        assert_eq!(b.to_str(), \"Box<Any>\".to_owned());\n+\n+        let a = &8u as &Any;\n+        let b = &Test as &Any;\n         assert_eq!(format!(\"{}\", a), \"&Any\".to_owned());\n         assert_eq!(format!(\"{}\", b), \"&Any\".to_owned());\n     }"}, {"sha": "d42ad49485f6dae9927a33e8df4c68afc394fe68", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -255,7 +255,7 @@ mod test {\n     fn cell_has_sensible_show() {\n         use str::StrSlice;\n \n-        let x = ::realcore::cell::Cell::new(\"foo bar\");\n+        let x = Cell::new(\"foo bar\");\n         assert!(format!(\"{}\", x).contains(x.get()));\n \n         x.set(\"baz qux\");"}, {"sha": "6e9d4c9bafbf616be4ae623ac8c9fad8ea641f87", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -633,9 +633,9 @@ impl Default for char {\n mod test {\n     use super::{escape_unicode, escape_default};\n \n-    use realcore::char::Char;\n+    use char::Char;\n     use slice::ImmutableVector;\n-    use realstd::option::{Some, None};\n+    use option::{Some, None};\n     use realstd::strbuf::StrBuf;\n     use realstd::str::StrAllocating;\n "}, {"sha": "c7befe2f4b1e0a64d23bd7c162577b79f067ef7e", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -131,7 +131,7 @@ mod test {\n     fn test_owned_clone() {\n         let a = box 5i;\n         let b: Box<int> = realclone(&a);\n-        assert_eq!(a, b);\n+        assert!(a == b);\n     }\n \n     #[test]"}, {"sha": "e5fb148aded341b64fa5db72d5faa8ecfa1dd69e", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -352,8 +352,16 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n \n             let mut filler = Filler { buf: buf, end: &mut end };\n             match sign {\n-                SignNeg => { let _ = write!(&mut filler, \"{:-}\", exp); }\n-                SignNone | SignAll => { let _ = write!(&mut filler, \"{}\", exp); }\n+                SignNeg => {\n+                    let _ = format_args!(|args| {\n+                        fmt::write(&mut filler, args)\n+                    }, \"{:-}\", exp);\n+                }\n+                SignNone | SignAll => {\n+                    let _ = format_args!(|args| {\n+                        fmt::write(&mut filler, args)\n+                    }, \"{}\", exp);\n+                }\n             }\n         }\n     }"}, {"sha": "979928c10ad2ff04ec16b500e95126cefd9a7778", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -13,16 +13,15 @@\n #![allow(unused_variable)]\n \n use any;\n-use cast;\n use cell::Cell;\n use char::Char;\n use container::Container;\n use iter::{Iterator, range};\n use kinds::Copy;\n+use mem;\n use option::{Option, Some, None};\n-use owned::Box;\n-use result;\n use result::{Ok, Err};\n+use result;\n use slice::{Vector, ImmutableVector};\n use slice;\n use str::StrSlice;\n@@ -34,8 +33,7 @@ pub use self::num::RadixFmt;\n \n macro_rules! write(\n     ($dst:expr, $($arg:tt)*) => ({\n-        let dst: &mut ::fmt::FormatWriter = $dst;\n-        format_args!(|args| { ::std::fmt::write(dst, args) }, $($arg)*)\n+        format_args!(|args| { $dst.write_fmt(args) }, $($arg)*)\n     })\n )\n \n@@ -104,7 +102,7 @@ impl<'a> Arguments<'a> {\n     #[doc(hidden)] #[inline]\n     pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n                           args: &'a [Argument<'a>]) -> Arguments<'a> {\n-        Arguments{ fmt: cast::transmute(fmt), args: args }\n+        Arguments{ fmt: mem::transmute(fmt), args: args }\n     }\n }\n \n@@ -329,7 +327,7 @@ impl<'a> Formatter<'a> {\n             rt::Plural(offset, ref selectors, ref default) => {\n                 // This is validated at compile-time to be a pointer to a\n                 // '&uint' value.\n-                let value: &uint = unsafe { cast::transmute(arg.value) };\n+                let value: &uint = unsafe { mem::transmute(arg.value) };\n                 let value = *value;\n \n                 // First, attempt to match against explicit values without the\n@@ -372,7 +370,7 @@ impl<'a> Formatter<'a> {\n             rt::Select(ref selectors, ref default) => {\n                 // This is validated at compile-time to be a pointer to a\n                 // string slice,\n-                let value: & &str = unsafe { cast::transmute(arg.value) };\n+                let value: & &str = unsafe { mem::transmute(arg.value) };\n                 let value = *value;\n \n                 for s in selectors.iter() {\n@@ -565,10 +563,33 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     unsafe {\n         Argument {\n-            formatter: cast::transmute(f),\n-            value: cast::transmute(t)\n+            formatter: mem::transmute(f),\n+            value: mem::transmute(t)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+pub fn format(args: &Arguments) -> ~str {\n+    use str;\n+    use realstd::str::StrAllocating;\n+    use realstd::io::MemWriter;\n+\n+    fn mywrite<T: ::realstd::io::Writer>(t: &mut T, b: &[u8]) {\n+        use realstd::io::Writer;\n+        let _ = t.write(b);\n+    }\n+\n+    impl FormatWriter for MemWriter {\n+        fn write(&mut self, bytes: &[u8]) -> Result {\n+            mywrite(self, bytes);\n+            Ok(())\n         }\n     }\n+\n+    let mut i = MemWriter::new();\n+    let _ = write(&mut i, args);\n+    str::from_utf8(i.get_ref()).unwrap().to_owned()\n }\n \n /// When the compiler determines that the type of an argument *must* be a string\n@@ -590,12 +611,12 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n impl<T: Show> Show for @T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n }\n-impl<T: Show> Show for Box<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n-}\n impl<'a, T: Show> Show for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n }\n+impl<'a, T: Show> Show for &'a mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n+}\n \n impl Bool for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n@@ -613,7 +634,7 @@ impl Char for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8, ..4];\n         let amt = self.encode_utf8(utf8);\n-        let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n+        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n         secret_string(&s, f)\n     }\n }\n@@ -738,20 +759,20 @@ macro_rules! tuple (\n         impl<$($name:Show),*> Show for ($($name,)*) {\n             #[allow(uppercase_variables, dead_assignment)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n-                try!(write!(f.buf, \"(\"));\n+                try!(write!(f, \"(\"));\n                 let ($(ref $name,)*) = *self;\n                 let mut n = 0;\n                 $(\n                     if n > 0 {\n-                        try!(write!(f.buf, \", \"));\n+                        try!(write!(f, \", \"));\n                     }\n-                    try!(write!(f.buf, \"{}\", *$name));\n+                    try!(write!(f, \"{}\", *$name));\n                     n += 1;\n                 )*\n                 if n == 1 {\n-                    try!(write!(f.buf, \",\"));\n+                    try!(write!(f, \",\"));\n                 }\n-                write!(f.buf, \")\")\n+                write!(f, \")\")\n             }\n         }\n         peel!($($name,)*)\n@@ -760,30 +781,26 @@ macro_rules! tuple (\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl Show for Box<any::Any> {\n-    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"Box<Any>\") }\n-}\n-\n impl<'a> Show for &'a any::Any {\n     fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n }\n \n impl<'a, T: Show> Show for &'a [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"[\"));\n+            try!(write!(f, \"[\"));\n         }\n         let mut is_first = true;\n         for x in self.iter() {\n             if is_first {\n                 is_first = false;\n             } else {\n-                try!(write!(f.buf, \", \"));\n+                try!(write!(f, \", \"));\n             }\n-            try!(write!(f.buf, \"{}\", *x))\n+            try!(write!(f, \"{}\", *x))\n         }\n         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"]\"));\n+            try!(write!(f, \"]\"));\n         }\n         Ok(())\n     }\n@@ -809,7 +826,7 @@ impl Show for () {\n \n impl<T: Copy + Show> Show for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.get())\n+        write!(f, r\"Cell \\{ value: {} \\}\", self.get())\n     }\n }\n "}, {"sha": "d9a327137812586759525a274962cb33347fde04", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -172,7 +172,7 @@ macro_rules! integer {\n         int_base!(Octal    for $Int as $Uint  -> Octal)\n         int_base!(LowerHex for $Int as $Uint  -> LowerHex)\n         int_base!(UpperHex for $Int as $Uint  -> UpperHex)\n-        radix_fmt!($Int as $Uint, fmt_int)\n+        radix_fmt!($Int as $Int, fmt_int)\n \n         int_base!(Show     for $Uint as $Uint -> Decimal)\n         int_base!(Unsigned for $Uint as $Uint -> Decimal)\n@@ -194,7 +194,7 @@ mod tests {\n     use fmt::radix;\n     use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n     use super::{GenericRadix, Radix};\n-    use str::StrAllocating;\n+    use realstd::str::StrAllocating;\n \n     #[test]\n     fn test_radix_base() {"}, {"sha": "d40701860f46eb09ed85117e205ef3fe0fec0623", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 76, "deletions": 34, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -2329,19 +2329,48 @@ pub mod order {\n \n #[cfg(test)]\n mod tests {\n-    use realstd::prelude::*;\n-    use realstd::iter::*;\n-    use realstd::num;\n+    use prelude::*;\n+    use iter::*;\n+    use num;\n+    use realstd::vec::Vec;\n+    use realstd::slice::Vector;\n \n     use cmp;\n     use realstd::owned::Box;\n     use uint;\n \n+    impl<T> FromIterator<T> for Vec<T> {\n+        fn from_iter<I: Iterator<T>>(mut iterator: I) -> Vec<T> {\n+            let mut v = Vec::new();\n+            for e in iterator {\n+                v.push(e);\n+            }\n+            return v;\n+        }\n+    }\n+\n+    impl<'a, T> Iterator<&'a T> for ::realcore::slice::Items<'a, T> {\n+        fn next(&mut self) -> Option<&'a T> {\n+            use RealSome = realcore::option::Some;\n+            use RealNone = realcore::option::None;\n+            fn mynext<T, I: ::realcore::iter::Iterator<T>>(i: &mut I)\n+                -> ::realcore::option::Option<T>\n+            {\n+                use realcore::iter::Iterator;\n+                i.next()\n+            }\n+            match mynext(self) {\n+                RealSome(t) => Some(t),\n+                RealNone => None,\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_counter_from_iter() {\n         let it = count(0, 5).take(10);\n         let xs: Vec<int> = FromIterator::from_iter(it);\n-        assert_eq!(xs, vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+        assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n \n     #[test]\n@@ -2371,7 +2400,7 @@ mod tests {\n     fn test_filter_map() {\n         let mut it = count(0u, 1u).take(10)\n             .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-        assert_eq!(it.collect::<Vec<uint>>(), vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n+        assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n \n     #[test]\n@@ -2630,7 +2659,7 @@ mod tests {\n     fn test_collect() {\n         let a = vec![1, 2, 3, 4, 5];\n         let b: Vec<int> = a.iter().map(|&x| x).collect();\n-        assert_eq!(a, b);\n+        assert!(a == b);\n     }\n \n     #[test]\n@@ -2702,7 +2731,8 @@ mod tests {\n         let mut it = xs.iter();\n         it.next();\n         it.next();\n-        assert_eq!(it.rev().map(|&x| x).collect::<Vec<int>>(), vec![16, 14, 12, 10, 8, 6]);\n+        assert!(it.rev().map(|&x| x).collect::<Vec<int>>() ==\n+                vec![16, 14, 12, 10, 8, 6]);\n     }\n \n     #[test]\n@@ -2940,12 +2970,12 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_range() {\n-        assert_eq!(range(11i, 14).rev().collect::<Vec<int>>(), vec![13i, 12, 11]);\n+        assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n         for _ in range(10i, 0).rev() {\n             fail!(\"unreachable\");\n         }\n \n-        assert_eq!(range(11u, 14).rev().collect::<Vec<uint>>(), vec![13u, 12, 11]);\n+        assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n         for _ in range(10u, 0).rev() {\n             fail!(\"unreachable\");\n         }\n@@ -2997,14 +3027,14 @@ mod tests {\n             }\n         }\n \n-        assert_eq!(range(0i, 5).collect::<Vec<int>>(), vec![0i, 1, 2, 3, 4]);\n-        assert_eq!(range(-10i, -1).collect::<Vec<int>>(),\n+        assert!(range(0i, 5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n+        assert!(range(-10i, -1).collect::<Vec<int>>() ==\n                    vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-        assert_eq!(range(0i, 5).rev().collect::<Vec<int>>(), vec![4, 3, 2, 1, 0]);\n-        assert_eq!(range(200, -5).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range(200, -5).rev().collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range(200, 200).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range(200, 200).rev().collect::<Vec<int>>(), vec![]);\n+        assert!(range(0i, 5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n+        assert_eq!(range(200, -5).len(), 0);\n+        assert_eq!(range(200, -5).rev().len(), 0);\n+        assert_eq!(range(200, 200).len(), 0);\n+        assert_eq!(range(200, 200).rev().len(), 0);\n \n         assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n         // this test is only meaningful when sizeof uint < sizeof u64\n@@ -3015,32 +3045,44 @@ mod tests {\n \n     #[test]\n     fn test_range_inclusive() {\n-        assert_eq!(range_inclusive(0i, 5).collect::<Vec<int>>(), vec![0i, 1, 2, 3, 4, 5]);\n-        assert_eq!(range_inclusive(0i, 5).rev().collect::<Vec<int>>(), vec![5i, 4, 3, 2, 1, 0]);\n-        assert_eq!(range_inclusive(200, -5).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range_inclusive(200, -5).rev().collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range_inclusive(200, 200).collect::<Vec<int>>(), vec![200]);\n-        assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<int>>(), vec![200]);\n+        assert!(range_inclusive(0i, 5).collect::<Vec<int>>() ==\n+                vec![0i, 1, 2, 3, 4, 5]);\n+        assert!(range_inclusive(0i, 5).rev().collect::<Vec<int>>() ==\n+                vec![5i, 4, 3, 2, 1, 0]);\n+        assert_eq!(range_inclusive(200, -5).len(), 0);\n+        assert_eq!(range_inclusive(200, -5).rev().len(), 0);\n+        assert!(range_inclusive(200, 200).collect::<Vec<int>>() == vec![200]);\n+        assert!(range_inclusive(200, 200).rev().collect::<Vec<int>>() == vec![200]);\n     }\n \n     #[test]\n     fn test_range_step() {\n-        assert_eq!(range_step(0i, 20, 5).collect::<Vec<int>>(), vec![0, 5, 10, 15]);\n-        assert_eq!(range_step(20i, 0, -5).collect::<Vec<int>>(), vec![20, 15, 10, 5]);\n-        assert_eq!(range_step(20i, 0, -6).collect::<Vec<int>>(), vec![20, 14, 8, 2]);\n-        assert_eq!(range_step(200u8, 255, 50).collect::<Vec<u8>>(), vec![200u8, 250]);\n-        assert_eq!(range_step(200, -5, 1).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range_step(200, 200, 1).collect::<Vec<int>>(), vec![]);\n+        assert!(range_step(0i, 20, 5).collect::<Vec<int>>() ==\n+                vec![0, 5, 10, 15]);\n+        assert!(range_step(20i, 0, -5).collect::<Vec<int>>() ==\n+                vec![20, 15, 10, 5]);\n+        assert!(range_step(20i, 0, -6).collect::<Vec<int>>() ==\n+                vec![20, 14, 8, 2]);\n+        assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n+                vec![200u8, 250]);\n+        assert!(range_step(200, -5, 1).collect::<Vec<int>>() == vec![]);\n+        assert!(range_step(200, 200, 1).collect::<Vec<int>>() == vec![]);\n     }\n \n     #[test]\n     fn test_range_step_inclusive() {\n-        assert_eq!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>(), vec![0, 5, 10, 15, 20]);\n-        assert_eq!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>(), vec![20, 15, 10, 5, 0]);\n-        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>(), vec![20, 14, 8, 2]);\n-        assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>(), vec![200u8, 250]);\n-        assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>(), vec![200]);\n+        assert!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>() ==\n+                vec![0, 5, 10, 15, 20]);\n+        assert!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>() ==\n+                vec![20, 15, 10, 5, 0]);\n+        assert!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>() ==\n+                vec![20, 14, 8, 2]);\n+        assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n+                vec![200u8, 250]);\n+        assert!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>() ==\n+                vec![]);\n+        assert!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>() ==\n+                vec![200]);\n     }\n \n     #[test]"}, {"sha": "05b314b6998478a998fad6e2fc6b947cb5474ec0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -11,7 +11,7 @@\n //! The Rust core library\n //!\n //! This library is meant to represent the core functionality of rust that is\n-//! maximally portable to other platforms. To that exent, this library has no\n+//! maximally portable to other platforms. To that extent, this library has no\n //! knowledge of things like allocation, threads, I/O, etc. This library is\n //! built on the assumption of a few existing symbols:\n //!\n@@ -48,15 +48,14 @@\n #[cfg(test)] extern crate realcore = \"core\";\n #[cfg(test)] extern crate libc;\n #[cfg(test)] extern crate native;\n-#[phase(syntax, link)] #[cfg(test)] extern crate realstd = \"std\";\n-#[phase(syntax, link)] #[cfg(test)] extern crate log;\n+#[cfg(test)] extern crate rand;\n+#[cfg(test)] extern crate realstd = \"std\";\n \n #[cfg(test)] pub use cmp = realcore::cmp;\n #[cfg(test)] pub use kinds = realcore::kinds;\n #[cfg(test)] pub use ops = realcore::ops;\n #[cfg(test)] pub use ty = realcore::ty;\n \n-#[cfg(not(test))]\n mod macros;\n \n #[path = \"num/float_macros.rs\"] mod float_macros;\n@@ -131,13 +130,13 @@ mod core {\n mod std {\n     pub use clone;\n     pub use cmp;\n-    pub use fmt;\n     pub use kinds;\n     pub use option;\n+    pub use fmt;\n \n-    #[cfg(test)] pub use realstd::fmt;    // needed for fail!()\n     #[cfg(test)] pub use realstd::rt;     // needed for fail!()\n-    #[cfg(test)] pub use realstd::option; // needed for assert!()\n+    // #[cfg(test)] pub use realstd::option; // needed for fail!()\n+    // #[cfg(test)] pub use realstd::fmt;    // needed for fail!()\n     #[cfg(test)] pub use realstd::os;     // needed for tests\n     #[cfg(test)] pub use realstd::slice;  // needed for tests\n     #[cfg(test)] pub use realstd::vec;    // needed for vec![]"}, {"sha": "6474c5e37a44b46cb6930a35fef275ee3f085526", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -54,6 +54,17 @@ macro_rules! assert(\n     );\n )\n \n+/// Runtime assertion for equality, for details see std::macros\n+macro_rules! assert_eq(\n+    ($cond1:expr, $cond2:expr) => ({\n+        let c1 = $cond1;\n+        let c2 = $cond2;\n+        if c1 != c2 || c2 != c1 {\n+            fail!(\"expressions not equal, left: {}, right: {}\", c1, c2);\n+        }\n+    })\n+)\n+\n /// Runtime assertion, disableable at compile time\n #[macro_export]\n macro_rules! debug_assert(\n@@ -65,3 +76,13 @@ macro_rules! debug_assert(\n macro_rules! try(\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n )\n+\n+#[cfg(test)]\n+macro_rules! vec( ($($e:expr),*) => ({\n+    let mut _v = ::std::vec::Vec::new();\n+    $(_v.push($e);)*\n+    _v\n+}) )\n+\n+#[cfg(test)]\n+macro_rules! format( ($($arg:tt)*) => (format_args!(::fmt::format, $($arg)*)) )"}, {"sha": "00f21ee4c9cedee495cd2d9dfd8e400cdc95d223", "filename": "src/libcore/option.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -595,9 +595,11 @@ pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) ->\n \n #[cfg(test)]\n mod tests {\n-    use realstd::option::collect;\n-    use realstd::prelude::*;\n-    use realstd::iter::range;\n+    use realstd::vec::Vec;\n+    use realstd::str::StrAllocating;\n+    use option::collect;\n+    use prelude::*;\n+    use iter::range;\n \n     use str::StrSlice;\n     use kinds::marker;\n@@ -638,7 +640,7 @@ mod tests {\n         impl ::ops::Drop for R {\n            fn drop(&mut self) {\n                 let ii = &*self.i;\n-                let i = ii.borrow().clone();\n+                let i = *ii.borrow();\n                 *ii.borrow_mut() = i + 1;\n             }\n         }\n@@ -649,9 +651,14 @@ mod tests {\n             }\n         }\n \n+        fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n+            use realstd::clone::Clone;\n+            t.clone()\n+        }\n+\n         let i = Rc::new(RefCell::new(0));\n         {\n-            let x = R(i.clone());\n+            let x = R(realclone(&i));\n             let opt = Some(x);\n             let _y = opt.unwrap();\n         }\n@@ -849,21 +856,21 @@ mod tests {\n     fn test_collect() {\n         let v: Option<Vec<int>> = collect(range(0, 0)\n                                           .map(|_| Some(0)));\n-        assert_eq!(v, Some(vec![]));\n+        assert!(v == Some(vec![]));\n \n         let v: Option<Vec<int>> = collect(range(0, 3)\n                                           .map(|x| Some(x)));\n-        assert_eq!(v, Some(vec![0, 1, 2]));\n+        assert!(v == Some(vec![0, 1, 2]));\n \n         let v: Option<Vec<int>> = collect(range(0, 3)\n                                           .map(|x| if x > 1 { None } else { Some(x) }));\n-        assert_eq!(v, None);\n+        assert!(v == None);\n \n         // test that it does not take more elements than it needs\n         let mut functions = [|| Some(()), || None, || fail!()];\n \n         let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n \n-        assert_eq!(v, None);\n+        assert!(v == None);\n     }\n }"}, {"sha": "acdf0bf06589f6a7dcaa1874f1ad9b0316b1650b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -480,7 +480,7 @@ impl<T> Ord for *mut T {\n #[cfg(test)]\n pub mod ptr_tests {\n     use super::*;\n-    use realstd::prelude::*;\n+    use prelude::*;\n \n     use realstd::c_str::ToCStr;\n     use mem;\n@@ -660,9 +660,6 @@ pub mod ptr_tests {\n                     let expected = expected_arr[ctr].with_ref(|buf| {\n                             str::raw::from_c_str(buf)\n                         });\n-                    debug!(\n-                        \"test_ptr_array_each_with_len e: {}, a: {}\",\n-                        expected, actual);\n                     assert_eq!(actual, expected);\n                     ctr += 1;\n                     iteration_count += 1;\n@@ -696,9 +693,6 @@ pub mod ptr_tests {\n                     let expected = expected_arr[ctr].with_ref(|buf| {\n                         str::raw::from_c_str(buf)\n                     });\n-                    debug!(\n-                        \"test_ptr_array_each e: {}, a: {}\",\n-                        expected, actual);\n                     assert_eq!(actual, expected);\n                     ctr += 1;\n                     iteration_count += 1;"}, {"sha": "3237269e4a64fb0dbe8a22e9822055c327e4ae29", "filename": "src/libcore/result.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -268,7 +268,7 @@\n \n use clone::Clone;\n use cmp::Eq;\n-use fmt::Show;\n+use std::fmt::Show;\n use iter::{Iterator, FromIterator};\n use option::{None, Option, Some};\n \n@@ -621,9 +621,12 @@ pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n \n #[cfg(test)]\n mod tests {\n-    use realstd::result::{collect, fold, fold_};\n-    use realstd::prelude::*;\n-    use realstd::iter::range;\n+    use realstd::vec::Vec;\n+    use realstd::str::StrAllocating;\n+\n+    use result::{collect, fold, fold_};\n+    use prelude::*;\n+    use iter::range;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n     pub fn op2() -> Result<int, ~str> { Err(\"sadface\".to_owned()) }\n@@ -670,33 +673,37 @@ mod tests {\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Ok(\"ab\".to_owned()));\n-        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Err(\"a\".to_owned()));\n+        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"),\n+                   Ok(\"ab\".to_owned()));\n+        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"),\n+                   Err(\"a\".to_owned()));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Ok(\"a\".to_owned()));\n-        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Err(\"ab\".to_owned()));\n+        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"),\n+                   Ok(\"a\".to_owned()));\n+        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"),\n+                   Err(\"ab\".to_owned()));\n     }\n \n     #[test]\n     fn test_collect() {\n         let v: Result<Vec<int>, ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n-        assert_eq!(v, Ok(vec![]));\n+        assert!(v == Ok(vec![]));\n \n         let v: Result<Vec<int>, ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n-        assert_eq!(v, Ok(vec![0, 1, 2]));\n+        assert!(v == Ok(vec![0, 1, 2]));\n \n         let v: Result<Vec<int>, int> = collect(range(0, 3)\n                                                .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n-        assert_eq!(v, Err(2));\n+        assert!(v == Err(2));\n \n         // test that it does not take more elements than it needs\n         let mut functions = [|| Ok(()), || Err(1), || fail!()];\n \n         let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n-        assert_eq!(v, Err(1));\n+        assert!(v == Err(1));\n     }\n \n     #[test]\n@@ -720,15 +727,6 @@ mod tests {\n                    Err(1));\n     }\n \n-    #[test]\n-    pub fn test_to_str() {\n-        let ok: Result<int, ~str> = Ok(100);\n-        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n-\n-        assert_eq!(ok.to_str(), \"Ok(100)\".to_owned());\n-        assert_eq!(err.to_str(), \"Err(Err)\".to_owned());\n-    }\n-\n     #[test]\n     pub fn test_fmt_default() {\n         let ok: Result<int, ~str> = Ok(100);"}, {"sha": "b55952e70598a85a069f8ab6c7015802bb4630a7", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -20,7 +20,7 @@\n //      1. Implement DST\n //      2. Make `Box<T>` not a language feature\n //      3. Move `Box<T>` to a separate crate, liballoc.\n-//      4. Implement relevant trais in liballoc, not libcore\n+//      4. Implement relevant traits in liballoc, not libcore\n //\n // Currently, no progress has been made on this list.\n "}, {"sha": "d80e9f0888865b2e16415461f84c98524f44cd2e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -103,12 +103,24 @@ fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n     ty::walk_ty(original_type, |t| {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n-            ty_trait(box ty::TyTrait { def_id, .. }) |\n             ty_struct(def_id, _) => {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     found_nominal = true;\n                 }\n             }\n+            ty_trait(box ty::TyTrait { def_id, ref store, .. }) => {\n+                if def_id.krate == ast::LOCAL_CRATE {\n+                    found_nominal = true;\n+                }\n+                if *store == ty::UniqTraitStore {\n+                    match tcx.lang_items.owned_box() {\n+                        Some(did) if did.krate == ast::LOCAL_CRATE => {\n+                            found_nominal = true;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n             ty_uniq(..) => {\n                 match tcx.lang_items.owned_box() {\n                     Some(did) if did.krate == ast::LOCAL_CRATE => {"}, {"sha": "563da5318f7c13f1e67d2cccd3340e6aa3a404b5", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -290,7 +290,7 @@ impl fmt::Show for clean::Type {\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path} => {\n                 try!(resolved_path(f, did, path, false));\n-                tybounds(f.buf, typarams)\n+                tybounds(f, typarams)\n             }\n             clean::Self(..) => f.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {"}, {"sha": "86b77a46a39809a165a96d7acda41d06201ffeac", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -285,10 +285,10 @@ use std::io;\n format_args!(fmt::format, \"this returns {}\", \"~str\");\n \n let some_writer: &mut io::Writer = &mut io::stdout();\n-format_args!(|args| { fmt::write(some_writer, args) }, \"print with a {}\", \"closure\");\n+format_args!(|args| { write!(some_writer, \"{}\", args) }, \"print with a {}\", \"closure\");\n \n fn my_fmt_fn(args: &fmt::Arguments) {\n-    fmt::write(&mut io::stdout(), args);\n+    write!(&mut io::stdout(), \"{}\", args);\n }\n format_args!(my_fmt_fn, \"or a {} too\", \"function\");\n # }\n@@ -490,6 +490,7 @@ use repr;\n use result::{Ok, Err};\n use str::{StrAllocating};\n use str;\n+use strbuf::StrBuf;\n use slice::Vector;\n \n pub use core::fmt::{Formatter, Result, FormatWriter, Show, rt};\n@@ -550,6 +551,13 @@ pub fn format(args: &Arguments) -> ~str {\n     str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned()\n }\n \n+/// Temporary transition utility\n+pub fn format_strbuf(args: &Arguments) -> StrBuf {\n+    let mut output = io::MemWriter::new();\n+    let _ = write!(&mut output, \"{}\", args);\n+    str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf()\n+}\n+\n impl<T> Poly for T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match (f.width, f.precision) {"}, {"sha": "fc760e6fe4ca312cd874369a7ac17df517b2dc1a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -308,9 +308,9 @@ impl fmt::Show for Command {\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}\", str::from_utf8_lossy(self.program.as_bytes_no_nul())));\n+        try!(write!(f, \"{}\", str::from_utf8_lossy(self.program.as_bytes_no_nul())));\n         for arg in self.args.iter() {\n-            try!(write!(f.buf, \" '{}'\", str::from_utf8_lossy(arg.as_bytes_no_nul())));\n+            try!(write!(f, \" '{}'\", str::from_utf8_lossy(arg.as_bytes_no_nul())));\n         }\n         Ok(())\n     }"}, {"sha": "e9ea0df2a7b9e4f02b3706a9f6b849827bc75f51", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -19,7 +19,6 @@ use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n use num::strconv;\n-use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use num;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};"}, {"sha": "869a275b1d4089b57eb983bc99b599b54dd3f17a", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -15,6 +15,7 @@\n use prelude::*;\n \n use from_str::FromStr;\n+use intrinsics;\n use libc::c_int;\n use num::strconv;\n use num;"}, {"sha": "ddff42f68dba9fe870fb49fbfb9c89586d692eab", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -68,11 +68,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     let mut buf = [0u8, ..65];\n     let amt = {\n         let mut wr = ::io::BufWriter::new(buf);\n-        if radix == 10 {\n-            (write!(&mut wr, \"{}\", n)).unwrap()\n-        } else {\n-            (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap()\n-        }\n+        (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n     f(buf.slice(0, amt))\n@@ -82,11 +78,7 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        if radix == 10 {\n-            format!(\"{}\", *self)\n-        } else {\n-            format!(\"{}\", ::fmt::radix(*self, radix as u8))\n-        }\n+        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n     }\n }\n "}, {"sha": "e58872b8395a6c388cc974eb83aa007c2bd3de6e", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -19,7 +19,6 @@ use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use result::ResultUnwrap;\n use slice::{CloneableVector, ImmutableVector, MutableVector};\n use std::cmp::{Ord, Eq};\n use str::{StrAllocating, StrSlice};"}, {"sha": "bd6684b390572b217e717aff2305146e30288239", "filename": "src/libstd/owned.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -14,6 +14,7 @@ use any::{Any, AnyRefExt};\n use clone::Clone;\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n use default::Default;\n+use fmt;\n use intrinsics;\n use mem;\n use raw::TraitObject;\n@@ -99,3 +100,16 @@ impl AnyOwnExt for Box<Any> {\n         }\n     }\n }\n+\n+impl<T: fmt::Show> fmt::Show for Box<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl fmt::Show for Box<Any> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Box<Any>\")\n+    }\n+}"}, {"sha": "5c875b4a2ad088acd92035d2c85f498c12e982cd", "filename": "src/libstd/task.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -49,7 +49,6 @@ use str::{Str, SendStr, IntoMaybeOwned};\n \n #[cfg(test)] use any::AnyRefExt;\n #[cfg(test)] use owned::AnyOwnExt;\n-#[cfg(test)] use realstd::result::ResultUnwrap;\n #[cfg(test)] use result;\n #[cfg(test)] use str::StrAllocating;\n "}, {"sha": "f0bc0204fd26d17a53262f6581ba2619246396ea", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// no-pretty-expanded\n+\n #![feature(phase)]\n #[phase(syntax)] extern crate green;\n \n@@ -33,7 +35,7 @@ impl fmt::Show for Color {\n             Yellow => \"yellow\",\n             Blue => \"blue\",\n         };\n-        f.buf.write(str.as_bytes())\n+        write!(f, \"{}\", str)\n     }\n }\n \n@@ -82,7 +84,7 @@ impl fmt::Show for Number {\n         }\n \n         for s in out.iter().rev() {\n-            try!(f.buf.write(s.as_bytes()));\n+            try!(write!(f, \"{}\", s))\n         }\n         Ok(())\n     }"}, {"sha": "14c2a5ae6c8b6a153700957d50945f37dbedcca3", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// no-pretty-expanded\n+\n #![allow(unused_must_use, dead_code)]\n #![feature(macro_rules)]\n \n@@ -22,8 +24,9 @@ fn borrowing_writer_from_struct_and_formatting_struct_field(foo: Foo) {\n     write!(foo.writer, \"{}\", foo.other);\n }\n \n-pub fn main() {\n+fn main() {\n     let mut w = MemWriter::new();\n     write!(&mut w as &mut Writer, \"\");\n     write!(&mut w, \"\"); // should coerce\n+    println!(\"ok\");\n }"}]}