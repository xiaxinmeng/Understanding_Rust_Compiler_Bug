{"sha": "5ff551d86f32155792dbeecc23f8e498fced41b8", "node_id": "C_kwDOAAsO6NoAKDVmZjU1MWQ4NmYzMjE1NTc5MmRiZWVjYzIzZjhlNDk4ZmNlZDQxYjg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-02T10:06:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-02T10:06:24Z"}, "message": "Merge #10426\n\n10426: internal: use naming that matches intended use-case r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9de82d81b4c4515372126142b9226785fa343ade", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9de82d81b4c4515372126142b9226785fa343ade"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ff551d86f32155792dbeecc23f8e498fced41b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhWC8gCRBK7hj4Ov3rIwAA9XUIACH7+gFVvcDXajg1ElfBYe+v\nCrwn8xtE4xaJQIz0j8DXeilaJOYEnhOmbezu3Ppmk1nBd5jrugE9YmzFS56E9DO7\nnDn8LjiqfLKELDb1kg5Tgm5POG39XvfjjuUzam/fDspoZ9+A+zlm27x//b4AnyXD\n+zWLEH+vOdw/1Ax2c8V3UY+iPcawqTKUhSRYZpYKN8mKdY5Ih1Wml5EEjcVX1Ccw\nNUasCp2OKm9XhJwGA9PxTBHszlPYmUzKLTKQnks40BIs1RUsRaz4DoEBEpWS5rr1\nRy3vuQB7ZB4kXT2t3ZAVQ9KTNntMYi60Gc+Z7NiFCapvB1tTx7mwuzXKIsTe+Fw=\n=301v\n-----END PGP SIGNATURE-----\n", "payload": "tree 9de82d81b4c4515372126142b9226785fa343ade\nparent c1fa58378173fa0b1aa582d5888f1155e37799c0\nparent 12103b16de2012988cc4ebcb025f7149a7ee6336\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633169184 +0000\ncommitter GitHub <noreply@github.com> 1633169184 +0000\n\nMerge #10426\n\n10426: internal: use naming that matches intended use-case r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff551d86f32155792dbeecc23f8e498fced41b8", "html_url": "https://github.com/rust-lang/rust/commit/5ff551d86f32155792dbeecc23f8e498fced41b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ff551d86f32155792dbeecc23f8e498fced41b8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1fa58378173fa0b1aa582d5888f1155e37799c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1fa58378173fa0b1aa582d5888f1155e37799c0", "html_url": "https://github.com/rust-lang/rust/commit/c1fa58378173fa0b1aa582d5888f1155e37799c0"}, {"sha": "12103b16de2012988cc4ebcb025f7149a7ee6336", "url": "https://api.github.com/repos/rust-lang/rust/commits/12103b16de2012988cc4ebcb025f7149a7ee6336", "html_url": "https://github.com/rust-lang/rust/commit/12103b16de2012988cc4ebcb025f7149a7ee6336"}], "stats": {"total": 175, "additions": 97, "deletions": 78}, "files": [{"sha": "f910edebf11080c13f53c7061131fb43dc150093", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=5ff551d86f32155792dbeecc23f8e498fced41b8", "patch": "@@ -3,7 +3,7 @@ use ide_db::{\n     base_db::FilePosition,\n     defs::{Definition, NameClass, NameRefClass},\n     helpers::{for_each_break_expr, for_each_tail_expr, node_ext::walk_expr, pick_best_token},\n-    search::{FileReference, ReferenceAccess, SearchScope},\n+    search::{FileReference, ReferenceCategory, SearchScope},\n     RootDatabase,\n };\n use rustc_hash::FxHashSet;\n@@ -19,7 +19,10 @@ use crate::{display::TryToNav, references, NavigationTarget};\n #[derive(PartialEq, Eq, Hash)]\n pub struct HighlightedRange {\n     pub range: TextRange,\n-    pub access: Option<ReferenceAccess>,\n+    // FIXME: This needs to be more precise. Reference category makes sense only\n+    // for references, but we also have defs. And things like exit points are\n+    // neither.\n+    pub category: Option<ReferenceCategory>,\n }\n \n #[derive(Default, Clone)]\n@@ -87,7 +90,10 @@ fn highlight_references(\n                 .remove(&file_id)\n         })\n         .flatten()\n-        .map(|FileReference { access, range, .. }| HighlightedRange { range, access });\n+        .map(|FileReference { category: access, range, .. }| HighlightedRange {\n+            range,\n+            category: access,\n+        });\n \n     let declarations = defs.iter().flat_map(|def| {\n         match def {\n@@ -99,8 +105,12 @@ fn highlight_references(\n         .filter(|decl| decl.file_id == file_id)\n         .and_then(|decl| {\n             let range = decl.focus_range?;\n-            let access = references::decl_access(&def, syntax, range);\n-            Some(HighlightedRange { range, access })\n+            let category = if references::decl_mutability(&def, syntax, range) {\n+                Some(ReferenceCategory::Write)\n+            } else {\n+                None\n+            };\n+            Some(HighlightedRange { range, category })\n         })\n     });\n \n@@ -125,18 +135,20 @@ fn highlight_exit_points(\n         walk_expr(&body, &mut |expr| match expr {\n             ast::Expr::ReturnExpr(expr) => {\n                 if let Some(token) = expr.return_token() {\n-                    highlights.push(HighlightedRange { access: None, range: token.text_range() });\n+                    highlights.push(HighlightedRange { category: None, range: token.text_range() });\n                 }\n             }\n             ast::Expr::TryExpr(try_) => {\n                 if let Some(token) = try_.question_mark_token() {\n-                    highlights.push(HighlightedRange { access: None, range: token.text_range() });\n+                    highlights.push(HighlightedRange { category: None, range: token.text_range() });\n                 }\n             }\n             ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n                 if sema.type_of_expr(&expr).map_or(false, |ty| ty.original.is_never()) {\n-                    highlights\n-                        .push(HighlightedRange { access: None, range: expr.syntax().text_range() });\n+                    highlights.push(HighlightedRange {\n+                        category: None,\n+                        range: expr.syntax().text_range(),\n+                    });\n                 }\n             }\n             _ => (),\n@@ -154,7 +166,7 @@ fn highlight_exit_points(\n                         .map_or_else(|| tail.syntax().text_range(), |tok| tok.text_range()),\n                     _ => tail.syntax().text_range(),\n                 };\n-                highlights.push(HighlightedRange { access: None, range })\n+                highlights.push(HighlightedRange { category: None, range })\n             });\n         }\n         Some(highlights)\n@@ -187,13 +199,13 @@ fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n             token.map(|tok| tok.text_range()),\n             label.as_ref().map(|it| it.syntax().text_range()),\n         );\n-        highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n+        highlights.extend(range.map(|range| HighlightedRange { category: None, range }));\n         for_each_break_expr(label, body, &mut |break_| {\n             let range = cover_range(\n                 break_.break_token().map(|it| it.text_range()),\n                 break_.lifetime().map(|it| it.syntax().text_range()),\n             );\n-            highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n+            highlights.extend(range.map(|range| HighlightedRange { category: None, range }));\n         });\n         Some(highlights)\n     }\n@@ -241,13 +253,13 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n         body: Option<ast::Expr>,\n     ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights =\n-            vec![HighlightedRange { access: None, range: async_token?.text_range() }];\n+            vec![HighlightedRange { category: None, range: async_token?.text_range() }];\n         if let Some(body) = body {\n             walk_expr(&body, &mut |expr| {\n                 if let ast::Expr::AwaitExpr(expr) = expr {\n                     if let Some(token) = expr.await_token() {\n                         highlights\n-                            .push(HighlightedRange { access: None, range: token.text_range() });\n+                            .push(HighlightedRange { category: None, range: token.text_range() });\n                     }\n                 }\n             });\n@@ -353,10 +365,10 @@ mod tests {\n             .map(|hl| {\n                 (\n                     hl.range,\n-                    hl.access.map(|it| {\n+                    hl.category.map(|it| {\n                         match it {\n-                            ReferenceAccess::Read => \"read\",\n-                            ReferenceAccess::Write => \"write\",\n+                            ReferenceCategory::Read => \"read\",\n+                            ReferenceCategory::Write => \"write\",\n                         }\n                         .to_string()\n                     }),"}, {"sha": "5c47227990700e1d07c91c2ad414cd2e12eecd63", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=5ff551d86f32155792dbeecc23f8e498fced41b8", "patch": "@@ -108,7 +108,7 @@ pub use ide_db::{\n     call_info::CallInfo,\n     label::Label,\n     line_index::{LineCol, LineColUtf16, LineIndex},\n-    search::{ReferenceAccess, SearchScope},\n+    search::{ReferenceCategory, SearchScope},\n     source_change::{FileSystemEdit, SourceChange},\n     symbol_index::Query,\n     RootDatabase, SymbolKind,"}, {"sha": "fd36cfc44def9b178e6ab313294293bfe2f852f3", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=5ff551d86f32155792dbeecc23f8e498fced41b8", "patch": "@@ -16,7 +16,7 @@ use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n-    search::{ReferenceAccess, SearchScope, UsageSearchResult},\n+    search::{ReferenceCategory, SearchScope, UsageSearchResult},\n     RootDatabase,\n };\n use rustc_hash::FxHashMap;\n@@ -31,13 +31,13 @@ use crate::{display::TryToNav, FilePosition, NavigationTarget};\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     pub declaration: Option<Declaration>,\n-    pub references: FxHashMap<FileId, Vec<(TextRange, Option<ReferenceAccess>)>>,\n+    pub references: FxHashMap<FileId, Vec<(TextRange, Option<ReferenceCategory>)>>,\n }\n \n #[derive(Debug, Clone)]\n pub struct Declaration {\n     pub nav: NavigationTarget,\n-    pub access: Option<ReferenceAccess>,\n+    pub is_mut: bool,\n }\n \n // Feature: Find All References\n@@ -88,7 +88,7 @@ pub(crate) fn find_all_refs(\n                 .map(|nav| {\n                     let decl_range = nav.focus_or_full_range();\n                     Declaration {\n-                        access: decl_access(&def, sema.parse(nav.file_id).syntax(), decl_range),\n+                        is_mut: decl_mutability(&def, sema.parse(nav.file_id).syntax(), decl_range),\n                         nav,\n                     }\n                 });\n@@ -102,7 +102,7 @@ pub(crate) fn find_all_refs(\n                         (\n                             file_id,\n                             refs.into_iter()\n-                                .map(|file_ref| (file_ref.range, file_ref.access))\n+                                .map(|file_ref| (file_ref.range, file_ref.category))\n                                 .collect(),\n                         )\n                     })\n@@ -145,27 +145,19 @@ pub(crate) fn find_defs<'a>(\n     })\n }\n \n-pub(crate) fn decl_access(\n-    def: &Definition,\n-    syntax: &SyntaxNode,\n-    range: TextRange,\n-) -> Option<ReferenceAccess> {\n+pub(crate) fn decl_mutability(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> bool {\n     match def {\n         Definition::Local(_) | Definition::Field(_) => {}\n-        _ => return None,\n+        _ => return false,\n     };\n \n-    let stmt = find_node_at_offset::<ast::LetStmt>(syntax, range.start())?;\n-    if stmt.initializer().is_some() {\n-        let pat = stmt.pat()?;\n-        if let ast::Pat::IdentPat(it) = pat {\n-            if it.mut_token().is_some() {\n-                return Some(ReferenceAccess::Write);\n-            }\n-        }\n+    match find_node_at_offset::<ast::LetStmt>(syntax, range.start()) {\n+        Some(stmt) if stmt.initializer().is_some() => match stmt.pat() {\n+            Some(ast::Pat::IdentPat(it)) => it.mut_token().is_some(),\n+            _ => false,\n+        },\n+        _ => false,\n     }\n-\n-    None\n }\n \n /// Filter out all non-literal usages for adt-defs\n@@ -283,7 +275,7 @@ fn is_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use ide_db::base_db::FileId;\n+    use ide_db::{base_db::FileId, search::ReferenceCategory};\n     use stdx::format_to;\n \n     use crate::{fixture, SearchScope};\n@@ -1095,8 +1087,8 @@ impl Foo {\n \n             if let Some(decl) = refs.declaration {\n                 format_to!(actual, \"{}\", decl.nav.debug_render());\n-                if let Some(access) = decl.access {\n-                    format_to!(actual, \" {:?}\", access)\n+                if decl.is_mut {\n+                    format_to!(actual, \" {:?}\", ReferenceCategory::Write)\n                 }\n                 actual += \"\\n\\n\";\n             }"}, {"sha": "585ef31daf2e73cbd4170f1757df5007ab1c20a6", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=5ff551d86f32155792dbeecc23f8e498fced41b8", "patch": "@@ -6,7 +6,7 @@ use hir::{HirDisplay, InFile, Local, Semantics, TypeInfo};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     helpers::node_ext::{preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr},\n-    search::{FileReference, ReferenceAccess, SearchScope},\n+    search::{FileReference, ReferenceCategory, SearchScope},\n     RootDatabase,\n };\n use itertools::Itertools;\n@@ -877,7 +877,7 @@ fn reference_is_exclusive(\n     ctx: &AssistContext,\n ) -> bool {\n     // we directly modify variable with set: `n = 0`, `n += 1`\n-    if reference.access == Some(ReferenceAccess::Write) {\n+    if reference.category == Some(ReferenceCategory::Write) {\n         return true;\n     }\n "}, {"sha": "707323272974f5308eb988f51fa4f8542d4e66f3", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=5ff551d86f32155792dbeecc23f8e498fced41b8", "patch": "@@ -58,13 +58,18 @@ impl IntoIterator for UsageSearchResult {\n pub struct FileReference {\n     pub range: TextRange,\n     pub name: ast::NameLike,\n-    pub access: Option<ReferenceAccess>,\n+    pub category: Option<ReferenceCategory>,\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum ReferenceAccess {\n-    Read,\n+pub enum ReferenceCategory {\n+    // FIXME: Add this variant and delete the `retain_adt_literal_usages` function.\n+    // Create\n     Write,\n+    Read,\n+    // FIXME: Some day should be able to search in doc comments. Would probably\n+    // need to switch from enum to bitflags then?\n+    // DocComment\n }\n \n /// Generally, `search_scope` returns files that might contain references for the element.\n@@ -472,7 +477,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    access: None,\n+                    category: None,\n                 };\n                 sink(file_id, reference)\n             }\n@@ -491,7 +496,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    access: None,\n+                    category: None,\n                 };\n                 sink(file_id, reference)\n             }\n@@ -510,7 +515,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::Lifetime(lifetime.clone()),\n-                    access: None,\n+                    category: None,\n                 };\n                 sink(file_id, reference)\n             }\n@@ -529,7 +534,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    access: reference_access(&def, name_ref),\n+                    category: ReferenceCategory::new(&def, name_ref),\n                 };\n                 sink(file_id, reference)\n             }\n@@ -539,7 +544,7 @@ impl<'a> FindUsages<'a> {\n                     let reference = FileReference {\n                         range,\n                         name: ast::NameLike::NameRef(name_ref.clone()),\n-                        access: reference_access(&def, name_ref),\n+                        category: ReferenceCategory::new(&def, name_ref),\n                     };\n                     sink(file_id, reference)\n                 } else {\n@@ -550,14 +555,19 @@ impl<'a> FindUsages<'a> {\n                 let field = Definition::Field(field);\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let access = match self.def {\n-                    Definition::Field(_) if field == self.def => reference_access(&field, name_ref),\n+                    Definition::Field(_) if field == self.def => {\n+                        ReferenceCategory::new(&field, name_ref)\n+                    }\n                     Definition::Local(l) if local == l => {\n-                        reference_access(&Definition::Local(local), name_ref)\n+                        ReferenceCategory::new(&Definition::Local(local), name_ref)\n                     }\n                     _ => return false,\n                 };\n-                let reference =\n-                    FileReference { range, name: ast::NameLike::NameRef(name_ref.clone()), access };\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    category: access,\n+                };\n                 sink(file_id, reference)\n             }\n             _ => false,\n@@ -580,14 +590,17 @@ impl<'a> FindUsages<'a> {\n                     range,\n                     name: ast::NameLike::Name(name.clone()),\n                     // FIXME: mutable patterns should have `Write` access\n-                    access: Some(ReferenceAccess::Read),\n+                    category: Some(ReferenceCategory::Read),\n                 };\n                 sink(file_id, reference)\n             }\n             Some(NameClass::ConstReference(def)) if self.def == def => {\n                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n-                let reference =\n-                    FileReference { range, name: ast::NameLike::Name(name.clone()), access: None };\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::Name(name.clone()),\n+                    category: None,\n+                };\n                 sink(file_id, reference)\n             }\n             // Resolve trait impl function definitions to the trait definition's version if self.def is the trait definition's\n@@ -611,7 +624,7 @@ impl<'a> FindUsages<'a> {\n                         let reference = FileReference {\n                             range,\n                             name: ast::NameLike::Name(name.clone()),\n-                            access: None,\n+                            category: None,\n                         };\n                         sink(file_id, reference)\n                     })\n@@ -642,32 +655,34 @@ fn def_to_ty(sema: &Semantics<RootDatabase>, def: &Definition) -> Option<hir::Ty\n     }\n }\n \n-fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n-    // Only Locals and Fields have accesses for now.\n-    if !matches!(def, Definition::Local(_) | Definition::Field(_)) {\n-        return None;\n-    }\n+impl ReferenceCategory {\n+    fn new(def: &Definition, r: &ast::NameRef) -> Option<ReferenceCategory> {\n+        // Only Locals and Fields have accesses for now.\n+        if !matches!(def, Definition::Local(_) | Definition::Field(_)) {\n+            return None;\n+        }\n \n-    let mode = name_ref.syntax().ancestors().find_map(|node| {\n+        let mode = r.syntax().ancestors().find_map(|node| {\n         match_ast! {\n             match (node) {\n                 ast::BinExpr(expr) => {\n                     if matches!(expr.op_kind()?, ast::BinaryOp::Assignment { .. }) {\n                         // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n                         // FIXME: This is not terribly accurate.\n                         if let Some(lhs) = expr.lhs() {\n-                            if lhs.syntax().text_range().end() == name_ref.syntax().text_range().end() {\n-                                return Some(ReferenceAccess::Write);\n+                            if lhs.syntax().text_range().end() == r.syntax().text_range().end() {\n+                                return Some(ReferenceCategory::Write);\n                             }\n                         }\n                     }\n-                    Some(ReferenceAccess::Read)\n+                    Some(ReferenceCategory::Read)\n                 },\n                 _ => None\n             }\n         }\n     });\n \n-    // Default Locals and Fields to read\n-    mode.or(Some(ReferenceAccess::Read))\n+        // Default Locals and Fields to read\n+        mode.or(Some(ReferenceCategory::Read))\n+    }\n }"}, {"sha": "e62bb9499fa36aad936cfb65fdf42b2dde27a21e", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=5ff551d86f32155792dbeecc23f8e498fced41b8", "patch": "@@ -1182,9 +1182,9 @@ pub(crate) fn handle_document_highlight(\n     };\n     let res = refs\n         .into_iter()\n-        .map(|ide::HighlightedRange { range, access }| lsp_types::DocumentHighlight {\n+        .map(|ide::HighlightedRange { range, category }| lsp_types::DocumentHighlight {\n             range: to_proto::range(&line_index, range),\n-            kind: access.map(to_proto::document_highlight_kind),\n+            kind: category.map(to_proto::document_highlight_kind),\n         })\n         .collect();\n     Ok(Some(res))"}, {"sha": "59a768397fefe5b408dec5d232d0597d542f2ab5", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff551d86f32155792dbeecc23f8e498fced41b8/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=5ff551d86f32155792dbeecc23f8e498fced41b8", "patch": "@@ -9,7 +9,7 @@ use ide::{\n     Annotation, AnnotationKind, Assist, AssistKind, CallInfo, Cancellable, CompletionItem,\n     CompletionItemKind, CompletionRelevance, Documentation, FileId, FileRange, FileSystemEdit,\n     Fold, FoldKind, Highlight, HlMod, HlOperator, HlPunct, HlRange, HlTag, Indel, InlayHint,\n-    InlayKind, Markup, NavigationTarget, ReferenceAccess, RenameError, Runnable, Severity,\n+    InlayKind, Markup, NavigationTarget, ReferenceCategory, RenameError, Runnable, Severity,\n     SourceChange, StructureNodeKind, SymbolKind, TextEdit, TextRange, TextSize,\n };\n use itertools::Itertools;\n@@ -75,11 +75,11 @@ pub(crate) fn structure_node_kind(kind: StructureNodeKind) -> lsp_types::SymbolK\n }\n \n pub(crate) fn document_highlight_kind(\n-    reference_access: ReferenceAccess,\n+    category: ReferenceCategory,\n ) -> lsp_types::DocumentHighlightKind {\n-    match reference_access {\n-        ReferenceAccess::Read => lsp_types::DocumentHighlightKind::Read,\n-        ReferenceAccess::Write => lsp_types::DocumentHighlightKind::Write,\n+    match category {\n+        ReferenceCategory::Read => lsp_types::DocumentHighlightKind::Read,\n+        ReferenceCategory::Write => lsp_types::DocumentHighlightKind::Write,\n     }\n }\n "}]}