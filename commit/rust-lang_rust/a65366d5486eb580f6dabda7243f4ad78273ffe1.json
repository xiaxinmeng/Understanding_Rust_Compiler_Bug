{"sha": "a65366d5486eb580f6dabda7243f4ad78273ffe1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NTM2NmQ1NDg2ZWI1ODBmNmRhYmRhNzI0M2Y0YWQ3ODI3M2ZmZTE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-17T22:25:35Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-18T00:14:32Z"}, "message": "Parse explicit self in more places. Work on #2585.", "tree": {"sha": "9572417b7479a8bac26723d0cdd6e6a6d271eeb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9572417b7479a8bac26723d0cdd6e6a6d271eeb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a65366d5486eb580f6dabda7243f4ad78273ffe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a65366d5486eb580f6dabda7243f4ad78273ffe1", "html_url": "https://github.com/rust-lang/rust/commit/a65366d5486eb580f6dabda7243f4ad78273ffe1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a65366d5486eb580f6dabda7243f4ad78273ffe1/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0845579130e91f31e58d5453d87a6e4afa0cfacf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0845579130e91f31e58d5453d87a6e4afa0cfacf", "html_url": "https://github.com/rust-lang/rust/commit/0845579130e91f31e58d5453d87a6e4afa0cfacf"}], "stats": {"total": 122, "additions": 68, "deletions": 54}, "files": [{"sha": "648ec3e60db7b738ce1a8d2a7fe6de9e6971f151", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 68, "deletions": 54, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a65366d5486eb580f6dabda7243f4ad78273ffe1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65366d5486eb580f6dabda7243f4ad78273ffe1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a65366d5486eb580f6dabda7243f4ad78273ffe1", "patch": "@@ -291,17 +291,8 @@ struct parser {\n         let inputs = do self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n             seq_sep_trailing_disallowed(token::COMMA)) |p| {\n-            let mode = p.parse_arg_mode();\n-            let name = if is_plain_ident(p.token)\n-                && p.look_ahead(1u) == token::COLON {\n \n-                let name = self.parse_value_ident();\n-                p.bump();\n-                name\n-            } else { @~\"\" };\n-\n-            {mode: mode, ty: p.parse_ty(false), ident: name,\n-             id: p.get_id()}\n+            p.parse_arg_general(false)\n         };\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         return {inputs: inputs, output: ret_ty,\n@@ -321,11 +312,18 @@ struct parser {\n             // could change.\n             let vis = p.parse_visibility();\n             let ident = p.parse_method_name();\n+\n             let tps = p.parse_ty_params();\n-            let d = p.parse_ty_fn_decl(pur);\n+\n+            let (self_ty, d, _) = do self.parse_fn_decl_with_self(pur) |p| {\n+                // This is somewhat dubious; We don't want to allow argument\n+                // names to be left off if there is a definition...\n+                either::Left(p.parse_arg_general(false))\n+            };\n+            // XXX: Wrong. Shouldn't allow both static and self_ty\n+            let self_ty = if is_static { static_sty } else { self_ty };\n+\n             let hi = p.last_span.hi;\n-            let self_ty = if is_static { static_sty } else\n-                { spanned(lo, hi, sty_by_ref) }; // XXX: Wrong.\n             debug!{\"parse_trait_methods(): trait method signature ends in \\\n                     `%s`\",\n                    token_to_str(p.reader, p.token)};\n@@ -571,12 +569,30 @@ struct parser {\n         }\n     }\n \n-    fn parse_arg() -> arg_or_capture_item {\n+    // This version of parse arg doesn't necessarily require\n+    // identifier names.\n+    fn parse_arg_general(require_name: bool) -> arg {\n         let m = self.parse_arg_mode();\n-        let i = self.parse_value_ident();\n-        self.expect(token::COLON);\n+        let i = if require_name {\n+            let name = self.parse_value_ident();\n+            self.expect(token::COLON);\n+            name\n+        } else {\n+            if is_plain_ident(self.token)\n+                && self.look_ahead(1u) == token::COLON {\n+                let name = self.parse_value_ident();\n+                self.bump();\n+                name\n+            } else { @~\"\" }\n+        };\n+\n         let t = self.parse_ty(false);\n-        either::Left({mode: m, ty: t, ident: i, id: self.get_id()})\n+\n+        {mode: m, ty: t, ident: i, id: self.get_id()}\n+    }\n+\n+    fn parse_arg() -> arg_or_capture_item {\n+        either::Left(self.parse_arg_general(true))\n     }\n \n     fn parse_arg_or_capture_item() -> arg_or_capture_item {\n@@ -2308,48 +2324,46 @@ struct parser {\n                                     fn(parser) -> arg_or_capture_item)\n                             -> (self_ty, fn_decl, capture_clause) {\n \n+        fn maybe_parse_self_ty(cnstr: fn(+mutability) -> ast::self_ty_,\n+                               p: parser) -> ast::self_ty_ {\n+            // We need to make sure it isn't a mode or a type\n+            if p.token_is_keyword(~\"self\", p.look_ahead(1)) ||\n+                ((p.token_is_keyword(~\"const\", p.look_ahead(1)) ||\n+                  p.token_is_keyword(~\"mut\", p.look_ahead(1))) &&\n+                 p.token_is_keyword(~\"self\", p.look_ahead(2))) {\n+\n+                p.bump();\n+                let mutability = p.parse_mutability();\n+                p.expect_self_ident();\n+                cnstr(mutability)\n+            } else {\n+                sty_by_ref\n+            }\n+        }\n+\n         self.expect(token::LPAREN);\n \n         // A bit of complexity and lookahead is needed here in order to to be\n         // backwards compatible.\n         let lo = self.span.lo;\n-        let self_ty;\n-        match copy self.token {\n-            token::BINOP(token::AND) => {\n-                // We need to make sure it isn't a mode.\n-                if self.token_is_keyword(~\"self\", self.look_ahead(1)) ||\n-                    ((self.token_is_keyword(~\"const\", self.look_ahead(1)) ||\n-                      self.token_is_keyword(~\"mut\", self.look_ahead(1))) &&\n-                      self.token_is_keyword(~\"self\", self.look_ahead(2))) {\n-\n-                    self.bump();\n-                    let mutability = self.parse_mutability();\n-                    self.expect_self_ident();\n-                    self_ty = sty_region(mutability);\n-                } else {\n-                    self_ty = sty_by_ref;\n-                }\n-            }\n-            token::AT => {\n-                self.bump();\n-                let mutability = self.parse_mutability();\n-                self.expect_self_ident();\n-                self_ty = sty_box(mutability);\n-            }\n-            token::TILDE => {\n-                self.bump();\n-                let mutability = self.parse_mutability();\n-                self.expect_self_ident();\n-                self_ty = sty_uniq(mutability);\n-            }\n-            token::IDENT(*) if self.is_self_ident() => {\n-                self.bump();\n-                self_ty = sty_value;\n-            }\n-            _ => {\n-                self_ty = sty_by_ref;\n-            }\n-        }\n+        let self_ty = match copy self.token {\n+          token::BINOP(token::AND) => {\n+            maybe_parse_self_ty(sty_region, self)\n+          }\n+          token::AT => {\n+            maybe_parse_self_ty(sty_box, self)\n+          }\n+          token::TILDE => {\n+            maybe_parse_self_ty(sty_uniq, self)\n+          }\n+          token::IDENT(*) if self.is_self_ident() => {\n+            self.bump();\n+            sty_value\n+          }\n+          _ => {\n+            sty_by_ref\n+          }\n+        };\n \n         // If we parsed a self type, expect a comma before the argument list.\n         let args_or_capture_items;"}]}