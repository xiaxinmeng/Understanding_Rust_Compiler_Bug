{"sha": "91e44ea05651ea9d9fda1e903009e3a3390dd7c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZTQ0ZWEwNTY1MWVhOWQ5ZmRhMWU5MDMwMDllM2EzMzkwZGQ3YzA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-26T05:11:19Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-26T18:14:39Z"}, "message": "Be a little more clever about calculating sizes for class types\n\nWe could try to calculate the size of a partially-converted class type,\nand run into an LLVM error because we were trying to calculate the size\nof a named struct whose fields hadn't yet be filled in. The issue can be\ndodged by extending simplify_type to convert classes to isomorphic\nstructural records, just for the purposes of size calculations.\n\n(for real this time) Closes #2718", "tree": {"sha": "646f8422729456038648df5165ca5d5d2334d00e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/646f8422729456038648df5165ca5d5d2334d00e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91e44ea05651ea9d9fda1e903009e3a3390dd7c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91e44ea05651ea9d9fda1e903009e3a3390dd7c0", "html_url": "https://github.com/rust-lang/rust/commit/91e44ea05651ea9d9fda1e903009e3a3390dd7c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91e44ea05651ea9d9fda1e903009e3a3390dd7c0/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf69604551324f68d1fc7ab0386ecbe9e1aaa504", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf69604551324f68d1fc7ab0386ecbe9e1aaa504", "html_url": "https://github.com/rust-lang/rust/commit/cf69604551324f68d1fc7ab0386ecbe9e1aaa504"}], "stats": {"total": 299, "additions": 272, "deletions": 27}, "files": [{"sha": "33e6051d70b2caa0c424902377de7dfdf7abf3af", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/91e44ea05651ea9d9fda1e903009e3a3390dd7c0/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e44ea05651ea9d9fda1e903009e3a3390dd7c0/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=91e44ea05651ea9d9fda1e903009e3a3390dd7c0", "patch": "@@ -18,6 +18,7 @@ import syntax::codemap::span;\n import dvec::{dvec, extensions};\n \n import std::map::hashmap;\n+import option::is_some;\n \n import ty_ctxt = middle::ty::ctxt;\n \n@@ -732,19 +733,24 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           ty::ty_estr(ty::vstore_slice(_)) {\n             ty::mk_tup(tcx, [nilptr(tcx), ty::mk_int(tcx)]/~)\n           }\n+          // Reduce a class type to a record type in which all the fields are\n+          // simplified\n+          ty::ty_class(did, substs) {\n+            let simpl_fields = (if is_some(ty::ty_dtor(tcx, did)) {\n+                // remember the drop flag\n+                  [{ident: @\"drop\", mt: {ty:\n+                                        ty::mk_u8(tcx),\n+                                        mutbl: ast::m_mutbl}}]/~ }\n+                else { []/~ }) +\n+              ty::lookup_class_fields(tcx, did).map {|f|\n+                 let t = ty::lookup_field_type(tcx, did, f.id, substs);\n+                 {ident: f.ident,\n+                  mt: {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n+            };\n+            ty::mk_rec(tcx, simpl_fields)\n+          }\n           _ { typ }\n         }\n     }\n     ty::fold_ty(tcx, typ) {|t| simplifier(tcx, t) }\n }\n-\n-// Given a tag type `ty`, returns the offset of the payload.\n-//fn tag_payload_offs(bcx: block, tag_id: ast::def_id, tps: [ty::t]/~)\n-//    -> ValueRef {\n-//    alt tag_kind(tag_id) {\n-//      tk_unit | tk_enum | tk_newtype { C_int(bcx.ccx(), 0) }\n-//      tk_complex {\n-//        compute_tag_metrics(tag_id, tps)\n-//      }\n-//    }\n-//}"}, {"sha": "90184bf05af1af22780fe36526d4be4122d5f712", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 255, "deletions": 16, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/91e44ea05651ea9d9fda1e903009e3a3390dd7c0/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e44ea05651ea9d9fda1e903009e3a3390dd7c0/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=91e44ea05651ea9d9fda1e903009e3a3390dd7c0", "patch": "@@ -1,7 +1,141 @@\n-fn sender_terminate<T:send>(p: *packet<T>) {\n-}\n+mod pipes {\n+    import unsafe::{forget, reinterpret_cast};\n+\n+    enum state {\n+        empty,\n+        full,\n+        blocked,\n+        terminated\n+    }\n+\n+    type packet<T: send> = {\n+        mut state: state,\n+        mut blocked_task: option<task::task>,\n+        mut payload: option<T>\n+    };\n+\n+    fn packet<T: send>() -> *packet<T> unsafe {\n+        let p: *packet<T> = unsafe::transmute(~{\n+            mut state: empty,\n+            mut blocked_task: none::<task::task>,\n+            mut payload: none::<T>\n+        });\n+        p\n+    }\n+\n+    #[abi = \"rust-intrinsic\"]\n+    mod rusti {\n+      fn atomic_xchng(&dst: int, src: int) -> int { fail; }\n+      fn atomic_xchng_acq(&dst: int, src: int) -> int { fail; }\n+      fn atomic_xchng_rel(&dst: int, src: int) -> int { fail; }\n+    }\n+\n+    // We should consider moving this to core::unsafe, although I\n+    // suspect graydon would want us to use void pointers instead.\n+    unsafe fn uniquify<T>(x: *T) -> ~T {\n+        unsafe { unsafe::reinterpret_cast(x) }\n+    }\n+\n+    fn swap_state_acq(&dst: state, src: state) -> state {\n+        unsafe {\n+            reinterpret_cast(rusti::atomic_xchng_acq(\n+                *(ptr::mut_addr_of(dst) as *mut int),\n+                src as int))\n+        }\n+    }\n+\n+    fn swap_state_rel(&dst: state, src: state) -> state {\n+        unsafe {\n+            reinterpret_cast(rusti::atomic_xchng_rel(\n+                *(ptr::mut_addr_of(dst) as *mut int),\n+                src as int))\n+        }\n+    }\n+\n+    fn send<T: send>(-p: send_packet<T>, -payload: T) {\n+        let p = p.unwrap();\n+        let p = unsafe { uniquify(p) };\n+        assert (*p).payload == none;\n+        (*p).payload <- some(payload);\n+        let old_state = swap_state_rel((*p).state, full);\n+        alt old_state {\n+          empty {\n+            // Yay, fastpath.\n \n-class send_packet<T: send> {\n+            // The receiver will eventually clean this up.\n+            unsafe { forget(p); }\n+          }\n+          full { fail \"duplicate send\" }\n+          blocked {\n+            // FIXME: once the target will actually block, tell the\n+            // scheduler to wake it up.\n+\n+            // The receiver will eventually clean this up.\n+            unsafe { forget(p); }\n+          }\n+          terminated {\n+            // The receiver will never receive this. Rely on drop_glue\n+            // to clean everything up.\n+          }\n+        }\n+    }\n+\n+    fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n+        let p = p.unwrap();\n+        let p = unsafe { uniquify(p) };\n+        loop {\n+            let old_state = swap_state_acq((*p).state,\n+                                           blocked);\n+            alt old_state {\n+              empty | blocked { task::yield(); }\n+              full {\n+                let mut payload = none;\n+                payload <-> (*p).payload;\n+                ret some(option::unwrap(payload))\n+              }\n+              terminated {\n+                assert old_state == terminated;\n+                ret none;\n+              }\n+            }\n+        }\n+    }\n+\n+    fn sender_terminate<T: send>(p: *packet<T>) {\n+        let p = unsafe { uniquify(p) };\n+        alt swap_state_rel((*p).state, terminated) {\n+          empty | blocked {\n+            // The receiver will eventually clean up.\n+            unsafe { forget(p) }\n+          }\n+          full {\n+            // This is impossible\n+            fail \"you dun goofed\"\n+          }\n+          terminated {\n+            // I have to clean up, use drop_glue\n+          }\n+        }\n+    }\n+\n+    fn receiver_terminate<T: send>(p: *packet<T>) {\n+        let p = unsafe { uniquify(p) };\n+        alt swap_state_rel((*p).state, terminated) {\n+          empty {\n+            // the sender will clean up\n+            unsafe { forget(p) }\n+          }\n+          blocked {\n+            // this shouldn't happen.\n+            fail \"terminating a blocked packet\"\n+          }\n+          terminated | full {\n+            // I have to clean up, use drop_glue\n+          }\n+        }\n+    }\n+\n+    class send_packet<T: send> {\n         let mut p: option<*packet<T>>;\n         new(p: *packet<T>) { self.p = some(p); }\n         drop {\n@@ -16,23 +150,128 @@ class send_packet<T: send> {\n             p <-> self.p;\n             option::unwrap(p)\n         }\n+    }\n+\n+    class recv_packet<T: send> {\n+        let mut p: option<*packet<T>>;\n+        new(p: *packet<T>) { self.p = some(p); }\n+        drop {\n+            if self.p != none {\n+                let mut p = none;\n+                p <-> self.p;\n+                receiver_terminate(option::unwrap(p))\n+            }\n+        }\n+        fn unwrap() -> *packet<T> {\n+            let mut p = none;\n+            p <-> self.p;\n+            option::unwrap(p)\n+        }\n+    }\n+\n+    fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n+        let p = packet();\n+        (send_packet(p), recv_packet(p))\n+    }\n }\n \n-enum state {\n-        empty,\n-        full,\n-        blocked,\n-        terminated\n+mod pingpong {\n+    enum ping = pipes::send_packet<pong>;\n+    enum pong = pipes::send_packet<ping>;\n+\n+    fn liberate_ping(-p: ping) -> pipes::send_packet<pong> unsafe {\n+        let addr : *pipes::send_packet<pong> = alt p {\n+          ping(x) { unsafe::reinterpret_cast(ptr::addr_of(x)) }\n+        };\n+        let liberated_value <- *addr;\n+        unsafe::forget(p);\n+        liberated_value\n+    }\n+\n+    fn liberate_pong(-p: pong) -> pipes::send_packet<ping> unsafe {\n+        let addr : *pipes::send_packet<ping> = alt p {\n+          pong(x) { unsafe::reinterpret_cast(ptr::addr_of(x)) }\n+        };\n+        let liberated_value <- *addr;\n+        unsafe::forget(p);\n+        liberated_value\n+    }\n+\n+    fn init() -> (client::ping, server::ping) {\n+        pipes::entangle()\n+    }\n+\n+    mod client {\n+        type ping = pipes::send_packet<pingpong::ping>;\n+        type pong = pipes::recv_packet<pingpong::pong>;\n+\n+        fn do_ping(-c: ping) -> pong {\n+            let (sp, rp) = pipes::entangle();\n+\n+            pipes::send(c, ping(sp));\n+            rp\n+        }\n+\n+        fn do_pong(-c: pong) -> (ping, ()) {\n+            let packet = pipes::recv(c);\n+            if packet == none {\n+                fail \"sender closed the connection\"\n+            }\n+            (liberate_pong(option::unwrap(packet)), ())\n+        }\n+    }\n+\n+    mod server {\n+        type ping = pipes::recv_packet<pingpong::ping>;\n+        type pong = pipes::send_packet<pingpong::pong>;\n+\n+        fn do_ping(-c: ping) -> (pong, ()) {\n+            let packet = pipes::recv(c);\n+            if packet == none {\n+                fail \"sender closed the connection\"\n+            }\n+            (liberate_ping(option::unwrap(packet)), ())\n+        }\n+\n+        fn do_pong(-c: pong) -> ping {\n+            let (sp, rp) = pipes::entangle();\n+            pipes::send(c, pong(sp));\n+            rp\n+        }\n+    }\n }\n \n-type packet<T: send> = {\n-        mut state: state,\n-        mut blocked_task: option<task::task>,\n-        mut payload: option<T>\n-};\n+fn client(-chan: pingpong::client::ping) {\n+    let chan = pingpong::client::do_ping(chan);\n+    log(error, \"Sent ping\");\n+    let (chan, _data) = pingpong::client::do_pong(chan);\n+    log(error, \"Received pong\");\n+}\n+\n+fn server(-chan: pingpong::server::ping) {\n+    let (chan, _data) = pingpong::server::do_ping(chan);\n+    log(error, \"Received ping\");\n+    let chan = pingpong::server::do_pong(chan);\n+    log(error, \"Sent pong\");\n+}\n \n fn main() {\n-  let _s: send_packet<int> = send_packet(ptr::addr_of({mut state: empty,\n-        mut blocked_task: none,\n-        mut payload: some(42)}));\n+  /*\n+//    Commented out because of option::get error\n+\n+    let (client_, server_) = pingpong::init();\n+    let client_ = ~mut some(client_);\n+    let server_ = ~mut some(server_);\n+\n+    task::spawn {|move client_|\n+        let mut client__ = none;\n+        *client_ <-> client__;\n+        client(option::unwrap(client__));\n+    };\n+    task::spawn {|move server_|\n+        let mut server_\u02ca = none;\n+        *server_ <-> server_\u02ca;\n+        server(option::unwrap(server_\u02ca));\n+    };\n+  */\n }"}]}