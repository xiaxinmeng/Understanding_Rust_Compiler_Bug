{"sha": "ddcd157d03a067419d7f5b4375cfaff5a474856a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkY2QxNTdkMDNhMDY3NDE5ZDdmNWI0Mzc1Y2ZhZmY1YTQ3NDg1NmE=", "commit": {"author": {"name": "Stefan Lankes", "email": "stlankes@users.noreply.github.com", "date": "2019-10-22T17:01:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-22T17:01:09Z"}, "message": "Merge branch 'master' into rusty-hermit", "tree": {"sha": "c0b1bc8b196ff630dc9b7dfcf6f4e869e38b5e6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0b1bc8b196ff630dc9b7dfcf6f4e869e38b5e6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddcd157d03a067419d7f5b4375cfaff5a474856a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdrzXVCRBK7hj4Ov3rIwAAdHIIAHi8TAazaK9iqd1cBCkrhyJg\nFO1JPo+9rcTpAIY4EZW8X+zRQwQqd/qUjnGOyXLPvBlrPxvCB5OKpRAUHrxYRtnQ\n8vO+TJ45IHTYmkbIDsEzSeuiO03g8jv5nClIDqpZBpLLHr15IcuRjdJHzwK3uINn\naSmXmmA+u8SYF59+MNHyFdLrVrCsQNJnfN6jetz+ZyQQXNYzUcOQORbJz6WFivD9\ntWoGvof21Wyup8ZAnEHDFlr8aYYXIWWK2iomhJkBTYYm5K1gbVW54DZza+akJiR/\n4EAb9B9T9UHnJZIVqmLy+1EfcuLxZttjIQEnNK1cO8Mr/4BVm1FoppHHEw9ArAU=\n=0AMZ\n-----END PGP SIGNATURE-----\n", "payload": "tree c0b1bc8b196ff630dc9b7dfcf6f4e869e38b5e6c\nparent 8a11c61a7af9ffa6585ee93b266e02fa1d642ba8\nparent 57bfb8096295150c06559da10adc5629e445a4ac\nauthor Stefan Lankes <stlankes@users.noreply.github.com> 1571763669 +0200\ncommitter GitHub <noreply@github.com> 1571763669 +0200\n\nMerge branch 'master' into rusty-hermit"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddcd157d03a067419d7f5b4375cfaff5a474856a", "html_url": "https://github.com/rust-lang/rust/commit/ddcd157d03a067419d7f5b4375cfaff5a474856a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddcd157d03a067419d7f5b4375cfaff5a474856a/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a11c61a7af9ffa6585ee93b266e02fa1d642ba8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a11c61a7af9ffa6585ee93b266e02fa1d642ba8", "html_url": "https://github.com/rust-lang/rust/commit/8a11c61a7af9ffa6585ee93b266e02fa1d642ba8"}, {"sha": "57bfb8096295150c06559da10adc5629e445a4ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/57bfb8096295150c06559da10adc5629e445a4ac", "html_url": "https://github.com/rust-lang/rust/commit/57bfb8096295150c06559da10adc5629e445a4ac"}], "stats": {"total": 6288, "additions": 3542, "deletions": 2746}, "files": [{"sha": "487867c375d4529a0a7f0e36c6b2207665e174c6", "filename": ".gitignore", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,6 +1,10 @@\n-# This file should only ignore things that are generated during a build,\n-# generated by common IDEs, and optional files controlled by the user\n-# that affect the build (such as config.toml).\n+# This file should only ignore things that are generated during a `x.py` build,\n+# generated by common IDEs, and optional files controlled by the user that\n+# affect the build (such as config.toml).\n+# In particular, things like `mir_dump` should not be listed here; they are only\n+# created during manual debugging and many people like to clean up instead of\n+# having git ignore such leftovers. You can use `.git/info/exclude` to\n+# configure your local ignore list.\n # FIXME: This needs cleanup.\n *~\n .#*\n@@ -52,3 +56,4 @@ config.stamp\n Session.vim\n .cargo\n no_llvm_build\n+# Before adding new lines, see the comment at the top."}, {"sha": "1dcf9ed319f149ee1054dbc761f47ad9dc2702e7", "filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -28,9 +28,6 @@\n [submodule \"src/doc/rust-by-example\"]\n \tpath = src/doc/rust-by-example\n \turl = https://github.com/rust-lang/rust-by-example.git\n-[submodule \"src/llvm-emscripten\"]\n-\tpath = src/llvm-emscripten\n-\turl = https://github.com/rust-lang/llvm.git\n [submodule \"src/stdarch\"]\n \tpath = src/stdarch\n \turl = https://github.com/rust-lang/stdarch.git"}, {"sha": "e83d38b569ffbf8789b8c2f9f1d48f222acead4c", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1724,9 +1724,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.62\"\n+version = \"0.2.64\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34fcd2c08d2f832f376f4173a231990fa5aef4e99fb569867318a227ef4c06ba\"\n+checksum = \"74dfca3d9957906e8d1e6a0b641dc9a59848e793f1da2165889fd4f62d10d79c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -3567,6 +3567,7 @@ dependencies = [\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n  \"rustc_resolve\",\n+ \"rustc_target\",\n  \"rustc_traits\",\n  \"rustc_typeck\",\n  \"serialize\","}, {"sha": "be977024426097f689f56e5869194d95b334ceb1", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -374,10 +374,7 @@\n \n # This is an array of the codegen backends that will be compiled for the rustc\n # that's being compiled. The default is to only build the LLVM codegen backend,\n-# but you can also optionally enable the \"emscripten\" backend for asm.js or\n-# make this an empty array (but that probably won't get too far in the\n-# bootstrap)\n-# FIXME: remove the obsolete emscripten backend option.\n+# and currently the only standard option supported is `\"llvm\"`\n #codegen-backends = [\"llvm\"]\n \n # This is the name of the directory in which codegen backends will get installed"}, {"sha": "4caf36a6f2a51442df56e79af4028492c25647e8", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -734,10 +734,6 @@ def update_submodules(self):\n             if module.endswith(\"llvm-project\"):\n                 if self.get_toml('llvm-config') and self.get_toml('lld') != 'true':\n                     continue\n-            if module.endswith(\"llvm-emscripten\"):\n-                backends = self.get_toml('codegen-backends')\n-                if backends is None or not 'emscripten' in backends:\n-                    continue\n             check = self.check_submodule(module, slow_submodules)\n             filtered_submodules.append((module, check))\n             submodules_names.append(module)"}, {"sha": "4310f2c6fa1405902c8ee04fdf068be18dda8226", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -161,7 +161,7 @@ impl Ord for Interned<String> {\n     }\n }\n \n-struct TyIntern<T: Hash + Clone + Eq> {\n+struct TyIntern<T: Clone + Eq> {\n     items: Vec<T>,\n     set: HashMap<T, Interned<T>>,\n }"}, {"sha": "5074b035789ae13798659e19013e954f22c03f6d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -210,7 +210,6 @@ pub fn std_cargo(builder: &Builder<'_>,\n             // config.toml equivalent) is used\n             let llvm_config = builder.ensure(native::Llvm {\n                 target: builder.config.build,\n-                emscripten: false,\n             });\n             cargo.env(\"LLVM_CONFIG\", llvm_config);\n             cargo.env(\"RUSTC_BUILD_SANITIZERS\", \"1\");\n@@ -615,36 +614,27 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n                              compiler: &Compiler,\n                              target: Interned<String>,\n                              backend: Interned<String>) -> String {\n-    let mut features = String::new();\n-\n     match &*backend {\n-        \"llvm\" | \"emscripten\" => {\n+        \"llvm\" => {\n             // Build LLVM for our target. This will implicitly build the\n             // host LLVM if necessary.\n             let llvm_config = builder.ensure(native::Llvm {\n                 target,\n-                emscripten: backend == \"emscripten\",\n             });\n \n-            if backend == \"emscripten\" {\n-                features.push_str(\" emscripten\");\n-            }\n-\n             builder.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n                      compiler.stage, &compiler.host, target, backend));\n \n             // Pass down configuration from the LLVM build into the build of\n             // librustc_llvm and librustc_codegen_llvm.\n-            if builder.is_rust_llvm(target) && backend != \"emscripten\" {\n+            if builder.is_rust_llvm(target) {\n                 cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n             }\n \n             cargo.env(\"LLVM_CONFIG\", &llvm_config);\n-            if backend != \"emscripten\" {\n-                let target_config = builder.config.target_config.get(&target);\n-                if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-                    cargo.env(\"CFG_LLVM_ROOT\", s);\n-                }\n+            let target_config = builder.config.target_config.get(&target);\n+            if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+                cargo.env(\"CFG_LLVM_ROOT\", s);\n             }\n             // Some LLVM linker flags (-L and -l) may be needed to link librustc_llvm.\n             if let Some(ref s) = builder.config.llvm_ldflags {\n@@ -662,9 +652,7 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n                                          \"libstdc++.a\");\n                 cargo.env(\"LLVM_STATIC_STDCPP\", file);\n             }\n-            if builder.config.llvm_link_shared ||\n-                (builder.config.llvm_thin_lto && backend != \"emscripten\")\n-            {\n+            if builder.config.llvm_link_shared || builder.config.llvm_thin_lto {\n                 cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n             }\n             if builder.config.llvm_use_libcxx {\n@@ -676,8 +664,7 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n         }\n         _ => panic!(\"unknown backend: {}\", backend),\n     }\n-\n-    features\n+    String::new()\n }\n \n /// Creates the `codegen-backends` folder for a compiler that's about to be"}, {"sha": "441bb8d68faf9c5915dc346300e31ca5167b0468", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -668,7 +668,6 @@ impl Config {\n \n     pub fn llvm_enabled(&self) -> bool {\n         self.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\"))\n-        || self.rust_codegen_backends.contains(&INTERNER.intern_str(\"emscripten\"))\n     }\n }\n "}, {"sha": "76509134f7ccdf3c3517a449fa5c380e58e6f372", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -55,7 +55,6 @@ def v(*args):\n o(\"dist-src\", \"rust.dist-src\", \"when building tarballs enables building a source tarball\")\n o(\"cargo-native-static\", \"build.cargo-native-static\", \"static native libraries in cargo\")\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n-o(\"emscripten\", None, \"compile the emscripten backend as well as LLVM\")\n o(\"full-tools\", None, \"enable all tools\")\n o(\"lld\", \"rust.lld\", \"build lld\")\n o(\"lldb\", \"rust.lldb\", \"build lldb\")\n@@ -335,10 +334,8 @@ def set(key, value):\n         set('build.host', value.split(','))\n     elif option.name == 'target':\n         set('build.target', value.split(','))\n-    elif option.name == 'emscripten':\n-        set('rust.codegen-backends', ['llvm', 'emscripten'])\n     elif option.name == 'full-tools':\n-        set('rust.codegen-backends', ['llvm', 'emscripten'])\n+        set('rust.codegen-backends', ['llvm'])\n         set('rust.lld', True)\n         set('rust.llvm-tools', True)\n         set('build.extended', True)"}, {"sha": "514ad1144491706c50b4fe4831e23652a29bc4ab", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -826,17 +826,13 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n \n         const LLVM_TEST: &[&str] = &[\n             \"llvm-project/llvm/test\", \"llvm-project\\\\llvm\\\\test\",\n-            \"llvm-emscripten/test\", \"llvm-emscripten\\\\test\",\n         ];\n         if LLVM_TEST.iter().any(|path| spath.contains(path)) &&\n             (spath.ends_with(\".ll\") ||\n              spath.ends_with(\".td\") ||\n              spath.ends_with(\".s\")) {\n             return false\n         }\n-        if spath.contains(\"test/emscripten\") || spath.contains(\"test\\\\emscripten\") {\n-            return false\n-        }\n \n         let full_path = Path::new(dir).join(path);\n         if exclude_dirs.iter().any(|excl| full_path == Path::new(excl)) {"}, {"sha": "42c3cfbd84ab2d4206a26854e1e6589ac86d133a", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -232,7 +232,6 @@ pub struct Build {\n     miri_info: channel::GitInfo,\n     rustfmt_info: channel::GitInfo,\n     in_tree_llvm_info: channel::GitInfo,\n-    emscripten_llvm_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n     doc_tests: DocTests,\n@@ -351,7 +350,6 @@ impl Build {\n \n         // we always try to use git for LLVM builds\n         let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n-        let emscripten_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-emscripten\"));\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n@@ -376,7 +374,6 @@ impl Build {\n             miri_info,\n             rustfmt_info,\n             in_tree_llvm_info,\n-            emscripten_llvm_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             ar: HashMap::new(),\n@@ -553,10 +550,6 @@ impl Build {\n         self.out.join(&*target).join(\"llvm\")\n     }\n \n-    fn emscripten_llvm_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"llvm-emscripten\")\n-    }\n-\n     fn lld_out(&self, target: Interned<String>) -> PathBuf {\n         self.out.join(&*target).join(\"lld\")\n     }"}, {"sha": "97cdd25680162869758a0349269360f112e4c1d2", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 25, "deletions": 50, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -28,7 +28,6 @@ use crate::GitRepo;\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: Interned<String>,\n-    pub emscripten: bool,\n }\n \n impl Step for Llvm {\n@@ -40,46 +39,35 @@ impl Step for Llvm {\n         run.path(\"src/llvm-project\")\n             .path(\"src/llvm-project/llvm\")\n             .path(\"src/llvm\")\n-            .path(\"src/llvm-emscripten\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        let emscripten = run.path.ends_with(\"llvm-emscripten\");\n         run.builder.ensure(Llvm {\n             target: run.target,\n-            emscripten,\n         });\n     }\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target = self.target;\n-        let emscripten = self.emscripten;\n \n         // If we're using a custom LLVM bail out here, but we can only use a\n         // custom LLVM for the build triple.\n-        if !self.emscripten {\n-            if let Some(config) = builder.config.target_config.get(&target) {\n-                if let Some(ref s) = config.llvm_config {\n-                    check_llvm_version(builder, s);\n-                    return s.to_path_buf()\n-                }\n+        if let Some(config) = builder.config.target_config.get(&target) {\n+            if let Some(ref s) = config.llvm_config {\n+                check_llvm_version(builder, s);\n+                return s.to_path_buf()\n             }\n         }\n \n-        let (llvm_info, root, out_dir, llvm_config_ret_dir) = if emscripten {\n-            let info = &builder.emscripten_llvm_info;\n-            let dir = builder.emscripten_llvm_out(target);\n-            let config_dir = dir.join(\"bin\");\n-            (info, \"src/llvm-emscripten\", dir, config_dir)\n-        } else {\n-            let info = &builder.in_tree_llvm_info;\n-            let mut dir = builder.llvm_out(builder.config.build);\n-            if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n-                dir.push(\"build\");\n-            }\n-            (info, \"src/llvm-project/llvm\", builder.llvm_out(target), dir.join(\"bin\"))\n-        };\n+        let llvm_info = &builder.in_tree_llvm_info;\n+        let root = \"src/llvm-project/llvm\";\n+        let out_dir = builder.llvm_out(target);\n+        let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n+        if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n+            llvm_config_ret_dir.push(\"build\");\n+        }\n+        llvm_config_ret_dir.push(\"bin\");\n \n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n@@ -107,8 +95,7 @@ impl Step for Llvm {\n             }\n         }\n \n-        let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n-        builder.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n+        builder.info(&format!(\"Building LLVM for {}\", target));\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n@@ -123,23 +110,15 @@ impl Step for Llvm {\n \n         // NOTE: remember to also update `config.toml.example` when changing the\n         // defaults!\n-        let llvm_targets = if self.emscripten {\n-            \"JSBackend\"\n-        } else {\n-            match builder.config.llvm_targets {\n-                Some(ref s) => s,\n-                None => \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n-                         Sparc;SystemZ;WebAssembly;X86\",\n-            }\n+        let llvm_targets = match &builder.config.llvm_targets {\n+            Some(s) => s,\n+            None => \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n+                     Sparc;SystemZ;WebAssembly;X86\",\n         };\n \n-        let llvm_exp_targets = if self.emscripten {\n-            \"\"\n-        } else {\n-            match builder.config.llvm_experimental_targets {\n-                Some(ref s) => s,\n-                None => \"\",\n-            }\n+        let llvm_exp_targets = match builder.config.llvm_experimental_targets {\n+            Some(ref s) => s,\n+            None => \"\",\n         };\n \n         let assertions = if builder.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n@@ -163,25 +142,23 @@ impl Step for Llvm {\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n-        if builder.config.llvm_thin_lto && !emscripten {\n+        if builder.config.llvm_thin_lto {\n             cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n             if !target.contains(\"apple\") {\n                cfg.define(\"LLVM_ENABLE_LLD\", \"ON\");\n             }\n         }\n \n-        let want_lldb = builder.config.lldb_enabled && !self.emscripten;\n-\n         // This setting makes the LLVM tools link to the dynamic LLVM library,\n         // which saves both memory during parallel links and overall disk space\n         // for the tools. We don't do this on every platform as it doesn't work\n         // equally well everywhere.\n-        if builder.llvm_link_tools_dynamically(target) && !emscripten {\n+        if builder.llvm_link_tools_dynamically(target) {\n             cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n         }\n \n         // For distribution we want the LLVM tools to be *statically* linked to libstdc++\n-        if builder.config.llvm_tools_enabled || want_lldb {\n+        if builder.config.llvm_tools_enabled || builder.config.lldb_enabled {\n             if !target.contains(\"windows\") {\n                 if target.contains(\"apple\") {\n                     cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-static-libstdc++\");\n@@ -209,7 +186,7 @@ impl Step for Llvm {\n             enabled_llvm_projects.push(\"compiler-rt\");\n         }\n \n-        if want_lldb {\n+        if builder.config.lldb_enabled {\n             enabled_llvm_projects.push(\"clang\");\n             enabled_llvm_projects.push(\"lldb\");\n             // For the time being, disable code signing.\n@@ -234,10 +211,9 @@ impl Step for Llvm {\n         }\n \n         // http://llvm.org/docs/HowToCrossCompileLLVM.html\n-        if target != builder.config.build && !emscripten {\n+        if target != builder.config.build {\n             builder.ensure(Llvm {\n                 target: builder.config.build,\n-                emscripten: false,\n             });\n             // FIXME: if the llvm root for the build triple is overridden then we\n             //        should use llvm-tblgen from there, also should verify that it\n@@ -481,7 +457,6 @@ impl Step for Lld {\n \n         let llvm_config = builder.ensure(Llvm {\n             target: self.target,\n-            emscripten: false,\n         });\n \n         let out_dir = builder.lld_out(target);"}, {"sha": "7ed67c6c7c5d528eb9c364c9a689870f3a3b1b0d", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -427,7 +427,7 @@ impl Step for Miri {\n             // (We do this separately from the above so that when the setup actually\n             // happens we get some output.)\n             // We re-use the `cargo` from above.\n-            cargo.arg(\"--env\");\n+            cargo.arg(\"--print-sysroot\");\n \n             // FIXME: Is there a way in which we can re-use the usual `run` helpers?\n             let miri_sysroot = if builder.config.dry_run {\n@@ -437,13 +437,11 @@ impl Step for Miri {\n                 let out = cargo.output()\n                     .expect(\"We already ran `cargo miri setup` before and that worked\");\n                 assert!(out.status.success(), \"`cargo miri setup` returned with non-0 exit code\");\n-                // Output is \"MIRI_SYSROOT=<str>\\n\".\n+                // Output is \"<sysroot>\\n\".\n                 let stdout = String::from_utf8(out.stdout)\n                     .expect(\"`cargo miri setup` stdout is not valid UTF-8\");\n-                let stdout = stdout.trim();\n-                builder.verbose(&format!(\"`cargo miri setup --env` returned: {:?}\", stdout));\n-                let sysroot = stdout.splitn(2, '=')\n-                    .nth(1).expect(\"`cargo miri setup` stdout did not contain '='\");\n+                let sysroot = stdout.trim_end();\n+                builder.verbose(&format!(\"`cargo miri setup --print-sysroot` said: {:?}\", sysroot));\n                 sysroot.to_owned()\n             };\n \n@@ -1165,7 +1163,7 @@ impl Step for Compiletest {\n                     }).to_string()\n             })\n         };\n-        let lldb_exe = if builder.config.lldb_enabled && !target.contains(\"emscripten\") {\n+        let lldb_exe = if builder.config.lldb_enabled {\n             // Test against the lldb that was just built.\n             builder.llvm_out(target).join(\"bin\").join(\"lldb\")\n         } else {\n@@ -1234,7 +1232,6 @@ impl Step for Compiletest {\n         if builder.config.llvm_enabled() {\n             let llvm_config = builder.ensure(native::Llvm {\n                 target: builder.config.build,\n-                emscripten: false,\n             });\n             if !builder.config.dry_run {\n                 let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));"}, {"sha": "fab3824a20ae3723968d0f018a6c161b7245bfc7", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -139,7 +139,6 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-aarch64=/musl-aarch64 \\\n       --musl-root-mips=/musl-mips \\\n       --musl-root-mipsel=/musl-mipsel \\\n-      --enable-emscripten \\\n       --disable-docs\n \n ENV SCRIPT \\"}, {"sha": "92c6e546a389571c1ab59492104a8bd7afc787d7", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -47,7 +47,7 @@ function fetch_github_commit_archive {\n     rm $cached\n }\n \n-included=\"src/llvm-project src/llvm-emscripten src/doc/book src/doc/rust-by-example\"\n+included=\"src/llvm-project src/doc/book src/doc/rust-by-example\"\n modules=\"$(git config --file .gitmodules --get-regexp '\\.path$' | cut -d' ' -f2)\"\n modules=($modules)\n use_git=\"\""}, {"sha": "813d7c4bafef8cfdaf779be20dacf71cfc46de35", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -596,30 +596,6 @@ warning: function cannot return without recursing\n   |\n ```\n \n-## unions-with-drop-fields\n-\n-This lint detects use of unions that contain fields with possibly non-trivial drop code. Some\n-example code that triggers this lint:\n-\n-```rust\n-#![feature(untagged_unions)]\n-\n-union U {\n-    s: String,\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n- --> src/main.rs:4:5\n-  |\n-4 |     s: String,\n-  |     ^^^^^^^^^\n-  |\n-```\n-\n ## unknown-lints\n \n This lint detects unrecognized lint attribute. Some"}, {"sha": "00a864170583efb921a8e3b6ddc29eca3ae6b269", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -167,7 +167,7 @@ pub trait FromIterator<A>: Sized {\n /// // and we'll implement IntoIterator\n /// impl IntoIterator for MyCollection {\n ///     type Item = i32;\n-///     type IntoIter = ::std::vec::IntoIter<Self::Item>;\n+///     type IntoIter = std::vec::IntoIter<Self::Item>;\n ///\n ///     fn into_iter(self) -> Self::IntoIter {\n ///         self.0.into_iter()"}, {"sha": "b4ade70414462cd45704c47623b16fb9134751b6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -3757,8 +3757,8 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n-            pub fn is_power_of_two(self) -> bool {\n-                (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n+            pub const fn is_power_of_two(self) -> bool {\n+                self.count_ones() == 1\n             }\n         }\n "}, {"sha": "d29147645f7ef8d7bfbf30442b194b23c80790f3", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -76,7 +76,7 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n /// ```\n /// # #![feature(dispatch_from_dyn, unsize)]\n /// # use std::{ops::DispatchFromDyn, marker::Unsize};\n-/// # struct Rc<T: ?Sized>(::std::rc::Rc<T>);\n+/// # struct Rc<T: ?Sized>(std::rc::Rc<T>);\n /// impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T>\n /// where\n ///     T: Unsize<U>,"}, {"sha": "9eb29eae7f75ab388f403ee4a472ea96c72dc93b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -64,7 +64,7 @@\n //!\n //! fn check_optional(optional: Option<Box<i32>>) {\n //!     match optional {\n-//!         Some(ref p) => println!(\"has value {}\", p),\n+//!         Some(p) => println!(\"has value {}\", p),\n //!         None => println!(\"has no value\"),\n //!     }\n //! }\n@@ -83,7 +83,7 @@\n //! let msg = Some(\"howdy\");\n //!\n //! // Take a reference to the contained string\n-//! if let Some(ref m) = msg {\n+//! if let Some(m) = &msg {\n //!     println!(\"{}\", *m);\n //! }\n //!\n@@ -395,10 +395,10 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, def: T) -> T {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Some(x) => x,\n-            None => def,\n+            None => default,\n         }\n     }\n "}, {"sha": "3cc0a1cd75e88f393dafa92680dcb0b807e048f3", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -188,7 +188,7 @@ unsafe fn real_drop_in_place<T: ?Sized>(to_drop: &mut T) {\n /// let p: *const i32 = ptr::null();\n /// assert!(p.is_null());\n /// ```\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n pub const fn null<T>() -> *const T { 0 as *const T }\n@@ -203,7 +203,7 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n /// let p: *mut i32 = ptr::null_mut();\n /// assert!(p.is_null());\n /// ```\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n pub const fn null_mut<T>() -> *mut T { 0 as *mut T }"}, {"sha": "f67012d8f2fceb72abe0ce67b0242296b255392b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -176,15 +176,15 @@ Section: Creating a string\n /// ```\n /// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n ///     loop {\n-///         match ::std::str::from_utf8(input) {\n+///         match std::str::from_utf8(input) {\n ///             Ok(valid) => {\n ///                 push(valid);\n ///                 break\n ///             }\n ///             Err(error) => {\n ///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n ///                 unsafe {\n-///                     push(::std::str::from_utf8_unchecked(valid))\n+///                     push(std::str::from_utf8_unchecked(valid))\n ///                 }\n ///                 push(\"\\u{FFFD}\");\n ///"}, {"sha": "93274ef0c927cdc1050bdc368710f3d672006fa2", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -36,5 +36,5 @@ parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"0.6.8\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.3\""}, {"sha": "0104507f7020ff30b940af4ffe85eaf85492f33e", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -35,7 +35,7 @@ impl DepNodeIndex {\n     pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(PartialEq)]\n pub enum DepNodeColor {\n     Red,\n     Green(DepNodeIndex)"}, {"sha": "d95637c3b986828638e8ea34b1b90cc56d2b2b0f", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -599,7 +599,6 @@ macro_rules! define_global_metadata_kind {\n     (pub enum GlobalMetaDataKind {\n         $($variant:ident),*\n     }) => (\n-        #[derive(Clone, Copy, Debug, Hash, RustcEncodable, RustcDecodable)]\n         pub enum GlobalMetaDataKind {\n             $($variant),*\n         }"}, {"sha": "364a8ace1aac434dd08b04403dbe7e0c3b0a5d0a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1077,7 +1077,7 @@ impl Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1211,7 +1211,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1388,8 +1388,7 @@ impl Body {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n     Async(AsyncGeneratorKind),\n@@ -1412,8 +1411,7 @@ impl fmt::Display for GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,"}, {"sha": "7ee461a859bd6b4e78f93589f406370110e29602", "filename": "src/librustc/hir/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -11,7 +11,7 @@ use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n-#[derive(Hash, PartialEq, Eq)]\n+#[derive(PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }"}, {"sha": "49a2c90bdbf603e37bf28edbafbb3c68781892f0", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -468,7 +468,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ConstValue::Infer(InferConst::Fresh(_)) => {\n                 bug!(\"encountered a fresh const during canonicalization\")\n             }\n-            ConstValue::Infer(InferConst::Canonical(debruijn, _)) => {\n+            ConstValue::Bound(debruijn, _) => {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n@@ -700,8 +700,8 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             let var = self.canonical_var(info, const_var.into());\n             self.tcx().mk_const(\n                 ty::Const {\n-                    val: ConstValue::Infer(InferConst::Canonical(self.binder_index, var.into())),\n-                    ty: const_var.ty,\n+                    val: ConstValue::Bound(self.binder_index, var.into()),\n+                    ty: self.fold_ty(const_var.ty),\n                 }\n             )\n         }"}, {"sha": "d833feeeb09d615f6187e69300cd2cd4cab17780", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -33,7 +33,7 @@ use std::ops::Index;\n use syntax::source_map::Span;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::GenericArg;\n-use crate::ty::{self, BoundVar, InferConst, Lift, List, Region, TyCtxt};\n+use crate::ty::{self, BoundVar, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n \n@@ -73,7 +73,7 @@ pub struct CanonicalVarValues<'tcx> {\n /// various parts of it with canonical variables. This struct stores\n /// those replaced bits to remember for when we process the query\n /// result.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct OriginalQueryValues<'tcx> {\n     /// Map from the universes that appear in the query to the\n     /// universes in the caller context. For the time being, we only\n@@ -510,9 +510,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                     GenericArgKind::Const(ct) => {\n                         tcx.mk_const(ty::Const {\n                             ty: ct.ty,\n-                            val: ConstValue::Infer(\n-                                InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from_u32(i))\n-                            ),\n+                            val: ConstValue::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n                         }).into()\n                     }\n                 })"}, {"sha": "7ad6006012f49cafecf02430b776414e90ee9f0a", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -26,7 +26,7 @@ use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n-use crate::ty::{self, BoundVar, InferConst, Ty, TyCtxt};\n+use crate::ty::{self, BoundVar, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n impl<'tcx> InferCtxtBuilder<'tcx> {\n@@ -493,10 +493,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     }\n                 }\n                 GenericArgKind::Const(result_value) => {\n-                    if let ty::Const {\n-                        val: ConstValue::Infer(InferConst::Canonical(debrujin, b)),\n-                        ..\n-                    } = result_value {\n+                    if let ty::Const { val: ConstValue::Bound(debrujin, b), .. } = result_value {\n                         // ...in which case we would set `canonical_vars[0]` to `Some(const X)`.\n \n                         // We only allow a `ty::INNERMOST` index in substitutions."}, {"sha": "f06dbc72cd9611c71f7ae383813ebca1f55df0a7", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -53,7 +53,7 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n-#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum RelationDir {\n     SubtypeOf, SupertypeOf, EqTo\n }"}, {"sha": "1841bd9ea6423e9a4e3d8c390fa348389275b186", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 return ct;\n             }\n \n-            ConstValue::Infer(ty::InferConst::Canonical(..)) |\n+            ConstValue::Bound(..) |\n             ConstValue::Placeholder(_) => {\n                 bug!(\"unexpected const {:?}\", ct)\n             }"}, {"sha": "f4ed7dac1f7c435b55fcea2a988224cdc0185319", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -407,7 +407,7 @@ pub enum RegionVariableOrigin {\n     NLL(NLLRegionVariableOrigin),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug)]\n pub enum NLLRegionVariableOrigin {\n     /// During NLL region processing, we create variables for free\n     /// regions that we encounter in the function signature and"}, {"sha": "64ef0421808f44f29958a7f79ac7d677bf7f6042", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -27,12 +27,12 @@ use crate::ty::error::TypeError;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::GenericArg;\n-use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::mir::interpret::ConstValue;\n use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Debug;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq)]\n pub enum NormalizationStrategy {\n     Lazy,\n     Eager,\n@@ -618,7 +618,7 @@ where\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        if let ty::Const { val: ConstValue::Infer(InferConst::Canonical(_, _)), .. } = a {\n+        if let ty::Const { val: ConstValue::Bound(..), .. } = a {\n             // FIXME(const_generics): I'm unsure how this branch should actually be handled,\n             // so this is probably not correct.\n             self.infcx.super_combine_consts(self, a, b)\n@@ -993,7 +993,7 @@ where\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         debug!(\"TypeGeneralizer::consts(a={:?})\", a);\n \n-        if let ty::Const { val: ConstValue::Infer(InferConst::Canonical(_, _)), .. } = a {\n+        if let ty::Const { val: ConstValue::Bound(..), .. } = a {\n             bug!(\n                 \"unexpected inference variable encountered in NLL generalization: {:?}\",\n                 a"}, {"sha": "8c6a7c9a376a79900eabcada996a0681fce73777", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -116,7 +116,7 @@ pub struct RegionConstraintData<'tcx> {\n }\n \n /// Represents a constraint that influences the inference process.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, PartialOrd, Ord)]\n pub enum Constraint<'tcx> {\n     /// A region variable is a subregion of another.\n     VarSubVar(RegionVid, RegionVid),"}, {"sha": "7c3a338366c9af3f3edf3ab291006e33411875b3", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,7 +1,7 @@\n use super::{InferCtxt, FixupError, FixupResult, Span};\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::mir::interpret::ConstValue;\n-use crate::ty::{self, Ty, Const, TyCtxt, TypeFoldable, InferConst, TypeFlags};\n+use crate::ty::{self, Ty, Const, TyCtxt, TypeFoldable, InferConst};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -29,7 +29,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_infer_types() {\n+        if !t.has_infer_types() && !t.has_infer_consts() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n@@ -38,7 +38,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n-        if !ct.has_type_flags(TypeFlags::HAS_CT_INFER) {\n+        if !ct.has_infer_consts() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let ct = self.infcx.shallow_resolve(ct);"}, {"sha": "3b0ac9ada8f65894e7cc52fbcbd6f0c73e3fd6fa", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -43,6 +43,7 @@\n #![feature(nll)]\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n+#![feature(option_expect_none)]\n #![feature(range_is_empty)]\n #![feature(slice_patterns)]\n #![feature(specialization)]"}, {"sha": "8ed06cbdc7623051a5ac9b348822309427d60001", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -202,11 +202,7 @@ impl<'a> LintLevelsBuilder<'a> {\n             let meta = unwrap_or!(attr.meta(), continue);\n             attr::mark_used(attr);\n \n-            let mut metas = if let Some(metas) = meta.meta_item_list() {\n-                metas\n-            } else {\n-                continue;\n-            };\n+            let mut metas = unwrap_or!(meta.meta_item_list(), continue);\n \n             if metas.is_empty() {\n                 // FIXME (#55112): issue unused-attributes lint for `#[level()]`"}, {"sha": "ec1e32988a607b4d0a3ac041a9b82ec8a7aea006", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -117,7 +117,7 @@ pub struct NativeLibrary {\n     pub wasm_import_module: Option<Symbol>,\n }\n \n-#[derive(Clone, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ForeignModule {\n     pub foreign_items: Vec<DefId>,\n     pub def_id: DefId,"}, {"sha": "cbf336fdbe2f3cd69627c81f94a8f689644e2a6e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -102,7 +102,7 @@ pub struct Upvar {\n }\n \n // different kinds of pointers:\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n pub enum PointerKind<'tcx> {\n     /// `Box<T>`\n     Unique,\n@@ -116,7 +116,7 @@ pub enum PointerKind<'tcx> {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g., a field\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq)]\n pub enum InteriorKind {\n     InteriorField(FieldIndex),\n     InteriorElement(InteriorOffsetKind),\n@@ -139,13 +139,13 @@ impl Hash for FieldIndex {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq)]\n pub enum InteriorOffsetKind {\n     Index,   // e.g., `array_expr[index_expr]`\n     Pattern, // e.g., `fn foo([_, a, _, _]: [A; 4]) { ... }`\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable."}, {"sha": "e65f17c79497e169c6375153ba836883c1183ce7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -25,7 +25,7 @@ use crate::util::nodemap::{FxHashSet, FxHashMap};\n use std::mem::replace;\n use std::cmp::Ordering;\n \n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Copy, Debug, Eq, Hash)]\n+#[derive(PartialEq, Clone, Copy, Debug)]\n pub enum StabilityLevel {\n     Unstable,\n     Stable,\n@@ -905,11 +905,10 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n             // Warn if the user has enabled an already-stable lang feature.\n             unnecessary_stable_feature_lint(tcx, span, feature, since);\n         }\n-        if lang_features.contains(&feature) {\n+        if !lang_features.insert(feature) {\n             // Warn if the user enables a lang feature multiple times.\n             duplicate_feature_err(tcx.sess, span, feature);\n         }\n-        lang_features.insert(feature);\n     }\n \n     let declared_lib_features = &tcx.features().declared_lib_features;"}, {"sha": "796d293e2c63cb72c1e05c32ed6c3a6618ef819b", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -245,6 +245,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// as a slice.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n+    /// on `InterpCx` instead.\n     #[inline]\n     pub fn get_bytes(\n         &self,\n@@ -275,6 +277,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// so be sure to actually put data there!\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n+    /// on `InterpCx` instead.\n     pub fn get_bytes_mut(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -297,6 +301,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n+    ///\n+    /// Most likely, you want to call `Memory::read_c_str` instead of this method.\n     pub fn read_c_str(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -342,33 +348,22 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `Memory::write_bytes` instead of this method.\n     pub fn write_bytes(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        src: &[u8],\n+        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n     ) -> InterpResult<'tcx>\n     {\n+        let mut src = src.into_iter();\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n-        bytes.clone_from_slice(src);\n-        Ok(())\n-    }\n-\n-    /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    pub fn write_repeat(\n-        &mut self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        val: u8,\n-        count: Size\n-    ) -> InterpResult<'tcx>\n-    {\n-        let bytes = self.get_bytes_mut(cx, ptr, count)?;\n-        for b in bytes {\n-            *b = val;\n+        // `zip` would stop when the first iterator ends; we want to definitely\n+        // cover all of `bytes`.\n+        for dest in bytes {\n+            *dest = src.next().expect(\"iterator was shorter than it said it would be\");\n         }\n+        src.next().expect_none(\"iterator was longer than it said it would be\");\n         Ok(())\n     }\n \n@@ -380,6 +375,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n     pub fn read_scalar(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -418,6 +414,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n     pub fn read_ptr_sized(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -435,6 +432,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -477,6 +475,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Writes a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n     pub fn write_ptr_sized(\n         &mut self,\n         cx: &impl HasDataLayout,"}, {"sha": "ac16b8b884c450f9b51b8729e2c051087d056b84", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -5,11 +5,12 @@ use rustc_apfloat::{Float, ieee::{Double, Single}};\n use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n+use crate::ty::{BoundVar, DebruijnIndex};\n \n use super::{InterpResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n /// Represents the result of a raw const operation, pre-validation.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n+#[derive(Clone, HashStable)]\n pub struct RawConst<'tcx> {\n     // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n@@ -28,6 +29,9 @@ pub enum ConstValue<'tcx> {\n     /// Infer the value of the const.\n     Infer(InferConst<'tcx>),\n \n+    /// Bound const variable, used only when preparing a trait query.\n+    Bound(DebruijnIndex, BoundVar),\n+\n     /// A placeholder const - universally quantified higher-ranked const.\n     Placeholder(PlaceholderConst),\n \n@@ -66,8 +70,9 @@ impl<'tcx> ConstValue<'tcx> {\n         match *self {\n             ConstValue::Param(_) |\n             ConstValue::Infer(_) |\n+            ConstValue::Bound(..) |\n             ConstValue::Placeholder(_) |\n-            ConstValue::ByRef{ .. } |\n+            ConstValue::ByRef { .. } |\n             ConstValue::Unevaluated(..) |\n             ConstValue::Slice { .. } => None,\n             ConstValue::Scalar(val) => Some(val),\n@@ -487,7 +492,7 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n     Scalar(Scalar<Tag, Id>),\n     Undef,"}, {"sha": "ccf64c51e133041167bd61955d1195720d42fe09", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -468,7 +468,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n /// Most passes can work with it as a whole, within a single function.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceInfo {\n     /// The source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -608,7 +608,7 @@ pub enum LocalKind {\n     ReturnPointer,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VarBindingForm<'tcx> {\n     /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n     pub binding_mode: ty::BindingMode,\n@@ -630,7 +630,7 @@ pub struct VarBindingForm<'tcx> {\n     pub pat_span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum BindingForm<'tcx> {\n     /// This is a binding for a non-`self` binding, or a `self` that has an explicit type.\n     Var(VarBindingForm<'tcx>),\n@@ -641,7 +641,7 @@ pub enum BindingForm<'tcx> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -2392,7 +2392,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n \n@@ -2438,7 +2438,7 @@ pub struct Constant<'tcx> {\n /// The first will lead to the constraint `w: &'1 str` (for some\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserTypeProjections {\n     pub(crate) contents: Vec<(UserTypeProjection, Span)>,\n }\n@@ -2515,7 +2515,7 @@ impl<'tcx> UserTypeProjections {\n /// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionKind>,\n@@ -2724,7 +2724,7 @@ impl Location {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n@@ -2733,15 +2733,15 @@ pub enum UnsafetyViolationKind {\n     BorrowPacked(hir::HirId),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub description: InternedString,\n     pub details: InternedString,\n     pub kind: UnsafetyViolationKind,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n     /// Violations that are propagated *upwards* from this function.\n     pub violations: Lrc<[UnsafetyViolation]>,"}, {"sha": "eeb997d75ca55c084f32ebef7ad7917e1b99eca4", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -15,7 +15,7 @@ use std::fmt;\n use std::hash::Hash;\n \n /// Describes how a monomorphization will be instantiated in object files.\n-#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+#[derive(PartialEq)]\n pub enum InstantiationMode {\n     /// There will be exactly one instance of the given MonoItem. It will have\n     /// external linkage so that it can be linked to from other codegen units.\n@@ -251,7 +251,7 @@ pub struct CodegenUnit<'tcx> {\n     size_estimate: Option<usize>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum Linkage {\n     External,\n     AvailableExternally,\n@@ -280,7 +280,7 @@ impl_stable_hash_for!(enum self::Linkage {\n     Common\n });\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Visibility {\n     Default,\n     Hidden,"}, {"sha": "427540d72758e257f263cfcb57dd6212f0837034", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -947,7 +947,7 @@ impl<'tcx> MirVisitable<'tcx> for Option<Terminator<'tcx>> {\n \n /// Extra information passed to `visit_ty` and friends to give context\n /// about where the type etc appears.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug)]\n pub enum TyContext {\n     LocalDecl {\n         /// The index of the local variable we are visiting."}, {"sha": "2446d4f4788df8035ab8d7cd41b892678d7b1243", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 67, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -7,24 +7,19 @@ use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::sync::Lrc;\n \n use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n \n use syntax;\n-use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n+use syntax::ast::{self, IntTy, UintTy};\n use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n-use syntax::parse::new_parser_from_source_str;\n-use syntax::parse::token;\n-use syntax::sess::ParseSess;\n use syntax::symbol::{sym, Symbol};\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::source_map::SourceMap;\n \n use errors::emitter::HumanReadableErrorType;\n-use errors::{ColorConfig, FatalError, Handler, SourceMapperDyn};\n+use errors::{ColorConfig, FatalError, Handler};\n \n use getopts;\n \n@@ -67,7 +62,7 @@ impl_stable_hash_via_hash!(OptLevel);\n \n /// This is what the `LtoCli` values get mapped to after resolving defaults and\n /// and taking other command line options into account.\n-#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+#[derive(Clone, PartialEq)]\n pub enum Lto {\n     /// Don't do any LTO whatsoever\n     No,\n@@ -301,10 +296,10 @@ impl OutputTypes {\n /// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n /// *Do not* switch `BTreeMap` or `BTreeSet` out for an unsorted container type! That\n /// would break dependency tracking for command-line arguments.\n-#[derive(Clone, Hash)]\n+#[derive(Clone)]\n pub struct Externs(BTreeMap<String, ExternEntry>);\n \n-#[derive(Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug, Default)]\n+#[derive(Clone, Debug, Default)]\n pub struct ExternEntry {\n     pub locations: BTreeSet<Option<String>>,\n     pub is_private_dep: bool\n@@ -464,7 +459,7 @@ pub enum PrintRequest {\n     NativeStaticLibs,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Copy, Clone)]\n pub enum BorrowckMode {\n     Mir,\n     Migrate,\n@@ -1854,59 +1849,6 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     opts\n }\n \n-struct NullEmitter;\n-\n-impl errors::emitter::Emitter for NullEmitter {\n-    fn emit_diagnostic(&mut self, _: &errors::Diagnostic) {}\n-    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> { None }\n-}\n-\n-// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n-pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n-    syntax::with_default_globals(move || {\n-        let cfg = cfgspecs.into_iter().map(|s| {\n-\n-            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let handler = Handler::with_emitter(false, None, Box::new(NullEmitter));\n-            let sess = ParseSess::with_span_handler(handler, cm);\n-            let filename = FileName::cfg_spec_source_code(&s);\n-            let mut parser = new_parser_from_source_str(&sess, filename, s.to_string());\n-\n-            macro_rules! error {($reason: expr) => {\n-                early_error(ErrorOutputType::default(),\n-                            &format!(concat!(\"invalid `--cfg` argument: `{}` (\", $reason, \")\"), s));\n-            }}\n-\n-            match &mut parser.parse_meta_item() {\n-                Ok(meta_item) if parser.token == token::Eof => {\n-                    if meta_item.path.segments.len() != 1 {\n-                        error!(\"argument key must be an identifier\");\n-                    }\n-                    match &meta_item.kind {\n-                        MetaItemKind::List(..) => {\n-                            error!(r#\"expected `key` or `key=\"value\"`\"#);\n-                        }\n-                        MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n-                            error!(\"argument value must be a string\");\n-                        }\n-                        MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n-                            let ident = meta_item.ident().expect(\"multi-segment cfg key\");\n-                            return (ident.name, meta_item.value_str());\n-                        }\n-                    }\n-                }\n-                Ok(..) => {}\n-                Err(err) => err.cancel(),\n-            }\n-\n-            error!(r#\"expected `key` or `key=\"value\"`\"#);\n-        }).collect::<ast::CrateConfig>();\n-        cfg.into_iter().map(|(a, b)| {\n-            (a.to_string(), b.map(|b| b.to_string()))\n-        }).collect()\n-    })\n-}\n-\n pub fn get_cmd_lint_options(matches: &getopts::Matches,\n                             error_format: ErrorOutputType)\n                             -> (Vec<(String, lint::Level)>, bool, Option<lint::Level>) {\n@@ -2877,6 +2819,3 @@ mod dep_tracking {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "949dad751a101f69c3d1a8c9cddedc14df31f507", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,5 +1,4 @@\n use std::path::{Path, PathBuf};\n-use rustc_macros::HashStable;\n use crate::session::{early_error, config};\n use crate::session::filesearch::make_target_lib_path;\n \n@@ -10,7 +9,7 @@ pub struct SearchPath {\n     pub files: Vec<PathBuf>,\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash, HashStable)]\n+#[derive(PartialEq, Clone, Copy, Debug, HashStable)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "f6ea77dc5cc684562944f209750988f6cbcd7135", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -40,7 +40,7 @@ pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::normalize::Normalize<T>>>;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug)]\n pub struct NoSolution;\n \n pub type Fallible<T> = Result<T, NoSolution>;"}, {"sha": "7aa98703411b28e2881a5b962d448160e393055c", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -3,7 +3,7 @@ use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Clone, Debug)]\n pub struct ImpliedOutlivesBounds<'tcx> {\n     pub ty: Ty<'tcx>,\n }"}, {"sha": "5570144489cdf315bfb783698df01ab386adab05", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -2,7 +2,7 @@ use crate::hir::BindingAnnotation::*;\n use crate::hir::BindingAnnotation;\n use crate::hir::Mutability;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BindingMode {\n     BindByReference(Mutability),\n     BindByValue(Mutability),"}, {"sha": "d118bef37fc119e79475dbaedae51bd3fb0a4455", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -827,7 +827,7 @@ rustc_index::newtype_index! {\n pub type CanonicalUserTypeAnnotations<'tcx> =\n     IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct CanonicalUserTypeAnnotation<'tcx> {\n     pub user_ty: CanonicalUserType<'tcx>,\n     pub span: Span,\n@@ -882,7 +882,7 @@ impl CanonicalUserType<'tcx> {\n                         },\n \n                         GenericArgKind::Const(ct) => match ct.val {\n-                            ConstValue::Infer(InferConst::Canonical(debruijn, b)) => {\n+                            ConstValue::Bound(debruijn, b) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(debruijn, ty::INNERMOST);\n                                 cvar == b\n@@ -899,7 +899,7 @@ impl CanonicalUserType<'tcx> {\n /// A user-given type annotation attached to a constant. These arise\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n "}, {"sha": "3395715f67ff98424a8d4874629ec76be93f1c17", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -51,7 +51,6 @@ pub enum TypeError<'tcx> {\n     IntrinsicCast,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum UnconstrainedNumeric {\n     UnconstrainedFloat,\n     UnconstrainedInt,"}, {"sha": "27a09b394b8fa32b8923140e5ff6f2219fad90fc", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -19,7 +19,7 @@ pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n /// the non-stable but fast to construct DefId-version is the better choice.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub enum SimplifiedTypeGen<D>\n-    where D: Copy + Debug + Ord + Eq + Hash\n+    where D: Copy + Debug + Ord + Eq\n {\n     BoolSimplifiedType,\n     CharSimplifiedType,\n@@ -123,10 +123,10 @@ pub fn simplify_type(\n     }\n }\n \n-impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n+impl<D: Copy + Debug + Ord + Eq> SimplifiedTypeGen<D> {\n     pub fn map_def<U, F>(self, map: F) -> SimplifiedTypeGen<U>\n         where F: Fn(D) -> U,\n-              U: Copy + Debug + Ord + Eq + Hash,\n+              U: Copy + Debug + Ord + Eq,\n     {\n         match self {\n             BoolSimplifiedType => BoolSimplifiedType,\n@@ -155,7 +155,7 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n \n impl<'a, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n where\n-    D: Copy + Debug + Ord + Eq + Hash + HashStable<StableHashingContext<'a>>,\n+    D: Copy + Debug + Ord + Eq + HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);"}, {"sha": "cb1fb4f685de57853fa775241e1f97acaca3fd55", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -240,10 +240,10 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);\n                 match infer {\n                     InferConst::Fresh(_) => {}\n-                    InferConst::Canonical(debruijn, _) => self.add_binder(debruijn),\n                     InferConst::Var(_) => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX),\n                 }\n             }\n+            ConstValue::Bound(debruijn, _) => self.add_binder(debruijn),\n             ConstValue::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_PARAMS);\n             }"}, {"sha": "bacf3d42f043130fd47b040df8f40720ba5710a9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -88,6 +88,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n+    fn has_infer_consts(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_CT_INFER)\n+    }\n     fn has_local_value(&self) -> bool {\n         self.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n     }\n@@ -518,10 +521,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const {\n-            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n-            ty,\n-        } = *ct {\n+        if let ty::Const { val: ConstValue::Bound(debruijn, bound_const), ty } = *ct {\n             if debruijn == self.current_index {\n                 let fld_c = &mut self.fld_c;\n                 let ct = fld_c(bound_const, ty);\n@@ -567,7 +567,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         // identity for bound types and consts\n         let fld_t = |bound_ty| self.mk_ty(ty::Bound(ty::INNERMOST, bound_ty));\n         let fld_c = |bound_ct, ty| {\n-            self.mk_const_infer(ty::InferConst::Canonical(ty::INNERMOST, bound_ct), ty)\n+            self.mk_const(ty::Const {\n+                val: ConstValue::Bound(ty::INNERMOST, bound_ct),\n+                ty,\n+            })\n         };\n         self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n@@ -718,7 +721,6 @@ impl<'tcx> TyCtxt<'tcx> {\n // vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n enum Direction {\n     In,\n     Out,\n@@ -799,10 +801,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const {\n-            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n-            ty,\n-        } = *ct {\n+        if let ty::Const { val: ConstValue::Bound(debruijn, bound_ct), ty } = *ct {\n             if self.amount == 0 || debruijn < self.current_index {\n                 ct\n             } else {\n@@ -813,7 +812,10 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                         debruijn.shifted_out(self.amount)\n                     }\n                 };\n-                self.tcx.mk_const_infer(ty::InferConst::Canonical(debruijn, bound_const), ty)\n+                self.tcx.mk_const(ty::Const {\n+                    val: ConstValue::Bound(debruijn, bound_ct),\n+                    ty,\n+                })\n             }\n         } else {\n             ct.super_fold_with(self)\n@@ -917,8 +919,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         // const, as it has types/regions embedded in a lot of other\n         // places.\n         match ct.val {\n-            ConstValue::Infer(ty::InferConst::Canonical(debruijn, _))\n-                if debruijn >= self.outer_index => true,\n+            ConstValue::Bound(debruijn, _) if debruijn >= self.outer_index => true,\n             _ => ct.super_visit_with(self),\n         }\n     }"}, {"sha": "d377b7328e80b1d2a4e8f4b2b8c2d3f7201a95e5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -159,7 +159,7 @@ impl AssocItemContainer {\n /// The \"header\" of an impl is everything outside the body: a Self type, a trait\n /// ref (in the case of a trait impl), and a set of predicates (from the\n /// bounds / where-clauses).\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Debug)]\n pub struct ImplHeader<'tcx> {\n     pub impl_def_id: DefId,\n     pub self_ty: Ty<'tcx>,\n@@ -195,7 +195,7 @@ pub struct AssocItem {\n     pub method_has_self_argument: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable)]\n pub enum AssocKind {\n     Const,\n     Method,\n@@ -331,7 +331,7 @@ impl Visibility {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcDecodable, RustcEncodable, HashStable)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n@@ -752,7 +752,7 @@ pub struct UpvarId {\n     pub closure_expr_id: LocalDefId,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy, HashStable)]\n+#[derive(Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,"}, {"sha": "f61801cd23276b86e2be67ba2751b7a46310bbaf", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -8,14 +8,12 @@ use crate::ty::subst::SubstsRef;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::mir;\n \n-use std::fmt::Debug;\n-use std::hash::Hash;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::symbol::InternedString;\n \n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n-pub(super) trait Key: Clone + Hash + Eq + Debug {\n+pub(super) trait Key {\n     /// Given an instance of this key, what crate is it referring to?\n     /// This is used to find the provider.\n     fn query_crate(&self) -> CrateNum;\n@@ -201,10 +199,7 @@ impl Key for InternedString {\n \n /// Canonical query goals correspond to abstract trait operations that\n /// are not tied to any crate in particular.\n-impl<'tcx, T> Key for Canonical<'tcx, T>\n-where\n-    T: Debug + Hash + Clone + Eq,\n-{\n+impl<'tcx, T> Key for Canonical<'tcx, T> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "41b4883793b5414c8c4f319814abd84c62192f6e", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -801,7 +801,7 @@ macro_rules! define_queries_inner {\n         }\n \n         #[allow(nonstandard_style)]\n-        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+        #[derive(Clone, Copy)]\n         pub enum QueryName {\n             $($name),*\n         }\n@@ -819,7 +819,7 @@ macro_rules! define_queries_inner {\n         }\n \n         #[allow(nonstandard_style)]\n-        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+        #[derive(Clone, Debug)]\n         pub enum Query<$tcx> {\n             $($(#[$attr])* $name($K)),*\n         }"}, {"sha": "6b1f10bdb21c46f9ed84308ee122f76ba2594243", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1379,27 +1379,23 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstValue::ByRef { alloc, offset } =>\n-                ConstValue::ByRef { alloc, offset },\n             ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n-            ConstValue::Placeholder(p) => ConstValue::Placeholder(p),\n-            ConstValue::Scalar(a) => ConstValue::Scalar(a),\n-            ConstValue::Slice { data, start, end } => ConstValue::Slice { data, start, end },\n             ConstValue::Unevaluated(did, substs)\n                 => ConstValue::Unevaluated(did, substs.fold_with(folder)),\n+            ConstValue::ByRef { .. } | ConstValue::Bound(..) | ConstValue::Placeholder(..)\n+            | ConstValue::Scalar(..) | ConstValue::Slice { .. } => *self,\n+\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ConstValue::ByRef { .. } => false,\n             ConstValue::Infer(ic) => ic.visit_with(visitor),\n             ConstValue::Param(p) => p.visit_with(visitor),\n-            ConstValue::Placeholder(_) => false,\n-            ConstValue::Scalar(_) => false,\n-            ConstValue::Slice { .. } => false,\n             ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n+            ConstValue::ByRef { .. } | ConstValue::Bound(..) | ConstValue::Placeholder(_)\n+            | ConstValue::Scalar(_) | ConstValue::Slice { .. } => false,\n         }\n     }\n }"}, {"sha": "298e798959635ef5c7275a768f4d6d02c5677052", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -304,8 +304,7 @@ static_assert_size!(TyKind<'_>, 24);\n /// type parameters is similar, but the role of CK and CS are\n /// different. CK represents the \"yield type\" and CS represents the\n /// \"return type\" of the generator.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n-         RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with the types of the upvars.\n@@ -392,8 +391,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n }\n \n /// Similar to `ClosureSubsts`; see the above documentation for more.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n-         RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug)]\n pub struct GeneratorSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n@@ -1035,7 +1033,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug)]\n pub struct GenSig<'tcx> {\n     pub yield_ty: Ty<'tcx>,\n     pub return_ty: Ty<'tcx>,\n@@ -2373,6 +2371,4 @@ pub enum InferConst<'tcx> {\n     Var(ConstVid<'tcx>),\n     /// A fresh const variable. See `infer::freshen` for more details.\n     Fresh(u32),\n-    /// Canonicalized const variable, used only when preparing a trait query.\n-    Canonical(DebruijnIndex, BoundVar),\n }"}, {"sha": "29721979099d59e0c7635b92f5a8d3a936e6cf19", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -2,7 +2,7 @@\n \n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::ty::{self, Lift, List, Ty, TyCtxt, InferConst, ParamConst};\n+use crate::ty::{self, Lift, List, Ty, TyCtxt, ParamConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::mir::interpret::ConstValue;\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n@@ -234,9 +234,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n \n                 ty::GenericParamDefKind::Const => {\n                     tcx.mk_const(ty::Const {\n-                        val: ConstValue::Infer(\n-                            InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from(param.index))\n-                        ),\n+                        val: ConstValue::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n                         ty: tcx.type_of(def_id),\n                     }).into()\n                 }"}, {"sha": "5555dace45bfa63e750d01875875fc367ad86f2d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -818,6 +818,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     ///\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n+    ///\n+    /// Note that this method is used to check eligible types in unions.\n     #[inline]\n     pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx.needs_drop_raw(param_env.and(self)).0"}, {"sha": "867bbd22cfbbb1246fa71b32c133979b7f3d69d2", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -12,9 +12,3 @@ test = false\n \n [dependencies]\n rustc_llvm = { path = \"../librustc_llvm\" }\n-\n-[features]\n-# This is used to convince Cargo to separately cache builds of `rustc_codegen_llvm`\n-# when this option is enabled or not. That way we can build two, cache two\n-# artifacts, and have nice speedy rebuilds.\n-emscripten = [\"rustc_llvm/emscripten\"]"}, {"sha": "b3be3d09f17da9c06748786d74244af39edfcffb", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -53,9 +53,7 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n     let symbol_filter = &|&(ref name, level): &(String, SymbolExportLevel)| {\n         if level.is_below_threshold(export_threshold) {\n-            let mut bytes = Vec::with_capacity(name.len() + 1);\n-            bytes.extend(name.bytes());\n-            Some(CString::new(bytes).unwrap())\n+            Some(CString::new(name.as_str()).unwrap())\n         } else {\n             None\n         }"}, {"sha": "7bd82ced3c386f7f777bc4897bbb5fe660320698", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -2069,11 +2069,9 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, 'tcx>,\n     {\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n-        if composite_types_completed.contains(&composite_type_metadata) {\n+        if !composite_types_completed.insert(&composite_type_metadata) {\n             bug!(\"debuginfo::set_members_of_composite_type() - \\\n                   Already completed forward declaration re-encountered.\");\n-        } else {\n-            composite_types_completed.insert(composite_type_metadata);\n         }\n     }\n "}, {"sha": "c69942ef3f2d52fd18c0c3abdc49c153212a5d04", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -50,7 +50,7 @@ pub enum CallConv {\n }\n \n /// LLVMRustLinkage\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq)]\n #[repr(C)]\n pub enum Linkage {\n     ExternalLinkage = 0,\n@@ -67,7 +67,6 @@ pub enum Linkage {\n }\n \n // LLVMRustVisibility\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n #[repr(C)]\n pub enum Visibility {\n     Default = 0,"}, {"sha": "ba5e47aeede1b36f8a355f8309848f7c53f82e48", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -79,6 +79,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             ConstValue::Unevaluated(..) => bug!(\"unevaluated constant in `OperandRef::from_const`\"),\n             ConstValue::Param(_) => bug!(\"encountered a ConstValue::Param in codegen\"),\n             ConstValue::Infer(_) => bug!(\"encountered a ConstValue::Infer in codegen\"),\n+            ConstValue::Bound(..) => bug!(\"encountered a ConstValue::Bound in codegen\"),\n             ConstValue::Placeholder(_) => bug!(\"encountered a ConstValue::Placeholder in codegen\"),\n             ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {"}, {"sha": "7e662ea37dbb410bd8c203c80ece30d3bf90792b", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -556,7 +556,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Bx::Value {\n         let is_float = input_ty.is_floating_point();\n         let is_signed = input_ty.is_signed();\n-        let is_unit = input_ty.is_unit();\n         match op {\n             mir::BinOp::Add => if is_float {\n                 bx.fadd(lhs, rhs)\n@@ -594,13 +593,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::BinOp::Shl => common::build_unchecked_lshift(bx, lhs, rhs),\n             mir::BinOp::Shr => common::build_unchecked_rshift(bx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n-            mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_unit {\n-                bx.cx().const_bool(match op {\n-                    mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n-                    mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n-                    _ => unreachable!()\n-                })\n-            } else if is_float {\n+            mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_float {\n                 bx.fcmp(\n                     base::bin_op_to_fcmp_predicate(op.to_hir_binop()),\n                     lhs, rhs"}, {"sha": "9fdcea6df88c59a7a865a68d7d38051661be5a3a", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -60,10 +60,10 @@ impl<N> SnapshotVecDelegate for Edge<N> {\n     fn reverse(_: &mut Vec<Edge<N>>, _: ()) {}\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub struct NodeIndex(pub usize);\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub struct EdgeIndex(pub usize);\n \n pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);"}, {"sha": "2f972eeccdcbd2494477483ea16c3ba14abf4b8d", "filename": "src/librustc_data_structures/sharded.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -90,7 +90,7 @@ impl<T> Sharded<T> {\n \n pub type ShardedHashMap<K, V> = Sharded<FxHashMap<K, V>>;\n \n-impl<K: Eq + Hash, V> ShardedHashMap<K, V> {\n+impl<K: Eq, V> ShardedHashMap<K, V> {\n     pub fn len(&self) -> usize {\n         self.lock_shards().iter().map(|shard| shard.len()).sum()\n     }"}, {"sha": "bdd3dc9665629a5af94a362ce3b08b53c24f110e", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -7,7 +7,7 @@ use std::mem;\n mod tests;\n \n pub struct SnapshotMap<K, V>\n-    where K: Hash + Clone + Eq\n+    where K: Clone + Eq\n {\n     map: FxHashMap<K, V>,\n     undo_log: Vec<UndoLog<K, V>>,"}, {"sha": "092208cfe1db74d6c3ff2ed525d6f31f3042ced1", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -169,7 +169,7 @@ pub trait HashStable<CTX> {\n /// example, for DefId that can be converted to a DefPathHash. This is used for\n /// bringing maps into a predictable order before hashing them.\n pub trait ToStableHashKey<HCX> {\n-    type KeyType: Ord + Clone + Sized + HashStable<HCX>;\n+    type KeyType: Ord + Sized + HashStable<HCX>;\n     fn to_stable_hash_key(&self, hcx: &HCX) -> Self::KeyType;\n }\n \n@@ -460,7 +460,7 @@ impl_stable_hash_via_hash!(::std::path::Path);\n impl_stable_hash_via_hash!(::std::path::PathBuf);\n \n impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n-    where K: ToStableHashKey<HCX> + Eq + Hash,\n+    where K: ToStableHashKey<HCX> + Eq,\n           V: HashStable<HCX>,\n           R: BuildHasher,\n {\n@@ -471,7 +471,7 @@ impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n }\n \n impl<K, R, HCX> HashStable<HCX> for ::std::collections::HashSet<K, R>\n-    where K: ToStableHashKey<HCX> + Eq + Hash,\n+    where K: ToStableHashKey<HCX> + Eq,\n           R: BuildHasher,\n {\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n@@ -513,10 +513,10 @@ pub fn hash_stable_hashmap<HCX, K, V, R, SK, F>(\n     hasher: &mut StableHasher,\n     map: &::std::collections::HashMap<K, V, R>,\n     to_stable_hash_key: F)\n-    where K: Eq + Hash,\n+    where K: Eq,\n           V: HashStable<HCX>,\n           R: BuildHasher,\n-          SK: HashStable<HCX> + Ord + Clone,\n+          SK: HashStable<HCX> + Ord,\n           F: Fn(&K, &HCX) -> SK,\n {\n     let mut entries: Vec<_> = map.iter()"}, {"sha": "f09474ff4d344a8c37f801b09cd9b2de1f42d60a", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -738,7 +738,7 @@ impl<T: Clone> Clone for RwLock<T> {\n \n /// A type which only allows its inner value to be used in one thread.\n /// It will panic if it is used on multiple threads.\n-#[derive(Copy, Clone, Hash, Debug, Eq, PartialEq)]\n+#[derive(Debug)]\n pub struct OneThread<T> {\n     #[cfg(parallel_compiler)]\n     thread: thread::ThreadId,"}, {"sha": "d97da489db8df88d11bc900dda5c8d2f51796a37", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -3,7 +3,7 @@ use crate::stable_hasher::{StableHasher, HashStable};\n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ThinVec<T>(Option<Box<Vec<T>>>);\n \n impl<T> ThinVec<T> {"}, {"sha": "371f0f6fa0b4482eb35b3d4c5ddf3c2b832027d3", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -14,7 +14,7 @@\n #[cfg(test)]\n mod tests;\n \n-#[derive(Clone, Hash, Debug, PartialEq)]\n+#[derive(Clone)]\n pub struct TinyList<T: PartialEq> {\n     head: Option<Element<T>>\n }\n@@ -80,7 +80,7 @@ impl<T: PartialEq> TinyList<T> {\n     }\n }\n \n-#[derive(Clone, Hash, Debug, PartialEq)]\n+#[derive(Clone)]\n struct Element<T: PartialEq> {\n     data: T,\n     next: Option<Box<Element<T>>>,"}, {"sha": "a3926c15551728c996aff3b75d3a1abd0eb3093a", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -11,7 +11,7 @@ use std::mem;\n mod tests;\n \n #[derive(Clone, Debug)]\n-pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n+pub struct TransitiveRelation<T: Eq + Hash> {\n     // List of elements. This is used to map from a T to a usize.\n     elements: Vec<T>,\n \n@@ -35,7 +35,7 @@ pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n }\n \n // HACK(eddyb) manual impl avoids `Default` bound on `T`.\n-impl<T: Clone + Debug + Eq + Hash> Default for TransitiveRelation<T> {\n+impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n     fn default() -> Self {\n         TransitiveRelation {\n             elements: Default::default(),\n@@ -46,7 +46,7 @@ impl<T: Clone + Debug + Eq + Hash> Default for TransitiveRelation<T> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, RustcEncodable, RustcDecodable, Debug)]\n struct Index(usize);\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "bfcbec8b78f3773493df44b4edab3fda7bd08b96", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -167,7 +167,7 @@ pub fn run_compiler(\n     };\n \n     let sopts = config::build_session_options(&matches);\n-    let cfg = config::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n+    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n \n     let mut dummy_config = |sopts, cfg, diagnostic_output| {\n         let mut config = interface::Config {"}, {"sha": "e3b55a141338a60bdbfef580bf6ae048115a0b94", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -12,7 +12,7 @@ use Destination::*;\n use syntax_pos::{SourceFile, Span, MultiSpan};\n \n use crate::{\n-    Level, CodeSuggestion, Diagnostic, SubDiagnostic,\n+    Level, CodeSuggestion, Diagnostic, SubDiagnostic, pluralise,\n     SuggestionStyle, SourceMapper, SourceMapperDyn, DiagnosticId,\n };\n use crate::Level::Error;\n@@ -1572,7 +1572,8 @@ impl EmitterWriter {\n             }\n         }\n         if suggestions.len() > MAX_SUGGESTIONS {\n-            let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n+            let others = suggestions.len() - MAX_SUGGESTIONS;\n+            let msg = format!(\"and {} other candidate{}\", others, pluralise!(others));\n             buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n         } else if notice_capitalization {\n             let msg = \"notice the capitalization difference\";"}, {"sha": "0d8d765a572c29d78f87bc875d319345b54680d5", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -27,6 +27,7 @@ rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_passes = { path = \"../librustc_passes\" }\n+rustc_target = { path = \"../librustc_target\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "5e1ad3e61dd185040f3f12b23766997715fc4173", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -3,7 +3,8 @@ use crate::util;\n pub use crate::passes::BoxedResolver;\n \n use rustc::lint;\n-use rustc::session::config::{self, Input};\n+use rustc::session::early_error;\n+use rustc::session::config::{self, Input, ErrorOutputType};\n use rustc::session::{DiagnosticOutput, Session};\n use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -14,9 +15,13 @@ use rustc_metadata::cstore::CStore;\n use std::path::PathBuf;\n use std::result;\n use std::sync::{Arc, Mutex};\n-use syntax;\n-use syntax::source_map::{FileLoader, SourceMap};\n+use syntax::{self, parse};\n+use syntax::ast::{self, MetaItemKind};\n+use syntax::parse::token;\n+use syntax::source_map::{FileName, FilePathMapping, FileLoader, SourceMap};\n+use syntax::sess::ParseSess;\n use syntax_pos::edition;\n+use rustc_errors::{Diagnostic, emitter::Emitter, Handler, SourceMapperDyn};\n \n pub type Result<T> = result::Result<T, ErrorReported>;\n \n@@ -60,6 +65,58 @@ impl Compiler {\n     }\n }\n \n+/// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n+pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n+    struct NullEmitter;\n+    impl Emitter for NullEmitter {\n+        fn emit_diagnostic(&mut self, _: &Diagnostic) {}\n+        fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> { None }\n+    }\n+\n+    syntax::with_default_globals(move || {\n+        let cfg = cfgspecs.into_iter().map(|s| {\n+\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+            let handler = Handler::with_emitter(false, None, Box::new(NullEmitter));\n+            let sess = ParseSess::with_span_handler(handler, cm);\n+            let filename = FileName::cfg_spec_source_code(&s);\n+            let mut parser = parse::new_parser_from_source_str(&sess, filename, s.to_string());\n+\n+            macro_rules! error {($reason: expr) => {\n+                early_error(ErrorOutputType::default(),\n+                            &format!(concat!(\"invalid `--cfg` argument: `{}` (\", $reason, \")\"), s));\n+            }}\n+\n+            match &mut parser.parse_meta_item() {\n+                Ok(meta_item) if parser.token == token::Eof => {\n+                    if meta_item.path.segments.len() != 1 {\n+                        error!(\"argument key must be an identifier\");\n+                    }\n+                    match &meta_item.kind {\n+                        MetaItemKind::List(..) => {\n+                            error!(r#\"expected `key` or `key=\"value\"`\"#);\n+                        }\n+                        MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n+                            error!(\"argument value must be a string\");\n+                        }\n+                        MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n+                            let ident = meta_item.ident().expect(\"multi-segment cfg key\");\n+                            return (ident.name, meta_item.value_str());\n+                        }\n+                    }\n+                }\n+                Ok(..) => {}\n+                Err(err) => err.cancel(),\n+            }\n+\n+            error!(r#\"expected `key` or `key=\"value\"`\"#);\n+        }).collect::<ast::CrateConfig>();\n+        cfg.into_iter().map(|(a, b)| {\n+            (a.to_string(), b.map(|b| b.to_string()))\n+        }).collect()\n+    })\n+}\n+\n /// The compiler configuration\n pub struct Config {\n     /// Command line options"}, {"sha": "53baf6556fb5bdb4abff7bcebef08a7c17227a38", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -18,3 +18,6 @@ pub mod util;\n mod proc_macro_decls;\n \n pub use interface::{run_compiler, Config};\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "7a57605da58b82974c7d2ffa5fa1f917af22919c", "filename": "src/librustc_interface/tests.rs", "status": "renamed", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,25 +1,24 @@\n-use getopts;\n-use crate::lint;\n-use crate::middle::cstore;\n-use crate::session::config::{\n-    build_configuration,\n-    build_session_options,\n-    to_crate_config,\n-    parse_cfgspecs,\n-};\n-use crate::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n-use crate::session::build_session;\n-use crate::session::search_paths::SearchPath;\n+extern crate getopts;\n+\n+use crate::interface::parse_cfgspecs;\n+\n+use rustc::lint;\n+use rustc::middle::cstore;\n+use rustc::session::config::{build_configuration, build_session_options, to_crate_config};\n+use rustc::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n+use rustc::session::config::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n+use rustc::session::config::{rustc_optgroups, Options, ErrorOutputType, Passes};\n+use rustc::session::build_session;\n+use rustc::session::search_paths::SearchPath;\n use std::collections::{BTreeMap, BTreeSet};\n use std::iter::FromIterator;\n use std::path::PathBuf;\n-use super::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n use syntax::symbol::sym;\n use syntax::edition::{Edition, DEFAULT_EDITION};\n use syntax;\n-use super::Options;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::{ColorConfig, emitter::HumanReadableErrorType, registry};\n \n pub fn build_session_options_and_crate_config(\n     matches: &getopts::Matches,\n@@ -30,22 +29,23 @@ pub fn build_session_options_and_crate_config(\n     )\n }\n \n-impl ExternEntry {\n-    fn new_public<S: Into<String>,\n-                  I: IntoIterator<Item = Option<S>>>(locations: I) -> ExternEntry {\n-        let locations: BTreeSet<_> = locations.into_iter().map(|o| o.map(|s| s.into()))\n-            .collect();\n-\n-        ExternEntry {\n-            locations,\n-            is_private_dep: false\n-        }\n+fn new_public_extern_entry<S, I>(locations: I) -> ExternEntry\n+where\n+    S: Into<String>,\n+    I: IntoIterator<Item = Option<S>>,\n+{\n+    let locations: BTreeSet<_> = locations.into_iter().map(|o| o.map(|s| s.into()))\n+        .collect();\n+\n+    ExternEntry {\n+        locations,\n+        is_private_dep: false\n     }\n }\n \n fn optgroups() -> getopts::Options {\n     let mut opts = getopts::Options::new();\n-    for group in super::rustc_optgroups() {\n+    for group in rustc_optgroups() {\n         (group.apply)(&mut opts);\n     }\n     return opts;\n@@ -63,7 +63,7 @@ fn test_switch_implies_cfg_test() {\n             Ok(m) => m,\n             Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f),\n         };\n-        let registry = errors::registry::Registry::new(&[]);\n+        let registry = registry::Registry::new(&[]);\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess, to_crate_config(cfg));\n@@ -81,7 +81,7 @@ fn test_switch_implies_cfg_test_unless_cfg_test() {\n             Ok(m) => m,\n             Err(f) => panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f),\n         };\n-        let registry = errors::registry::Registry::new(&[]);\n+        let registry = registry::Registry::new(&[]);\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess, to_crate_config(cfg));\n@@ -95,7 +95,7 @@ fn test_switch_implies_cfg_test_unless_cfg_test() {\n fn test_can_print_warnings() {\n     syntax::with_default_globals(|| {\n         let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n-        let registry = errors::registry::Registry::new(&[]);\n+        let registry = registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n         assert!(!sess.diagnostic().can_emit_warnings());\n@@ -105,15 +105,15 @@ fn test_can_print_warnings() {\n         let matches = optgroups()\n             .parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()])\n             .unwrap();\n-        let registry = errors::registry::Registry::new(&[]);\n+        let registry = registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n         assert!(sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n         let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n-        let registry = errors::registry::Registry::new(&[]);\n+        let registry = registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n         assert!(sess.diagnostic().can_emit_warnings());\n@@ -172,33 +172,33 @@ fn test_externs_tracking_hash_different_construction_order() {\n     v1.externs = Externs::new(mk_map(vec![\n         (\n             String::from(\"a\"),\n-            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+            new_public_extern_entry(vec![Some(\"b\"), Some(\"c\")])\n         ),\n         (\n             String::from(\"d\"),\n-            ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n+            new_public_extern_entry(vec![Some(\"e\"), Some(\"f\")])\n         ),\n     ]));\n \n     v2.externs = Externs::new(mk_map(vec![\n         (\n             String::from(\"d\"),\n-            ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n+            new_public_extern_entry(vec![Some(\"e\"), Some(\"f\")])\n         ),\n         (\n             String::from(\"a\"),\n-            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+            new_public_extern_entry(vec![Some(\"b\"), Some(\"c\")])\n         ),\n     ]));\n \n     v3.externs = Externs::new(mk_map(vec![\n         (\n             String::from(\"a\"),\n-            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+            new_public_extern_entry(vec![Some(\"b\"), Some(\"c\")])\n         ),\n         (\n             String::from(\"d\"),\n-            ExternEntry::new_public(vec![Some(\"f\"), Some(\"e\")])\n+            new_public_extern_entry(vec![Some(\"f\"), Some(\"e\")])\n         ),\n     ]));\n \n@@ -282,9 +282,9 @@ fn test_search_paths_tracking_hash_different_order() {\n     let mut v3 = Options::default();\n     let mut v4 = Options::default();\n \n-    const JSON: super::ErrorOutputType = super::ErrorOutputType::Json {\n+    const JSON: ErrorOutputType = ErrorOutputType::Json {\n         pretty: false,\n-        json_rendered: super::HumanReadableErrorType::Default(super::ColorConfig::Never),\n+        json_rendered: HumanReadableErrorType::Default(ColorConfig::Never),\n     };\n \n     // Reference\n@@ -455,7 +455,7 @@ fn test_codegen_options_tracking_hash() {\n     opts.cg.codegen_units = Some(42);\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n-    opts.cg.remark = super::Passes::Some(vec![String::from(\"pass1\"), String::from(\"pass2\")]);\n+    opts.cg.remark = Passes::Some(vec![String::from(\"pass1\"), String::from(\"pass2\")]);\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n     opts.cg.save_temps = true;", "previous_filename": "src/librustc/session/config/tests.rs"}, {"sha": "5d9a97cc21eefe2302b82deec42e768e892e00ae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -980,35 +980,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     }\n }\n \n-declare_lint! {\n-    UNIONS_WITH_DROP_FIELDS,\n-    Warn,\n-    \"use of unions that contain fields with possibly non-trivial drop code\"\n-}\n-\n-declare_lint_pass!(\n-    /// Lint for unions that contain fields with possibly non-trivial destructors.\n-    UnionsWithDropFields => [UNIONS_WITH_DROP_FIELDS]\n-);\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n-    fn check_item(&mut self, ctx: &LateContext<'_, '_>, item: &hir::Item) {\n-        if let hir::ItemKind::Union(ref vdata, _) = item.kind {\n-            for field in vdata.fields() {\n-                let field_ty = ctx.tcx.type_of(\n-                    ctx.tcx.hir().local_def_id(field.hir_id));\n-                if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n-                    ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n-                                  field.span,\n-                                  \"union contains a field with possibly non-trivial drop code, \\\n-                                   drop code of union fields is ignored when dropping the union\");\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     pub UNREACHABLE_PUB,\n     Allow,\n@@ -1288,7 +1259,6 @@ declare_lint_pass!(\n         NO_MANGLE_GENERIC_ITEMS,\n         MUTABLE_TRANSMUTES,\n         UNSTABLE_FEATURES,\n-        UNIONS_WITH_DROP_FIELDS,\n         UNREACHABLE_PUB,\n         TYPE_ALIAS_BOUNDS,\n         TRIVIAL_BOUNDS"}, {"sha": "f83755181f82e9c37232ceff2556dcbff0e02890", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -164,9 +164,6 @@ macro_rules! late_lint_mod_passes {\n             // Depends on referenced function signatures in expressions\n             MutableTransmutes: MutableTransmutes,\n \n-            // Depends on types of fields, checks if they implement Drop\n-            UnionsWithDropFields: UnionsWithDropFields,\n-\n             TypeAliasBounds: TypeAliasBounds,\n \n             TrivialConstraints: TrivialConstraints,"}, {"sha": "7412e8a2cb9bd7f8c0cc54d44b39ce6b90eb91b0", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -738,10 +738,10 @@ impl<'a> CrateLoader<'a> {\n                 if !self.sess.crate_types.borrow().iter().all(|ct| {\n                     match *ct {\n                         // Link the runtime\n-                        config::CrateType::Staticlib |\n                         config::CrateType::Executable => true,\n                         // This crate will be compiled with the required\n                         // instrumentation pass\n+                        config::CrateType::Staticlib |\n                         config::CrateType::Rlib |\n                         config::CrateType::Dylib |\n                         config::CrateType::Cdylib =>"}, {"sha": "a58db6a903bb99f1622fce33cfeb7d42a0d981db", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -198,12 +198,10 @@ impl Collector<'tcx> {\n                     self.tcx.sess.err(&format!(\"renaming of the library `{}` was specified, \\\n                                                 however this crate contains no `#[link(...)]` \\\n                                                 attributes referencing this library.\", name));\n-                } else if renames.contains(name) {\n+                } else if !renames.insert(name) {\n                     self.tcx.sess.err(&format!(\"multiple renamings were \\\n                                                 specified for library `{}` .\",\n                                                name));\n-                } else {\n-                    renames.insert(name);\n                 }\n             }\n         }"}, {"sha": "4c469a82ac3d6b9dc1bce871165c0d47a824707a", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -78,16 +78,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 .last()\n                 .unwrap();\n \n-            if self.uninitialized_error_reported.contains(&root_place) {\n+            if !self.uninitialized_error_reported.insert(root_place) {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n                     root_place\n                 );\n                 return;\n             }\n \n-            self.uninitialized_error_reported.insert(root_place);\n-\n             let item_msg = match self.describe_place_with_options(used_place,\n                                                                   IncludingDowncast(true)) {\n                 Some(name) => format!(\"`{}`\", name),"}, {"sha": "8a242b7ee25ba861beb07b0131e8cd4a9d0f1c0e", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -71,7 +71,7 @@ impl Index<OutlivesConstraintIndex> for OutlivesConstraintSet {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct OutlivesConstraint {\n     // NB. The ordering here is not significant for correctness, but\n     // it is for convenience. Before we dump the constraints in the"}, {"sha": "75213d30982f9a833e936d28cec1537e32a1d611", "filename": "src/librustc_mir/borrow_check/nll/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -11,7 +11,7 @@ use syntax_pos::Span;\n /// indexed by the region `R0`.\n crate struct MemberConstraintSet<'tcx, R>\n where\n-    R: Copy + Hash + Eq,\n+    R: Copy + Eq,\n {\n     /// Stores the first \"member\" constraint for a given `R0`. This is an\n     /// index into the `constraints` vector below.\n@@ -191,7 +191,7 @@ where\n \n impl<'tcx, R> Index<NllMemberConstraintIndex> for MemberConstraintSet<'tcx, R>\n where\n-    R: Copy + Hash + Eq,\n+    R: Copy + Eq,\n {\n     type Output = NllMemberConstraint<'tcx>;\n "}, {"sha": "7a86536573dcf5f7728e67282211019c981791ea", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -129,7 +129,7 @@ rustc_index::newtype_index! {\n \n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug)]\n crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),"}, {"sha": "fd1f333010adc4b716554683b6d0f70ea6467500", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -146,7 +146,7 @@ struct UniversalRegionIndices<'tcx> {\n     indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialEq)]\n pub enum RegionClassification {\n     /// A **global** region is one that can be named from\n     /// anywhere. There is only one, `'static`."}, {"sha": "dc6d4b27886e4c72e043f6bbb958a5dc03a87aee", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -189,8 +189,8 @@ use std::ops::RangeInclusive;\n use std::u128;\n use std::convert::TryInto;\n \n-pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> &'a Pat<'tcx> {\n-    cx.pattern_arena.alloc(LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat))\n+pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n+    LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat)\n }\n \n struct LiteralExpander<'tcx> {"}, {"sha": "77f3768172fb4013f8bffbfc270a15a7063453ef", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -154,7 +154,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                         self.tables\n                     );\n                     patcx.include_lint_checks();\n-                    let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n+                    let pattern =\n+                        cx.pattern_arena.alloc(expand_pattern(cx, patcx.lower_pattern(&pat))) as &_;\n                     if !patcx.errors.is_empty() {\n                         patcx.report_inlining_errors(pat.span);\n                         have_errors = true;\n@@ -253,8 +254,9 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n+            let pattern = expand_pattern(cx, pattern);\n             let pats: Matrix<'_, '_> = vec![smallvec![\n-                expand_pattern(cx, pattern)\n+                &pattern\n             ]].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {"}, {"sha": "58480912929b305466170164296a405b8e0e29c0", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1214,7 +1214,7 @@ fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n \n         // tracks ADT's previously encountered during search, so that\n         // we will not recur on them again.\n-        seen: FxHashSet<&'tcx AdtDef>,\n+        seen: FxHashSet<hir::def_id::DefId>,\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n@@ -1254,14 +1254,12 @@ fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n                 return true // Halt visiting!\n             }\n \n-            if self.seen.contains(adt_def) {\n+            if !self.seen.insert(adt_def.did) {\n                 debug!(\"Search already seen adt_def: {:?}\", adt_def);\n                 // let caller continue its search\n                 return false;\n             }\n \n-            self.seen.insert(adt_def);\n-\n             // `#[structural_match]` does not care about the\n             // instantiation of the generics in an ADT (it\n             // instead looks directly at its fields outside"}, {"sha": "2ab7c41bb787e0e4e56d1d305df94687db0fc5de", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -91,7 +91,7 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     pub extra: Extra,\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+#[derive(Clone, Eq, PartialEq)]\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n@@ -113,7 +113,7 @@ pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n }\n \n /// Current value of a local variable\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq)]\n pub enum LocalValue<Tag=(), Id=AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,"}, {"sha": "eef1868ec65b69574d6d5af3a1cc3d7e5915760b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -7,7 +7,7 @@\n //! short-circuiting the empty case!\n \n use std::collections::VecDeque;\n-use std::ptr;\n+use std::{ptr, iter};\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n@@ -22,7 +22,7 @@ use super::{\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n };\n \n-#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n+#[derive(Debug, PartialEq, Copy, Clone)]\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n@@ -785,6 +785,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.get(ptr.alloc_id)?.read_c_str(self, ptr)\n     }\n \n+    /// Writes the given stream of bytes into memory.\n+    ///\n+    /// Performs appropriate bounds checks.\n+    pub fn write_bytes(\n+        &mut self,\n+        ptr: Scalar<M::PointerTag>,\n+        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n+    ) -> InterpResult<'tcx>\n+    {\n+        let src = src.into_iter();\n+        let size = Size::from_bytes(src.len() as u64);\n+        let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n+            Some(ptr) => ptr,\n+            None => return Ok(()), // zero-sized access\n+        };\n+        let tcx = self.tcx.tcx;\n+        self.get_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n+    }\n+\n     /// Expects the caller to have checked bounds and alignment.\n     pub fn copy(\n         &mut self,"}, {"sha": "4fd5e6a5435517742aa728c558b637ecaf137397", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -26,7 +26,7 @@ pub use rustc::mir::interpret::ScalarMaybeUndef;\n /// operations and fat pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Immediate<Tag=(), Id=AllocId> {\n     Scalar(ScalarMaybeUndef<Tag, Id>),\n     ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n@@ -123,7 +123,7 @@ impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n /// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Operand<Tag=(), Id=AllocId> {\n     Immediate(Immediate<Tag, Id>),\n     Indirect(MemPlace<Tag, Id>),\n@@ -153,7 +153,7 @@ impl<Tag> Operand<Tag> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct OpTy<'tcx, Tag=()> {\n     op: Operand<Tag>, // Keep this private, it helps enforce invariants\n     pub layout: TyLayout<'tcx>,\n@@ -589,8 +589,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let ptr = self.tag_static_base_pointer(Pointer::new(id, offset));\n                 Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n             },\n-            ConstValue::Scalar(x) =>\n-                Operand::Immediate(tag_scalar(x).into()),\n+            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x).into()),\n             ConstValue::Slice { data, start, end } => {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen.\n@@ -606,6 +605,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             ConstValue::Param(..) |\n             ConstValue::Infer(..) |\n+            ConstValue::Bound(..) |\n             ConstValue::Placeholder(..) |\n             ConstValue::Unevaluated(..) =>\n                 bug!(\"eval_const_to_op: Unexpected ConstValue {:?}\", val),"}, {"sha": "158b730b9bd43735e0ce5f1ae22981e75d6bb7d8", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -72,13 +72,11 @@ fn check_fn_for_unconditional_recursion(\n     let caller_substs = &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count];\n \n     while let Some(bb) = reachable_without_self_call_queue.pop() {\n-        if visited.contains(bb) {\n+        if !visited.insert(bb) {\n             //already done\n             continue;\n         }\n \n-        visited.insert(bb);\n-\n         let block = &basic_blocks[bb];\n \n         if let Some(ref terminator) = block.terminator {"}, {"sha": "5e31b80bec6d3d5a6f87ce2cd6841ffdfa94da1c", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -199,7 +199,7 @@ use rustc_data_structures::sync::{MTRef, MTLock, ParallelIterator, par_iter};\n \n use std::iter;\n \n-#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n+#[derive(PartialEq)]\n pub enum MonoItemCollectionMode {\n     Eager,\n     Lazy"}, {"sha": "108c6c9786b2a7e4860394811aec1b40b727ca96", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -431,7 +431,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         place_layout: TyLayout<'tcx>,\n         source_info: SourceInfo,\n         place: &Place<'tcx>,\n-    ) -> Option<Const<'tcx>> {\n+    ) -> Option<()> {\n         let span = source_info.span;\n \n         let overflow_check = self.tcx.sess.overflow_checks();\n@@ -518,39 +518,35 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 }\n             }\n \n-            // Work around: avoid ICE in miri.\n-            // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n-            // from a function argument that hasn't been assigned to in this function. The main\n-            // issue is if an arg is a fat-pointer, miri `expects()` to be able to read the value\n-            // of that pointer to get size info. However, since this is `ConstProp`, that argument\n-            // doesn't actually have a backing value and so this causes an ICE.\n+            // Work around: avoid ICE in miri. FIXME(wesleywiser)\n+            // The Miri engine ICEs when taking a reference to an uninitialized unsized\n+            // local. There's nothing it can do here: taking a reference needs an allocation\n+            // which needs to know the size. Normally that's okay as during execution\n+            // (e.g. for CTFE) it can never happen. But here in const_prop\n+            // unknown data is uninitialized, so if e.g. a function argument is unsized\n+            // and has a reference taken, we get an ICE.\n             Rvalue::Ref(_, _, Place { base: PlaceBase::Local(local), projection: box [] }) => {\n                 trace!(\"checking Ref({:?})\", place);\n                 let alive =\n                     if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n                         true\n-                    } else { false };\n+                    } else {\n+                        false\n+                    };\n \n-                if local.as_usize() <= self.ecx.frame().body.arg_count && !alive {\n-                    trace!(\"skipping Ref({:?})\", place);\n+                if !alive {\n+                    trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n                     return None;\n                 }\n             }\n \n-            // Work around: avoid extra unnecessary locals.\n-            // FIXME(wesleywiser): const eval will turn this into a `const Scalar(<ZST>)` that\n-            // `SimplifyLocals` doesn't know it can remove.\n-            Rvalue::Aggregate(_, operands) if operands.len() == 0 => {\n-                return None;\n-            }\n-\n             _ => { }\n         }\n \n         self.use_ecx(source_info, |this| {\n             trace!(\"calling eval_rvalue_into_place(rvalue = {:?}, place = {:?})\", rvalue, place);\n             this.ecx.eval_rvalue_into_place(rvalue, place)?;\n-            this.ecx.eval_place_to_op(place, Some(place_layout))\n+            Ok(())\n         })\n     }\n \n@@ -714,24 +710,23 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                     base: PlaceBase::Local(local),\n                     projection: box [],\n                 } = *place {\n-                    if let Some(value) = self.const_prop(rval,\n-                                                         place_layout,\n-                                                         statement.source_info,\n-                                                         place) {\n-                        trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n+                    let source = statement.source_info;\n+                    if let Some(()) = self.const_prop(rval, place_layout, source, place) {\n                         if self.can_const_prop[local] {\n-                            trace!(\"stored {:?} to {:?}\", value, local);\n-                            assert_eq!(self.get_const(local), Some(value));\n+                            trace!(\"propagated into {:?}\", local);\n \n                             if self.should_const_prop() {\n+                                let value =\n+                                    self.get_const(local).expect(\"local was dead/uninitialized\");\n+                                trace!(\"replacing {:?} with {:?}\", rval, value);\n                                 self.replace_with_const(\n                                     rval,\n                                     value,\n                                     statement.source_info,\n                                 );\n                             }\n                         } else {\n-                            trace!(\"can't propagate {:?} to {:?}\", value, local);\n+                            trace!(\"can't propagate into {:?}\", local);\n                             self.remove_const(local);\n                         }\n                     }"}, {"sha": "e41b4678dbd0db649469416e6e5f34d62dd181b1", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 54, "deletions": 22, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -31,7 +31,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::visit::{MutVisitor, Visitor, PlaceContext};\n+use rustc::mir::visit::{MutVisitor, Visitor, PlaceContext, MutatingUseContext};\n use rustc::session::config::DebugInfo;\n use std::borrow::Cow;\n use crate::transform::{MirPass, MirSource};\n@@ -293,23 +293,31 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n pub struct SimplifyLocals;\n \n impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let mut marker = DeclMarker { locals: BitSet::new_empty(body.local_decls.len()) };\n-        marker.visit_body(body);\n-        // Return pointer and arguments are always live\n-        marker.locals.insert(RETURN_PLACE);\n-        for arg in body.args_iter() {\n-            marker.locals.insert(arg);\n-        }\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        trace!(\"running SimplifyLocals on {:?}\", source);\n+        let locals = {\n+            let mut marker = DeclMarker {\n+                locals: BitSet::new_empty(body.local_decls.len()),\n+                body,\n+            };\n+            marker.visit_body(body);\n+            // Return pointer and arguments are always live\n+            marker.locals.insert(RETURN_PLACE);\n+            for arg in body.args_iter() {\n+                marker.locals.insert(arg);\n+            }\n \n-        // We may need to keep dead user variables live for debuginfo.\n-        if tcx.sess.opts.debuginfo == DebugInfo::Full {\n-            for local in body.vars_iter() {\n-                marker.locals.insert(local);\n+            // We may need to keep dead user variables live for debuginfo.\n+            if tcx.sess.opts.debuginfo == DebugInfo::Full {\n+                for local in body.vars_iter() {\n+                    marker.locals.insert(local);\n+                }\n             }\n-        }\n \n-        let map = make_local_map(&mut body.local_decls, marker.locals);\n+            marker.locals\n+        };\n+\n+        let map = make_local_map(&mut body.local_decls, locals);\n         // Update references to all vars and tmps now\n         LocalUpdater { map }.visit_body(body);\n         body.local_decls.shrink_to_fit();\n@@ -334,18 +342,35 @@ fn make_local_map<V>(\n     map\n }\n \n-struct DeclMarker {\n+struct DeclMarker<'a, 'tcx> {\n     pub locals: BitSet<Local>,\n+    pub body: &'a Body<'tcx>,\n }\n \n-impl<'tcx> Visitor<'tcx> for DeclMarker {\n-    fn visit_local(&mut self, local: &Local, ctx: PlaceContext, _: Location) {\n+impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: &Local, ctx: PlaceContext, location: Location) {\n         // Ignore storage markers altogether, they get removed along with their otherwise unused\n         // decls.\n         // FIXME: Extend this to all non-uses.\n-        if !ctx.is_storage_marker() {\n-            self.locals.insert(*local);\n+        if ctx.is_storage_marker() {\n+            return;\n         }\n+\n+        // Ignore stores of constants because `ConstProp` and `CopyProp` can remove uses of many\n+        // of these locals. However, if the local is still needed, then it will be referenced in\n+        // another place and we'll mark it as being used there.\n+        if ctx == PlaceContext::MutatingUse(MutatingUseContext::Store) {\n+            let stmt =\n+                &self.body.basic_blocks()[location.block].statements[location.statement_index];\n+            if let StatementKind::Assign(box (p, Rvalue::Use(Operand::Constant(c)))) = &stmt.kind {\n+                if p.as_local().is_some() {\n+                    trace!(\"skipping store of const value {:?} to {:?}\", c, local);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.locals.insert(*local);\n     }\n }\n \n@@ -357,9 +382,16 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n         data.statements.retain(|stmt| {\n-            match stmt.kind {\n+            match &stmt.kind {\n                 StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n-                    self.map[l].is_some()\n+                    self.map[*l].is_some()\n+                }\n+                StatementKind::Assign(box (place, _)) => {\n+                    if let Some(local) = place.as_local() {\n+                        self.map[local].is_some()\n+                    } else {\n+                        true\n+                    }\n                 }\n                 _ => true\n             }"}, {"sha": "b82cba8c83dc4d65b182ff415f21eabdfb43ee18", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1682,7 +1682,7 @@ enum Wizard {\n }\n \n trait Isengard {\n-    fn wizard(w: Wizard) { // error!\n+    fn wizard(w: Wizard) { // ok!\n         match w {\n             Wizard::Saruman => {\n                 // do something"}, {"sha": "34edd5eaf4fc727b7a86c62fffe51deae201da32", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -673,13 +673,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     self.throw_unresolved_import_error(errors, None);\n                     errors = vec![];\n                 }\n-                if !seen_spans.contains(&err.span) {\n+                if seen_spans.insert(err.span) {\n                     let path = import_path_to_string(\n                         &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n                         &import.subclass,\n                         err.span,\n                     );\n-                    seen_spans.insert(err.span);\n                     errors.push((path, err));\n                     prev_root_id = import.root_id;\n                 }"}, {"sha": "d91588db1834fa59184cd8129d17e60766566a60", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -71,8 +71,7 @@ mod riscv_base;\n mod wasm32_base;\n mod vxworks_base;\n \n-#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n-         RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum LinkerFlavor {\n     Em,\n     Gcc,\n@@ -82,8 +81,7 @@ pub enum LinkerFlavor {\n     PtxLinker,\n }\n \n-#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n-         RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum LldFlavor {\n     Wasm,\n     Ld64,"}, {"sha": "8d136a1b65c79504ec1b91f9153193b8a703fd4c", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -33,7 +33,7 @@ use rustc::traits::{\n     InEnvironment,\n     ChalkCanonicalGoal,\n };\n-use rustc::ty::{self, TyCtxt, InferConst};\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{GenericArg, GenericArgKind};\n@@ -286,7 +286,7 @@ impl context::ContextOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n                     _ => false,\n                 },\n                 GenericArgKind::Const(ct) => match ct.val {\n-                    ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)) => {\n+                    ConstValue::Bound(debruijn, bound_ct) => {\n                         debug_assert_eq!(debruijn, ty::INNERMOST);\n                         cvar == bound_ct\n                     }"}, {"sha": "49d76681196af6db5f1b6a7a1343e65a7878a5e0", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -16,7 +16,7 @@ use rustc::traits::{\n     Environment,\n     InEnvironment,\n };\n-use rustc::ty::{self, Ty, TyCtxt, InferConst};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::GenericArg;\n use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc::mir::interpret::ConstValue;\n@@ -287,10 +287,7 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        if let ty::Const {\n-            val: ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)),\n-            ..\n-        } = a {\n+        if let ty::Const { val: ConstValue::Bound(debruijn, bound_ct), .. } = a {\n             if *debruijn == self.binder_index {\n                 self.unify_free_answer_var(*bound_ct, b.into())?;\n                 return Ok(b);\n@@ -299,14 +296,8 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n \n         match (a, b) {\n             (\n-                ty::Const {\n-                    val: ConstValue::Infer(InferConst::Canonical(a_debruijn, a_bound)),\n-                    ..\n-                },\n-                ty::Const {\n-                    val: ConstValue::Infer(InferConst::Canonical(b_debruijn, b_bound)),\n-                    ..\n-                },\n+                ty::Const { val: ConstValue::Bound(a_debruijn, a_bound), .. },\n+                ty::Const { val: ConstValue::Bound(b_debruijn, b_bound), .. },\n             ) => {\n                 assert_eq!(a_debruijn, b_debruijn);\n                 assert_eq!(a_bound, b_bound);"}, {"sha": "8eab9c4e67e3313ea4a17f3c90792ba88aaf01da", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -232,8 +232,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.sess,\n                 span,\n                 E0632,\n-                \"cannot provide explicit type parameters when `impl Trait` is \\\n-                 used in argument position.\"\n+                \"cannot provide explicit generic arguments when `impl Trait` is \\\n+                 used in argument position\"\n             };\n \n             err.emit();"}, {"sha": "bfccb032458f5288bef592a4cb1fc2fc02f06ef9", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -811,7 +811,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         target: Ty<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        let source = self.resolve_type_vars_with_obligations(expr_ty);\n+        let source = self.resolve_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n@@ -829,7 +829,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Same as `try_coerce()`, but without side-effects.\n     pub fn can_coerce(&self, expr_ty: Ty<'tcx>, target: Ty<'tcx>) -> bool {\n-        let source = self.resolve_type_vars_with_obligations(expr_ty);\n+        let source = self.resolve_vars_with_obligations(expr_ty);\n         debug!(\"coercion::can({:?} -> {:?})\", source, target);\n \n         let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n@@ -853,8 +853,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 -> RelateResult<'tcx, Ty<'tcx>>\n         where E: AsCoercionSite\n     {\n-        let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n-        let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n+        let prev_ty = self.resolve_vars_with_obligations(prev_ty);\n+        let new_ty = self.resolve_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n@@ -1333,7 +1333,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             err.span_label(return_sp, \"expected because this return type...\");\n             err.span_label( *sp, format!(\n                 \"...is found to be `{}` here\",\n-                fcx.resolve_type_vars_with_obligations(expected),\n+                fcx.resolve_vars_with_obligations(expected),\n             ));\n         }\n         err"}, {"sha": "3509d6566ec93860315bea31234230f9a6df90f3", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               expected: Ty<'tcx>,\n                               allow_two_phase: AllowTwoPhase)\n                               -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n-        let expected = self.resolve_type_vars_with_obligations(expected);\n+        let expected = self.resolve_vars_with_obligations(expected);\n \n         let e = match self.try_coerce(expr, checked_ty, expected, allow_two_phase) {\n             Ok(ty) => return (ty, None),\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expr = expr.peel_drop_temps();\n         let cause = self.misc(expr.span);\n-        let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n+        let expr_ty = self.resolve_vars_with_obligations(checked_ty);\n         let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n \n         if self.is_assign_to_bool(expr, expected) {"}, {"sha": "f5f85bbcb100c4bb7028de09dfc20380326dbc4b", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1010,7 +1010,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr,\n     ) -> Ty<'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n-            let ty = self.resolve_type_vars_with_obligations(ty);\n+            let ty = self.resolve_vars_with_obligations(ty);\n             match ty.kind {\n                 ty::Tuple(ref flds) => Some(&flds[..]),\n                 _ => None"}, {"sha": "d90ed2a790bb642fdecbcaaf1ac97e149e3bdfbb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -919,7 +919,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // This occurs for UFCS desugaring of `T::method`, where there is no\n         // receiver expression for the method call, and thus no autoderef.\n         if let SelfSource::QPath(_) = source {\n-            return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n+            return is_local(self.resolve_vars_with_obligations(rcvr_ty));\n         }\n \n         self.autoderef(span, rcvr_ty).any(|(ty, _)| is_local(ty))"}, {"sha": "73a025182a7e338ae9854f37b31aa0190095e62d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1387,9 +1387,37 @@ fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n     check_transparent(tcx, span, def_id);\n+    check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def_id);\n }\n \n+/// When the `#![feature(untagged_unions)]` gate is active,\n+/// check that the fields of the `union` does not contain fields that need dropping.\n+fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n+    let item_type = tcx.type_of(item_def_id);\n+    if let ty::Adt(def, substs) = item_type.kind {\n+        assert!(def.is_union());\n+        let fields = &def.non_enum_variant().fields;\n+        for field in fields {\n+            let field_ty = field.ty(tcx, substs);\n+            // We are currently checking the type this field came from, so it must be local.\n+            let field_span = tcx.hir().span_if_local(field.did).unwrap();\n+            let param_env = tcx.param_env(field.did);\n+            if field_ty.needs_drop(tcx, param_env) {\n+                struct_span_err!(tcx.sess, field_span, E0740,\n+                                    \"unions may not contain fields that need dropping\")\n+                            .span_note(field_span,\n+                                        \"`std::mem::ManuallyDrop` can be used to wrap the type\")\n+                            .emit();\n+                return false;\n+            }\n+        }\n+    } else {\n+        span_bug!(span, \"unions must be ty::Adt, but got {:?}\", item_type.kind);\n+    }\n+    return true;\n+}\n+\n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n /// projections that would result in \"inheriting lifetimes\".\n fn check_opaque<'tcx>(\n@@ -2440,23 +2468,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.cause(span, ObligationCauseCode::MiscObligation)\n     }\n \n-    /// Resolves type variables in `ty` if possible. Unlike the infcx\n+    /// Resolves type and const variables in `ty` if possible. Unlike the infcx\n     /// version (resolve_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n     /// to get more type information.\n-    fn resolve_type_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"resolve_type_vars_with_obligations(ty={:?})\", ty);\n+    fn resolve_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        debug!(\"resolve_vars_with_obligations(ty={:?})\", ty);\n \n         // No Infer()? Nothing needs doing.\n-        if !ty.has_infer_types() {\n-            debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n+        if !ty.has_infer_types() && !ty.has_infer_consts() {\n+            debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.resolve_vars_if_possible(&ty);\n-        if !ty.has_infer_types() {\n-            debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n+        if !ty.has_infer_types() && !ty.has_infer_consts()  {\n+            debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n         }\n \n@@ -2467,7 +2495,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.select_obligations_where_possible(false, |_| {});\n         ty = self.resolve_vars_if_possible(&ty);\n \n-        debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n+        debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n         ty\n     }\n \n@@ -3668,7 +3696,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                            formal_ret: Ty<'tcx>,\n                                            formal_args: &[Ty<'tcx>])\n                                            -> Vec<Ty<'tcx>> {\n-        let formal_ret = self.resolve_type_vars_with_obligations(formal_ret);\n+        let formal_ret = self.resolve_vars_with_obligations(formal_ret);\n         let ret_ty = match expected_ret.only_has_type(self) {\n             Some(ret) => ret,\n             None => return Vec::new()\n@@ -4517,7 +4545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_suggestion(\n                     span,\n                     \"try adding a return type\",\n-                    format!(\"-> {} \", self.resolve_type_vars_with_obligations(found)),\n+                    format!(\"-> {} \", self.resolve_vars_with_obligations(found)),\n                     Applicability::MachineApplicable);\n                 true\n             }\n@@ -4993,7 +5021,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // If no resolution is possible, then an error is reported.\n     // Numeric inference variables may be left unresolved.\n     pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let ty = self.resolve_type_vars_with_obligations(ty);\n+        let ty = self.resolve_vars_with_obligations(ty);\n         if !ty.is_ty_var() {\n             ty\n         } else {"}, {"sha": "819c347d3ae95988008297ca12de1f10cd5e694e", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_with_needs(lhs_expr, Needs::MutPlace)\n             }\n         };\n-        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n+        let lhs_ty = self.resolve_vars_with_obligations(lhs_ty);\n \n         // N.B., as we have not yet type-checked the RHS, we don't have the\n         // type at hand. Make a variable to represent it. The whole reason\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // see `NB` above\n         let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n-        let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n+        let rhs_ty = self.resolve_vars_with_obligations(rhs_ty);\n \n         let return_ty = match result {\n             Ok(method) => {"}, {"sha": "97c30f208f5ecb8fa8f2d40cdee2b977590563de", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -251,7 +251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         mut def_bm: BindingMode,\n     ) -> (Ty<'tcx>, BindingMode) {\n-        let mut expected = self.resolve_type_vars_with_obligations(&expected);\n+        let mut expected = self.resolve_vars_with_obligations(&expected);\n \n         // Peel off as many `&` or `&mut` from the scrutinee type as possible. For example,\n         // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches"}, {"sha": "3ecbf620cbc7b9068d956b2a355b924f47f9c10c", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -4863,6 +4863,10 @@ assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n ```\n \"##,\n \n+E0740: r##\"\n+A `union` cannot have fields with destructors.\n+\"##,\n+\n E0733: r##\"\n Recursion in an `async fn` requires boxing. For example, this will not compile:\n \n@@ -5048,8 +5052,8 @@ the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n //  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)\n     E0627, // yield statement outside of generator literal\n-    E0632, // cannot provide explicit type parameters when `impl Trait` is used\n-           // in argument position.\n+    E0632, // cannot provide explicit generic arguments when `impl Trait` is\n+           // used in argument position\n     E0634, // type has conflicting packed representaton hints\n     E0640, // infer outlives requirements\n     E0641, // cannot cast to/from a pointer with an unknown kind"}, {"sha": "09c9757dc4d07dd08d14fa75d52b6aaffb04d6ac", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1307,7 +1307,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, Debug)]\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n@@ -1589,7 +1589,7 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n }\n \n // maybe use a Generic enum and use Vec<Generic>?\n-#[derive(Clone, PartialEq, Eq, Debug, Default, Hash)]\n+#[derive(Clone, Debug, Default)]\n pub struct Generics {\n     pub params: Vec<GenericParamDef>,\n     pub where_predicates: Vec<WherePredicate>,\n@@ -3847,7 +3847,7 @@ impl Clean<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Copy, Debug, Hash)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum ImplPolarity {\n     Positive,\n     Negative,\n@@ -4506,7 +4506,6 @@ struct RegionDeps<'tcx> {\n     smaller: FxHashSet<RegionTarget<'tcx>>\n }\n \n-#[derive(Eq, PartialEq, Hash, Debug)]\n enum SimpleBound {\n     TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier),\n     Outlives(Lifetime),"}, {"sha": "0b8d4d6c302f19bc8986c43dafb5d8374fe090c7", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -53,6 +53,8 @@ pub struct Options {\n     pub codegen_options_strs: Vec<String>,\n     /// Debugging (`-Z`) options to pass to the compiler.\n     pub debugging_options: DebuggingOptions,\n+    /// Debugging (`-Z`) options strings to pass to the compiler.\n+    pub debugging_options_strs: Vec<String>,\n     /// The target used to compile the crate against.\n     pub target: TargetTriple,\n     /// Edition used when reading the crate. Defaults to \"2015\". Also used by default when\n@@ -478,6 +480,7 @@ impl Options {\n         let generate_redirect_pages = matches.opt_present(\"generate-redirect-pages\");\n         let test_builder = matches.opt_str(\"test-builder\").map(PathBuf::from);\n         let codegen_options_strs = matches.opt_strs(\"C\");\n+        let debugging_options_strs = matches.opt_strs(\"Z\");\n         let lib_strs = matches.opt_strs(\"L\");\n         let extern_strs = matches.opt_strs(\"extern\");\n         let runtool = matches.opt_str(\"runtool\");\n@@ -499,6 +502,7 @@ impl Options {\n             codegen_options,\n             codegen_options_strs,\n             debugging_options,\n+            debugging_options_strs,\n             target,\n             edition,\n             maybe_sysroot,"}, {"sha": "2337ec5a52cccb2f011547988ac20ab02520d88b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -329,7 +329,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n     let config = interface::Config {\n         opts: sessopts,\n-        crate_cfg: config::parse_cfgspecs(cfgs),\n+        crate_cfg: interface::parse_cfgspecs(cfgs),\n         input,\n         input_path: cpath,\n         output_file: None,"}, {"sha": "8afc50f83bfaf67d0e434b7e1a871addbe6aa171", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -67,7 +67,7 @@ pub fn run(options: Options) -> i32 {\n     cfgs.push(\"doctest\".to_owned());\n     let config = interface::Config {\n         opts: sessopts,\n-        crate_cfg: config::parse_cfgspecs(cfgs),\n+        crate_cfg: interface::parse_cfgspecs(cfgs),\n         input,\n         input_path: None,\n         output_file: None,\n@@ -280,6 +280,9 @@ fn run_test(\n     for codegen_options_str in &options.codegen_options_strs {\n         compiler.arg(\"-C\").arg(&codegen_options_str);\n     }\n+    for debugging_option_str in &options.debugging_options_strs {\n+        compiler.arg(\"-Z\").arg(&debugging_option_str);\n+    }\n     if no_run {\n         compiler.arg(\"--emit=metadata\");\n     }"}, {"sha": "f2e9be14c8d12ed4198240ab7a7d8898fef0f527", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -143,7 +143,7 @@ impl<T> Decodable for BTreeSet<T>\n }\n \n impl<K, V, S> Encodable for HashMap<K, V, S>\n-    where K: Encodable + Hash + Eq,\n+    where K: Encodable + Eq,\n           V: Encodable,\n           S: BuildHasher,\n {\n@@ -180,7 +180,7 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n }\n \n impl<T, S> Encodable for HashSet<T, S>\n-    where T: Encodable + Hash + Eq,\n+    where T: Encodable + Eq,\n           S: BuildHasher,\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {"}, {"sha": "6dcda98631014a1eed927bdcc5c5c7c73af702a7", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -327,7 +327,31 @@ impl CString {\n     /// [`NulError`]: struct.NulError.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n-        Self::_new(t.into())\n+        trait SpecIntoVec {\n+            fn into_vec(self) -> Vec<u8>;\n+        }\n+        impl<T: Into<Vec<u8>>> SpecIntoVec for T {\n+            default fn into_vec(self) -> Vec<u8> {\n+                self.into()\n+            }\n+        }\n+        // Specialization for avoiding reallocation.\n+        impl SpecIntoVec for &'_ [u8] {\n+            fn into_vec(self) -> Vec<u8> {\n+                let mut v = Vec::with_capacity(self.len() + 1);\n+                v.extend(self);\n+                v\n+            }\n+        }\n+        impl SpecIntoVec for &'_ str {\n+            fn into_vec(self) -> Vec<u8> {\n+                let mut v = Vec::with_capacity(self.len() + 1);\n+                v.extend(self.as_bytes());\n+                v\n+            }\n+        }\n+\n+        Self::_new(SpecIntoVec::into_vec(t))\n     }\n \n     fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {"}, {"sha": "6574ef13db9532ab5c33ecf92cbc0b9f61db30f5", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -762,7 +762,7 @@ pub fn set_print(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write +\n /// otherwise. `label` identifies the stream in a panic message.\n ///\n /// This function is used to print error messages, so it takes extra\n-/// care to avoid causing a panic when `local_stream` is unusable.\n+/// care to avoid causing a panic when `local_s` is unusable.\n /// For instance, if the TLS key for the local stream is\n /// already destroyed, or if the local stream is locked by another\n /// thread, it will just fall back to the global stream."}, {"sha": "ab8a55660cb0c3be93a2dc560b3c11bebea856d5", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -33,9 +33,72 @@ mod as_keyword { }\n //\n /// Exit early from a loop.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// When `break` is encountered, execution of the associated loop body is\n+/// immediately terminated.\n+///\n+/// ```rust\n+/// let mut last = 0;\n+///\n+/// for x in 1..100 {\n+///     if x > 12 {\n+///         break;\n+///     }\n+///     last = x;\n+/// }\n+///\n+/// assert_eq!(last, 12);\n+/// println!(\"{}\", last);\n+/// ```\n+///\n+/// A break expression is normally associated with the innermost loop enclosing the\n+/// `break` but a label can be used to specify which enclosing loop is affected.\n+///\n+///```rust\n+/// 'outer: for i in 1..=5 {\n+///     println!(\"outer iteration (i): {}\", i);\n+///\n+///     'inner: for j in 1..=200 {\n+///         println!(\"    inner iteration (j): {}\", j);\n+///         if j >= 3 {\n+///             // breaks from inner loop, let's outer loop continue.\n+///             break;\n+///         }\n+///         if i >= 2 {\n+///             // breaks from outer loop, and directly to \"Bye\".\n+///             break 'outer;\n+///         }\n+///     }\n+/// }\n+/// println!(\"Bye.\");\n+///```\n+///\n+/// When associated with `loop`, a break expression may be used to return a value from that loop.\n+/// This is only valid with `loop` and not with any other type of loop.\n+/// If no value is specified, `break;` returns `()`.\n+/// Every `break` within a loop must return the same type.\n+///\n+/// ```rust\n+/// let (mut a, mut b) = (1, 1);\n+/// let result = loop {\n+///     if b > 10 {\n+///         break b;\n+///     }\n+///     let c = a + b;\n+///     a = b;\n+///     b = c;\n+/// };\n+/// // first number in Fibonacci sequence over 10:\n+/// assert_eq!(result, 13);\n+/// println!(\"{}\", result);\n+/// ```\n+///\n+/// For more details consult the [Reference on \"break expression\"] and the [Reference on \"break and\n+/// loop values\"].\n+///\n+/// [Reference on \"break expression\"]: ../reference/expressions/loop-expr.html#break-expressions\n+/// [Reference on \"break and loop values\"]:\n+/// ../reference/expressions/loop-expr.html#break-and-loop-values\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n mod break_keyword { }\n \n #[doc(keyword = \"const\")]"}, {"sha": "93d3e4ea3df228a33fefc5534065897a8abcb5fa", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -275,6 +275,7 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(log_syntax)]\n+#![feature(manually_drop_take)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(needs_panic_runtime)]\n@@ -297,6 +298,7 @@\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n #![feature(slice_patterns)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stdsimd)]"}, {"sha": "a9e4457f42374e2aed532638d23f75523eb7a714", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -202,7 +202,7 @@ impl UdpSocket {\n     ///\n     /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n     /// assert_eq!(socket.peer_addr().unwrap_err().kind(),\n-    ///            ::std::io::ErrorKind::NotConnected);\n+    ///            std::io::ErrorKind::NotConnected);\n     /// ```\n     #[stable(feature = \"udp_peer_addr\", since = \"1.40.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {"}, {"sha": "577673b7e405b6e3e3de3e86f6636823e366aaed", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -264,7 +264,7 @@ impl RefUnwindSafe for atomic::AtomicI128 {}\n #[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicUsize {}\n-#[cfg(target_hastarget_has_atomic_load_store_atomic = \"8\")]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU8 {}\n #[cfg(target_has_atomic_load_store = \"16\")]"}, {"sha": "2dde81bb0ecd48bc4681e1fc99a292bb9cfc0eaa", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -12,8 +12,7 @@ use core::panic::{BoxMeUp, PanicInfo, Location};\n use crate::any::Any;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::mem;\n-use crate::ptr;\n+use crate::mem::{self, ManuallyDrop};\n use crate::raw;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::stdio::panic_output;\n@@ -227,10 +226,9 @@ pub use realstd::rt::update_panic_count;\n \n /// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>> {\n-    #[allow(unions_with_drop_fields)]\n     union Data<F, R> {\n-        f: F,\n-        r: R,\n+        f: ManuallyDrop<F>,\n+        r: ManuallyDrop<R>,\n     }\n \n     // We do some sketchy operations with ownership here for the sake of\n@@ -261,7 +259,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     let mut any_data = 0;\n     let mut any_vtable = 0;\n     let mut data = Data {\n-        f,\n+        f: ManuallyDrop::new(f)\n     };\n \n     let r = __rust_maybe_catch_panic(do_call::<F, R>,\n@@ -271,7 +269,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n \n     return if r == 0 {\n         debug_assert!(update_panic_count(0) == 0);\n-        Ok(data.r)\n+        Ok(ManuallyDrop::into_inner(data.r))\n     } else {\n         update_panic_count(-1);\n         debug_assert!(update_panic_count(0) == 0);\n@@ -284,8 +282,9 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n         unsafe {\n             let data = data as *mut Data<F, R>;\n-            let f = ptr::read(&mut (*data).f);\n-            ptr::write(&mut (*data).r, f());\n+            let data = &mut (*data);\n+            let f = ManuallyDrop::take(&mut data.f);\n+            data.r = ManuallyDrop::new(f());\n         }\n     }\n }"}, {"sha": "4b0cf8312f1894ba25b3abc41ef237fc1f7871cc", "filename": "src/libstd/process.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1488,12 +1488,12 @@ impl Child {\n /// }\n ///\n /// fn main() {\n-///     ::std::process::exit(match run_app() {\n-///        Ok(_) => 0,\n-///        Err(err) => {\n-///            eprintln!(\"error: {:?}\", err);\n-///            1\n-///        }\n+///     std::process::exit(match run_app() {\n+///         Ok(_) => 0,\n+///         Err(err) => {\n+///             eprintln!(\"error: {:?}\", err);\n+///             1\n+///         }\n ///     });\n /// }\n /// ```"}, {"sha": "ba611a6b7e7b9ae768bf6f6d5e13fba1f372be45", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -71,22 +71,7 @@ impl FileDesc {\n         #[cfg(target_os = \"android\")]\n         use super::android::cvt_pread64;\n \n-        #[cfg(target_os = \"emscripten\")]\n-        unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n-            use crate::convert::TryInto;\n-            use libc::pread64;\n-            // pread64 on emscripten actually takes a 32 bit offset\n-            if let Ok(o) = offset.try_into() {\n-                cvt(pread64(fd, buf, count, o))\n-            } else {\n-                Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                   \"cannot pread >2GB\"))\n-            }\n-        }\n-\n-        #[cfg(not(any(target_os = \"android\", target_os = \"emscripten\")))]\n+        #[cfg(not(target_os = \"android\"))]\n         unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n             -> io::Result<isize>\n         {\n@@ -128,22 +113,7 @@ impl FileDesc {\n         #[cfg(target_os = \"android\")]\n         use super::android::cvt_pwrite64;\n \n-        #[cfg(target_os = \"emscripten\")]\n-        unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n-            use crate::convert::TryInto;\n-            use libc::pwrite64;\n-            // pwrite64 on emscripten actually takes a 32 bit offset\n-            if let Ok(o) = offset.try_into() {\n-                cvt(pwrite64(fd, buf, count, o))\n-            } else {\n-                Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                   \"cannot pwrite >2GB\"))\n-            }\n-        }\n-\n-        #[cfg(not(any(target_os = \"android\", target_os = \"emscripten\")))]\n+        #[cfg(not(target_os = \"android\"))]\n         unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n             -> io::Result<isize>\n         {"}, {"sha": "b34ebf7dae6efa07cc3ba9ecdc00223d6969b009", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -783,8 +783,6 @@ impl File {\n             SeekFrom::End(off) => (libc::SEEK_END, off),\n             SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n         };\n-        #[cfg(target_os = \"emscripten\")]\n-        let pos = pos as i32;\n         let n = cvt(unsafe { lseek64(self.0.raw(), pos, whence) })?;\n         Ok(n as u64)\n     }"}, {"sha": "8be7f4478fa09c0c6ffd415d153d2b651d39df21", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1305,7 +1305,7 @@ impl MacroDef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`.\n     Cooked,\n@@ -1327,7 +1327,7 @@ pub struct Lit {\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LitIntType {\n     Signed(IntTy),\n     Unsigned(UintTy),\n@@ -1337,7 +1337,7 @@ pub enum LitIntType {\n /// Literal kind.\n ///\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Hash, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`).\n     Str(Symbol, StrStyle),"}, {"sha": "84c86c9651fcf4a501d4e9e35f144133283b3354", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -84,15 +84,15 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum InlineAttr {\n     None,\n     Hint,\n     Always,\n     Never,\n }\n \n-#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum OptimizeAttr {\n     None,\n     Speed,\n@@ -624,8 +624,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n     }\n }\n \n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, Clone)]\n pub struct Deprecation {\n     pub since: Option<Symbol>,\n     pub note: Option<Symbol>,\n@@ -749,7 +748,7 @@ pub enum ReprAttr {\n     ReprAlign(u32),\n }\n \n-#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+#[derive(Eq, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n     UnsignedInt(ast::UintTy)"}, {"sha": "3fa13f08d3ab650e5bdc4104634268281d2fd163", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -67,7 +67,7 @@ pub struct Globals {\n impl Globals {\n     fn new(edition: Edition) -> Globals {\n         Globals {\n-            // We have no idea how many attributes their will be, so just\n+            // We have no idea how many attributes there will be, so just\n             // initiate the vectors with 0 bits. We'll grow them as necessary.\n             used_attrs: Lock::new(GrowableBitSet::new_empty()),\n             known_attrs: Lock::new(GrowableBitSet::new_empty()),"}, {"sha": "d987dc855b6156ec8c7ae2fbdd272167a1c47540", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -35,7 +35,6 @@ use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n-#[derive(Hash, PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }"}, {"sha": "a1d147637e27e82379948bbbb3550b1d300c35a2", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -41,7 +41,7 @@ pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,"}, {"sha": "58edf23a5b1e2be2dadb7e4762f0f18ce7976788", "filename": "src/libsyntax_expand/base.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbase.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1072,7 +1072,11 @@ impl<'a> ExtCtxt<'a> {\n     /// This unifies the logic used for resolving `include_X!`, and `#[doc(include)]` file paths.\n     ///\n     /// Returns an absolute path to the file that `path` refers to.\n-    pub fn resolve_path(&self, path: impl Into<PathBuf>, span: Span) -> PathBuf {\n+    pub fn resolve_path(\n+        &self,\n+        path: impl Into<PathBuf>,\n+        span: Span,\n+    ) -> Result<PathBuf, DiagnosticBuilder<'a>> {\n         let path = path.into();\n \n         // Relative paths are resolved relative to the file in which they are found\n@@ -1082,13 +1086,16 @@ impl<'a> ExtCtxt<'a> {\n             let mut result = match self.source_map().span_to_unmapped_path(callsite) {\n                 FileName::Real(path) => path,\n                 FileName::DocTest(path, _) => path,\n-                other => panic!(\"cannot resolve relative path in non-file source `{}`\", other),\n+                other => return Err(self.struct_span_err(\n+                    span,\n+                    &format!(\"cannot resolve relative path in non-file source `{}`\", other),\n+                )),\n             };\n             result.pop();\n             result.push(path);\n-            result\n+            Ok(result)\n         } else {\n-            path\n+            Ok(path)\n         }\n     }\n }"}, {"sha": "fc521e5edc06b146176ce26eebdff22b7c0c8c66", "filename": "src/libsyntax_expand/expand.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fexpand.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1418,7 +1418,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                         return noop_visit_attribute(at, self);\n                     }\n \n-                    let filename = self.cx.resolve_path(&*file.as_str(), it.span());\n+                    let filename = match self.cx.resolve_path(&*file.as_str(), it.span()) {\n+                        Ok(filename) => filename,\n+                        Err(mut err) => {\n+                            err.emit();\n+                            continue;\n+                        }\n+                    };\n+\n                     match self.cx.source_map().load_file(&filename) {\n                         Ok(source_file) => {\n                             let src = source_file.src.as_ref()"}, {"sha": "d0f790638efa3afd5ca07ffc3db8c7ce3c3c0c1f", "filename": "src/libsyntax_expand/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -73,7 +73,7 @@ impl KleeneToken {\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,"}, {"sha": "f6c58fcdfa1cbf009ab10d56a0007f91773fada4", "filename": "src/libsyntax_ext/source_util.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -76,7 +76,13 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n         None => return DummyResult::any(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let file = cx.resolve_path(file, sp);\n+    let file = match cx.resolve_path(file, sp) {\n+        Ok(f) => f,\n+        Err(mut err) => {\n+            err.emit();\n+            return DummyResult::any(sp);\n+        },\n+    };\n     let directory_ownership = DirectoryOwnership::Owned { relative: None };\n     let p = parse::new_sub_parser_from_file(cx.parse_sess(), &file, directory_ownership, None, sp);\n \n@@ -122,7 +128,13 @@ pub fn expand_include_str(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n         Some(f) => f,\n         None => return DummyResult::any(sp)\n     };\n-    let file = cx.resolve_path(file, sp);\n+    let file = match cx.resolve_path(file, sp) {\n+        Ok(f) => f,\n+        Err(mut err) => {\n+            err.emit();\n+            return DummyResult::any(sp);\n+        },\n+    };\n     match cx.source_map().load_binary_file(&file) {\n         Ok(bytes) => match std::str::from_utf8(&bytes) {\n             Ok(src) => {\n@@ -147,7 +159,13 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n         Some(f) => f,\n         None => return DummyResult::any(sp)\n     };\n-    let file = cx.resolve_path(file, sp);\n+    let file = match cx.resolve_path(file, sp) {\n+        Ok(f) => f,\n+        Err(mut err) => {\n+            err.emit();\n+            return DummyResult::any(sp);\n+        },\n+    };\n     match cx.source_map().load_binary_file(&file) {\n         Ok(bytes) => {\n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Lrc::new(bytes))))"}, {"sha": "7e42b931961f8638670e7e63dfcde0e3b991d1d6", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1311,7 +1311,7 @@ pub struct BytePos(pub u32);\n /// A character offset. Because of multibyte UTF-8 characters, a byte offset\n /// is not equivalent to a character offset. The `SourceMap` will convert `BytePos`\n /// values to `CharPos` values as necessary.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub struct CharPos(pub usize);\n \n // FIXME: lots of boilerplate in these impls, but so far my attempts to fix"}, {"sha": "c142c5213d2e0c579a2645753baf497a56c26152", "filename": "src/libtest/bench.rs", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fbench.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,258 @@\n+//! Benchmarking module.\n+pub use std::hint::black_box;\n+\n+use super::{\n+    event::CompletedTest,\n+    helpers::sink::Sink,\n+    options::BenchMode,\n+    types::TestDesc,\n+    test_result::TestResult,\n+    Sender,\n+};\n+\n+use crate::stats;\n+use std::time::{Duration, Instant};\n+use std::cmp;\n+use std::io;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::sync::{Arc, Mutex};\n+\n+/// Manager of the benchmarking runs.\n+///\n+/// This is fed into functions marked with `#[bench]` to allow for\n+/// set-up & tear-down before running a piece of code repeatedly via a\n+/// call to `iter`.\n+#[derive(Clone)]\n+pub struct Bencher {\n+    mode: BenchMode,\n+    summary: Option<stats::Summary>,\n+    pub bytes: u64,\n+}\n+\n+impl Bencher {\n+    /// Callback for benchmark functions to run in their body.\n+    pub fn iter<T, F>(&mut self, mut inner: F)\n+    where\n+        F: FnMut() -> T,\n+    {\n+        if self.mode == BenchMode::Single {\n+            ns_iter_inner(&mut inner, 1);\n+            return;\n+        }\n+\n+        self.summary = Some(iter(&mut inner));\n+    }\n+\n+    pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n+    where\n+        F: FnMut(&mut Bencher),\n+    {\n+        f(self);\n+        return self.summary;\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq)]\n+pub struct BenchSamples {\n+    pub ns_iter_summ: stats::Summary,\n+    pub mb_s: usize,\n+}\n+\n+pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n+    use std::fmt::Write;\n+    let mut output = String::new();\n+\n+    let median = bs.ns_iter_summ.median as usize;\n+    let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n+\n+    output\n+        .write_fmt(format_args!(\n+            \"{:>11} ns/iter (+/- {})\",\n+            fmt_thousands_sep(median, ','),\n+            fmt_thousands_sep(deviation, ',')\n+        ))\n+        .unwrap();\n+    if bs.mb_s != 0 {\n+        output\n+            .write_fmt(format_args!(\" = {} MB/s\", bs.mb_s))\n+            .unwrap();\n+    }\n+    output\n+}\n+\n+// Format a number with thousands separators\n+fn fmt_thousands_sep(mut n: usize, sep: char) -> String {\n+    use std::fmt::Write;\n+    let mut output = String::new();\n+    let mut trailing = false;\n+    for &pow in &[9, 6, 3, 0] {\n+        let base = 10_usize.pow(pow);\n+        if pow == 0 || trailing || n / base != 0 {\n+            if !trailing {\n+                output.write_fmt(format_args!(\"{}\", n / base)).unwrap();\n+            } else {\n+                output.write_fmt(format_args!(\"{:03}\", n / base)).unwrap();\n+            }\n+            if pow != 0 {\n+                output.push(sep);\n+            }\n+            trailing = true;\n+        }\n+        n %= base;\n+    }\n+\n+    output\n+}\n+\n+fn ns_from_dur(dur: Duration) -> u64 {\n+    dur.as_secs() * 1_000_000_000 + (dur.subsec_nanos() as u64)\n+}\n+\n+fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n+where\n+    F: FnMut() -> T,\n+{\n+    let start = Instant::now();\n+    for _ in 0..k {\n+        black_box(inner());\n+    }\n+    return ns_from_dur(start.elapsed());\n+}\n+\n+pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n+where\n+    F: FnMut() -> T,\n+{\n+    // Initial bench run to get ballpark figure.\n+    let ns_single = ns_iter_inner(inner, 1);\n+\n+    // Try to estimate iter count for 1ms falling back to 1m\n+    // iterations if first run took < 1ns.\n+    let ns_target_total = 1_000_000; // 1ms\n+    let mut n = ns_target_total / cmp::max(1, ns_single);\n+\n+    // if the first run took more than 1ms we don't want to just\n+    // be left doing 0 iterations on every loop. The unfortunate\n+    // side effect of not being able to do as many runs is\n+    // automatically handled by the statistical analysis below\n+    // (i.e., larger error bars).\n+    n = cmp::max(1, n);\n+\n+    let mut total_run = Duration::new(0, 0);\n+    let samples: &mut [f64] = &mut [0.0_f64; 50];\n+    loop {\n+        let loop_start = Instant::now();\n+\n+        for p in &mut *samples {\n+            *p = ns_iter_inner(inner, n) as f64 / n as f64;\n+        }\n+\n+        stats::winsorize(samples, 5.0);\n+        let summ = stats::Summary::new(samples);\n+\n+        for p in &mut *samples {\n+            let ns = ns_iter_inner(inner, 5 * n);\n+            *p = ns as f64 / (5 * n) as f64;\n+        }\n+\n+        stats::winsorize(samples, 5.0);\n+        let summ5 = stats::Summary::new(samples);\n+\n+        let loop_run = loop_start.elapsed();\n+\n+        // If we've run for 100ms and seem to have converged to a\n+        // stable median.\n+        if loop_run > Duration::from_millis(100)\n+            && summ.median_abs_dev_pct < 1.0\n+            && summ.median - summ5.median < summ5.median_abs_dev\n+        {\n+            return summ5;\n+        }\n+\n+        total_run = total_run + loop_run;\n+        // Longest we ever run for is 3s.\n+        if total_run > Duration::from_secs(3) {\n+            return summ5;\n+        }\n+\n+        // If we overflow here just return the results so far. We check a\n+        // multiplier of 10 because we're about to multiply by 2 and the\n+        // next iteration of the loop will also multiply by 5 (to calculate\n+        // the summ5 result)\n+        n = match n.checked_mul(10) {\n+            Some(_) => n * 2,\n+            None => {\n+                return summ5;\n+            }\n+        };\n+    }\n+}\n+\n+pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<CompletedTest>, nocapture: bool, f: F)\n+where\n+    F: FnMut(&mut Bencher),\n+{\n+    let mut bs = Bencher {\n+        mode: BenchMode::Auto,\n+        summary: None,\n+        bytes: 0,\n+    };\n+\n+    let data = Arc::new(Mutex::new(Vec::new()));\n+    let oldio = if !nocapture {\n+        Some((\n+            io::set_print(Some(Sink::new_boxed(&data))),\n+            io::set_panic(Some(Sink::new_boxed(&data))),\n+        ))\n+    } else {\n+        None\n+    };\n+\n+    let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n+\n+    if let Some((printio, panicio)) = oldio {\n+        io::set_print(printio);\n+        io::set_panic(panicio);\n+    }\n+\n+    let test_result = match result {\n+        //bs.bench(f) {\n+        Ok(Some(ns_iter_summ)) => {\n+            let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n+            let mb_s = bs.bytes * 1000 / ns_iter;\n+\n+            let bs = BenchSamples {\n+                ns_iter_summ,\n+                mb_s: mb_s as usize,\n+            };\n+            TestResult::TrBench(bs)\n+        }\n+        Ok(None) => {\n+            // iter not called, so no data.\n+            // FIXME: error in this case?\n+            let samples: &mut [f64] = &mut [0.0_f64; 1];\n+            let bs = BenchSamples {\n+                ns_iter_summ: stats::Summary::new(samples),\n+                mb_s: 0,\n+            };\n+            TestResult::TrBench(bs)\n+        }\n+        Err(_) => TestResult::TrFailed,\n+    };\n+\n+    let stdout = data.lock().unwrap().to_vec();\n+    let message = CompletedTest::new(desc, test_result, None, stdout);\n+    monitor_ch.send(message).unwrap();\n+}\n+\n+pub fn run_once<F>(f: F)\n+where\n+    F: FnMut(&mut Bencher),\n+{\n+    let mut bs = Bencher {\n+        mode: BenchMode::Single,\n+        summary: None,\n+        bytes: 0,\n+    };\n+    bs.bench(f);\n+}"}, {"sha": "f95d5aad18a654792815573564f12259244e0a29", "filename": "src/libtest/cli.rs", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fcli.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,444 @@\n+//! Module converting command-line arguments into test configuration.\n+\n+use std::env;\n+use std::path::PathBuf;\n+use getopts;\n+\n+use super::options::{RunIgnored, ColorConfig, OutputFormat, Options};\n+use super::time::TestTimeOptions;\n+use super::helpers::isatty;\n+\n+#[derive(Debug)]\n+pub struct TestOpts {\n+    pub list: bool,\n+    pub filter: Option<String>,\n+    pub filter_exact: bool,\n+    pub exclude_should_panic: bool,\n+    pub run_ignored: RunIgnored,\n+    pub run_tests: bool,\n+    pub bench_benchmarks: bool,\n+    pub logfile: Option<PathBuf>,\n+    pub nocapture: bool,\n+    pub color: ColorConfig,\n+    pub format: OutputFormat,\n+    pub test_threads: Option<usize>,\n+    pub skip: Vec<String>,\n+    pub time_options: Option<TestTimeOptions>,\n+    pub options: Options,\n+}\n+\n+impl TestOpts {\n+    pub fn use_color(&self) -> bool {\n+        match self.color {\n+            ColorConfig::AutoColor => !self.nocapture && isatty::stdout_isatty(),\n+            ColorConfig::AlwaysColor => true,\n+            ColorConfig::NeverColor => false,\n+        }\n+    }\n+}\n+\n+/// Result of parsing the options.\n+pub type OptRes = Result<TestOpts, String>;\n+/// Result of parsing the option part.\n+type OptPartRes<T> = Result<T, String>;\n+\n+fn optgroups() -> getopts::Options {\n+    let mut opts = getopts::Options::new();\n+    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n+        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n+        .optflag(\"\", \"exclude-should-panic\", \"Excludes tests marked as should_panic\")\n+        .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n+        .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n+        .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n+        .optflag(\"h\", \"help\", \"Display this message (longer with --help)\")\n+        .optopt(\n+            \"\",\n+            \"logfile\",\n+            \"Write logs to the specified file instead \\\n+             of stdout\",\n+            \"PATH\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"nocapture\",\n+            \"don't capture stdout/stderr of each \\\n+             task, allow printing directly\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"test-threads\",\n+            \"Number of threads used for running tests \\\n+             in parallel\",\n+            \"n_threads\",\n+        )\n+        .optmulti(\n+            \"\",\n+            \"skip\",\n+            \"Skip tests whose names contain FILTER (this flag can \\\n+             be used multiple times)\",\n+            \"FILTER\",\n+        )\n+        .optflag(\n+            \"q\",\n+            \"quiet\",\n+            \"Display one character per test instead of one line. \\\n+             Alias to --format=terse\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"exact\",\n+            \"Exactly match filters rather than by substring\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"color\",\n+            \"Configure coloring of output:\n+            auto   = colorize if stdout is a tty and tests are run on serially (default);\n+            always = always colorize output;\n+            never  = never colorize output;\",\n+            \"auto|always|never\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"format\",\n+            \"Configure formatting of output:\n+            pretty = Print verbose output;\n+            terse  = Display one character per test;\n+            json   = Output a json document\",\n+            \"pretty|terse|json\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"show-output\",\n+            \"Show captured stdout of successful tests\"\n+        )\n+        .optopt(\n+            \"Z\",\n+            \"\",\n+            \"Enable nightly-only flags:\n+            unstable-options = Allow use of experimental features\",\n+            \"unstable-options\",\n+        )\n+        .optflagopt(\n+            \"\",\n+            \"report-time\",\n+            \"Show execution time of each test. Awailable values:\n+            plain   = do not colorize the execution time (default);\n+            colored = colorize output according to the `color` parameter value;\n+\n+            Threshold values for colorized output can be configured via\n+            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n+            `RUST_TEST_TIME_DOCTEST` environment variables.\n+\n+            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+\n+            Not available for --format=terse\",\n+            \"plain|colored\"\n+        )\n+        .optflag(\n+            \"\",\n+            \"ensure-time\",\n+            \"Treat excess of the test execution time limit as error.\n+\n+            Threshold values for this option can be configured via\n+            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n+            `RUST_TEST_TIME_DOCTEST` environment variables.\n+\n+            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+\n+            `CRITICAL_TIME` here means the limit that should not be exceeded by test.\n+            \"\n+        );\n+    return opts;\n+}\n+\n+fn usage(binary: &str, options: &getopts::Options) {\n+    let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n+    println!(\n+        r#\"{usage}\n+\n+The FILTER string is tested against the name of all tests, and only those\n+tests whose names contain the filter are run.\n+\n+By default, all tests are run in parallel. This can be altered with the\n+--test-threads flag or the RUST_TEST_THREADS environment variable when running\n+tests (set it to 1).\n+\n+All tests have their standard output and standard error captured by default.\n+This can be overridden with the --nocapture flag or setting RUST_TEST_NOCAPTURE\n+environment variable to a value other than \"0\". Logging is not captured by default.\n+\n+Test Attributes:\n+\n+    `#[test]`        - Indicates a function is a test to be run. This function\n+                       takes no arguments.\n+    `#[bench]`       - Indicates a function is a benchmark to be run. This\n+                       function takes one argument (test::Bencher).\n+    `#[should_panic]` - This function (also labeled with `#[test]`) will only pass if\n+                        the code causes a panic (an assertion failure or panic!)\n+                        A message may be provided, which the failure string must\n+                        contain: #[should_panic(expected = \"foo\")].\n+    `#[ignore]`       - When applied to a function which is already attributed as a\n+                        test, then the test runner will ignore these tests during\n+                        normal test runs. Running with --ignored or --include-ignored will run\n+                        these tests.\"#,\n+        usage = options.usage(&message)\n+    );\n+}\n+\n+/// Parses command line arguments into test options.\n+/// Returns `None` if help was requested (since we only show help message and don't run tests),\n+/// returns `Some(Err(..))` if provided arguments are incorrect,\n+/// otherwise creates a `TestOpts` object and returns it.\n+pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n+    // Parse matches.\n+    let opts = optgroups();\n+    let args = args.get(1..).unwrap_or(args);\n+    let matches = match opts.parse(args) {\n+        Ok(m) => m,\n+        Err(f) => return Some(Err(f.to_string())),\n+    };\n+\n+    // Check if help was requested.\n+    if matches.opt_present(\"h\") {\n+        // Show help and do nothing more.\n+        usage(&args[0], &opts);\n+        return None;\n+    }\n+\n+    // Actually parse the opts.\n+    let opts_result = parse_opts_impl(matches);\n+\n+    Some(opts_result)\n+}\n+\n+// Gets the option value and checks if unstable features are enabled.\n+macro_rules! unstable_optflag {\n+    ($matches:ident, $allow_unstable:ident, $option_name:literal) => {{\n+        let opt = $matches.opt_present($option_name);\n+        if !$allow_unstable && opt {\n+            return Err(format!(\n+                \"The \\\"{}\\\" flag is only accepted on the nightly compiler\",\n+                $option_name\n+            ));\n+        }\n+\n+        opt\n+    }};\n+}\n+\n+// Implementation of `parse_opts` that doesn't care about help message\n+// and returns a `Result`.\n+fn parse_opts_impl(matches: getopts::Matches) -> OptRes {\n+    let allow_unstable = get_allow_unstable(&matches)?;\n+\n+    // Unstable flags\n+    let exclude_should_panic = unstable_optflag!(matches, allow_unstable, \"exclude-should-panic\");\n+    let include_ignored = unstable_optflag!(matches, allow_unstable, \"include-ignored\");\n+    let time_options = get_time_options(&matches, allow_unstable)?;\n+\n+    let quiet = matches.opt_present(\"quiet\");\n+    let exact = matches.opt_present(\"exact\");\n+    let list = matches.opt_present(\"list\");\n+    let skip = matches.opt_strs(\"skip\");\n+\n+    let bench_benchmarks = matches.opt_present(\"bench\");\n+    let run_tests = !bench_benchmarks || matches.opt_present(\"test\");\n+\n+    let logfile = get_log_file(&matches)?;\n+    let run_ignored = get_run_ignored(&matches, include_ignored)?;\n+    let filter = get_filter(&matches)?;\n+    let nocapture = get_nocapture(&matches)?;\n+    let test_threads = get_test_threads(&matches)?;\n+    let color = get_color_config(&matches)?;\n+    let format = get_format(&matches, quiet, allow_unstable)?;\n+\n+    let options = Options::new().display_output(matches.opt_present(\"show-output\"));\n+\n+    let test_opts = TestOpts {\n+        list,\n+        filter,\n+        filter_exact: exact,\n+        exclude_should_panic,\n+        run_ignored,\n+        run_tests,\n+        bench_benchmarks,\n+        logfile,\n+        nocapture,\n+        color,\n+        format,\n+        test_threads,\n+        skip,\n+        time_options,\n+        options,\n+    };\n+\n+    Ok(test_opts)\n+}\n+\n+// FIXME: Copied from libsyntax until linkage errors are resolved. Issue #47566\n+fn is_nightly() -> bool {\n+    // Whether this is a feature-staged build, i.e., on the beta or stable channel\n+    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+    // Whether we should enable unstable features for bootstrapping\n+    let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+\n+    bootstrap || !disable_unstable_features\n+}\n+\n+// Gets the CLI options assotiated with `report-time` feature.\n+fn get_time_options(\n+    matches: &getopts::Matches,\n+    allow_unstable: bool)\n+-> OptPartRes<Option<TestTimeOptions>> {\n+    let report_time = unstable_optflag!(matches, allow_unstable, \"report-time\");\n+    let colored_opt_str = matches.opt_str(\"report-time\");\n+    let mut report_time_colored = report_time && colored_opt_str == Some(\"colored\".into());\n+    let ensure_test_time = unstable_optflag!(matches, allow_unstable, \"ensure-time\");\n+\n+    // If `ensure-test-time` option is provided, time output is enforced,\n+    // so user won't be confused if any of tests will silently fail.\n+    let options = if report_time || ensure_test_time {\n+        if ensure_test_time && !report_time {\n+            report_time_colored = true;\n+        }\n+        Some(TestTimeOptions::new_from_env(ensure_test_time, report_time_colored))\n+    } else {\n+        None\n+    };\n+\n+    Ok(options)\n+}\n+\n+fn get_test_threads(matches: &getopts::Matches) -> OptPartRes<Option<usize>> {\n+    let test_threads = match matches.opt_str(\"test-threads\") {\n+        Some(n_str) => match n_str.parse::<usize>() {\n+            Ok(0) => return Err(\"argument for --test-threads must not be 0\".to_string()),\n+            Ok(n) => Some(n),\n+            Err(e) => {\n+                return Err(format!(\n+                    \"argument for --test-threads must be a number > 0 \\\n+                     (error: {})\",\n+                    e\n+                ));\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    Ok(test_threads)\n+}\n+\n+fn get_format(\n+    matches: &getopts::Matches,\n+    quiet: bool,\n+    allow_unstable: bool\n+) -> OptPartRes<OutputFormat> {\n+    let format = match matches.opt_str(\"format\").as_ref().map(|s| &**s) {\n+        None if quiet => OutputFormat::Terse,\n+        Some(\"pretty\") | None => OutputFormat::Pretty,\n+        Some(\"terse\") => OutputFormat::Terse,\n+        Some(\"json\") => {\n+            if !allow_unstable {\n+                return Err(\n+                    \"The \\\"json\\\" format is only accepted on the nightly compiler\".into(),\n+                );\n+            }\n+            OutputFormat::Json\n+        }\n+\n+        Some(v) => {\n+            return Err(format!(\n+                \"argument for --format must be pretty, terse, or json (was \\\n+                 {})\",\n+                v\n+            ));\n+        }\n+    };\n+\n+    Ok(format)\n+}\n+\n+fn get_color_config(matches: &getopts::Matches) -> OptPartRes<ColorConfig> {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n+        Some(\"auto\") | None => ColorConfig::AutoColor,\n+        Some(\"always\") => ColorConfig::AlwaysColor,\n+        Some(\"never\") => ColorConfig::NeverColor,\n+\n+        Some(v) => {\n+            return Err(format!(\n+                \"argument for --color must be auto, always, or never (was \\\n+                 {})\",\n+                v\n+            ));\n+        }\n+    };\n+\n+    Ok(color)\n+}\n+\n+fn get_nocapture(matches: &getopts::Matches) -> OptPartRes<bool> {\n+    let mut nocapture = matches.opt_present(\"nocapture\");\n+    if !nocapture {\n+        nocapture = match env::var(\"RUST_TEST_NOCAPTURE\") {\n+            Ok(val) => &val != \"0\",\n+            Err(_) => false,\n+        };\n+    }\n+\n+    Ok(nocapture)\n+}\n+\n+fn get_run_ignored(matches: &getopts::Matches, include_ignored: bool) -> OptPartRes<RunIgnored> {\n+    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n+        (true, true) => {\n+            return Err(\n+                \"the options --include-ignored and --ignored are mutually exclusive\".into(),\n+            );\n+        }\n+        (true, false) => RunIgnored::Yes,\n+        (false, true) => RunIgnored::Only,\n+        (false, false) => RunIgnored::No,\n+    };\n+\n+    Ok(run_ignored)\n+}\n+\n+fn get_filter(matches: &getopts::Matches) -> OptPartRes<Option<String>> {\n+    let filter = if !matches.free.is_empty() {\n+        Some(matches.free[0].clone())\n+    } else {\n+        None\n+    };\n+\n+    Ok(filter)\n+}\n+\n+fn get_allow_unstable(matches: &getopts::Matches) -> OptPartRes<bool> {\n+    let mut allow_unstable = false;\n+\n+    if let Some(opt) = matches.opt_str(\"Z\") {\n+        if !is_nightly() {\n+            return Err(\n+                \"the option `Z` is only accepted on the nightly compiler\".into(),\n+            );\n+        }\n+\n+        match &*opt {\n+            \"unstable-options\" => {\n+                allow_unstable = true;\n+            }\n+            _ => {\n+                return Err(\"Unrecognized option to `Z`\".into());\n+            }\n+        }\n+    };\n+\n+    Ok(allow_unstable)\n+}\n+\n+fn get_log_file(matches: &getopts::Matches) -> OptPartRes<Option<PathBuf>> {\n+    let logfile = matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s));\n+\n+    Ok(logfile)\n+}"}, {"sha": "e17030726ceaa0e721b828bcdcc7a349602a72b6", "filename": "src/libtest/console.rs", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fconsole.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,308 @@\n+//! Module providing interface for running tests in the console.\n+\n+use std::fs::File;\n+use std::io::prelude::Write;\n+use std::io;\n+\n+use term;\n+\n+use super::{\n+    bench::fmt_bench_samples,\n+    cli::TestOpts,\n+    event::{TestEvent, CompletedTest},\n+    formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter},\n+    helpers::{\n+        concurrency::get_concurrency,\n+        metrics::MetricMap,\n+    },\n+    types::{TestDesc, TestDescAndFn, NamePadding},\n+    options::{Options, OutputFormat},\n+    test_result::TestResult,\n+    time::TestExecTime,\n+    run_tests,\n+    filter_tests,\n+};\n+\n+/// Generic wrapper over stdout.\n+pub enum OutputLocation<T> {\n+    Pretty(Box<term::StdoutTerminal>),\n+    Raw(T),\n+}\n+\n+impl<T: Write> Write for OutputLocation<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        match *self {\n+            OutputLocation::Pretty(ref mut term) => term.write(buf),\n+            OutputLocation::Raw(ref mut stdout) => stdout.write(buf),\n+        }\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        match *self {\n+            OutputLocation::Pretty(ref mut term) => term.flush(),\n+            OutputLocation::Raw(ref mut stdout) => stdout.flush(),\n+        }\n+    }\n+}\n+\n+pub struct ConsoleTestState {\n+    pub log_out: Option<File>,\n+    pub total: usize,\n+    pub passed: usize,\n+    pub failed: usize,\n+    pub ignored: usize,\n+    pub allowed_fail: usize,\n+    pub filtered_out: usize,\n+    pub measured: usize,\n+    pub metrics: MetricMap,\n+    pub failures: Vec<(TestDesc, Vec<u8>)>,\n+    pub not_failures: Vec<(TestDesc, Vec<u8>)>,\n+    pub time_failures: Vec<(TestDesc, Vec<u8>)>,\n+    pub options: Options,\n+}\n+\n+impl ConsoleTestState {\n+    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n+        let log_out = match opts.logfile {\n+            Some(ref path) => Some(File::create(path)?),\n+            None => None,\n+        };\n+\n+        Ok(ConsoleTestState {\n+            log_out,\n+            total: 0,\n+            passed: 0,\n+            failed: 0,\n+            ignored: 0,\n+            allowed_fail: 0,\n+            filtered_out: 0,\n+            measured: 0,\n+            metrics: MetricMap::new(),\n+            failures: Vec::new(),\n+            not_failures: Vec::new(),\n+            time_failures: Vec::new(),\n+            options: opts.options,\n+        })\n+    }\n+\n+    pub fn write_log<F, S>(\n+        &mut self,\n+        msg: F,\n+    ) -> io::Result<()>\n+    where\n+        S: AsRef<str>,\n+        F: FnOnce() -> S,\n+    {\n+        match self.log_out {\n+            None => Ok(()),\n+            Some(ref mut o) => {\n+                let msg = msg();\n+                let msg = msg.as_ref();\n+                o.write_all(msg.as_bytes())\n+            },\n+        }\n+    }\n+\n+    pub fn write_log_result(&mut self,test: &TestDesc,\n+        result: &TestResult,\n+        exec_time: Option<&TestExecTime>,\n+    ) -> io::Result<()> {\n+        self.write_log(|| format!(\n+            \"{} {}\",\n+            match *result {\n+                TestResult::TrOk => \"ok\".to_owned(),\n+                TestResult::TrFailed => \"failed\".to_owned(),\n+                TestResult::TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n+                TestResult::TrIgnored => \"ignored\".to_owned(),\n+                TestResult::TrAllowedFail => \"failed (allowed)\".to_owned(),\n+                TestResult::TrBench(ref bs) => fmt_bench_samples(bs),\n+                TestResult::TrTimedFail => \"failed (time limit exceeded)\".to_owned(),\n+            },\n+            test.name,\n+        ))?;\n+        if let Some(exec_time) = exec_time {\n+            self.write_log(|| format!(\" <{}>\", exec_time))?;\n+        }\n+        self.write_log(|| \"\\n\")\n+    }\n+\n+    fn current_test_count(&self) -> usize {\n+        self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n+    }\n+}\n+\n+// List the tests to console, and optionally to logfile. Filters are honored.\n+pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n+    let mut output = match term::stdout() {\n+        None => OutputLocation::Raw(io::stdout()),\n+        Some(t) => OutputLocation::Pretty(t),\n+    };\n+\n+    let quiet = opts.format == OutputFormat::Terse;\n+    let mut st = ConsoleTestState::new(opts)?;\n+\n+    let mut ntest = 0;\n+    let mut nbench = 0;\n+\n+    for test in filter_tests(&opts, tests) {\n+        use crate::TestFn::*;\n+\n+        let TestDescAndFn {\n+            desc: TestDesc { name, .. },\n+            testfn,\n+        } = test;\n+\n+        let fntype = match testfn {\n+            StaticTestFn(..) | DynTestFn(..) => {\n+                ntest += 1;\n+                \"test\"\n+            }\n+            StaticBenchFn(..) | DynBenchFn(..) => {\n+                nbench += 1;\n+                \"benchmark\"\n+            }\n+        };\n+\n+        writeln!(output, \"{}: {}\", name, fntype)?;\n+        st.write_log(|| format!(\"{} {}\\n\", fntype, name))?;\n+    }\n+\n+    fn plural(count: u32, s: &str) -> String {\n+        match count {\n+            1 => format!(\"{} {}\", 1, s),\n+            n => format!(\"{} {}s\", n, s),\n+        }\n+    }\n+\n+    if !quiet {\n+        if ntest != 0 || nbench != 0 {\n+            writeln!(output, \"\")?;\n+        }\n+\n+        writeln!(\n+            output,\n+            \"{}, {}\",\n+            plural(ntest, \"test\"),\n+            plural(nbench, \"benchmark\")\n+        )?;\n+    }\n+\n+    Ok(())\n+}\n+\n+// Updates `ConsoleTestState` depending on result of the test execution.\n+fn handle_test_result(st: &mut ConsoleTestState, completed_test: CompletedTest) {\n+    let test = completed_test.desc;\n+    let stdout = completed_test.stdout;\n+    match completed_test.result {\n+        TestResult::TrOk => {\n+            st.passed += 1;\n+            st.not_failures.push((test, stdout));\n+        }\n+        TestResult::TrIgnored => st.ignored += 1,\n+        TestResult::TrAllowedFail => st.allowed_fail += 1,\n+        TestResult::TrBench(bs) => {\n+            st.metrics.insert_metric(\n+                test.name.as_slice(),\n+                bs.ns_iter_summ.median,\n+                bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n+            );\n+            st.measured += 1\n+        }\n+        TestResult::TrFailed => {\n+            st.failed += 1;\n+            st.failures.push((test, stdout));\n+        }\n+        TestResult::TrFailedMsg(msg) => {\n+            st.failed += 1;\n+            let mut stdout = stdout;\n+            stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n+            st.failures.push((test, stdout));\n+        }\n+        TestResult::TrTimedFail => {\n+            st.failed += 1;\n+            st.time_failures.push((test, stdout));\n+        }\n+    }\n+}\n+\n+// Handler for events that occur during test execution.\n+// It is provided as a callback to the `run_tests` function.\n+fn on_test_event(\n+    event: &TestEvent,\n+    st: &mut ConsoleTestState,\n+    out: &mut dyn OutputFormatter,\n+) -> io::Result<()> {\n+    match (*event).clone() {\n+        TestEvent::TeFiltered(ref filtered_tests) => {\n+            st.total = filtered_tests.len();\n+            out.write_run_start(filtered_tests.len())?;\n+        }\n+        TestEvent::TeFilteredOut(filtered_out) => {\n+            st.filtered_out = filtered_out;\n+        }\n+        TestEvent::TeWait(ref test) => out.write_test_start(test)?,\n+        TestEvent::TeTimeout(ref test) => out.write_timeout(test)?,\n+        TestEvent::TeResult(completed_test) => {\n+            let test = &completed_test.desc;\n+            let result = &completed_test.result;\n+            let exec_time = &completed_test.exec_time;\n+            let stdout = &completed_test.stdout;\n+\n+            st.write_log_result(test, result, exec_time.as_ref())?;\n+            out.write_result(test, result, exec_time.as_ref(), &*stdout, st)?;\n+            handle_test_result(st, completed_test);\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+/// A simple console test runner.\n+/// Runs provided tests reporting process and results to the stdout.\n+pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n+    let output = match term::stdout() {\n+        None => OutputLocation::Raw(io::stdout()),\n+        Some(t) => OutputLocation::Pretty(t),\n+    };\n+\n+    let max_name_len = tests\n+        .iter()\n+        .max_by_key(|t| len_if_padded(*t))\n+        .map(|t| t.desc.name.as_slice().len())\n+        .unwrap_or(0);\n+\n+    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n+\n+    let mut out: Box<dyn OutputFormatter> = match opts.format {\n+        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n+            output,\n+            opts.use_color(),\n+            max_name_len,\n+            is_multithreaded,\n+            opts.time_options,\n+        )),\n+        OutputFormat::Terse => Box::new(TerseFormatter::new(\n+            output,\n+            opts.use_color(),\n+            max_name_len,\n+            is_multithreaded,\n+        )),\n+        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n+    };\n+    let mut st = ConsoleTestState::new(opts)?;\n+\n+    run_tests(opts, tests, |x| on_test_event(&x, &mut st, &mut *out))?;\n+\n+    assert!(st.current_test_count() == st.total);\n+\n+    return out.write_run_finish(&st);\n+}\n+\n+// Calculates padding for given test description.\n+fn len_if_padded(t: &TestDescAndFn) -> usize {\n+    match t.testfn.padding() {\n+        NamePadding::PadNone => 0,\n+        NamePadding::PadOnRight => t.desc.name.as_slice().len(),\n+    }\n+}"}, {"sha": "eefbd2d6a813a5804ddd0d6926058f1cc26d683b", "filename": "src/libtest/event.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fevent.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,41 @@\n+//! Module containing different events that can occur\n+//! during tests execution process.\n+\n+use super::types::TestDesc;\n+use super::test_result::TestResult;\n+use super::time::TestExecTime;\n+\n+#[derive(Debug, Clone)]\n+pub struct CompletedTest {\n+    pub desc: TestDesc,\n+    pub result: TestResult,\n+    pub exec_time: Option<TestExecTime>,\n+    pub stdout: Vec<u8>,\n+}\n+\n+impl CompletedTest {\n+    pub fn new(\n+        desc: TestDesc,\n+        result: TestResult,\n+        exec_time: Option<TestExecTime>,\n+        stdout: Vec<u8>\n+    ) -> Self {\n+        Self {\n+            desc,\n+            result,\n+            exec_time,\n+            stdout,\n+        }\n+    }\n+}\n+\n+unsafe impl Send for CompletedTest {}\n+\n+#[derive(Debug, Clone)]\n+pub enum TestEvent {\n+    TeFiltered(Vec<TestDesc>),\n+    TeWait(TestDesc),\n+    TeResult(CompletedTest),\n+    TeTimeout(TestDesc),\n+    TeFilteredOut(usize),\n+}"}, {"sha": "b73d7349678a720c81f519ca233d7997e4452e8b", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,4 +1,16 @@\n-use super::*;\n+use std::{\n+    io,\n+    io::prelude::Write,\n+    borrow::Cow,\n+};\n+\n+use crate::{\n+    types::TestDesc,\n+    time,\n+    test_result::TestResult,\n+    console::{ConsoleTestState, OutputLocation},\n+};\n+use super::OutputFormatter;\n \n pub(crate) struct JsonFormatter<T> {\n     out: OutputLocation<T>,\n@@ -27,7 +39,7 @@ impl<T: Write> JsonFormatter<T> {\n         ty: &str,\n         name: &str,\n         evt: &str,\n-        exec_time: Option<&TestExecTime>,\n+        exec_time: Option<&time::TestExecTime>,\n         stdout: Option<Cow<'_, str>>,\n         extra: Option<&str>,\n     ) -> io::Result<()> {\n@@ -76,25 +88,26 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n         &mut self,\n         desc: &TestDesc,\n         result: &TestResult,\n-        exec_time: Option<&TestExecTime>,\n+        exec_time: Option<&time::TestExecTime>,\n         stdout: &[u8],\n         state: &ConsoleTestState,\n     ) -> io::Result<()> {\n-        let stdout = if (state.options.display_output || *result != TrOk) && stdout.len() > 0 {\n+        let display_stdout = state.options.display_output || *result != TestResult::TrOk;\n+        let stdout = if display_stdout && stdout.len() > 0 {\n             Some(String::from_utf8_lossy(stdout))\n         } else {\n             None\n         };\n         match *result {\n-            TrOk => {\n+            TestResult::TrOk => {\n                 self.write_event(\"test\", desc.name.as_slice(), \"ok\", exec_time, stdout, None)\n             }\n \n-            TrFailed => {\n+            TestResult::TrFailed => {\n                 self.write_event(\"test\", desc.name.as_slice(), \"failed\", exec_time, stdout, None)\n             }\n \n-            TrTimedFail => self.write_event(\n+            TestResult::TrTimedFail => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),\n                 \"failed\",\n@@ -103,7 +116,7 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 Some(r#\"\"reason\": \"time limit exceeded\"\"#),\n             ),\n \n-            TrFailedMsg(ref m) => self.write_event(\n+            TestResult::TrFailedMsg(ref m) => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),\n                 \"failed\",\n@@ -112,11 +125,11 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 Some(&*format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n             ),\n \n-            TrIgnored => {\n+            TestResult::TrIgnored => {\n                 self.write_event(\"test\", desc.name.as_slice(), \"ignored\", exec_time, stdout, None)\n             }\n \n-            TrAllowedFail => self.write_event(\n+            TestResult::TrAllowedFail => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),\n                 \"allowed_failure\",\n@@ -125,7 +138,7 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 None,\n             ),\n \n-            TrBench(ref bs) => {\n+            TestResult::TrBench(ref bs) => {\n                 let median = bs.ns_iter_summ.median as usize;\n                 let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n "}, {"sha": "b6649a3effc7c6ea048ac668969cfaa13c7b6d7c", "filename": "src/libtest/formatters/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,4 +1,14 @@\n-use super::*;\n+use std::{\n+    io,\n+    io::prelude::Write,\n+};\n+\n+use crate::{\n+    types::{TestDesc, TestName},\n+    time,\n+    test_result::TestResult,\n+    console::{ConsoleTestState},\n+};\n \n mod pretty;\n mod json;\n@@ -16,7 +26,7 @@ pub(crate) trait OutputFormatter {\n         &mut self,\n         desc: &TestDesc,\n         result: &TestResult,\n-        exec_time: Option<&TestExecTime>,\n+        exec_time: Option<&time::TestExecTime>,\n         stdout: &[u8],\n         state: &ConsoleTestState,\n     ) -> io::Result<()>;"}, {"sha": "2fdbc63d51330eb7f464d0849ee20d83566bc717", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,9 +1,21 @@\n-use super::*;\n+use std::{\n+    io,\n+    io::prelude::Write,\n+};\n+\n+use crate::{\n+    types::TestDesc,\n+    time,\n+    test_result::TestResult,\n+    console::{ConsoleTestState, OutputLocation},\n+    bench::fmt_bench_samples,\n+};\n+use super::OutputFormatter;\n \n pub(crate) struct PrettyFormatter<T> {\n     out: OutputLocation<T>,\n     use_color: bool,\n-    time_options: Option<TestTimeOptions>,\n+    time_options: Option<time::TestTimeOptions>,\n \n     /// Number of columns to fill when aligning names\n     max_name_len: usize,\n@@ -17,7 +29,7 @@ impl<T: Write> PrettyFormatter<T> {\n         use_color: bool,\n         max_name_len: usize,\n         is_multithreaded: bool,\n-        time_options: Option<TestTimeOptions>,\n+        time_options: Option<time::TestTimeOptions>,\n     ) -> Self {\n         PrettyFormatter {\n             out,\n@@ -67,7 +79,7 @@ impl<T: Write> PrettyFormatter<T> {\n \n     pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n         match self.out {\n-            Pretty(ref mut term) => {\n+            OutputLocation::Pretty(ref mut term) => {\n                 if self.use_color {\n                     term.fg(color)?;\n                 }\n@@ -77,7 +89,7 @@ impl<T: Write> PrettyFormatter<T> {\n                 }\n                 term.flush()\n             }\n-            Raw(ref mut stdout) => {\n+            OutputLocation::Raw(ref mut stdout) => {\n                 stdout.write_all(word.as_bytes())?;\n                 stdout.flush()\n             }\n@@ -93,7 +105,7 @@ impl<T: Write> PrettyFormatter<T> {\n     fn write_time(\n         &mut self,\n         desc: &TestDesc,\n-        exec_time: Option<&TestExecTime>\n+        exec_time: Option<&time::TestExecTime>\n     ) -> io::Result<()> {\n         if let (Some(opts), Some(time)) = (self.time_options, exec_time) {\n             let time_str = format!(\" <{}>\", time);\n@@ -194,7 +206,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         &mut self,\n         desc: &TestDesc,\n         result: &TestResult,\n-        exec_time: Option<&TestExecTime>,\n+        exec_time: Option<&time::TestExecTime>,\n         _: &[u8],\n         _: &ConsoleTestState,\n     ) -> io::Result<()> {\n@@ -203,15 +215,15 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         }\n \n         match *result {\n-            TrOk => self.write_ok()?,\n-            TrFailed | TrFailedMsg(_) => self.write_failed()?,\n-            TrIgnored => self.write_ignored()?,\n-            TrAllowedFail => self.write_allowed_fail()?,\n-            TrBench(ref bs) => {\n+            TestResult::TrOk => self.write_ok()?,\n+            TestResult::TrFailed | TestResult::TrFailedMsg(_) => self.write_failed()?,\n+            TestResult::TrIgnored => self.write_ignored()?,\n+            TestResult::TrAllowedFail => self.write_allowed_fail()?,\n+            TestResult::TrBench(ref bs) => {\n                 self.write_bench()?;\n                 self.write_plain(&format!(\": {}\", fmt_bench_samples(bs)))?;\n             }\n-            TrTimedFail => self.write_time_failed()?,\n+            TestResult::TrTimedFail => self.write_time_failed()?,\n         }\n \n         self.write_time(desc, exec_time)?;\n@@ -225,7 +237,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n \n         self.write_plain(&format!(\n             \"test {} has been running for over {} seconds\\n\",\n-            desc.name, TEST_WARN_TIMEOUT_S\n+            desc.name, time::TEST_WARN_TIMEOUT_S\n         ))\n     }\n "}, {"sha": "fe56157d9c10a2624f88f3b846621387daf331eb", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,4 +1,20 @@\n-use super::*;\n+use std::{\n+    io,\n+    io::prelude::Write,\n+};\n+\n+use crate::{\n+    types::TestDesc,\n+    time,\n+    test_result::TestResult,\n+    types::NamePadding,\n+    console::{ConsoleTestState, OutputLocation},\n+    bench::fmt_bench_samples,\n+};\n+use super::OutputFormatter;\n+\n+// insert a '\\n' after 100 tests in quiet mode\n+const QUIET_MODE_MAX_COLUMN: usize = 100;\n \n pub(crate) struct TerseFormatter<T> {\n     out: OutputLocation<T>,\n@@ -68,7 +84,7 @@ impl<T: Write> TerseFormatter<T> {\n \n     pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n         match self.out {\n-            Pretty(ref mut term) => {\n+            OutputLocation::Pretty(ref mut term) => {\n                 if self.use_color {\n                     term.fg(color)?;\n                 }\n@@ -78,7 +94,7 @@ impl<T: Write> TerseFormatter<T> {\n                 }\n                 term.flush()\n             }\n-            Raw(ref mut stdout) => {\n+            OutputLocation::Raw(ref mut stdout) => {\n                 stdout.write_all(word.as_bytes())?;\n                 stdout.flush()\n             }\n@@ -163,7 +179,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         // in order to indicate benchmarks.\n         // When running benchmarks, terse-mode should still print their name as if\n         // it is the Pretty formatter.\n-        if !self.is_multithreaded && desc.name.padding() == PadOnRight {\n+        if !self.is_multithreaded && desc.name.padding() == NamePadding::PadOnRight {\n             self.write_test_name(desc)?;\n         }\n \n@@ -174,16 +190,18 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         &mut self,\n         desc: &TestDesc,\n         result: &TestResult,\n-        _: Option<&TestExecTime>,\n+        _: Option<&time::TestExecTime>,\n         _: &[u8],\n         _: &ConsoleTestState,\n     ) -> io::Result<()> {\n         match *result {\n-            TrOk => self.write_ok(),\n-            TrFailed | TrFailedMsg(_) | TrTimedFail => self.write_failed(),\n-            TrIgnored => self.write_ignored(),\n-            TrAllowedFail => self.write_allowed_fail(),\n-            TrBench(ref bs) => {\n+            TestResult::TrOk => self.write_ok(),\n+            TestResult::TrFailed\n+                | TestResult::TrFailedMsg(_)\n+                | TestResult::TrTimedFail => self.write_failed(),\n+            TestResult::TrIgnored => self.write_ignored(),\n+            TestResult::TrAllowedFail => self.write_allowed_fail(),\n+            TestResult::TrBench(ref bs) => {\n                 if self.is_multithreaded {\n                     self.write_test_name(desc)?;\n                 }\n@@ -196,7 +214,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n         self.write_plain(&format!(\n             \"test {} has been running for over {} seconds\\n\",\n-            desc.name, TEST_WARN_TIMEOUT_S\n+            desc.name, time::TEST_WARN_TIMEOUT_S\n         ))\n     }\n "}, {"sha": "61651a927c5f7aea2222b461d33d64f8610ccc25", "filename": "src/libtest/helpers/concurrency.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fconcurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fconcurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fconcurrency.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,143 @@\n+//! Helper module which helps to determine amount of threads to be used\n+//! during tests execution.\n+use std::env;\n+\n+#[allow(deprecated)]\n+pub fn get_concurrency() -> usize {\n+    return match env::var(\"RUST_TEST_THREADS\") {\n+        Ok(s) => {\n+            let opt_n: Option<usize> = s.parse().ok();\n+            match opt_n {\n+                Some(n) if n > 0 => n,\n+                _ => panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\", s),\n+            }\n+        }\n+        Err(..) => num_cpus(),\n+    };\n+\n+    #[cfg(windows)]\n+    #[allow(nonstandard_style)]\n+    fn num_cpus() -> usize {\n+        #[repr(C)]\n+        struct SYSTEM_INFO {\n+            wProcessorArchitecture: u16,\n+            wReserved: u16,\n+            dwPageSize: u32,\n+            lpMinimumApplicationAddress: *mut u8,\n+            lpMaximumApplicationAddress: *mut u8,\n+            dwActiveProcessorMask: *mut u8,\n+            dwNumberOfProcessors: u32,\n+            dwProcessorType: u32,\n+            dwAllocationGranularity: u32,\n+            wProcessorLevel: u16,\n+            wProcessorRevision: u16,\n+        }\n+        extern \"system\" {\n+            fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n+        }\n+        unsafe {\n+            let mut sysinfo = std::mem::zeroed();\n+            GetSystemInfo(&mut sysinfo);\n+            sysinfo.dwNumberOfProcessors as usize\n+        }\n+    }\n+\n+    #[cfg(target_os = \"vxworks\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: Implement num_cpus on vxWorks\n+        1\n+    }\n+\n+    #[cfg(target_os = \"redox\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: Implement num_cpus on Redox\n+        1\n+    }\n+\n+    #[cfg(any(\n+        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\")\n+    ))]\n+    fn num_cpus() -> usize {\n+        1\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"cloudabi\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"solaris\",\n+    ))]\n+    fn num_cpus() -> usize {\n+        unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n+    }\n+\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))]\n+    fn num_cpus() -> usize {\n+        use std::ptr;\n+\n+        let mut cpus: libc::c_uint = 0;\n+        let mut cpus_size = std::mem::size_of_val(&cpus);\n+\n+        unsafe {\n+            cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n+        }\n+        if cpus < 1 {\n+            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+            unsafe {\n+                libc::sysctl(\n+                    mib.as_mut_ptr(),\n+                    2,\n+                    &mut cpus as *mut _ as *mut _,\n+                    &mut cpus_size as *mut _ as *mut _,\n+                    ptr::null_mut(),\n+                    0,\n+                );\n+            }\n+            if cpus < 1 {\n+                cpus = 1;\n+            }\n+        }\n+        cpus as usize\n+    }\n+\n+    #[cfg(target_os = \"openbsd\")]\n+    fn num_cpus() -> usize {\n+        use std::ptr;\n+\n+        let mut cpus: libc::c_uint = 0;\n+        let mut cpus_size = std::mem::size_of_val(&cpus);\n+        let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+\n+        unsafe {\n+            libc::sysctl(\n+                mib.as_mut_ptr(),\n+                2,\n+                &mut cpus as *mut _ as *mut _,\n+                &mut cpus_size as *mut _ as *mut _,\n+                ptr::null_mut(),\n+                0,\n+            );\n+        }\n+        if cpus < 1 {\n+            cpus = 1;\n+        }\n+        cpus as usize\n+    }\n+\n+    #[cfg(target_os = \"haiku\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: implement\n+        1\n+    }\n+\n+    #[cfg(target_os = \"l4re\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: implement\n+        1\n+    }\n+}"}, {"sha": "831bef3b118ac1500f695885c0a9795faf77485d", "filename": "src/libtest/helpers/exit_code.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fexit_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fexit_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fexit_code.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,20 @@\n+//! Helper module to detect subprocess exit code.\n+\n+use std::process::ExitStatus;\n+\n+#[cfg(not(unix))]\n+pub fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n+    status.code().ok_or(\"received no exit code from child process\".into())\n+}\n+\n+#[cfg(unix)]\n+pub fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n+    use std::os::unix::process::ExitStatusExt;\n+    match status.code() {\n+        Some(code) => Ok(code),\n+        None => match status.signal() {\n+            Some(signal) => Err(format!(\"child process exited with signal {}\", signal)),\n+            None => Err(\"child process exited with unknown signal\".into()),\n+        }\n+    }\n+}"}, {"sha": "6e4954778e60523c90cd4011cbad0be3951b9bb4", "filename": "src/libtest/helpers/isatty.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fisatty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fisatty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fisatty.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,33 @@\n+//! Helper module which provides a function to test\n+//! if stdout is a tty.\n+\n+#[cfg(any(\n+    target_os = \"cloudabi\",\n+    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+    all(target_vendor = \"fortanix\", target_env = \"sgx\")\n+))]\n+pub fn stdout_isatty() -> bool {\n+    // FIXME: Implement isatty on SGX\n+    false\n+}\n+#[cfg(unix)]\n+pub fn stdout_isatty() -> bool {\n+    unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n+}\n+#[cfg(windows)]\n+pub fn stdout_isatty() -> bool {\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    type HANDLE = *mut u8;\n+    type LPDWORD = *mut u32;\n+    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n+    extern \"system\" {\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n+        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n+    }\n+    unsafe {\n+        let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n+        let mut out = 0;\n+        GetConsoleMode(handle, &mut out) != 0\n+    }\n+}"}, {"sha": "f77a23e6875b2c1b6a65e1d00a9169c8872fec47", "filename": "src/libtest/helpers/metrics.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fmetrics.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,50 @@\n+//! Benchmark metrics.\n+use std::collections::BTreeMap;\n+\n+#[derive(Clone, PartialEq, Debug, Copy)]\n+pub struct Metric {\n+    value: f64,\n+    noise: f64,\n+}\n+\n+impl Metric {\n+    pub fn new(value: f64, noise: f64) -> Metric {\n+        Metric { value, noise }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq)]\n+pub struct MetricMap(BTreeMap<String, Metric>);\n+\n+impl MetricMap {\n+    pub fn new() -> MetricMap {\n+        MetricMap(BTreeMap::new())\n+    }\n+\n+    /// Insert a named `value` (+/- `noise`) metric into the map. The value\n+    /// must be non-negative. The `noise` indicates the uncertainty of the\n+    /// metric, which doubles as the \"noise range\" of acceptable\n+    /// pairwise-regressions on this named value, when comparing from one\n+    /// metric to the next using `compare_to_old`.\n+    ///\n+    /// If `noise` is positive, then it means this metric is of a value\n+    /// you want to see grow smaller, so a change larger than `noise` in the\n+    /// positive direction represents a regression.\n+    ///\n+    /// If `noise` is negative, then it means this metric is of a value\n+    /// you want to see grow larger, so a change larger than `noise` in the\n+    /// negative direction represents a regression.\n+    pub fn insert_metric(&mut self, name: &str, value: f64, noise: f64) {\n+        let m = Metric { value, noise };\n+        self.0.insert(name.to_owned(), m);\n+    }\n+\n+    pub fn fmt_metrics(&self) -> String {\n+        let v = self\n+            .0\n+            .iter()\n+            .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n+            .collect::<Vec<_>>();\n+        v.join(\", \")\n+    }\n+}"}, {"sha": "6a2ef6086cb92b55273655c8078ca93d79b6fc47", "filename": "src/libtest/helpers/mod.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fmod.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,8 @@\n+//! Module with common helpers not directly related to tests\n+//! but used in `libtest`.\n+\n+pub mod concurrency;\n+pub mod isatty;\n+pub mod metrics;\n+pub mod sink;\n+pub mod exit_code;"}, {"sha": "aa7fe2487730e3aa28b451ef91bd35103fda7aea", "filename": "src/libtest/helpers/sink.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fsink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fhelpers%2Fsink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fsink.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,24 @@\n+//! Module providing a helper structure to capture output in subprocesses.\n+\n+use std::{\n+    io,\n+    io::prelude::Write,\n+    sync::{Arc, Mutex},\n+};\n+\n+pub struct Sink(Arc<Mutex<Vec<u8>>>);\n+\n+impl Sink {\n+    pub fn new_boxed(data: &Arc<Mutex<Vec<u8>>>) -> Box<Self> {\n+        Box::new(Self(data.clone()))\n+    }\n+}\n+\n+impl Write for Sink {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Write::write(&mut *self.0.lock().unwrap(), data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}"}, {"sha": "179558e8f9a184efcbe9af4ce88cdd86b336700a", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 118, "deletions": 1733, "changes": 1851, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -30,338 +30,98 @@\n #![feature(termination_trait_lib)]\n #![feature(test)]\n \n-use getopts;\n-#[cfg(any(unix, target_os = \"cloudabi\"))]\n-extern crate libc;\n-use term;\n-\n+// Public reexports\n pub use self::ColorConfig::*;\n-use self::NamePadding::*;\n-use self::OutputLocation::*;\n-use self::TestEvent::*;\n-pub use self::TestFn::*;\n-pub use self::TestName::*;\n-pub use self::TestResult::*;\n-\n-use std::any::Any;\n-use std::borrow::Cow;\n-use std::cmp;\n-use std::collections::BTreeMap;\n-use std::env;\n-use std::fmt;\n-use std::fs::File;\n-use std::io;\n-use std::io::prelude::*;\n-use std::panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo};\n-use std::path::PathBuf;\n-use std::process;\n-use std::process::{ExitStatus, Command, Termination};\n-use std::str::FromStr;\n-use std::sync::mpsc::{channel, Sender};\n-use std::sync::{Arc, Mutex};\n-use std::thread;\n-use std::time::{Duration, Instant};\n-\n-#[cfg(test)]\n-mod tests;\n-\n-const TEST_WARN_TIMEOUT_S: u64 = 60;\n-const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n-\n-const SECONDARY_TEST_INVOKER_VAR: &'static str = \"__RUST_TEST_INVOKE\";\n+pub use self::types::*;\n+pub use self::types::TestName::*;\n+pub use self::options::{Options, ShouldPanic};\n+pub use self::bench::{Bencher, black_box};\n \n-// Return codes for secondary process.\n-// Start somewhere other than 0 so we know the return code means what we think\n-// it means.\n-const TR_OK: i32 = 50;\n-const TR_FAILED: i32 = 51;\n-\n-/// This small module contains constants used by `report-time` option.\n-/// Those constants values will be used if corresponding environment variables are not set.\n-///\n-/// To override values for unit-tests, use a constant `RUST_TEST_TIME_UNIT`,\n-/// To override values for integration tests, use a constant `RUST_TEST_TIME_INTEGRATION`,\n-/// To override values for doctests, use a constant `RUST_TEST_TIME_DOCTEST`.\n-///\n-/// Example of the expected format is `RUST_TEST_TIME_xxx=100,200`, where 100 means\n-/// warn time, and 200 means critical time.\n-pub mod time_constants {\n-    use std::time::Duration;\n-    use super::TEST_WARN_TIMEOUT_S;\n-\n-    /// Environment variable for overriding default threshold for unit-tests.\n-    pub const UNIT_ENV_NAME: &str = \"RUST_TEST_TIME_UNIT\";\n-\n-    // Unit tests are supposed to be really quick.\n-    pub const UNIT_WARN: Duration = Duration::from_millis(50);\n-    pub const UNIT_CRITICAL: Duration = Duration::from_millis(100);\n-\n-    /// Environment variable for overriding default threshold for unit-tests.\n-    pub const INTEGRATION_ENV_NAME: &str = \"RUST_TEST_TIME_INTEGRATION\";\n-\n-    // Integration tests may have a lot of work, so they can take longer to execute.\n-    pub const INTEGRATION_WARN: Duration = Duration::from_millis(500);\n-    pub const INTEGRATION_CRITICAL: Duration = Duration::from_millis(1000);\n-\n-    /// Environment variable for overriding default threshold for unit-tests.\n-    pub const DOCTEST_ENV_NAME: &str = \"RUST_TEST_TIME_DOCTEST\";\n-\n-    // Doctests are similar to integration tests, because they can include a lot of\n-    // initialization code.\n-    pub const DOCTEST_WARN: Duration = INTEGRATION_WARN;\n-    pub const DOCTEST_CRITICAL: Duration = INTEGRATION_CRITICAL;\n-\n-    // Do not suppose anything about unknown tests, base limits on the\n-    // `TEST_WARN_TIMEOUT_S` constant.\n-    pub const UNKNOWN_WARN: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S);\n-    pub const UNKNOWN_CRITICAL: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S * 2);\n-}\n-\n-// to be used by rustc to compile tests in libtest\n+// Module to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use crate::{\n-        assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-        Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, RunStrategy,\n-        ShouldPanic, StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n-        TestOpts, TestTimeOptions, TestType, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n+        bench::Bencher,\n+        cli::{parse_opts, TestOpts},\n+        helpers::metrics::{Metric, MetricMap},\n+        options::{ShouldPanic, Options, RunIgnored, RunStrategy},\n+        test_result::{TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk},\n+        time::{TestTimeOptions, TestExecTime},\n+        types::{\n+            DynTestFn, DynTestName, StaticBenchFn, StaticTestFn, StaticTestName,\n+            TestDesc, TestDescAndFn, TestName, TestType,\n+        },\n+        assert_test_result, filter_tests, run_test, test_main, test_main_static,\n     };\n }\n \n-mod formatters;\n-pub mod stats;\n-\n-use crate::formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n-\n-/// Whether to execute tests concurrently or not\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Concurrent {\n-    Yes,\n-    No,\n-}\n-\n-/// Type of the test according to the [rust book](https://doc.rust-lang.org/cargo/guide/tests.html)\n-/// conventions.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum TestType {\n-    /// Unit-tests are expected to be in the `src` folder of the crate.\n-    UnitTest,\n-    /// Integration-style tests are expected to be in the `tests` folder of the crate.\n-    IntegrationTest,\n-    /// Doctests are created by the `librustdoc` manually, so it's a different type of test.\n-    DocTest,\n-    /// Tests for the sources that don't follow the project layout convention\n-    /// (e.g. tests in raw `main.rs` compiled by calling `rustc --test` directly).\n-    Unknown,\n-}\n-\n-// The name of a test. By convention this follows the rules for rust\n-// paths; i.e., it should be a series of identifiers separated by double\n-// colons. This way if some test runner wants to arrange the tests\n-// hierarchically it may.\n-\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum TestName {\n-    StaticTestName(&'static str),\n-    DynTestName(String),\n-    AlignedTestName(Cow<'static, str>, NamePadding),\n-}\n-impl TestName {\n-    fn as_slice(&self) -> &str {\n-        match *self {\n-            StaticTestName(s) => s,\n-            DynTestName(ref s) => s,\n-            AlignedTestName(ref s, _) => &*s,\n-        }\n-    }\n-\n-    fn padding(&self) -> NamePadding {\n-        match self {\n-            &AlignedTestName(_, p) => p,\n-            _ => PadNone,\n-        }\n-    }\n+use std::{\n+    env,\n+    io,\n+    io::prelude::Write,\n+    panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n+    process,\n+    process::{Command, Termination},\n+    sync::mpsc::{channel, Sender},\n+    sync::{Arc, Mutex},\n+    thread,\n+    time::{Duration, Instant},\n+};\n \n-    fn with_padding(&self, padding: NamePadding) -> TestName {\n-        let name = match self {\n-            &TestName::StaticTestName(name) => Cow::Borrowed(name),\n-            &TestName::DynTestName(ref name) => Cow::Owned(name.clone()),\n-            &TestName::AlignedTestName(ref name, _) => name.clone(),\n-        };\n-\n-        TestName::AlignedTestName(name, padding)\n-    }\n-}\n-impl fmt::Display for TestName {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self.as_slice(), f)\n-    }\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum NamePadding {\n-    PadNone,\n-    PadOnRight,\n-}\n-\n-impl TestDesc {\n-    fn padded_name(&self, column_count: usize, align: NamePadding) -> String {\n-        let mut name = String::from(self.name.as_slice());\n-        let fill = column_count.saturating_sub(name.len());\n-        let pad = \" \".repeat(fill);\n-        match align {\n-            PadNone => name,\n-            PadOnRight => {\n-                name.push_str(&pad);\n-                name\n-            }\n-        }\n-    }\n-}\n-\n-/// Represents a benchmark function.\n-pub trait TDynBenchFn: Send {\n-    fn run(&self, harness: &mut Bencher);\n-}\n-\n-// A function that runs a test. If the function returns successfully,\n-// the test succeeds; if the function panics then the test fails. We\n-// may need to come up with a more clever definition of test in order\n-// to support isolation of tests into threads.\n-pub enum TestFn {\n-    StaticTestFn(fn()),\n-    StaticBenchFn(fn(&mut Bencher)),\n-    DynTestFn(Box<dyn FnOnce() + Send>),\n-    DynBenchFn(Box<dyn TDynBenchFn + 'static>),\n-}\n-\n-impl TestFn {\n-    fn padding(&self) -> NamePadding {\n-        match *self {\n-            StaticTestFn(..) => PadNone,\n-            StaticBenchFn(..) => PadOnRight,\n-            DynTestFn(..) => PadNone,\n-            DynBenchFn(..) => PadOnRight,\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for TestFn {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(match *self {\n-            StaticTestFn(..) => \"StaticTestFn(..)\",\n-            StaticBenchFn(..) => \"StaticBenchFn(..)\",\n-            DynTestFn(..) => \"DynTestFn(..)\",\n-            DynBenchFn(..) => \"DynBenchFn(..)\",\n-        })\n-    }\n-}\n-\n-/// Manager of the benchmarking runs.\n-///\n-/// This is fed into functions marked with `#[bench]` to allow for\n-/// set-up & tear-down before running a piece of code repeatedly via a\n-/// call to `iter`.\n-#[derive(Clone)]\n-pub struct Bencher {\n-    mode: BenchMode,\n-    summary: Option<stats::Summary>,\n-    pub bytes: u64,\n-}\n-\n-#[derive(Clone, PartialEq, Eq)]\n-pub enum BenchMode {\n-    Auto,\n-    Single,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ShouldPanic {\n-    No,\n-    Yes,\n-    YesWithMessage(&'static str),\n-}\n-\n-// The definition of a single test. A test runner will run a list of\n-// these.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct TestDesc {\n-    pub name: TestName,\n-    pub ignore: bool,\n-    pub should_panic: ShouldPanic,\n-    pub allow_fail: bool,\n-    pub test_type: TestType,\n-}\n-\n-#[derive(Debug)]\n-pub struct TestDescAndFn {\n-    pub desc: TestDesc,\n-    pub testfn: TestFn,\n-}\n-\n-#[derive(Clone, PartialEq, Debug, Copy)]\n-pub struct Metric {\n-    value: f64,\n-    noise: f64,\n-}\n-\n-impl Metric {\n-    pub fn new(value: f64, noise: f64) -> Metric {\n-        Metric { value, noise }\n-    }\n-}\n+pub mod stats;\n+pub mod bench;\n+mod formatters;\n+mod cli;\n+mod console;\n+mod event;\n+mod helpers;\n+mod time;\n+mod types;\n+mod options;\n+mod test_result;\n \n-/// In case we want to add other options as well, just add them in this struct.\n-#[derive(Copy, Clone, Debug)]\n-pub struct Options {\n-    display_output: bool,\n-    panic_abort: bool,\n-}\n+#[cfg(test)]\n+mod tests;\n \n-impl Options {\n-    pub fn new() -> Options {\n-        Options {\n-            display_output: false,\n-            panic_abort: false,\n-        }\n-    }\n+use test_result::*;\n+use time::TestExecTime;\n+use options::{RunStrategy, Concurrent, RunIgnored, ColorConfig};\n+use event::{CompletedTest, TestEvent};\n+use cli::TestOpts;\n+use helpers::sink::Sink;\n+use helpers::concurrency::get_concurrency;\n+use helpers::exit_code::get_exit_code;\n \n-    pub fn display_output(mut self, display_output: bool) -> Options {\n-        self.display_output = display_output;\n-        self\n-    }\n+// Process exit code to be used to indicate test failures.\n+const ERROR_EXIT_CODE: i32 = 101;\n \n-    pub fn panic_abort(mut self, panic_abort: bool) -> Options {\n-        self.panic_abort = panic_abort;\n-        self\n-    }\n-}\n+const SECONDARY_TEST_INVOKER_VAR: &'static str = \"__RUST_TEST_INVOKE\";\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Options>) {\n-    let mut opts = match parse_opts(args) {\n+    let mut opts = match cli::parse_opts(args) {\n         Some(Ok(o)) => o,\n         Some(Err(msg)) => {\n             eprintln!(\"error: {}\", msg);\n-            process::exit(101);\n+            process::exit(ERROR_EXIT_CODE);\n         }\n         None => return,\n     };\n     if let Some(options) = options {\n         opts.options = options;\n     }\n     if opts.list {\n-        if let Err(e) = list_tests_console(&opts, tests) {\n+        if let Err(e) = console::list_tests_console(&opts, tests) {\n             eprintln!(\"error: io error when listing tests: {:?}\", e);\n-            process::exit(101);\n+            process::exit(ERROR_EXIT_CODE);\n         }\n     } else {\n-        match run_tests_console(&opts, tests) {\n+        match console::run_tests_console(&opts, tests) {\n             Ok(true) => {}\n-            Ok(false) => process::exit(101),\n+            Ok(false) => process::exit(ERROR_EXIT_CODE),\n             Err(e) => {\n                 eprintln!(\"error: io error when listing tests: {:?}\", e);\n-                process::exit(101);\n+                process::exit(ERROR_EXIT_CODE);\n             }\n         }\n     }\n@@ -440,939 +200,11 @@ pub fn assert_test_result<T: Termination>(result: T) {\n     );\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum ColorConfig {\n-    AutoColor,\n-    AlwaysColor,\n-    NeverColor,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum OutputFormat {\n-    Pretty,\n-    Terse,\n-    Json,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum RunIgnored {\n-    Yes,\n-    No,\n-    Only,\n-}\n-\n-/// Structure denoting time limits for test execution.\n-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n-pub struct TimeThreshold {\n-    pub warn: Duration,\n-    pub critical: Duration,\n-}\n-\n-impl TimeThreshold {\n-    /// Creates a new `TimeThreshold` instance with provided durations.\n-    pub fn new(warn: Duration, critical: Duration) -> Self {\n-        Self {\n-            warn,\n-            critical,\n-        }\n-    }\n-\n-    /// Attempts to create a `TimeThreshold` instance with values obtained\n-    /// from the environment variable, and returns `None` if the variable\n-    /// is not set.\n-    /// Environment variable format is expected to match `\\d+,\\d+`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if variable with provided name is set but contains inappropriate\n-    /// value.\n-    pub fn from_env_var(env_var_name: &str) -> Option<Self> {\n-        let durations_str = env::var(env_var_name).ok()?;\n-\n-        // Split string into 2 substrings by comma and try to parse numbers.\n-        let mut durations = durations_str\n-            .splitn(2, ',')\n-            .map(|v| {\n-                u64::from_str(v).unwrap_or_else(|_| {\n-                    panic!(\n-                        \"Duration value in variable {} is expected to be a number, but got {}\",\n-                        env_var_name, v\n-                    )\n-                })\n-            });\n-\n-        // Callback to be called if the environment variable has unexpected structure.\n-        let panic_on_incorrect_value = || {\n-            panic!(\n-                \"Duration variable {} expected to have 2 numbers separated by comma, but got {}\",\n-                env_var_name, durations_str\n-            );\n-        };\n-\n-        let (warn, critical) = (\n-            durations.next().unwrap_or_else(panic_on_incorrect_value),\n-            durations.next().unwrap_or_else(panic_on_incorrect_value)\n-        );\n-\n-        if warn > critical {\n-            panic!(\"Test execution warn time should be less or equal to the critical time\");\n-        }\n-\n-        Some(Self::new(Duration::from_millis(warn), Duration::from_millis(critical)))\n-    }\n-}\n-\n-/// Structure with parameters for calculating test execution time.\n-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n-pub struct TestTimeOptions {\n-    /// Denotes if the test critical execution time limit excess should be considered\n-    /// a test failure.\n-    pub error_on_excess: bool,\n-    pub colored: bool,\n-    pub unit_threshold: TimeThreshold,\n-    pub integration_threshold: TimeThreshold,\n-    pub doctest_threshold: TimeThreshold,\n-}\n-\n-impl TestTimeOptions {\n-    pub fn new_from_env(error_on_excess: bool, colored: bool) -> Self {\n-        let unit_threshold =\n-            TimeThreshold::from_env_var(time_constants::UNIT_ENV_NAME)\n-                .unwrap_or_else(Self::default_unit);\n-\n-        let integration_threshold =\n-            TimeThreshold::from_env_var(time_constants::INTEGRATION_ENV_NAME)\n-                .unwrap_or_else(Self::default_integration);\n-\n-        let doctest_threshold =\n-            TimeThreshold::from_env_var(time_constants::DOCTEST_ENV_NAME)\n-                .unwrap_or_else(Self::default_doctest);\n-\n-        Self {\n-            error_on_excess,\n-            colored,\n-            unit_threshold,\n-            integration_threshold,\n-            doctest_threshold,\n-        }\n-    }\n-\n-    pub fn is_warn(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n-        exec_time.0 >= self.warn_time(test)\n-    }\n-\n-    pub fn is_critical(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n-        exec_time.0 >= self.critical_time(test)\n-    }\n-\n-    fn warn_time(&self, test: &TestDesc) -> Duration {\n-        match test.test_type {\n-            TestType::UnitTest => self.unit_threshold.warn,\n-            TestType::IntegrationTest => self.integration_threshold.warn,\n-            TestType::DocTest => self.doctest_threshold.warn,\n-            TestType::Unknown => time_constants::UNKNOWN_WARN,\n-        }\n-    }\n-\n-    fn critical_time(&self, test: &TestDesc) -> Duration {\n-        match test.test_type {\n-            TestType::UnitTest => self.unit_threshold.critical,\n-            TestType::IntegrationTest => self.integration_threshold.critical,\n-            TestType::DocTest => self.doctest_threshold.critical,\n-            TestType::Unknown => time_constants::UNKNOWN_CRITICAL,\n-        }\n-    }\n-\n-    fn default_unit() -> TimeThreshold {\n-        TimeThreshold::new(time_constants::UNIT_WARN, time_constants::UNIT_CRITICAL)\n-    }\n-\n-    fn default_integration() -> TimeThreshold {\n-        TimeThreshold::new(time_constants::INTEGRATION_WARN, time_constants::INTEGRATION_CRITICAL)\n-    }\n-\n-    fn default_doctest() -> TimeThreshold {\n-        TimeThreshold::new(time_constants::DOCTEST_WARN, time_constants::DOCTEST_CRITICAL)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct TestOpts {\n-    pub list: bool,\n-    pub filter: Option<String>,\n-    pub filter_exact: bool,\n-    pub exclude_should_panic: bool,\n-    pub run_ignored: RunIgnored,\n-    pub run_tests: bool,\n-    pub bench_benchmarks: bool,\n-    pub logfile: Option<PathBuf>,\n-    pub nocapture: bool,\n-    pub color: ColorConfig,\n-    pub format: OutputFormat,\n-    pub test_threads: Option<usize>,\n-    pub skip: Vec<String>,\n-    pub time_options: Option<TestTimeOptions>,\n-    pub options: Options,\n-}\n-\n-/// Result of parsing the options.\n-pub type OptRes = Result<TestOpts, String>;\n-/// Result of parsing the option part.\n-type OptPartRes<T> = Result<Option<T>, String>;\n-\n-fn optgroups() -> getopts::Options {\n-    let mut opts = getopts::Options::new();\n-    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n-        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n-        .optflag(\"\", \"exclude-should-panic\", \"Excludes tests marked as should_panic\")\n-        .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n-        .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n-        .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n-        .optflag(\"h\", \"help\", \"Display this message (longer with --help)\")\n-        .optopt(\n-            \"\",\n-            \"logfile\",\n-            \"Write logs to the specified file instead \\\n-             of stdout\",\n-            \"PATH\",\n-        )\n-        .optflag(\n-            \"\",\n-            \"nocapture\",\n-            \"don't capture stdout/stderr of each \\\n-             task, allow printing directly\",\n-        )\n-        .optopt(\n-            \"\",\n-            \"test-threads\",\n-            \"Number of threads used for running tests \\\n-             in parallel\",\n-            \"n_threads\",\n-        )\n-        .optmulti(\n-            \"\",\n-            \"skip\",\n-            \"Skip tests whose names contain FILTER (this flag can \\\n-             be used multiple times)\",\n-            \"FILTER\",\n-        )\n-        .optflag(\n-            \"q\",\n-            \"quiet\",\n-            \"Display one character per test instead of one line. \\\n-             Alias to --format=terse\",\n-        )\n-        .optflag(\n-            \"\",\n-            \"exact\",\n-            \"Exactly match filters rather than by substring\",\n-        )\n-        .optopt(\n-            \"\",\n-            \"color\",\n-            \"Configure coloring of output:\n-            auto   = colorize if stdout is a tty and tests are run on serially (default);\n-            always = always colorize output;\n-            never  = never colorize output;\",\n-            \"auto|always|never\",\n-        )\n-        .optopt(\n-            \"\",\n-            \"format\",\n-            \"Configure formatting of output:\n-            pretty = Print verbose output;\n-            terse  = Display one character per test;\n-            json   = Output a json document\",\n-            \"pretty|terse|json\",\n-        )\n-        .optflag(\n-            \"\",\n-            \"show-output\",\n-            \"Show captured stdout of successful tests\"\n-        )\n-        .optopt(\n-            \"Z\",\n-            \"\",\n-            \"Enable nightly-only flags:\n-            unstable-options = Allow use of experimental features\",\n-            \"unstable-options\",\n-        )\n-        .optflagopt(\n-            \"\",\n-            \"report-time\",\n-            \"Show execution time of each test. Awailable values:\n-            plain   = do not colorize the execution time (default);\n-            colored = colorize output according to the `color` parameter value;\n-\n-            Threshold values for colorized output can be configured via\n-            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n-            `RUST_TEST_TIME_DOCTEST` environment variables.\n-\n-            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n-\n-            Not available for --format=terse\",\n-            \"plain|colored\"\n-        )\n-        .optflag(\n-            \"\",\n-            \"ensure-time\",\n-            \"Treat excess of the test execution time limit as error.\n-\n-            Threshold values for this option can be configured via\n-            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n-            `RUST_TEST_TIME_DOCTEST` environment variables.\n-\n-            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n-\n-            `CRITICAL_TIME` here means the limit that should not be exceeded by test.\n-            \"\n-        );\n-    return opts;\n-}\n-\n-fn usage(binary: &str, options: &getopts::Options) {\n-    let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n-    println!(\n-        r#\"{usage}\n-\n-The FILTER string is tested against the name of all tests, and only those\n-tests whose names contain the filter are run.\n-\n-By default, all tests are run in parallel. This can be altered with the\n---test-threads flag or the RUST_TEST_THREADS environment variable when running\n-tests (set it to 1).\n-\n-All tests have their standard output and standard error captured by default.\n-This can be overridden with the --nocapture flag or setting RUST_TEST_NOCAPTURE\n-environment variable to a value other than \"0\". Logging is not captured by default.\n-\n-Test Attributes:\n-\n-    `#[test]`        - Indicates a function is a test to be run. This function\n-                       takes no arguments.\n-    `#[bench]`       - Indicates a function is a benchmark to be run. This\n-                       function takes one argument (test::Bencher).\n-    `#[should_panic]` - This function (also labeled with `#[test]`) will only pass if\n-                        the code causes a panic (an assertion failure or panic!)\n-                        A message may be provided, which the failure string must\n-                        contain: #[should_panic(expected = \"foo\")].\n-    `#[ignore]`       - When applied to a function which is already attributed as a\n-                        test, then the test runner will ignore these tests during\n-                        normal test runs. Running with --ignored or --include-ignored will run\n-                        these tests.\"#,\n-        usage = options.usage(&message)\n-    );\n-}\n-\n-// FIXME: Copied from libsyntax until linkage errors are resolved. Issue #47566\n-fn is_nightly() -> bool {\n-    // Whether this is a feature-staged build, i.e., on the beta or stable channel\n-    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n-    // Whether we should enable unstable features for bootstrapping\n-    let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n-\n-    bootstrap || !disable_unstable_features\n-}\n-\n-// Gets the option value and checks if unstable features are enabled.\n-macro_rules! unstable_optflag {\n-    ($matches:ident, $allow_unstable:ident, $option_name:literal) => {{\n-        let opt = $matches.opt_present($option_name);\n-        if !$allow_unstable && opt {\n-            return Some(Err(format!(\n-                \"The \\\"{}\\\" flag is only accepted on the nightly compiler\",\n-                $option_name\n-            )));\n-        }\n-\n-        opt\n-    }};\n-}\n-\n-// Gets the CLI options assotiated with `report-time` feature.\n-fn get_time_options(\n-    matches: &getopts::Matches,\n-    allow_unstable: bool)\n--> Option<OptPartRes<TestTimeOptions>> {\n-    let report_time = unstable_optflag!(matches, allow_unstable, \"report-time\");\n-    let colored_opt_str = matches.opt_str(\"report-time\");\n-    let mut report_time_colored = report_time && colored_opt_str == Some(\"colored\".into());\n-    let ensure_test_time = unstable_optflag!(matches, allow_unstable, \"ensure-time\");\n-\n-    // If `ensure-test-time` option is provided, time output is enforced,\n-    // so user won't be confused if any of tests will silently fail.\n-    let options = if report_time || ensure_test_time {\n-        if ensure_test_time && !report_time {\n-            report_time_colored = true;\n-        }\n-        Some(TestTimeOptions::new_from_env(ensure_test_time, report_time_colored))\n-    } else {\n-        None\n-    };\n-\n-    Some(Ok(options))\n-}\n-\n-// Parses command line arguments into test options\n-pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n-    let mut allow_unstable = false;\n-    let opts = optgroups();\n-    let args = args.get(1..).unwrap_or(args);\n-    let matches = match opts.parse(args) {\n-        Ok(m) => m,\n-        Err(f) => return Some(Err(f.to_string())),\n-    };\n-\n-    if let Some(opt) = matches.opt_str(\"Z\") {\n-        if !is_nightly() {\n-            return Some(Err(\n-                \"the option `Z` is only accepted on the nightly compiler\".into(),\n-            ));\n-        }\n-\n-        match &*opt {\n-            \"unstable-options\" => {\n-                allow_unstable = true;\n-            }\n-            _ => {\n-                return Some(Err(\"Unrecognized option to `Z`\".into()));\n-            }\n-        }\n-    };\n-\n-    if matches.opt_present(\"h\") {\n-        usage(&args[0], &opts);\n-        return None;\n-    }\n-\n-    let filter = if !matches.free.is_empty() {\n-        Some(matches.free[0].clone())\n-    } else {\n-        None\n-    };\n-\n-    let exclude_should_panic = unstable_optflag!(matches, allow_unstable, \"exclude-should-panic\");\n-\n-    let include_ignored = unstable_optflag!(matches, allow_unstable, \"include-ignored\");\n-\n-    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n-        (true, true) => {\n-            return Some(Err(\n-                \"the options --include-ignored and --ignored are mutually exclusive\".into(),\n-            ));\n-        }\n-        (true, false) => RunIgnored::Yes,\n-        (false, true) => RunIgnored::Only,\n-        (false, false) => RunIgnored::No,\n-    };\n-    let quiet = matches.opt_present(\"quiet\");\n-    let exact = matches.opt_present(\"exact\");\n-    let list = matches.opt_present(\"list\");\n-\n-    let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map(|s| PathBuf::from(&s));\n-\n-    let bench_benchmarks = matches.opt_present(\"bench\");\n-    let run_tests = !bench_benchmarks || matches.opt_present(\"test\");\n-\n-    let mut nocapture = matches.opt_present(\"nocapture\");\n-    if !nocapture {\n-        nocapture = match env::var(\"RUST_TEST_NOCAPTURE\") {\n-            Ok(val) => &val != \"0\",\n-            Err(_) => false,\n-        };\n-    }\n-\n-    let time_options = match get_time_options(&matches, allow_unstable) {\n-        Some(Ok(val)) => val,\n-        Some(Err(e)) => return Some(Err(e)),\n-        None => panic!(\"Unexpected output from `get_time_options`\"),\n-    };\n-\n-    let test_threads = match matches.opt_str(\"test-threads\") {\n-        Some(n_str) => match n_str.parse::<usize>() {\n-            Ok(0) => return Some(Err(\"argument for --test-threads must not be 0\".to_string())),\n-            Ok(n) => Some(n),\n-            Err(e) => {\n-                return Some(Err(format!(\n-                    \"argument for --test-threads must be a number > 0 \\\n-                     (error: {})\",\n-                    e\n-                )));\n-            }\n-        },\n-        None => None,\n-    };\n-\n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n-        Some(\"auto\") | None => AutoColor,\n-        Some(\"always\") => AlwaysColor,\n-        Some(\"never\") => NeverColor,\n-\n-        Some(v) => {\n-            return Some(Err(format!(\n-                \"argument for --color must be auto, always, or never (was \\\n-                 {})\",\n-                v\n-            )));\n-        }\n-    };\n-\n-    let format = match matches.opt_str(\"format\").as_ref().map(|s| &**s) {\n-        None if quiet => OutputFormat::Terse,\n-        Some(\"pretty\") | None => OutputFormat::Pretty,\n-        Some(\"terse\") => OutputFormat::Terse,\n-        Some(\"json\") => {\n-            if !allow_unstable {\n-                return Some(Err(\n-                    \"The \\\"json\\\" format is only accepted on the nightly compiler\".into(),\n-                ));\n-            }\n-            OutputFormat::Json\n-        }\n-\n-        Some(v) => {\n-            return Some(Err(format!(\n-                \"argument for --format must be pretty, terse, or json (was \\\n-                 {})\",\n-                v\n-            )));\n-        }\n-    };\n-\n-    let test_opts = TestOpts {\n-        list,\n-        filter,\n-        filter_exact: exact,\n-        exclude_should_panic,\n-        run_ignored,\n-        run_tests,\n-        bench_benchmarks,\n-        logfile,\n-        nocapture,\n-        color,\n-        format,\n-        test_threads,\n-        skip: matches.opt_strs(\"skip\"),\n-        time_options,\n-        options: Options::new().display_output(matches.opt_present(\"show-output\")),\n-    };\n-\n-    Some(Ok(test_opts))\n-}\n-\n-#[derive(Debug, Clone, PartialEq)]\n-pub struct BenchSamples {\n-    ns_iter_summ: stats::Summary,\n-    mb_s: usize,\n-}\n-\n-#[derive(Debug, Clone, PartialEq)]\n-pub enum TestResult {\n-    TrOk,\n-    TrFailed,\n-    TrFailedMsg(String),\n-    TrIgnored,\n-    TrAllowedFail,\n-    TrBench(BenchSamples),\n-    TrTimedFail,\n-}\n-\n-unsafe impl Send for TestResult {}\n-\n-/// The meassured execution time of a unit test.\n-#[derive(Clone, PartialEq)]\n-pub struct TestExecTime(Duration);\n-\n-impl fmt::Display for TestExecTime {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:.3}s\", self.0.as_secs_f64())\n-    }\n-}\n-\n-enum OutputLocation<T> {\n-    Pretty(Box<term::StdoutTerminal>),\n-    Raw(T),\n-}\n-\n-impl<T: Write> Write for OutputLocation<T> {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        match *self {\n-            Pretty(ref mut term) => term.write(buf),\n-            Raw(ref mut stdout) => stdout.write(buf),\n-        }\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        match *self {\n-            Pretty(ref mut term) => term.flush(),\n-            Raw(ref mut stdout) => stdout.flush(),\n-        }\n-    }\n-}\n-\n-struct ConsoleTestState {\n-    log_out: Option<File>,\n-    total: usize,\n-    passed: usize,\n-    failed: usize,\n-    ignored: usize,\n-    allowed_fail: usize,\n-    filtered_out: usize,\n-    measured: usize,\n-    metrics: MetricMap,\n-    failures: Vec<(TestDesc, Vec<u8>)>,\n-    not_failures: Vec<(TestDesc, Vec<u8>)>,\n-    time_failures: Vec<(TestDesc, Vec<u8>)>,\n-    options: Options,\n-}\n-\n-impl ConsoleTestState {\n-    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n-        let log_out = match opts.logfile {\n-            Some(ref path) => Some(File::create(path)?),\n-            None => None,\n-        };\n-\n-        Ok(ConsoleTestState {\n-            log_out,\n-            total: 0,\n-            passed: 0,\n-            failed: 0,\n-            ignored: 0,\n-            allowed_fail: 0,\n-            filtered_out: 0,\n-            measured: 0,\n-            metrics: MetricMap::new(),\n-            failures: Vec::new(),\n-            not_failures: Vec::new(),\n-            time_failures: Vec::new(),\n-            options: opts.options,\n-        })\n-    }\n-\n-    pub fn write_log<F, S>(\n-        &mut self,\n-        msg: F,\n-    ) -> io::Result<()>\n-    where\n-        S: AsRef<str>,\n-        F: FnOnce() -> S,\n-    {\n-        match self.log_out {\n-            None => Ok(()),\n-            Some(ref mut o) => {\n-                let msg = msg();\n-                let msg = msg.as_ref();\n-                o.write_all(msg.as_bytes())\n-            },\n-        }\n-    }\n-\n-    pub fn write_log_result(&mut self,test: &TestDesc,\n-        result: &TestResult,\n-        exec_time: Option<&TestExecTime>,\n-    ) -> io::Result<()> {\n-        self.write_log(|| format!(\n-            \"{} {}\",\n-            match *result {\n-                TrOk => \"ok\".to_owned(),\n-                TrFailed => \"failed\".to_owned(),\n-                TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n-                TrIgnored => \"ignored\".to_owned(),\n-                TrAllowedFail => \"failed (allowed)\".to_owned(),\n-                TrBench(ref bs) => fmt_bench_samples(bs),\n-                TrTimedFail => \"failed (time limit exceeded)\".to_owned(),\n-            },\n-            test.name,\n-        ))?;\n-        if let Some(exec_time) = exec_time {\n-            self.write_log(|| format!(\" <{}>\", exec_time))?;\n-        }\n-        self.write_log(|| \"\\n\")\n-    }\n-\n-    fn current_test_count(&self) -> usize {\n-        self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n-    }\n-}\n-\n-// Format a number with thousands separators\n-fn fmt_thousands_sep(mut n: usize, sep: char) -> String {\n-    use std::fmt::Write;\n-    let mut output = String::new();\n-    let mut trailing = false;\n-    for &pow in &[9, 6, 3, 0] {\n-        let base = 10_usize.pow(pow);\n-        if pow == 0 || trailing || n / base != 0 {\n-            if !trailing {\n-                output.write_fmt(format_args!(\"{}\", n / base)).unwrap();\n-            } else {\n-                output.write_fmt(format_args!(\"{:03}\", n / base)).unwrap();\n-            }\n-            if pow != 0 {\n-                output.push(sep);\n-            }\n-            trailing = true;\n-        }\n-        n %= base;\n-    }\n-\n-    output\n-}\n-\n-pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n-    use std::fmt::Write;\n-    let mut output = String::new();\n-\n-    let median = bs.ns_iter_summ.median as usize;\n-    let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n-\n-    output\n-        .write_fmt(format_args!(\n-            \"{:>11} ns/iter (+/- {})\",\n-            fmt_thousands_sep(median, ','),\n-            fmt_thousands_sep(deviation, ',')\n-        ))\n-        .unwrap();\n-    if bs.mb_s != 0 {\n-        output\n-            .write_fmt(format_args!(\" = {} MB/s\", bs.mb_s))\n-            .unwrap();\n-    }\n-    output\n-}\n-\n-// List the tests to console, and optionally to logfile. Filters are honored.\n-pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n-    let mut output = match term::stdout() {\n-        None => Raw(io::stdout()),\n-        Some(t) => Pretty(t),\n-    };\n-\n-    let quiet = opts.format == OutputFormat::Terse;\n-    let mut st = ConsoleTestState::new(opts)?;\n-\n-    let mut ntest = 0;\n-    let mut nbench = 0;\n-\n-    for test in filter_tests(&opts, tests) {\n-        use crate::TestFn::*;\n-\n-        let TestDescAndFn {\n-            desc: TestDesc { name, .. },\n-            testfn,\n-        } = test;\n-\n-        let fntype = match testfn {\n-            StaticTestFn(..) | DynTestFn(..) => {\n-                ntest += 1;\n-                \"test\"\n-            }\n-            StaticBenchFn(..) | DynBenchFn(..) => {\n-                nbench += 1;\n-                \"benchmark\"\n-            }\n-        };\n-\n-        writeln!(output, \"{}: {}\", name, fntype)?;\n-        st.write_log(|| format!(\"{} {}\\n\", fntype, name))?;\n-    }\n-\n-    fn plural(count: u32, s: &str) -> String {\n-        match count {\n-            1 => format!(\"{} {}\", 1, s),\n-            n => format!(\"{} {}s\", n, s),\n-        }\n-    }\n-\n-    if !quiet {\n-        if ntest != 0 || nbench != 0 {\n-            writeln!(output, \"\")?;\n-        }\n-\n-        writeln!(\n-            output,\n-            \"{}, {}\",\n-            plural(ntest, \"test\"),\n-            plural(nbench, \"benchmark\")\n-        )?;\n-    }\n-\n-    Ok(())\n-}\n-\n-// A simple console test runner\n-pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n-    fn callback(\n-        event: &TestEvent,\n-        st: &mut ConsoleTestState,\n-        out: &mut dyn OutputFormatter,\n-    ) -> io::Result<()> {\n-        match (*event).clone() {\n-            TeFiltered(ref filtered_tests) => {\n-                st.total = filtered_tests.len();\n-                out.write_run_start(filtered_tests.len())\n-            }\n-            TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n-            TeWait(ref test) => out.write_test_start(test),\n-            TeTimeout(ref test) => out.write_timeout(test),\n-            TeResult(test, result, exec_time, stdout) => {\n-                st.write_log_result(&test, &result, exec_time.as_ref())?;\n-                out.write_result(&test, &result, exec_time.as_ref(), &*stdout, &st)?;\n-                match result {\n-                    TrOk => {\n-                        st.passed += 1;\n-                        st.not_failures.push((test, stdout));\n-                    }\n-                    TrIgnored => st.ignored += 1,\n-                    TrAllowedFail => st.allowed_fail += 1,\n-                    TrBench(bs) => {\n-                        st.metrics.insert_metric(\n-                            test.name.as_slice(),\n-                            bs.ns_iter_summ.median,\n-                            bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n-                        );\n-                        st.measured += 1\n-                    }\n-                    TrFailed => {\n-                        st.failed += 1;\n-                        st.failures.push((test, stdout));\n-                    }\n-                    TrFailedMsg(msg) => {\n-                        st.failed += 1;\n-                        let mut stdout = stdout;\n-                        stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n-                        st.failures.push((test, stdout));\n-                    }\n-                    TrTimedFail => {\n-                        st.failed += 1;\n-                        st.time_failures.push((test, stdout));\n-                    }\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    let output = match term::stdout() {\n-        None => Raw(io::stdout()),\n-        Some(t) => Pretty(t),\n-    };\n-\n-    let max_name_len = tests\n-        .iter()\n-        .max_by_key(|t| len_if_padded(*t))\n-        .map(|t| t.desc.name.as_slice().len())\n-        .unwrap_or(0);\n-\n-    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n-\n-    let mut out: Box<dyn OutputFormatter> = match opts.format {\n-        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n-            output,\n-            use_color(opts),\n-            max_name_len,\n-            is_multithreaded,\n-            opts.time_options,\n-        )),\n-        OutputFormat::Terse => Box::new(TerseFormatter::new(\n-            output,\n-            use_color(opts),\n-            max_name_len,\n-            is_multithreaded,\n-        )),\n-        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n-    };\n-    let mut st = ConsoleTestState::new(opts)?;\n-    fn len_if_padded(t: &TestDescAndFn) -> usize {\n-        match t.testfn.padding() {\n-            PadNone => 0,\n-            PadOnRight => t.desc.name.as_slice().len(),\n-        }\n-    }\n-\n-    run_tests(opts, tests, |x| callback(&x, &mut st, &mut *out))?;\n-\n-    assert!(st.current_test_count() == st.total);\n-\n-    return out.write_run_finish(&st);\n-}\n-\n-fn use_color(opts: &TestOpts) -> bool {\n-    match opts.color {\n-        AutoColor => !opts.nocapture && stdout_isatty(),\n-        AlwaysColor => true,\n-        NeverColor => false,\n-    }\n-}\n-\n-#[cfg(any(\n-    target_os = \"cloudabi\",\n-    target_os = \"hermit\",\n-    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-    all(target_vendor = \"fortanix\", target_env = \"sgx\")\n-))]\n-fn stdout_isatty() -> bool {\n-    // FIXME: Implement isatty on SGX\n-    false\n-}\n-#[cfg(unix)]\n-fn stdout_isatty() -> bool {\n-    unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n-}\n-#[cfg(windows)]\n-fn stdout_isatty() -> bool {\n-    type DWORD = u32;\n-    type BOOL = i32;\n-    type HANDLE = *mut u8;\n-    type LPDWORD = *mut u32;\n-    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n-    extern \"system\" {\n-        fn GetStdHandle(which: DWORD) -> HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n-    }\n-    unsafe {\n-        let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n-        let mut out = 0;\n-        GetConsoleMode(handle, &mut out) != 0\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub enum TestEvent {\n-    TeFiltered(Vec<TestDesc>),\n-    TeWait(TestDesc),\n-    TeResult(TestDesc, TestResult, Option<TestExecTime>, Vec<u8>),\n-    TeTimeout(TestDesc),\n-    TeFilteredOut(usize),\n-}\n-\n-pub type MonitorMsg = (TestDesc, TestResult, Option<TestExecTime>, Vec<u8>);\n-\n-struct Sink(Arc<Mutex<Vec<u8>>>);\n-impl Write for Sink {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Write::write(&mut *self.0.lock().unwrap(), data)\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-pub enum RunStrategy {\n-    /// Runs the test in the current process, and sends the result back over the\n-    /// supplied channel.\n-    InProcess,\n-\n-    /// Spawns a subprocess to run the test, and sends the result back over the\n-    /// supplied channel. Requires `argv[0]` to exist and point to the binary\n-    /// that's currently running.\n-    SpawnPrimary,\n-}\n-\n-pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n+pub fn run_tests<F>(\n+    opts: &TestOpts,\n+    tests: Vec<TestDescAndFn>,\n+    mut notify_about_test_event: F\n+) -> io::Result<()>\n where\n     F: FnMut(TestEvent) -> io::Result<()>,\n {\n@@ -1400,11 +232,13 @@ where\n     };\n \n     let filtered_out = tests_len - filtered_tests.len();\n-    callback(TeFilteredOut(filtered_out))?;\n+    let event = TestEvent::TeFilteredOut(filtered_out);\n+    notify_about_test_event(event)?;\n \n     let filtered_descs = filtered_tests.iter().map(|t| t.desc.clone()).collect();\n \n-    callback(TeFiltered(filtered_descs))?;\n+    let event = TestEvent::TeFiltered(filtered_descs);\n+    notify_about_test_event(event)?;\n \n     let (filtered_tests, filtered_benchs): (Vec<_>, _) =\n         filtered_tests.into_iter().partition(|e| match e.testfn {\n@@ -1418,7 +252,7 @@ where\n     remaining.reverse();\n     let mut pending = 0;\n \n-    let (tx, rx) = channel::<MonitorMsg>();\n+    let (tx, rx) = channel::<CompletedTest>();\n     let run_strategy = if opts.options.panic_abort {\n         RunStrategy::SpawnPrimary\n     } else {\n@@ -1459,18 +293,23 @@ where\n     if concurrency == 1 {\n         while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n-            callback(TeWait(test.desc.clone()))?;\n+            let event = TestEvent::TeWait(test.desc.clone());\n+            notify_about_test_event(event)?;\n             run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n-            let (test, result, exec_time, stdout) = rx.recv().unwrap();\n-            callback(TeResult(test, result, exec_time, stdout))?;\n+            let completed_test = rx.recv().unwrap();\n+\n+            let event = TestEvent::TeResult(completed_test);\n+            notify_about_test_event(event)?;\n         }\n     } else {\n         while pending > 0 || !remaining.is_empty() {\n             while pending < concurrency && !remaining.is_empty() {\n                 let test = remaining.pop().unwrap();\n-                let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n+                let timeout = time::get_default_test_timeout();\n                 running_tests.insert(test.desc.clone(), timeout);\n-                callback(TeWait(test.desc.clone()))?; //here no pad\n+\n+                let event = TestEvent::TeWait(test.desc.clone());\n+                notify_about_test_event(event)?; //here no pad\n                 run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::Yes);\n                 pending += 1;\n             }\n@@ -1480,188 +319,47 @@ where\n                 if let Some(timeout) = calc_timeout(&running_tests) {\n                     res = rx.recv_timeout(timeout);\n                     for test in get_timed_out_tests(&mut running_tests) {\n-                        callback(TeTimeout(test))?;\n+                        let event = TestEvent::TeTimeout(test);\n+                        notify_about_test_event(event)?;\n                     }\n-                    if res != Err(RecvTimeoutError::Timeout) {\n-                        break;\n+\n+                    match res {\n+                        Err(RecvTimeoutError::Timeout) => {\n+                            // Result is not yet ready, continue waiting.\n+                        }\n+                        _ => {\n+                            // We've got a result, stop the loop.\n+                            break;\n+                        }\n                     }\n                 } else {\n                     res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n                     break;\n                 }\n             }\n \n-            let (desc, result, exec_time, stdout) = res.unwrap();\n-            running_tests.remove(&desc);\n+            let completed_test = res.unwrap();\n+            running_tests.remove(&completed_test.desc);\n \n-            callback(TeResult(desc, result, exec_time, stdout))?;\n+            let event = TestEvent::TeResult(completed_test);\n+            notify_about_test_event(event)?;\n             pending -= 1;\n         }\n     }\n \n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n         for b in filtered_benchs {\n-            callback(TeWait(b.desc.clone()))?;\n+            let event = TestEvent::TeWait(b.desc.clone());\n+            notify_about_test_event(event)?;\n             run_test(opts, false, b, run_strategy, tx.clone(), Concurrent::No);\n-            let (test, result, exec_time, stdout) = rx.recv().unwrap();\n-            callback(TeResult(test, result, exec_time, stdout))?;\n-        }\n-    }\n-    Ok(())\n-}\n+            let completed_test = rx.recv().unwrap();\n \n-#[allow(deprecated)]\n-fn get_concurrency() -> usize {\n-    return match env::var(\"RUST_TEST_THREADS\") {\n-        Ok(s) => {\n-            let opt_n: Option<usize> = s.parse().ok();\n-            match opt_n {\n-                Some(n) if n > 0 => n,\n-                _ => panic!(\n-                    \"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n-                    s\n-                ),\n-            }\n-        }\n-        Err(..) => num_cpus(),\n-    };\n-\n-    #[cfg(windows)]\n-    #[allow(nonstandard_style)]\n-    fn num_cpus() -> usize {\n-        #[repr(C)]\n-        struct SYSTEM_INFO {\n-            wProcessorArchitecture: u16,\n-            wReserved: u16,\n-            dwPageSize: u32,\n-            lpMinimumApplicationAddress: *mut u8,\n-            lpMaximumApplicationAddress: *mut u8,\n-            dwActiveProcessorMask: *mut u8,\n-            dwNumberOfProcessors: u32,\n-            dwProcessorType: u32,\n-            dwAllocationGranularity: u32,\n-            wProcessorLevel: u16,\n-            wProcessorRevision: u16,\n-        }\n-        extern \"system\" {\n-            fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n+            let event = TestEvent::TeResult(completed_test);\n+            notify_about_test_event(event)?;\n         }\n-        unsafe {\n-            let mut sysinfo = std::mem::zeroed();\n-            GetSystemInfo(&mut sysinfo);\n-            sysinfo.dwNumberOfProcessors as usize\n-        }\n-    }\n-\n-    #[cfg(target_os = \"vxworks\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: Implement num_cpus on vxWorks\n-        1\n-    }\n-\n-    #[cfg(target_os = \"redox\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: Implement num_cpus on Redox\n-        1\n-    }\n-\n-    #[cfg(target_os = \"hermit\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: Implement num_cpus on HermitCore\n-        1\n-    }\n-\n-    #[cfg(any(\n-        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-        all(target_vendor = \"fortanix\", target_env = \"sgx\")\n-    ))]\n-    fn num_cpus() -> usize {\n-        1\n-    }\n-\n-    #[cfg(any(\n-        target_os = \"android\",\n-        target_os = \"cloudabi\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_os = \"ios\",\n-        target_os = \"linux\",\n-        target_os = \"macos\",\n-        target_os = \"solaris\",\n-    ))]\n-    fn num_cpus() -> usize {\n-        unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n-    }\n-\n-    #[cfg(any(\n-        target_os = \"freebsd\",\n-        target_os = \"dragonfly\",\n-        target_os = \"netbsd\"\n-    ))]\n-    fn num_cpus() -> usize {\n-        use std::ptr;\n-\n-        let mut cpus: libc::c_uint = 0;\n-        let mut cpus_size = std::mem::size_of_val(&cpus);\n-\n-        unsafe {\n-            cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n-        }\n-        if cpus < 1 {\n-            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-            unsafe {\n-                libc::sysctl(\n-                    mib.as_mut_ptr(),\n-                    2,\n-                    &mut cpus as *mut _ as *mut _,\n-                    &mut cpus_size as *mut _ as *mut _,\n-                    ptr::null_mut(),\n-                    0,\n-                );\n-            }\n-            if cpus < 1 {\n-                cpus = 1;\n-            }\n-        }\n-        cpus as usize\n-    }\n-\n-    #[cfg(target_os = \"openbsd\")]\n-    fn num_cpus() -> usize {\n-        use std::ptr;\n-\n-        let mut cpus: libc::c_uint = 0;\n-        let mut cpus_size = std::mem::size_of_val(&cpus);\n-        let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-\n-        unsafe {\n-            libc::sysctl(\n-                mib.as_mut_ptr(),\n-                2,\n-                &mut cpus as *mut _ as *mut _,\n-                &mut cpus_size as *mut _ as *mut _,\n-                ptr::null_mut(),\n-                0,\n-            );\n-        }\n-        if cpus < 1 {\n-            cpus = 1;\n-        }\n-        cpus as usize\n-    }\n-\n-    #[cfg(target_os = \"haiku\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: implement\n-        1\n-    }\n-\n-    #[cfg(target_os = \"l4re\")]\n-    fn num_cpus() -> usize {\n-        // FIXME: implement\n-        1\n     }\n+    Ok(())\n }\n \n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n@@ -1737,7 +435,7 @@ pub fn run_test(\n     force_ignore: bool,\n     test: TestDescAndFn,\n     strategy: RunStrategy,\n-    monitor_ch: Sender<MonitorMsg>,\n+    monitor_ch: Sender<CompletedTest>,\n     concurrency: Concurrent,\n ) {\n     let TestDescAndFn { desc, testfn } = test;\n@@ -1747,20 +445,21 @@ pub fn run_test(\n         && (cfg!(target_arch = \"wasm32\") || cfg!(target_os = \"emscripten\"));\n \n     if force_ignore || desc.ignore || ignore_because_no_process_support {\n-        monitor_ch.send((desc, TrIgnored, None, Vec::new())).unwrap();\n+        let message = CompletedTest::new(desc, TrIgnored, None, Vec::new());\n+        monitor_ch.send(message).unwrap();\n         return;\n     }\n \n     struct TestRunOpts {\n         pub strategy: RunStrategy,\n         pub nocapture: bool,\n         pub concurrency: Concurrent,\n-        pub time: Option<TestTimeOptions>,\n+        pub time: Option<time::TestTimeOptions>,\n     }\n \n     fn run_test_inner(\n         desc: TestDesc,\n-        monitor_ch: Sender<MonitorMsg>,\n+        monitor_ch: Sender<CompletedTest>,\n         testfn: Box<dyn FnOnce() + Send>,\n         opts: TestRunOpts,\n     ) {\n@@ -1842,94 +541,21 @@ fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n     f()\n }\n \n-fn calc_result<'a>(\n-    desc: &TestDesc,\n-    task_result: Result<(), &'a (dyn Any + 'static + Send)>,\n-    time_opts: &Option<TestTimeOptions>,\n-    exec_time: &Option<TestExecTime>\n-) -> TestResult {\n-    let result = match (&desc.should_panic, task_result) {\n-        (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n-        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n-            if err\n-                .downcast_ref::<String>()\n-                .map(|e| &**e)\n-                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n-                .map(|e| e.contains(msg))\n-                .unwrap_or(false)\n-            {\n-                TrOk\n-            } else {\n-                if desc.allow_fail {\n-                    TrAllowedFail\n-                } else {\n-                    TrFailedMsg(format!(\"panic did not include expected string '{}'\", msg))\n-                }\n-            }\n-        }\n-        (&ShouldPanic::Yes, Ok(())) => TrFailedMsg(\"test did not panic as expected\".to_string()),\n-        _ if desc.allow_fail => TrAllowedFail,\n-        _ => TrFailed,\n-    };\n-\n-    // If test is already failed (or allowed to fail), do not change the result.\n-    if result != TrOk {\n-        return result;\n-    }\n-\n-    // Check if test is failed due to timeout.\n-    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n-        if opts.error_on_excess && opts.is_critical(desc, time) {\n-            return TrTimedFail;\n-        }\n-    }\n-\n-    result\n-}\n-\n-fn get_result_from_exit_code(\n-    desc: &TestDesc,\n-    code: i32,\n-    time_opts: &Option<TestTimeOptions>,\n-    exec_time: &Option<TestExecTime>,\n-) -> TestResult {\n-    let result = match (desc.allow_fail, code) {\n-        (_, TR_OK) => TrOk,\n-        (true, TR_FAILED) => TrAllowedFail,\n-        (false, TR_FAILED) => TrFailed,\n-        (_, _) => TrFailedMsg(format!(\"got unexpected return code {}\", code)),\n-    };\n-\n-    // If test is already failed (or allowed to fail), do not change the result.\n-    if result != TrOk {\n-        return result;\n-    }\n-\n-    // Check if test is failed due to timeout.\n-    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n-        if opts.error_on_excess && opts.is_critical(desc, time) {\n-            return TrTimedFail;\n-        }\n-    }\n-\n-    result\n-}\n-\n fn run_test_in_process(\n     desc: TestDesc,\n     nocapture: bool,\n     report_time: bool,\n     testfn: Box<dyn FnOnce() + Send>,\n-    monitor_ch: Sender<MonitorMsg>,\n-    time_opts: Option<TestTimeOptions>,\n+    monitor_ch: Sender<CompletedTest>,\n+    time_opts: Option<time::TestTimeOptions>,\n ) {\n     // Buffer for capturing standard I/O\n     let data = Arc::new(Mutex::new(Vec::new()));\n \n     let oldio = if !nocapture {\n         Some((\n-            io::set_print(Some(Box::new(Sink(data.clone())))),\n-            io::set_panic(Some(Box::new(Sink(data.clone())))),\n+            io::set_print(Some(Sink::new_boxed(&data))),\n+            io::set_panic(Some(Sink::new_boxed(&data))),\n         ))\n     } else {\n         None\n@@ -1956,14 +582,15 @@ fn run_test_in_process(\n         Err(e) => calc_result(&desc, Err(e.as_ref()), &time_opts, &exec_time),\n     };\n     let stdout = data.lock().unwrap().to_vec();\n-    monitor_ch.send((desc.clone(), test_result, exec_time, stdout)).unwrap();\n+    let message = CompletedTest::new(desc.clone(), test_result, exec_time, stdout);\n+    monitor_ch.send(message).unwrap();\n }\n \n fn spawn_test_subprocess(\n     desc: TestDesc,\n     report_time: bool,\n-    monitor_ch: Sender<MonitorMsg>,\n-    time_opts: Option<TestTimeOptions>,\n+    monitor_ch: Sender<CompletedTest>,\n+    time_opts: Option<time::TestTimeOptions>,\n ) {\n     let (result, test_output, exec_time) = (|| {\n         let args = env::args().collect::<Vec<_>>();\n@@ -2007,7 +634,8 @@ fn spawn_test_subprocess(\n         (result, test_output, exec_time)\n     })();\n \n-    monitor_ch.send((desc.clone(), result, exec_time, test_output)).unwrap();\n+    let message = CompletedTest::new(desc.clone(), result, exec_time, test_output);\n+    monitor_ch.send(message).unwrap();\n }\n \n fn run_test_in_spawned_subprocess(\n@@ -2032,9 +660,9 @@ fn run_test_in_spawned_subprocess(\n         }\n \n         if let TrOk = test_result {\n-            process::exit(TR_OK);\n+            process::exit(test_result::TR_OK);\n         } else {\n-            process::exit(TR_FAILED);\n+            process::exit(test_result::TR_FAILED);\n         }\n     });\n     let record_result2 = record_result.clone();\n@@ -2043,246 +671,3 @@ fn run_test_in_spawned_subprocess(\n     record_result(None);\n     unreachable!(\"panic=abort callback should have exited the process\")\n }\n-\n-#[cfg(not(unix))]\n-fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n-    status.code().ok_or(\"received no exit code from child process\".into())\n-}\n-\n-#[cfg(unix)]\n-fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n-    use std::os::unix::process::ExitStatusExt;\n-    match status.code() {\n-        Some(code) => Ok(code),\n-        None => match status.signal() {\n-            Some(signal) => Err(format!(\"child process exited with signal {}\", signal)),\n-            None => Err(\"child process exited with unknown signal\".into()),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq)]\n-pub struct MetricMap(BTreeMap<String, Metric>);\n-\n-impl MetricMap {\n-    pub fn new() -> MetricMap {\n-        MetricMap(BTreeMap::new())\n-    }\n-\n-    /// Insert a named `value` (+/- `noise`) metric into the map. The value\n-    /// must be non-negative. The `noise` indicates the uncertainty of the\n-    /// metric, which doubles as the \"noise range\" of acceptable\n-    /// pairwise-regressions on this named value, when comparing from one\n-    /// metric to the next using `compare_to_old`.\n-    ///\n-    /// If `noise` is positive, then it means this metric is of a value\n-    /// you want to see grow smaller, so a change larger than `noise` in the\n-    /// positive direction represents a regression.\n-    ///\n-    /// If `noise` is negative, then it means this metric is of a value\n-    /// you want to see grow larger, so a change larger than `noise` in the\n-    /// negative direction represents a regression.\n-    pub fn insert_metric(&mut self, name: &str, value: f64, noise: f64) {\n-        let m = Metric { value, noise };\n-        self.0.insert(name.to_owned(), m);\n-    }\n-\n-    pub fn fmt_metrics(&self) -> String {\n-        let v = self\n-            .0\n-            .iter()\n-            .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n-            .collect::<Vec<_>>();\n-        v.join(\", \")\n-    }\n-}\n-\n-// Benchmarking\n-\n-pub use std::hint::black_box;\n-\n-impl Bencher {\n-    /// Callback for benchmark functions to run in their body.\n-    pub fn iter<T, F>(&mut self, mut inner: F)\n-    where\n-        F: FnMut() -> T,\n-    {\n-        if self.mode == BenchMode::Single {\n-            ns_iter_inner(&mut inner, 1);\n-            return;\n-        }\n-\n-        self.summary = Some(iter(&mut inner));\n-    }\n-\n-    pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n-    where\n-        F: FnMut(&mut Bencher),\n-    {\n-        f(self);\n-        return self.summary;\n-    }\n-}\n-\n-fn ns_from_dur(dur: Duration) -> u64 {\n-    dur.as_secs() * 1_000_000_000 + (dur.subsec_nanos() as u64)\n-}\n-\n-fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n-where\n-    F: FnMut() -> T,\n-{\n-    let start = Instant::now();\n-    for _ in 0..k {\n-        black_box(inner());\n-    }\n-    return ns_from_dur(start.elapsed());\n-}\n-\n-pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n-where\n-    F: FnMut() -> T,\n-{\n-    // Initial bench run to get ballpark figure.\n-    let ns_single = ns_iter_inner(inner, 1);\n-\n-    // Try to estimate iter count for 1ms falling back to 1m\n-    // iterations if first run took < 1ns.\n-    let ns_target_total = 1_000_000; // 1ms\n-    let mut n = ns_target_total / cmp::max(1, ns_single);\n-\n-    // if the first run took more than 1ms we don't want to just\n-    // be left doing 0 iterations on every loop. The unfortunate\n-    // side effect of not being able to do as many runs is\n-    // automatically handled by the statistical analysis below\n-    // (i.e., larger error bars).\n-    n = cmp::max(1, n);\n-\n-    let mut total_run = Duration::new(0, 0);\n-    let samples: &mut [f64] = &mut [0.0_f64; 50];\n-    loop {\n-        let loop_start = Instant::now();\n-\n-        for p in &mut *samples {\n-            *p = ns_iter_inner(inner, n) as f64 / n as f64;\n-        }\n-\n-        stats::winsorize(samples, 5.0);\n-        let summ = stats::Summary::new(samples);\n-\n-        for p in &mut *samples {\n-            let ns = ns_iter_inner(inner, 5 * n);\n-            *p = ns as f64 / (5 * n) as f64;\n-        }\n-\n-        stats::winsorize(samples, 5.0);\n-        let summ5 = stats::Summary::new(samples);\n-\n-        let loop_run = loop_start.elapsed();\n-\n-        // If we've run for 100ms and seem to have converged to a\n-        // stable median.\n-        if loop_run > Duration::from_millis(100)\n-            && summ.median_abs_dev_pct < 1.0\n-            && summ.median - summ5.median < summ5.median_abs_dev\n-        {\n-            return summ5;\n-        }\n-\n-        total_run = total_run + loop_run;\n-        // Longest we ever run for is 3s.\n-        if total_run > Duration::from_secs(3) {\n-            return summ5;\n-        }\n-\n-        // If we overflow here just return the results so far. We check a\n-        // multiplier of 10 because we're about to multiply by 2 and the\n-        // next iteration of the loop will also multiply by 5 (to calculate\n-        // the summ5 result)\n-        n = match n.checked_mul(10) {\n-            Some(_) => n * 2,\n-            None => {\n-                return summ5;\n-            }\n-        };\n-    }\n-}\n-\n-pub mod bench {\n-    use super::{\n-        BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult\n-    };\n-    use crate::stats;\n-    use std::cmp;\n-    use std::io;\n-    use std::panic::{catch_unwind, AssertUnwindSafe};\n-    use std::sync::{Arc, Mutex};\n-\n-    pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<MonitorMsg>, nocapture: bool, f: F)\n-    where\n-        F: FnMut(&mut Bencher),\n-    {\n-        let mut bs = Bencher {\n-            mode: BenchMode::Auto,\n-            summary: None,\n-            bytes: 0,\n-        };\n-\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let oldio = if !nocapture {\n-            Some((\n-                io::set_print(Some(Box::new(Sink(data.clone())))),\n-                io::set_panic(Some(Box::new(Sink(data.clone())))),\n-            ))\n-        } else {\n-            None\n-        };\n-\n-        let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n-\n-        if let Some((printio, panicio)) = oldio {\n-            io::set_print(printio);\n-            io::set_panic(panicio);\n-        }\n-\n-        let test_result = match result {\n-            //bs.bench(f) {\n-            Ok(Some(ns_iter_summ)) => {\n-                let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n-                let mb_s = bs.bytes * 1000 / ns_iter;\n-\n-                let bs = BenchSamples {\n-                    ns_iter_summ,\n-                    mb_s: mb_s as usize,\n-                };\n-                TestResult::TrBench(bs)\n-            }\n-            Ok(None) => {\n-                // iter not called, so no data.\n-                // FIXME: error in this case?\n-                let samples: &mut [f64] = &mut [0.0_f64; 1];\n-                let bs = BenchSamples {\n-                    ns_iter_summ: stats::Summary::new(samples),\n-                    mb_s: 0,\n-                };\n-                TestResult::TrBench(bs)\n-            }\n-            Err(_) => TestResult::TrFailed,\n-        };\n-\n-        let stdout = data.lock().unwrap().to_vec();\n-        monitor_ch.send((desc, test_result, None, stdout)).unwrap();\n-    }\n-\n-    pub fn run_once<F>(f: F)\n-    where\n-        F: FnMut(&mut Bencher),\n-    {\n-        let mut bs = Bencher {\n-            mode: BenchMode::Single,\n-            summary: None,\n-            bytes: 0,\n-        };\n-        bs.bench(f);\n-    }\n-}"}, {"sha": "ec87b0fcd463b58ef2a4dccb2cddc8a8043d2730", "filename": "src/libtest/options.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Foptions.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,90 @@\n+//! Enums denoting options for test execution.\n+\n+/// Whether to execute tests concurrently or not\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Concurrent {\n+    Yes,\n+    No,\n+}\n+\n+/// Number of times to run a benchmarked function\n+#[derive(Clone, PartialEq, Eq)]\n+pub enum BenchMode {\n+    Auto,\n+    Single,\n+}\n+\n+/// Whether test is expected to panic or not\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ShouldPanic {\n+    No,\n+    Yes,\n+    YesWithMessage(&'static str),\n+}\n+\n+/// Whether should console output be colored or not\n+#[derive(Copy, Clone, Debug)]\n+pub enum ColorConfig {\n+    AutoColor,\n+    AlwaysColor,\n+    NeverColor,\n+}\n+\n+/// Format of the test results output\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum OutputFormat {\n+    /// Verbose output\n+    Pretty,\n+    /// Quiet output\n+    Terse,\n+    /// JSON output\n+    Json,\n+}\n+\n+/// Whether ignored test should be runned or not\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum RunIgnored {\n+    Yes,\n+    No,\n+    /// Run only ignored tests\n+    Only,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub enum RunStrategy {\n+    /// Runs the test in the current process, and sends the result back over the\n+    /// supplied channel.\n+    InProcess,\n+\n+    /// Spawns a subprocess to run the test, and sends the result back over the\n+    /// supplied channel. Requires `argv[0]` to exist and point to the binary\n+    /// that's currently running.\n+    SpawnPrimary,\n+}\n+\n+/// Options for the test run defined by the caller (instead of CLI arguments).\n+/// In case we want to add other options as well, just add them in this struct.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Options {\n+    pub display_output: bool,\n+    pub panic_abort: bool,\n+}\n+\n+impl Options {\n+    pub fn new() -> Options {\n+        Options {\n+            display_output: false,\n+            panic_abort: false,\n+        }\n+    }\n+\n+    pub fn display_output(mut self, display_output: bool) -> Options {\n+        self.display_output = display_output;\n+        self\n+    }\n+\n+    pub fn panic_abort(mut self, panic_abort: bool) -> Options {\n+        self.panic_abort = panic_abort;\n+        self\n+    }\n+}"}, {"sha": "eaf41bc9e22559f1cf867c9614ff2903988487aa", "filename": "src/libtest/stats/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fstats%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Fstats%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats%2Ftests.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -4,7 +4,7 @@ extern crate test;\n use std::f64;\n use std::io::prelude::*;\n use std::io;\n-use self::test::Bencher;\n+use self::test::test::Bencher;\n \n // Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n "}, {"sha": "80ca9dea18f5aff3ab26b4d57964850ddd7315bc", "filename": "src/libtest/test_result.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Ftest_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Ftest_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftest_result.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,107 @@\n+use std::any::Any;\n+\n+use super::bench::BenchSamples;\n+use super::time;\n+use super::types::TestDesc;\n+use super::options::ShouldPanic;\n+\n+pub use self::TestResult::*;\n+\n+// Return codes for secondary process.\n+// Start somewhere other than 0 so we know the return code means what we think\n+// it means.\n+pub const TR_OK: i32 = 50;\n+pub const TR_FAILED: i32 = 51;\n+\n+#[derive(Debug, Clone, PartialEq)]\n+pub enum TestResult {\n+    TrOk,\n+    TrFailed,\n+    TrFailedMsg(String),\n+    TrIgnored,\n+    TrAllowedFail,\n+    TrBench(BenchSamples),\n+    TrTimedFail,\n+}\n+\n+unsafe impl Send for TestResult {}\n+\n+/// Creates a `TestResult` depending on the raw result of test execution\n+/// and assotiated data.\n+pub fn calc_result<'a>(\n+    desc: &TestDesc,\n+    task_result: Result<(), &'a (dyn Any + 'static + Send)>,\n+    time_opts: &Option<time::TestTimeOptions>,\n+    exec_time: &Option<time::TestExecTime>\n+) -> TestResult {\n+    let result = match (&desc.should_panic, task_result) {\n+        (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TestResult::TrOk,\n+        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n+            if err\n+                .downcast_ref::<String>()\n+                .map(|e| &**e)\n+                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n+                .map(|e| e.contains(msg))\n+                .unwrap_or(false)\n+            {\n+                TestResult::TrOk\n+            } else {\n+                if desc.allow_fail {\n+                    TestResult::TrAllowedFail\n+                } else {\n+                    TestResult::TrFailedMsg(\n+                        format!(\"panic did not include expected string '{}'\", msg)\n+                    )\n+                }\n+            }\n+        }\n+        (&ShouldPanic::Yes, Ok(())) => {\n+            TestResult::TrFailedMsg(\"test did not panic as expected\".to_string())\n+        }\n+        _ if desc.allow_fail => TestResult::TrAllowedFail,\n+        _ => TestResult::TrFailed,\n+    };\n+\n+    // If test is already failed (or allowed to fail), do not change the result.\n+    if result != TestResult::TrOk {\n+        return result;\n+    }\n+\n+    // Check if test is failed due to timeout.\n+    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n+        if opts.error_on_excess && opts.is_critical(desc, time) {\n+            return TestResult::TrTimedFail;\n+        }\n+    }\n+\n+    result\n+}\n+\n+/// Creates a `TestResult` depending on the exit code of test subprocess.\n+pub fn get_result_from_exit_code(\n+    desc: &TestDesc,\n+    code: i32,\n+    time_opts: &Option<time::TestTimeOptions>,\n+    exec_time: &Option<time::TestExecTime>,\n+) -> TestResult {\n+    let result = match (desc.allow_fail, code) {\n+        (_, TR_OK) => TestResult::TrOk,\n+        (true, TR_FAILED) => TestResult::TrAllowedFail,\n+        (false, TR_FAILED) => TestResult::TrFailed,\n+        (_, _) => TestResult::TrFailedMsg(format!(\"got unexpected return code {}\", code)),\n+    };\n+\n+    // If test is already failed (or allowed to fail), do not change the result.\n+    if result != TestResult::TrOk {\n+        return result;\n+    }\n+\n+    // Check if test is failed due to timeout.\n+    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n+        if opts.error_on_excess && opts.is_critical(desc, time) {\n+            return TestResult::TrTimedFail;\n+        }\n+    }\n+\n+    result\n+}"}, {"sha": "9de774555e9ccab037f333b110bb76b11c0b5ecf", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,11 +1,19 @@\n use super::*;\n \n-use crate::test::{\n-    filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored, RunStrategy,\n-    // ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TestTimeOptions,\n-    // TestType, TrFailedMsg, TrIgnored, TrOk,\n-    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts,\n-    TrIgnored, TrOk,\n+use crate::{\n+    bench::Bencher,\n+    console::OutputLocation,\n+    options::OutputFormat,\n+    time::{TimeThreshold, TestTimeOptions},\n+    formatters::PrettyFormatter,\n+    test::{\n+        filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap,\n+        RunIgnored, RunStrategy, ShouldPanic, StaticTestName, TestDesc,\n+        TestDescAndFn, TestOpts, TrIgnored, TrOk,\n+        // FIXME (introduced by #65251)\n+        // ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TestTimeOptions,\n+        // TestType, TrFailedMsg, TrIgnored, TrOk,\n+    },\n };\n use std::sync::mpsc::channel;\n use std::time::Duration;\n@@ -74,8 +82,8 @@ pub fn do_not_run_ignored_tests() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res != TrOk);\n+    let result = rx.recv().unwrap().result;\n+    assert!(result != TrOk);\n }\n \n #[test]\n@@ -93,11 +101,11 @@ pub fn ignored_tests_result_in_ignored() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrIgnored);\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrIgnored);\n }\n \n-// FIXME: Re-enable emscripten once it can catch panics again\n+// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn test_should_panic() {\n@@ -116,11 +124,11 @@ fn test_should_panic() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrOk);\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrOk);\n }\n \n-// FIXME: Re-enable emscripten once it can catch panics again\n+// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn test_should_panic_good_message() {\n@@ -139,11 +147,11 @@ fn test_should_panic_good_message() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrOk);\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrOk);\n }\n \n-// FIXME: Re-enable emscripten once it can catch panics again\n+// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn test_should_panic_bad_message() {\n@@ -165,11 +173,11 @@ fn test_should_panic_bad_message() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n }\n \n-// FIXME: Re-enable emscripten once it can catch panics again\n+// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn test_should_panic_but_succeeds() {\n@@ -186,8 +194,8 @@ fn test_should_panic_but_succeeds() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrFailedMsg(\"test did not panic as expected\".to_string()));\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrFailedMsg(\"test did not panic as expected\".to_string()));\n }\n \n fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n@@ -214,7 +222,7 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n     };\n     let (tx, rx) = channel();\n     run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, _, exec_time, _) = rx.recv().unwrap();\n+    let exec_time = rx.recv().unwrap().exec_time;\n     exec_time\n }\n \n@@ -252,7 +260,7 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n     };\n     let (tx, rx) = channel();\n     run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, result, _, _) = rx.recv().unwrap();\n+    let result = rx.recv().unwrap().result;\n \n     result\n }\n@@ -658,9 +666,9 @@ fn should_sort_failures_before_printing_them() {\n         test_type: TestType::Unknown,\n     };\n \n-    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false, None);\n+    let mut out = PrettyFormatter::new(OutputLocation::Raw(Vec::new()), false, 10, false, None);\n \n-    let st = ConsoleTestState {\n+    let st = console::ConsoleTestState {\n         log_out: None,\n         total: 0,\n         passed: 0,\n@@ -678,8 +686,8 @@ fn should_sort_failures_before_printing_them() {\n \n     out.write_failures(&st).unwrap();\n     let s = match out.output_location() {\n-        &Raw(ref m) => String::from_utf8_lossy(&m[..]),\n-        &Pretty(_) => unreachable!(),\n+        &OutputLocation::Raw(ref m) => String::from_utf8_lossy(&m[..]),\n+        &OutputLocation::Pretty(_) => unreachable!(),\n     };\n \n     let apos = s.find(\"a\").unwrap();"}, {"sha": "f4d4b17b620ba7c467f8171a26d60721291943ac", "filename": "src/libtest/time.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftime.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,206 @@\n+//! Module `time` contains everything related to the time measurement of unit tests\n+//! execution.\n+//! Two main purposes of this module:\n+//! - Check whether test is timed out.\n+//! - Provide helpers for `report-time` and `measure-time` options.\n+\n+use std::time::{Duration, Instant};\n+use std::str::FromStr;\n+use std::fmt;\n+use std::env;\n+\n+use super::types::{TestDesc, TestType};\n+\n+pub const TEST_WARN_TIMEOUT_S: u64 = 60;\n+\n+/// This small module contains constants used by `report-time` option.\n+/// Those constants values will be used if corresponding environment variables are not set.\n+///\n+/// To override values for unit-tests, use a constant `RUST_TEST_TIME_UNIT`,\n+/// To override values for integration tests, use a constant `RUST_TEST_TIME_INTEGRATION`,\n+/// To override values for doctests, use a constant `RUST_TEST_TIME_DOCTEST`.\n+///\n+/// Example of the expected format is `RUST_TEST_TIME_xxx=100,200`, where 100 means\n+/// warn time, and 200 means critical time.\n+pub mod time_constants {\n+    use std::time::Duration;\n+    use super::TEST_WARN_TIMEOUT_S;\n+\n+    /// Environment variable for overriding default threshold for unit-tests.\n+    pub const UNIT_ENV_NAME: &str = \"RUST_TEST_TIME_UNIT\";\n+\n+    // Unit tests are supposed to be really quick.\n+    pub const UNIT_WARN: Duration = Duration::from_millis(50);\n+    pub const UNIT_CRITICAL: Duration = Duration::from_millis(100);\n+\n+    /// Environment variable for overriding default threshold for unit-tests.\n+    pub const INTEGRATION_ENV_NAME: &str = \"RUST_TEST_TIME_INTEGRATION\";\n+\n+    // Integration tests may have a lot of work, so they can take longer to execute.\n+    pub const INTEGRATION_WARN: Duration = Duration::from_millis(500);\n+    pub const INTEGRATION_CRITICAL: Duration = Duration::from_millis(1000);\n+\n+    /// Environment variable for overriding default threshold for unit-tests.\n+    pub const DOCTEST_ENV_NAME: &str = \"RUST_TEST_TIME_DOCTEST\";\n+\n+    // Doctests are similar to integration tests, because they can include a lot of\n+    // initialization code.\n+    pub const DOCTEST_WARN: Duration = INTEGRATION_WARN;\n+    pub const DOCTEST_CRITICAL: Duration = INTEGRATION_CRITICAL;\n+\n+    // Do not suppose anything about unknown tests, base limits on the\n+    // `TEST_WARN_TIMEOUT_S` constant.\n+    pub const UNKNOWN_WARN: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S);\n+    pub const UNKNOWN_CRITICAL: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S * 2);\n+}\n+\n+/// Returns an `Instance` object denoting when the test should be considered\n+/// timed out.\n+pub fn get_default_test_timeout() -> Instant {\n+    Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S)\n+}\n+\n+/// The meassured execution time of a unit test.\n+#[derive(Debug, Clone, PartialEq)]\n+pub struct TestExecTime(pub Duration);\n+\n+impl fmt::Display for TestExecTime {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:.3}s\", self.0.as_secs_f64())\n+    }\n+}\n+\n+/// Structure denoting time limits for test execution.\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n+pub struct TimeThreshold {\n+    pub warn: Duration,\n+    pub critical: Duration,\n+}\n+\n+impl TimeThreshold {\n+    /// Creates a new `TimeThreshold` instance with provided durations.\n+    pub fn new(warn: Duration, critical: Duration) -> Self {\n+        Self {\n+            warn,\n+            critical,\n+        }\n+    }\n+\n+    /// Attempts to create a `TimeThreshold` instance with values obtained\n+    /// from the environment variable, and returns `None` if the variable\n+    /// is not set.\n+    /// Environment variable format is expected to match `\\d+,\\d+`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if variable with provided name is set but contains inappropriate\n+    /// value.\n+    pub fn from_env_var(env_var_name: &str) -> Option<Self> {\n+        let durations_str = env::var(env_var_name).ok()?;\n+\n+        // Split string into 2 substrings by comma and try to parse numbers.\n+        let mut durations = durations_str\n+            .splitn(2, ',')\n+            .map(|v| {\n+                u64::from_str(v).unwrap_or_else(|_| {\n+                    panic!(\n+                        \"Duration value in variable {} is expected to be a number, but got {}\",\n+                        env_var_name, v\n+                    )\n+                })\n+            });\n+\n+        // Callback to be called if the environment variable has unexpected structure.\n+        let panic_on_incorrect_value = || {\n+            panic!(\n+                \"Duration variable {} expected to have 2 numbers separated by comma, but got {}\",\n+                env_var_name, durations_str\n+            );\n+        };\n+\n+        let (warn, critical) = (\n+            durations.next().unwrap_or_else(panic_on_incorrect_value),\n+            durations.next().unwrap_or_else(panic_on_incorrect_value)\n+        );\n+\n+        if warn > critical {\n+            panic!(\"Test execution warn time should be less or equal to the critical time\");\n+        }\n+\n+        Some(Self::new(Duration::from_millis(warn), Duration::from_millis(critical)))\n+    }\n+}\n+\n+/// Structure with parameters for calculating test execution time.\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n+pub struct TestTimeOptions {\n+    /// Denotes if the test critical execution time limit excess should be considered\n+    /// a test failure.\n+    pub error_on_excess: bool,\n+    pub colored: bool,\n+    pub unit_threshold: TimeThreshold,\n+    pub integration_threshold: TimeThreshold,\n+    pub doctest_threshold: TimeThreshold,\n+}\n+\n+impl TestTimeOptions {\n+    pub fn new_from_env(error_on_excess: bool, colored: bool) -> Self {\n+        let unit_threshold =\n+            TimeThreshold::from_env_var(time_constants::UNIT_ENV_NAME)\n+                .unwrap_or_else(Self::default_unit);\n+\n+        let integration_threshold =\n+            TimeThreshold::from_env_var(time_constants::INTEGRATION_ENV_NAME)\n+                .unwrap_or_else(Self::default_integration);\n+\n+        let doctest_threshold =\n+            TimeThreshold::from_env_var(time_constants::DOCTEST_ENV_NAME)\n+                .unwrap_or_else(Self::default_doctest);\n+\n+        Self {\n+            error_on_excess,\n+            colored,\n+            unit_threshold,\n+            integration_threshold,\n+            doctest_threshold,\n+        }\n+    }\n+\n+    pub fn is_warn(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n+        exec_time.0 >= self.warn_time(test)\n+    }\n+\n+    pub fn is_critical(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n+        exec_time.0 >= self.critical_time(test)\n+    }\n+\n+    fn warn_time(&self, test: &TestDesc) -> Duration {\n+        match test.test_type {\n+            TestType::UnitTest => self.unit_threshold.warn,\n+            TestType::IntegrationTest => self.integration_threshold.warn,\n+            TestType::DocTest => self.doctest_threshold.warn,\n+            TestType::Unknown => time_constants::UNKNOWN_WARN,\n+        }\n+    }\n+\n+    fn critical_time(&self, test: &TestDesc) -> Duration {\n+        match test.test_type {\n+            TestType::UnitTest => self.unit_threshold.critical,\n+            TestType::IntegrationTest => self.integration_threshold.critical,\n+            TestType::DocTest => self.doctest_threshold.critical,\n+            TestType::Unknown => time_constants::UNKNOWN_CRITICAL,\n+        }\n+    }\n+\n+    fn default_unit() -> TimeThreshold {\n+        TimeThreshold::new(time_constants::UNIT_WARN, time_constants::UNIT_CRITICAL)\n+    }\n+\n+    fn default_integration() -> TimeThreshold {\n+        TimeThreshold::new(time_constants::INTEGRATION_WARN, time_constants::INTEGRATION_CRITICAL)\n+    }\n+\n+    fn default_doctest() -> TimeThreshold {\n+        TimeThreshold::new(time_constants::DOCTEST_WARN, time_constants::DOCTEST_CRITICAL)\n+    }\n+}"}, {"sha": "89bcf2cf2853be1ee49aaa16c28f0ba30f18b02e", "filename": "src/libtest/types.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Flibtest%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftypes.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,145 @@\n+//! Common types used by `libtest`.\n+\n+use std::fmt;\n+use std::borrow::Cow;\n+\n+use super::options;\n+use super::bench::Bencher;\n+\n+pub use NamePadding::*;\n+pub use TestName::*;\n+pub use TestFn::*;\n+\n+/// Type of the test according to the [rust book](https://doc.rust-lang.org/cargo/guide/tests.html)\n+/// conventions.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum TestType {\n+    /// Unit-tests are expected to be in the `src` folder of the crate.\n+    UnitTest,\n+    /// Integration-style tests are expected to be in the `tests` folder of the crate.\n+    IntegrationTest,\n+    /// Doctests are created by the `librustdoc` manually, so it's a different type of test.\n+    DocTest,\n+    /// Tests for the sources that don't follow the project layout convention\n+    /// (e.g. tests in raw `main.rs` compiled by calling `rustc --test` directly).\n+    Unknown,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum NamePadding {\n+    PadNone,\n+    PadOnRight,\n+}\n+\n+// The name of a test. By convention this follows the rules for rust\n+// paths; i.e., it should be a series of identifiers separated by double\n+// colons. This way if some test runner wants to arrange the tests\n+// hierarchically it may.\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TestName {\n+    StaticTestName(&'static str),\n+    DynTestName(String),\n+    AlignedTestName(Cow<'static, str>, NamePadding),\n+}\n+\n+impl TestName {\n+    pub fn as_slice(&self) -> &str {\n+        match *self {\n+            StaticTestName(s) => s,\n+            DynTestName(ref s) => s,\n+            AlignedTestName(ref s, _) => &*s,\n+        }\n+    }\n+\n+    pub fn padding(&self) -> NamePadding {\n+        match self {\n+            &AlignedTestName(_, p) => p,\n+            _ => PadNone,\n+        }\n+    }\n+\n+    pub fn with_padding(&self, padding: NamePadding) -> TestName {\n+        let name = match self {\n+            &TestName::StaticTestName(name) => Cow::Borrowed(name),\n+            &TestName::DynTestName(ref name) => Cow::Owned(name.clone()),\n+            &TestName::AlignedTestName(ref name, _) => name.clone(),\n+        };\n+\n+        TestName::AlignedTestName(name, padding)\n+    }\n+}\n+impl fmt::Display for TestName {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self.as_slice(), f)\n+    }\n+}\n+\n+/// Represents a benchmark function.\n+pub trait TDynBenchFn: Send {\n+    fn run(&self, harness: &mut Bencher);\n+}\n+\n+// A function that runs a test. If the function returns successfully,\n+// the test succeeds; if the function panics then the test fails. We\n+// may need to come up with a more clever definition of test in order\n+// to support isolation of tests into threads.\n+pub enum TestFn {\n+    StaticTestFn(fn()),\n+    StaticBenchFn(fn(&mut Bencher)),\n+    DynTestFn(Box<dyn FnOnce() + Send>),\n+    DynBenchFn(Box<dyn TDynBenchFn + 'static>),\n+}\n+\n+impl TestFn {\n+    pub fn padding(&self) -> NamePadding {\n+        match *self {\n+            StaticTestFn(..) => PadNone,\n+            StaticBenchFn(..) => PadOnRight,\n+            DynTestFn(..) => PadNone,\n+            DynBenchFn(..) => PadOnRight,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for TestFn {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match *self {\n+            StaticTestFn(..) => \"StaticTestFn(..)\",\n+            StaticBenchFn(..) => \"StaticBenchFn(..)\",\n+            DynTestFn(..) => \"DynTestFn(..)\",\n+            DynBenchFn(..) => \"DynBenchFn(..)\",\n+        })\n+    }\n+}\n+\n+// The definition of a single test. A test runner will run a list of\n+// these.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct TestDesc {\n+    pub name: TestName,\n+    pub ignore: bool,\n+    pub should_panic: options::ShouldPanic,\n+    pub allow_fail: bool,\n+    pub test_type: TestType,\n+}\n+\n+impl TestDesc {\n+    pub fn padded_name(&self, column_count: usize, align: NamePadding) -> String {\n+        let mut name = String::from(self.name.as_slice());\n+        let fill = column_count.saturating_sub(name.len());\n+        let pad = \" \".repeat(fill);\n+        match align {\n+            PadNone => name,\n+            PadOnRight => {\n+                name.push_str(&pad);\n+                name\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct TestDescAndFn {\n+    pub desc: TestDesc,\n+    pub testfn: TestFn,\n+}"}, {"sha": "7f23313edff8beccb3fe44b815714269c5124c15", "filename": "src/llvm-emscripten", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-emscripten?ref=8a11c61a7af9ffa6585ee93b266e02fa1d642ba8", "patch": "@@ -1 +0,0 @@\n-Subproject commit 7f23313edff8beccb3fe44b815714269c5124c15"}, {"sha": "00b3b29698bed85cb66f2eb7115eff3c82dcbbd7", "filename": "src/test/incremental/const-generics/issue-61338.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61338.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61338.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61338.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,14 @@\n+// revisions:rpass1\n+\n+#![feature(const_generics)]\n+\n+struct Struct<T>(T);\n+\n+impl<T, const N: usize> Struct<[T; N]> {\n+    fn f() {}\n+    fn g() { Self::f(); }\n+}\n+\n+fn main() {\n+    Struct::<[u32; 3]>::g();\n+}"}, {"sha": "a7465b77267a59f2f5a2feebed449cd150ac51f4", "filename": "src/test/incremental/const-generics/issue-61516.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,16 @@\n+// revisions:rpass1\n+\n+#![feature(const_generics)]\n+\n+struct FakeArray<T, const N: usize>(T);\n+\n+impl<T, const N: usize> FakeArray<T, { N }> {\n+    fn len(&self) -> usize {\n+        N\n+    }\n+}\n+\n+fn main() {\n+    let fa = FakeArray::<u32, { 32 }>(1);\n+    assert_eq!(fa.len(), 32);\n+}"}, {"sha": "90e279bfc74332682a3cad97976b0319990396a2", "filename": "src/test/incremental/const-generics/issue-62536.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-62536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-62536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-62536.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,12 @@\n+// revisions:cfail1\n+#![feature(const_generics)]\n+//[cfail1]~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct S<T, const N: usize>([T; N]);\n+\n+fn f<T, const N: usize>(x: T) -> S<T, {N}> { panic!() }\n+\n+fn main() {\n+    f(0u8);\n+    //[cfail1]~^ ERROR type annotations needed\n+}"}, {"sha": "b3c12fbb6e81327e5918ba8a4438f7af60fcfe02", "filename": "src/test/incremental/const-generics/issue-64087.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-64087.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-64087.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-64087.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,11 @@\n+// revisions:cfail1\n+#![feature(const_generics)]\n+//[cfail1]~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn combinator<T, const S: usize>() -> [T; S] {}\n+//[cfail1]~^ ERROR mismatched types\n+\n+fn main() {\n+    combinator().into_iter();\n+    //[cfail1]~^ ERROR type annotations needed\n+}"}, {"sha": "353e323e67b448dad05424b299d9c7aa9a456fcd", "filename": "src/test/incremental/const-generics/issue-65623.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-65623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-65623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-65623.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,14 @@\n+// revisions:rpass1\n+#![feature(const_generics)]\n+\n+pub struct Foo<T, const N: usize>([T; 0]);\n+\n+impl<T, const N: usize> Foo<T, {N}> {\n+    pub fn new() -> Self {\n+        Foo([])\n+    }\n+}\n+\n+fn main() {\n+    let _: Foo<u32, 0> = Foo::new();\n+}"}, {"sha": "8e134ad14fc144e6f11bda977f768d8fb5c7c8c2", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;"}, {"sha": "4e8ba5a209df8d9e80bd4238264b9ef342826519", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -22,7 +22,7 @@ pub fn change_name() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir\")]\n+    except=\"HirBody,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_name() {\n     let _y = 2u64;\n@@ -86,7 +86,7 @@ pub fn change_mutability_of_slot() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_slot() {\n     let _x: u64 = 0;\n@@ -182,7 +182,7 @@ pub fn add_initializer() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n+    except=\"HirBody,typeck_tables_of,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_initializer() {\n     let _x: i16 = 3i16;\n@@ -198,7 +198,7 @@ pub fn change_initializer() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built,optimized_mir\")]\n+    except=\"HirBody,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_initializer() {\n     let _x = 5u16;"}, {"sha": "ca85ee39e36715146df7724d3bff5470ec29bc99", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;"}, {"sha": "1e628d019196b3b619c18ca5ef972424af31bbe5", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;"}, {"sha": "295c2244879f8cc6f448f851047446c629c127e5", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;"}, {"sha": "6f03438ff723487bbf04ee56297133a0391654df", "filename": "src/test/mir-opt/simplify-locals-removes-unused-consts.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,89 @@\n+// compile-flags: -C overflow-checks=no\n+\n+fn use_zst(_: ((), ())) { }\n+\n+struct Temp {\n+    x: u8\n+}\n+\n+fn use_u8(_: u8) { }\n+\n+fn main() {\n+    let ((), ()) = ((), ());\n+    use_zst(((), ()));\n+\n+    use_u8((Temp { x : 40 }).x + 2);\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.main.SimplifyLocals.before.mir\n+// let mut _0: ();\n+// let mut _1: ((), ());\n+// let mut _2: ();\n+// let mut _3: ();\n+// let _4: ();\n+// let mut _5: ((), ());\n+// let mut _6: ();\n+// let mut _7: ();\n+// let _8: ();\n+// let mut _9: u8;\n+// let mut _10: u8;\n+// let mut _11: Temp;\n+// scope 1 {\n+// }\n+// bb0: {\n+//   StorageLive(_1);\n+//   StorageLive(_2);\n+//   _2 = const Scalar(<ZST>) : ();\n+//   StorageLive(_3);\n+//   _3 = const Scalar(<ZST>) : ();\n+//   _1 = const Scalar(<ZST>) : ((), ());\n+//   StorageDead(_3);\n+//   StorageDead(_2);\n+//   StorageDead(_1);\n+//   StorageLive(_4);\n+//   StorageLive(_6);\n+//   _6 = const Scalar(<ZST>) : ();\n+//   StorageLive(_7);\n+//   _7 = const Scalar(<ZST>) : ();\n+//   StorageDead(_7);\n+//   StorageDead(_6);\n+//   _4 = const use_zst(const Scalar(<ZST>) : ((), ())) -> bb1;\n+// }\n+// bb1: {\n+//   StorageDead(_4);\n+//   StorageLive(_8);\n+//   StorageLive(_10);\n+//   StorageLive(_11);\n+//   _11 = const Scalar(0x28) : Temp;\n+//   _10 = const 40u8;\n+//   StorageDead(_10);\n+//   _8 = const use_u8(const 42u8) -> bb2;\n+// }\n+// bb2: {\n+//   StorageDead(_11);\n+//   StorageDead(_8);\n+//   return;\n+// }\n+// END rustc.main.SimplifyLocals.before.mir\n+// START rustc.main.SimplifyLocals.after.mir\n+// let mut _0: ();\n+// let _1: ();\n+// let _2: ();\n+// scope 1 {\n+// }\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const use_zst(const Scalar(<ZST>) : ((), ())) -> bb1;\n+// }\n+// bb1: {\n+//   StorageDead(_1);\n+//   StorageLive(_2);\n+//   _2 = const use_u8(const 42u8) -> bb2;\n+// }\n+// bb2: {\n+//   StorageDead(_2);\n+//   return;\n+// }\n+// END rustc.main.SimplifyLocals.after.mir"}, {"sha": "f270dec5fe232511e1881b3ce0c17e40f4f77106", "filename": "src/test/mir-opt/slice-drop-shim.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,5 +1,7 @@\n+// compile-flags: -Zmir-opt-level=0\n+\n fn main() {\n-    std::ptr::drop_in_place::<[String]> as unsafe fn(_);\n+    let _fn = std::ptr::drop_in_place::<[String]> as unsafe fn(_);\n }\n \n // END RUST SOURCE"}, {"sha": "f56475b441f1a0aa0731c950f2a7757cc990891e", "filename": "src/test/run-make-fulldeps/sanitizer-staticlib-link/Makefile", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -4,12 +4,18 @@\n \n -include ../tools.mk\n \n-# This test builds a staticlib, then an executable that links to it.\n-# The staticlib and executable both  are compiled with address sanitizer,\n-# and we assert that a fault in the staticlib is correctly detected.\n+# This test first builds a staticlib with AddressSanitizer and checks that\n+# linking it to an executable fails due to the missing sanitizer runtime.\n+# It then builds an executable linking to the staticlib and checks that\n+# the fault in the staticlib is detected correctly.\n+\n+# Note that checking for the link failure actually checks two things at once:\n+#   1) That the library has the sanitizer intrumentation\n+#   2) and that library does not have the sanitizer runtime\n \n all:\n \t$(RUSTC) -g -Z sanitizer=address --crate-type staticlib --target $(TARGET) library.rs\n-\t$(CC) program.c $(call STATICLIB,library) $(call OUT_EXE,program) $(EXTRACFLAGS) $(EXTRACXXFLAGS)\n+\t! $(CC) program.c $(call STATICLIB,library) $(call OUT_EXE,program) $(EXTRACFLAGS) $(EXTRACXXFLAGS)\n+\t$(RUSTC) -g -Z sanitizer=address --crate-type bin --target $(TARGET) -L . program.rs\n \tLD_LIBRARY_PATH=$(TMPDIR) $(TMPDIR)/program 2>&1 | $(CGREP) stack-buffer-overflow\n "}, {"sha": "21e1ade2cd52c41807cbdcfa34af556d2dddc8c7", "filename": "src/test/run-make-fulldeps/sanitizer-staticlib-link/program.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2Fprogram.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,10 @@\n+#[link(name = \"library\")]\n+extern {\n+    fn overflow();\n+}\n+\n+fn main() {\n+    unsafe {\n+        overflow();\n+    }\n+}"}, {"sha": "a8753d14de22f958f656fe431c3c80b279b84de6", "filename": "src/test/rustdoc-ui/failed-doctest-missing-codes.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -6,13 +6,13 @@ failures:\n \n ---- $DIR/failed-doctest-missing-codes.rs - Foo (line 8) stdout ----\n error[E0308]: mismatched types\n- --> $DIR/failed-doctest-missing-codes.rs:9:13\n-  |\n-3 | let x: () = 5i32;\n-  |             ^^^^ expected (), found i32\n-  |\n-  = note: expected type `()`\n-             found type `i32`\n+  --> $DIR/failed-doctest-missing-codes.rs:9:13\n+   |\n+LL | let x: () = 5i32;\n+   |             ^^^^ expected (), found i32\n+   |\n+   = note: expected type `()`\n+              found type `i32`\n \n error: aborting due to previous error\n "}, {"sha": "9887d07a3eb6e9bbd8d4681513089087c4908cc2", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -7,10 +7,10 @@ failures:\n \n ---- $DIR/failed-doctest-output.rs - OtherStruct (line 21) stdout ----\n error[E0425]: cannot find value `no` in this scope\n- --> $DIR/failed-doctest-output.rs:22:1\n-  |\n-3 | no\n-  | ^^ not found in this scope\n+  --> $DIR/failed-doctest-output.rs:22:1\n+   |\n+LL | no\n+   | ^^ not found in this scope\n \n error: aborting due to previous error\n "}, {"sha": "4ea6455d3aa4cf864a788503d48a83890ba93371", "filename": "src/test/rustdoc-ui/unparseable-doc-test.stdout", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -6,10 +6,10 @@ failures:\n \n ---- $DIR/unparseable-doc-test.rs - foo (line 6) stdout ----\n error: unterminated double quote string\n- --> $DIR/unparseable-doc-test.rs:8:1\n-  |\n-2 | \"unterminated\n-  | ^^^^^^^^^^^^^\n+  --> $DIR/unparseable-doc-test.rs:8:1\n+   |\n+LL | \"unterminated\n+   | ^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6af9ed3e33f661e44c0105494b858ec88c3e717a", "filename": "src/test/rustdoc/sanitizer-option.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,17 @@\n+// needs-sanitizer-support\n+// compile-flags: --test -Z sanitizer=address\n+//\n+// #43031: Verify that rustdoc passes `-Z` options to rustc. Use an extern\n+// function that is provided by the sanitizer runtime, if flag is not passed\n+// correctly, then linking will fail.\n+\n+/// ```\n+/// extern {\n+///     fn __sanitizer_print_stack_trace();\n+/// }\n+///\n+/// fn main() {\n+///     unsafe { __sanitizer_print_stack_trace() };\n+/// }\n+/// ```\n+pub fn z_flag_is_passed_to_rustc() {}"}, {"sha": "97c5acf1f72ca42129efce0205612dc331f7719d", "filename": "src/test/ui/associated-type-bounds/union-bounds.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -3,13 +3,13 @@\n #![feature(associated_type_bounds)]\n #![feature(untagged_unions)]\n \n-#![allow(unions_with_drop_fields, unused_assignments)]\n+#![allow(unused_assignments)]\n \n-trait Tr1 { type As1; }\n-trait Tr2 { type As2; }\n-trait Tr3 { type As3; }\n-trait Tr4<'a> { type As4; }\n-trait Tr5 { type As5; }\n+trait Tr1: Copy { type As1: Copy; }\n+trait Tr2: Copy { type As2: Copy; }\n+trait Tr3: Copy { type As3: Copy; }\n+trait Tr4<'a>: Copy { type As4: Copy; }\n+trait Tr5: Copy { type As5: Copy; }\n \n impl Tr1 for &str { type As1 = bool; }\n impl Tr2 for bool { type As2 = u8; }\n@@ -71,7 +71,8 @@ where\n     let _: &'a T = &x.f0;\n }\n \n-union UnSelf<T> where Self: Tr1<As1: Tr2> {\n+#[derive(Copy, Clone)]\n+union UnSelf<T> where Self: Tr1<As1: Tr2>, T: Copy {\n     f0: T,\n     f1: <Self as Tr1>::As1,\n     f2: <<Self as Tr1>::As1 as Tr2>::As2,"}, {"sha": "7090cb880fd497b3c587a5d2519466bbd061426b", "filename": "src/test/ui/const-generics/const-argument-cross-crate-mismatch.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,20 +1,20 @@\n error[E0308]: mismatched types\n-  --> $DIR/const-argument-cross-crate-mismatch.rs:6:41\n+  --> $DIR/const-argument-cross-crate-mismatch.rs:6:67\n    |\n LL |     let _ = const_generic_lib::function(const_generic_lib::Struct([0u8, 1u8]));\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `3usize`, found `2usize`\n+   |                                                                   ^^^^^^^^^^ expected an array with a fixed size of 3 elements, found one with 2 elements\n    |\n-   = note: expected type `const_generic_lib::Struct<3usize>`\n-              found type `const_generic_lib::Struct<_: usize>`\n+   = note: expected type `[u8; 3]`\n+              found type `[u8; 2]`\n \n error[E0308]: mismatched types\n-  --> $DIR/const-argument-cross-crate-mismatch.rs:8:39\n+  --> $DIR/const-argument-cross-crate-mismatch.rs:8:65\n    |\n LL |     let _: const_generic_lib::Alias = const_generic_lib::Struct([0u8, 1u8, 2u8]);\n-   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2usize`, found `3usize`\n+   |                                                                 ^^^^^^^^^^^^^^^ expected an array with a fixed size of 2 elements, found one with 3 elements\n    |\n-   = note: expected type `const_generic_lib::Struct<2usize>`\n-              found type `const_generic_lib::Struct<_: usize>`\n+   = note: expected type `[u8; 2]`\n+              found type `[u8; 3]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8cf527f0429f025eb3b9dec86fe56f1916adfde9", "filename": "src/test/ui/consts/const-eval/issue-65394.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,8 +1,5 @@\n // Test for absence of validation mismatch ICE in #65394\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir(borrowck_graphviz_postflow=\"hello.dot\")]\n const _: Vec<i32> = {\n     let mut x = Vec::<i32>::new();\n     let r = &mut x; //~ ERROR references in constants may only refer to immutable values"}, {"sha": "15df813836e5ba46201431ab6dd9d9293cf604e7", "filename": "src/test/ui/consts/const-eval/issue-65394.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,11 +1,11 @@\n error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/issue-65394.rs:8:13\n+  --> $DIR/issue-65394.rs:5:13\n    |\n LL |     let r = &mut x;\n    |             ^^^^^^ constants require immutable values\n \n-[ERROR rustc_mir::transform::qualify_consts] old validator: [($DIR/issue-65394.rs:8:13: 8:19, \"MutBorrow(Mut { allow_two_phase_borrow: false })\")]\n-[ERROR rustc_mir::transform::qualify_consts] new validator: [($DIR/issue-65394.rs:8:13: 8:19, \"MutBorrow(Mut { allow_two_phase_borrow: false })\"), ($DIR/issue-65394.rs:7:9: 7:14, \"LiveDrop\")]\n+[ERROR rustc_mir::transform::qualify_consts] old validator: [($DIR/issue-65394.rs:5:13: 5:19, \"MutBorrow(Mut { allow_two_phase_borrow: false })\")]\n+[ERROR rustc_mir::transform::qualify_consts] new validator: [($DIR/issue-65394.rs:5:13: 5:19, \"MutBorrow(Mut { allow_two_phase_borrow: false })\"), ($DIR/issue-65394.rs:4:9: 4:14, \"LiveDrop\")]\n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0017`."}, {"sha": "8e84a900605f552ccdf65a793af6cf70dcf40224", "filename": "src/test/ui/consts/const-int-pow-rpass.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+\n+const IS_POWER_OF_TWO_A: bool = 0u32.is_power_of_two();\n+const IS_POWER_OF_TWO_B: bool = 32u32.is_power_of_two();\n+const IS_POWER_OF_TWO_C: bool = 33u32.is_power_of_two();\n+\n+fn main() {\n+    assert!(!IS_POWER_OF_TWO_A);\n+    assert!(IS_POWER_OF_TWO_B);\n+    assert!(!IS_POWER_OF_TWO_C);\n+}"}, {"sha": "e1ac4306575daae87383c611245271ccc96e19ec", "filename": "src/test/ui/consts/miri_unleashed/non_const_fn.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+#![warn(const_err)]\n+\n+// A test demonstrating that we prevent calling non-const fn during CTFE.\n+\n+fn foo() {}\n+\n+const C: () = foo(); //~ WARN: skipping const checks\n+//~^ WARN any use of this value will cause an error\n+\n+fn main() {\n+    println!(\"{:?}\", C); //~ ERROR: evaluation of constant expression failed\n+}"}, {"sha": "7a574b34304cb5225cea9cf53accb3e03e96be28", "filename": "src/test/ui/consts/miri_unleashed/non_const_fn.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,29 @@\n+warning: skipping const checks\n+  --> $DIR/non_const_fn.rs:8:15\n+   |\n+LL | const C: () = foo();\n+   |               ^^^^^\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/non_const_fn.rs:8:15\n+   |\n+LL | const C: () = foo();\n+   | --------------^^^^^-\n+   |               |\n+   |               calling non-const function `foo`\n+   |\n+note: lint level defined here\n+  --> $DIR/non_const_fn.rs:2:9\n+   |\n+LL | #![warn(const_err)]\n+   |         ^^^^^^^^^\n+\n+error[E0080]: evaluation of constant expression failed\n+  --> $DIR/non_const_fn.rs:12:22\n+   |\n+LL |     println!(\"{:?}\", C);\n+   |                      ^ referenced constant has errors\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "5a7568fe2cd50fa025c5ad8018da27c56f448d4b", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -8,6 +8,7 @@\n #![feature(slice_patterns)]\n \n use std::cell::{Cell, RefCell};\n+use std::mem::ManuallyDrop;\n use std::ops::Generator;\n use std::panic;\n use std::pin::Pin;\n@@ -152,17 +153,16 @@ fn assignment1(a: &Allocator, c0: bool) {\n     _v = _w;\n }\n \n-#[allow(unions_with_drop_fields)]\n union Boxy<T> {\n-    a: T,\n-    b: T,\n+    a: ManuallyDrop<T>,\n+    b: ManuallyDrop<T>,\n }\n \n fn union1(a: &Allocator) {\n     unsafe {\n-        let mut u = Boxy { a: a.alloc() };\n-        u.b = a.alloc();\n-        drop(u.a);\n+        let mut u = Boxy { a: ManuallyDrop::new(a.alloc()) };\n+        *u.b = a.alloc(); // drops first alloc\n+        drop(ManuallyDrop::into_inner(u.a));\n     }\n }\n "}, {"sha": "0faa9090f4ebcfd898a632a1faf6d6dc6448d5be", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,7 +1,7 @@\n #![feature(untagged_unions)]\n \n-trait Tr1 { type As1; }\n-trait Tr2 { type As2; }\n+trait Tr1 { type As1: Copy; }\n+trait Tr2 { type As2: Copy; }\n \n struct S1;\n #[derive(Copy, Clone)]\n@@ -32,7 +32,7 @@ enum _En1<T: Tr1<As1: Tr2>> {\n \n union _Un1<T: Tr1<As1: Tr2>> {\n //~^ ERROR associated type bounds are unstable\n-    outest: T,\n+    outest: std::mem::ManuallyDrop<T>,\n     outer: T::As1,\n     inner: <T::As1 as Tr2>::As2,\n }"}, {"sha": "9ee0e6f681dcc4ae2f1b9b335ab15a90825d8aee", "filename": "src/test/ui/feature-gates/feature-gate-untagged_unions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -7,11 +7,11 @@ union U2<T: Copy> { // OK\n }\n \n union U3 { //~ ERROR unions with non-`Copy` fields are unstable\n-    a: String,\n+    a: String, //~ ERROR unions may not contain fields that need dropping\n }\n \n union U4<T> { //~ ERROR unions with non-`Copy` fields are unstable\n-    a: T,\n+    a: T, //~ ERROR unions may not contain fields that need dropping\n }\n \n union U5 { //~ ERROR unions with `Drop` implementations are unstable"}, {"sha": "1885518a4585cc0e8b916bd34e31f39d18821624", "filename": "src/test/ui/feature-gates/feature-gate-untagged_unions.stderr", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -31,6 +31,31 @@ LL | | }\n    = note: for more information, see https://github.com/rust-lang/rust/issues/32836\n    = help: add `#![feature(untagged_unions)]` to the crate attributes to enable\n \n-error: aborting due to 3 previous errors\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/feature-gate-untagged_unions.rs:10:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/feature-gate-untagged_unions.rs:10:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/feature-gate-untagged_unions.rs:14:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/feature-gate-untagged_unions.rs:14:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0658`.\n+Some errors have detailed explanations: E0658, E0740.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "f661c62c9e4408db0c3a69d9226a06366f0cf80d", "filename": "src/test/ui/impl-trait/issues/universal-issue-48703.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -5,5 +5,5 @@ use std::fmt::Debug;\n fn foo<T>(x: impl Debug) { }\n \n fn main() {\n-    foo::<String>('a'); //~ ERROR cannot provide explicit type parameters\n+    foo::<String>('a'); //~ ERROR cannot provide explicit generic arguments\n }"}, {"sha": "a51302dce29660972888582ccd194c7a58c3644a", "filename": "src/test/ui/impl-trait/issues/universal-issue-48703.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,4 +1,4 @@\n-error[E0632]: cannot provide explicit type parameters when `impl Trait` is used in argument position.\n+error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n   --> $DIR/universal-issue-48703.rs:8:5\n    |\n LL |     foo::<String>('a');"}, {"sha": "4ac0a694cb148f785679ea9021004bfc989eaa82", "filename": "src/test/ui/impl-trait/issues/universal-turbofish-in-method-issue-50950.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -12,6 +12,6 @@ struct TestEvent(i32);\n fn main() {\n     let mut evt = EventHandler {};\n     evt.handle_event::<TestEvent, fn(TestEvent)>(|_evt| {\n-        //~^ ERROR cannot provide explicit type parameters\n+        //~^ ERROR cannot provide explicit generic arguments\n     });\n }"}, {"sha": "f09aa166ef508c5b388d70d4c95ae4cd88ab2264", "filename": "src/test/ui/impl-trait/issues/universal-turbofish-in-method-issue-50950.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,4 +1,4 @@\n-error[E0632]: cannot provide explicit type parameters when `impl Trait` is used in argument position.\n+error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n   --> $DIR/universal-turbofish-in-method-issue-50950.rs:14:9\n    |\n LL |     evt.handle_event::<TestEvent, fn(TestEvent)>(|_evt| {"}, {"sha": "291086d4f694e81facf6b3bbb753c2460e8ab9e3", "filename": "src/test/ui/issues/issue-17546.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -27,7 +27,7 @@ LL |     use std::prelude::v1::Result;\n    |\n LL |     use std::result::Result;\n    |\n-     and 1 other candidates\n+     and 1 other candidate\n \n error[E0573]: expected type, found variant `Result`\n   --> $DIR/issue-17546.rs:28:13\n@@ -44,7 +44,7 @@ LL | use std::prelude::v1::Result;\n    |\n LL | use std::result::Result;\n    |\n-     and 1 other candidates\n+     and 1 other candidate\n \n error[E0573]: expected type, found variant `NoResult`\n   --> $DIR/issue-17546.rs:33:15"}, {"sha": "ea8a3c177e9d7f77dd202b8dced545200e861400", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,13 +1,12 @@\n #![feature(rustc_attrs)]\n #![feature(untagged_unions)]\n-#![allow(unions_with_drop_fields)]\n \n #[rustc_outlives]\n-union Foo<'b, U> { //~ ERROR rustc_outlives\n+union Foo<'b, U: Copy> { //~ ERROR rustc_outlives\n     bar: Bar<'b, U>\n }\n \n-union Bar<'a, T> where T: 'a {\n+union Bar<'a, T: Copy> where T: 'a {\n     x: &'a (),\n     y: T,\n }"}, {"sha": "8aa246e8bfeb35f312a6fd413bc7a9f36295a470", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,7 +1,7 @@\n error: rustc_outlives\n-  --> $DIR/explicit-union.rs:6:1\n+  --> $DIR/explicit-union.rs:5:1\n    |\n-LL | / union Foo<'b, U> {\n+LL | / union Foo<'b, U: Copy> {\n LL | |     bar: Bar<'b, U>\n LL | | }\n    | |_^"}, {"sha": "0da3cc2ba1b0434c363c2c8503066ef878e03840", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,14 +1,13 @@\n #![feature(rustc_attrs)]\n #![feature(untagged_unions)]\n-#![allow(unions_with_drop_fields)]\n \n #[rustc_outlives]\n-union Foo<'a, T> { //~ ERROR rustc_outlives\n+union Foo<'a, T: Copy> { //~ ERROR rustc_outlives\n     field1: Bar<'a, T>\n }\n \n // Type U needs to outlive lifetime 'b\n-union Bar<'b, U> {\n+union Bar<'b, U: Copy> {\n     field2: &'b U\n }\n "}, {"sha": "a42285a56d0890cb39d809e5494b26bd8bb9336a", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,7 +1,7 @@\n error: rustc_outlives\n-  --> $DIR/nested-union.rs:6:1\n+  --> $DIR/nested-union.rs:5:1\n    |\n-LL | / union Foo<'a, T> {\n+LL | / union Foo<'a, T: Copy> {\n LL | |     field1: Bar<'a, T>\n LL | | }\n    | |_^"}, {"sha": "3b1eb9e1dfa16a86543aad7f17e3126941a65839", "filename": "src/test/ui/self/self-in-typedefs.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -3,7 +3,8 @@\n #![feature(untagged_unions)]\n \n #![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n+\n+use std::mem::ManuallyDrop;\n \n enum A<'a, T: 'a>\n where\n@@ -24,6 +25,14 @@ where\n union C<'a, T: 'a>\n where\n     Self: Send, T: PartialEq<Self>\n+{\n+    foo: &'a Self,\n+    bar: ManuallyDrop<T>,\n+}\n+\n+union D<'a, T: 'a>\n+where\n+    Self: Send, T: PartialEq<Self> + Copy\n {\n     foo: &'a Self,\n     bar: T,"}, {"sha": "610937739c194489104ee2d1e413b63b0abc7a2a", "filename": "src/test/ui/symbol-names/impl1.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -46,13 +46,13 @@ error: def-path(bar::<impl foo::Foo>::baz)\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17h059bf53000885489E)\n+error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17h636bc933fc62ee2fE)\n   --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::h059bf53000885489)\n+error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::h636bc933fc62ee2f)\n   --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]"}, {"sha": "e14697f5c3e97d01a0e7fc16c952c5031d15c4f0", "filename": "src/test/ui/synthetic-param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fsynthetic-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fsynthetic-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsynthetic-param.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -17,12 +17,12 @@ impl<S> Bar<S> {\n }\n \n fn main() {\n-    func::<u8>(42); //~ ERROR cannot provide explicit type parameters\n+    func::<u8>(42); //~ ERROR cannot provide explicit generic arguments\n     func(42); // Ok\n \n-    Foo::func::<u8>(42); //~ ERROR cannot provide explicit type parameters\n+    Foo::func::<u8>(42); //~ ERROR cannot provide explicit generic arguments\n     Foo::func(42); // Ok\n \n-    Bar::<i8>::func::<u8>(42); //~ ERROR cannot provide explicit type parameters\n+    Bar::<i8>::func::<u8>(42); //~ ERROR cannot provide explicit generic arguments\n     Bar::<i8>::func(42); // Ok\n }"}, {"sha": "f8d14f26f32de05e92519de00c6e4e36814a1e37", "filename": "src/test/ui/synthetic-param.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fsynthetic-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Fsynthetic-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsynthetic-param.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,16 +1,16 @@\n-error[E0632]: cannot provide explicit type parameters when `impl Trait` is used in argument position.\n+error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n   --> $DIR/synthetic-param.rs:20:5\n    |\n LL |     func::<u8>(42);\n    |     ^^^^^^^^^^\n \n-error[E0632]: cannot provide explicit type parameters when `impl Trait` is used in argument position.\n+error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n   --> $DIR/synthetic-param.rs:23:5\n    |\n LL |     Foo::func::<u8>(42);\n    |     ^^^^^^^^^^^^^^^\n \n-error[E0632]: cannot provide explicit type parameters when `impl Trait` is used in argument position.\n+error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n   --> $DIR/synthetic-param.rs:26:5\n    |\n LL |     Bar::<i8>::func::<u8>(42);"}, {"sha": "91e9a0d0b659c7e7cbc1a496f2adfed56d97fd8e", "filename": "src/test/ui/union/issue-41073.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,24 @@\n+#![feature(untagged_unions)]\n+\n+union Test {\n+    a: A, //~ ERROR unions may not contain fields that need dropping\n+    b: B\n+}\n+\n+#[derive(Debug)]\n+struct A(i32);\n+impl Drop for A {\n+    fn drop(&mut self) { println!(\"A\"); }\n+}\n+\n+#[derive(Debug)]\n+struct B(f32);\n+impl Drop for B {\n+    fn drop(&mut self) { println!(\"B\"); }\n+}\n+\n+fn main() {\n+    let mut test = Test { a: A(3) };\n+    println!(\"{:?}\", unsafe { test.b });\n+    unsafe { test.b = B(0.5); }\n+}"}, {"sha": "2e9598b227124f9e07731f2a48ca956935bd7d4a", "filename": "src/test/ui/union/issue-41073.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,15 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/issue-41073.rs:4:5\n+   |\n+LL |     a: A,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/issue-41073.rs:4:5\n+   |\n+LL |     a: A,\n+   |     ^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0740`."}, {"sha": "edf08e6ca678f13a4340aac6b5afd54052fc8bff", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,51 +1,90 @@\n #![feature(untagged_unions)]\n #![allow(unused)]\n \n-#[allow(unions_with_drop_fields)]\n+use std::ops::{Deref, DerefMut};\n+\n+#[derive(Default)]\n+struct MockBox<T> {\n+    value: [T; 1],\n+}\n+\n+impl<T> MockBox<T> {\n+    fn new(value: T) -> Self { MockBox { value: [value] } }\n+}\n+\n+impl<T> Deref for MockBox<T> {\n+    type Target = T;\n+    fn deref(&self) -> &T { &self.value[0] }\n+}\n+\n+impl<T> DerefMut for MockBox<T> {\n+    fn deref_mut(&mut self) -> &mut T { &mut self.value[0] }\n+}\n+\n+#[derive(Default)]\n+struct MockVec<T> {\n+    value: [T; 0],\n+}\n+\n+impl<T> MockVec<T> {\n+    fn new() -> Self { MockVec { value: [] } }\n+}\n+\n+impl<T> Deref for MockVec<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] { &self.value }\n+}\n+\n+impl<T> DerefMut for MockVec<T> {\n+    fn deref_mut(&mut self) -> &mut [T] { &mut self.value }\n+}\n+\n+\n union U {\n-    x: ((Vec<u8>, Vec<u8>), Vec<u8>),\n-    y: Box<Vec<u8>>,\n+    x: ((MockVec<u8>, MockVec<u8>), MockVec<u8>),\n+    y: MockBox<MockVec<u8>>,\n }\n \n fn use_borrow<T>(_: &T) {}\n \n unsafe fn parent_sibling_borrow() {\n-    let mut u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let mut u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = &mut u.x.0;\n     let b = &u.y; //~ ERROR cannot borrow `u` (via `u.y`)\n     use_borrow(a);\n }\n \n unsafe fn parent_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = u.x.0;\n     let b = u.y; //~ ERROR use of moved value: `u`\n }\n \n unsafe fn grandparent_sibling_borrow() {\n-    let mut u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let mut u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = &mut (u.x.0).0;\n     let b = &u.y; //~ ERROR cannot borrow `u` (via `u.y`)\n     use_borrow(a);\n }\n \n unsafe fn grandparent_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = (u.x.0).0;\n     let b = u.y; //~ ERROR use of moved value: `u`\n }\n \n unsafe fn deref_sibling_borrow() {\n-    let mut u = U { y: Box::default() };\n+    let mut u = U { y: MockBox::default() };\n     let a = &mut *u.y;\n     let b = &u.x; //~ ERROR cannot borrow `u` (via `u.x`)\n     use_borrow(a);\n }\n \n unsafe fn deref_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n-    let a = *u.y;\n-    let b = u.x; //~ ERROR use of moved value: `u`\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n+    // No way to test deref-move without Box in union\n+    // let a = *u.y;\n+    // let b = u.x; ERROR use of moved value: `u`\n }\n \n "}, {"sha": "8ba155bafb0b95526c0e13fa4ca9f2bd072db98a", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.stderr", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,5 +1,5 @@\n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:15:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:53:13\n    |\n LL |     let a = &mut u.x.0;\n    |             ---------- mutable borrow occurs here (via `u.x.0`)\n@@ -11,17 +11,17 @@ LL |     use_borrow(a);\n    = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0`\n \n error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:22:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:60:13\n    |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+LL |     let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n    |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = u.x.0;\n    |             ----- value moved here\n LL |     let b = u.y;\n    |             ^^^ value used here after move\n \n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0.0`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:28:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:66:13\n    |\n LL |     let a = &mut (u.x.0).0;\n    |             -------------- mutable borrow occurs here (via `u.x.0.0`)\n@@ -33,38 +33,28 @@ LL |     use_borrow(a);\n    = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0.0`\n \n error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:35:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:73:13\n    |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+LL |     let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n    |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = (u.x.0).0;\n    |             --------- value moved here\n LL |     let b = u.y;\n    |             ^^^ value used here after move\n \n-error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `*u.y`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:41:13\n+error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `u.y`)\n+  --> $DIR/union-borrow-move-parent-sibling.rs:79:13\n    |\n LL |     let a = &mut *u.y;\n-   |             --------- mutable borrow occurs here (via `*u.y`)\n+   |                   --- mutable borrow occurs here (via `u.y`)\n LL |     let b = &u.x;\n-   |             ^^^^ immutable borrow of `u.x` -- which overlaps with `*u.y` -- occurs here\n+   |             ^^^^ immutable borrow of `u.x` -- which overlaps with `u.y` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n    |\n-   = note: `u.x` is a field of the union `U`, so it overlaps the field `*u.y`\n+   = note: `u.x` is a field of the union `U`, so it overlaps the field `u.y`\n \n-error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:48:13\n-   |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n-   |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n-LL |     let a = *u.y;\n-   |             ---- value moved here\n-LL |     let b = u.x;\n-   |             ^^^ value used here after move\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0382, E0502.\n For more information about an error, try `rustc --explain E0382`."}, {"sha": "8f816cc1b737c6c4822e80379c969ae6185337ba", "filename": "src/test/ui/union/union-custom-drop.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,19 @@\n+// test for a union with a field that's a union with a manual impl Drop\n+// Ensures we do not treat all unions as not having any drop glue.\n+\n+#![feature(untagged_unions)]\n+\n+union Foo {\n+    bar: Bar, //~ ERROR unions may not contain fields that need dropping\n+}\n+\n+union Bar {\n+    a: i32,\n+    b: u32,\n+}\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "ee2333f905fb4106ed234eb144621456a2c3621d", "filename": "src/test/ui/union/union-custom-drop.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,15 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-custom-drop.rs:7:5\n+   |\n+LL |     bar: Bar,\n+   |     ^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-custom-drop.rs:7:5\n+   |\n+LL |     bar: Bar,\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0740`."}, {"sha": "60e280f53f52c8dc0caabf6f4aad068a4c312c73", "filename": "src/test/ui/union/union-derive-clone.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,5 +1,7 @@\n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n #[derive(Clone)] //~ ERROR the trait bound `U1: std::marker::Copy` is not satisfied\n union U1 {\n     a: u8,\n@@ -18,14 +20,19 @@ union U3 {\n }\n \n #[derive(Clone, Copy)]\n-union U4<T> {\n+union U4<T: Copy> {\n     a: T, // OK\n }\n \n+#[derive(Clone, Copy)]\n+union U5<T> {\n+    a: ManuallyDrop<T>, // OK\n+}\n+\n #[derive(Clone)]\n struct CloneNoCopy;\n \n fn main() {\n-    let u = U4 { a: CloneNoCopy };\n-    let w = u.clone(); //~ ERROR no method named `clone` found for type `U4<CloneNoCopy>`\n+    let u = U5 { a: ManuallyDrop::new(CloneNoCopy) };\n+    let w = u.clone(); //~ ERROR no method named `clone` found for type `U5<CloneNoCopy>`\n }"}, {"sha": "6893f9176f2db7778bd846d090c0707a2f9dcacc", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,22 +1,22 @@\n error[E0277]: the trait bound `U1: std::marker::Copy` is not satisfied\n-  --> $DIR/union-derive-clone.rs:3:10\n+  --> $DIR/union-derive-clone.rs:5:10\n    |\n LL | #[derive(Clone)]\n    |          ^^^^^ the trait `std::marker::Copy` is not implemented for `U1`\n    |\n    = note: required by `std::clone::AssertParamIsCopy`\n \n-error[E0599]: no method named `clone` found for type `U4<CloneNoCopy>` in the current scope\n-  --> $DIR/union-derive-clone.rs:30:15\n+error[E0599]: no method named `clone` found for type `U5<CloneNoCopy>` in the current scope\n+  --> $DIR/union-derive-clone.rs:37:15\n    |\n-LL | union U4<T> {\n+LL | union U5<T> {\n    | ----------- method `clone` not found for this\n ...\n LL |     let w = u.clone();\n-   |               ^^^^^ method not found in `U4<CloneNoCopy>`\n+   |               ^^^^^ method not found in `U5<CloneNoCopy>`\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n-           `U4<CloneNoCopy> : std::clone::Clone`\n+           `U5<CloneNoCopy> : std::clone::Clone`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `std::clone::Clone`"}, {"sha": "b2f7ae679fd6849ec8ee3dae2843bfec8d4ef4ea", "filename": "src/test/ui/union/union-derive-rpass.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n #![allow(unused_variables)]\n-#![allow(unions_with_drop_fields)]\n \n // Some traits can be derived for unions.\n \n@@ -24,11 +23,11 @@ impl PartialEq for U { fn eq(&self, rhs: &Self) -> bool { true } }\n     Copy,\n     Eq\n )]\n-union W<T> {\n+union W<T: Copy> {\n     a: T,\n }\n \n-impl<T> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n+impl<T: Copy> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n \n fn main() {\n     let u = U { b: 0 };"}, {"sha": "f1511b0a60180c63328642c3325542b916a89b55", "filename": "src/test/ui/union/union-drop-assign.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,15 +1,16 @@\n // run-pass\n #![allow(unused_assignments)]\n-#![allow(unions_with_drop_fields)]\n \n // Drop works for union itself.\n \n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n struct S;\n \n union U {\n-    a: S\n+    a: ManuallyDrop<S>\n }\n \n impl Drop for S {\n@@ -28,11 +29,11 @@ static mut CHECK: u8 = 0;\n \n fn main() {\n     unsafe {\n-        let mut u = U { a: S };\n+        let mut u = U { a: ManuallyDrop::new(S) };\n         assert_eq!(CHECK, 0);\n-        u = U { a: S };\n+        u = U { a: ManuallyDrop::new(S) };\n         assert_eq!(CHECK, 1); // union itself is assigned, union is dropped, field is not dropped\n-        u.a = S;\n+        *u.a = S;\n         assert_eq!(CHECK, 11); // union field is assigned, field is dropped\n     }\n }"}, {"sha": "daa03ce6b6fd85d47473ca9942124e28cd949cbe", "filename": "src/test/ui/union/union-drop.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-drop.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n #![allow(unused_variables)]\n-#![allow(unions_with_drop_fields)]\n \n // Drop works for union itself.\n \n@@ -21,12 +20,6 @@ union Y {\n     a: S,\n }\n \n-impl Drop for S {\n-    fn drop(&mut self) {\n-        unsafe { CHECK += 10; }\n-    }\n-}\n-\n impl Drop for U {\n     fn drop(&mut self) {\n         unsafe { CHECK += 1; }\n@@ -51,10 +44,10 @@ fn main() {\n         {\n             let w = W { a: S };\n         }\n-        assert_eq!(CHECK, 2); // 2, not 11, dtor of S is not called\n+        assert_eq!(CHECK, 2); // 2, dtor of W is called\n         {\n             let y = Y { a: S };\n         }\n-        assert_eq!(CHECK, 2); // 2, not 12, dtor of S is not called\n+        assert_eq!(CHECK, 2); // 2, dtor of Y is called\n     }\n }"}, {"sha": "eb169c516d2a81f53d438a04d66c7c3b7115294e", "filename": "src/test/ui/union/union-generic-rpass.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,37 +1,33 @@\n // run-pass\n #![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n \n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n union MaybeItem<T: Iterator> {\n-    elem: T::Item,\n+    elem: ManuallyDrop<T::Item>,\n     none: (),\n }\n \n-union U<A, B> {\n+union U<A, B> where A: Copy, B: Copy {\n     a: A,\n     b: B,\n }\n \n-unsafe fn union_transmute<A, B>(a: A) -> B {\n+unsafe fn union_transmute<A, B>(a: A) -> B where A: Copy, B: Copy {\n     U { a: a }.b\n }\n \n fn main() {\n     unsafe {\n-        let u = U::<String, Vec<u8>> { a: String::from(\"abcd\") };\n-\n-        assert_eq!(u.b.len(), 4);\n-        assert_eq!(u.b[0], b'a');\n-\n         let b = union_transmute::<(u8, u8), u16>((1, 1));\n         assert_eq!(b, (1 << 8) + 1);\n \n         let v: Vec<u8> = vec![1, 2, 3];\n         let mut i = v.iter();\n         i.next();\n-        let mi = MaybeItem::<std::slice::Iter<_>> { elem: i.next().unwrap() };\n-        assert_eq!(*mi.elem, 2);\n+        let mi = MaybeItem::<std::slice::Iter<_>> { elem: ManuallyDrop::new(i.next().unwrap()) };\n+        assert_eq!(**mi.elem, 2);\n     }\n }"}, {"sha": "a43a5050865691e6bd7db60e2222feff00ecfc16", "filename": "src/test/ui/union/union-manuallydrop-rpass.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,42 @@\n+#![feature(untagged_unions)]\n+#![allow(dead_code)]\n+// run-pass\n+\n+use std::mem::needs_drop;\n+use std::mem::ManuallyDrop;\n+\n+struct NeedDrop;\n+\n+impl Drop for NeedDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+union UnionOk1<T> {\n+    empty: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+union UnionOk2 {\n+    value: ManuallyDrop<NeedDrop>,\n+}\n+\n+#[allow(dead_code)]\n+union UnionOk3<T: Copy> {\n+    empty: (),\n+    value: T,\n+}\n+\n+trait Foo { }\n+\n+trait ImpliesCopy : Copy { }\n+\n+#[allow(dead_code)]\n+union UnionOk4<T: ImpliesCopy> {\n+    value: T,\n+}\n+\n+fn main() {\n+    // NeedDrop should not make needs_drop true\n+    assert!(!needs_drop::<UnionOk1<NeedDrop>>());\n+    assert!(!needs_drop::<UnionOk3<&dyn Foo>>());\n+}"}, {"sha": "59282bec59b84de9cbf6757e0c78ef1197e21406", "filename": "src/test/ui/union/union-nodrop.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,12 +1,11 @@\n // run-pass\n \n-#![feature(core_intrinsics)]\n #![feature(untagged_unions)]\n \n-#![allow(unions_with_drop_fields)]\n #![allow(dead_code)]\n \n-use std::intrinsics::needs_drop;\n+use std::mem::needs_drop;\n+use std::mem::ManuallyDrop;\n \n struct NeedDrop;\n \n@@ -16,10 +15,14 @@ impl Drop for NeedDrop {\n \n // Constant expressios allow `NoDrop` to go out of scope,\n // unlike a value of the interior type implementing `Drop`.\n-static X: () = (NoDrop { inner: NeedDrop }, ()).1;\n+static X: () = (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1;\n+\n+const Y: () = (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1;\n+\n+const fn _f() { (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1 }\n \n // A union that scrubs the drop glue from its inner type\n-union NoDrop<T> {inner: T}\n+union NoDrop<T> { inner: ManuallyDrop<T> }\n \n // Copy currently can't be implemented on drop-containing unions,\n // this may change later\n@@ -40,7 +43,7 @@ struct Baz {\n     y: Box<u8>,\n }\n \n-union ActuallyDrop<T> {inner: T}\n+union ActuallyDrop<T> { inner: ManuallyDrop<T> }\n \n impl<T> Drop for ActuallyDrop<T> {\n     fn drop(&mut self) {}"}, {"sha": "8234beb74a8269137568b0d8b63c6575fd61b9a9", "filename": "src/test/ui/union/union-overwrite.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,21 +1,27 @@\n // run-pass\n-#![allow(unions_with_drop_fields)]\n-\n #![feature(untagged_unions)]\n \n #[repr(C)]\n+#[derive(Copy, Clone)]\n struct Pair<T, U>(T, U);\n #[repr(C)]\n+#[derive(Copy, Clone)]\n struct Triple<T>(T, T, T);\n \n #[repr(C)]\n-union U<A, B> {\n+union U<A, B>\n+where\n+    A: Copy, B: Copy\n+{\n     a: Pair<A, A>,\n     b: B,\n }\n \n #[repr(C)]\n-union W<A, B> {\n+union W<A, B>\n+where\n+    A: Copy, B: Copy\n+{\n     a: A,\n     b: B,\n }"}, {"sha": "8535cbd019ce87c6871f2dfbc8511df2e186c25a", "filename": "src/test/ui/union/union-unsafe.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,29 +1,33 @@\n #![feature(untagged_unions)]\n+use std::mem::ManuallyDrop;\n \n union U1 {\n     a: u8\n }\n \n union U2 {\n-    a: String\n+    a: ManuallyDrop<String>\n }\n \n union U3<T> {\n-    a: T\n+    a: ManuallyDrop<T>\n }\n \n union U4<T: Copy> {\n     a: T\n }\n \n fn generic_noncopy<T: Default>() {\n-    let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n+    u3.a = ManuallyDrop::new(T::default()); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    *u3.a = T::default(); //~ ERROR access to union field is unsafe\n }\n \n fn generic_copy<T: Copy + Default>() {\n-    let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); // OK\n+    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n+    u3.a = ManuallyDrop::new(T::default()); // OK\n+    *u3.a = T::default(); //~ ERROR access to union field is unsafe\n+\n     let mut u4 = U4 { a: T::default() };\n     u4.a = T::default(); // OK\n }\n@@ -32,14 +36,20 @@ fn main() {\n     let mut u1 = U1 { a: 10 }; // OK\n     let a = u1.a; //~ ERROR access to union field is unsafe\n     u1.a = 11; // OK\n+\n     let U1 { a } = u1; //~ ERROR access to union field is unsafe\n     if let U1 { a: 12 } = u1 {} //~ ERROR access to union field is unsafe\n     // let U1 { .. } = u1; // OK\n \n-    let mut u2 = U2 { a: String::from(\"old\") }; // OK\n-    u2.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n-    let mut u3 = U3 { a: 0 }; // OK\n-    u3.a = 1; // OK\n-    let mut u3 = U3 { a: String::from(\"old\") }; // OK\n-    u3.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    let mut u2 = U2 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n+    u2.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    *u2.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n+\n+    let mut u3 = U3 { a: ManuallyDrop::new(0) }; // OK\n+    u3.a = ManuallyDrop::new(1); // OK\n+    *u3.a = 1; //~ ERROR access to union field is unsafe\n+\n+    let mut u3 = U3 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n+    u3.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    *u3.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n }"}, {"sha": "e020dab63f8f442d503b119caf1b59bcd2d53793", "filename": "src/test/ui/union/union-unsafe.stderr", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,51 +1,91 @@\n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:21:5\n+  --> $DIR/union-unsafe.rs:22:5\n    |\n-LL |     u3.a = T::default();\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u3.a = ManuallyDrop::new(T::default());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:33:13\n+  --> $DIR/union-unsafe.rs:23:6\n+   |\n+LL |     *u3.a = T::default();\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:29:6\n+   |\n+LL |     *u3.a = T::default();\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:37:13\n    |\n LL |     let a = u1.a;\n    |             ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:35:14\n+  --> $DIR/union-unsafe.rs:40:14\n    |\n LL |     let U1 { a } = u1;\n    |              ^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:36:20\n+  --> $DIR/union-unsafe.rs:41:20\n    |\n LL |     if let U1 { a: 12 } = u1 {}\n    |                    ^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:40:5\n+  --> $DIR/union-unsafe.rs:45:5\n    |\n-LL |     u2.a = String::from(\"new\");\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u2.a = ManuallyDrop::new(String::from(\"new\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:46:6\n+   |\n+LL |     *u2.a = String::from(\"new\");\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:50:6\n+   |\n+LL |     *u3.a = 1;\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:44:5\n+  --> $DIR/union-unsafe.rs:53:5\n    |\n-LL |     u3.a = String::from(\"new\");\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u3.a = ManuallyDrop::new(String::from(\"new\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n-error: aborting due to 6 previous errors\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:54:6\n+   |\n+LL |     *u3.a = String::from(\"new\");\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}, {"sha": "4dbeb7c1e7e973d3a0b7b3afc99bcf8d01a4af9c", "filename": "src/test/ui/union/union-with-drop-fields-lint-rpass.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8a11c61a7af9ffa6585ee93b266e02fa1d642ba8/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a11c61a7af9ffa6585ee93b266e02fa1d642ba8/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs?ref=8a11c61a7af9ffa6585ee93b266e02fa1d642ba8", "patch": "@@ -1,32 +0,0 @@\n-// run-pass\n-\n-#![feature(untagged_unions)]\n-#![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n-\n-union U {\n-    a: u8, // OK\n-}\n-\n-union W {\n-    a: String, // OK\n-    b: String, // OK\n-}\n-\n-struct S(String);\n-\n-// `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n-union Y {\n-    a: S, // OK\n-}\n-\n-// We don't know if `T` is trivially-destructable or not until trans\n-union J<T> {\n-    a: T, // OK\n-}\n-\n-union H<T: Copy> {\n-    a: T, // OK\n-}\n-\n-fn main() {}"}, {"sha": "2f90f240d2e1947e05807f22bf49dbfa0dfdb4bb", "filename": "src/test/ui/union/union-with-drop-fields-lint.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8a11c61a7af9ffa6585ee93b266e02fa1d642ba8/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a11c61a7af9ffa6585ee93b266e02fa1d642ba8/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr?ref=8a11c61a7af9ffa6585ee93b266e02fa1d642ba8", "patch": "@@ -1,26 +0,0 @@\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:10:5\n-   |\n-LL |     a: String,\n-   |     ^^^^^^^^^\n-   |\n-note: lint level defined here\n-  --> $DIR/union-with-drop-fields-lint.rs:3:9\n-   |\n-LL | #![deny(unions_with_drop_fields)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:18:5\n-   |\n-LL |     a: S,\n-   |     ^^^^\n-\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:23:5\n-   |\n-LL |     a: T,\n-   |     ^^^^\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "e3c63a6d5b5a2e7ad447a3ff7bb7a8d3e794e4fa", "filename": "src/test/ui/union/union-with-drop-fields.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1,26 +1,25 @@\n #![feature(untagged_unions)]\n #![allow(dead_code)]\n-#![deny(unions_with_drop_fields)]\n \n union U {\n     a: u8, // OK\n }\n \n union W {\n-    a: String, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: String, //~ ERROR unions may not contain fields that need dropping\n     b: String, // OK, only one field is reported\n }\n \n struct S(String);\n \n // `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n union Y {\n-    a: S, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: S, //~ ERROR unions may not contain fields that need dropping\n }\n \n // We don't know if `T` is trivially-destructable or not until trans\n union J<T> {\n-    a: T, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: T, //~ ERROR unions may not contain fields that need dropping\n }\n \n union H<T: Copy> {", "previous_filename": "src/test/ui/union/union-with-drop-fields-lint.rs"}, {"sha": "0e77279be616a7a1f71b2759a70e1b29a776dcfa", "filename": "src/test/ui/union/union-with-drop-fields.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,39 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:9:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:9:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:17:5\n+   |\n+LL |     a: S,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:17:5\n+   |\n+LL |     a: S,\n+   |     ^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:22:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:22:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0740`."}, {"sha": "fccb2398248802a268fcda544ff3945247ef2119", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -1 +1 @@\n-Subproject commit 2adc39f27b7fd2d06b3d1d470827928766731a1d\n+Subproject commit fccb2398248802a268fcda544ff3945247ef2119"}, {"sha": "ee555a3e5bda764a0500d82d80e00462f6cc6f05", "filename": "src/tools/tidy/src/debug_artifacts.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftools%2Ftidy%2Fsrc%2Fdebug_artifacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftools%2Ftidy%2Fsrc%2Fdebug_artifacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdebug_artifacts.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -0,0 +1,24 @@\n+//! Tidy check to prevent creation of unnecessary debug artifacts.\n+\n+use std::path::{Path, PathBuf};\n+\n+const GRAPHVIZ_POSTFLOW_MSG: &'static str =\n+    \"`borrowck_graphviz_postflow` attribute in test\";\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    let test_dir: PathBuf = path.join(\"test\");\n+\n+    super::walk(&test_dir, &mut super::filter_dirs, &mut |entry, contents| {\n+        let filename = entry.path();\n+        let is_rust = filename.extension().map_or(false, |ext| ext == \"rs\");\n+        if !is_rust {\n+            return;\n+        }\n+\n+        for (i, line) in contents.lines().enumerate() {\n+            if line.contains(\"borrowck_graphviz_postflow\") {\n+                tidy_error!(bad, \"{}:{}: {}\", filename.display(), i + 1, GRAPHVIZ_POSTFLOW_MSG);\n+            }\n+        }\n+    });\n+}"}, {"sha": "d9db68ff66efd0969381d710c961eb8e167abdf4", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -31,6 +31,7 @@ macro_rules! tidy_error {\n \n pub mod bins;\n pub mod style;\n+pub mod debug_artifacts;\n pub mod errors;\n pub mod features;\n pub mod cargo;\n@@ -45,7 +46,6 @@ pub mod error_codes_check;\n \n fn filter_dirs(path: &Path) -> bool {\n     let skip = [\n-        \"src/llvm-emscripten\",\n         \"src/llvm-project\",\n         \"src/stdarch\",\n         \"src/tools/cargo\","}, {"sha": "de6b0c5b28d9de31674a7d353a03167dd87b49c1", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddcd157d03a067419d7f5b4375cfaff5a474856a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=ddcd157d03a067419d7f5b4375cfaff5a474856a", "patch": "@@ -22,6 +22,7 @@ fn main() {\n     let verbose = args.iter().any(|s| *s == \"--verbose\");\n     bins::check(&path, &mut bad);\n     style::check(&path, &mut bad);\n+    debug_artifacts::check(&path, &mut bad);\n     errors::check(&path, &mut bad);\n     cargo::check(&path, &mut bad);\n     edition::check(&path, &mut bad);"}]}