{"sha": "21e062da2fa1a476380d64f5479e5049067648cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZTA2MmRhMmZhMWE0NzYzODBkNjRmNTQ3OWU1MDQ5MDY3NjQ4Y2I=", "commit": {"author": {"name": "Jiewen Yao", "email": "jiewen.yao@intel.com", "date": "2019-08-29T03:44:37Z"}, "committer": {"name": "Jiewen Yao", "email": "jiewen.yao@intel.com", "date": "2019-09-10T06:13:14Z"}, "message": "Add i686-unknown-uefi target\n\nThis adds a new rustc target-configuration called 'i686-unknown_uefi'.\nThis is similar to existing x86_64-unknown_uefi target.\n\nThe i686-unknown-uefi target can be used to build Intel Architecture\n32bit UEFI application. The ABI defined in UEFI environment (aka IA32)\nis similar to cdecl.\n\nWe choose i686-unknown-uefi-gnu instead of i686-unknown-uefi to avoid\nthe intrinsics generated by LLVM. The detail of root-cause and solution\nanalysis is added as comment in the code.\nFor x86_64-unknown-uefi, we cannot use -gnu, because the ABI between\nMSVC and GNU is totally different, and UEFI chooses ABI similar to MSVC.\nFor i686-unknown-uefi, the UEFI chooses cdecl ABI, which is same as\nMSVC and GNU. According to LLVM code, the only differences between MSVC\nand GNU are fmodf(f32), longjmp() and TLS, which have no impact to UEFI.\nAs such, using i686-unknown-uefi-gnu is the simplest way to pass the build.\n\nAdding the undefined symbols, such as _aulldiv() to rust compiler-builtins\nis out of scope. But it may be considered later.\n\nThe scope of this patch is limited to support target-configuration.\n\nNo standard library support is added in this patch. Such work can be\ndone in future enhancement.\n\nCc: Josh Triplett <josh.triplett@intel.com>\nReviewed-by: Josh Triplett <josh.triplett@intel.com>", "tree": {"sha": "f5487b053b848f4ad16b38faec8a17a6e3ae31cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5487b053b848f4ad16b38faec8a17a6e3ae31cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21e062da2fa1a476380d64f5479e5049067648cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21e062da2fa1a476380d64f5479e5049067648cb", "html_url": "https://github.com/rust-lang/rust/commit/21e062da2fa1a476380d64f5479e5049067648cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21e062da2fa1a476380d64f5479e5049067648cb/comments", "author": {"login": "jyao1", "id": 12147155, "node_id": "MDQ6VXNlcjEyMTQ3MTU1", "avatar_url": "https://avatars.githubusercontent.com/u/12147155?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyao1", "html_url": "https://github.com/jyao1", "followers_url": "https://api.github.com/users/jyao1/followers", "following_url": "https://api.github.com/users/jyao1/following{/other_user}", "gists_url": "https://api.github.com/users/jyao1/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyao1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyao1/subscriptions", "organizations_url": "https://api.github.com/users/jyao1/orgs", "repos_url": "https://api.github.com/users/jyao1/repos", "events_url": "https://api.github.com/users/jyao1/events{/privacy}", "received_events_url": "https://api.github.com/users/jyao1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyao1", "id": 12147155, "node_id": "MDQ6VXNlcjEyMTQ3MTU1", "avatar_url": "https://avatars.githubusercontent.com/u/12147155?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyao1", "html_url": "https://github.com/jyao1", "followers_url": "https://api.github.com/users/jyao1/followers", "following_url": "https://api.github.com/users/jyao1/following{/other_user}", "gists_url": "https://api.github.com/users/jyao1/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyao1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyao1/subscriptions", "organizations_url": "https://api.github.com/users/jyao1/orgs", "repos_url": "https://api.github.com/users/jyao1/repos", "events_url": "https://api.github.com/users/jyao1/events{/privacy}", "received_events_url": "https://api.github.com/users/jyao1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b36e9dea3f2ff25b1d0df2669836c33cce89ae5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b36e9dea3f2ff25b1d0df2669836c33cce89ae5", "html_url": "https://github.com/rust-lang/rust/commit/0b36e9dea3f2ff25b1d0df2669836c33cce89ae5"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "c60f7b422d18f4a7d272f14f0fb80df6ba0860a7", "filename": "src/librustc_target/spec/i686_unknown_uefi.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/21e062da2fa1a476380d64f5479e5049067648cb/src%2Flibrustc_target%2Fspec%2Fi686_unknown_uefi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e062da2fa1a476380d64f5479e5049067648cb/src%2Flibrustc_target%2Fspec%2Fi686_unknown_uefi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_unknown_uefi.rs?ref=21e062da2fa1a476380d64f5479e5049067648cb", "patch": "@@ -0,0 +1,98 @@\n+// This defines the ia32 target for UEFI systems as described in the UEFI specification. See the\n+// uefi-base module for generic UEFI options. On ia32 systems\n+// UEFI systems always run in protected-mode, have the interrupt-controller pre-configured and\n+// force a single-CPU execution.\n+// The cdecl ABI is used. It differs from the stdcall or fastcall ABI.\n+// \"i686-unknown-windows\" is used to get the minimal subset of windows-specific features.\n+\n+use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::uefi_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = Some(64);\n+\n+    // We disable MMX and SSE for now, even though UEFI allows using them. Problem is, you have to\n+    // enable these CPU features explicitly before their first use, otherwise their instructions\n+    // will trigger an exception. Rust does not inject any code that enables AVX/MMX/SSE\n+    // instruction sets, so this must be done by the firmware. However, existing firmware is known\n+    // to leave these uninitialized, thus triggering exceptions if we make use of them. Which is\n+    // why we avoid them and instead use soft-floats. This is also what GRUB and friends did so\n+    // far.\n+    // If you initialize FP units yourself, you can override these flags with custom linker\n+    // arguments, thus giving you access to full MMX/SSE acceleration.\n+    base.features = \"-mmx,-sse,+soft-float\".to_string();\n+\n+    // UEFI mirrors the calling-conventions used on windows. In case of i686 this means small\n+    // structs will be returned as int. This shouldn't matter much, since the restrictions placed\n+    // by the UEFI specifications forbid any ABI to return structures.\n+    base.abi_return_struct_as_int = true;\n+\n+    // Use -GNU here, because of the reason below:\n+    // Backgound and Problem:\n+    //   If we use i686-unknown-windows, the LLVM IA32 MSVC generates compiler intrinsic\n+    //   _alldiv, _aulldiv, _allrem, _aullrem, _allmul, which will cause undefined symbol.\n+    //   A real issue is __aulldiv() is refered by __udivdi3() - udivmod_inner!(), from\n+    //   https://github.com/rust-lang-nursery/compiler-builtins.\n+    //   As result, rust-lld generates link error finally.\n+    // Root-cause:\n+    //   In rust\\src\\llvm-project\\llvm\\lib\\Target\\X86\\X86ISelLowering.cpp,\n+    //   we have below code to use MSVC intrinsics. It assumes MSVC target\n+    //   will link MSVC library. But that is NOT true in UEFI environment.\n+    //   UEFI does not link any MSVC or GCC standard library.\n+    //      if (Subtarget.isTargetKnownWindowsMSVC() ||\n+    //          Subtarget.isTargetWindowsItanium()) {\n+    //        // Setup Windows compiler runtime calls.\n+    //        setLibcallName(RTLIB::SDIV_I64, \"_alldiv\");\n+    //        setLibcallName(RTLIB::UDIV_I64, \"_aulldiv\");\n+    //        setLibcallName(RTLIB::SREM_I64, \"_allrem\");\n+    //        setLibcallName(RTLIB::UREM_I64, \"_aullrem\");\n+    //        setLibcallName(RTLIB::MUL_I64, \"_allmul\");\n+    //        setLibcallCallingConv(RTLIB::SDIV_I64, CallingConv::X86_StdCall);\n+    //        setLibcallCallingConv(RTLIB::UDIV_I64, CallingConv::X86_StdCall);\n+    //        setLibcallCallingConv(RTLIB::SREM_I64, CallingConv::X86_StdCall);\n+    //        setLibcallCallingConv(RTLIB::UREM_I64, CallingConv::X86_StdCall);\n+    //        setLibcallCallingConv(RTLIB::MUL_I64, CallingConv::X86_StdCall);\n+    //      }\n+    //   The compiler intrisics should be implemented by compiler-builtins.\n+    //   Unfortunately, compiler-builtins has not provided those intrinsics yet. Such as:\n+    //      i386/divdi3.S\n+    //      i386/lshrdi3.S\n+    //      i386/moddi3.S\n+    //      i386/muldi3.S\n+    //      i386/udivdi3.S\n+    //      i386/umoddi3.S\n+    // Possible solution:\n+    //   1. Eliminate Intrinsics generation.\n+    //      1.1 Choose differnt target to bypass isTargetKnownWindowsMSVC().\n+    //      1.2 Remove the \"Setup Windows compiler runtime calls\" in LLVM\n+    //   2. Implement Intrinsics.\n+    //   We evaluated all options.\n+    //   #2 is hard because we need implement the intrinsics (_aulldiv) generated\n+    //   from the other intrinscis (__udivdi3) implementation with the same\n+    //   functionality (udivmod_inner). If we let _aulldiv() call udivmod_inner!(),\n+    //   then we are in loop. We may have to find another way to implement udivmod_inner!().\n+    //   #1.2 may break the existing usage.\n+    //   #1.1 seems the simplest solution today.\n+    //   The IA32 -gnu calling convention is same as the one defined in UEFI specification.\n+    //   It uses cdecl, EAX/ECX/EDX as volatile register, and EAX/EDX as return value.\n+    //   We also checked the LLVM X86TargetLowering, the differences between -gnu and -msvc\n+    //   is fmodf(f32), longjmp() and TLS. None of them impacts the UEFI code.\n+    // As a result, we choose -gnu for i686 version before those intrisics are implemented in\n+    // compiler-builtins. After compiler-builtins implements all required intrinsics, we may\n+    // remove -gnu and use the default one.\n+    Ok(Target {\n+        llvm_target: \"i686-unknown-windows-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32\".to_string(),\n+        target_os: \"uefi\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        arch: \"x86\".to_string(),\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Link),\n+\n+        options: base,\n+    })\n+}"}, {"sha": "2d8ae028554a28ed58af9f74be558e34e1215b0c", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21e062da2fa1a476380d64f5479e5049067648cb/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e062da2fa1a476380d64f5479e5049067648cb/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=21e062da2fa1a476380d64f5479e5049067648cb", "patch": "@@ -493,6 +493,7 @@ supported_targets! {\n     (\"x86_64-fortanix-unknown-sgx\", x86_64_fortanix_unknown_sgx),\n \n     (\"x86_64-unknown-uefi\", x86_64_unknown_uefi),\n+    (\"i686-unknown-uefi\", i686_unknown_uefi),\n \n     (\"nvptx64-nvidia-cuda\", nvptx64_nvidia_cuda),\n "}]}