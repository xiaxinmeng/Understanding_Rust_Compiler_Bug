{"sha": "39052c55bb0259930dd9e6b0fc27a715793b07c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MDUyYzU1YmIwMjU5OTMwZGQ5ZTZiMGZjMjdhNzE1NzkzYjA3Yzg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-02-21T16:15:43Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-04T22:33:43Z"}, "message": "expand: Move module file path stack from global session to expansion data\n\nAlso don't push the paths on the stack directly in `fn parse_external_mod`, return them instead.", "tree": {"sha": "39522cbe266f40699b2d97e69a837ab3ce5f495f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39522cbe266f40699b2d97e69a837ab3ce5f495f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39052c55bb0259930dd9e6b0fc27a715793b07c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39052c55bb0259930dd9e6b0fc27a715793b07c8", "html_url": "https://github.com/rust-lang/rust/commit/39052c55bb0259930dd9e6b0fc27a715793b07c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39052c55bb0259930dd9e6b0fc27a715793b07c8/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc18eb471772403de20cd9bc0a836ce1f5e09e98", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc18eb471772403de20cd9bc0a836ce1f5e09e98", "html_url": "https://github.com/rust-lang/rust/commit/bc18eb471772403de20cd9bc0a836ce1f5e09e98"}], "stats": {"total": 150, "additions": 80, "deletions": 70}, "files": [{"sha": "98659f15a7e2f8cb08a54e34548a81316dd1eedf", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=39052c55bb0259930dd9e6b0fc27a715793b07c8", "patch": "@@ -101,7 +101,7 @@ pub fn expand_include<'cx>(\n         None => return DummyResult::any(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let mut file = match cx.resolve_path(file, sp) {\n+    let file = match cx.resolve_path(file, sp) {\n         Ok(f) => f,\n         Err(mut err) => {\n             err.emit();\n@@ -114,10 +114,9 @@ pub fn expand_include<'cx>(\n     // then the path of `bar.rs` should be relative to the directory of `file`.\n     // See https://github.com/rust-lang/rust/pull/69838/files#r395217057 for a discussion.\n     // `MacroExpander::fully_expand_fragment` later restores, so \"stack discipline\" is maintained.\n-    file.pop();\n+    let dir_path = file.parent().unwrap_or(&file).to_owned();\n+    cx.current_expansion.module = Rc::new(cx.current_expansion.module.with_dir_path(dir_path));\n     cx.current_expansion.directory_ownership = DirectoryOwnership::Owned { relative: None };\n-    let mod_path = cx.current_expansion.module.mod_path.clone();\n-    cx.current_expansion.module = Rc::new(ModuleData { mod_path, directory: file });\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,"}, {"sha": "a0632522ca0e54452269416ffa824b82c889b873", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=39052c55bb0259930dd9e6b0fc27a715793b07c8", "patch": "@@ -894,10 +894,26 @@ pub trait ResolverExpand {\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Default)]\n pub struct ModuleData {\n+    /// Path to the module starting from the crate name, like `my_crate::foo::bar`.\n     pub mod_path: Vec<Ident>,\n-    pub directory: PathBuf,\n+    /// Stack of paths to files loaded by out-of-line module items,\n+    /// used to detect and report recursive module inclusions.\n+    pub file_path_stack: Vec<PathBuf>,\n+    /// Directory to search child module files in,\n+    /// often (but not necessarily) the parent of the top file path on the `file_path_stack`.\n+    pub dir_path: PathBuf,\n+}\n+\n+impl ModuleData {\n+    pub fn with_dir_path(&self, dir_path: PathBuf) -> ModuleData {\n+        ModuleData {\n+            mod_path: self.mod_path.clone(),\n+            file_path_stack: self.file_path_stack.clone(),\n+            dir_path,\n+        }\n+    }\n }\n \n #[derive(Clone)]\n@@ -946,7 +962,7 @@ impl<'a> ExtCtxt<'a> {\n             current_expansion: ExpansionData {\n                 id: ExpnId::root(),\n                 depth: 0,\n-                module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n+                module: Default::default(),\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n             },"}, {"sha": "8d633afacf4787eb878a6ef19d81e4b738f06efe", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=39052c55bb0259930dd9e6b0fc27a715793b07c8", "patch": "@@ -355,16 +355,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     // FIXME: Avoid visiting the crate as a `Mod` item,\n     // make crate a first class expansion target instead.\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let mut module = ModuleData {\n-            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n-            directory: match self.cx.source_map().span_to_unmapped_path(krate.span) {\n-                FileName::Real(name) => name.into_local_path(),\n-                other => PathBuf::from(other.to_string()),\n-            },\n+        let file_path = match self.cx.source_map().span_to_unmapped_path(krate.span) {\n+            FileName::Real(name) => name.into_local_path(),\n+            other => PathBuf::from(other.to_string()),\n         };\n-        module.directory.pop();\n-        self.cx.root_path = module.directory.clone();\n-        self.cx.current_expansion.module = Rc::new(module);\n+        let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n+        self.cx.root_path = dir_path.clone();\n+        self.cx.current_expansion.module = Rc::new(ModuleData {\n+            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n+            file_path_stack: vec![file_path],\n+            dir_path,\n+        });\n \n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n@@ -1276,25 +1277,30 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::invalid() => {\n-                let sess = &self.cx.sess.parse_sess;\n-                let orig_ownership = self.cx.current_expansion.directory_ownership;\n-                let mut module = (*self.cx.current_expansion.module).clone();\n-\n-                let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n-                let dir = Directory { ownership: orig_ownership, path: module.directory };\n-                let Directory { ownership, path } = match mod_kind {\n+                let dir = Directory {\n+                    ownership: self.cx.current_expansion.directory_ownership,\n+                    path: self.cx.current_expansion.module.dir_path.clone(),\n+                };\n+                let (file_path, Directory { ownership, path }) = match mod_kind {\n                     ModKind::Loaded(_, Inline::Yes, _) => {\n                         // Inline `mod foo { ... }`, but we still need to push directories.\n+                        let dir_path = push_directory(&self.cx.sess, ident, &attrs, dir);\n                         item.attrs = attrs;\n-                        push_directory(&self.cx.sess, ident, &item.attrs, dir)\n+                        (None, dir_path)\n                     }\n                     ModKind::Loaded(_, Inline::No, _) => {\n                         panic!(\"`mod` item is loaded from a file for the second time\")\n                     }\n                     ModKind::Unloaded => {\n                         // We have an outline `mod foo;` so we need to parse the file.\n-                        let (items, inner_span, dir) =\n-                            parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n+                        let (items, inner_span, file_path, dir_path) = parse_external_mod(\n+                            &self.cx.sess,\n+                            ident,\n+                            span,\n+                            &self.cx.current_expansion.module.file_path_stack,\n+                            dir,\n+                            &mut attrs,\n+                        );\n \n                         let krate =\n                             ast::Crate { attrs, items, span: inner_span, proc_macros: vec![] };\n@@ -1305,34 +1311,29 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                         *mod_kind = ModKind::Loaded(krate.items, Inline::No, inner_span);\n                         item.attrs = krate.attrs;\n                         // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n-                        item = match self.configure(item) {\n-                            Some(node) => node,\n-                            None => {\n-                                if *pushed {\n-                                    sess.included_mod_stack.borrow_mut().pop();\n-                                }\n-                                return Default::default();\n-                            }\n-                        };\n-                        dir\n+                        item = configure!(self, item);\n+                        (Some(file_path), dir_path)\n                     }\n                 };\n \n                 // Set the module info before we flat map.\n-                self.cx.current_expansion.directory_ownership = ownership;\n-                module.directory = path;\n+                let mut module = self.cx.current_expansion.module.with_dir_path(path);\n                 module.mod_path.push(ident);\n+                if let Some(file_path) = file_path {\n+                    module.file_path_stack.push(file_path);\n+                }\n+\n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n+                let orig_dir_ownership =\n+                    mem::replace(&mut self.cx.current_expansion.directory_ownership, ownership);\n \n                 let result = noop_flat_map_item(item, self);\n \n                 // Restore the module info.\n+                self.cx.current_expansion.directory_ownership = orig_dir_ownership;\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.directory_ownership = orig_ownership;\n-                if *pushed {\n-                    sess.included_mod_stack.borrow_mut().pop();\n-                }\n+\n                 result\n             }\n             _ => {"}, {"sha": "55b48e4f6b2543acb35bdf7d1fd8302f351edc67", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=39052c55bb0259930dd9e6b0fc27a715793b07c8", "patch": "@@ -42,31 +42,27 @@ crate fn parse_external_mod(\n     sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n+    file_path_stack: &[PathBuf],\n     Directory { mut ownership, path }: Directory,\n     attrs: &mut Vec<Attribute>,\n-    pop_mod_stack: &mut bool,\n-) -> (Vec<P<Item>>, Span, Directory) {\n+) -> (Vec<P<Item>>, Span, PathBuf, Directory) {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n     let result: PResult<'_, _> = try {\n         // Extract the file path and the new ownership.\n         let mp = submod_path(sess, id, span, &attrs, ownership, &path)?;\n         ownership = mp.ownership;\n \n         // Ensure file paths are acyclic.\n-        let mut included_mod_stack = sess.parse_sess.included_mod_stack.borrow_mut();\n-        error_on_circular_module(&sess.parse_sess, span, &mp.path, &included_mod_stack)?;\n-        included_mod_stack.push(mp.path.clone());\n-        *pop_mod_stack = true; // We have pushed, so notify caller.\n-        drop(included_mod_stack);\n+        error_on_circular_module(&sess.parse_sess, span, &mp.path, file_path_stack)?;\n \n         // Actually parse the external file as a module.\n         let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n         let (mut inner_attrs, items, inner_span) = parser.parse_mod(&token::Eof)?;\n         attrs.append(&mut inner_attrs);\n-        (items, inner_span)\n+        (items, inner_span, mp.path)\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (items, inner_span) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n+    let (items, inner_span, file_path) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n \n     // Extract the directory path for submodules of  the module.\n     let path = sess.source_map().span_to_unmapped_path(inner_span);\n@@ -76,18 +72,18 @@ crate fn parse_external_mod(\n     };\n     path.pop();\n \n-    (items, inner_span, Directory { ownership, path })\n+    (items, inner_span, file_path, Directory { ownership, path })\n }\n \n fn error_on_circular_module<'a>(\n     sess: &'a ParseSess,\n     span: Span,\n     path: &Path,\n-    included_mod_stack: &[PathBuf],\n+    file_path_stack: &[PathBuf],\n ) -> PResult<'a, ()> {\n-    if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n+    if let Some(i) = file_path_stack.iter().position(|p| *p == path) {\n         let mut err = String::from(\"circular modules: \");\n-        for p in &included_mod_stack[i..] {\n+        for p in &file_path_stack[i..] {\n             err.push_str(&p.to_string_lossy());\n             err.push_str(\" -> \");\n         }"}, {"sha": "592773bfe1b440920df5b8bcceb5838994453f32", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39052c55bb0259930dd9e6b0fc27a715793b07c8/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=39052c55bb0259930dd9e6b0fc27a715793b07c8", "patch": "@@ -13,7 +13,6 @@ use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n use rustc_span::{MultiSpan, Span, Symbol};\n \n-use std::path::PathBuf;\n use std::str;\n \n /// The set of keys (and, optionally, values) that define the compilation\n@@ -122,8 +121,6 @@ pub struct ParseSess {\n     pub missing_fragment_specifiers: Lock<FxHashMap<Span, NodeId>>,\n     /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n-    /// Used to determine and report recursive module inclusions.\n-    pub included_mod_stack: Lock<Vec<PathBuf>>,\n     source_map: Lrc<SourceMap>,\n     pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n     /// Contains the spans of block expressions that could have been incomplete based on the\n@@ -157,7 +154,6 @@ impl ParseSess {\n             edition: ExpnId::root().expn_data().edition,\n             missing_fragment_specifiers: Default::default(),\n             raw_identifier_spans: Lock::new(Vec::new()),\n-            included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),"}, {"sha": "d4b47efe681580fa2f97d9c92f16780ec8a10812", "filename": "src/test/ui/parser/circular_modules_main.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39052c55bb0259930dd9e6b0fc27a715793b07c8/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39052c55bb0259930dd9e6b0fc27a715793b07c8/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs?ref=39052c55bb0259930dd9e6b0fc27a715793b07c8", "patch": "@@ -1,10 +1,12 @@\n+// error-pattern: circular modules\n+\n #[path = \"circular_modules_hello.rs\"]\n-mod circular_modules_hello; //~ ERROR: circular modules\n+mod circular_modules_hello;\n \n pub fn hi_str() -> String {\n     \"Hi!\".to_string()\n }\n \n fn main() {\n-    circular_modules_hello::say_hello(); //~ ERROR cannot find function `say_hello` in module\n+    circular_modules_hello::say_hello();\n }"}, {"sha": "ee45f65a3bd5ad1b079e3161e5f843b64f76cef3", "filename": "src/test/ui/parser/circular_modules_main.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39052c55bb0259930dd9e6b0fc27a715793b07c8/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39052c55bb0259930dd9e6b0fc27a715793b07c8/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr?ref=39052c55bb0259930dd9e6b0fc27a715793b07c8", "patch": "@@ -1,18 +1,18 @@\n-error: circular modules: $DIR/circular_modules_hello.rs -> $DIR/circular_modules_main.rs -> $DIR/circular_modules_hello.rs\n-  --> $DIR/circular_modules_main.rs:2:1\n+error: circular modules: $DIR/circular_modules_main.rs -> $DIR/circular_modules_hello.rs -> $DIR/circular_modules_main.rs\n+  --> $DIR/circular_modules_hello.rs:4:1\n    |\n-LL | mod circular_modules_hello;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | mod circular_modules_main;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0425]: cannot find function `say_hello` in module `circular_modules_hello`\n-  --> $DIR/circular_modules_main.rs:9:29\n+error[E0425]: cannot find function `hi_str` in module `circular_modules_main`\n+  --> $DIR/circular_modules_hello.rs:7:43\n    |\n-LL |     circular_modules_hello::say_hello();\n-   |                             ^^^^^^^^^ not found in `circular_modules_hello`\n+LL |     println!(\"{}\", circular_modules_main::hi_str());\n+   |                                           ^^^^^^ not found in `circular_modules_main`\n    |\n help: consider importing this function\n    |\n-LL | use circular_modules_hello::say_hello;\n+LL | use hi_str;\n    |\n \n error: aborting due to 2 previous errors"}]}