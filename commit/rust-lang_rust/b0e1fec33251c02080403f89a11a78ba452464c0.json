{"sha": "b0e1fec33251c02080403f89a11a78ba452464c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZTFmZWMzMzI1MWMwMjA4MDQwM2Y4OWExMWE3OGJhNDUyNDY0YzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-14T21:13:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "break out the code that computes VerifyBounds\n\nLater, we'll defer this work until a separate phase.", "tree": {"sha": "50283963b167ac3a369bae61565f7435fb1a221d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50283963b167ac3a369bae61565f7435fb1a221d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0e1fec33251c02080403f89a11a78ba452464c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e1fec33251c02080403f89a11a78ba452464c0", "html_url": "https://github.com/rust-lang/rust/commit/b0e1fec33251c02080403f89a11a78ba452464c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0e1fec33251c02080403f89a11a78ba452464c0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2e0215a1f38e38f260f9295aca98e99f6f6a400", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2e0215a1f38e38f260f9295aca98e99f6f6a400", "html_url": "https://github.com/rust-lang/rust/commit/b2e0215a1f38e38f260f9295aca98e99f6f6a400"}], "stats": {"total": 494, "additions": 276, "deletions": 218}, "files": [{"sha": "282aef786f08ab2ad8b724b9f8130dd643edfff6", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e1fec33251c02080403f89a11a78ba452464c0/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e1fec33251c02080403f89a11a78ba452464c0/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=b0e1fec33251c02080403f89a11a78ba452464c0", "patch": "@@ -13,3 +13,4 @@\n pub mod env;\n pub mod free_region_map;\n pub mod obligations;\n+pub mod verify;"}, {"sha": "c19c8f57d2d072a8c47d333732a5c91297d4b442", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 12, "deletions": 218, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/b0e1fec33251c02080403f89a11a78ba452464c0/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e1fec33251c02080403f89a11a78ba452464c0/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=b0e1fec33251c02080403f89a11a78ba452464c0", "patch": "@@ -69,14 +69,13 @@\n //! might later infer `?U` to something like `&'b u32`, which would\n //! imply that `'b: 'a`.\n \n-use hir::def_id::DefId;\n use infer::outlives::env::RegionBoundPairs;\n+use infer::outlives::verify::VerifyBoundCx;\n use infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n-use traits::{self, ObligationCause};\n+use traits::ObligationCause;\n use ty::outlives::Component;\n-use ty::subst::{Subst, Substs};\n use ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n@@ -244,9 +243,7 @@ where\n     // of these fields.\n     delegate: D,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n-    implicit_region_bound: Option<ty::Region<'tcx>>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    verify_bound: VerifyBoundCx<'cx, 'gcx, 'tcx>,\n }\n \n pub trait TypeOutlivesDelegate<'tcx> {\n@@ -280,9 +277,12 @@ where\n         Self {\n             delegate,\n             tcx,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n+            verify_bound: VerifyBoundCx::new(\n+                tcx,\n+                region_bound_pairs,\n+                implicit_region_bound,\n+                param_env,\n+            ),\n         }\n     }\n \n@@ -357,8 +357,8 @@ where\n             region, param_ty, origin\n         );\n \n-        let verify_bound = self.param_bound(param_ty);\n         let generic = GenericKind::Param(param_ty);\n+        let verify_bound = self.verify_bound.generic_bound(generic);\n         self.delegate\n             .push_verify(origin, generic, region, verify_bound);\n     }\n@@ -391,7 +391,7 @@ where\n         // Compute the bounds we can derive from the environment or trait\n         // definition.  We know that the projection outlives all the\n         // regions in this list.\n-        let env_bounds = self.projection_declared_bounds(projection_ty);\n+        let env_bounds = self.verify_bound.projection_declared_bounds(projection_ty);\n \n         debug!(\"projection_must_outlive: env_bounds={:?}\", env_bounds);\n \n@@ -463,217 +463,11 @@ where\n         // projection outlive; in some cases, this may add insufficient\n         // edges into the inference graph, leading to inference failures\n         // even though a satisfactory solution exists.\n-        let verify_bound = self.projection_bound(env_bounds, projection_ty);\n         let generic = GenericKind::Projection(projection_ty);\n+        let verify_bound = self.verify_bound.generic_bound(generic);\n         self.delegate\n             .push_verify(origin, generic.clone(), region, verify_bound);\n     }\n-\n-    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        match ty.sty {\n-            ty::Param(p) => self.param_bound(p),\n-            ty::Projection(data) => {\n-                let declared_bounds = self.projection_declared_bounds(data);\n-                self.projection_bound(declared_bounds, data)\n-            }\n-            _ => self.recursive_type_bound(ty),\n-        }\n-    }\n-\n-    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n-        debug!(\"param_bound(param_ty={:?})\", param_ty);\n-\n-        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n-\n-        // Add in the default bound of fn body that applies to all in\n-        // scope type parameters:\n-        param_bounds.extend(self.implicit_region_bound);\n-\n-        VerifyBound::AnyRegion(param_bounds)\n-    }\n-\n-    fn projection_declared_bounds(\n-        &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        // First assemble bounds from where clauses and traits.\n-\n-        let mut declared_bounds =\n-            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n-\n-        declared_bounds\n-            .extend_from_slice(&self.declared_projection_bounds_from_trait(projection_ty));\n-\n-        declared_bounds\n-    }\n-\n-    fn projection_bound(\n-        &self,\n-        declared_bounds: Vec<ty::Region<'tcx>>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> VerifyBound<'tcx> {\n-        debug!(\n-            \"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n-            declared_bounds, projection_ty\n-        );\n-\n-        // see the extensive comment in projection_must_outlive\n-        let ty = self.tcx\n-            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_type_bound(ty);\n-\n-        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n-    }\n-\n-    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        let mut bounds = ty.walk_shallow()\n-            .map(|subty| self.type_bound(subty))\n-            .collect::<Vec<_>>();\n-\n-        let mut regions = ty.regions();\n-        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n-        bounds.push(VerifyBound::AllRegions(regions));\n-\n-        // remove bounds that must hold, since they are not interesting\n-        bounds.retain(|b| !b.must_hold());\n-\n-        if bounds.len() == 1 {\n-            bounds.pop().unwrap()\n-        } else {\n-            VerifyBound::AllBounds(bounds)\n-        }\n-    }\n-\n-    fn declared_generic_bounds_from_env(\n-        &self,\n-        generic: GenericKind<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx;\n-\n-        // To start, collect bounds from user environment. Note that\n-        // parameter environments are already elaborated, so we don't\n-        // have to worry about that. Comparing using `==` is a bit\n-        // dubious for projections, but it will work for simple cases\n-        // like `T` and `T::Item`. It may not work as well for things\n-        // like `<T as Foo<'a>>::Item`.\n-        let generic_ty = generic.to_ty(tcx);\n-        let c_b = self.param_env.caller_bounds;\n-        let mut param_bounds = self.collect_outlives_from_predicate_list(generic_ty, c_b);\n-\n-        // Next, collect regions we scraped from the well-formedness\n-        // constraints in the fn signature. To do that, we walk the list\n-        // of known relations from the fn ctxt.\n-        //\n-        // This is crucial because otherwise code like this fails:\n-        //\n-        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n-        //\n-        // The problem is that the type of `x` is `&'a A`. To be\n-        // well-formed, then, A must be lower-generic by `'a`, but we\n-        // don't know that this holds from first principles.\n-        for &(r, p) in self.region_bound_pairs {\n-            debug!(\"generic={:?} p={:?}\", generic, p);\n-            if generic == p {\n-                param_bounds.push(r);\n-            }\n-        }\n-\n-        param_bounds\n-    }\n-\n-    /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n-    /// declared in the trait definition. For example, if the trait were\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a> {\n-    ///     type Bar: 'a;\n-    /// }\n-    /// ```\n-    ///\n-    /// then this function would return `'x`. This is subject to the\n-    /// limitations around higher-ranked bounds described in\n-    /// `region_bounds_declared_on_associated_item`.\n-    fn declared_projection_bounds_from_trait(\n-        &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n-        let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n-        for r in &mut bounds {\n-            *r = r.subst(self.tcx, projection_ty.substs);\n-        }\n-        bounds\n-    }\n-\n-    /// Given the def-id of an associated item, returns any region\n-    /// bounds attached to that associated item from the trait definition.\n-    ///\n-    /// For example:\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a> {\n-    ///     type Bar: 'a;\n-    /// }\n-    /// ```\n-    ///\n-    /// If we were given the def-id of `Foo::Bar`, we would return\n-    /// `'a`. You could then apply the substitutions from the\n-    /// projection to convert this into your namespace. This also\n-    /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on\n-    /// the trait. In fact, it works by searching for just such a\n-    /// where-clause.\n-    ///\n-    /// It will not, however, work for higher-ranked bounds like:\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a, 'b>\n-    /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n-    /// {\n-    ///     type Bar;\n-    /// }\n-    /// ```\n-    ///\n-    /// This is for simplicity, and because we are not really smart\n-    /// enough to cope with such bounds anywhere.\n-    fn region_bounds_declared_on_associated_item(\n-        &self,\n-        assoc_item_def_id: DefId,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx;\n-        let assoc_item = tcx.associated_item(assoc_item_def_id);\n-        let trait_def_id = assoc_item.container.assert_trait();\n-        let trait_predicates = tcx.predicates_of(trait_def_id);\n-        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n-        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n-        self.collect_outlives_from_predicate_list(\n-            identity_proj,\n-            traits::elaborate_predicates(tcx, trait_predicates.predicates),\n-        )\n-    }\n-\n-    /// Searches through a predicate list for a predicate `T: 'a`.\n-    ///\n-    /// Careful: does not elaborate predicates, and just uses `==`\n-    /// when comparing `ty` for equality, so `ty` must be something\n-    /// that does not involve inference variables and where you\n-    /// otherwise want a precise match.\n-    fn collect_outlives_from_predicate_list<I, P>(\n-        &self,\n-        ty: Ty<'tcx>,\n-        predicates: I,\n-    ) -> Vec<ty::Region<'tcx>>\n-    where\n-        I: IntoIterator<Item = P>,\n-        P: AsRef<ty::Predicate<'tcx>>,\n-    {\n-        predicates\n-            .into_iter()\n-            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n-            .filter_map(|p| p.no_late_bound_regions())\n-            .filter(|p| p.0 == ty)\n-            .map(|p| p.1)\n-            .collect()\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'gcx, 'tcx> {"}, {"sha": "3a1e205793104dcafb3be22c3235b4307d311004", "filename": "src/librustc/infer/outlives/verify.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/b0e1fec33251c02080403f89a11a78ba452464c0/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e1fec33251c02080403f89a11a78ba452464c0/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=b0e1fec33251c02080403f89a11a78ba452464c0", "patch": "@@ -0,0 +1,263 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::DefId;\n+use infer::outlives::env::RegionBoundPairs;\n+use infer::{GenericKind, VerifyBound};\n+use traits;\n+use ty::subst::{Subst, Substs};\n+use ty::{self, Ty, TyCtxt};\n+\n+/// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n+/// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n+/// described on the module comment. The final constraints are emitted\n+/// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n+/// accrues them into the `region_obligations` code, but for NLL we\n+/// use something else.\n+pub struct VerifyBoundCx<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+        }\n+    }\n+\n+    /// Returns a \"verify bound\" that encodes what we know about\n+    /// `generic` and the regions it outlives.\n+    pub fn generic_bound(&self, generic: GenericKind<'tcx>) -> VerifyBound<'tcx> {\n+        match generic {\n+            GenericKind::Param(param_ty) => self.param_bound(param_ty),\n+            GenericKind::Projection(projection_ty) => self.projection_bound(projection_ty),\n+        }\n+    }\n+\n+    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        match ty.sty {\n+            ty::Param(p) => self.param_bound(p),\n+            ty::Projection(data) => self.projection_bound(data),\n+            _ => self.recursive_type_bound(ty),\n+        }\n+    }\n+\n+    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n+        debug!(\"param_bound(param_ty={:?})\", param_ty);\n+\n+        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n+\n+        // Add in the default bound of fn body that applies to all in\n+        // scope type parameters:\n+        param_bounds.extend(self.implicit_region_bound);\n+\n+        VerifyBound::AnyRegion(param_bounds)\n+    }\n+\n+    /// Searches the where clauses in scope for regions that\n+    /// `projection_ty` is known to outlive. Currently requires an\n+    /// exact match.\n+    pub fn projection_declared_bounds(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        // First assemble bounds from where clauses and traits.\n+\n+        let mut declared_bounds =\n+            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n+\n+        declared_bounds\n+            .extend_from_slice(&self.declared_projection_bounds_from_trait(projection_ty));\n+\n+        declared_bounds\n+    }\n+\n+    pub fn projection_bound(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> VerifyBound<'tcx> {\n+        debug!(\n+            \"projection_bound(projection_ty={:?})\",\n+            projection_ty\n+        );\n+\n+        let declared_bounds = self.projection_declared_bounds(projection_ty);\n+\n+        debug!(\"projection_bound: declared_bounds = {:?}\", declared_bounds);\n+\n+        // see the extensive comment in projection_must_outlive\n+        let ty = self.tcx\n+            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+        let recursive_bound = self.recursive_type_bound(ty);\n+\n+        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n+    }\n+\n+    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        let mut bounds = ty.walk_shallow()\n+            .map(|subty| self.type_bound(subty))\n+            .collect::<Vec<_>>();\n+\n+        let mut regions = ty.regions();\n+        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n+        bounds.push(VerifyBound::AllRegions(regions));\n+\n+        // remove bounds that must hold, since they are not interesting\n+        bounds.retain(|b| !b.must_hold());\n+\n+        if bounds.len() == 1 {\n+            bounds.pop().unwrap()\n+        } else {\n+            VerifyBound::AllBounds(bounds)\n+        }\n+    }\n+\n+    fn declared_generic_bounds_from_env(\n+        &self,\n+        generic: GenericKind<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        let tcx = self.tcx;\n+\n+        // To start, collect bounds from user environment. Note that\n+        // parameter environments are already elaborated, so we don't\n+        // have to worry about that. Comparing using `==` is a bit\n+        // dubious for projections, but it will work for simple cases\n+        // like `T` and `T::Item`. It may not work as well for things\n+        // like `<T as Foo<'a>>::Item`.\n+        let generic_ty = generic.to_ty(tcx);\n+        let c_b = self.param_env.caller_bounds;\n+        let mut param_bounds = self.collect_outlives_from_predicate_list(generic_ty, c_b);\n+\n+        // Next, collect regions we scraped from the well-formedness\n+        // constraints in the fn signature. To do that, we walk the list\n+        // of known relations from the fn ctxt.\n+        //\n+        // This is crucial because otherwise code like this fails:\n+        //\n+        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n+        //\n+        // The problem is that the type of `x` is `&'a A`. To be\n+        // well-formed, then, A must be lower-generic by `'a`, but we\n+        // don't know that this holds from first principles.\n+        for &(r, p) in self.region_bound_pairs {\n+            debug!(\"generic={:?} p={:?}\", generic, p);\n+            if generic == p {\n+                param_bounds.push(r);\n+            }\n+        }\n+\n+        param_bounds\n+    }\n+\n+    /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n+    /// declared in the trait definition. For example, if the trait were\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// then this function would return `'x`. This is subject to the\n+    /// limitations around higher-ranked bounds described in\n+    /// `region_bounds_declared_on_associated_item`.\n+    fn declared_projection_bounds_from_trait(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n+        let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n+        for r in &mut bounds {\n+            *r = r.subst(self.tcx, projection_ty.substs);\n+        }\n+        bounds\n+    }\n+\n+    /// Given the def-id of an associated item, returns any region\n+    /// bounds attached to that associated item from the trait definition.\n+    ///\n+    /// For example:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// If we were given the def-id of `Foo::Bar`, we would return\n+    /// `'a`. You could then apply the substitutions from the\n+    /// projection to convert this into your namespace. This also\n+    /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on\n+    /// the trait. In fact, it works by searching for just such a\n+    /// where-clause.\n+    ///\n+    /// It will not, however, work for higher-ranked bounds like:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a, 'b>\n+    /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n+    /// {\n+    ///     type Bar;\n+    /// }\n+    /// ```\n+    ///\n+    /// This is for simplicity, and because we are not really smart\n+    /// enough to cope with such bounds anywhere.\n+    fn region_bounds_declared_on_associated_item(\n+        &self,\n+        assoc_item_def_id: DefId,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        let tcx = self.tcx;\n+        let assoc_item = tcx.associated_item(assoc_item_def_id);\n+        let trait_def_id = assoc_item.container.assert_trait();\n+        let trait_predicates = tcx.predicates_of(trait_def_id);\n+        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n+        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n+        self.collect_outlives_from_predicate_list(\n+            identity_proj,\n+            traits::elaborate_predicates(tcx, trait_predicates.predicates),\n+        )\n+    }\n+\n+    /// Searches through a predicate list for a predicate `T: 'a`.\n+    ///\n+    /// Careful: does not elaborate predicates, and just uses `==`\n+    /// when comparing `ty` for equality, so `ty` must be something\n+    /// that does not involve inference variables and where you\n+    /// otherwise want a precise match.\n+    fn collect_outlives_from_predicate_list<I, P>(\n+        &self,\n+        ty: Ty<'tcx>,\n+        predicates: I,\n+    ) -> Vec<ty::Region<'tcx>>\n+    where\n+        I: IntoIterator<Item = P>,\n+        P: AsRef<ty::Predicate<'tcx>>,\n+    {\n+        predicates\n+            .into_iter()\n+            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n+            .filter_map(|p| p.no_late_bound_regions())\n+            .filter(|p| p.0 == ty)\n+            .map(|p| p.1)\n+            .collect()\n+    }\n+}"}]}