{"sha": "ecdab5ff35297e9d70647f076b3aba656c8ad850", "node_id": "C_kwDOAAsO6NoAKGVjZGFiNWZmMzUyOTdlOWQ3MDY0N2YwNzZiM2FiYTY1NmM4YWQ4NTA", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-01T11:36:00Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:21Z"}, "message": "Clearer boundries between alloc metadata with multiple buffers and an individual store buffer", "tree": {"sha": "314a478daf4c921c99e32b0f1530316d4966ad56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/314a478daf4c921c99e32b0f1530316d4966ad56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecdab5ff35297e9d70647f076b3aba656c8ad850", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRDkACgkQGBtJ+fOP\nM3TgjQwAkf3TlXKf7Fb+yjqEbzdXSB7SVEGT1hRHUgoScxTF0Ykku26PB7lr96Rz\n/h5Rg0ZQPieVPrAl1CZSEr777QB2zghe3NWKNJWUfoeT7TnKGSojOJcCUl3KIaW2\ndwfLlig+4fSrMe6kVE4PZZRwO65hobLCzO+glO2uSDrM+zdeAVOfDmgapDRVFZps\nJbFzWF3rdFZiUYWe47IrFqeURda7D3tSJ1zbe4yspNYa/PPT4EaMfiyy2OblP0J3\n0VQQLgvros/hT9LCb5zQJtRecct8vr9hH9adQpBLHxzcuMaJswMRiDqvkxkxuV2d\nLD/3usWWE/MkSPp5fACfUg+AlSoqteQ4U5yBq710sS3Mv2MOkAd2+hbDAlvKKbZc\naIyfT8SNyxqzTOi2AG4jFlv8eurv9812zTcif9Mf3ykMRLJK+OdO9wiHOeDd8WrG\ngij9IvsWvxLpKRcfrIlBTbd0GJRw8e4BJTMKaGrVMrOcmzG14W34gL3g47or9vDS\nDJ0wk/aE\n=V0n5\n-----END PGP SIGNATURE-----", "payload": "tree 314a478daf4c921c99e32b0f1530316d4966ad56\nparent cf266584b7d9e42f6b1ba622b828e7d95c243225\nauthor Andy Wang <cbeuw.andy@gmail.com> 1651404960 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539321 +0100\n\nClearer boundries between alloc metadata with multiple buffers and an individual store buffer\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdab5ff35297e9d70647f076b3aba656c8ad850", "html_url": "https://github.com/rust-lang/rust/commit/ecdab5ff35297e9d70647f076b3aba656c8ad850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecdab5ff35297e9d70647f076b3aba656c8ad850/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf266584b7d9e42f6b1ba622b828e7d95c243225", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf266584b7d9e42f6b1ba622b828e7d95c243225", "html_url": "https://github.com/rust-lang/rust/commit/cf266584b7d9e42f6b1ba622b828e7d95c243225"}], "stats": {"total": 76, "additions": 36, "deletions": 40}, "files": [{"sha": "303cf7007e75344e7fca1bcd21e3f067b5cd09fa", "filename": "src/data_race.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecdab5ff35297e9d70647f076b3aba656c8ad850/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecdab5ff35297e9d70647f076b3aba656c8ad850/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=ecdab5ff35297e9d70647f076b3aba656c8ad850", "patch": "@@ -519,8 +519,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                     global.sc_read();\n                 }\n                 let mut rng = this.machine.rng.borrow_mut();\n-                let loaded = alloc_buffers.buffered_read(\n-                    alloc_range(base_offset, place.layout.size),\n+                let buffer = alloc_buffers.get_store_buffer(alloc_range(base_offset, place.layout.size));\n+                let loaded = buffer.buffered_read(\n                     global,\n                     atomic == AtomicReadOp::SeqCst,\n                     &mut *rng,\n@@ -555,10 +555,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             if atomic == AtomicWriteOp::SeqCst {\n                 global.sc_write();\n             }\n-            let size = dest.layout.size;\n-            alloc_buffers.buffered_write(\n+            let mut buffer = alloc_buffers.get_store_buffer_mut(alloc_range(base_offset, dest.layout.size));\n+            buffer.buffered_write(\n                 val,\n-                alloc_range(base_offset, size),\n                 global,\n                 atomic == AtomicWriteOp::SeqCst,\n             )?;\n@@ -708,7 +707,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                 let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n                 if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n                     if global.multi_threaded.get() {\n-                        alloc_buffers.read_from_last_store(alloc_range(base_offset, size), global);\n+                        let buffer = alloc_buffers.get_store_buffer(alloc_range(base_offset, size));\n+                        buffer.read_from_last_store(global);\n                     }\n                 }\n             }\n@@ -735,10 +735,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                 global.sc_read();\n                 global.sc_write();\n             }\n-            let size = place.layout.size;\n-            let range = alloc_range(base_offset, size);\n-            alloc_buffers.read_from_last_store(range, global);\n-            alloc_buffers.buffered_write(new_val, range, global, atomic == AtomicRwOp::SeqCst)?;\n+            let range = alloc_range(base_offset, place.layout.size);\n+            let mut buffer = alloc_buffers.get_store_buffer_mut(range);\n+            buffer.read_from_last_store(global);\n+            buffer.buffered_write(new_val, global, atomic == AtomicRwOp::SeqCst)?;\n         }\n         Ok(())\n     }"}, {"sha": "2cf9a98b13351d3b83767fae18f73d0951e1956a", "filename": "src/weak_memory.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ecdab5ff35297e9d70647f076b3aba656c8ad850/src%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecdab5ff35297e9d70647f076b3aba656c8ad850/src%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fweak_memory.rs?ref=ecdab5ff35297e9d70647f076b3aba656c8ad850", "patch": "@@ -53,48 +53,63 @@ impl StoreBufferAlloc {\n     }\n \n     /// Gets a store buffer associated with an atomic object in this allocation\n-    fn get_store_buffer(&self, range: AllocRange) -> Ref<'_, StoreBuffer> {\n+    pub fn get_store_buffer(&self, range: AllocRange) -> Ref<'_, StoreBuffer> {\n         Ref::map(self.store_buffer.borrow(), |range_map| {\n             let (.., store_buffer) = range_map.iter(range.start, range.size).next().unwrap();\n             store_buffer\n         })\n     }\n \n-    fn get_store_buffer_mut(&self, range: AllocRange) -> RefMut<'_, StoreBuffer> {\n+    pub fn get_store_buffer_mut(&self, range: AllocRange) -> RefMut<'_, StoreBuffer> {\n         RefMut::map(self.store_buffer.borrow_mut(), |range_map| {\n             let (.., store_buffer) = range_map.iter_mut(range.start, range.size).next().unwrap();\n             store_buffer\n         })\n     }\n \n+}\n+\n+const STORE_BUFFER_LIMIT: usize = 128;\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StoreBuffer {\n+    // Stores to this location in modification order\n+    buffer: VecDeque<StoreElement>,\n+}\n+\n+impl Default for StoreBuffer {\n+    fn default() -> Self {\n+        let mut buffer = VecDeque::new();\n+        buffer.reserve(STORE_BUFFER_LIMIT);\n+        Self { buffer }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> StoreBuffer {\n     /// Reads from the last store in modification order\n-    pub fn read_from_last_store<'tcx>(&self, range: AllocRange, global: &GlobalState) {\n-        let store_buffer = self.get_store_buffer(range);\n-        let store_elem = store_buffer.buffer.back();\n+    pub fn read_from_last_store(&self, global: &GlobalState) {\n+        let store_elem = self.buffer.back();\n         if let Some(store_elem) = store_elem {\n             let (index, clocks) = global.current_thread_state();\n             store_elem.load_impl(index, &clocks);\n         }\n     }\n \n-    pub fn buffered_read<'tcx>(\n+    pub fn buffered_read(\n         &self,\n-        range: AllocRange,\n         global: &GlobalState,\n         is_seqcst: bool,\n         rng: &mut (impl rand::Rng + ?Sized),\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx, Option<ScalarMaybeUninit<Tag>>> {\n         // Having a live borrow to store_buffer while calling validate_atomic_load is fine\n         // because the race detector doesn't touch store_buffer\n-        let store_buffer = self.get_store_buffer(range);\n \n         let store_elem = {\n             // The `clocks` we got here must be dropped before calling validate_atomic_load\n             // as the race detector will update it\n             let (.., clocks) = global.current_thread_state();\n             // Load from a valid entry in the store buffer\n-            store_buffer.fetch_store(is_seqcst, &clocks, &mut *rng)\n+            self.fetch_store(is_seqcst, &clocks, &mut *rng)\n         };\n \n         // Unlike in write_scalar_atomic, thread clock updates have to be done\n@@ -110,37 +125,18 @@ impl StoreBufferAlloc {\n         Ok(loaded)\n     }\n \n-    pub fn buffered_write<'tcx>(\n+    pub fn buffered_write(\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n-        range: AllocRange,\n         global: &GlobalState,\n         is_seqcst: bool,\n     ) -> InterpResult<'tcx> {\n         let (index, clocks) = global.current_thread_state();\n \n-        let mut store_buffer = self.get_store_buffer_mut(range);\n-        store_buffer.store_impl(val, index, &clocks.clock, is_seqcst);\n+        self.store_impl(val, index, &clocks.clock, is_seqcst);\n         Ok(())\n     }\n-}\n \n-const STORE_BUFFER_LIMIT: usize = 128;\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct StoreBuffer {\n-    // Stores to this location in modification order\n-    buffer: VecDeque<StoreElement>,\n-}\n-\n-impl Default for StoreBuffer {\n-    fn default() -> Self {\n-        let mut buffer = VecDeque::new();\n-        buffer.reserve(STORE_BUFFER_LIMIT);\n-        Self { buffer }\n-    }\n-}\n-\n-impl<'mir, 'tcx: 'mir> StoreBuffer {\n     /// Selects a valid store element in the buffer.\n     /// The buffer does not contain the value used to initialise the atomic object\n     /// so a fresh atomic object has an empty store buffer until an explicit store."}]}