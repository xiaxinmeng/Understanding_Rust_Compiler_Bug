{"sha": "24874170b4dfc93243b18815b6d896e87f7ddafe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ODc0MTcwYjRkZmM5MzI0M2IxODgxNWI2ZDg5NmU4N2Y3ZGRhZmU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-08-02T20:10:10Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-08-03T12:08:47Z"}, "message": "split the FFI part of rustc_llvm to rustc_llvm::ffi", "tree": {"sha": "0be914c8d6084a364e644a4e9502a87f026a2fd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0be914c8d6084a364e644a4e9502a87f026a2fd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24874170b4dfc93243b18815b6d896e87f7ddafe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24874170b4dfc93243b18815b6d896e87f7ddafe", "html_url": "https://github.com/rust-lang/rust/commit/24874170b4dfc93243b18815b6d896e87f7ddafe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24874170b4dfc93243b18815b6d896e87f7ddafe/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d091ef802f5aa6d5b81e711ecd7e5f66a76b01a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d091ef802f5aa6d5b81e711ecd7e5f66a76b01a9", "html_url": "https://github.com/rust-lang/rust/commit/d091ef802f5aa6d5b81e711ecd7e5f66a76b01a9"}], "stats": {"total": 4154, "additions": 2087, "deletions": 2067}, "files": [{"sha": "8520ae1df60dd460898aa08fa6549d2bd23b432a", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=24874170b4dfc93243b18815b6d896e87f7ddafe", "patch": "@@ -16,7 +16,8 @@ pub use self::Diagnostic::*;\n use libc::{c_char, c_uint};\n use std::ptr;\n \n-use {DebugLocRef, DiagnosticInfoRef, TwineRef, ValueRef};\n+use {DiagnosticInfoRef, TwineRef, ValueRef};\n+use ffi::DebugLocRef;\n \n #[derive(Copy, Clone)]\n pub enum OptimizationDiagnosticKind {"}, {"sha": "53a287ea8ec0d1ac726a903accae5a73f9f3995c", "filename": "src/librustc_llvm/ffi.rs", "status": "added", "additions": 2063, "deletions": 0, "changes": 2063, "blob_url": "https://github.com/rust-lang/rust/blob/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=24874170b4dfc93243b18815b6d896e87f7ddafe", "patch": "@@ -0,0 +1,2063 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use debuginfo::{DIBuilderRef, DIDescriptor,\n+                DIFile, DILexicalBlock, DISubprogram, DIType,\n+                DIBasicType, DIDerivedType, DICompositeType, DIScope,\n+                DIVariable, DIGlobalVariable, DIArray, DISubrange,\n+                DITemplateTypeParameter, DIEnumerator, DINameSpace};\n+use RustStringRef;\n+\n+use libc::{c_uint, c_ushort, c_int, size_t, c_char};\n+use libc::{c_longlong, c_ulonglong, c_void};\n+\n+pub type Opcode = u32;\n+pub type Bool = c_uint;\n+\n+pub const True: Bool = 1 as Bool;\n+pub const False: Bool = 0 as Bool;\n+\n+#[repr(C)]\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum LLVMRustResult {\n+    Success,\n+    Failure,\n+}\n+// Consts for the LLVM CallConv type, pre-cast to usize.\n+\n+/// LLVM CallingConv::ID. Should we wrap this?\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CallConv {\n+    CCallConv = 0,\n+    FastCallConv = 8,\n+    ColdCallConv = 9,\n+    X86StdcallCallConv = 64,\n+    X86FastcallCallConv = 65,\n+    X86_64_Win64 = 79,\n+    X86_VectorCall = 80\n+}\n+\n+/// LLVMLinkage\n+///\n+/// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n+/// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n+/// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n+/// they've been removed in upstream LLVM commit r203866.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[repr(C)]\n+pub enum Linkage {\n+    ExternalLinkage = 0,\n+    AvailableExternallyLinkage = 1,\n+    LinkOnceAnyLinkage = 2,\n+    LinkOnceODRLinkage = 3,\n+    WeakAnyLinkage = 5,\n+    WeakODRLinkage = 6,\n+    AppendingLinkage = 7,\n+    InternalLinkage = 8,\n+    PrivateLinkage = 9,\n+    ExternalWeakLinkage = 12,\n+    CommonLinkage = 14,\n+}\n+\n+/// LLVMDiagnosticSeverity\n+#[repr(C)]\n+#[derive(Copy, Clone, Debug)]\n+pub enum DiagnosticSeverity {\n+    Error = 0,\n+    Warning = 1,\n+    Remark = 2,\n+    Note = 3,\n+}\n+\n+/// LLVMRustDLLStorageClassTypes\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum DLLStorageClassTypes {\n+    Other,\n+    Default,\n+    DllImport,\n+    DllExport,\n+}\n+\n+bitflags! {\n+    #[derive(Default, Debug)]\n+    flags Attribute : u64 {\n+        const ZExt            = 1 << 0,\n+        const SExt            = 1 << 1,\n+        const NoReturn        = 1 << 2,\n+        const InReg           = 1 << 3,\n+        const StructRet       = 1 << 4,\n+        const NoUnwind        = 1 << 5,\n+        const NoAlias         = 1 << 6,\n+        const ByVal           = 1 << 7,\n+        const Nest            = 1 << 8,\n+        const ReadNone        = 1 << 9,\n+        const ReadOnly        = 1 << 10,\n+        const NoInline        = 1 << 11,\n+        const AlwaysInline    = 1 << 12,\n+        const OptimizeForSize = 1 << 13,\n+        const StackProtect    = 1 << 14,\n+        const StackProtectReq = 1 << 15,\n+        const NoCapture       = 1 << 21,\n+        const NoRedZone       = 1 << 22,\n+        const NoImplicitFloat = 1 << 23,\n+        const Naked           = 1 << 24,\n+        const InlineHint      = 1 << 25,\n+        const ReturnsTwice    = 1 << 29,\n+        const UWTable         = 1 << 30,\n+        const NonLazyBind     = 1 << 31,\n+\n+        // Some of these are missing from the LLVM C API, the rest are\n+        // present, but commented out, and preceded by the following warning:\n+        // FIXME: These attributes are currently not included in the C API as\n+        // a temporary measure until the API/ABI impact to the C API is understood\n+        // and the path forward agreed upon.\n+        const SanitizeAddress = 1 << 32,\n+        const MinSize         = 1 << 33,\n+        const NoDuplicate     = 1 << 34,\n+        const StackProtectStrong = 1 << 35,\n+        const SanitizeThread  = 1 << 36,\n+        const SanitizeMemory  = 1 << 37,\n+        const NoBuiltin       = 1 << 38,\n+        const Returned        = 1 << 39,\n+        const Cold            = 1 << 40,\n+        const Builtin         = 1 << 41,\n+        const OptimizeNone    = 1 << 42,\n+        const InAlloca        = 1 << 43,\n+        const NonNull         = 1 << 44,\n+        const JumpTable       = 1 << 45,\n+        const Convergent      = 1 << 46,\n+        const SafeStack       = 1 << 47,\n+        const NoRecurse       = 1 << 48,\n+        const InaccessibleMemOnly         = 1 << 49,\n+        const InaccessibleMemOrArgMemOnly = 1 << 50,\n+    }\n+}\n+\n+/// LLVMIntPredicate\n+#[derive(Copy, Clone)]\n+pub enum IntPredicate {\n+    IntEQ = 32,\n+    IntNE = 33,\n+    IntUGT = 34,\n+    IntUGE = 35,\n+    IntULT = 36,\n+    IntULE = 37,\n+    IntSGT = 38,\n+    IntSGE = 39,\n+    IntSLT = 40,\n+    IntSLE = 41,\n+}\n+\n+/// LLVMRealPredicate\n+#[derive(Copy, Clone)]\n+pub enum RealPredicate {\n+    RealPredicateFalse = 0,\n+    RealOEQ = 1,\n+    RealOGT = 2,\n+    RealOGE = 3,\n+    RealOLT = 4,\n+    RealOLE = 5,\n+    RealONE = 6,\n+    RealORD = 7,\n+    RealUNO = 8,\n+    RealUEQ = 9,\n+    RealUGT = 10,\n+    RealUGE = 11,\n+    RealULT = 12,\n+    RealULE = 13,\n+    RealUNE = 14,\n+    RealPredicateTrue = 15,\n+}\n+\n+/// LLVMTypeKind; FIXME: wrap\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+pub enum TypeKind {\n+    Void      = 0,\n+    Half      = 1,\n+    Float     = 2,\n+    Double    = 3,\n+    X86_FP80  = 4,\n+    FP128     = 5,\n+    PPC_FP128 = 6,\n+    Label     = 7,\n+    Integer   = 8,\n+    Function  = 9,\n+    Struct    = 10,\n+    Array     = 11,\n+    Pointer   = 12,\n+    Vector    = 13,\n+    Metadata  = 14,\n+    X86_MMX   = 15,\n+}\n+\n+/// LLVMAtomicRmwBinOp\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum AtomicRmwBinOp {\n+    AtomicXchg = 0,\n+    AtomicAdd  = 1,\n+    AtomicSub  = 2,\n+    AtomicAnd  = 3,\n+    AtomicNand = 4,\n+    AtomicOr   = 5,\n+    AtomicXor  = 6,\n+    AtomicMax  = 7,\n+    AtomicMin  = 8,\n+    AtomicUMax = 9,\n+    AtomicUMin = 10,\n+}\n+\n+/// LLVMAtomicOrdering\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum AtomicOrdering {\n+    NotAtomic = 0,\n+    Unordered = 1,\n+    Monotonic = 2,\n+    // Consume = 3,  // Not specified yet.\n+    Acquire = 4,\n+    Release = 5,\n+    AcquireRelease = 6,\n+    SequentiallyConsistent = 7\n+}\n+\n+/// LLVMRustSynchronizationScope\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum SynchronizationScope {\n+    Other,\n+    SingleThread,\n+    CrossThread,\n+}\n+\n+/// LLVMRustFileType\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum FileType {\n+    Other,\n+    AssemblyFile,\n+    ObjectFile,\n+}\n+\n+/// FIXME: ?\n+#[derive(Copy, Clone)]\n+pub enum MetadataType {\n+    MD_dbg = 0,\n+    MD_tbaa = 1,\n+    MD_prof = 2,\n+    MD_fpmath = 3,\n+    MD_range = 4,\n+    MD_tbaa_struct = 5,\n+    MD_invariant_load = 6,\n+    MD_alias_scope = 7,\n+    MD_noalias = 8,\n+    MD_nontemporal = 9,\n+    MD_mem_parallel_loop_access = 10,\n+    MD_nonnull = 11,\n+}\n+\n+/// FIXME: ?\n+#[derive(Copy, Clone)]\n+pub enum AsmDialect {\n+    AD_ATT   = 0,\n+    AD_Intel = 1\n+}\n+\n+/// LLVMRustCodeGenOptLevel\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CodeGenOptLevel {\n+    Other,\n+    None,\n+    Less,\n+    Default,\n+    Aggressive,\n+}\n+\n+/// LLVMRelocMode\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum RelocMode {\n+    Default = 0,\n+    Static = 1,\n+    PIC = 2,\n+    DynamicNoPic = 3,\n+}\n+\n+/// LLVMRustCodeModel\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum CodeModel {\n+    Other,\n+    Default,\n+    JITDefault,\n+    Small,\n+    Kernel,\n+    Medium,\n+    Large,\n+}\n+\n+/// LLVMRustDiagnosticKind\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum DiagnosticKind {\n+    Other,\n+    InlineAsm,\n+    StackSize,\n+    DebugMetadataVersion,\n+    SampleProfile,\n+    OptimizationRemark,\n+    OptimizationRemarkMissed,\n+    OptimizationRemarkAnalysis,\n+    OptimizationRemarkAnalysisFPCommute,\n+    OptimizationRemarkAnalysisAliasing,\n+    OptimizationRemarkOther,\n+    OptimizationFailure,\n+}\n+\n+/// LLVMRustArchiveKind\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum ArchiveKind {\n+    Other,\n+    K_GNU,\n+    K_MIPS64,\n+    K_BSD,\n+    K_COFF,\n+}\n+/// LLVMRustPassKind\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+pub enum PassKind {\n+    Other,\n+    Function,\n+    Module,\n+}\n+\n+// Opaque pointer types\n+#[allow(missing_copy_implementations)]\n+pub enum Module_opaque {}\n+pub type ModuleRef = *mut Module_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Context_opaque {}\n+pub type ContextRef = *mut Context_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Type_opaque {}\n+pub type TypeRef = *mut Type_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Value_opaque {}\n+pub type ValueRef = *mut Value_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Metadata_opaque {}\n+pub type MetadataRef = *mut Metadata_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum BasicBlock_opaque {}\n+pub type BasicBlockRef = *mut BasicBlock_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Builder_opaque {}\n+pub type BuilderRef = *mut Builder_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum ExecutionEngine_opaque {}\n+pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum MemoryBuffer_opaque {}\n+pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum PassManager_opaque {}\n+pub type PassManagerRef = *mut PassManager_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum PassManagerBuilder_opaque {}\n+pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Use_opaque {}\n+pub type UseRef = *mut Use_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum TargetData_opaque {}\n+pub type TargetDataRef = *mut TargetData_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum ObjectFile_opaque {}\n+pub type ObjectFileRef = *mut ObjectFile_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum SectionIterator_opaque {}\n+pub type SectionIteratorRef = *mut SectionIterator_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Pass_opaque {}\n+pub type PassRef = *mut Pass_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum TargetMachine_opaque {}\n+pub type TargetMachineRef = *mut TargetMachine_opaque;\n+pub enum Archive_opaque {}\n+pub type ArchiveRef = *mut Archive_opaque;\n+pub enum ArchiveIterator_opaque {}\n+pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n+pub enum ArchiveChild_opaque {}\n+pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Twine_opaque {}\n+pub type TwineRef = *mut Twine_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum DiagnosticInfo_opaque {}\n+pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum DebugLoc_opaque {}\n+pub type DebugLocRef = *mut DebugLoc_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum SMDiagnostic_opaque {}\n+pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum RustArchiveMember_opaque {}\n+pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum OperandBundleDef_opaque {}\n+pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+\n+pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n+pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n+\n+pub mod debuginfo {\n+    pub use self::DIDescriptorFlags::*;\n+    use super::{MetadataRef};\n+\n+    #[allow(missing_copy_implementations)]\n+    pub enum DIBuilder_opaque {}\n+    pub type DIBuilderRef = *mut DIBuilder_opaque;\n+\n+    pub type DIDescriptor = MetadataRef;\n+    pub type DIScope = DIDescriptor;\n+    pub type DILocation = DIDescriptor;\n+    pub type DIFile = DIScope;\n+    pub type DILexicalBlock = DIScope;\n+    pub type DISubprogram = DIScope;\n+    pub type DINameSpace = DIScope;\n+    pub type DIType = DIDescriptor;\n+    pub type DIBasicType = DIType;\n+    pub type DIDerivedType = DIType;\n+    pub type DICompositeType = DIDerivedType;\n+    pub type DIVariable = DIDescriptor;\n+    pub type DIGlobalVariable = DIDescriptor;\n+    pub type DIArray = DIDescriptor;\n+    pub type DISubrange = DIDescriptor;\n+    pub type DIEnumerator = DIDescriptor;\n+    pub type DITemplateTypeParameter = DIDescriptor;\n+\n+    #[derive(Copy, Clone)]\n+    pub enum DIDescriptorFlags {\n+      FlagPrivate            = 1 << 0,\n+      FlagProtected          = 1 << 1,\n+      FlagFwdDecl            = 1 << 2,\n+      FlagAppleBlock         = 1 << 3,\n+      FlagBlockByrefStruct   = 1 << 4,\n+      FlagVirtual            = 1 << 5,\n+      FlagArtificial         = 1 << 6,\n+      FlagExplicit           = 1 << 7,\n+      FlagPrototyped         = 1 << 8,\n+      FlagObjcClassComplete  = 1 << 9,\n+      FlagObjectPointer      = 1 << 10,\n+      FlagVector             = 1 << 11,\n+      FlagStaticMember       = 1 << 12,\n+      FlagIndirectVariable   = 1 << 13,\n+      FlagLValueReference    = 1 << 14,\n+      FlagRValueReference    = 1 << 15\n+    }\n+}\n+\n+\n+// Link to our native llvm bindings (things that we need to use the C++ api\n+// for) and because llvm is written in C++ we need to link against libstdc++\n+//\n+// You'll probably notice that there is an omission of all LLVM libraries\n+// from this location. This is because the set of LLVM libraries that we\n+// link to is mostly defined by LLVM, and the `llvm-config` tool is used to\n+// figure out the exact set of libraries. To do this, the build system\n+// generates an llvmdeps.rs file next to this one which will be\n+// automatically updated whenever LLVM is updated to include an up-to-date\n+// set of the libraries we need to link to LLVM for.\n+#[link(name = \"rustllvm\", kind = \"static\")]\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n+#[linked_from = \"rustllvm\"] // not quite true but good enough\n+extern {\n+    /* Create and destroy contexts. */\n+    pub fn LLVMContextCreate() -> ContextRef;\n+    pub fn LLVMContextDispose(C: ContextRef);\n+    pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n+                                    Name: *const c_char,\n+                                    SLen: c_uint)\n+                                    -> c_uint;\n+\n+    /* Create and destroy modules. */\n+    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n+                                             C: ContextRef)\n+                                             -> ModuleRef;\n+    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n+    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n+    pub fn LLVMDisposeModule(M: ModuleRef);\n+\n+    /// Data layout. See Module::getDataLayout.\n+    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n+    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n+\n+    /// Target triple. See Module::getTargetTriple.\n+    pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n+    pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n+\n+    /// See Module::dump.\n+    pub fn LLVMDumpModule(M: ModuleRef);\n+\n+    /// See Module::setModuleInlineAsm.\n+    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n+\n+    /// See llvm::LLVMTypeKind::getTypeID.\n+    pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n+\n+    /// See llvm::LLVMType::getContext.\n+    pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n+\n+    /* Operations on integer types */\n+    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint)\n+                                -> TypeRef;\n+\n+    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n+\n+    /* Operations on real types */\n+    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n+\n+    /* Operations on function types */\n+    pub fn LLVMFunctionType(ReturnType: TypeRef,\n+                            ParamTypes: *const TypeRef,\n+                            ParamCount: c_uint,\n+                            IsVarArg: Bool)\n+                            -> TypeRef;\n+    pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n+    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n+    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n+\n+    /* Operations on struct types */\n+    pub fn LLVMStructTypeInContext(C: ContextRef,\n+                                   ElementTypes: *const TypeRef,\n+                                   ElementCount: c_uint,\n+                                   Packed: Bool)\n+                                   -> TypeRef;\n+    pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetStructElementTypes(StructTy: TypeRef,\n+                                     Dest: *mut TypeRef);\n+    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n+\n+    /* Operations on array, pointer, and vector types (sequence types) */\n+    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n+    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n+                           -> TypeRef;\n+    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)\n+                          -> TypeRef;\n+\n+    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n+    pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n+                                  -> *const c_void;\n+    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n+\n+    /* Operations on other types */\n+    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMRustMetadataTypeInContext(C: ContextRef) -> TypeRef;\n+\n+    /* Operations on all values */\n+    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n+    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n+    pub fn LLVMDumpValue(Val: ValueRef);\n+    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n+    pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n+    pub fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n+    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n+\n+    /* Operations on Uses */\n+    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+    pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n+    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n+    pub fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n+\n+    /* Operations on Users */\n+    pub fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n+    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n+\n+    /* Operations on constants of any type */\n+    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n+    /* all zeroes */\n+    pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstICmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n+                         -> ValueRef;\n+    /* only for isize/vector */\n+    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n+    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n+    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n+    pub fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n+\n+    /* Operations on metadata */\n+    pub fn LLVMMDStringInContext(C: ContextRef,\n+                                 Str: *const c_char,\n+                                 SLen: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMMDNodeInContext(C: ContextRef,\n+                               Vals: *const ValueRef,\n+                               Count: c_uint)\n+                               -> ValueRef;\n+    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n+                                       Str: *const c_char,\n+                                       Val: ValueRef);\n+\n+    /* Operations on scalar constants */\n+    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n+                        -> ValueRef;\n+    pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n+                                -> ValueRef;\n+    pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n+                                       Text: *const c_char,\n+                                       SLen: c_uint,\n+                                       Radix: u8)\n+                                       -> ValueRef;\n+    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n+    pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n+                                        Text: *const c_char,\n+                                        SLen: c_uint)\n+                                        -> ValueRef;\n+    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n+    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+\n+\n+    /* Operations on composite constants */\n+    pub fn LLVMConstStringInContext(C: ContextRef,\n+                                    Str: *const c_char,\n+                                    Length: c_uint,\n+                                    DontNullTerminate: Bool)\n+                                    -> ValueRef;\n+    pub fn LLVMConstStructInContext(C: ContextRef,\n+                                    ConstantVals: *const ValueRef,\n+                                    Count: c_uint,\n+                                    Packed: Bool)\n+                                    -> ValueRef;\n+\n+    pub fn LLVMConstArray(ElementTy: TypeRef,\n+                          ConstantVals: *const ValueRef,\n+                          Length: c_uint)\n+                          -> ValueRef;\n+    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n+                           -> ValueRef;\n+\n+    /* Constant expressions */\n+    pub fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                              -> ValueRef;\n+    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                       -> ValueRef;\n+    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstGEP(ConstantVal: ValueRef,\n+                        ConstantIndices: *const ValueRef,\n+                        NumIndices: c_uint)\n+                        -> ValueRef;\n+    pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n+                                ConstantIndices: *const ValueRef,\n+                                NumIndices: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n+                          -> ValueRef;\n+    pub fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n+                            -> ValueRef;\n+    pub fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                          -> ValueRef;\n+    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef)\n+                             -> ValueRef;\n+    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef)\n+                             -> ValueRef;\n+    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                            -> ValueRef;\n+    pub fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                   -> ValueRef;\n+    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                -> ValueRef;\n+    pub fn LLVMConstIntCast(ConstantVal: ValueRef,\n+                            ToType: TypeRef,\n+                            isSigned: Bool)\n+                            -> ValueRef;\n+    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstSelect(ConstantCondition: ValueRef,\n+                           ConstantIfTrue: ValueRef,\n+                           ConstantIfFalse: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstExtractElement(VectorConstant: ValueRef,\n+                                   IndexConstant: ValueRef)\n+                                   -> ValueRef;\n+    pub fn LLVMConstInsertElement(VectorConstant: ValueRef,\n+                                  ElementValueConstant: ValueRef,\n+                                  IndexConstant: ValueRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n+                                  VectorBConstant: ValueRef,\n+                                  MaskConstant: ValueRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n+                                 IdxList: *const c_uint,\n+                                 NumIdx: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n+                                ElementValueConstant: ValueRef,\n+                                IdxList: *const c_uint,\n+                                NumIdx: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n+                              AsmString: *const c_char,\n+                              Constraints: *const c_char,\n+                              HasSideEffects: Bool,\n+                              IsAlignStack: Bool)\n+                              -> ValueRef;\n+    pub fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n+\n+\n+\n+    /* Operations on global variables, functions, and aliases (globals) */\n+    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n+    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n+    pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n+    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n+    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n+    pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n+\n+\n+    /* Operations on global variables */\n+    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n+                                       Ty: TypeRef,\n+                                       Name: *const c_char,\n+                                       AddressSpace: c_uint)\n+                                       -> ValueRef;\n+    pub fn LLVMGetNamedGlobal(M: ModuleRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMRustGetOrInsertGlobal(M: ModuleRef,\n+                                     Name: *const c_char,\n+                                     T: TypeRef)\n+                                     -> ValueRef;\n+    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n+    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMSetInitializer(GlobalVar: ValueRef,\n+                              ConstantVal: ValueRef);\n+    pub fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n+    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n+    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n+    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n+    pub fn LLVMRustGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+\n+    /* Operations on aliases */\n+    pub fn LLVMAddAlias(M: ModuleRef,\n+                        Ty: TypeRef,\n+                        Aliasee: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+\n+    /* Operations on functions */\n+    pub fn LLVMAddFunction(M: ModuleRef,\n+                           Name: *const c_char,\n+                           FunctionTy: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMDeleteFunction(Fn: ValueRef);\n+    pub fn LLVMRustGetOrInsertFunction(M: ModuleRef,\n+                                       Name: *const c_char,\n+                                       FunctionTy: TypeRef)\n+                                       -> ValueRef;\n+    pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+    pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n+    pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n+    pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: u64);\n+    pub fn LLVMRustAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+    pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef, index: c_uint,\n+                                              Name: *const c_char,\n+                                              Value: *const c_char);\n+    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef,\n+                                            index: c_uint,\n+                                            attr: u64);\n+    pub fn LLVMRustRemoveFunctionAttrString(Fn: ValueRef,\n+                                            index: c_uint,\n+                                            Name: *const c_char);\n+    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);\n+\n+    /* Operations on parameters */\n+    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n+    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n+    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n+\n+    /* Operations on basic blocks */\n+    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n+    pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n+    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+\n+    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n+                                         Fn: ValueRef,\n+                                         Name: *const c_char)\n+                                         -> BasicBlockRef;\n+    pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n+                                         BB: BasicBlockRef,\n+                                         Name: *const c_char)\n+                                         -> BasicBlockRef;\n+    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n+\n+    pub fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef,\n+                                   MoveAfter: BasicBlockRef);\n+\n+    pub fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef,\n+                                    MoveBefore: BasicBlockRef);\n+\n+    /* Operations on instructions */\n+    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n+\n+    /* Operations on call sites */\n+    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+    pub fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+    pub fn LLVMAddInstrAttribute(Instr: ValueRef,\n+                                 index: c_uint,\n+                                 IA: c_uint);\n+    pub fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    IA: c_uint);\n+    pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n+                                      index: c_uint,\n+                                      align: c_uint);\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    Val: u64);\n+    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef,\n+                                                  index: c_uint,\n+                                                  bytes: u64);\n+\n+    /* Operations on call instructions (only) */\n+    pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n+    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n+\n+    /* Operations on load/store instructions (only) */\n+    pub fn LLVMGetVolatile(MemoryAccessInst: ValueRef) -> Bool;\n+    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n+\n+    /* Operations on phi nodes */\n+    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n+                           IncomingValues: *const ValueRef,\n+                           IncomingBlocks: *const BasicBlockRef,\n+                           Count: c_uint);\n+    pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+    pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: c_uint)\n+                                -> BasicBlockRef;\n+\n+    /* Instruction builders */\n+    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+    pub fn LLVMPositionBuilder(Builder: BuilderRef,\n+                               Block: BasicBlockRef,\n+                               Instr: ValueRef);\n+    pub fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n+                                     Instr: ValueRef);\n+    pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n+                                    Block: BasicBlockRef);\n+    pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n+    pub fn LLVMClearInsertionPosition(Builder: BuilderRef);\n+    pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n+    pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n+                                         Instr: ValueRef,\n+                                         Name: *const c_char);\n+    pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n+\n+    /* Metadata */\n+    pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n+    pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n+    pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n+\n+    /* Terminators */\n+    pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n+    pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildAggregateRet(B: BuilderRef,\n+                                 RetVals: *const ValueRef,\n+                                 N: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMBuildCondBr(B: BuilderRef,\n+                           If: ValueRef,\n+                           Then: BasicBlockRef,\n+                           Else: BasicBlockRef)\n+                           -> ValueRef;\n+    pub fn LLVMBuildSwitch(B: BuilderRef,\n+                           V: ValueRef,\n+                           Else: BasicBlockRef,\n+                           NumCases: c_uint)\n+                           -> ValueRef;\n+    pub fn LLVMBuildIndirectBr(B: BuilderRef,\n+                               Addr: ValueRef,\n+                               NumDests: c_uint)\n+                               -> ValueRef;\n+    pub fn LLVMRustBuildInvoke(B: BuilderRef,\n+                               Fn: ValueRef,\n+                               Args: *const ValueRef,\n+                               NumArgs: c_uint,\n+                               Then: BasicBlockRef,\n+                               Catch: BasicBlockRef,\n+                               Bundle: OperandBundleDefRef,\n+                               Name: *const c_char)\n+                               -> ValueRef;\n+    pub fn LLVMRustBuildLandingPad(B: BuilderRef,\n+                                   Ty: TypeRef,\n+                                   PersFn: ValueRef,\n+                                   NumClauses: c_uint,\n+                                   Name: *const c_char,\n+                                   F: ValueRef)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n+\n+    pub fn LLVMRustBuildCleanupPad(B: BuilderRef,\n+                                   ParentPad: ValueRef,\n+                                   ArgCnt: c_uint,\n+                                   Args: *const ValueRef,\n+                                   Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustBuildCleanupRet(B: BuilderRef,\n+                                   CleanupPad: ValueRef,\n+                                   UnwindBB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMRustBuildCatchPad(B: BuilderRef,\n+                                 ParentPad: ValueRef,\n+                                 ArgCnt: c_uint,\n+                                 Args: *const ValueRef,\n+                                 Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustBuildCatchRet(B: BuilderRef,\n+                                 Pad: ValueRef,\n+                                 BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMRustBuildCatchSwitch(Builder: BuilderRef,\n+                                    ParentPad: ValueRef,\n+                                    BB: BasicBlockRef,\n+                                    NumHandlers: c_uint,\n+                                    Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef,\n+                              Handler: BasicBlockRef);\n+    pub fn LLVMRustSetPersonalityFn(B: BuilderRef, Pers: ValueRef);\n+\n+    /* Add a case to the switch instruction */\n+    pub fn LLVMAddCase(Switch: ValueRef,\n+                       OnVal: ValueRef,\n+                       Dest: BasicBlockRef);\n+\n+    /* Add a destination to the indirectbr instruction */\n+    pub fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n+\n+    /* Add a clause to the landing pad instruction */\n+    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n+\n+    /* Set the cleanup on a landing pad instruction */\n+    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n+\n+    /* Arithmetic */\n+    pub fn LLVMBuildAdd(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWAdd(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWAdd(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFAdd(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSub(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWSub(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWSub(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFSub(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildMul(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWMul(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWMul(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFMul(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildUDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildExactSDiv(B: BuilderRef,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildFDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildURem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSRem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFRem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildShl(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildLShr(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildAShr(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildAnd(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildOr(B: BuilderRef,\n+                       LHS: ValueRef,\n+                       RHS: ValueRef,\n+                       Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildXor(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildBinOp(B: BuilderRef,\n+                          Op: Opcode,\n+                          LHS: ValueRef,\n+                          RHS: ValueRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n+\n+    /* Memory */\n+    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildLoad(B: BuilderRef,\n+                         PointerVal: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+\n+    pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n+                          -> ValueRef;\n+\n+    pub fn LLVMBuildGEP(B: BuilderRef,\n+                        Pointer: ValueRef,\n+                        Indices: *const ValueRef,\n+                        NumIndices: c_uint,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n+                                Pointer: ValueRef,\n+                                Indices: *const ValueRef,\n+                                NumIndices: c_uint,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildStructGEP(B: BuilderRef,\n+                              Pointer: ValueRef,\n+                              Idx: c_uint,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildGlobalString(B: BuilderRef,\n+                                 Str: *const c_char,\n+                                 Name: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n+                                    Str: *const c_char,\n+                                    Name: *const c_char)\n+                                    -> ValueRef;\n+\n+    /* Casts */\n+    pub fn LLVMBuildTrunc(B: BuilderRef,\n+                          Val: ValueRef,\n+                          DestTy: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildZExt(B: BuilderRef,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSExt(B: BuilderRef,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFPToUI(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFPToSI(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildUIToFP(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildSIToFP(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFPTrunc(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildFPExt(B: BuilderRef,\n+                          Val: ValueRef,\n+                          DestTy: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildPtrToInt(B: BuilderRef,\n+                             Val: ValueRef,\n+                             DestTy: TypeRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildIntToPtr(B: BuilderRef,\n+                             Val: ValueRef,\n+                             DestTy: TypeRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildBitCast(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n+                                   Val: ValueRef,\n+                                   DestTy: TypeRef,\n+                                   Name: *const c_char)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildCast(B: BuilderRef,\n+                         Op: Opcode,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char) -> ValueRef;\n+    pub fn LLVMBuildPointerCast(B: BuilderRef,\n+                                Val: ValueRef,\n+                                DestTy: TypeRef,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildIntCast(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildFPCast(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+\n+    /* Comparisons */\n+    pub fn LLVMBuildICmp(B: BuilderRef,\n+                         Op: c_uint,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFCmp(B: BuilderRef,\n+                         Op: c_uint,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+\n+    /* Miscellaneous instructions */\n+    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMRustBuildCall(B: BuilderRef,\n+                             Fn: ValueRef,\n+                             Args: *const ValueRef,\n+                             NumArgs: c_uint,\n+                             Bundle: OperandBundleDefRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildSelect(B: BuilderRef,\n+                           If: ValueRef,\n+                           Then: ValueRef,\n+                           Else: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildVAArg(B: BuilderRef,\n+                          list: ValueRef,\n+                          Ty: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildExtractElement(B: BuilderRef,\n+                                   VecVal: ValueRef,\n+                                   Index: ValueRef,\n+                                   Name: *const c_char)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildInsertElement(B: BuilderRef,\n+                                  VecVal: ValueRef,\n+                                  EltVal: ValueRef,\n+                                  Index: ValueRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildShuffleVector(B: BuilderRef,\n+                                  V1: ValueRef,\n+                                  V2: ValueRef,\n+                                  Mask: ValueRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildExtractValue(B: BuilderRef,\n+                                 AggVal: ValueRef,\n+                                 Index: c_uint,\n+                                 Name: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildInsertValue(B: BuilderRef,\n+                                AggVal: ValueRef,\n+                                EltVal: ValueRef,\n+                                Index: c_uint,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+\n+    pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildPtrDiff(B: BuilderRef,\n+                            LHS: ValueRef,\n+                            RHS: ValueRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+\n+    /* Atomic Operations */\n+    pub fn LLVMRustBuildAtomicLoad(B: BuilderRef,\n+                                   PointerVal: ValueRef,\n+                                   Name: *const c_char,\n+                                   Order: AtomicOrdering,\n+                                   Alignment: c_uint)\n+                                   -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicStore(B: BuilderRef,\n+                                    Val: ValueRef,\n+                                    Ptr: ValueRef,\n+                                    Order: AtomicOrdering,\n+                                    Alignment: c_uint)\n+                                    -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n+                                      LHS: ValueRef,\n+                                      CMP: ValueRef,\n+                                      RHS: ValueRef,\n+                                      Order: AtomicOrdering,\n+                                      FailureOrder: AtomicOrdering,\n+                                      Weak: Bool)\n+                                      -> ValueRef;\n+\n+    pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n+                              Op: AtomicRmwBinOp,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Order: AtomicOrdering,\n+                              SingleThreaded: Bool)\n+                              -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicFence(B: BuilderRef,\n+                                    Order: AtomicOrdering,\n+                                    Scope: SynchronizationScope);\n+\n+\n+    /* Selected entries from the downcasts. */\n+    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n+\n+    /// Writes a module to the specified path. Returns 0 on success.\n+    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n+\n+    /// Creates target data from a target layout string.\n+    pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n+    /// Number of bytes clobbered when doing a Store to *T.\n+    pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n+                               -> c_ulonglong;\n+\n+    /// Number of bytes clobbered when doing a Store to *T.\n+    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n+                                -> c_ulonglong;\n+\n+    /// Distance between successive elements in an array of T. Includes ABI padding.\n+    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n+\n+    /// Returns the preferred alignment of a type.\n+    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                        -> c_uint;\n+    /// Returns the minimum alignment of a type.\n+    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                  -> c_uint;\n+\n+    /// Computes the byte offset of the indexed struct element for a\n+    /// target.\n+    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n+                               StructTy: TypeRef,\n+                               Element: c_uint)\n+                               -> c_ulonglong;\n+\n+    /// Returns the minimum alignment of a type when part of a call frame.\n+    pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                        -> c_uint;\n+\n+    /// Disposes target data.\n+    pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n+\n+    /// Creates a pass manager.\n+    pub fn LLVMCreatePassManager() -> PassManagerRef;\n+\n+    /// Creates a function-by-function pass manager\n+    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n+                                                  -> PassManagerRef;\n+\n+    /// Disposes a pass manager.\n+    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n+\n+    /// Runs a pass manager on a module.\n+    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n+\n+    /// Runs the function passes on the provided function.\n+    pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n+                                      -> Bool;\n+\n+    /// Initializes all the function passes scheduled in the manager\n+    pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n+\n+    /// Finalizes all the function passes scheduled in the manager\n+    pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n+\n+    pub fn LLVMInitializePasses();\n+\n+    /// Adds a verification pass.\n+    pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n+\n+    pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n+    pub fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n+    pub fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n+    pub fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n+    pub fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n+    pub fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n+    pub fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n+    pub fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n+    pub fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n+    pub fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n+    pub fn LLVMAddReassociatePass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n+    pub fn LLVMAddLICMPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n+    pub fn LLVMAddGVNPass(PM: PassManagerRef);\n+    pub fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n+    pub fn LLVMAddSCCPPass(PM: PassManagerRef);\n+    pub fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n+    pub fn LLVMAddConstantMergePass(PM: PassManagerRef);\n+    pub fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n+    pub fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n+    pub fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n+    pub fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n+    pub fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n+    pub fn LLVMAddPruneEHPass(PM: PassManagerRef);\n+    pub fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n+    pub fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n+    pub fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n+    pub fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n+\n+    pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n+    pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n+    pub fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n+                                             OptimizationLevel: c_uint);\n+    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n+                                              Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n+        PMB: PassManagerBuilderRef,\n+        threshold: c_uint);\n+    pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+\n+    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef,\n+        Internalize: Bool,\n+        RunInliner: Bool);\n+\n+    /// Destroys a memory buffer.\n+    pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n+\n+\n+    /* Stuff that's in rustllvm/ because it's not upstream yet. */\n+\n+    /// Opens an object file.\n+    pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n+    /// Closes an object file.\n+    pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n+\n+    /// Enumerates the sections in an object file.\n+    pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n+    /// Destroys a section iterator.\n+    pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n+    /// Returns true if the section iterator is at the end of the section\n+    /// list:\n+    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n+                                      SI: SectionIteratorRef)\n+                                      -> Bool;\n+    /// Moves the section iterator to point to the next section.\n+    pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n+    /// Returns the current section size.\n+    pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n+    /// Returns the current section contents as a string buffer.\n+    pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n+\n+    /// Reads the given file and returns it as a memory buffer. Use\n+    /// LLVMDisposeMemoryBuffer() to get rid of it.\n+    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n+                                                        -> MemoryBufferRef;\n+    /// Borrows the contents of the memory buffer (doesn't copy it)\n+    pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n+                                                 InputDataLength: size_t,\n+                                                 BufferName: *const c_char,\n+                                                 RequiresNull: Bool)\n+                                                 -> MemoryBufferRef;\n+    pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n+                                                     InputDataLength: size_t,\n+                                                     BufferName: *const c_char)\n+                                                     -> MemoryBufferRef;\n+\n+    pub fn LLVMIsMultithreaded() -> Bool;\n+    pub fn LLVMStartMultithreaded() -> Bool;\n+\n+    /// Returns a string describing the last error caused by an LLVMRust* call.\n+    pub fn LLVMRustGetLastError() -> *const c_char;\n+\n+    /// Print the pass timings since static dtors aren't picking them up.\n+    pub fn LLVMRustPrintPassTimings();\n+\n+    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n+\n+    pub fn LLVMStructSetBody(StructTy: TypeRef,\n+                             ElementTypes: *const TypeRef,\n+                             ElementCount: c_uint,\n+                             Packed: Bool);\n+\n+    pub fn LLVMConstNamedStruct(S: TypeRef,\n+                                ConstantVals: *const ValueRef,\n+                                Count: c_uint)\n+                                -> ValueRef;\n+\n+    /// Enables LLVM debug output.\n+    pub fn LLVMRustSetDebug(Enabled: c_int);\n+\n+    /// Prepares inline assembly.\n+    pub fn LLVMRustInlineAsm(Ty: TypeRef,\n+                             AsmString: *const c_char,\n+                             Constraints: *const c_char,\n+                             SideEffects: Bool,\n+                             AlignStack: Bool,\n+                             Dialect: c_uint)\n+                             -> ValueRef;\n+\n+    pub fn LLVMRustDebugMetadataVersion() -> u32;\n+    pub fn LLVMRustVersionMajor() -> u32;\n+    pub fn LLVMRustVersionMinor() -> u32;\n+\n+    pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n+                                 name: *const c_char,\n+                                 value: u32);\n+\n+    pub fn LLVMRustDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n+\n+    pub fn LLVMRustDIBuilderDispose(Builder: DIBuilderRef);\n+\n+    pub fn LLVMRustDIBuilderFinalize(Builder: DIBuilderRef);\n+\n+    pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n+                                              Lang: c_uint,\n+                                              File: *const c_char,\n+                                              Dir: *const c_char,\n+                                              Producer: *const c_char,\n+                                              isOptimized: bool,\n+                                              Flags: *const c_char,\n+                                              RuntimeVer: c_uint,\n+                                              SplitName: *const c_char)\n+                                              -> DIDescriptor;\n+\n+    pub fn LLVMRustDIBuilderCreateFile(Builder: DIBuilderRef,\n+                                       Filename: *const c_char,\n+                                       Directory: *const c_char)\n+                                       -> DIFile;\n+\n+    pub fn LLVMRustDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n+                                                 File: DIFile,\n+                                                 ParameterTypes: DIArray)\n+                                                 -> DICompositeType;\n+\n+    pub fn LLVMRustDIBuilderCreateFunction(Builder: DIBuilderRef,\n+                                           Scope: DIDescriptor,\n+                                           Name: *const c_char,\n+                                           LinkageName: *const c_char,\n+                                           File: DIFile,\n+                                           LineNo: c_uint,\n+                                           Ty: DIType,\n+                                           isLocalToUnit: bool,\n+                                           isDefinition: bool,\n+                                           ScopeLine: c_uint,\n+                                           Flags: c_uint,\n+                                           isOptimized: bool,\n+                                           Fn: ValueRef,\n+                                           TParam: DIArray,\n+                                           Decl: DIDescriptor)\n+                                           -> DISubprogram;\n+\n+    pub fn LLVMRustDIBuilderCreateBasicType(Builder: DIBuilderRef,\n+                                            Name: *const c_char,\n+                                            SizeInBits: u64,\n+                                            AlignInBits: u64,\n+                                            Encoding: c_uint)\n+                                            -> DIBasicType;\n+\n+    pub fn LLVMRustDIBuilderCreatePointerType(Builder: DIBuilderRef,\n+                                          PointeeTy: DIType,\n+                                          SizeInBits: u64,\n+                                          AlignInBits: u64,\n+                                          Name: *const c_char)\n+                                          -> DIDerivedType;\n+\n+    pub fn LLVMRustDIBuilderCreateStructType(Builder: DIBuilderRef,\n+                                             Scope: DIDescriptor,\n+                                             Name: *const c_char,\n+                                             File: DIFile,\n+                                             LineNumber: c_uint,\n+                                             SizeInBits: u64,\n+                                             AlignInBits: u64,\n+                                             Flags: c_uint,\n+                                             DerivedFrom: DIType,\n+                                             Elements: DIArray,\n+                                             RunTimeLang: c_uint,\n+                                             VTableHolder: DIType,\n+                                             UniqueId: *const c_char)\n+                                             -> DICompositeType;\n+\n+    pub fn LLVMRustDIBuilderCreateMemberType(Builder: DIBuilderRef,\n+                                             Scope: DIDescriptor,\n+                                             Name: *const c_char,\n+                                             File: DIFile,\n+                                             LineNo: c_uint,\n+                                             SizeInBits: u64,\n+                                             AlignInBits: u64,\n+                                             OffsetInBits: u64,\n+                                             Flags: c_uint,\n+                                             Ty: DIType)\n+                                             -> DIDerivedType;\n+\n+    pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n+                                               Scope: DIScope,\n+                                               File: DIFile,\n+                                               Line: c_uint,\n+                                               Col: c_uint)\n+                                               -> DILexicalBlock;\n+\n+    pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n+                                                 Context: DIScope,\n+                                                 Name: *const c_char,\n+                                                 LinkageName: *const c_char,\n+                                                 File: DIFile,\n+                                                 LineNo: c_uint,\n+                                                 Ty: DIType,\n+                                                 isLocalToUnit: bool,\n+                                                 Val: ValueRef,\n+                                                 Decl: DIDescriptor)\n+                                                 -> DIGlobalVariable;\n+\n+    pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,\n+                                           Tag: c_uint,\n+                                           Scope: DIDescriptor,\n+                                           Name: *const c_char,\n+                                           File: DIFile,\n+                                           LineNo: c_uint,\n+                                           Ty: DIType,\n+                                           AlwaysPreserve: bool,\n+                                           Flags: c_uint,\n+                                           AddrOps: *const i64,\n+                                           AddrOpsCount: c_uint,\n+                                           ArgNo: c_uint)\n+                                           -> DIVariable;\n+\n+    pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,\n+                                            Size: u64,\n+                                            AlignInBits: u64,\n+                                            Ty: DIType,\n+                                            Subscripts: DIArray)\n+                                            -> DIType;\n+\n+    pub fn LLVMRustDIBuilderCreateVectorType(Builder: DIBuilderRef,\n+                                             Size: u64,\n+                                             AlignInBits: u64,\n+                                             Ty: DIType,\n+                                             Subscripts: DIArray)\n+                                             -> DIType;\n+\n+    pub fn LLVMRustDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n+                                                Lo: i64,\n+                                                Count: i64)\n+                                                -> DISubrange;\n+\n+    pub fn LLVMRustDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n+                                             Ptr: *const DIDescriptor,\n+                                             Count: c_uint)\n+                                             -> DIArray;\n+\n+    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n+                                               Val: ValueRef,\n+                                               VarInfo: DIVariable,\n+                                               AddrOps: *const i64,\n+                                               AddrOpsCount: c_uint,\n+                                               DL: ValueRef,\n+                                               InsertAtEnd: BasicBlockRef)\n+                                               -> ValueRef;\n+\n+    pub fn LLVMRustDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n+                                                Val: ValueRef,\n+                                                VarInfo: DIVariable,\n+                                                AddrOps: *const i64,\n+                                                AddrOpsCount: c_uint,\n+                                                DL: ValueRef,\n+                                                InsertBefore: ValueRef)\n+                                                -> ValueRef;\n+\n+    pub fn LLVMRustDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n+                                             Name: *const c_char,\n+                                             Val: u64)\n+                                             -> DIEnumerator;\n+\n+    pub fn LLVMRustDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n+                                                  Scope: DIScope,\n+                                                  Name: *const c_char,\n+                                                  File: DIFile,\n+                                                  LineNumber: c_uint,\n+                                                  SizeInBits: u64,\n+                                                  AlignInBits: u64,\n+                                                  Elements: DIArray,\n+                                                  ClassType: DIType)\n+                                                  -> DIType;\n+\n+    pub fn LLVMRustDIBuilderCreateUnionType(Builder: DIBuilderRef,\n+                                            Scope: DIScope,\n+                                            Name: *const c_char,\n+                                            File: DIFile,\n+                                            LineNumber: c_uint,\n+                                            SizeInBits: u64,\n+                                            AlignInBits: u64,\n+                                            Flags: c_uint,\n+                                            Elements: DIArray,\n+                                            RunTimeLang: c_uint,\n+                                            UniqueId: *const c_char)\n+                                            -> DIType;\n+\n+    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n+\n+    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n+                                                        Scope: DIScope,\n+                                                        Name: *const c_char,\n+                                                        Ty: DIType,\n+                                                        File: DIFile,\n+                                                        LineNo: c_uint,\n+                                                        ColumnNo: c_uint)\n+                                                        -> DITemplateTypeParameter;\n+\n+\n+    pub fn LLVMRustDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n+                                            Scope: DIScope,\n+                                            Name: *const c_char,\n+                                            File: DIFile,\n+                                            LineNo: c_uint)\n+                                            -> DINameSpace;\n+    pub fn LLVMRustDICompositeTypeSetTypeArray(Builder: DIBuilderRef,\n+                                               CompositeType: DIType,\n+                                               TypeArray: DIArray);\n+\n+\n+    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: ContextRef,\n+                                                Line: c_uint,\n+                                                Column: c_uint,\n+                                                Scope: DIScope,\n+                                                InlinedAt: MetadataRef)\n+                                                -> ValueRef;\n+    pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n+    pub fn LLVMRustDIBuilderCreateOpPlus() -> i64;\n+\n+    pub fn LLVMRustWriteTypeToString(Type: TypeRef, s: RustStringRef);\n+    pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n+\n+    pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n+\n+    pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n+\n+    pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n+    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n+    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n+\n+    pub fn LLVMRustHasFeature(T: TargetMachineRef,\n+                              s: *const c_char) -> bool;\n+\n+    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n+                                       CPU: *const c_char,\n+                                       Features: *const c_char,\n+                                       Model: CodeModel,\n+                                       Reloc: RelocMode,\n+                                       Level: CodeGenOptLevel,\n+                                       UseSoftFP: bool,\n+                                       PositionIndependentExecutable: bool,\n+                                       FunctionSections: bool,\n+                                       DataSections: bool) -> TargetMachineRef;\n+    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n+    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n+                                     PM: PassManagerRef,\n+                                     M: ModuleRef);\n+    pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n+                                         M: ModuleRef,\n+                                         DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n+                                               OptLevel: CodeGenOptLevel,\n+                                               MergeFunctions: bool,\n+                                               SLPVectorize: bool,\n+                                               LoopVectorize: bool);\n+    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n+                                  DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n+    pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n+                                   PM: PassManagerRef,\n+                                   M: ModuleRef,\n+                                   Output: *const c_char,\n+                                   FileType: FileType)\n+                                   -> LLVMRustResult;\n+    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n+                               M: ModuleRef,\n+                               Output: *const c_char);\n+    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n+    pub fn LLVMRustPrintPasses();\n+    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n+    pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n+                                       AddLifetimes: bool);\n+    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n+                                         bc: *const c_char,\n+                                         len: size_t) -> bool;\n+    pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n+                                      syms: *const *const c_char,\n+                                      len: size_t);\n+    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n+\n+    pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n+    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n+    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n+    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildFree(ACR: ArchiveChildRef);\n+    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n+    pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n+\n+    pub fn LLVMRustSetDLLStorageClass(V: ValueRef,\n+                                      C: DLLStorageClassTypes);\n+\n+    pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n+                                  data: *mut *const c_char) -> size_t;\n+\n+    pub fn LLVMRustWriteTwineToString(T: TwineRef, s: RustStringRef);\n+\n+    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n+                                           Handler: DiagnosticHandler,\n+                                           DiagnosticContext: *mut c_void);\n+\n+    pub fn LLVMRustUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n+                                                pass_name_out: *mut *const c_char,\n+                                                function_out: *mut ValueRef,\n+                                                debugloc_out: *mut DebugLocRef,\n+                                                message_out: *mut TwineRef);\n+    pub fn LLVMRustUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n+                                             cookie_out: *mut c_uint,\n+                                             message_out: *mut TwineRef,\n+                                             instruction_out: *mut ValueRef);\n+\n+    pub fn LLVMRustWriteDiagnosticInfoToString(DI: DiagnosticInfoRef,\n+                                               s: RustStringRef);\n+    pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;\n+    pub fn LLVMRustGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n+\n+    pub fn LLVMRustWriteDebugLocToString(C: ContextRef,\n+                                         DL: DebugLocRef,\n+                                         s: RustStringRef);\n+\n+    pub fn LLVMRustSetInlineAsmDiagnosticHandler(C: ContextRef,\n+                                                 H: InlineAsmDiagHandler,\n+                                                 CX: *mut c_void);\n+\n+    pub fn LLVMRustWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n+\n+    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n+                                NumMembers: size_t,\n+                                Members: *const RustArchiveMemberRef,\n+                                WriteSymbtab: bool,\n+                                Kind: ArchiveKind) ->\n+                                LLVMRustResult;\n+    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n+                                    Name: *const c_char,\n+                                    Child: ArchiveChildRef) -> RustArchiveMemberRef;\n+    pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n+\n+    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef,\n+                                                  TM: TargetMachineRef);\n+    pub fn LLVMRustGetModuleDataLayout(M: ModuleRef) -> TargetDataRef;\n+\n+    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n+                                         Inputs: *const ValueRef,\n+                                         NumInputs: c_uint)\n+                                         -> OperandBundleDefRef;\n+    pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n+\n+    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n+\n+    pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n+    pub fn LLVMRustUnsetComdat(V: ValueRef);\n+    pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n+}\n+\n+\n+// LLVM requires symbols from this library, but apparently they're not printed\n+// during llvm-config?\n+#[cfg(windows)]\n+#[link(name = \"ole32\")]\n+extern {}"}, {"sha": "f451b167196c96cf626bfbd65d41541fb5dc6a8c", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 18, "deletions": 2062, "changes": 2080, "blob_url": "https://github.com/rust-lang/rust/blob/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=24874170b4dfc93243b18815b6d896e87f7ddafe", "patch": "@@ -37,43 +37,26 @@ pub use self::AttributeSet::*;\n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n pub use self::TypeKind::*;\n-pub use self::AtomicBinOp::*;\n+pub use self::AtomicRmwBinOp::*;\n pub use self::MetadataType::*;\n pub use self::AsmDialect::*;\n pub use self::CodeGenOptSize::*;\n pub use self::DiagnosticKind::*;\n pub use self::CallConv::*;\n-pub use self::Visibility::*;\n pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n \n use std::str::FromStr;\n+use std::slice;\n use std::ffi::{CString, CStr};\n use std::cell::RefCell;\n-use std::slice;\n-use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n-use libc::{c_longlong, c_ulonglong, c_void};\n-use debuginfo::{DIBuilderRef, DIDescriptor,\n-                DIFile, DILexicalBlock, DISubprogram, DIType,\n-                DIBasicType, DIDerivedType, DICompositeType, DIScope,\n-                DIVariable, DIGlobalVariable, DIArray, DISubrange,\n-                DITemplateTypeParameter, DIEnumerator, DINameSpace};\n+use libc::{c_uint, c_ushort, c_char, size_t};\n \n pub mod archive_ro;\n pub mod diagnostic;\n+pub mod ffi;\n \n-pub type Opcode = u32;\n-pub type Bool = c_uint;\n-\n-pub const True: Bool = 1 as Bool;\n-pub const False: Bool = 0 as Bool;\n-\n-#[repr(C)]\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum LLVMRustResult {\n-    Success = 0,\n-    Failure = 1\n-}\n+pub use ffi::*;\n \n impl LLVMRustResult {\n     pub fn into_result(self) -> Result<(), ()> {\n@@ -84,122 +67,6 @@ impl LLVMRustResult {\n     }\n }\n \n-// Consts for the LLVM CallConv type, pre-cast to usize.\n-\n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum CallConv {\n-    CCallConv = 0,\n-    FastCallConv = 8,\n-    ColdCallConv = 9,\n-    X86StdcallCallConv = 64,\n-    X86FastcallCallConv = 65,\n-    X86_64_Win64 = 79,\n-    X86_VectorCall = 80\n-}\n-\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum Visibility {\n-    LLVMDefaultVisibility = 0,\n-    HiddenVisibility = 1,\n-    ProtectedVisibility = 2,\n-}\n-\n-// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n-// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n-// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n-// they've been removed in upstream LLVM commit r203866.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-#[repr(C)]\n-pub enum Linkage {\n-    ExternalLinkage = 0,\n-    AvailableExternallyLinkage = 1,\n-    LinkOnceAnyLinkage = 2,\n-    LinkOnceODRLinkage = 3,\n-    WeakAnyLinkage = 5,\n-    WeakODRLinkage = 6,\n-    AppendingLinkage = 7,\n-    InternalLinkage = 8,\n-    PrivateLinkage = 9,\n-    ExternalWeakLinkage = 12,\n-    CommonLinkage = 14,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone, Debug)]\n-pub enum DiagnosticSeverity {\n-    Error = 0,\n-    Warning = 1,\n-    Remark = 2,\n-    Note = 3,\n-}\n-\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum DLLStorageClassTypes {\n-    Other,\n-    Default,\n-    DllImport,\n-    DllExport,\n-}\n-\n-bitflags! {\n-    #[derive(Default, Debug)]\n-    flags Attribute : u64 {\n-        const ZExt            = 1 << 0,\n-        const SExt            = 1 << 1,\n-        const NoReturn        = 1 << 2,\n-        const InReg           = 1 << 3,\n-        const StructRet       = 1 << 4,\n-        const NoUnwind        = 1 << 5,\n-        const NoAlias         = 1 << 6,\n-        const ByVal           = 1 << 7,\n-        const Nest            = 1 << 8,\n-        const ReadNone        = 1 << 9,\n-        const ReadOnly        = 1 << 10,\n-        const NoInline        = 1 << 11,\n-        const AlwaysInline    = 1 << 12,\n-        const OptimizeForSize = 1 << 13,\n-        const StackProtect    = 1 << 14,\n-        const StackProtectReq = 1 << 15,\n-        const NoCapture       = 1 << 21,\n-        const NoRedZone       = 1 << 22,\n-        const NoImplicitFloat = 1 << 23,\n-        const Naked           = 1 << 24,\n-        const InlineHint      = 1 << 25,\n-        const ReturnsTwice    = 1 << 29,\n-        const UWTable         = 1 << 30,\n-        const NonLazyBind     = 1 << 31,\n-\n-        // Some of these are missing from the LLVM C API, the rest are\n-        // present, but commented out, and preceded by the following warning:\n-        // FIXME: These attributes are currently not included in the C API as\n-        // a temporary measure until the API/ABI impact to the C API is understood\n-        // and the path forward agreed upon.\n-        const SanitizeAddress = 1 << 32,\n-        const MinSize         = 1 << 33,\n-        const NoDuplicate     = 1 << 34,\n-        const StackProtectStrong = 1 << 35,\n-        const SanitizeThread  = 1 << 36,\n-        const SanitizeMemory  = 1 << 37,\n-        const NoBuiltin       = 1 << 38,\n-        const Returned        = 1 << 39,\n-        const Cold            = 1 << 40,\n-        const Builtin         = 1 << 41,\n-        const OptimizeNone    = 1 << 42,\n-        const InAlloca        = 1 << 43,\n-        const NonNull         = 1 << 44,\n-        const JumpTable       = 1 << 45,\n-        const Convergent      = 1 << 46,\n-        const SafeStack       = 1 << 47,\n-        const NoRecurse       = 1 << 48,\n-        const InaccessibleMemOnly         = 1 << 49,\n-        const InaccessibleMemOrArgMemOnly = 1 << 50,\n-    }\n-}\n-\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Attributes {\n     regular: Attribute,\n@@ -255,143 +122,6 @@ pub enum AttributeSet {\n     FunctionIndex = !0\n }\n \n-// enum for the LLVM IntPredicate type\n-#[derive(Copy, Clone)]\n-pub enum IntPredicate {\n-    IntEQ = 32,\n-    IntNE = 33,\n-    IntUGT = 34,\n-    IntUGE = 35,\n-    IntULT = 36,\n-    IntULE = 37,\n-    IntSGT = 38,\n-    IntSGE = 39,\n-    IntSLT = 40,\n-    IntSLE = 41,\n-}\n-\n-// enum for the LLVM RealPredicate type\n-#[derive(Copy, Clone)]\n-pub enum RealPredicate {\n-    RealPredicateFalse = 0,\n-    RealOEQ = 1,\n-    RealOGT = 2,\n-    RealOGE = 3,\n-    RealOLT = 4,\n-    RealOLE = 5,\n-    RealONE = 6,\n-    RealORD = 7,\n-    RealUNO = 8,\n-    RealUEQ = 9,\n-    RealUGT = 10,\n-    RealUGE = 11,\n-    RealULT = 12,\n-    RealULE = 13,\n-    RealUNE = 14,\n-    RealPredicateTrue = 15,\n-}\n-\n-// The LLVM TypeKind type - must stay in sync with the def of\n-// LLVMTypeKind in llvm/include/llvm-c/Core.h\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum TypeKind {\n-    Void      = 0,\n-    Half      = 1,\n-    Float     = 2,\n-    Double    = 3,\n-    X86_FP80  = 4,\n-    FP128     = 5,\n-    PPC_FP128 = 6,\n-    Label     = 7,\n-    Integer   = 8,\n-    Function  = 9,\n-    Struct    = 10,\n-    Array     = 11,\n-    Pointer   = 12,\n-    Vector    = 13,\n-    Metadata  = 14,\n-    X86_MMX   = 15,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AtomicBinOp {\n-    AtomicXchg = 0,\n-    AtomicAdd  = 1,\n-    AtomicSub  = 2,\n-    AtomicAnd  = 3,\n-    AtomicNand = 4,\n-    AtomicOr   = 5,\n-    AtomicXor  = 6,\n-    AtomicMax  = 7,\n-    AtomicMin  = 8,\n-    AtomicUMax = 9,\n-    AtomicUMin = 10,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AtomicOrdering {\n-    NotAtomic = 0,\n-    Unordered = 1,\n-    Monotonic = 2,\n-    // Consume = 3,  // Not specified yet.\n-    Acquire = 4,\n-    Release = 5,\n-    AcquireRelease = 6,\n-    SequentiallyConsistent = 7\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum SynchronizationScope {\n-    Other,\n-    SingleThread,\n-    CrossThread,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum FileType {\n-    Other,\n-    AssemblyFile,\n-    ObjectFile,\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum MetadataType {\n-    MD_dbg = 0,\n-    MD_tbaa = 1,\n-    MD_prof = 2,\n-    MD_fpmath = 3,\n-    MD_range = 4,\n-    MD_tbaa_struct = 5,\n-    MD_invariant_load = 6,\n-    MD_alias_scope = 7,\n-    MD_noalias = 8,\n-    MD_nontemporal = 9,\n-    MD_mem_parallel_loop_access = 10,\n-    MD_nonnull = 11,\n-}\n-\n-// Inline Asm Dialect\n-#[derive(Copy, Clone)]\n-pub enum AsmDialect {\n-    AD_ATT   = 0,\n-    AD_Intel = 1\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum CodeGenOptLevel {\n-    Other,\n-    None,\n-    Less,\n-    Default,\n-    Aggressive,\n-}\n-\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n pub enum CodeGenOptSize {\n@@ -400,54 +130,6 @@ pub enum CodeGenOptSize {\n     CodeGenOptSizeAggressive = 2,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum RelocMode {\n-    Default = 0,\n-    Static = 1,\n-    PIC = 2,\n-    DynamicNoPic = 3,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum CodeModel {\n-    Other,\n-    Default,\n-    JITDefault,\n-    Small,\n-    Kernel,\n-    Medium,\n-    Large,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum DiagnosticKind {\n-    Other,\n-    InlineAsm,\n-    StackSize,\n-    DebugMetadataVersion,\n-    SampleProfile,\n-    OptimizationRemark,\n-    OptimizationRemarkMissed,\n-    OptimizationRemarkAnalysis,\n-    OptimizationRemarkAnalysisFPCommute,\n-    OptimizationRemarkAnalysisAliasing,\n-    OptimizationRemarkOther,\n-    OptimizationFailure,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum ArchiveKind {\n-    Other,\n-    K_GNU,\n-    K_MIPS64,\n-    K_BSD,\n-    K_COFF,\n-}\n-\n impl FromStr for ArchiveKind {\n     type Err = ();\n \n@@ -462,1732 +144,22 @@ impl FromStr for ArchiveKind {\n     }\n }\n \n-/// Represents the different LLVM passes Rust supports\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum PassKind {\n-    Other,\n-    Function,\n-    Module,\n-}\n-\n-// Opaque pointer types\n-#[allow(missing_copy_implementations)]\n-pub enum Module_opaque {}\n-pub type ModuleRef = *mut Module_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Context_opaque {}\n-pub type ContextRef = *mut Context_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Type_opaque {}\n-pub type TypeRef = *mut Type_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Value_opaque {}\n-pub type ValueRef = *mut Value_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Metadata_opaque {}\n-pub type MetadataRef = *mut Metadata_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum BasicBlock_opaque {}\n-pub type BasicBlockRef = *mut BasicBlock_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Builder_opaque {}\n-pub type BuilderRef = *mut Builder_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum ExecutionEngine_opaque {}\n-pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n #[allow(missing_copy_implementations)]\n-pub enum MemoryBuffer_opaque {}\n-pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum PassManager_opaque {}\n-pub type PassManagerRef = *mut PassManager_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum PassManagerBuilder_opaque {}\n-pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Use_opaque {}\n-pub type UseRef = *mut Use_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum TargetData_opaque {}\n-pub type TargetDataRef = *mut TargetData_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum ObjectFile_opaque {}\n-pub type ObjectFileRef = *mut ObjectFile_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum SectionIterator_opaque {}\n-pub type SectionIteratorRef = *mut SectionIterator_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Pass_opaque {}\n-pub type PassRef = *mut Pass_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum TargetMachine_opaque {}\n-pub type TargetMachineRef = *mut TargetMachine_opaque;\n-pub enum Archive_opaque {}\n-pub type ArchiveRef = *mut Archive_opaque;\n-pub enum ArchiveIterator_opaque {}\n-pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n-pub enum ArchiveChild_opaque {}\n-pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Twine_opaque {}\n-pub type TwineRef = *mut Twine_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum DiagnosticInfo_opaque {}\n-pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum DebugLoc_opaque {}\n-pub type DebugLocRef = *mut DebugLoc_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum SMDiagnostic_opaque {}\n-pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum RustArchiveMember_opaque {}\n-pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum OperandBundleDef_opaque {}\n-pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n-\n-pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n-pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n-\n-pub mod debuginfo {\n-    pub use self::DIDescriptorFlags::*;\n-    use super::{MetadataRef};\n-\n-    #[allow(missing_copy_implementations)]\n-    pub enum DIBuilder_opaque {}\n-    pub type DIBuilderRef = *mut DIBuilder_opaque;\n-\n-    pub type DIDescriptor = MetadataRef;\n-    pub type DIScope = DIDescriptor;\n-    pub type DILocation = DIDescriptor;\n-    pub type DIFile = DIScope;\n-    pub type DILexicalBlock = DIScope;\n-    pub type DISubprogram = DIScope;\n-    pub type DINameSpace = DIScope;\n-    pub type DIType = DIDescriptor;\n-    pub type DIBasicType = DIType;\n-    pub type DIDerivedType = DIType;\n-    pub type DICompositeType = DIDerivedType;\n-    pub type DIVariable = DIDescriptor;\n-    pub type DIGlobalVariable = DIDescriptor;\n-    pub type DIArray = DIDescriptor;\n-    pub type DISubrange = DIDescriptor;\n-    pub type DIEnumerator = DIDescriptor;\n-    pub type DITemplateTypeParameter = DIDescriptor;\n-\n-    #[derive(Copy, Clone)]\n-    pub enum DIDescriptorFlags {\n-      FlagPrivate            = 1 << 0,\n-      FlagProtected          = 1 << 1,\n-      FlagFwdDecl            = 1 << 2,\n-      FlagAppleBlock         = 1 << 3,\n-      FlagBlockByrefStruct   = 1 << 4,\n-      FlagVirtual            = 1 << 5,\n-      FlagArtificial         = 1 << 6,\n-      FlagExplicit           = 1 << 7,\n-      FlagPrototyped         = 1 << 8,\n-      FlagObjcClassComplete  = 1 << 9,\n-      FlagObjectPointer      = 1 << 10,\n-      FlagVector             = 1 << 11,\n-      FlagStaticMember       = 1 << 12,\n-      FlagIndirectVariable   = 1 << 13,\n-      FlagLValueReference    = 1 << 14,\n-      FlagRValueReference    = 1 << 15\n-    }\n-}\n-\n-\n-// Link to our native llvm bindings (things that we need to use the C++ api\n-// for) and because llvm is written in C++ we need to link against libstdc++\n-//\n-// You'll probably notice that there is an omission of all LLVM libraries\n-// from this location. This is because the set of LLVM libraries that we\n-// link to is mostly defined by LLVM, and the `llvm-config` tool is used to\n-// figure out the exact set of libraries. To do this, the build system\n-// generates an llvmdeps.rs file next to this one which will be\n-// automatically updated whenever LLVM is updated to include an up-to-date\n-// set of the libraries we need to link to LLVM for.\n-#[link(name = \"rustllvm\", kind = \"static\")]\n-#[cfg(not(cargobuild))]\n-extern {}\n-\n-#[linked_from = \"rustllvm\"] // not quite true but good enough\n-extern {\n-    /* Create and destroy contexts. */\n-    pub fn LLVMContextCreate() -> ContextRef;\n-    pub fn LLVMContextDispose(C: ContextRef);\n-    pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n-                                    Name: *const c_char,\n-                                    SLen: c_uint)\n-                                    -> c_uint;\n-\n-    /* Create and destroy modules. */\n-    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n-                                             C: ContextRef)\n-                                             -> ModuleRef;\n-    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n-    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n-    pub fn LLVMDisposeModule(M: ModuleRef);\n-\n-    /// Data layout. See Module::getDataLayout.\n-    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n-    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n-\n-    /// Target triple. See Module::getTargetTriple.\n-    pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n-    pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n-\n-    /// See Module::dump.\n-    pub fn LLVMDumpModule(M: ModuleRef);\n-\n-    /// See Module::setModuleInlineAsm.\n-    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n-\n-    /// See llvm::LLVMTypeKind::getTypeID.\n-    pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n-\n-    /// See llvm::LLVMType::getContext.\n-    pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n-\n-    /* Operations on integer types */\n-    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint)\n-                                -> TypeRef;\n-\n-    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n-\n-    /* Operations on real types */\n-    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n-\n-    /* Operations on function types */\n-    pub fn LLVMFunctionType(ReturnType: TypeRef,\n-                            ParamTypes: *const TypeRef,\n-                            ParamCount: c_uint,\n-                            IsVarArg: Bool)\n-                            -> TypeRef;\n-    pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n-    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n-\n-    /* Operations on struct types */\n-    pub fn LLVMStructTypeInContext(C: ContextRef,\n-                                   ElementTypes: *const TypeRef,\n-                                   ElementCount: c_uint,\n-                                   Packed: Bool)\n-                                   -> TypeRef;\n-    pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetStructElementTypes(StructTy: TypeRef,\n-                                     Dest: *mut TypeRef);\n-    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n-\n-    /* Operations on array, pointer, and vector types (sequence types) */\n-    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n-    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n-                           -> TypeRef;\n-    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)\n-                          -> TypeRef;\n-\n-    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n-                                  -> *const c_void;\n-    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n-\n-    /* Operations on other types */\n-    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMRustMetadataTypeInContext(C: ContextRef) -> TypeRef;\n-\n-    /* Operations on all values */\n-    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n-    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n-    pub fn LLVMDumpValue(Val: ValueRef);\n-    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n-    pub fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n-    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n-\n-    /* Operations on Uses */\n-    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n-    pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n-    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n-    pub fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n-\n-    /* Operations on Users */\n-    pub fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n-    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n-    pub fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n-\n-    /* Operations on constants of any type */\n-    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n-    /* all zeroes */\n-    pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstICmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n-                         -> ValueRef;\n-    /* only for isize/vector */\n-    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n-    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n-    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n-    pub fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n-\n-    /* Operations on metadata */\n-    pub fn LLVMMDStringInContext(C: ContextRef,\n-                                 Str: *const c_char,\n-                                 SLen: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMMDNodeInContext(C: ContextRef,\n-                               Vals: *const ValueRef,\n-                               Count: c_uint)\n-                               -> ValueRef;\n-    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n-                                       Str: *const c_char,\n-                                       Val: ValueRef);\n-\n-    /* Operations on scalar constants */\n-    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n-                        -> ValueRef;\n-    pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n-                                -> ValueRef;\n-    pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n-                                       Text: *const c_char,\n-                                       SLen: c_uint,\n-                                       Radix: u8)\n-                                       -> ValueRef;\n-    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-    pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n-                                        Text: *const c_char,\n-                                        SLen: c_uint)\n-                                        -> ValueRef;\n-    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n-    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n-\n-\n-    /* Operations on composite constants */\n-    pub fn LLVMConstStringInContext(C: ContextRef,\n-                                    Str: *const c_char,\n-                                    Length: c_uint,\n-                                    DontNullTerminate: Bool)\n-                                    -> ValueRef;\n-    pub fn LLVMConstStructInContext(C: ContextRef,\n-                                    ConstantVals: *const ValueRef,\n-                                    Count: c_uint,\n-                                    Packed: Bool)\n-                                    -> ValueRef;\n-\n-    pub fn LLVMConstArray(ElementTy: TypeRef,\n-                          ConstantVals: *const ValueRef,\n-                          Length: c_uint)\n-                          -> ValueRef;\n-    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n-                           -> ValueRef;\n-\n-    /* Constant expressions */\n-    pub fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n-                              RHSConstant: ValueRef)\n-                              -> ValueRef;\n-    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                       -> ValueRef;\n-    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstGEP(ConstantVal: ValueRef,\n-                        ConstantIndices: *const ValueRef,\n-                        NumIndices: c_uint)\n-                        -> ValueRef;\n-    pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n-                                ConstantIndices: *const ValueRef,\n-                                NumIndices: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n-                          -> ValueRef;\n-    pub fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n-                            -> ValueRef;\n-    pub fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                          -> ValueRef;\n-    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef)\n-                             -> ValueRef;\n-    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef)\n-                             -> ValueRef;\n-    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                            -> ValueRef;\n-    pub fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                   -> ValueRef;\n-    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                -> ValueRef;\n-    pub fn LLVMConstIntCast(ConstantVal: ValueRef,\n-                            ToType: TypeRef,\n-                            isSigned: Bool)\n-                            -> ValueRef;\n-    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstSelect(ConstantCondition: ValueRef,\n-                           ConstantIfTrue: ValueRef,\n-                           ConstantIfFalse: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstExtractElement(VectorConstant: ValueRef,\n-                                   IndexConstant: ValueRef)\n-                                   -> ValueRef;\n-    pub fn LLVMConstInsertElement(VectorConstant: ValueRef,\n-                                  ElementValueConstant: ValueRef,\n-                                  IndexConstant: ValueRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n-                                  VectorBConstant: ValueRef,\n-                                  MaskConstant: ValueRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n-                                 IdxList: *const c_uint,\n-                                 NumIdx: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n-                                ElementValueConstant: ValueRef,\n-                                IdxList: *const c_uint,\n-                                NumIdx: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n-                              AsmString: *const c_char,\n-                              Constraints: *const c_char,\n-                              HasSideEffects: Bool,\n-                              IsAlignStack: Bool)\n-                              -> ValueRef;\n-    pub fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n-\n-\n-\n-    /* Operations on global variables, functions, and aliases (globals) */\n-    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n-    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-    pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n-    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n-    pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n-    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n-\n-\n-    /* Operations on global variables */\n-    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n-                                       Ty: TypeRef,\n-                                       Name: *const c_char,\n-                                       AddressSpace: c_uint)\n-                                       -> ValueRef;\n-    pub fn LLVMGetNamedGlobal(M: ModuleRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMRustGetOrInsertGlobal(M: ModuleRef,\n-                                     Name: *const c_char,\n-                                     T: TypeRef)\n-                                     -> ValueRef;\n-    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n-    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMSetInitializer(GlobalVar: ValueRef,\n-                              ConstantVal: ValueRef);\n-    pub fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n-    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n-    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n-    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n-    pub fn LLVMRustGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-\n-    /* Operations on aliases */\n-    pub fn LLVMAddAlias(M: ModuleRef,\n-                        Ty: TypeRef,\n-                        Aliasee: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-\n-    /* Operations on functions */\n-    pub fn LLVMAddFunction(M: ModuleRef,\n-                           Name: *const c_char,\n-                           FunctionTy: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMDeleteFunction(Fn: ValueRef);\n-    pub fn LLVMRustGetOrInsertFunction(M: ModuleRef,\n-                                       Name: *const c_char,\n-                                       FunctionTy: TypeRef)\n-                                       -> ValueRef;\n-    pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n-    pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n-    pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: uint64_t);\n-    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n-    pub fn LLVMRustAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-    pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef, index: c_uint,\n-                                              Name: *const c_char,\n-                                              Value: *const c_char);\n-    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef,\n-                                            index: c_uint,\n-                                            attr: uint64_t);\n-    pub fn LLVMRustRemoveFunctionAttrString(Fn: ValueRef,\n-                                            index: c_uint,\n-                                            Name: *const c_char);\n-    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);\n-\n-    /* Operations on parameters */\n-    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n-    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n-    pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n-    pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n-\n-    /* Operations on basic blocks */\n-    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n-    pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n-    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    pub fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    pub fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-\n-    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n-                                         Fn: ValueRef,\n-                                         Name: *const c_char)\n-                                         -> BasicBlockRef;\n-    pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n-                                         BB: BasicBlockRef,\n-                                         Name: *const c_char)\n-                                         -> BasicBlockRef;\n-    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n-\n-    pub fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef,\n-                                   MoveAfter: BasicBlockRef);\n-\n-    pub fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef,\n-                                    MoveBefore: BasicBlockRef);\n-\n-    /* Operations on instructions */\n-    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n-\n-    /* Operations on call sites */\n-    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n-    pub fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n-    pub fn LLVMAddInstrAttribute(Instr: ValueRef,\n-                                 index: c_uint,\n-                                 IA: c_uint);\n-    pub fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n-                                    index: c_uint,\n-                                    IA: c_uint);\n-    pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n-                                      index: c_uint,\n-                                      align: c_uint);\n-    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef,\n-                                    index: c_uint,\n-                                    Val: uint64_t);\n-    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef,\n-                                                  index: c_uint,\n-                                                  bytes: uint64_t);\n-\n-    /* Operations on call instructions (only) */\n-    pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n-    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n-\n-    /* Operations on load/store instructions (only) */\n-    pub fn LLVMGetVolatile(MemoryAccessInst: ValueRef) -> Bool;\n-    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n-\n-    /* Operations on phi nodes */\n-    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n-                           IncomingValues: *const ValueRef,\n-                           IncomingBlocks: *const BasicBlockRef,\n-                           Count: c_uint);\n-    pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n-    pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: c_uint)\n-                                -> BasicBlockRef;\n-\n-    /* Instruction builders */\n-    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n-    pub fn LLVMPositionBuilder(Builder: BuilderRef,\n-                               Block: BasicBlockRef,\n-                               Instr: ValueRef);\n-    pub fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n-                                     Instr: ValueRef);\n-    pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n-                                    Block: BasicBlockRef);\n-    pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n-    pub fn LLVMClearInsertionPosition(Builder: BuilderRef);\n-    pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n-    pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n-                                         Instr: ValueRef,\n-                                         Name: *const c_char);\n-    pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n-\n-    /* Metadata */\n-    pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n-    pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n-    pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n-\n-    /* Terminators */\n-    pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n-    pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildAggregateRet(B: BuilderRef,\n-                                 RetVals: *const ValueRef,\n-                                 N: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMBuildCondBr(B: BuilderRef,\n-                           If: ValueRef,\n-                           Then: BasicBlockRef,\n-                           Else: BasicBlockRef)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSwitch(B: BuilderRef,\n-                           V: ValueRef,\n-                           Else: BasicBlockRef,\n-                           NumCases: c_uint)\n-                           -> ValueRef;\n-    pub fn LLVMBuildIndirectBr(B: BuilderRef,\n-                               Addr: ValueRef,\n-                               NumDests: c_uint)\n-                               -> ValueRef;\n-    pub fn LLVMRustBuildInvoke(B: BuilderRef,\n-                               Fn: ValueRef,\n-                               Args: *const ValueRef,\n-                               NumArgs: c_uint,\n-                               Then: BasicBlockRef,\n-                               Catch: BasicBlockRef,\n-                               Bundle: OperandBundleDefRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-    pub fn LLVMRustBuildLandingPad(B: BuilderRef,\n-                                   Ty: TypeRef,\n-                                   PersFn: ValueRef,\n-                                   NumClauses: c_uint,\n-                                   Name: *const c_char,\n-                                   F: ValueRef)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n-\n-    pub fn LLVMRustBuildCleanupPad(B: BuilderRef,\n-                                   ParentPad: ValueRef,\n-                                   ArgCnt: c_uint,\n-                                   Args: *const ValueRef,\n-                                   Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustBuildCleanupRet(B: BuilderRef,\n-                                   CleanupPad: ValueRef,\n-                                   UnwindBB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMRustBuildCatchPad(B: BuilderRef,\n-                                 ParentPad: ValueRef,\n-                                 ArgCnt: c_uint,\n-                                 Args: *const ValueRef,\n-                                 Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustBuildCatchRet(B: BuilderRef,\n-                                 Pad: ValueRef,\n-                                 BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMRustBuildCatchSwitch(Builder: BuilderRef,\n-                                    ParentPad: ValueRef,\n-                                    BB: BasicBlockRef,\n-                                    NumHandlers: c_uint,\n-                                    Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef,\n-                              Handler: BasicBlockRef);\n-    pub fn LLVMRustSetPersonalityFn(B: BuilderRef, Pers: ValueRef);\n-\n-    /* Add a case to the switch instruction */\n-    pub fn LLVMAddCase(Switch: ValueRef,\n-                       OnVal: ValueRef,\n-                       Dest: BasicBlockRef);\n-\n-    /* Add a destination to the indirectbr instruction */\n-    pub fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n-\n-    /* Add a clause to the landing pad instruction */\n-    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n-\n-    /* Set the cleanup on a landing pad instruction */\n-    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n-\n-    /* Arithmetic */\n-    pub fn LLVMBuildAdd(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWAdd(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWAdd(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFAdd(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSub(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWSub(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWSub(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFSub(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildMul(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWMul(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWMul(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFMul(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildUDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildExactSDiv(B: BuilderRef,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildFDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildURem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSRem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFRem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildShl(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildLShr(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAShr(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAnd(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildOr(B: BuilderRef,\n-                       LHS: ValueRef,\n-                       RHS: ValueRef,\n-                       Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildXor(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildBinOp(B: BuilderRef,\n-                          Op: Opcode,\n-                          LHS: ValueRef,\n-                          RHS: ValueRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n-\n-    /* Memory */\n-    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildLoad(B: BuilderRef,\n-                         PointerVal: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-\n-    pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n-                          -> ValueRef;\n-\n-    pub fn LLVMBuildGEP(B: BuilderRef,\n-                        Pointer: ValueRef,\n-                        Indices: *const ValueRef,\n-                        NumIndices: c_uint,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n-                                Pointer: ValueRef,\n-                                Indices: *const ValueRef,\n-                                NumIndices: c_uint,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMBuildStructGEP(B: BuilderRef,\n-                              Pointer: ValueRef,\n-                              Idx: c_uint,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildGlobalString(B: BuilderRef,\n-                                 Str: *const c_char,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n-                                    Str: *const c_char,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-\n-    /* Casts */\n-    pub fn LLVMBuildTrunc(B: BuilderRef,\n-                          Val: ValueRef,\n-                          DestTy: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildZExt(B: BuilderRef,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSExt(B: BuilderRef,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFPToUI(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFPToSI(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildUIToFP(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSIToFP(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFPTrunc(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildFPExt(B: BuilderRef,\n-                          Val: ValueRef,\n-                          DestTy: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildPtrToInt(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildIntToPtr(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildBitCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n-                                  Val: ValueRef,\n-                                  DestTy: TypeRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n-                                  Val: ValueRef,\n-                                  DestTy: TypeRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n-                                   Val: ValueRef,\n-                                   DestTy: TypeRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildCast(B: BuilderRef,\n-                         Op: Opcode,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildPointerCast(B: BuilderRef,\n-                                Val: ValueRef,\n-                                DestTy: TypeRef,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMBuildIntCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildFPCast(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-\n-    /* Comparisons */\n-    pub fn LLVMBuildICmp(B: BuilderRef,\n-                         Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFCmp(B: BuilderRef,\n-                         Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-\n-    /* Miscellaneous instructions */\n-    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMRustBuildCall(B: BuilderRef,\n-                             Fn: ValueRef,\n-                             Args: *const ValueRef,\n-                             NumArgs: c_uint,\n-                             Bundle: OperandBundleDefRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildSelect(B: BuilderRef,\n-                           If: ValueRef,\n-                           Then: ValueRef,\n-                           Else: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildVAArg(B: BuilderRef,\n-                          list: ValueRef,\n-                          Ty: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildExtractElement(B: BuilderRef,\n-                                   VecVal: ValueRef,\n-                                   Index: ValueRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildInsertElement(B: BuilderRef,\n-                                  VecVal: ValueRef,\n-                                  EltVal: ValueRef,\n-                                  Index: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildShuffleVector(B: BuilderRef,\n-                                  V1: ValueRef,\n-                                  V2: ValueRef,\n-                                  Mask: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildExtractValue(B: BuilderRef,\n-                                 AggVal: ValueRef,\n-                                 Index: c_uint,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildInsertValue(B: BuilderRef,\n-                                AggVal: ValueRef,\n-                                EltVal: ValueRef,\n-                                Index: c_uint,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-\n-    pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildPtrDiff(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-\n-    /* Atomic Operations */\n-    pub fn LLVMRustBuildAtomicLoad(B: BuilderRef,\n-                                   PointerVal: ValueRef,\n-                                   Name: *const c_char,\n-                                   Order: AtomicOrdering,\n-                                   Alignment: c_uint)\n-                                   -> ValueRef;\n-\n-    pub fn LLVMRustBuildAtomicStore(B: BuilderRef,\n-                                    Val: ValueRef,\n-                                    Ptr: ValueRef,\n-                                    Order: AtomicOrdering,\n-                                    Alignment: c_uint)\n-                                    -> ValueRef;\n-\n-    pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n-                                      LHS: ValueRef,\n-                                      CMP: ValueRef,\n-                                      RHS: ValueRef,\n-                                      Order: AtomicOrdering,\n-                                      FailureOrder: AtomicOrdering,\n-                                      Weak: Bool)\n-                                      -> ValueRef;\n-\n-    pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n-                              Op: AtomicBinOp,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Order: AtomicOrdering,\n-                              SingleThreaded: Bool)\n-                              -> ValueRef;\n-\n-    pub fn LLVMRustBuildAtomicFence(B: BuilderRef,\n-                                    Order: AtomicOrdering,\n-                                    Scope: SynchronizationScope);\n-\n-\n-    /* Selected entries from the downcasts. */\n-    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n-\n-    /// Writes a module to the specified path. Returns 0 on success.\n-    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n-\n-    /// Creates target data from a target layout string.\n-    pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n-    /// Number of bytes clobbered when doing a Store to *T.\n-    pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n-                               -> c_ulonglong;\n-\n-    /// Number of bytes clobbered when doing a Store to *T.\n-    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n-                                -> c_ulonglong;\n-\n-    /// Distance between successive elements in an array of T. Includes ABI padding.\n-    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n-\n-    /// Returns the preferred alignment of a type.\n-    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                        -> c_uint;\n-    /// Returns the minimum alignment of a type.\n-    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                  -> c_uint;\n-\n-    /// Computes the byte offset of the indexed struct element for a\n-    /// target.\n-    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n-                               StructTy: TypeRef,\n-                               Element: c_uint)\n-                               -> c_ulonglong;\n-\n-    /// Returns the minimum alignment of a type when part of a call frame.\n-    pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                        -> c_uint;\n-\n-    /// Disposes target data.\n-    pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n-\n-    /// Creates a pass manager.\n-    pub fn LLVMCreatePassManager() -> PassManagerRef;\n-\n-    /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n-                                                  -> PassManagerRef;\n-\n-    /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n-\n-    /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n-\n-    /// Runs the function passes on the provided function.\n-    pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n-                                      -> Bool;\n-\n-    /// Initializes all the function passes scheduled in the manager\n-    pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n-\n-    /// Finalizes all the function passes scheduled in the manager\n-    pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n-\n-    pub fn LLVMInitializePasses();\n-\n-    /// Adds a verification pass.\n-    pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n-\n-    pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n-    pub fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n-    pub fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n-    pub fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n-    pub fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n-    pub fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n-    pub fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n-    pub fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n-    pub fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n-    pub fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n-    pub fn LLVMAddReassociatePass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n-    pub fn LLVMAddLICMPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n-    pub fn LLVMAddGVNPass(PM: PassManagerRef);\n-    pub fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n-    pub fn LLVMAddSCCPPass(PM: PassManagerRef);\n-    pub fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n-    pub fn LLVMAddConstantMergePass(PM: PassManagerRef);\n-    pub fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n-    pub fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n-    pub fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n-    pub fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n-    pub fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n-    pub fn LLVMAddPruneEHPass(PM: PassManagerRef);\n-    pub fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n-    pub fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n-    pub fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n-    pub fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n-\n-    pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n-    pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n-    pub fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n-                                             OptimizationLevel: c_uint);\n-    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n-                                              Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: PassManagerBuilderRef,\n-        threshold: c_uint);\n-    pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef);\n-\n-    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef);\n-    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef,\n-        Internalize: Bool,\n-        RunInliner: Bool);\n-\n-    /// Destroys a memory buffer.\n-    pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n-\n-\n-    /* Stuff that's in rustllvm/ because it's not upstream yet. */\n-\n-    /// Opens an object file.\n-    pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n-    /// Closes an object file.\n-    pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n-\n-    /// Enumerates the sections in an object file.\n-    pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n-    /// Destroys a section iterator.\n-    pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n-    /// Returns true if the section iterator is at the end of the section\n-    /// list:\n-    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n-                                      SI: SectionIteratorRef)\n-                                      -> Bool;\n-    /// Moves the section iterator to point to the next section.\n-    pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n-    /// Returns the current section size.\n-    pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n-    /// Returns the current section contents as a string buffer.\n-    pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n-\n-    /// Reads the given file and returns it as a memory buffer. Use\n-    /// LLVMDisposeMemoryBuffer() to get rid of it.\n-    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n-                                                        -> MemoryBufferRef;\n-    /// Borrows the contents of the memory buffer (doesn't copy it)\n-    pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n-                                                 InputDataLength: size_t,\n-                                                 BufferName: *const c_char,\n-                                                 RequiresNull: Bool)\n-                                                 -> MemoryBufferRef;\n-    pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n-                                                     InputDataLength: size_t,\n-                                                     BufferName: *const c_char)\n-                                                     -> MemoryBufferRef;\n-\n-    pub fn LLVMIsMultithreaded() -> Bool;\n-    pub fn LLVMStartMultithreaded() -> Bool;\n-\n-    /// Returns a string describing the last error caused by an LLVMRust* call.\n-    pub fn LLVMRustGetLastError() -> *const c_char;\n-\n-    /// Print the pass timings since static dtors aren't picking them up.\n-    pub fn LLVMRustPrintPassTimings();\n-\n-    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n-\n-    pub fn LLVMStructSetBody(StructTy: TypeRef,\n-                             ElementTypes: *const TypeRef,\n-                             ElementCount: c_uint,\n-                             Packed: Bool);\n-\n-    pub fn LLVMConstNamedStruct(S: TypeRef,\n-                                ConstantVals: *const ValueRef,\n-                                Count: c_uint)\n-                                -> ValueRef;\n-\n-    /// Enables LLVM debug output.\n-    pub fn LLVMRustSetDebug(Enabled: c_int);\n-\n-    /// Prepares inline assembly.\n-    pub fn LLVMRustInlineAsm(Ty: TypeRef,\n-                             AsmString: *const c_char,\n-                             Constraints: *const c_char,\n-                             SideEffects: Bool,\n-                             AlignStack: Bool,\n-                             Dialect: c_uint)\n-                             -> ValueRef;\n-\n-    pub fn LLVMRustDebugMetadataVersion() -> u32;\n-    pub fn LLVMRustVersionMajor() -> u32;\n-    pub fn LLVMRustVersionMinor() -> u32;\n-\n-    pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n-                                 name: *const c_char,\n-                                 value: u32);\n-\n-    pub fn LLVMRustDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n-\n-    pub fn LLVMRustDIBuilderDispose(Builder: DIBuilderRef);\n-\n-    pub fn LLVMRustDIBuilderFinalize(Builder: DIBuilderRef);\n-\n-    pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n-                                              Lang: c_uint,\n-                                              File: *const c_char,\n-                                              Dir: *const c_char,\n-                                              Producer: *const c_char,\n-                                              isOptimized: bool,\n-                                              Flags: *const c_char,\n-                                              RuntimeVer: c_uint,\n-                                              SplitName: *const c_char)\n-                                              -> DIDescriptor;\n-\n-    pub fn LLVMRustDIBuilderCreateFile(Builder: DIBuilderRef,\n-                                       Filename: *const c_char,\n-                                       Directory: *const c_char)\n-                                       -> DIFile;\n-\n-    pub fn LLVMRustDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n-                                                 File: DIFile,\n-                                                 ParameterTypes: DIArray)\n-                                                 -> DICompositeType;\n-\n-    pub fn LLVMRustDIBuilderCreateFunction(Builder: DIBuilderRef,\n-                                           Scope: DIDescriptor,\n-                                           Name: *const c_char,\n-                                           LinkageName: *const c_char,\n-                                           File: DIFile,\n-                                           LineNo: c_uint,\n-                                           Ty: DIType,\n-                                           isLocalToUnit: bool,\n-                                           isDefinition: bool,\n-                                           ScopeLine: c_uint,\n-                                           Flags: c_uint,\n-                                           isOptimized: bool,\n-                                           Fn: ValueRef,\n-                                           TParam: DIArray,\n-                                           Decl: DIDescriptor)\n-                                           -> DISubprogram;\n-\n-    pub fn LLVMRustDIBuilderCreateBasicType(Builder: DIBuilderRef,\n-                                            Name: *const c_char,\n-                                            SizeInBits: u64,\n-                                            AlignInBits: u64,\n-                                            Encoding: c_uint)\n-                                            -> DIBasicType;\n-\n-    pub fn LLVMRustDIBuilderCreatePointerType(Builder: DIBuilderRef,\n-                                          PointeeTy: DIType,\n-                                          SizeInBits: u64,\n-                                          AlignInBits: u64,\n-                                          Name: *const c_char)\n-                                          -> DIDerivedType;\n-\n-    pub fn LLVMRustDIBuilderCreateStructType(Builder: DIBuilderRef,\n-                                             Scope: DIDescriptor,\n-                                             Name: *const c_char,\n-                                             File: DIFile,\n-                                             LineNumber: c_uint,\n-                                             SizeInBits: u64,\n-                                             AlignInBits: u64,\n-                                             Flags: c_uint,\n-                                             DerivedFrom: DIType,\n-                                             Elements: DIArray,\n-                                             RunTimeLang: c_uint,\n-                                             VTableHolder: DIType,\n-                                             UniqueId: *const c_char)\n-                                             -> DICompositeType;\n-\n-    pub fn LLVMRustDIBuilderCreateMemberType(Builder: DIBuilderRef,\n-                                             Scope: DIDescriptor,\n-                                             Name: *const c_char,\n-                                             File: DIFile,\n-                                             LineNo: c_uint,\n-                                             SizeInBits: u64,\n-                                             AlignInBits: u64,\n-                                             OffsetInBits: u64,\n-                                             Flags: c_uint,\n-                                             Ty: DIType)\n-                                             -> DIDerivedType;\n-\n-    pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n-                                               Scope: DIScope,\n-                                               File: DIFile,\n-                                               Line: c_uint,\n-                                               Col: c_uint)\n-                                               -> DILexicalBlock;\n-\n-    pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n-                                                 Context: DIScope,\n-                                                 Name: *const c_char,\n-                                                 LinkageName: *const c_char,\n-                                                 File: DIFile,\n-                                                 LineNo: c_uint,\n-                                                 Ty: DIType,\n-                                                 isLocalToUnit: bool,\n-                                                 Val: ValueRef,\n-                                                 Decl: DIDescriptor)\n-                                                 -> DIGlobalVariable;\n-\n-    pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,\n-                                           Tag: c_uint,\n-                                           Scope: DIDescriptor,\n-                                           Name: *const c_char,\n-                                           File: DIFile,\n-                                           LineNo: c_uint,\n-                                           Ty: DIType,\n-                                           AlwaysPreserve: bool,\n-                                           Flags: c_uint,\n-                                           AddrOps: *const i64,\n-                                           AddrOpsCount: c_uint,\n-                                           ArgNo: c_uint)\n-                                           -> DIVariable;\n-\n-    pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,\n-                                            Size: u64,\n-                                            AlignInBits: u64,\n-                                            Ty: DIType,\n-                                            Subscripts: DIArray)\n-                                            -> DIType;\n-\n-    pub fn LLVMRustDIBuilderCreateVectorType(Builder: DIBuilderRef,\n-                                             Size: u64,\n-                                             AlignInBits: u64,\n-                                             Ty: DIType,\n-                                             Subscripts: DIArray)\n-                                             -> DIType;\n-\n-    pub fn LLVMRustDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n-                                                Lo: i64,\n-                                                Count: i64)\n-                                                -> DISubrange;\n-\n-    pub fn LLVMRustDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n-                                             Ptr: *const DIDescriptor,\n-                                             Count: c_uint)\n-                                             -> DIArray;\n-\n-    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n-                                               Val: ValueRef,\n-                                               VarInfo: DIVariable,\n-                                               AddrOps: *const i64,\n-                                               AddrOpsCount: c_uint,\n-                                               DL: ValueRef,\n-                                               InsertAtEnd: BasicBlockRef)\n-                                               -> ValueRef;\n-\n-    pub fn LLVMRustDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n-                                                Val: ValueRef,\n-                                                VarInfo: DIVariable,\n-                                                AddrOps: *const i64,\n-                                                AddrOpsCount: c_uint,\n-                                                DL: ValueRef,\n-                                                InsertBefore: ValueRef)\n-                                                -> ValueRef;\n-\n-    pub fn LLVMRustDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n-                                             Name: *const c_char,\n-                                             Val: u64)\n-                                             -> DIEnumerator;\n-\n-    pub fn LLVMRustDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n-                                                  Scope: DIScope,\n-                                                  Name: *const c_char,\n-                                                  File: DIFile,\n-                                                  LineNumber: c_uint,\n-                                                  SizeInBits: u64,\n-                                                  AlignInBits: u64,\n-                                                  Elements: DIArray,\n-                                                  ClassType: DIType)\n-                                                  -> DIType;\n-\n-    pub fn LLVMRustDIBuilderCreateUnionType(Builder: DIBuilderRef,\n-                                            Scope: DIScope,\n-                                            Name: *const c_char,\n-                                            File: DIFile,\n-                                            LineNumber: c_uint,\n-                                            SizeInBits: u64,\n-                                            AlignInBits: u64,\n-                                            Flags: c_uint,\n-                                            Elements: DIArray,\n-                                            RunTimeLang: c_uint,\n-                                            UniqueId: *const c_char)\n-                                            -> DIType;\n-\n-    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n-\n-    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n-                                                        Scope: DIScope,\n-                                                        Name: *const c_char,\n-                                                        Ty: DIType,\n-                                                        File: DIFile,\n-                                                        LineNo: c_uint,\n-                                                        ColumnNo: c_uint)\n-                                                        -> DITemplateTypeParameter;\n-\n-\n-    pub fn LLVMRustDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n-                                            Scope: DIScope,\n-                                            Name: *const c_char,\n-                                            File: DIFile,\n-                                            LineNo: c_uint)\n-                                            -> DINameSpace;\n-    pub fn LLVMRustDICompositeTypeSetTypeArray(Builder: DIBuilderRef,\n-                                               CompositeType: DIType,\n-                                               TypeArray: DIArray);\n-\n-\n-    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: ContextRef,\n-                                                Line: c_uint,\n-                                                Column: c_uint,\n-                                                Scope: DIScope,\n-                                                InlinedAt: MetadataRef)\n-                                                -> ValueRef;\n-    pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n-    pub fn LLVMRustDIBuilderCreateOpPlus() -> i64;\n-\n-    pub fn LLVMRustWriteTypeToString(Type: TypeRef, s: RustStringRef);\n-    pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n-\n-    pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n-    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n-    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n-\n-    pub fn LLVMRustHasFeature(T: TargetMachineRef,\n-                              s: *const c_char) -> bool;\n-\n-    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n-                                       CPU: *const c_char,\n-                                       Features: *const c_char,\n-                                       Model: CodeModel,\n-                                       Reloc: RelocMode,\n-                                       Level: CodeGenOptLevel,\n-                                       UseSoftFP: bool,\n-                                       PositionIndependentExecutable: bool,\n-                                       FunctionSections: bool,\n-                                       DataSections: bool) -> TargetMachineRef;\n-    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n-    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n-                                     PM: PassManagerRef,\n-                                     M: ModuleRef);\n-    pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n-                                         M: ModuleRef,\n-                                         DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n-                                               OptLevel: CodeGenOptLevel,\n-                                               MergeFunctions: bool,\n-                                               SLPVectorize: bool,\n-                                               LoopVectorize: bool);\n-    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n-                                  DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n-    pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n-                                   PM: PassManagerRef,\n-                                   M: ModuleRef,\n-                                   Output: *const c_char,\n-                                   FileType: FileType)\n-                                   -> LLVMRustResult;\n-    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n-                               M: ModuleRef,\n-                               Output: *const c_char);\n-    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n-    pub fn LLVMRustPrintPasses();\n-    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n-    pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n-                                       AddLifetimes: bool);\n-    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n-                                         bc: *const c_char,\n-                                         len: size_t) -> bool;\n-    pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n-                                      syms: *const *const c_char,\n-                                      len: size_t);\n-    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n-\n-    pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n-    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n-    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n-    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n-                                    size: *mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n-                                    size: *mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildFree(ACR: ArchiveChildRef);\n-    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n-    pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n-\n-    pub fn LLVMRustSetDLLStorageClass(V: ValueRef,\n-                                      C: DLLStorageClassTypes);\n-\n-    pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n-                                  data: *mut *const c_char) -> size_t;\n-\n-    pub fn LLVMRustWriteTwineToString(T: TwineRef, s: RustStringRef);\n-\n-    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n-                                           Handler: DiagnosticHandler,\n-                                           DiagnosticContext: *mut c_void);\n-\n-    pub fn LLVMRustUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n-                                                pass_name_out: *mut *const c_char,\n-                                                function_out: *mut ValueRef,\n-                                                debugloc_out: *mut DebugLocRef,\n-                                                message_out: *mut TwineRef);\n-    pub fn LLVMRustUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n-                                             cookie_out: *mut c_uint,\n-                                             message_out: *mut TwineRef,\n-                                             instruction_out: *mut ValueRef);\n-\n-    pub fn LLVMRustWriteDiagnosticInfoToString(DI: DiagnosticInfoRef,\n-                                               s: RustStringRef);\n-    pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;\n-    pub fn LLVMRustGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n-\n-    pub fn LLVMRustWriteDebugLocToString(C: ContextRef,\n-                                         DL: DebugLocRef,\n-                                         s: RustStringRef);\n-\n-    pub fn LLVMRustSetInlineAsmDiagnosticHandler(C: ContextRef,\n-                                                 H: InlineAsmDiagHandler,\n-                                                 CX: *mut c_void);\n-\n-    pub fn LLVMRustWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n-\n-    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n-                                NumMembers: size_t,\n-                                Members: *const RustArchiveMemberRef,\n-                                WriteSymbtab: bool,\n-                                Kind: ArchiveKind) ->\n-                                LLVMRustResult;\n-    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n-                                    Name: *const c_char,\n-                                    Child: ArchiveChildRef) -> RustArchiveMemberRef;\n-    pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n-\n-    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef,\n-                                                  TM: TargetMachineRef);\n-    pub fn LLVMRustGetModuleDataLayout(M: ModuleRef) -> TargetDataRef;\n-\n-    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n-                                         Inputs: *const ValueRef,\n-                                         NumInputs: c_uint)\n-                                         -> OperandBundleDefRef;\n-    pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n+pub enum RustString_opaque {}\n+pub type RustStringRef = *mut RustString_opaque;\n+type RustStringRepr = *mut RefCell<Vec<u8>>;\n \n-    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n+/// Appending to a Rust string -- used by raw_rust_string_ostream.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n+                                                     ptr: *const c_char,\n+                                                     size: size_t) {\n+    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n \n-    pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n-    pub fn LLVMRustUnsetComdat(V: ValueRef);\n-    pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n+    let sr = sr as RustStringRepr;\n+    (*sr).borrow_mut().extend_from_slice(slice);\n }\n \n-// LLVM requires symbols from this library, but apparently they're not printed\n-// during llvm-config?\n-#[cfg(windows)]\n-#[link(name = \"ole32\")]\n-extern {}\n-\n pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n     unsafe {\n         LLVMSetInstructionCallConv(instr, cc as c_uint);\n@@ -2254,14 +226,14 @@ pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n     unsafe {\n         LLVMRustAddFunctionAttribute(fn_, FunctionIndex as c_uint,\n-                                     attr.bits() as uint64_t)\n+                                     attr.bits() as u64)\n     }\n }\n \n pub fn RemoveFunctionAttributes(fn_: ValueRef, attr: Attribute) {\n     unsafe {\n         LLVMRustRemoveFunctionAttributes(fn_, FunctionIndex as c_uint,\n-                                         attr.bits() as uint64_t)\n+                                         attr.bits() as u64)\n     }\n }\n \n@@ -2359,22 +331,6 @@ pub fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n     }\n }\n \n-#[allow(missing_copy_implementations)]\n-pub enum RustString_opaque {}\n-pub type RustStringRef = *mut RustString_opaque;\n-type RustStringRepr = *mut RefCell<Vec<u8>>;\n-\n-/// Appending to a Rust string -- used by raw_rust_string_ostream.\n-#[no_mangle]\n-pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n-                                                     ptr: *const c_char,\n-                                                     size: size_t) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n-\n-    let sr = sr as RustStringRepr;\n-    (*sr).borrow_mut().extend_from_slice(slice);\n-}\n-\n pub fn build_string<F>(f: F) -> Option<String> where F: FnOnce(RustStringRef){\n     let mut buf = RefCell::new(Vec::new());\n     f(&mut buf as RustStringRepr as RustStringRef);"}, {"sha": "8cd47bd148d0cf597e5241a65bc6b0b511a7635f", "filename": "src/librustc_trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=24874170b4dfc93243b18815b6d896e87f7ddafe", "patch": "@@ -12,7 +12,7 @@\n #![allow(non_snake_case)]\n \n use llvm;\n-use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use common::*;\n@@ -1117,7 +1117,7 @@ pub fn AtomicCmpXchg(cx: Block, dst: ValueRef,\n                      weak: llvm::Bool) -> ValueRef {\n     B(cx).atomic_cmpxchg(dst, cmp, src, order, failure_order, weak)\n }\n-pub fn AtomicRMW(cx: Block, op: AtomicBinOp,\n+pub fn AtomicRMW(cx: Block, op: AtomicRmwBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)"}, {"sha": "28d69d4815faba4cabab90a2cff14a5ca87233dc", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24874170b4dfc93243b18815b6d896e87f7ddafe/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=24874170b4dfc93243b18815b6d896e87f7ddafe", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use base;\n@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                          order, failure_order, weak)\n         }\n     }\n-    pub fn atomic_rmw(&self, op: AtomicBinOp,\n+    pub fn atomic_rmw(&self, op: AtomicRmwBinOp,\n                      dst: ValueRef, src: ValueRef,\n                      order: AtomicOrdering) -> ValueRef {\n         unsafe {"}]}