{"sha": "ff664f3c6cc0b9b530406c2ffb380040b4c4fc88", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNjY0ZjNjNmNjMGI5YjUzMDQwNmMyZmZiMzgwMDQwYjRjNGZjODg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-09T20:23:27Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-16T17:38:11Z"}, "message": "More docs for std::io::Read", "tree": {"sha": "529824378ad5131bc183d76d4c336d096d5c5302", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/529824378ad5131bc183d76d4c336d096d5c5302"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff664f3c6cc0b9b530406c2ffb380040b4c4fc88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff664f3c6cc0b9b530406c2ffb380040b4c4fc88", "html_url": "https://github.com/rust-lang/rust/commit/ff664f3c6cc0b9b530406c2ffb380040b4c4fc88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff664f3c6cc0b9b530406c2ffb380040b4c4fc88/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2074b19bdc0359f9f0fd06d800f54440326e9942", "url": "https://api.github.com/repos/rust-lang/rust/commits/2074b19bdc0359f9f0fd06d800f54440326e9942", "html_url": "https://github.com/rust-lang/rust/commit/2074b19bdc0359f9f0fd06d800f54440326e9942"}], "stats": {"total": 290, "additions": 278, "deletions": 12}, "files": [{"sha": "55fdf2bb6f36c1d1e68da4480bc4a6a36a522606", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 278, "deletions": 12, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/ff664f3c6cc0b9b530406c2ffb380040b4c4fc88/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff664f3c6cc0b9b530406c2ffb380040b4c4fc88/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=ff664f3c6cc0b9b530406c2ffb380040b4c4fc88", "patch": "@@ -127,14 +127,49 @@ fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize>\n     ret\n }\n \n-/// A trait for objects which are byte-oriented sources.\n+/// The `Read` trait allows for reading bytes from a source.\n ///\n-/// Readers are defined by one method, `read`. Each call to `read` will attempt\n-/// to pull bytes from this source into a provided buffer.\n+/// Implementors of the `Read` trait are sometimes called 'readers'.\n ///\n-/// Readers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Read` trait.\n+/// Readers are defined by one required method, `read()`. Each call to `read`\n+/// will attempt to pull bytes from this source into a provided buffer. A\n+/// number of other methods are implemented in terms of `read()`, giving\n+/// implementors a number of ways to read bytes while only needing to implement\n+/// a single method.\n+///\n+/// Readers are intended to be composable with one another. Many implementors\n+/// throughout `std::io` take and provide types which implement the `Read`\n+/// trait.\n+///\n+/// # Examples\n+///\n+/// [`File`][file]s implement `Read`:\n+///\n+/// [file]: ../std/fs/struct.File.html\n+///\n+/// ```\n+/// use std::io;\n+/// use std::fs::File;\n+/// use std::io::Read;\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let mut f = try!(File::open(\"foo.txt\"));\n+/// let mut buffer = Vec::new();\n+///\n+/// // read some bytes\n+/// f.read(&mut buffer).unwrap();\n+///\n+/// // read the whole file\n+/// f.read_to_end(&mut buffer).unwrap();\n+///\n+/// // read into a String, so that you don't need to do the conversion.\n+/// let mut buffer = String::new();\n+/// f.read_to_string(&mut buffer).unwrap();\n+///\n+/// // and more! See the other methods for more details.\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Read {\n     /// Pull some bytes from this source into the specified buffer, returning\n@@ -164,6 +199,27 @@ pub trait Read {\n     /// If this function encounters any form of I/O or other error, an error\n     /// variant will be returned. If an error is returned then it must be\n     /// guaranteed that no bytes were read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = [0; 10];\n+    ///\n+    /// // read 10 bytes\n+    /// try!(f.read(&mut buffer[..]));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n \n@@ -185,6 +241,27 @@ pub trait Read {\n     /// If any other read error is encountered then this function immediately\n     /// returns. Any bytes which have already been read will be appended to\n     /// `buf`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = Vec::new();\n+    ///\n+    /// // read the whole file\n+    /// try!(f.read_to_end(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n         read_to_end(self, buf)\n@@ -200,7 +277,29 @@ pub trait Read {\n     /// If the data in this stream is *not* valid UTF-8 then an error is\n     /// returned and `buf` is unchanged.\n     ///\n-    /// See `read_to_end` for other error semantics.\n+    /// See [`read_to_end()`][readtoend] for other error semantics.\n+    ///\n+    /// [readtoend]: #method.read_to_end\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = String::new();\n+    ///\n+    /// try!(f.read_to_string(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we do *not* call `.read_to_end()` here. We are passing\n@@ -219,6 +318,36 @@ pub trait Read {\n     ///\n     /// The returned adaptor also implements `Read` and will simply borrow this\n     /// current reader.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::Read;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = Vec::new();\n+    /// let mut other_buffer = Vec::new();\n+    ///\n+    /// {\n+    ///     let reference = f.by_ref();\n+    ///\n+    ///     // read at most 5 bytes\n+    ///     try!(reference.take(5).read_to_end(&mut buffer));\n+    ///\n+    /// } // drop our &mut reference so we can use f again\n+    ///\n+    /// // original file still usable, read the rest\n+    /// try!(f.read_to_end(&mut other_buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n@@ -228,6 +357,27 @@ pub trait Read {\n     /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n     /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n     /// this iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    ///\n+    /// for byte in f.bytes() {\n+    ///     println!(\"{}\", byte.unwrap());\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(self) -> Bytes<Self> where Self: Sized {\n         Bytes { inner: self }\n@@ -243,6 +393,28 @@ pub trait Read {\n     ///\n     /// Currently this adaptor will discard intermediate data read, and should\n     /// be avoided if this is not desired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// #![feature(io)]\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    ///\n+    /// for c in f.chars() {\n+    ///     println!(\"{}\", c.unwrap());\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n@@ -255,6 +427,31 @@ pub trait Read {\n     /// The returned `Read` instance will first read all bytes from this object\n     /// until EOF is encountered. Afterwards the output is equivalent to the\n     /// output of `next`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f1 = try!(File::open(\"foo.txt\"));\n+    /// let mut f2 = try!(File::open(\"bar.txt\"));\n+    ///\n+    /// let mut handle = f1.chain(f2);\n+    /// let mut buffer = String::new();\n+    ///\n+    /// // read the value into a String. We could use any Read method here,\n+    /// // this is just one example.\n+    /// try!(handle.read_to_string(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized {\n         Chain { first: self, second: next, done_first: false }\n@@ -266,6 +463,29 @@ pub trait Read {\n     /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n     /// read errors will not count towards the number of bytes read and future\n     /// calls to `read` may succeed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = [0; 10];\n+    ///\n+    /// // read at most five bytes\n+    /// let mut handle = f.take(5);\n+    ///\n+    /// try!(handle.read(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n         Take { inner: self, limit: limit }\n@@ -277,6 +497,31 @@ pub trait Read {\n     /// Whenever the returned `Read` instance is read it will write the read\n     /// data to `out`. The current semantics of this implementation imply that\n     /// a `write` error will not report how much data was initially read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// #![feature(io)]\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer1 = Vec::with_capacity(10);\n+    /// let mut buffer2 = Vec::with_capacity(10);\n+    ///\n+    /// // write the output to buffer1 as we read\n+    /// let mut handle = f.tee(&mut buffer1);\n+    ///\n+    /// try!(handle.read(&mut buffer2));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n@@ -293,9 +538,30 @@ pub trait Read {\n /// The `flush` method is useful for adaptors and explicit buffers themselves\n /// for ensuring that all buffered data has been pushed out to the \"true sink\".\n ///\n-/// Writers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Write` trait.\n+/// * The `write()` method will attempt to write some data into the object,\n+///   returning how many bytes were successfully written.\n+///\n+/// * The `flush()` method is useful for adaptors and explicit buffers\n+///   themselves for ensuring that all buffered data has been pushed out to the\n+///   'true sink'.\n+///\n+/// Writers are intended to be composable with one another. Many implementors\n+/// throughout `std::io` take and provide types which implement the `Write`\n+/// trait.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let mut buffer = try!(File::create(\"foo.txt\"));\n+///\n+/// try!(buffer.write(b\"some bytes\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Write {\n     /// Write a buffer into this object, returning how many bytes were written.\n@@ -508,8 +774,8 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n /// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n /// to perform extra ways of reading.\n ///\n-/// For example, reading line-by-line requires using a buffer, so if you want\n-/// to read by line, you'll need `BufRead`, which includes a\n+/// For example, reading line-by-line is inefficient without using a buffer, so\n+/// if you want to read by line, you'll need `BufRead`, which includes a\n /// [`read_line()`][readline] method as well as a [`lines()`][lines] iterator.\n ///\n /// [readline]: #method.read_line"}]}