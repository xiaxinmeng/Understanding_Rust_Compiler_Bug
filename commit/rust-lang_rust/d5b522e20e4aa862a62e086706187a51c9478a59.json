{"sha": "d5b522e20e4aa862a62e086706187a51c9478a59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YjUyMmUyMGU0YWE4NjJhNjJlMDg2NzA2MTg3YTUxYzk0NzhhNTk=", "commit": {"author": {"name": "Chris Nixon", "email": "chris.nixon@sigma.me.uk", "date": "2015-08-03T17:10:49Z"}, "committer": {"name": "Chris Nixon", "email": "chris.nixon@sigma.me.uk", "date": "2015-08-04T19:36:28Z"}, "message": "Tweaked concurrency.md", "tree": {"sha": "f8fa2a01be88b16e80f3756213275d86f2746250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8fa2a01be88b16e80f3756213275d86f2746250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5b522e20e4aa862a62e086706187a51c9478a59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b522e20e4aa862a62e086706187a51c9478a59", "html_url": "https://github.com/rust-lang/rust/commit/d5b522e20e4aa862a62e086706187a51c9478a59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5b522e20e4aa862a62e086706187a51c9478a59/comments", "author": {"login": "c-nixon", "id": 5596332, "node_id": "MDQ6VXNlcjU1OTYzMzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5596332?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c-nixon", "html_url": "https://github.com/c-nixon", "followers_url": "https://api.github.com/users/c-nixon/followers", "following_url": "https://api.github.com/users/c-nixon/following{/other_user}", "gists_url": "https://api.github.com/users/c-nixon/gists{/gist_id}", "starred_url": "https://api.github.com/users/c-nixon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c-nixon/subscriptions", "organizations_url": "https://api.github.com/users/c-nixon/orgs", "repos_url": "https://api.github.com/users/c-nixon/repos", "events_url": "https://api.github.com/users/c-nixon/events{/privacy}", "received_events_url": "https://api.github.com/users/c-nixon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "c-nixon", "id": 5596332, "node_id": "MDQ6VXNlcjU1OTYzMzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5596332?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c-nixon", "html_url": "https://github.com/c-nixon", "followers_url": "https://api.github.com/users/c-nixon/followers", "following_url": "https://api.github.com/users/c-nixon/following{/other_user}", "gists_url": "https://api.github.com/users/c-nixon/gists{/gist_id}", "starred_url": "https://api.github.com/users/c-nixon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c-nixon/subscriptions", "organizations_url": "https://api.github.com/users/c-nixon/orgs", "repos_url": "https://api.github.com/users/c-nixon/repos", "events_url": "https://api.github.com/users/c-nixon/events{/privacy}", "received_events_url": "https://api.github.com/users/c-nixon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c980aba9a88704717229da3c1ec02685333c0db2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c980aba9a88704717229da3c1ec02685333c0db2", "html_url": "https://github.com/rust-lang/rust/commit/c980aba9a88704717229da3c1ec02685333c0db2"}], "stats": {"total": 94, "additions": 61, "deletions": 33}, "files": [{"sha": "17627da3513ec207b501e0818580dd190cc4998b", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d5b522e20e4aa862a62e086706187a51c9478a59/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/d5b522e20e4aa862a62e086706187a51c9478a59/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=d5b522e20e4aa862a62e086706187a51c9478a59", "patch": "@@ -135,28 +135,34 @@ This gives us an error:\n         ^~~~\n ```\n \n-In this case, we know that our code _should_ be safe, but Rust isn't sure. And\n-it's actually not safe: if we had a reference to `data` in each thread, and the\n-thread takes ownership of the reference, we have three owners! That's bad. We\n-can fix this by using the `Arc<T>` type, which is an atomic reference counted\n-pointer. The 'atomic' part means that it's safe to share across threads.\n+Rust knows this wouldn't be safe! If we had a reference to `data` in each\n+thread, and the thread takes ownership of the reference, we'd have three\n+owners!\n+\n+So, we need some type that lets us have more than one reference to a value and\n+that we can share between threads, that is it must implement `Sync`.\n+\n+We'll use `Arc<T>`, rust's standard atomic reference count type, which\n+wraps a value up with some extra runtime bookkeeping which allows us to\n+share the ownership of the value between multiple references at the same time.\n+\n+The bookkeeping consists of a count of how many of these references exist to\n+the value, hence the reference count part of the name.\n+\n+The Atomic part means `Arc<T>` can safely be accessed from multiple threads.\n+To do this the compiler guarantees that mutations of the internal count use\n+indivisible operations which can't have data races.\n \n-`Arc<T>` assumes one more property about its contents to ensure that it is safe\n-to share across threads: it assumes its contents are `Sync`. But in our\n-case, we want to be able to mutate the value. We need a type that can ensure\n-only one person at a time can mutate what's inside. For that, we can use the\n-`Mutex<T>` type. Here's the second version of our code. It still doesn't work,\n-but for a different reason:\n \n ```ignore\n use std::thread;\n-use std::sync::Mutex;\n+use std::sync::Arc;\n \n fn main() {\n-    let mut data = Mutex::new(vec![1, 2, 3]);\n+    let mut data = Arc::new(vec![1, 2, 3]);\n \n     for i in 0..3 {\n-        let data = data.lock().unwrap();\n+        let data = data.clone();\n         thread::spawn(move || {\n             data[i] += 1;\n         });\n@@ -166,29 +172,29 @@ fn main() {\n }\n ```\n \n-Here's the error:\n+We now call `clone()` on our `Arc<T>`, which increases the internal count.\n+This handle is then moved into the new thread.\n+\n+And... still gives us an error.\n \n ```text\n-<anon>:9:9: 9:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]\n-<anon>:11         thread::spawn(move || {\n-                  ^~~~~~~~~~~~~\n-<anon>:9:9: 9:22 note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent between threads safely\n-<anon>:11         thread::spawn(move || {\n-                  ^~~~~~~~~~~~~\n+<anon>:11:24 error: cannot borrow immutable borrowed content as mutable\n+<anon>:11                    data[i] += 1;\n+                             ^~~~\n ```\n \n-You see, [`Mutex`](../std/sync/struct.Mutex.html) has a\n-[`lock`](../std/sync/struct.Mutex.html#method.lock)\n-method which has this signature:\n+`Arc<T>` assumes one more property about its contents to ensure that it is safe\n+to share across threads: it assumes its contents are `Sync`. This is true for\n+our value if it's immutable, but we want to be able to mutate it, so we need\n+something else to persuade the borrow checker we know what we're doing.\n \n-```ignore\n-fn lock(&self) -> LockResult<MutexGuard<T>>\n-```\n+It looks like we need some type that allows us to safely mutate a shared value,\n+for example a type that that can ensure only one thread at a time is able to\n+mutate the value inside it at any one time.\n \n-Because `Send` is not implemented for `MutexGuard<T>`, we can't transfer the\n-guard across thread boundaries, which gives us our error.\n+For that, we can use the `Mutex<T>` type!\n \n-We can use `Arc<T>` to fix this. Here's the working version:\n+Here's the working version:\n \n ```rust\n use std::sync::{Arc, Mutex};\n@@ -209,9 +215,31 @@ fn main() {\n }\n ```\n \n-We now call `clone()` on our `Arc`, which increases the internal count. This\n-handle is then moved into the new thread. Let's examine the body of the\n-thread more closely:\n+\n+If we'd tried to use `Mutex<T>` without wrapping it in an `Arc<T>` we would have\n+seen another error like:\n+\n+```text\n+error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]\n+ thread::spawn(move || {\n+                  ^~~~~~~~~~~~~\n+note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent between threads safely\n+ thread::spawn(move || {\n+                  ^~~~~~~~~~~~~\n+```\n+\n+You see, [`Mutex`](../std/sync/struct.Mutex.html) has a\n+[`lock`](../std/sync/struct.Mutex.html#method.lock)\n+method which has this signature:\n+\n+```ignore\n+fn lock(&self) -> LockResult<MutexGuard<T>>\n+```\n+\n+and because `Send` is not implemented for `MutexGuard<T>`, we couldn't have\n+transferred the guard across thread boundaries on it's own.\n+\n+Let's examine the body of the thread more closely:\n \n ```rust\n # use std::sync::{Arc, Mutex};"}]}