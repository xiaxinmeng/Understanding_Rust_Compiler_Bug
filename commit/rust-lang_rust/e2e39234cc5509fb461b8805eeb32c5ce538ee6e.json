{"sha": "e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZTM5MjM0Y2M1NTA5ZmI0NjFiODgwNWVlYjMyYzVjZTUzOGVlNmU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-23T21:57:39Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-24T05:35:11Z"}, "message": "remove old_iter\n\nthe `test/run-pass/class-trait-bounded-param.rs` test was xfailed and\nwritten in an ancient dialect of Rust so I've just removed it\n\nthis also removes `to_vec` from DList because it's provided by\n`std::iter::to_vec`\n\nan Iterator implementation is added for OptVec but some transitional\ninternal iterator methods are still left", "tree": {"sha": "3d3e6047f22148cb76916b20c4ed274fc99a177d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d3e6047f22148cb76916b20c4ed274fc99a177d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "html_url": "https://github.com/rust-lang/rust/commit/e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac4211ef52a3577f901ed4dc7f370b05ca4e638d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4211ef52a3577f901ed4dc7f370b05ca4e638d", "html_url": "https://github.com/rust-lang/rust/commit/ac4211ef52a3577f901ed4dc7f370b05ca4e638d"}], "stats": {"total": 669, "additions": 120, "deletions": 549}, "files": [{"sha": "6e4507d4277ab9444a02af464b66c60a8eba7123", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -666,12 +666,8 @@ impl BitvSet {\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n-}\n-\n-impl BaseIter<uint> for BitvSet {\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n-    fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n+    pub fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n         for self.bitv.storage.iter().enumerate().advance |(i, &w)| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n                 return false;"}, {"sha": "1767aa8c397252932b84f819de987579c9e6824e", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 36, "deletions": 58, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -21,8 +21,6 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n use core::prelude::*;\n \n use core::managed;\n-use core::old_iter;\n-use core::vec;\n \n pub type DListLink<T> = Option<@mut DListNode<T>>;\n \n@@ -213,6 +211,42 @@ impl<T> DList<T> {\n }\n \n impl<T> DList<T> {\n+    /**\n+     * Iterates through the current contents.\n+     *\n+     * Attempts to access this dlist during iteration are allowed (to\n+     * allow for e.g. breadth-first search with in-place enqueues), but\n+     * removing the current node is forbidden.\n+     */\n+    pub fn each(@mut self, f: &fn(v: &T) -> bool) -> bool {\n+        let mut link = self.peek_n();\n+        while link.is_some() {\n+            let nobe = link.get();\n+            assert!(nobe.linked);\n+\n+            {\n+                let frozen_nobe = &*nobe;\n+                if !f(&frozen_nobe.data) { return false; }\n+            }\n+\n+            // Check (weakly) that the user didn't do a remove.\n+            if self.size == 0 {\n+                fail!(\"The dlist became empty during iteration??\")\n+            }\n+            if !nobe.linked ||\n+                (!((nobe.prev.is_some()\n+                    || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n+                                           nobe))\n+                   && (nobe.next.is_some()\n+                    || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n+                                           nobe)))) {\n+                fail!(\"Removing a dlist node during iteration is forbidden!\")\n+            }\n+            link = nobe.next_link();\n+        }\n+        return true;\n+    }\n+\n     /// Get the size of the list. O(1).\n     pub fn len(@mut self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n@@ -484,56 +518,6 @@ impl<T:Copy> DList<T> {\n \n     /// Get data at the list's tail, failing if empty. O(1).\n     pub fn tail(@mut self) -> T { copy self.tail_n().data }\n-\n-    /// Get the elements of the list as a vector. O(n).\n-    pub fn to_vec(@mut self) -> ~[T] {\n-        let mut v = vec::with_capacity(self.size);\n-        for old_iter::eachi(&self) |index,data| {\n-            v[index] = copy *data;\n-        }\n-        v\n-    }\n-}\n-\n-impl<T> BaseIter<T> for @mut DList<T> {\n-    /**\n-     * Iterates through the current contents.\n-     *\n-     * Attempts to access this dlist during iteration are allowed (to\n-     * allow for e.g. breadth-first search with in-place enqueues), but\n-     * removing the current node is forbidden.\n-     */\n-    fn each(&self, f: &fn(v: &T) -> bool) -> bool {\n-        let mut link = self.peek_n();\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-\n-            {\n-                let frozen_nobe = &*nobe;\n-                if !f(&frozen_nobe.data) { return false; }\n-            }\n-\n-            // Check (weakly) that the user didn't do a remove.\n-            if self.size == 0 {\n-                fail!(\"The dlist became empty during iteration??\")\n-            }\n-            if !nobe.linked ||\n-                (!((nobe.prev.is_some()\n-                    || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n-                                           nobe))\n-                   && (nobe.next.is_some()\n-                    || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n-                                           nobe)))) {\n-                fail!(\"Removing a dlist node during iteration is forbidden!\")\n-            }\n-            link = nobe.next_link();\n-        }\n-        return true;\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n #[cfg(test)]\n@@ -542,7 +526,6 @@ mod tests {\n \n     use super::*;\n \n-    use core::old_iter;\n     use core::vec;\n \n     #[test]\n@@ -759,11 +742,6 @@ mod tests {\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n-    fn test_dlist_foldl() {\n-        let l = from_vec(vec::from_fn(101, |x|x));\n-        assert_eq!(old_iter::foldl(&l, 0, |accum,elem| *accum+*elem), 5050);\n-    }\n-    #[test]\n     fn test_dlist_break_early() {\n         let l = from_vec([1,2,3,4,5]);\n         let mut x = 0;"}, {"sha": "4e201a6538ba428cc75b59bd971c09dc66e5a452", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -14,25 +14,15 @@\n \n use core::prelude::*;\n \n-use core::old_iter::BaseIter;\n use core::unstable::intrinsics::{move_val_init, init};\n use core::util::{replace, swap};\n use core::vec;\n \n-#[allow(missing_doc)]\n+/// A priority queue implemented with a binary heap\n pub struct PriorityQueue<T> {\n     priv data: ~[T],\n }\n \n-impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n-    /// Visit all values in the underlying vector.\n-    ///\n-    /// The values are **not** visited in order.\n-    fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.iter().advance(f) }\n-\n-    fn size_hint(&self) -> Option<uint> { Some(self.data.len()) }\n-}\n-\n impl<T:Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n     fn len(&self) -> uint { self.data.len() }\n@@ -47,6 +37,11 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n }\n \n impl<T:Ord> PriorityQueue<T> {\n+    /// Visit all values in the underlying vector.\n+    ///\n+    /// The values are **not** visited in order.\n+    pub fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.iter().advance(f) }\n+\n     /// Returns the greatest item in the queue - fails if empty\n     pub fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n "}, {"sha": "17126f0d32b5357e99f7c8d3f32c54a0fc788f89", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -19,8 +19,6 @@ use core::prelude::*;\n \n use core::cmp;\n use core::container::{Container, Mutable, Map, Set};\n-use core::old_iter::BaseIter;\n-use core::old_iter;\n use core::uint;\n use core::util::replace;\n use core::vec;\n@@ -212,12 +210,6 @@ impl Mutable for SmallIntSet {\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl BaseIter<uint> for SmallIntSet {\n-    /// Visit all values in order\n-    fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n impl Set<uint> for SmallIntSet {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &uint) -> bool { self.map.contains_key(value) }\n@@ -233,12 +225,14 @@ impl Set<uint> for SmallIntSet {\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty uintersection.\n     fn is_disjoint(&self, other: &SmallIntSet) -> bool {\n-        old_iter::all(self, |v| !other.contains(v))\n+        for self.each |v| { if other.contains(v) { return false } }\n+        true\n     }\n \n     /// Return true if the set is a subset of another\n     fn is_subset(&self, other: &SmallIntSet) -> bool {\n-        old_iter::all(self, |v| other.contains(v))\n+        for self.each |v| { if !other.contains(v) { return false } }\n+        true\n     }\n \n     /// Return true if the set is a superset of another\n@@ -286,6 +280,9 @@ impl Set<uint> for SmallIntSet {\n impl SmallIntSet {\n     /// Create an empty SmallIntSet\n     pub fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }\n+\n+    /// Visit all values in order\n+    pub fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n }\n \n #[cfg(test)]"}, {"sha": "4929dea9045bff8f9d788603f2cb15594252597d", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -249,22 +249,6 @@ pub struct TreeSet<T> {\n     priv map: TreeMap<T, ()>\n }\n \n-impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n-    /// Visit all values in order\n-    #[inline]\n-    fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n-    #[inline]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n-    /// Visit all values in reverse order\n-    #[inline]\n-    fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n-        self.map.each_key_reverse(f)\n-    }\n-}\n-\n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     #[inline]\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n@@ -499,6 +483,16 @@ impl<T: TotalOrd> TreeSet<T> {\n     pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n+\n+    /// Visit all values in order\n+    #[inline]\n+    pub fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n+\n+    /// Visit all values in reverse order\n+    #[inline]\n+    pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n }\n \n /// Lazy forward iterator over a set"}, {"sha": "1f2ede670fa1b0461e3cfc43bc03875af4cb5998", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -731,8 +731,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     }\n \n     let mut combined_ty_params = opt_vec::Empty;\n-    combined_ty_params.push_all(&owner_generics.ty_params);\n-    combined_ty_params.push_all(&method_generics.ty_params);\n+    for owner_generics.ty_params.each |x| { combined_ty_params.push(copy *x) }\n+    for method_generics.ty_params.each |x| { combined_ty_params.push(copy *x) }\n     let len = combined_ty_params.len();\n     encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n "}, {"sha": "7396dc1bd7bff0c66e8d439d14c6ebc4a3b35d99", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -507,7 +507,7 @@ impl FlowedMoveData {\n         for self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n-            if base_indices.contains(&moved_path) {\n+            if base_indices.iter().any_(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n                 if !f(move, self.move_data.path(moved_path).loan_path) {\n@@ -536,7 +536,7 @@ impl FlowedMoveData {\n                        -> bool {\n         //! True if `id` is the id of the LHS of an assignment\n \n-        self.move_data.assignee_ids.contains(&id)\n+        self.move_data.assignee_ids.iter().any_(|x| x == &id)\n     }\n \n     pub fn each_assignment_of(&self,"}, {"sha": "562bbca69297b7d0c87307e7de919116e1440923", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -3710,7 +3710,7 @@ impl Resolver {\n                 let function_type_rib = @Rib(rib_kind);\n                 self.type_ribs.push(function_type_rib);\n \n-                for generics.ty_params.eachi |index, type_parameter| {\n+                for generics.ty_params.iter().enumerate().advance |(index, type_parameter)| {\n                     let name = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id);"}, {"sha": "b871ed3d57afb23cb8dbc2663e3ed54820d4d342", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -14,7 +14,6 @@ use cast::transmute;\n use container::Container;\n use iterator::IteratorUtil;\n use kinds::Copy;\n-use old_iter;\n use option::Option;\n use sys;\n use uint;\n@@ -129,7 +128,7 @@ pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub fn from_fn<T>(n_elts: uint, op: old_iter::InitOp<T>) -> @[T] {\n+pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }"}, {"sha": "13c54799fac4d75c1b40941b00d34828523a6171", "filename": "src/libstd/core.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcore.rc?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -138,7 +138,6 @@ pub mod from_str;\n #[path = \"num/num.rs\"]\n pub mod num;\n pub mod iter;\n-pub mod old_iter;\n pub mod iterator;\n pub mod to_str;\n pub mod to_bytes;"}, {"sha": "9b87d76a309d030d26bc7987d9d6eb9213219f24", "filename": "src/libstd/old_iter.rs", "status": "removed", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/ac4211ef52a3577f901ed4dc7f370b05ca4e638d/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4211ef52a3577f901ed4dc7f370b05ca4e638d/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=ac4211ef52a3577f901ed4dc7f370b05ca4e638d", "patch": "@@ -1,296 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-**Deprecated** iteration traits and common implementations.\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use cmp::Eq;\n-use kinds::Copy;\n-use option::{None, Option, Some};\n-use vec;\n-\n-/// A function used to initialize the elements of a sequence\n-pub type InitOp<'self,T> = &'self fn(uint) -> T;\n-\n-pub trait BaseIter<A> {\n-    fn each(&self, blk: &fn(v: &A) -> bool) -> bool;\n-    fn size_hint(&self) -> Option<uint>;\n-}\n-\n-pub trait ReverseIter<A>: BaseIter<A> {\n-    fn each_reverse(&self, blk: &fn(&A) -> bool) -> bool;\n-}\n-\n-pub trait ExtendedIter<A> {\n-    fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool;\n-    fn all(&self, blk: &fn(&A) -> bool) -> bool;\n-    fn any(&self, blk: &fn(&A) -> bool) -> bool;\n-    fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n-    fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n-    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n-    fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n-}\n-\n-pub trait EqIter<A:Eq> {\n-    fn contains(&self, x: &A) -> bool;\n-    fn count(&self, x: &A) -> uint;\n-}\n-\n-pub trait CopyableIter<A:Copy> {\n-    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n-    fn to_vec(&self) -> ~[A];\n-    fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n-}\n-\n-// A trait for sequences that can be built by imperatively pushing elements\n-// onto them.\n-pub trait Buildable<A> {\n-    /**\n-     * Builds a buildable sequence by calling a provided function with\n-     * an argument function that pushes an element onto the back of\n-     * the sequence.\n-     * This version takes an initial size for the sequence.\n-     *\n-     * # Arguments\n-     *\n-     * * size - A hint for an initial size of the sequence\n-     * * builder - A function that will construct the sequence. It receives\n-     *             as an argument a function that will push an element\n-     *             onto the sequence being constructed.\n-     */\n-     fn build_sized(size: uint, builder: &fn(push: &fn(A))) -> Self;\n-}\n-\n-#[inline]\n-pub fn _eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n-    let mut i = 0;\n-    for this.each |a| {\n-        if !blk(i, a) {\n-            return false;\n-        }\n-        i += 1;\n-    }\n-    return true;\n-}\n-\n-pub fn eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n-    _eachi(this, blk)\n-}\n-\n-#[inline]\n-pub fn all<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n-    for this.each |a| {\n-        if !blk(a) {\n-            return false;\n-        }\n-    }\n-    return true;\n-}\n-\n-#[inline]\n-pub fn any<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n-    for this.each |a| {\n-        if blk(a) {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-#[inline]\n-pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(this: &IA,\n-                                            prd: &fn(&A) -> bool)\n-                                         -> ~[A] {\n-    do vec::build_sized_opt(this.size_hint()) |push| {\n-        for this.each |a| {\n-            if prd(a) { push(copy *a); }\n-        }\n-    }\n-}\n-\n-#[inline]\n-pub fn map_to_vec<A,B,IA:BaseIter<A>>(this: &IA, op: &fn(&A) -> B) -> ~[B] {\n-    do vec::build_sized_opt(this.size_hint()) |push| {\n-        for this.each |a| {\n-            push(op(a));\n-        }\n-    }\n-}\n-\n-#[inline]\n-pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(this: &IA,\n-                                                          op: &fn(&A) -> IB)\n-                                                       -> ~[B] {\n-    do vec::build |push| {\n-        for this.each |a| {\n-            for op(a).each |&b| {\n-                push(b);\n-            }\n-        }\n-    }\n-}\n-\n-#[inline]\n-pub fn foldl<A,B,IA:BaseIter<A>>(this: &IA, b0: B, blk: &fn(&B, &A) -> B)\n-                              -> B {\n-    let mut b = b0;\n-    for this.each |a| {\n-        b = blk(&b, a);\n-    }\n-    b\n-}\n-\n-#[inline]\n-pub fn to_vec<A:Copy,IA:BaseIter<A>>(this: &IA) -> ~[A] {\n-    map_to_vec(this, |&x| x)\n-}\n-\n-#[inline]\n-pub fn contains<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> bool {\n-    for this.each |a| {\n-        if *a == *x { return true; }\n-    }\n-    return false;\n-}\n-\n-#[inline]\n-pub fn count<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> uint {\n-    do foldl(this, 0) |count, value| {\n-        if *value == *x {\n-            *count + 1\n-        } else {\n-            *count\n-        }\n-    }\n-}\n-\n-#[inline]\n-pub fn position<A,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n-                               -> Option<uint> {\n-    let mut i = 0;\n-    for this.each |a| {\n-        if f(a) { return Some(i); }\n-        i += 1;\n-    }\n-    return None;\n-}\n-\n-#[inline]\n-pub fn find<A:Copy,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n-                                -> Option<A> {\n-    for this.each |i| {\n-        if f(i) { return Some(copy *i) }\n-    }\n-    return None;\n-}\n-\n-// Some functions for just building\n-\n-/**\n- * Builds a sequence by calling a provided function with an argument\n- * function that pushes an element to the back of a sequence.\n- *\n- * # Arguments\n- *\n- * * builder - A function that will construct the sequence. It receives\n- *             as an argument a function that will push an element\n- *             onto the sequence being constructed.\n- */\n-#[inline]\n-pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n-    Buildable::build_sized(4, builder)\n-}\n-\n-/**\n- * Builds a sequence by calling a provided function with an argument\n- * function that pushes an element to the back of the sequence.\n- * This version takes an initial size for the sequence.\n- *\n- * # Arguments\n- *\n- * * size - An option, maybe containing initial size of the sequence\n- *          to reserve.\n- * * builder - A function that will construct the sequence. It receives\n- *             as an argument a function that will push an element\n- *             onto the sequence being constructed.\n- */\n-#[inline]\n-pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n-                                          builder: &fn(push: &fn(A))) -> B {\n-    Buildable::build_sized(size.get_or_default(4), builder)\n-}\n-\n-// Functions that combine iteration and building\n-\n-/// Applies a function to each element of an iterable and returns the results\n-/// in a sequence built via `BU`.  See also `map_to_vec`.\n-#[inline]\n-pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n-    -> BU {\n-    do build_sized_opt(v.size_hint()) |push| {\n-        for v.each() |elem| {\n-            push(f(elem));\n-        }\n-    }\n-}\n-\n-/**\n- * Creates and initializes a generic sequence from a function.\n- *\n- * Creates a generic sequence of size `n_elts` and initializes the elements\n- * to the value returned by the function `op`.\n- */\n-#[inline]\n-pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n-    do Buildable::build_sized(n_elts) |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts { push(op(i)); i += 1u; }\n-    }\n-}\n-\n-/**\n- * Creates and initializes a generic sequence with some elements.\n- *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n- * to the value `t`.\n- */\n-#[inline]\n-pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n-    do Buildable::build_sized(n_elts) |push| {\n-        let mut i: uint = 0;\n-        while i < n_elts { push(copy t); i += 1; }\n-    }\n-}\n-\n-/// Appends two generic sequences.\n-#[inline]\n-pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n-                                                  -> BT {\n-    let size_opt = lhs.size_hint().chain_ref(\n-        |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n-    do build_sized_opt(size_opt) |push| {\n-        for lhs.each |x| { push(copy *x); }\n-        for rhs.each |x| { push(copy *x); }\n-    }\n-}\n-\n-/// Copies a generic sequence, possibly converting it to a different\n-/// type of sequence.\n-#[inline]\n-pub fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(v: &IT) -> BT {\n-    do build_sized_opt(v.size_hint()) |push| {\n-        for v.each |x| { push(copy *x); }\n-    }\n-}"}, {"sha": "6d7cb2a28a88d7e27d155a1231dee5dd14d39fda", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -46,8 +46,6 @@ pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Great\n pub use char::Char;\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use old_iter::{BaseIter, ReverseIter, ExtendedIter, EqIter};\n-pub use old_iter::CopyableIter;\n pub use iter::{Times, FromIter};\n pub use iterator::{Iterator, IteratorUtil, OrdIterator};\n pub use num::{Num, NumCast};"}, {"sha": "f4a79934e7e43812ba2c58c20e701d26d1e8ceda", "filename": "src/libstd/rt/uvio.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuvio.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -15,7 +15,6 @@ use super::io::net::ip::IpAddr;\n use super::uv::*;\n use super::rtio::*;\n use ops::Drop;\n-use old_iter::CopyableIter;\n use cell::Cell;\n use cast::transmute;\n use super::sched::{Scheduler, local_sched};"}, {"sha": "16c287c1da82387fc063a3103254a506ba46529c", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -29,7 +29,6 @@ use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator, MapIter\n use libc;\n use num::Zero;\n use option::{None, Option, Some};\n-use old_iter::EqIter;\n use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n@@ -2225,7 +2224,6 @@ mod tests {\n     use option::Some;\n     use libc::c_char;\n     use libc;\n-    use old_iter::BaseIter;\n     use ptr;\n     use str::*;\n     use vec;"}, {"sha": "9f812288621362542d23bc15f648891c217d2018", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -21,7 +21,6 @@ use iterator::IteratorUtil;\n use container::Map;\n use hash::Hash;\n use cmp::Eq;\n-use old_iter::BaseIter;\n use vec::ImmutableVector;\n use iterator::IteratorUtil;\n "}, {"sha": "e6449ef49229c730dc54904d3825cdae1e80129c", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -176,22 +176,6 @@ pub struct TrieSet {\n     priv map: TrieMap<()>\n }\n \n-impl BaseIter<uint> for TrieSet {\n-    /// Visit all values in order\n-    #[inline]\n-    fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n-    #[inline]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-impl ReverseIter<uint> for TrieSet {\n-    /// Visit all values in reverse order\n-    #[inline]\n-    fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n-        self.map.each_key_reverse(f)\n-    }\n-}\n-\n impl Container for TrieSet {\n     /// Return the number of elements in the set\n     #[inline]\n@@ -234,6 +218,16 @@ impl TrieSet {\n     pub fn remove(&mut self, value: &uint) -> bool {\n         self.map.remove(value)\n     }\n+\n+    /// Visit all values in order\n+    #[inline]\n+    pub fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n+\n+    /// Visit all values in reverse order\n+    #[inline]\n+    pub fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n }\n \n struct TrieNode<T> {"}, {"sha": "aeb5b000747f0304fd0b82eeb1e1a79bed5d1326", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -17,7 +17,6 @@ use cast;\n use container::{Container, Mutable};\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n-use old_iter;\n use iterator::{FromIterator, Iterator, IteratorUtil};\n use iter::FromIter;\n use kinds::Copy;\n@@ -124,7 +123,7 @@ pub fn capacity<T>(v: &const ~[T]) -> uint {\n  * Creates an owned vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub fn from_fn<T>(n_elts: uint, op: old_iter::InitOp<T>) -> ~[T] {\n+pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         do as_mut_buf(v) |p, _len| {\n@@ -815,7 +814,7 @@ pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n  * * init_op - A function to call to retreive each appended element's\n  *             value\n  */\n-pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: old_iter::InitOp<T>) {\n+pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: &fn(uint) -> T) {\n     let new_len = v.len() + n;\n     reserve_at_least(&mut *v, new_len);\n     let mut i: uint = 0u;\n@@ -1985,7 +1984,7 @@ pub trait OwnedVector<T> {\n     fn consume_reverse(self, f: &fn(uint, v: T));\n     fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n     fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n-    fn grow_fn(&mut self, n: uint, op: old_iter::InitOp<T>);\n+    fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -2064,7 +2063,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn grow_fn(&mut self, n: uint, op: old_iter::InitOp<T>) {\n+    fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T) {\n         grow_fn(self, n, op);\n     }\n }"}, {"sha": "55ac9c5ec1c82089078f9b985b5c2dd60b685639", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -375,7 +375,7 @@ impl gen_init for protocol {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         for (copy self.states).iter().advance |s| {\n             for s.generics.ty_params.each |tp| {\n-                match params.find(|tpp| tp.ident == tpp.ident) {\n+                match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n                   _ => ()\n                 }\n@@ -393,7 +393,7 @@ impl gen_init for protocol {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         let fields = do (copy self.states).iter().transform |s| {\n             for s.generics.ty_params.each |tp| {\n-                match params.find(|tpp| tp.ident == tpp.ident) {\n+                match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n                   _ => ()\n                 }"}, {"sha": "8917b481dc726063c51c1ed1b24687934e1d1011", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 38, "deletions": 79, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -17,9 +17,7 @@\n  */\n \n use core::prelude::*;\n-\n-use core::old_iter;\n-use core::old_iter::BaseIter;\n+use core::vec::VecIterator;\n \n #[deriving(Encodable, Decodable)]\n pub enum OptVec<T> {\n@@ -40,6 +38,13 @@ pub fn from<T>(t: ~[T]) -> OptVec<T> {\n }\n \n impl<T> OptVec<T> {\n+    fn each(&self, blk: &fn(v: &T) -> bool) -> bool {\n+        match *self {\n+            Empty => true,\n+            Vec(ref v) => v.iter().advance(blk)\n+        }\n+    }\n+\n     fn push(&mut self, t: T) {\n         match *self {\n             Vec(ref mut v) => {\n@@ -78,6 +83,28 @@ impl<T> OptVec<T> {\n             Vec(ref v) => v.len()\n         }\n     }\n+\n+    #[inline]\n+    fn iter<'r>(&'r self) -> OptVecIterator<'r, T> {\n+        match *self {\n+            Empty => OptVecIterator{iter: None},\n+            Vec(ref v) => OptVecIterator{iter: Some(v.iter())}\n+        }\n+    }\n+\n+    #[inline]\n+    fn map_to_vec<B>(&self, op: &fn(&T) -> B) -> ~[B] {\n+        self.iter().transform(op).collect()\n+    }\n+\n+    fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n+        let mut index = 0;\n+        self.map_to_vec(|a| {\n+            let i = index;\n+            index += 1;\n+            op(i, a)\n+        })\n+    }\n }\n \n pub fn take_vec<T>(v: OptVec<T>) -> ~[T] {\n@@ -96,22 +123,6 @@ impl<T:Copy> OptVec<T> {\n         }\n         return Vec(v0);\n     }\n-\n-    fn push_all<I: BaseIter<T>>(&mut self, from: &I) {\n-        for from.each |e| {\n-            self.push(copy *e);\n-        }\n-    }\n-\n-    #[inline]\n-    fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n-        let mut index = 0;\n-        old_iter::map_to_vec(self, |a| {\n-            let i = index;\n-            index += 1;\n-            op(i, a)\n-        })\n-    }\n }\n \n impl<A:Eq> Eq for OptVec<A> {\n@@ -131,68 +142,16 @@ impl<A:Eq> Eq for OptVec<A> {\n     }\n }\n \n-impl<A> BaseIter<A> for OptVec<A> {\n-    fn each(&self, blk: &fn(v: &A) -> bool) -> bool {\n-        match *self {\n-            Empty => true,\n-            Vec(ref v) => v.iter().advance(blk)\n-        }\n-    }\n-\n-    fn size_hint(&self) -> Option<uint> {\n-        Some(self.len())\n-    }\n+pub struct OptVecIterator<'self, T> {\n+    priv iter: Option<VecIterator<'self, T>>\n }\n \n-impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n+impl<'self, T> Iterator<&'self T> for OptVecIterator<'self, T> {\n     #[inline]\n-    fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) -> bool {\n-        old_iter::eachi(self, blk)\n-    }\n-    #[inline]\n-    fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::all(self, blk)\n-    }\n-    #[inline]\n-    fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::any(self, blk)\n-    }\n-    #[inline]\n-    fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        old_iter::foldl(self, b0, blk)\n-    }\n-    #[inline]\n-    fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        old_iter::position(self, f)\n-    }\n-    #[inline]\n-    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        old_iter::map_to_vec(self, op)\n-    }\n-    #[inline]\n-    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n-        -> ~[B] {\n-        old_iter::flat_map_to_vec(self, op)\n-    }\n-\n-}\n-\n-impl<A: Eq> old_iter::EqIter<A> for OptVec<A> {\n-    #[inline]\n-    fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n-    #[inline]\n-    fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n-}\n-\n-impl<A: Copy> old_iter::CopyableIter<A> for OptVec<A> {\n-    #[inline]\n-    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n-        old_iter::filter_to_vec(self, pred)\n-    }\n-    #[inline]\n-    fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n-    #[inline]\n-    fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n-        old_iter::find(self, f)\n+    fn next(&mut self) -> Option<&'self T> {\n+        match self.iter {\n+            Some(ref mut x) => x.next(),\n+            None => None\n+        }\n     }\n }"}, {"sha": "3d15ea16241f9f8e2c533bacf070500adb20ec93", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -13,7 +13,6 @@\n // Instead the failure will be delivered after the callbacks return.\n \n use std::libc;\n-use std::old_iter;\n use std::task;\n \n mod rustrt {"}, {"sha": "c54b8db46c88972aa777533e3ca05e2acc35252c", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e39234cc5509fb461b8805eeb32c5ce538ee6e/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=e2e39234cc5509fb461b8805eeb32c5ce538ee6e", "patch": "@@ -13,7 +13,6 @@\n use std::cmp;\n use std::container::{Container, Mutable, Map};\n use std::int;\n-use std::old_iter::BaseIter;\n use std::uint;\n \n enum cat_type { tuxedo, tabby, tortoiseshell }"}, {"sha": "75c62abcb0d55cdfa4b5747fe2c35809791f8cd0", "filename": "src/test/run-pass/class-trait-bounded-param.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ac4211ef52a3577f901ed4dc7f370b05ca4e638d/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4211ef52a3577f901ed4dc7f370b05ca4e638d/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs?ref=ac4211ef52a3577f901ed4dc7f370b05ca4e638d", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test\n-\n-extern mod extra;\n-use extra::oldmap::{map, hashmap, int_hash};\n-\n-class keys<K:Copy,V:Copy,M:Copy + map<K,V>>\n-    : old_iter::base_iter<K> {\n-\n-    let map: M;\n-\n-    new(map: M) {\n-        self.map = map;\n-    }\n-\n-    fn each(blk: &fn(K) -> bool) { self.map.each(|k, _v| blk(k) ) }\n-    fn size_hint() -> Option<uint> { Some(self.map.size()) }\n-    fn eachi(blk: &fn(uint, K) -> bool) { old_iter::eachi(self, blk) }\n-}\n-\n-pub fn main() {\n-    let m = int_hash();\n-    m.insert(1, 2);\n-    m.insert(3, 4);\n-    assert_eq!(old_iter::to_vec(keys(m)), ~[1, 3]);\n-}"}]}