{"sha": "ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlN2M3M2M1YTU4MDE3ZmI4NGI5N2JkYTRhODdiYWUwZjgzMWY2ZWE=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-10-12T18:57:29Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-10-12T19:18:24Z"}, "message": "Made a submodule for fn_ctxt", "tree": {"sha": "0bf2a7164feb5bf5e7af10d23c9e667797f6bf1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bf2a7164feb5bf5e7af10d23c9e667797f6bf1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "html_url": "https://github.com/rust-lang/rust/commit/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84878794edf0d60248be578943f9edbb5c0174ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/84878794edf0d60248be578943f9edbb5c0174ab", "html_url": "https://github.com/rust-lang/rust/commit/84878794edf0d60248be578943f9edbb5c0174ab"}], "stats": {"total": 127, "additions": 69, "deletions": 58}, "files": [{"sha": "017b0abd1d607533be4475d7003e75172e2ce383", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "renamed", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "patch": "@@ -1,9 +1,9 @@\n-use super::callee::{self, DeferredCallResolution};\n-use super::method::{self, MethodCallee, SelfSource};\n-use super::{BreakableCtxt, Diverges, Expectation, FallbackMode, FnCtxt, LocalTy};\n use crate::astconv::{\n     AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, PathSeg,\n };\n+use crate::check::callee::{self, DeferredCallResolution};\n+use crate::check::method::{self, MethodCallee, SelfSource};\n+use crate::check::{BreakableCtxt, Diverges, Expectation, FallbackMode, FnCtxt, LocalTy};\n \n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n@@ -41,7 +41,7 @@ use std::slice;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Produces warning on the given node, if the current point in the\n     /// function is unreachable, and there hasn't been another warning.\n-    pub(super) fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n+    pub(in super::super) fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n         // FIXME: Combine these two 'if' expressions into one once\n         // let chains are implemented\n         if let Diverges::Always { span: orig_span, custom_note } = self.diverges.get() {\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// version (resolve_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n     /// to get more type information.\n-    pub(super) fn resolve_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub(in super::super) fn resolve_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"resolve_vars_with_obligations(ty={:?})\", ty);\n \n         // No Infer()? Nothing needs doing.\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    pub(super) fn record_deferred_call_resolution(\n+    pub(in super::super) fn record_deferred_call_resolution(\n         &self,\n         closure_def_id: DefId,\n         r: DeferredCallResolution<'tcx>,\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         deferred_call_resolutions.entry(closure_def_id).or_default().push(r);\n     }\n \n-    pub(super) fn remove_deferred_call_resolutions(\n+    pub(in super::super) fn remove_deferred_call_resolutions(\n         &self,\n         closure_def_id: DefId,\n     ) -> Vec<DeferredCallResolution<'tcx>> {\n@@ -149,7 +149,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.typeck_results.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n-    pub(super) fn write_resolution(\n+    pub(in super::super) fn write_resolution(\n         &self,\n         hir_id: hir::HirId,\n         r: Result<(DefKind, DefId), ErrorReported>,\n@@ -335,7 +335,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// As `instantiate_type_scheme`, but for the bounds found in a\n     /// generic type scheme.\n-    pub(super) fn instantiate_bounds(\n+    pub(in super::super) fn instantiate_bounds(\n         &self,\n         span: Span,\n         def_id: DefId,\n@@ -355,7 +355,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Replaces the opaque types from the given value with type variables,\n     /// and records the `OpaqueTypeMap` for later use during writeback. See\n     /// `InferCtxt::instantiate_opaque_types` for more details.\n-    pub(super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n+    pub(in super::super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_id: hir::HirId,\n         value: &T,\n@@ -386,14 +386,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         value\n     }\n \n-    pub(super) fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n+    pub(in super::super) fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         self.inh.normalize_associated_types_in(span, self.body_id, self.param_env, value)\n     }\n \n-    pub(super) fn normalize_associated_types_in_as_infer_ok<T>(\n+    pub(in super::super) fn normalize_associated_types_in_as_infer_ok<T>(\n         &self,\n         span: Span,\n         value: &T,\n@@ -600,11 +600,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.normalize_associated_types_in(span, &field.ty(self.tcx, substs))\n     }\n \n-    pub(super) fn resolve_generator_interiors(&self, def_id: DefId) {\n+    pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior, kind) in generators.drain(..) {\n             self.select_obligations_where_possible(false, |_| {});\n-            super::generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n+            crate::check::generator_interior::resolve_interior(\n+                self, def_id, body_id, interior, kind,\n+            );\n         }\n     }\n \n@@ -620,7 +622,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // Fallback becomes very dubious if we have encountered type-checking errors.\n     // In that case, fallback to Error.\n     // The return value indicates whether fallback has occurred.\n-    pub(super) fn fallback_if_possible(&self, ty: Ty<'tcx>, mode: FallbackMode) -> bool {\n+    pub(in super::super) fn fallback_if_possible(&self, ty: Ty<'tcx>, mode: FallbackMode) -> bool {\n         use rustc_middle::ty::error::UnconstrainedNumeric::Neither;\n         use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n \n@@ -685,15 +687,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         true\n     }\n \n-    pub(super) fn select_all_obligations_or_error(&self) {\n+    pub(in super::super) fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n         if let Err(errors) = self.fulfillment_cx.borrow_mut().select_all_or_error(&self) {\n             self.report_fulfillment_errors(&errors, self.inh.body_id, false);\n         }\n     }\n \n     /// Select as many obligations as we can at present.\n-    pub(super) fn select_obligations_where_possible(\n+    pub(in super::super) fn select_obligations_where_possible(\n         &self,\n         fallback_has_occurred: bool,\n         mutate_fullfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n@@ -709,7 +711,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// returns a type of `&T`, but the actual type we assign to the\n     /// *expression* is `T`. So this function just peels off the return\n     /// type by one layer to yield `T`.\n-    pub(super) fn make_overloaded_place_return_type(\n+    pub(in super::super) fn make_overloaded_place_return_type(\n         &self,\n         method: MethodCallee<'tcx>,\n     ) -> ty::TypeAndMut<'tcx> {\n@@ -742,7 +744,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn obligations_for_self_ty<'b>(\n+    pub(in super::super) fn obligations_for_self_ty<'b>(\n         &'b self,\n         self_ty: ty::TyVid,\n     ) -> impl Iterator<Item = (ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n@@ -792,18 +794,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n     }\n \n-    pub(super) fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n+    pub(in super::super) fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n         self.obligations_for_self_ty(self_ty)\n             .any(|(tr, _)| Some(tr.def_id()) == self.tcx.lang_items().sized_trait())\n     }\n \n-    pub(super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n+    pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n         vec![self.tcx.ty_error(); len]\n     }\n \n     /// Unifies the output type with the expected type early, for more coercions\n     /// and forward type information on the input expressions.\n-    pub(super) fn expected_inputs_for_expected_output(\n+    pub(in super::super) fn expected_inputs_for_expected_output(\n         &self,\n         call_span: Span,\n         expected_ret: Expectation<'tcx>,\n@@ -856,7 +858,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expect_args\n     }\n \n-    pub(super) fn resolve_lang_item_path(\n+    pub(in super::super) fn resolve_lang_item_path(\n         &self,\n         lang_item: hir::LangItem,\n         span: Span,\n@@ -937,7 +939,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n-    pub(super) fn get_node_fn_decl(\n+    pub(in super::super) fn get_node_fn_decl(\n         &self,\n         node: Node<'tcx>,\n     ) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident, bool)> {\n@@ -973,7 +975,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub(super) fn note_internal_mutation_in_method(\n+    pub(in super::super) fn note_internal_mutation_in_method(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,\n@@ -1018,7 +1020,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn note_need_for_fn_pointer(\n+    pub(in super::super) fn note_need_for_fn_pointer(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expected: Ty<'tcx>,\n@@ -1055,7 +1057,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ));\n     }\n \n-    pub(super) fn could_remove_semicolon(\n+    pub(in super::super) fn could_remove_semicolon(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n@@ -1404,7 +1406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn with_breakable_ctxt<F: FnOnce() -> R, R>(\n+    pub(in super::super) fn with_breakable_ctxt<F: FnOnce() -> R, R>(\n         &self,\n         id: hir::HirId,\n         ctxt: BreakableCtxt<'tcx>,\n@@ -1429,7 +1431,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Instantiate a QueryResponse in a probe context, without a\n     /// good ObligationCause.\n-    pub(super) fn probe_instantiate_query_response(\n+    pub(in super::super) fn probe_instantiate_query_response(\n         &self,\n         span: Span,\n         original_values: &OriginalQueryValues<'tcx>,\n@@ -1444,7 +1446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Returns `true` if an expression is contained inside the LHS of an assignment expression.\n-    pub(super) fn expr_in_place(&self, mut expr_id: hir::HirId) -> bool {\n+    pub(in super::super) fn expr_in_place(&self, mut expr_id: hir::HirId) -> bool {\n         let mut contained_in_place = false;\n \n         while let hir::Node::Expr(parent_expr) =", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt_impl.rs"}, {"sha": "3224e04ee49fa1dce60741295105ca69ca1a2624", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "renamed", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "patch": "@@ -1,12 +1,12 @@\n-use super::coercion::CoerceMany;\n-use super::method::MethodCallee;\n-use super::Expectation::*;\n-use super::TupleArgumentsFlag::*;\n-use super::{\n+use crate::astconv::AstConv;\n+use crate::check::coercion::CoerceMany;\n+use crate::check::method::MethodCallee;\n+use crate::check::Expectation::*;\n+use crate::check::TupleArgumentsFlag::*;\n+use crate::check::{\n     potentially_plural_count, struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt,\n     LocalTy, Needs, TupleArgumentsFlag,\n };\n-use crate::astconv::AstConv;\n \n use rustc_ast as ast;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -26,14 +26,14 @@ use std::mem::replace;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub(super) fn check_casts(&self) {\n+    pub(in super::super) fn check_casts(&self) {\n         let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n         for cast in deferred_cast_checks.drain(..) {\n             cast.check(self);\n         }\n     }\n \n-    pub(super) fn check_method_argument_types(\n+    pub(in super::super) fn check_method_argument_types(\n         &self,\n         sp: Span,\n         expr: &'tcx hir::Expr<'tcx>,\n@@ -90,7 +90,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Generic function that factors out common logic from function calls,\n     /// method calls and overloaded operators.\n-    pub(super) fn check_argument_types(\n+    pub(in super::super) fn check_argument_types(\n         &self,\n         sp: Span,\n         expr: &'tcx hir::Expr<'tcx>,\n@@ -377,7 +377,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // AST fragment checking\n-    pub(super) fn check_lit(&self, lit: &hir::Lit, expected: Expectation<'tcx>) -> Ty<'tcx> {\n+    pub(in super::super) fn check_lit(\n+        &self,\n+        lit: &hir::Lit,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         match lit.node {\n@@ -563,7 +567,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn check_block_with_expected(\n+    pub(in super::super) fn check_block_with_expected(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected: Expectation<'tcx>,\n@@ -692,7 +696,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    pub(super) fn check_rustc_args_require_const(\n+    pub(in super::super) fn check_rustc_args_require_const(\n         &self,\n         def_id: DefId,\n         hir_id: hir::HirId,", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt_checks.rs"}, {"sha": "72c3b233ed934be694e3cf5f6ad2a2a22fdfcdf0", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "renamed", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "patch": "@@ -1,6 +1,14 @@\n-use super::coercion::DynamicCoerceMany;\n-use super::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n+mod _impl;\n+mod checks;\n+mod suggestions;\n+\n+pub use _impl::*;\n+pub use checks::*;\n+pub use suggestions::*;\n+\n use crate::astconv::AstConv;\n+use crate::check::coercion::DynamicCoerceMany;\n+use crate::check::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n \n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -18,7 +26,6 @@ use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode};\n use std::cell::{Cell, RefCell};\n use std::ops::Deref;\n \n-// The impl for this struct lives in fn_ctxt_impl.rs for file length reasons.\n pub struct FnCtxt<'a, 'tcx> {\n     pub(super) body_id: hir::HirId,\n ", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt.rs"}, {"sha": "9bad02c41b4b1fa2e7574eb604c72a3fe918f7a3", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "renamed", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "patch": "@@ -18,7 +18,11 @@ use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub(super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut DiagnosticBuilder<'_>) {\n+    pub(in super::super) fn suggest_semicolon_at_end(\n+        &self,\n+        span: Span,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n         err.span_suggestion_short(\n             span.shrink_to_hi(),\n             \"consider using a semicolon here\",\n@@ -251,7 +255,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n     /// in the heap by calling `Box::new()`.\n-    pub(super) fn suggest_boxing_when_appropriate(\n+    pub(in super::super) fn suggest_boxing_when_appropriate(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,\n@@ -286,7 +290,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n-    pub(super) fn suggest_calling_boxed_future_when_appropriate(\n+    pub(in super::super) fn suggest_calling_boxed_future_when_appropriate(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,\n@@ -381,7 +385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// This routine checks if the return type is left as default, the method is not part of an\n     /// `impl` block and that it isn't the `main` method. If so, it suggests setting the return\n     /// type.\n-    pub(super) fn suggest_missing_return_type(\n+    pub(in super::super) fn suggest_missing_return_type(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         fn_decl: &hir::FnDecl<'_>,\n@@ -447,7 +451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n     /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n     /// `.await` to the tail of the expression.\n-    pub(super) fn suggest_missing_await(\n+    pub(in super::super) fn suggest_missing_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,\n@@ -510,7 +514,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn suggest_missing_parentheses(\n+    pub(in super::super) fn suggest_missing_parentheses(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt_suggestions.rs"}, {"sha": "2dc769486c28ce7b7977f22d2026c8dc1d01e8ae", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce7c73c5a58017fb84b97bda4a87bae0f831f6ea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=ce7c73c5a58017fb84b97bda4a87bae0f831f6ea", "patch": "@@ -76,9 +76,6 @@ pub mod dropck;\n mod expectation;\n mod expr;\n mod fn_ctxt;\n-mod fn_ctxt_checks;\n-mod fn_ctxt_impl;\n-mod fn_ctxt_suggestions;\n mod gather_locals;\n mod generator_interior;\n mod inherited;\n@@ -99,10 +96,7 @@ use check::{\n pub use check::{check_item_type, check_wf_new};\n pub use diverges::Diverges;\n pub use expectation::Expectation;\n-pub use fn_ctxt::FnCtxt;\n-pub use fn_ctxt_checks::*;\n-pub use fn_ctxt_impl::*;\n-pub use fn_ctxt_suggestions::*;\n+pub use fn_ctxt::*;\n pub use inherited::{Inherited, InheritedBuilder};\n \n use crate::astconv::AstConv;"}]}