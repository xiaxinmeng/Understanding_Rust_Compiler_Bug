{"sha": "1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMGEzZmY1NWM0OTRkY2I2NjBlNGNkYWUyZGM0YjY5NzgxNWRjODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-16T13:23:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-16T13:23:23Z"}, "message": "Auto merge of #6937 - Jarcho:map_entry_suggestion, r=giraffate\n\nImprove `map_entry` suggestion\n\nfixes: #5176\nfixes: #4674\nfixes: #4664\nfixes: #1450\n\nStill need to handle the value returned by `insert` correctly.\n\nchangelog: Improve `map_entry` suggestion. Will now suggest `or_insert`, `insert_with` or `match _.entry(_)` as appopriate.\nchangelog: Fix `map_entry` false positives where the entry api can't be used. e.g. when the map is used for multiple things.", "tree": {"sha": "00b8347239f8ccbef9f73da9fc409ac03a3f0ef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00b8347239f8ccbef9f73da9fc409ac03a3f0ef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "html_url": "https://github.com/rust-lang/rust/commit/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e", "html_url": "https://github.com/rust-lang/rust/commit/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e"}, {"sha": "bcf348800751e8a03fdbaa49130e53a463e3a441", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf348800751e8a03fdbaa49130e53a463e3a441", "html_url": "https://github.com/rust-lang/rust/commit/bcf348800751e8a03fdbaa49130e53a463e3a441"}], "stats": {"total": 1889, "additions": 1518, "deletions": 371}, "files": [{"sha": "8db5050a5ac30510ccc424c15781860db49ba2da", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 575, "deletions": 122, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -1,33 +1,34 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n-use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n-use clippy_utils::SpanlessEq;\n-use clippy_utils::{get_item_name, paths};\n-use if_chain::if_chain;\n+use clippy_utils::{\n+    can_move_expr_to_closure_no_visit,\n+    diagnostics::span_lint_and_sugg,\n+    is_expr_final_block_expr, is_expr_used_or_unified, match_def_path, paths, peel_hir_expr_while,\n+    source::{reindent_multiline, snippet_indent, snippet_with_applicability, snippet_with_context},\n+    SpanlessEq,\n+};\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{BorrowKind, Expr, ExprKind, UnOp};\n+use rustc_hir::{\n+    intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n+    Block, Expr, ExprKind, Guard, HirId, Local, Stmt, StmtKind, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-use rustc_span::sym;\n+use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n+use std::fmt::Write;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n     /// or `BTreeMap`.\n     ///\n     /// **Why is this bad?** Using `entry` is more efficient.\n     ///\n-    /// **Known problems:** Some false negatives, eg.:\n+    /// **Known problems:** The suggestion may have type inference errors in some cases. e.g.\n     /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # let mut map = HashMap::new();\n-    /// # let v = 1;\n-    /// # let k = 1;\n-    /// if !map.contains_key(&k) {\n-    ///     map.insert(k.clone(), v);\n-    /// }\n+    /// let mut map = std::collections::HashMap::new();\n+    /// let _ = if !map.contains_key(&0) {\n+    ///     map.insert(0, 0)\n+    /// } else {\n+    ///     None\n+    /// };\n     /// ```\n     ///\n     /// **Example:**\n@@ -56,132 +57,584 @@ declare_clippy_lint! {\n declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n+    #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::If(check, then_block, ref else_block) = expr.kind {\n-            if let ExprKind::Unary(UnOp::Not, check) = check.kind {\n-                if let Some((ty, map, key)) = check_cond(cx, check) {\n-                    // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n-                    // we can give a better error message\n-                    let sole_expr = {\n-                        else_block.is_none()\n-                            && if let ExprKind::Block(then_block, _) = then_block.kind {\n-                                (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n-                            } else {\n-                                true\n-                            }\n-                        // XXXManishearth we can also check for if/else blocks containing `None`.\n-                    };\n-\n-                    let mut visitor = InsertVisitor {\n-                        cx,\n-                        span: expr.span,\n-                        ty,\n-                        map,\n-                        key,\n-                        sole_expr,\n-                    };\n-\n-                    walk_expr(&mut visitor, then_block);\n+        let (cond_expr, then_expr, else_expr) = match expr.kind {\n+            ExprKind::If(c, t, e) => (c, t, e),\n+            _ => return,\n+        };\n+        let (map_ty, contains_expr) = match try_parse_contains(cx, cond_expr) {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        let then_search = match find_insert_calls(cx, &contains_expr, then_expr) {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        let mut app = Applicability::MachineApplicable;\n+        let map_str = snippet_with_context(cx, contains_expr.map.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n+        let key_str = snippet_with_context(cx, contains_expr.key.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n+        let sugg = if let Some(else_expr) = else_expr {\n+            let else_search = match find_insert_calls(cx, &contains_expr, else_expr) {\n+                Some(search) => search,\n+                None => return,\n+            };\n+\n+            if then_search.edits.is_empty() && else_search.edits.is_empty() {\n+                // No insertions\n+                return;\n+            } else if then_search.edits.is_empty() || else_search.edits.is_empty() {\n+                // if .. { insert } else { .. } or if .. { .. } else { insert }\n+                let ((then_str, entry_kind), else_str) = match (else_search.edits.is_empty(), contains_expr.negated) {\n+                    (true, true) => (\n+                        then_search.snippet_vacant(cx, then_expr.span, &mut app),\n+                        snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                    (true, false) => (\n+                        then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                        snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                    (false, true) => (\n+                        else_search.snippet_occupied(cx, else_expr.span, &mut app),\n+                        snippet_with_applicability(cx, then_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                    (false, false) => (\n+                        else_search.snippet_vacant(cx, else_expr.span, &mut app),\n+                        snippet_with_applicability(cx, then_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                };\n+                format!(\n+                    \"if let {}::{} = {}.entry({}) {} else {}\",\n+                    map_ty.entry_path(),\n+                    entry_kind,\n+                    map_str,\n+                    key_str,\n+                    then_str,\n+                    else_str,\n+                )\n+            } else {\n+                // if .. { insert } else { insert }\n+                let ((then_str, then_entry), (else_str, else_entry)) = if contains_expr.negated {\n+                    (\n+                        then_search.snippet_vacant(cx, then_expr.span, &mut app),\n+                        else_search.snippet_occupied(cx, else_expr.span, &mut app),\n+                    )\n+                } else {\n+                    (\n+                        then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                        else_search.snippet_vacant(cx, else_expr.span, &mut app),\n+                    )\n+                };\n+                let indent_str = snippet_indent(cx, expr.span);\n+                let indent_str = indent_str.as_deref().unwrap_or(\"\");\n+                format!(\n+                    \"match {}.entry({}) {{\\n{indent}    {entry}::{} => {}\\n\\\n+                        {indent}    {entry}::{} => {}\\n{indent}}}\",\n+                    map_str,\n+                    key_str,\n+                    then_entry,\n+                    reindent_multiline(then_str.into(), true, Some(4 + indent_str.len())),\n+                    else_entry,\n+                    reindent_multiline(else_str.into(), true, Some(4 + indent_str.len())),\n+                    entry = map_ty.entry_path(),\n+                    indent = indent_str,\n+                )\n+            }\n+        } else {\n+            if then_search.edits.is_empty() {\n+                // no insertions\n+                return;\n+            }\n+\n+            // if .. { insert }\n+            if !then_search.allow_insert_closure {\n+                let (body_str, entry_kind) = if contains_expr.negated {\n+                    then_search.snippet_vacant(cx, then_expr.span, &mut app)\n+                } else {\n+                    then_search.snippet_occupied(cx, then_expr.span, &mut app)\n+                };\n+                format!(\n+                    \"if let {}::{} = {}.entry({}) {}\",\n+                    map_ty.entry_path(),\n+                    entry_kind,\n+                    map_str,\n+                    key_str,\n+                    body_str,\n+                )\n+            } else if let Some(insertion) = then_search.as_single_insertion() {\n+                let value_str = snippet_with_context(cx, insertion.value.span, then_expr.span.ctxt(), \"..\", &mut app).0;\n+                if contains_expr.negated {\n+                    if insertion.value.can_have_side_effects() {\n+                        format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, value_str)\n+                    } else {\n+                        format!(\"{}.entry({}).or_insert({});\", map_str, key_str, value_str)\n+                    }\n+                } else {\n+                    // TODO: suggest using `if let Some(v) = map.get_mut(k) { .. }` here.\n+                    // This would need to be a different lint.\n+                    return;\n                 }\n-            } else if let Some(else_block) = *else_block {\n-                if let Some((ty, map, key)) = check_cond(cx, check) {\n-                    let mut visitor = InsertVisitor {\n-                        cx,\n-                        span: expr.span,\n-                        ty,\n-                        map,\n-                        key,\n-                        sole_expr: false,\n-                    };\n-\n-                    walk_expr(&mut visitor, else_block);\n+            } else {\n+                let block_str = then_search.snippet_closure(cx, then_expr.span, &mut app);\n+                if contains_expr.negated {\n+                    format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, block_str)\n+                } else {\n+                    // TODO: suggest using `if let Some(v) = map.get_mut(k) { .. }` here.\n+                    // This would need to be a different lint.\n+                    return;\n                 }\n             }\n-        }\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_ENTRY,\n+            expr.span,\n+            &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", map_ty.name()),\n+            \"try this\",\n+            sugg,\n+            app,\n+        );\n     }\n }\n \n-fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static str, &'a Expr<'a>, &'a Expr<'a>)> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(path, _, params, _) = check.kind;\n-        if params.len() >= 2;\n-        if path.ident.name == sym!(contains_key);\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, key) = params[1].kind;\n-        then {\n-            let map = &params[0];\n-            let obj_ty = cx.typeck_results().expr_ty(map).peel_refs();\n+#[derive(Clone, Copy)]\n+enum MapType {\n+    Hash,\n+    BTree,\n+}\n+impl MapType {\n+    fn name(self) -> &'static str {\n+        match self {\n+            Self::Hash => \"HashMap\",\n+            Self::BTree => \"BTreeMap\",\n+        }\n+    }\n+    fn entry_path(self) -> &'static str {\n+        match self {\n+            Self::Hash => \"std::collections::hash_map::Entry\",\n+            Self::BTree => \"std::collections::btree_map::Entry\",\n+        }\n+    }\n+}\n \n-            return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n-                Some((\"BTreeMap\", map, key))\n-            }\n-            else if is_type_diagnostic_item(cx, obj_ty, sym::hashmap_type) {\n-                Some((\"HashMap\", map, key))\n-            }\n-            else {\n-                None\n+struct ContainsExpr<'tcx> {\n+    negated: bool,\n+    map: &'tcx Expr<'tcx>,\n+    key: &'tcx Expr<'tcx>,\n+    call_ctxt: SyntaxContext,\n+}\n+fn try_parse_contains(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(MapType, ContainsExpr<'tcx>)> {\n+    let mut negated = false;\n+    let expr = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::Unary(UnOp::Not, e) => {\n+            negated = !negated;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    match expr.kind {\n+        ExprKind::MethodCall(\n+            _,\n+            _,\n+            [map, Expr {\n+                kind: ExprKind::AddrOf(_, _, key),\n+                span: key_span,\n+                ..\n+            }],\n+            _,\n+        ) if key_span.ctxt() == expr.span.ctxt() => {\n+            let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n+            let expr = ContainsExpr {\n+                negated,\n+                map,\n+                key,\n+                call_ctxt: expr.span.ctxt(),\n             };\n+            if match_def_path(cx, id, &paths::BTREEMAP_CONTAINS_KEY) {\n+                Some((MapType::BTree, expr))\n+            } else if match_def_path(cx, id, &paths::HASHMAP_CONTAINS_KEY) {\n+                Some((MapType::Hash, expr))\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+struct InsertExpr<'tcx> {\n+    map: &'tcx Expr<'tcx>,\n+    key: &'tcx Expr<'tcx>,\n+    value: &'tcx Expr<'tcx>,\n+}\n+fn try_parse_insert(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n+    if let ExprKind::MethodCall(_, _, [map, key, value], _) = expr.kind {\n+        let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n+        if match_def_path(cx, id, &paths::BTREEMAP_INSERT) || match_def_path(cx, id, &paths::HASHMAP_INSERT) {\n+            Some(InsertExpr { map, key, value })\n+        } else {\n+            None\n         }\n+    } else {\n+        None\n     }\n+}\n \n-    None\n+/// An edit that will need to be made to move the expression to use the entry api\n+#[derive(Clone, Copy)]\n+enum Edit<'tcx> {\n+    /// A semicolon that needs to be removed. Used to create a closure for `insert_with`.\n+    RemoveSemi(Span),\n+    /// An insertion into the map.\n+    Insertion(Insertion<'tcx>),\n+}\n+impl Edit<'tcx> {\n+    fn as_insertion(self) -> Option<Insertion<'tcx>> {\n+        if let Self::Insertion(i) = self { Some(i) } else { None }\n+    }\n+}\n+#[derive(Clone, Copy)]\n+struct Insertion<'tcx> {\n+    call: &'tcx Expr<'tcx>,\n+    value: &'tcx Expr<'tcx>,\n }\n \n-struct InsertVisitor<'a, 'tcx, 'b> {\n-    cx: &'a LateContext<'tcx>,\n-    span: Span,\n-    ty: &'static str,\n-    map: &'b Expr<'b>,\n-    key: &'b Expr<'b>,\n-    sole_expr: bool,\n+/// This visitor needs to do a multiple things:\n+/// * Find all usages of the map. An insertion can only be made before any other usages of the map.\n+/// * Determine if there's an insertion using the same key. There's no need for the entry api\n+///   otherwise.\n+/// * Determine if the final statement executed is an insertion. This is needed to use\n+///   `or_insert_with`.\n+/// * Determine if there's any sub-expression that can't be placed in a closure.\n+/// * Determine if there's only a single insert statement. `or_insert` can be used in this case.\n+#[allow(clippy::struct_excessive_bools)]\n+struct InsertSearcher<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    /// The map expression used in the contains call.\n+    map: &'tcx Expr<'tcx>,\n+    /// The key expression used in the contains call.\n+    key: &'tcx Expr<'tcx>,\n+    /// The context of the top level block. All insert calls must be in the same context.\n+    ctxt: SyntaxContext,\n+    /// Whether this expression can be safely moved into a closure.\n+    allow_insert_closure: bool,\n+    /// Whether this expression can use the entry api.\n+    can_use_entry: bool,\n+    /// Whether this expression is the final expression in this code path. This may be a statement.\n+    in_tail_pos: bool,\n+    // Is this expression a single insert. A slightly better suggestion can be made in this case.\n+    is_single_insert: bool,\n+    /// If the visitor has seen the map being used.\n+    is_map_used: bool,\n+    /// The locations where changes need to be made for the suggestion.\n+    edits: Vec<Edit<'tcx>>,\n+    /// A stack of loops the visitor is currently in.\n+    loops: Vec<HirId>,\n }\n+impl<'tcx> InsertSearcher<'_, 'tcx> {\n+    /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n+    /// only if they are on separate code paths. This will return whether the map was used in the\n+    /// given expression.\n+    fn visit_cond_arm(&mut self, e: &'tcx Expr<'_>) -> bool {\n+        let is_map_used = self.is_map_used;\n+        let in_tail_pos = self.in_tail_pos;\n+        self.visit_expr(e);\n+        let res = self.is_map_used;\n+        self.is_map_used = is_map_used;\n+        self.in_tail_pos = in_tail_pos;\n+        res\n+    }\n \n-impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n-    type Map = Map<'tcx>;\n+    /// Visits an expression which is not itself in a tail position, but other sibling expressions\n+    /// may be. e.g. if conditions\n+    fn visit_non_tail_expr(&mut self, e: &'tcx Expr<'_>) {\n+        let in_tail_pos = self.in_tail_pos;\n+        self.in_tail_pos = false;\n+        self.visit_expr(e);\n+        self.in_tail_pos = in_tail_pos;\n+    }\n+}\n+impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n+    type Map = ErasedMap<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        match stmt.kind {\n+            StmtKind::Semi(e) => {\n+                self.visit_expr(e);\n+\n+                if self.in_tail_pos && self.allow_insert_closure {\n+                    // The spans are used to slice the top level expression into multiple parts. This requires that\n+                    // they all come from the same part of the source code.\n+                    if stmt.span.ctxt() == self.ctxt && e.span.ctxt() == self.ctxt {\n+                        self.edits\n+                            .push(Edit::RemoveSemi(stmt.span.trim_start(e.span).unwrap_or(DUMMY_SP)));\n+                    } else {\n+                        self.allow_insert_closure = false;\n+                    }\n+                }\n+            },\n+            StmtKind::Expr(e) => self.visit_expr(e),\n+            StmtKind::Local(Local { init: Some(e), .. }) => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n+                self.in_tail_pos = false;\n+                self.is_single_insert = false;\n+                self.visit_expr(e);\n+            },\n+            _ => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n+                self.is_single_insert = false;\n+            },\n+        }\n+    }\n+\n+    fn visit_block(&mut self, block: &'tcx Block<'_>) {\n+        // If the block is in a tail position, then the last expression (possibly a statement) is in the\n+        // tail position. The rest, however, are not.\n+        match (block.stmts, block.expr) {\n+            ([], None) => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n+            },\n+            ([], Some(expr)) => self.visit_expr(expr),\n+            (stmts, Some(expr)) => {\n+                let in_tail_pos = self.in_tail_pos;\n+                self.in_tail_pos = false;\n+                for stmt in stmts {\n+                    self.visit_stmt(stmt);\n+                }\n+                self.in_tail_pos = in_tail_pos;\n+                self.visit_expr(expr);\n+            },\n+            ([stmts @ .., stmt], None) => {\n+                let in_tail_pos = self.in_tail_pos;\n+                self.in_tail_pos = false;\n+                for stmt in stmts {\n+                    self.visit_stmt(stmt);\n+                }\n+                self.in_tail_pos = in_tail_pos;\n+                self.visit_stmt(stmt);\n+            },\n+        }\n+    }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, _, params, _) = expr.kind;\n-            if params.len() == 3;\n-            if path.ident.name == sym!(insert);\n-            if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);\n-            if SpanlessEq::new(self.cx).eq_expr(self.key, &params[1]);\n-            if snippet_opt(self.cx, self.map.span) == snippet_opt(self.cx, params[0].span);\n-            then {\n-                span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n-                                   &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", self.ty), |diag| {\n-                    if self.sole_expr {\n-                        let mut app = Applicability::MachineApplicable;\n-                        let help = format!(\"{}.entry({}).or_insert({});\",\n-                                           snippet_with_applicability(self.cx, self.map.span, \"map\", &mut app),\n-                                           snippet_with_applicability(self.cx, params[1].span, \"..\", &mut app),\n-                                           snippet_with_applicability(self.cx, params[2].span, \"..\", &mut app));\n-\n-                        diag.span_suggestion(\n-                            self.span,\n-                            \"consider using\",\n-                            help,\n-                            Applicability::MachineApplicable, // snippet\n-                        );\n+        if !self.can_use_entry {\n+            return;\n+        }\n+\n+        match try_parse_insert(self.cx, expr) {\n+            Some(insert_expr) if SpanlessEq::new(self.cx).eq_expr(self.map, insert_expr.map) => {\n+                // Multiple inserts, inserts with a different key, and inserts from a macro can't use the entry api.\n+                if self.is_map_used\n+                    || !SpanlessEq::new(self.cx).eq_expr(self.key, insert_expr.key)\n+                    || expr.span.ctxt() != self.ctxt\n+                {\n+                    self.can_use_entry = false;\n+                    return;\n+                }\n+\n+                self.edits.push(Edit::Insertion(Insertion {\n+                    call: expr,\n+                    value: insert_expr.value,\n+                }));\n+                self.is_map_used = true;\n+                self.allow_insert_closure &= self.in_tail_pos;\n+\n+                // The value doesn't affect whether there is only a single insert expression.\n+                let is_single_insert = self.is_single_insert;\n+                self.visit_non_tail_expr(insert_expr.value);\n+                self.is_single_insert = is_single_insert;\n+            },\n+            _ if SpanlessEq::new(self.cx).eq_expr(self.map, expr) => {\n+                self.is_map_used = true;\n+            },\n+            _ => match expr.kind {\n+                ExprKind::If(cond_expr, then_expr, Some(else_expr)) => {\n+                    self.is_single_insert = false;\n+                    self.visit_non_tail_expr(cond_expr);\n+                    // Each branch may contain it's own insert expression.\n+                    let mut is_map_used = self.visit_cond_arm(then_expr);\n+                    is_map_used |= self.visit_cond_arm(else_expr);\n+                    self.is_map_used = is_map_used;\n+                },\n+                ExprKind::Match(scrutinee_expr, arms, _) => {\n+                    self.is_single_insert = false;\n+                    self.visit_non_tail_expr(scrutinee_expr);\n+                    // Each branch may contain it's own insert expression.\n+                    let mut is_map_used = self.is_map_used;\n+                    for arm in arms {\n+                        if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n+                            self.visit_non_tail_expr(guard)\n+                        }\n+                        is_map_used |= self.visit_cond_arm(arm.body);\n                     }\n-                    else {\n-                        let help = format!(\"consider using `{}.entry({})`\",\n-                                           snippet(self.cx, self.map.span, \"map\"),\n-                                           snippet(self.cx, params[1].span, \"..\"));\n-\n-                        diag.span_label(\n-                            self.span,\n-                            &help,\n-                        );\n+                    self.is_map_used = is_map_used;\n+                },\n+                ExprKind::Loop(block, ..) => {\n+                    self.loops.push(expr.hir_id);\n+                    self.is_single_insert = false;\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    // Don't allow insertions inside of a loop.\n+                    let edit_len = self.edits.len();\n+                    self.visit_block(block);\n+                    if self.edits.len() != edit_len {\n+                        self.can_use_entry = false;\n                     }\n-                });\n-            }\n+                    self.loops.pop();\n+                },\n+                ExprKind::Block(block, _) => self.visit_block(block),\n+                ExprKind::InlineAsm(_) | ExprKind::LlvmInlineAsm(_) => {\n+                    self.can_use_entry = false;\n+                },\n+                _ => {\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    self.allow_insert_closure &= can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops);\n+                    // Sub expressions are no longer in the tail position.\n+                    self.is_single_insert = false;\n+                    self.in_tail_pos = false;\n+                    walk_expr(self, expr);\n+                },\n+            },\n         }\n+    }\n+}\n+\n+struct InsertSearchResults<'tcx> {\n+    edits: Vec<Edit<'tcx>>,\n+    allow_insert_closure: bool,\n+    is_single_insert: bool,\n+}\n+impl InsertSearchResults<'tcx> {\n+    fn as_single_insertion(&self) -> Option<Insertion<'tcx>> {\n+        self.is_single_insert.then(|| self.edits[0].as_insertion().unwrap())\n+    }\n \n-        if !self.sole_expr {\n-            walk_expr(self, expr);\n+    fn snippet(\n+        &self,\n+        cx: &LateContext<'_>,\n+        mut span: Span,\n+        app: &mut Applicability,\n+        write_wrapped: impl Fn(&mut String, Insertion<'_>, SyntaxContext, &mut Applicability),\n+    ) -> String {\n+        let ctxt = span.ctxt();\n+        let mut res = String::new();\n+        for insertion in self.edits.iter().filter_map(|e| e.as_insertion()) {\n+            res.push_str(&snippet_with_applicability(\n+                cx,\n+                span.until(insertion.call.span),\n+                \"..\",\n+                app,\n+            ));\n+            if is_expr_used_or_unified(cx.tcx, insertion.call) {\n+                write_wrapped(&mut res, insertion, ctxt, app);\n+            } else {\n+                let _ = write!(\n+                    res,\n+                    \"e.insert({})\",\n+                    snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0\n+                );\n+            }\n+            span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n         }\n+        res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n+        res\n     }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n+\n+    fn snippet_occupied(&self, cx: &LateContext<'_>, span: Span, app: &mut Applicability) -> (String, &'static str) {\n+        (\n+            self.snippet(cx, span, app, |res, insertion, ctxt, app| {\n+                // Insertion into a map would return `Some(&mut value)`, but the entry returns `&mut value`\n+                let _ = write!(\n+                    res,\n+                    \"Some(e.insert({}))\",\n+                    snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0\n+                );\n+            }),\n+            \"Occupied(mut e)\",\n+        )\n     }\n+\n+    fn snippet_vacant(&self, cx: &LateContext<'_>, span: Span, app: &mut Applicability) -> (String, &'static str) {\n+        (\n+            self.snippet(cx, span, app, |res, insertion, ctxt, app| {\n+                // Insertion into a map would return `None`, but the entry returns a mutable reference.\n+                let _ = if is_expr_final_block_expr(cx.tcx, insertion.call) {\n+                    write!(\n+                        res,\n+                        \"e.insert({});\\n{}None\",\n+                        snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n+                        snippet_indent(cx, insertion.call.span).as_deref().unwrap_or(\"\"),\n+                    )\n+                } else {\n+                    write!(\n+                        res,\n+                        \"{{ e.insert({}); None }}\",\n+                        snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n+                    )\n+                };\n+            }),\n+            \"Vacant(e)\",\n+        )\n+    }\n+\n+    fn snippet_closure(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n+        let ctxt = span.ctxt();\n+        let mut res = String::new();\n+        for edit in &self.edits {\n+            match *edit {\n+                Edit::Insertion(insertion) => {\n+                    // Cut out the value from `map.insert(key, value)`\n+                    res.push_str(&snippet_with_applicability(\n+                        cx,\n+                        span.until(insertion.call.span),\n+                        \"..\",\n+                        app,\n+                    ));\n+                    res.push_str(&snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0);\n+                    span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n+                },\n+                Edit::RemoveSemi(semi_span) => {\n+                    // Cut out the semicolon. This allows the value to be returned from the closure.\n+                    res.push_str(&snippet_with_applicability(cx, span.until(semi_span), \"..\", app));\n+                    span = span.trim_start(semi_span).unwrap_or(DUMMY_SP);\n+                },\n+            }\n+        }\n+        res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n+        res\n+    }\n+}\n+\n+fn find_insert_calls(\n+    cx: &LateContext<'tcx>,\n+    contains_expr: &ContainsExpr<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<InsertSearchResults<'tcx>> {\n+    let mut s = InsertSearcher {\n+        cx,\n+        map: contains_expr.map,\n+        key: contains_expr.key,\n+        ctxt: expr.span.ctxt(),\n+        edits: Vec::new(),\n+        is_map_used: false,\n+        allow_insert_closure: true,\n+        can_use_entry: true,\n+        in_tail_pos: true,\n+        is_single_insert: true,\n+        loops: Vec::new(),\n+    };\n+    s.visit_expr(expr);\n+    let allow_insert_closure = s.allow_insert_closure;\n+    let is_single_insert = s.is_single_insert;\n+    let edits = s.edits;\n+    s.can_use_entry.then(|| InsertSearchResults {\n+        edits,\n+        allow_insert_closure,\n+        is_single_insert,\n+    })\n }"}, {"sha": "0b873534f2c8d4be30d6fc29ed6191edebd49f69", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 5, "deletions": 52, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -1,16 +1,14 @@\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{can_partially_move_ty, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n-use clippy_utils::{in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs};\n+use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::{\n+    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs,\n+};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    def::Res,\n-    intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-    Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind, Path, QPath,\n-};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -199,51 +197,6 @@ impl LateLintPass<'_> for ManualMap {\n     }\n }\n \n-// Checks if the expression can be moved into a closure as is.\n-fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    struct V<'cx, 'tcx> {\n-        cx: &'cx LateContext<'tcx>,\n-        make_closure: bool,\n-    }\n-    impl Visitor<'tcx> for V<'_, 'tcx> {\n-        type Map = ErasedMap<'tcx>;\n-        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-            NestedVisitorMap::None\n-        }\n-\n-        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-            match e.kind {\n-                ExprKind::Break(..)\n-                | ExprKind::Continue(_)\n-                | ExprKind::Ret(_)\n-                | ExprKind::Yield(..)\n-                | ExprKind::InlineAsm(_)\n-                | ExprKind::LlvmInlineAsm(_) => {\n-                    self.make_closure = false;\n-                },\n-                // Accessing a field of a local value can only be done if the type isn't\n-                // partially moved.\n-                ExprKind::Field(base_expr, _)\n-                    if matches!(\n-                        base_expr.kind,\n-                        ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n-                    ) && can_partially_move_ty(self.cx, self.cx.typeck_results().expr_ty(base_expr)) =>\n-                {\n-                    // TODO: check if the local has been partially moved. Assume it has for now.\n-                    self.make_closure = false;\n-                    return;\n-                }\n-                _ => (),\n-            };\n-            walk_expr(self, e);\n-        }\n-    }\n-\n-    let mut v = V { cx, make_closure: true };\n-    v.visit_expr(expr);\n-    v.make_closure\n-}\n-\n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {"}, {"sha": "6c8a3302aa4afdb255086933b840c6b1ec998e69", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 146, "deletions": 19, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -60,12 +60,12 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, Body, Constness, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment, QPath,\n-    TraitItem, TraitItemKind, TraitRef, TyKind,\n+    def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n+    ImplItem, ImplItemKind, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment,\n+    QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -82,7 +82,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::is_recursively_primitive_type;\n+use crate::ty::{can_partially_move_ty, is_recursively_primitive_type};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -548,6 +548,73 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     None\n }\n \n+/// Checks if the top level expression can be moved into a closure as is.\n+pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n+    match expr.kind {\n+        ExprKind::Break(Destination { target_id: Ok(id), .. }, _)\n+        | ExprKind::Continue(Destination { target_id: Ok(id), .. })\n+            if jump_targets.contains(&id) =>\n+        {\n+            true\n+        },\n+        ExprKind::Break(..)\n+        | ExprKind::Continue(_)\n+        | ExprKind::Ret(_)\n+        | ExprKind::Yield(..)\n+        | ExprKind::InlineAsm(_)\n+        | ExprKind::LlvmInlineAsm(_) => false,\n+        // Accessing a field of a local value can only be done if the type isn't\n+        // partially moved.\n+        ExprKind::Field(base_expr, _)\n+            if matches!(\n+                base_expr.kind,\n+                ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n+            ) && can_partially_move_ty(cx, cx.typeck_results().expr_ty(base_expr)) =>\n+        {\n+            // TODO: check if the local has been partially moved. Assume it has for now.\n+            false\n+        }\n+        _ => true,\n+    }\n+}\n+\n+/// Checks if the expression can be moved into a closure as is.\n+pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        loops: Vec<HirId>,\n+        allow_closure: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if !self.allow_closure {\n+                return;\n+            }\n+            if let ExprKind::Loop(b, ..) = e.kind {\n+                self.loops.push(e.hir_id);\n+                self.visit_block(b);\n+                self.loops.pop();\n+            } else {\n+                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops);\n+                walk_expr(self, e);\n+            }\n+        }\n+    }\n+\n+    let mut v = V {\n+        cx,\n+        allow_closure: true,\n+        loops: Vec::new(),\n+    };\n+    v.visit_expr(expr);\n+    v.allow_closure\n+}\n+\n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n pub fn method_calls<'tcx>(\n@@ -1272,6 +1339,51 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n }\n \n+/// Gets the node where an expression is either used, or it's type is unified with another branch.\n+pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n+    let map = tcx.hir();\n+    let mut child_id = expr.hir_id;\n+    let mut iter = map.parent_iter(child_id);\n+    loop {\n+        match iter.next() {\n+            None => break None,\n+            Some((id, Node::Block(_))) => child_id = id,\n+            Some((id, Node::Arm(arm))) if arm.body.hir_id == child_id => child_id = id,\n+            Some((_, Node::Expr(expr))) => match expr.kind {\n+                ExprKind::Match(_, [arm], _) if arm.hir_id == child_id => child_id = expr.hir_id,\n+                ExprKind::Block(..) | ExprKind::DropTemps(_) => child_id = expr.hir_id,\n+                ExprKind::If(_, then_expr, None) if then_expr.hir_id == child_id => break None,\n+                _ => break Some(Node::Expr(expr)),\n+            },\n+            Some((_, node)) => break Some(node),\n+        }\n+    }\n+}\n+\n+/// Checks if the result of an expression is used, or it's type is unified with another branch.\n+pub fn is_expr_used_or_unified(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n+    !matches!(\n+        get_expr_use_or_unification_node(tcx, expr),\n+        None | Some(Node::Stmt(Stmt {\n+            kind: StmtKind::Expr(_)\n+                | StmtKind::Semi(_)\n+                | StmtKind::Local(Local {\n+                    pat: Pat {\n+                        kind: PatKind::Wild,\n+                        ..\n+                    },\n+                    ..\n+                }),\n+            ..\n+        }))\n+    )\n+}\n+\n+/// Checks if the expression is the final expression returned from a block.\n+pub fn is_expr_final_block_expr(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n+    matches!(get_parent_node(tcx, expr.hir_id), Some(Node::Block(..)))\n+}\n+\n pub fn is_no_std_crate(cx: &LateContext<'_>) -> bool {\n     cx.tcx.hir().attrs(hir::CRATE_HIR_ID).iter().any(|attr| {\n         if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n@@ -1441,28 +1553,43 @@ pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n     peel(pat, 0)\n }\n \n+/// Peels of expressions while the given closure returns `Some`.\n+pub fn peel_hir_expr_while<'tcx>(\n+    mut expr: &'tcx Expr<'tcx>,\n+    mut f: impl FnMut(&'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>>,\n+) -> &'tcx Expr<'tcx> {\n+    while let Some(e) = f(expr) {\n+        expr = e;\n+    }\n+    expr\n+}\n+\n /// Peels off up to the given number of references on the expression. Returns the underlying\n /// expression and the number of references removed.\n pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0, count)\n+    let mut remaining = count;\n+    let e = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::AddrOf(BorrowKind::Ref, _, e) if remaining != 0 => {\n+            remaining -= 1;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    (e, count - remaining)\n }\n \n /// Peels off all references on the expression. Returns the underlying expression and the number of\n /// references removed.\n pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(BorrowKind::Ref, _, expr) => f(expr, count + 1),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0)\n+    let mut count = 0;\n+    let e = peel_hir_expr_while(expr, |e| match e.kind {\n+        ExprKind::AddrOf(BorrowKind::Ref, _, e) => {\n+            count += 1;\n+            Some(e)\n+        },\n+        _ => None,\n+    });\n+    (e, count)\n }\n \n #[macro_export]"}, {"sha": "5e6733a300f2ca49cae21a62b5deeddc472685a2", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -13,7 +13,9 @@ pub(super) const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_\n pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n+pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n@@ -47,7 +49,9 @@ pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"fro\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n+pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n #[cfg(feature = \"internal-lints\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];"}, {"sha": "53180d1f9f54f699014b50c35f0d1e1eff33b9cc", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -66,6 +66,15 @@ pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n     snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n }\n \n+/// Gets a snippet of the indentation of the line of a span\n+pub fn snippet_indent<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+    snippet_opt(cx, line_span(cx, span)).map(|mut s| {\n+        let len = s.len() - s.trim_start().len();\n+        s.truncate(len);\n+        s\n+    })\n+}\n+\n // If the snippet is empty, it's an attribute that was inserted during macro\n // expansion and we want to ignore those, because they could come from external\n // sources that the user has no control over."}, {"sha": "cfad3090ba38d2bc7a0a5482c0c97084757f4fee", "filename": "tests/ui/entry.fixed", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -0,0 +1,155 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+#![feature(asm)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+macro_rules! insert {\n+    ($map:expr, $key:expr, $val:expr) => {\n+        $map.insert($key, $val)\n+    };\n+}\n+\n+fn foo() {}\n+\n+fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMap<K, V>, k: K, k2: K, v: V, v2: V) {\n+    // or_insert(v)\n+    m.entry(k).or_insert(v);\n+\n+    // semicolon on insert, use or_insert_with(..)\n+    m.entry(k).or_insert_with(|| {\n+        if true {\n+            v\n+        } else {\n+            v2\n+        }\n+    });\n+\n+    // semicolon on if, use or_insert_with(..)\n+    m.entry(k).or_insert_with(|| {\n+        if true {\n+            v\n+        } else {\n+            v2\n+        }\n+    });\n+\n+    // early return, use if let\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        if true {\n+            e.insert(v);\n+        } else {\n+            e.insert(v2);\n+            return;\n+        }\n+    }\n+\n+    // use or_insert_with(..)\n+    m.entry(k).or_insert_with(|| {\n+        foo();\n+        v\n+    });\n+\n+    // semicolon on insert and match, use or_insert_with(..)\n+    m.entry(k).or_insert_with(|| {\n+        match 0 {\n+            1 if true => {\n+                v\n+            },\n+            _ => {\n+                v2\n+            },\n+        }\n+    });\n+\n+    // one branch doesn't insert, use if let\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        match 0 {\n+            0 => foo(),\n+            _ => {\n+                e.insert(v2);\n+            },\n+        };\n+    }\n+\n+    // use or_insert_with\n+    m.entry(k).or_insert_with(|| {\n+        foo();\n+        match 0 {\n+            0 if false => {\n+                v\n+            },\n+            1 => {\n+                foo();\n+                v\n+            },\n+            2 | 3 => {\n+                for _ in 0..2 {\n+                    foo();\n+                }\n+                if true {\n+                    v\n+                } else {\n+                    v2\n+                }\n+            },\n+            _ => {\n+                v2\n+            },\n+        }\n+    });\n+\n+    // ok, insert in loop\n+    if !m.contains_key(&k) {\n+        for _ in 0..2 {\n+            m.insert(k, v);\n+        }\n+    }\n+\n+    // macro_expansion test, use or_insert(..)\n+    m.entry(m!(k)).or_insert_with(|| m!(v));\n+\n+    // ok, map used before insertion\n+    if !m.contains_key(&k) {\n+        let _ = m.len();\n+        m.insert(k, v);\n+    }\n+\n+    // ok, inline asm\n+    if !m.contains_key(&k) {\n+        unsafe { asm!(\"nop\") }\n+        m.insert(k, v);\n+    }\n+\n+    // ok, different keys.\n+    if !m.contains_key(&k) {\n+        m.insert(k2, v);\n+    }\n+\n+    // ok, different maps\n+    if !m.contains_key(&k) {\n+        m2.insert(k, v);\n+    }\n+\n+    // ok, insert in macro\n+    if !m.contains_key(&k) {\n+        insert!(m, k, v);\n+    }\n+}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n+    // insert then do something, use if let\n+    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fa9280b58de11cd513d6ced8c6ef0a8fe81b5cdf", "filename": "tests/ui/entry.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -0,0 +1,159 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+#![feature(asm)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+macro_rules! insert {\n+    ($map:expr, $key:expr, $val:expr) => {\n+        $map.insert($key, $val)\n+    };\n+}\n+\n+fn foo() {}\n+\n+fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMap<K, V>, k: K, k2: K, v: V, v2: V) {\n+    // or_insert(v)\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    }\n+\n+    // semicolon on insert, use or_insert_with(..)\n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v);\n+        } else {\n+            m.insert(k, v2);\n+        }\n+    }\n+\n+    // semicolon on if, use or_insert_with(..)\n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v)\n+        } else {\n+            m.insert(k, v2)\n+        };\n+    }\n+\n+    // early return, use if let\n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v);\n+        } else {\n+            m.insert(k, v2);\n+            return;\n+        }\n+    }\n+\n+    // use or_insert_with(..)\n+    if !m.contains_key(&k) {\n+        foo();\n+        m.insert(k, v);\n+    }\n+\n+    // semicolon on insert and match, use or_insert_with(..)\n+    if !m.contains_key(&k) {\n+        match 0 {\n+            1 if true => {\n+                m.insert(k, v);\n+            },\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        };\n+    }\n+\n+    // one branch doesn't insert, use if let\n+    if !m.contains_key(&k) {\n+        match 0 {\n+            0 => foo(),\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        };\n+    }\n+\n+    // use or_insert_with\n+    if !m.contains_key(&k) {\n+        foo();\n+        match 0 {\n+            0 if false => {\n+                m.insert(k, v);\n+            },\n+            1 => {\n+                foo();\n+                m.insert(k, v);\n+            },\n+            2 | 3 => {\n+                for _ in 0..2 {\n+                    foo();\n+                }\n+                if true {\n+                    m.insert(k, v);\n+                } else {\n+                    m.insert(k, v2);\n+                };\n+            },\n+            _ => {\n+                m.insert(k, v2);\n+            },\n+        }\n+    }\n+\n+    // ok, insert in loop\n+    if !m.contains_key(&k) {\n+        for _ in 0..2 {\n+            m.insert(k, v);\n+        }\n+    }\n+\n+    // macro_expansion test, use or_insert(..)\n+    if !m.contains_key(&m!(k)) {\n+        m.insert(m!(k), m!(v));\n+    }\n+\n+    // ok, map used before insertion\n+    if !m.contains_key(&k) {\n+        let _ = m.len();\n+        m.insert(k, v);\n+    }\n+\n+    // ok, inline asm\n+    if !m.contains_key(&k) {\n+        unsafe { asm!(\"nop\") }\n+        m.insert(k, v);\n+    }\n+\n+    // ok, different keys.\n+    if !m.contains_key(&k) {\n+        m.insert(k2, v);\n+    }\n+\n+    // ok, different maps\n+    if !m.contains_key(&k) {\n+        m2.insert(k, v);\n+    }\n+\n+    // ok, insert in macro\n+    if !m.contains_key(&k) {\n+        insert!(m, k, v);\n+    }\n+}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n+    // insert then do something, use if let\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2f075a97010a63d77365ce0ac6f03eeef8e3ab50", "filename": "tests/ui/entry.stderr", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -0,0 +1,186 @@\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:24:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^ help: try this: `m.entry(k).or_insert(v);`\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:29:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n+LL | |             m.insert(k, v);\n+LL | |         } else {\n+LL | |             m.insert(k, v2);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         if true {\n+LL |             v\n+LL |         } else {\n+LL |             v2\n+LL |         }\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:38:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n+LL | |             m.insert(k, v)\n+LL | |         } else {\n+LL | |             m.insert(k, v2)\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         if true {\n+LL |             v\n+LL |         } else {\n+LL |             v2\n+LL |         }\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:47:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n+LL | |             m.insert(k, v);\n+LL | |         } else {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         if true {\n+LL |             e.insert(v);\n+LL |         } else {\n+LL |             e.insert(v2);\n+LL |             return;\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:57:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         foo();\n+LL |         v\n+LL |     });\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:63:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         match 0 {\n+LL | |             1 if true => {\n+LL | |                 m.insert(k, v);\n+...  |\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         match 0 {\n+LL |             1 if true => {\n+LL |                 v\n+LL |             },\n+LL |             _ => {\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:75:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         match 0 {\n+LL | |             0 => foo(),\n+LL | |             _ => {\n+...  |\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         match 0 {\n+LL |             0 => foo(),\n+LL |             _ => {\n+LL |                 e.insert(v2);\n+LL |             },\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:85:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         match 0 {\n+LL | |             0 if false => {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         foo();\n+LL |         match 0 {\n+LL |             0 if false => {\n+LL |                 v\n+LL |             },\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:119:5\n+   |\n+LL | /     if !m.contains_key(&m!(k)) {\n+LL | |         m.insert(m!(k), m!(v));\n+LL | |     }\n+   | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n+\n+error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n+  --> $DIR/entry.rs:153:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "dcdaae7e72430494a3224bb9f0312ab07e90f274", "filename": "tests/ui/entry_fixable.fixed", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.fixed?ref=ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e", "patch": "@@ -1,15 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    m.entry(k).or_insert(v);\n-}\n-\n-fn main() {}"}, {"sha": "55d5b21568d0e03223089aad2e5990a3a104d9eb", "filename": "tests/ui/entry_fixable.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.rs?ref=ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e", "patch": "@@ -1,17 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(k, v);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "87403200ced5008788562ebe66b8c6c2ea918129", "filename": "tests/ui/entry_fixable.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_fixable.stderr?ref=ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e", "patch": "@@ -1,12 +0,0 @@\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_fixable.rs:12:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         m.insert(k, v);\n-LL | |     }\n-   | |_____^ help: consider using: `m.entry(k).or_insert(v);`\n-   |\n-   = note: `-D clippy::map-entry` implied by `-D warnings`\n-\n-error: aborting due to previous error\n-"}, {"sha": "f530fc023cfbf920f46b98cacb2847966234c6c8", "filename": "tests/ui/entry_unfixable.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_unfixable.rs?ref=ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e", "patch": "@@ -1,73 +0,0 @@\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n-\n-fn insert_if_present2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if m.contains_key(&k) {\n-        None\n-    } else {\n-        m.insert(k, v)\n-    };\n-}\n-\n-fn insert_if_absent3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        foo();\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n-\n-fn insert_if_present3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if m.contains_key(&k) {\n-        None\n-    } else {\n-        foo();\n-        m.insert(k, v)\n-    };\n-}\n-\n-fn insert_in_btreemap<K: Ord, V>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        foo();\n-        m.insert(k, v)\n-    } else {\n-        None\n-    };\n-}\n-\n-// should not trigger\n-fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(o, v);\n-    }\n-}\n-\n-// should not trigger, because the one uses different HashMap from another one\n-fn insert_from_different_map<K: Eq + Hash, V>(m: HashMap<K, V>, n: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        n.insert(k, v);\n-    }\n-}\n-\n-// should not trigger, because the one uses different HashMap from another one\n-fn insert_from_different_map2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, n: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        n.insert(k, v);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "e58c8d22dc45e2bc6303f3afeb8dd813ded7c42f", "filename": "tests/ui/entry_unfixable.stderr", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e/tests%2Fui%2Fentry_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_unfixable.stderr?ref=ddc2598230e4bb67d8a30d3a5cd8431c1cecb63e", "patch": "@@ -1,57 +0,0 @@\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:10:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-   |\n-   = note: `-D clippy::map-entry` implied by `-D warnings`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:18:5\n-   |\n-LL | /     if m.contains_key(&k) {\n-LL | |         None\n-LL | |     } else {\n-LL | |         m.insert(k, v)\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:26:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry_unfixable.rs:35:5\n-   |\n-LL | /     if m.contains_key(&k) {\n-LL | |         None\n-LL | |     } else {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry_unfixable.rs:44:5\n-   |\n-LL | /     if !m.contains_key(&k) {\n-LL | |         foo();\n-LL | |         m.insert(k, v)\n-LL | |     } else {\n-LL | |         None\n-LL | |     };\n-   | |_____^ consider using `m.entry(k)`\n-\n-error: aborting due to 5 previous errors\n-"}, {"sha": "2332fa6313ff3958dea096892b3ac236cfc16c14", "filename": "tests/ui/entry_with_else.fixed", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry_with_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry_with_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.fixed?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -0,0 +1,73 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+fn foo() {}\n+\n+fn insert_if_absent0<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+    } else {\n+        foo();\n+    }\n+\n+    if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+        e.insert(v);\n+    } else {\n+        foo();\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            if true { Some(e.insert(v)) } else { Some(e.insert(v2)) }\n+        }\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+            None\n+        }\n+    };\n+\n+    if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+        foo();\n+        Some(e.insert(v))\n+    } else {\n+        None\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "2ff0c038efe27fb3333dc4aea39e2e1da1e16e4f", "filename": "tests/ui/entry_with_else.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry_with_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry_with_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.rs?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -0,0 +1,60 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+fn foo() {}\n+\n+fn insert_if_absent0<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        foo();\n+    }\n+\n+    if !m.contains_key(&k) {\n+        foo();\n+    } else {\n+        m.insert(k, v);\n+    }\n+\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if m.contains_key(&k) {\n+        if true { m.insert(k, v) } else { m.insert(k, v2) }\n+    } else {\n+        m.insert(k, v)\n+    };\n+\n+    if m.contains_key(&k) {\n+        foo();\n+        m.insert(k, v)\n+    } else {\n+        None\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "6f62ff8d37457609f72a14510f69e3d661ff9cfe", "filename": "tests/ui/entry_with_else.stderr", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry_with_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fentry_with_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.stderr?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -0,0 +1,142 @@\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:16:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:22:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:28:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |     } else {\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:34:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |     } else {\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |     } else {\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:40:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:46:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         if true { m.insert(k, v) } else { m.insert(k, v2) }\n+LL | |     } else {\n+LL | |         m.insert(k, v)\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             if true { Some(e.insert(v)) } else { Some(e.insert(v2)) }\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:52:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         m.insert(k, v)\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+LL |         foo();\n+LL |         Some(e.insert(v))\n+LL |     } else {\n+LL |         None\n+LL |     };\n+   |\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "df2256e4f97de98afe0285e587ac9924c000fb3a", "filename": "tests/ui/string_lit_as_bytes.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fstring_lit_as_bytes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fstring_lit_as_bytes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.fixed?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -22,7 +22,7 @@ fn str_lit_as_bytes() {\n \n     let current_version = env!(\"CARGO_PKG_VERSION\").as_bytes();\n \n-    let includestr = include_bytes!(\"entry_unfixable.rs\");\n+    let includestr = include_bytes!(\"string_lit_as_bytes.rs\");\n \n     let _ = b\"string with newline\\t\\n\";\n }"}, {"sha": "c6bf8f732ed9f615d1ea2d660d6ed7602513270b", "filename": "tests/ui/string_lit_as_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fstring_lit_as_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fstring_lit_as_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.rs?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -22,7 +22,7 @@ fn str_lit_as_bytes() {\n \n     let current_version = env!(\"CARGO_PKG_VERSION\").as_bytes();\n \n-    let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n+    let includestr = include_str!(\"string_lit_as_bytes.rs\").as_bytes();\n \n     let _ = \"string with newline\\t\\n\".as_bytes();\n }"}, {"sha": "f47d6161c6cf2c8869b90783eebd684581ee9a91", "filename": "tests/ui/string_lit_as_bytes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fstring_lit_as_bytes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86/tests%2Fui%2Fstring_lit_as_bytes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.stderr?ref=1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "patch": "@@ -27,8 +27,8 @@ LL |     let bs = \"lit to owned\".to_owned().into_bytes();\n error: calling `as_bytes()` on `include_str!(..)`\n   --> $DIR/string_lit_as_bytes.rs:25:22\n    |\n-LL |     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"entry_unfixable.rs\")`\n+LL |     let includestr = include_str!(\"string_lit_as_bytes.rs\").as_bytes();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"string_lit_as_bytes.rs\")`\n \n error: calling `as_bytes()` on a string literal\n   --> $DIR/string_lit_as_bytes.rs:27:13"}]}