{"sha": "fa5bc6f1bd703cb081b48d032713bf78499bf155", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNWJjNmYxYmQ3MDNjYjA4MWI0OGQwMzI3MTNiZjc4NDk5YmYxNTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-06-30T22:43:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-06-30T22:44:36Z"}, "message": "core: Remove the unnecessary 'traits' module from 'slice'\n\nThis is only breaking for code that references the empty `slice::traits`\nmodule.\n\n[breaking-change]", "tree": {"sha": "32e43aae0ac66d96bf7aa372896ad51da6a82d30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32e43aae0ac66d96bf7aa372896ad51da6a82d30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa5bc6f1bd703cb081b48d032713bf78499bf155", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa5bc6f1bd703cb081b48d032713bf78499bf155", "html_url": "https://github.com/rust-lang/rust/commit/fa5bc6f1bd703cb081b48d032713bf78499bf155", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa5bc6f1bd703cb081b48d032713bf78499bf155/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16a9258797436498a00726e8aea2ee8a85755e15", "url": "https://api.github.com/repos/rust-lang/rust/commits/16a9258797436498a00726e8aea2ee8a85755e15", "html_url": "https://github.com/rust-lang/rust/commit/16a9258797436498a00726e8aea2ee8a85755e15"}], "stats": {"total": 88, "additions": 39, "deletions": 49}, "files": [{"sha": "0178c0318b81c2afde7be72eec396e4cfc55a425", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 39, "deletions": 49, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fa5bc6f1bd703cb081b48d032713bf78499bf155/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5bc6f1bd703cb081b48d032713bf78499bf155/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=fa5bc6f1bd703cb081b48d032713bf78499bf155", "patch": "@@ -36,7 +36,7 @@\n use mem::transmute;\n use clone::Clone;\n use collections::Collection;\n-use cmp::{PartialEq, Ord, Ordering, Less, Equal, Greater};\n+use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Less, Equal, Greater, Equiv};\n use cmp;\n use default::Default;\n use iter::*;\n@@ -1422,59 +1422,49 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n-#[allow(missing_doc)]\n-pub mod traits {\n-    use super::*;\n-\n-    use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Equiv};\n-    use iter::order;\n-    use collections::Collection;\n-    use option::Option;\n-\n-    impl<'a,T:PartialEq> PartialEq for &'a [T] {\n-        fn eq(&self, other: & &'a [T]) -> bool {\n-            self.len() == other.len() &&\n-                order::eq(self.iter(), other.iter())\n-        }\n-        fn ne(&self, other: & &'a [T]) -> bool {\n-            self.len() != other.len() ||\n-                order::ne(self.iter(), other.iter())\n-        }\n+impl<'a,T:PartialEq> PartialEq for &'a [T] {\n+    fn eq(&self, other: & &'a [T]) -> bool {\n+        self.len() == other.len() &&\n+            order::eq(self.iter(), other.iter())\n+    }\n+    fn ne(&self, other: & &'a [T]) -> bool {\n+        self.len() != other.len() ||\n+            order::ne(self.iter(), other.iter())\n     }\n+}\n \n-    impl<'a,T:Eq> Eq for &'a [T] {}\n+impl<'a,T:Eq> Eq for &'a [T] {}\n \n-    impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n+impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n+    #[inline]\n+    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+}\n \n-    impl<'a,T:Ord> Ord for &'a [T] {\n-        fn cmp(&self, other: & &'a [T]) -> Ordering {\n-            order::cmp(self.iter(), other.iter())\n-        }\n+impl<'a,T:Ord> Ord for &'a [T] {\n+    fn cmp(&self, other: & &'a [T]) -> Ordering {\n+        order::cmp(self.iter(), other.iter())\n     }\n+}\n \n-    impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n-        #[inline]\n-        fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {\n-            order::partial_cmp(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn lt(&self, other: & &'a [T]) -> bool {\n-            order::lt(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn le(&self, other: & &'a [T]) -> bool {\n-            order::le(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn ge(&self, other: & &'a [T]) -> bool {\n-            order::ge(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn gt(&self, other: & &'a [T]) -> bool {\n-            order::gt(self.iter(), other.iter())\n-        }\n+impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n+    #[inline]\n+    fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {\n+        order::partial_cmp(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn lt(&self, other: & &'a [T]) -> bool {\n+        order::lt(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn le(&self, other: & &'a [T]) -> bool {\n+        order::le(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn ge(&self, other: & &'a [T]) -> bool {\n+        order::ge(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn gt(&self, other: & &'a [T]) -> bool {\n+        order::gt(self.iter(), other.iter())\n     }\n }"}]}