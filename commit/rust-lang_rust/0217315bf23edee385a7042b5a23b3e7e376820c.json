{"sha": "0217315bf23edee385a7042b5a23b3e7e376820c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMTczMTViZjIzZWRlZTM4NWE3MDQyYjVhMjNiM2U3ZTM3NjgyMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-10T11:07:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-10T11:07:25Z"}, "message": "Auto merge of #44877 - nvzqz:box-conversions, r=alexcrichton\n\nImprove raw Box conversions\n\nThis PR has two goals:\n\n- Reduce use of `mem::transmute` in `Box` conversions\n\n  I understand that `mem::transmute`-ing non `#[repr(C)]` types is implementation-defined behavior.  This may not matter within the reference implementation of Rust, but I believe it's important to remain consistent. For example, I noticed that `str::from_utf8_unchecked` went from using `mem::transmute` to using pointer casts.\n\n- Make `Box` pointer conversions more straightforward regarding `Unique`", "tree": {"sha": "a081236a8c09dd20d54544f62cca217092f049d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a081236a8c09dd20d54544f62cca217092f049d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0217315bf23edee385a7042b5a23b3e7e376820c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0217315bf23edee385a7042b5a23b3e7e376820c", "html_url": "https://github.com/rust-lang/rust/commit/0217315bf23edee385a7042b5a23b3e7e376820c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0217315bf23edee385a7042b5a23b3e7e376820c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f578dfad0dd5d43b28eff71a7e857d10c3f55fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f578dfad0dd5d43b28eff71a7e857d10c3f55fe", "html_url": "https://github.com/rust-lang/rust/commit/5f578dfad0dd5d43b28eff71a7e857d10c3f55fe"}, {"sha": "22298b8240d40ed9b3dbdf570bccce56dfbfcd2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/22298b8240d40ed9b3dbdf570bccce56dfbfcd2c", "html_url": "https://github.com/rust-lang/rust/commit/22298b8240d40ed9b3dbdf570bccce56dfbfcd2c"}], "stats": {"total": 44, "additions": 40, "deletions": 4}, "files": [{"sha": "79292d390e5d25b71059656be8383835b13a9cfe", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0217315bf23edee385a7042b5a23b3e7e376820c/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0217315bf23edee385a7042b5a23b3e7e376820c/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=0217315bf23edee385a7042b5a23b3e7e376820c", "patch": "@@ -269,7 +269,38 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        mem::transmute(raw)\n+        Box::from_unique(Unique::new_unchecked(raw))\n+    }\n+\n+    /// Constructs a `Box` from a `Unique<T>` pointer.\n+    ///\n+    /// After calling this function, the memory is owned by a `Box` and `T` can\n+    /// then be destroyed and released upon drop.\n+    ///\n+    /// # Safety\n+    ///\n+    /// A `Unique<T>` can be safely created via [`Unique::new`] and thus doesn't\n+    /// necessarily own the data pointed to nor is the data guaranteed to live\n+    /// as long as the pointer.\n+    ///\n+    /// [`Unique::new`]: ../../core/ptr/struct.Unique.html#method.new\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unique)]\n+    ///\n+    /// fn main() {\n+    ///     let x = Box::new(5);\n+    ///     let ptr = Box::into_unique(x);\n+    ///     let x = unsafe { Box::from_unique(ptr) };\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n+               issue = \"27730\")]\n+    #[inline]\n+    pub unsafe fn from_unique(u: Unique<T>) -> Self {\n+        mem::transmute(u)\n     }\n \n     /// Consumes the `Box`, returning the wrapped raw pointer.\n@@ -295,21 +326,26 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n-        unsafe { mem::transmute(b) }\n+        Box::into_unique(b).as_ptr()\n     }\n \n     /// Consumes the `Box`, returning the wrapped pointer as `Unique<T>`.\n     ///\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the [`Box::from_raw`] function.\n+    /// proper way to do so is to either convert the `Unique<T>` pointer:\n+    ///\n+    /// - Into a `Box` with the [`Box::from_unique`] function.\n+    ///\n+    /// - Into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n+    ///   function.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_unique(b)` instead of `b.into_unique()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n+    /// [`Box::from_unique`]: struct.Box.html#method.from_unique\n     /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n     ///\n     /// # Examples"}]}