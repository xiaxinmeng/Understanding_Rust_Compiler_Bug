{"sha": "1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkMjg3N2Q3NzNkNjViNWE4OWViNDE3M2Q3ZDNjOThiMWJkODMxODc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-03T11:04:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-03T11:04:17Z"}, "message": "Merge pull request #506 from solson/rustup\n\nRustup for retagging", "tree": {"sha": "2acd6b01a865bfa9e540a75919d65f3769dfce77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2acd6b01a865bfa9e540a75919d65f3769dfce77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb3YCxCRBK7hj4Ov3rIwAAdHIIAHO1AjJohvWJUZv0hJ4UTgyr\nnO7zRm2CKHKSWDW7liH9uF7EAkxUTypE9MFZp2cQP4JWogAKCXHx+IH/xXFYZaZ3\ncy4KljfkYP9eiNGJWWMfvfccMKNa1kV7onL++5S8z9ouTAAq91WYBXBQBOvlFqsg\nyuvQ1xHqAsnrimdmp7+qFkM6t9VFA/bFcHXjxLzXA+G3wntO1PcigmvWsgPxHP0P\ngTORqFVtPzaTiC9YdCTywn+v/cLaJMUKO3UvsS1N616MEGpkHM8FWepzdm+4cpFg\n7SLud4PKezL7o0A51jqggtYaCjNsjLaUvXNxTU2upDuSOd5lnRVKA8iitva5SR0=\n=KJIe\n-----END PGP SIGNATURE-----\n", "payload": "tree 2acd6b01a865bfa9e540a75919d65f3769dfce77\nparent b1be4ee564eae748d79e11e9cbb1543cd045868c\nparent cb691b7ed9f0b6c37828d85126b2aaed4c2b57af\nauthor Ralf Jung <post@ralfj.de> 1541243057 +0100\ncommitter GitHub <noreply@github.com> 1541243057 +0100\n\nMerge pull request #506 from solson/rustup\n\nRustup for retagging"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "html_url": "https://github.com/rust-lang/rust/commit/1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1be4ee564eae748d79e11e9cbb1543cd045868c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1be4ee564eae748d79e11e9cbb1543cd045868c", "html_url": "https://github.com/rust-lang/rust/commit/b1be4ee564eae748d79e11e9cbb1543cd045868c"}, {"sha": "cb691b7ed9f0b6c37828d85126b2aaed4c2b57af", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb691b7ed9f0b6c37828d85126b2aaed4c2b57af", "html_url": "https://github.com/rust-lang/rust/commit/cb691b7ed9f0b6c37828d85126b2aaed4c2b57af"}], "stats": {"total": 1025, "additions": 671, "deletions": 354}, "files": [{"sha": "1e9ccbdf95000ff4d3b10aaa70747d6d3d46687f", "filename": "appveyor.yml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -14,19 +14,20 @@ branches:\n     - master\n \n install:\n-    # install Rust\n+    # Install Rust.\n     - set PATH=C:\\Program Files\\Git\\mingw64\\bin;C:\\msys64\\mingw%MSYS2_BITS%\\bin;%PATH%\n     - set /p RUST_TOOLCHAIN=<rust-version\n     - curl -sSf -o rustup-init.exe https://win.rustup.rs/\n     - rustup-init.exe -y --default-host %TARGET% --default-toolchain %RUST_TOOLCHAIN%\n     - set PATH=%USERPROFILE%\\.cargo\\bin;%PATH%\n     - rustc --version\n-    # customize installation\n+    # Customize installation.\n     - rustup component add rust-src\n     - cargo install xargo\n-    # prepare a libstd with MIR (cannot use bash script, obviously)\n+    # Prepare a libstd with MIR (cannot use bash script, obviously).\n+    # The flags here should be kept in sync with `add_miri_default_args` in `src/lib.rs`.\n     - cd xargo\n-    - set RUSTFLAGS=-Zalways-encode-mir -Zmir-emit-validate=1\n+    - set RUSTFLAGS=-Zalways-encode-mir -Zmir-emit-retag -Zmir-opt-level=0\n     - xargo build\n     - set RUSTFLAGS=\n     - cd .."}, {"sha": "6b277cc26bc90b4df312876d648f73ac8d94ab2b", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1 +1 @@\n-nightly-2018-10-30\n+nightly-2018-11-03"}, {"sha": "69c4f122544a5818f09175ab93d6ff2cfe3a4a7f", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -173,6 +173,7 @@ fn main() {\n                 .chain(Some(sys_root))\n                 .collect()\n         };\n+        args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n \n         // this check ensures that dependencies are built but not interpreted and the final crate is\n         // interpreted but not built\n@@ -186,7 +187,6 @@ fn main() {\n             Command::new(\"rustc\")\n         };\n \n-        args.extend_from_slice(&[\"-Z\".to_owned(), \"always-encode-mir\".to_owned()]);\n         args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-miri\"\"#.to_owned()]);\n \n         match command.args(&args).status() {"}, {"sha": "6fa9b817ffee73df16a46f4a456f56235f981e83", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -156,6 +156,7 @@ fn main() {\n                 true\n             }\n         }).collect();\n+        args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n         // file to process\n         args.push(path.display().to_string());\n \n@@ -165,10 +166,6 @@ fn main() {\n             args.push(Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\").display().to_string());\n         }\n \n-        args.push(\"-Zmir-opt-level=3\".to_owned());\n-        // for auxilary builds in unit tests\n-        args.push(\"-Zalways-encode-mir\".to_owned());\n-\n         // A threadsafe buffer for writing.\n         #[derive(Default, Clone)]\n         struct BufWriter(Arc<Mutex<Vec<u8>>>);"}, {"sha": "1bbf3c8c4a4a8e136242ee7730b273b81fe4d8ef", "filename": "src/bin/miri.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -10,6 +10,8 @@ extern crate rustc_codegen_utils;\n extern crate env_logger;\n extern crate log_settings;\n extern crate syntax;\n+\n+#[macro_use]\n extern crate log;\n \n use std::path::PathBuf;\n@@ -212,12 +214,7 @@ fn main() {\n     init_early_loggers();\n     let mut args: Vec<String> = std::env::args().collect();\n \n-    let sysroot_flag = String::from(\"--sysroot\");\n-    if !args.contains(&sysroot_flag) {\n-        args.push(sysroot_flag);\n-        args.push(find_sysroot());\n-    }\n-\n+    // Parse our own -Z flags and remove them before rustc gets their hand on them.\n     let mut validate = true;\n     args.retain(|arg| {\n         match arg.as_str() {\n@@ -229,7 +226,16 @@ fn main() {\n         }\n     });\n \n+    // Determine sysroot and let rustc know about it\n+    let sysroot_flag = String::from(\"--sysroot\");\n+    if !args.contains(&sysroot_flag) {\n+        args.push(sysroot_flag);\n+        args.push(find_sysroot());\n+    }\n+    // Finally, add the default flags all the way in the beginning, but after the binary name.\n+    args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n \n+    trace!(\"rustc arguments: {:?}\", args);\n     let result = rustc_driver::run(move || {\n         rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n             default: Box::new(RustcDefaultCalls),"}, {"sha": "a2271a5898b7fd286c0950b74adc3de56ca0afe6", "filename": "src/lib.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -26,7 +26,7 @@ use syntax::attr;\n \n \n pub use rustc_mir::interpret::*;\n-pub use rustc_mir::interpret::{self, AllocMap}; // resolve ambiguity\n+pub use rustc_mir::interpret::{self, AllocMap, PlaceTy}; // resolve ambiguity\n \n mod fn_call;\n mod operator;\n@@ -48,7 +48,16 @@ use crate::mono_hash_map::MonoHashMap;\n use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n \n // Used by priroda\n-pub use stacked_borrows::{Borrow, Stacks, Mut as MutBorrow};\n+pub use crate::stacked_borrows::{Borrow, Stack, Stacks, Mut as MutBorrow, BorStackItem};\n+\n+/// Insert rustc arguments at the beginning of the argument list that miri wants to be\n+/// set per default, for maximal validation power.\n+pub fn miri_default_args() -> &'static [&'static str] {\n+    // The flags here should be kept in sync with what bootstrap adds when `test-miri` is\n+    // set, which happens in `bootstrap/bin/rustc.rs` in the rustc sources; and also\n+    // kept in sync with `xargo/build.sh` in this repo and `appveyor.yml`.\n+    &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\"]\n+}\n \n // Used by priroda\n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n@@ -438,21 +447,30 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn memory_accessed(\n+    fn memory_read(\n         alloc: &Allocation<Borrow, Self::AllocExtra>,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        access: MemoryAccess,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.memory_accessed(ptr, size, access)\n+        alloc.extra.memory_read(ptr, size)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_written(\n+        alloc: &mut Allocation<Borrow, Self::AllocExtra>,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        alloc.extra.memory_written(ptr, size)\n     }\n \n     #[inline(always)]\n     fn memory_deallocated(\n         alloc: &mut Allocation<Borrow, Self::AllocExtra>,\n         ptr: Pointer<Borrow>,\n+        size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.memory_deallocated(ptr)\n+        alloc.extra.memory_deallocated(ptr, size)\n     }\n \n     #[inline(always)]\n@@ -507,4 +525,20 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             Ok(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n         }\n     }\n+\n+    #[inline(always)]\n+    fn retag(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        fn_entry: bool,\n+        place: PlaceTy<'tcx, Borrow>,\n+    ) -> EvalResult<'tcx> {\n+        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n+            // No tracking, or no retagging. This is possible because a dependency of ours might be\n+            // called with different flags than we are,\n+            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n+            // uninitialized data.\n+            return Ok(())\n+        }\n+        ecx.retag(fn_entry, place)\n+    }\n }"}, {"sha": "afc76fa375bc3dc823aa8d4fd2147e4c2baff1d5", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 214, "deletions": 173, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,11 +1,11 @@\n-use std::cell::{Cell, RefCell};\n+use std::cell::RefCell;\n \n-use rustc::ty::{Ty, layout::Size};\n+use rustc::ty::{self, Ty, layout::Size};\n use rustc::hir;\n \n-use super::{\n-    MemoryAccess, MemoryKind, MiriMemoryKind, RangeMap, EvalResult, AllocId,\n-    Pointer,\n+use crate::{\n+    MemoryKind, MiriMemoryKind, RangeMap, EvalResult, AllocId,\n+    Pointer, PlaceTy,\n };\n \n pub type Timestamp = u64;\n@@ -64,6 +64,12 @@ impl Borrow {\n     }\n }\n \n+impl Default for Borrow {\n+    fn default() -> Self {\n+        Borrow::Mut(Mut::Raw)\n+    }\n+}\n+\n /// An item in the borrow stack\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum BorStackItem {\n@@ -74,45 +80,52 @@ pub enum BorStackItem {\n     FnBarrier(usize)\n }\n \n-impl Default for Borrow {\n-    fn default() -> Self {\n-        Borrow::Mut(Mut::Raw)\n+impl BorStackItem {\n+    #[inline(always)]\n+    pub fn is_fn_barrier(self) -> bool {\n+        match self {\n+            BorStackItem::FnBarrier(_) => true,\n+            _ => false,\n+        }\n     }\n }\n \n-/// What kind of reference are we talking about?\n+/// What kind of usage of the pointer are we talking about?\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum RefKind {\n-    Mut,\n-    Shr,\n+pub enum UsageKind {\n+    /// Write, or create &mut\n+    Write,\n+    /// Read, or create &\n+    Read,\n+    /// Create *\n     Raw,\n }\n \n-impl From<Option<hir::Mutability>> for RefKind {\n+impl From<Option<hir::Mutability>> for UsageKind {\n     fn from(mutbl: Option<hir::Mutability>) -> Self {\n         match mutbl {\n-            None => RefKind::Raw,\n-            Some(hir::MutMutable) => RefKind::Mut,\n-            Some(hir::MutImmutable) => RefKind::Shr,\n+            None => UsageKind::Raw,\n+            Some(hir::MutMutable) => UsageKind::Write,\n+            Some(hir::MutImmutable) => UsageKind::Read,\n         }\n     }\n }\n \n /// Extra global machine state\n #[derive(Clone, Debug)]\n pub struct State {\n-    clock: Cell<Timestamp>\n+    clock: Timestamp\n }\n \n impl State {\n     pub fn new() -> State {\n-        State { clock: Cell::new(0) }\n+        State { clock: 0 }\n     }\n }\n \n /// Extra per-location state\n #[derive(Clone, Debug)]\n-struct Stack {\n+pub struct Stack {\n     borrows: Vec<BorStackItem>, // used as a stack\n     frozen_since: Option<Timestamp>,\n }\n@@ -126,95 +139,113 @@ impl Default for Stack {\n     }\n }\n \n+impl Stack {\n+    #[inline(always)]\n+    fn is_frozen(&self) -> bool {\n+        self.frozen_since.is_some()\n+    }\n+}\n+\n /// Extra per-allocation state\n #[derive(Clone, Debug, Default)]\n pub struct Stacks {\n+    // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n }\n \n /// Core operations\n impl<'tcx> Stack {\n-    /// Check if `bor` is currently active.  We accept a `Raw` on a frozen location\n-    /// because this could be a shared (re)borrow.  If you want to mutate, this\n-    /// is not the right function to call!\n-    fn check(&self, bor: Borrow) -> bool {\n-        match bor {\n-            Borrow::Frz(acc_t) =>\n-                // Must be frozen at least as long as the `acc_t` says.\n-                self.frozen_since.map_or(false, |loc_t| loc_t <= acc_t),\n-            Borrow::Mut(acc_m) =>\n-                // Raw pointers are fine with frozen locations. This is important because &Cell is raw!\n-                if self.frozen_since.is_some() {\n-                    acc_m.is_raw()\n-                } else {\n-                    self.borrows.last().map_or(false, |&loc_itm| loc_itm == BorStackItem::Mut(acc_m))\n-                }\n-        }\n-    }\n-\n     /// Check if `bor` could be activated by unfreezing and popping.\n-    /// `force_mut` indicates whether being frozen is potentially acceptable.\n+    /// `usage` indicates whether this is being used to read/write (or, equivalently, to\n+    /// borrow as &/&mut), or to borrow as raw.\n     /// Returns `Err` if the answer is \"no\"; otherwise the data says\n     /// what needs to happen to activate this: `None` = nothing,\n     /// `Some(n)` = unfreeze and make item `n` the top item of the stack.\n-    fn reactivatable(&self, bor: Borrow, force_mut: bool) -> Result<Option<usize>, String> {\n-        // Unless mutation is bound to happen, do NOT change anything if `bor` is already active.\n-        // In particular, if it is a `Mut(Raw)` and we are frozen, this should be a NOP.\n-        if !force_mut && self.check(bor) {\n-            return Ok(None);\n-        }\n-\n-        let acc_m = match bor {\n+    fn reactivatable(&self, bor: Borrow, usage: UsageKind) -> Result<Option<usize>, String> {\n+        let mut_borrow = match bor {\n             Borrow::Frz(since) =>\n-                return Err(if force_mut {\n-                    format!(\"Using a shared borrow for mutation\")\n-                } else {\n-                    format!(\n-                        \"Location should be frozen since {} but {}\",\n-                        since,\n-                        match self.frozen_since {\n-                            None => format!(\"it is not frozen at all\"),\n-                            Some(since) => format!(\"it is only frozen since {}\", since),\n-                        }\n-                    )\n-                }),\n-            Borrow::Mut(acc_m) => acc_m\n+                // The only way to reactivate a `Frz` is if this is already frozen.\n+                return match self.frozen_since {\n+                    _ if usage == UsageKind::Write =>\n+                        Err(format!(\"Using a shared borrow for mutation\")),\n+                    None =>\n+                        Err(format!(\"Location should be frozen but it is not\")),\n+                    Some(loc) if loc <= since =>\n+                        Ok(None),\n+                    Some(loc) =>\n+                        Err(format!(\"Location should be frozen since {} but it is only frozen \\\n+                                     since {}\", since, loc)),\n+                },\n+            Borrow::Mut(Mut::Raw) if self.is_frozen() && usage != UsageKind::Write =>\n+                // Non-mutating access with a raw from a frozen location is a special case: The\n+                // shared refs do not mind raw reads, and the raw itself does not assume any\n+                // exclusivity. So we do not even require there to be a raw on the stack,\n+                // the raw is instead \"matched\" by the fact that this location is frozen.\n+                // This does not break the assumption that an `&mut` we own is\n+                // exclusive for reads, because there we have the invariant that\n+                // the location is *not* frozen.\n+                return Ok(None),\n+            Borrow::Mut(mut_borrow) => mut_borrow\n         };\n-        // This is where we would unfreeze.\n+        // See if we can get there via popping.\n         for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n             match itm {\n                 BorStackItem::FnBarrier(_) =>\n-                    return Err(format!(\"Trying to reactivate a mutable borrow ({:?}) that lives behind a barrier\", acc_m)),\n-                BorStackItem::Mut(loc_m) => {\n-                    if loc_m == acc_m { return Ok(Some(idx)); }\n+                    return Err(format!(\"Trying to reactivate a mutable borrow ({:?}) that lives \\\n+                                        behind a barrier\", mut_borrow)),\n+                BorStackItem::Mut(loc) => {\n+                    if loc == mut_borrow {\n+                        // We found it!  This is good to know.\n+                        // Yet, maybe we do not really want to pop?\n+                        if usage == UsageKind::Read && self.is_frozen() {\n+                            // Whoever had exclusive access to this location allowed it\n+                            // to become frozen.  That can only happen if they reborrowed\n+                            // to a shared ref, at which point they gave up on exclusive access.\n+                            // Hence we allow more reads, entirely ignoring everything above\n+                            // on the stack (but still making sure it is on the stack).\n+                            // This does not break the assumption that an `&mut` we own is\n+                            // exclusive for reads, because there we have the invariant that\n+                            // the location is *not* frozen.\n+                            return Ok(None);\n+                        } else {\n+                            return Ok(Some(idx));\n+                        }\n+                    }\n                 }\n             }\n         }\n         // Nothing to be found.\n-        Err(format!(\"Mutable borrow-to-reactivate ({:?}) does not exist on the stack\", acc_m))\n+        Err(format!(\"Mutable borrow-to-reactivate ({:?}) does not exist on the stack\", mut_borrow))\n     }\n \n-    /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n-    /// unfreeze this location (because we are about to mutate, so a frozen `Raw` is not okay).\n-    fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n-        let action = match self.reactivatable(bor, force_mut) {\n+    /// Reactive `bor` for this stack.  `usage` indicates whether this is being\n+    /// used to read/write (or, equivalently, to borrow as &/&mut), or to borrow as raw.\n+    fn reactivate(&mut self, bor: Borrow, usage: UsageKind) -> EvalResult<'tcx> {\n+        let action = match self.reactivatable(bor, usage) {\n             Ok(action) => action,\n             Err(err) => return err!(MachineError(err)),\n         };\n-\n+        // Execute what `reactivatable` told us to do.\n         match action {\n             None => {}, // nothing to do\n             Some(top) => {\n+                if self.frozen_since.is_some() {\n+                    trace!(\"reactivate: Unfreezing\");\n+                }\n                 self.frozen_since = None;\n-                self.borrows.truncate(top+1);\n+                for itm in self.borrows.drain(top+1..).rev() {\n+                    trace!(\"reactivate: Popping {:?}\", itm);\n+                }\n             }\n         }\n \n         Ok(())\n     }\n \n     /// Initiate `bor`; mostly this means freezing or pushing.\n-    fn initiate(&mut self, bor: Borrow) -> EvalResult<'tcx> {\n+    /// This operation cannot fail; it is up to the caller to ensure that the precondition\n+    /// is met: We cannot push onto frozen stacks.\n+    fn initiate(&mut self, bor: Borrow) {\n         match bor {\n             Borrow::Frz(t) => {\n                 match self.frozen_since {\n@@ -240,83 +271,73 @@ impl<'tcx> Stack {\n                         // from it is fine with this as well.\n                         trace!(\"initiate: Initiating a raw on a frozen location, not doing a thing\"),\n                     Some(_) =>\n-                        return err!(MachineError(format!(\"Trying to mutate frozen location\")))\n+                        bug!(\"Trying to mutate frozen location\")\n                 }\n             }\n         }\n-        Ok(())\n     }\n }\n \n impl State {\n-    fn increment_clock(&self) -> Timestamp {\n-        let val = self.clock.get();\n-        self.clock.set(val + 1);\n+    fn increment_clock(&mut self) -> Timestamp {\n+        let val = self.clock;\n+        self.clock = val + 1;\n         val\n     }\n }\n \n /// Higher-level operations\n impl<'tcx> Stacks {\n-    pub fn memory_accessed(\n+    /// The single most operation: Make sure that using `ptr` as `usage` is okay,\n+    /// and if `new_bor` is present then make that the new current borrow.\n+    fn use_and_maybe_re_borrow(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        access: MemoryAccess,\n+        usage: UsageKind,\n+        new_bor: Option<Borrow>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"memory_accessed({:?}) with tag {:?}: {:?}, size {}\", access, ptr.tag, ptr, size.bytes());\n+        trace!(\"use_and_maybe_re_borrow of tag {:?} as {:?}, new {:?}: {:?}, size {}\",\n+            ptr.tag, usage, new_bor, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            // FIXME: Compare this with what the blog post says.\n-            stack.reactivate(ptr.tag, /*force_mut*/access == MemoryAccess::Write)?;\n+            stack.reactivate(ptr.tag, usage)?;\n+            if let Some(new_bor) = new_bor {\n+                stack.initiate(new_bor);\n+            }\n         }\n+\n         Ok(())\n     }\n \n-    pub fn memory_deallocated(\n-        &mut self,\n+    #[inline(always)]\n+    pub fn memory_read(\n+        &self,\n         ptr: Pointer<Borrow>,\n+        size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"memory_deallocated with tag {:?}: {:?}\", ptr.tag, ptr);\n-        let stacks = self.stacks.get_mut();\n-        for stack in stacks.iter_mut_all() {\n-            // This is like mutating.\n-            stack.reactivate(ptr.tag, /*force_mut*/true)?;\n-        }\n-        Ok(())\n+        // Reads behave exactly like the first half of a reborrow-to-shr\n+        self.use_and_maybe_re_borrow(ptr, size, UsageKind::Read, None)\n     }\n \n-    fn reborrow(\n-        &self,\n+    #[inline(always)]\n+    pub fn memory_written(\n+        &mut self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        new_bor: Borrow,\n-        permit_redundant: bool,\n     ) -> EvalResult<'tcx> {\n-        let mut stacks = self.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            if permit_redundant && stack.check(new_bor) {\n-                // The new borrow is already active!  This can happen when creating multiple\n-                // shared references from the same mutable reference.  Do nothing.\n-                trace!(\"reborrow: New borrow {:?} is already active, not doing a thing\", new_bor);\n-            } else {\n-                // If we are creating a uniq ref, we certainly want to unfreeze.\n-                // Even if we are doing so from a raw.\n-                // Notice that if this is a local, whenever we access it directly the\n-                // tag here will be the bottommost `Uniq` for that local.  That `Uniq`\n-                // never is accessible by the program, so it will not be used by any\n-                // other access.  IOW, whenever we directly use a local this will pop\n-                // everything else off the stack, invalidating all previous pointers\n-                // and, in particular, *all* raw pointers.  This subsumes the explicit\n-                // `reset` which the blog post [1] says to perform when accessing a local.\n-                //\n-                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n-                stack.reactivate(ptr.tag, /*force_mut*/new_bor.is_uniq())?;\n-                stack.initiate(new_bor)?;\n-            }\n-        }\n+        // Writes behave exactly like the first half of a reborrow-to-mut\n+        self.use_and_maybe_re_borrow(ptr, size, UsageKind::Write, None)\n+    }\n \n-        Ok(())\n+    pub fn memory_deallocated(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        // This is like mutating\n+        self.use_and_maybe_re_borrow(ptr, size, UsageKind::Write, None)\n+        // FIXME: Error out of there are any barriers?\n     }\n \n     /// Pushes the first borrow to the stacks, must be a mutable one.\n@@ -334,18 +355,12 @@ impl<'tcx> Stacks {\n }\n \n pub trait EvalContextExt<'tcx> {\n-    fn tag_for_pointee(\n-        &self,\n-        pointee_ty: Ty<'tcx>,\n-        ref_kind: RefKind,\n-    ) -> Borrow;\n-\n     fn tag_reference(\n-        &self,\n+        &mut self,\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        ref_kind: RefKind,\n+        usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow>;\n \n \n@@ -354,26 +369,35 @@ pub trait EvalContextExt<'tcx> {\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        ref_kind: RefKind,\n+        usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow>;\n \n     fn tag_new_allocation(\n         &mut self,\n         id: AllocId,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> Borrow;\n+\n+    fn retag(\n+        &mut self,\n+        fn_entry: bool,\n+        place: PlaceTy<'tcx, Borrow>\n+    ) -> EvalResult<'tcx>;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n-    fn tag_for_pointee(\n-        &self,\n+    /// Called for place-to-value conversion.\n+    fn tag_reference(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n-        ref_kind: RefKind,\n-    ) -> Borrow {\n+        size: Size,\n+        usage: UsageKind,\n+    ) -> EvalResult<'tcx, Borrow> {\n         let time = self.machine.stacked_borrows.increment_clock();\n-        match ref_kind {\n-            RefKind::Mut => Borrow::Mut(Mut::Uniq(time)),\n-            RefKind::Shr =>\n+        let new_bor = match usage {\n+            UsageKind::Write => Borrow::Mut(Mut::Uniq(time)),\n+            UsageKind::Read =>\n                 // FIXME This does not do enough checking when only part of the data has\n                 // interior mutability. When the type is `(i32, Cell<i32>)`, we want the\n                 // first field to be frozen but not the second.\n@@ -383,30 +407,18 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     // Shared reference with interior mutability.\n                     Borrow::Mut(Mut::Raw)\n                 },\n-            RefKind::Raw => Borrow::Mut(Mut::Raw),\n-        }\n-    }\n-\n-    /// Called for place-to-value conversion.\n-    fn tag_reference(\n-        &self,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n-        size: Size,\n-        ref_kind: RefKind,\n-    ) -> EvalResult<'tcx, Borrow> {\n-        let new_bor = self.tag_for_pointee(pointee_ty, ref_kind);\n+            UsageKind::Raw => Borrow::Mut(Mut::Raw),\n+        };\n         trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}, size {}): {:?}\",\n-            ref_kind, ptr, pointee_ty, size.bytes(), new_bor);\n+            usage, ptr, pointee_ty, size.bytes(), new_bor);\n \n         // Make sure this reference is not dangling or so\n         self.memory().check_bounds(ptr, size, false)?;\n \n         // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n         // memory.\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        let permit_redundant = ref_kind == RefKind::Shr; // redundant shared refs are okay\n-        alloc.extra.reborrow(ptr, size, new_bor, permit_redundant)?;\n+        alloc.extra.use_and_maybe_re_borrow(ptr, size, usage, Some(new_bor))?;\n \n         Ok(new_bor)\n     }\n@@ -420,43 +432,40 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        ref_kind: RefKind,\n+        usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow> {\n+        trace!(\"tag_reference: Accessing reference ({:?}) for {:?} (pointee {}, size {})\",\n+            usage, ptr, pointee_ty, size.bytes());\n         // In principle we should not have to do anything here.  However, with transmutes involved,\n-        // it can happen that the tag of `ptr` does not actually match `ref_kind`, and we\n+        // it can happen that the tag of `ptr` does not actually match `usage`, and we\n         // should adjust for that.\n         // Notably, the compiler can introduce such transmutes by optimizing away `&[mut]*`.\n         // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n-        match (ref_kind, ptr.tag) {\n-            (RefKind::Raw, _) => {\n+        match (usage, ptr.tag) {\n+            (UsageKind::Raw, _) => {\n                 // Don't use the tag, this is a raw access!  Even if there is a tag,\n                 // that means transmute happened and we ignore the tag.\n                 // Also don't do any further validation, this is raw after all.\n                 return Ok(Borrow::Mut(Mut::Raw));\n             }\n-            (RefKind::Mut, Borrow::Mut(Mut::Uniq(_))) |\n-            (RefKind::Shr, Borrow::Frz(_)) |\n-            (RefKind::Shr, Borrow::Mut(Mut::Raw)) => {\n+            (UsageKind::Write, Borrow::Mut(Mut::Uniq(_))) |\n+            (UsageKind::Read, Borrow::Frz(_)) |\n+            (UsageKind::Read, Borrow::Mut(Mut::Raw)) => {\n                 // Expected combinations.  Nothing to do.\n                 // FIXME: We probably shouldn't accept this if we got a raw shr without\n                 // interior mutability.\n             }\n-            (RefKind::Mut, Borrow::Mut(Mut::Raw)) => {\n+            (UsageKind::Write, Borrow::Mut(Mut::Raw)) => {\n                 // Raw transmuted to mut ref.  Keep this as raw access.\n                 // We cannot reborrow here; there might be a raw in `&(*var).1` where\n                 // `var` is an `&mut`.  The other field of the struct might be already frozen,\n                 // also using `var`, and that would be okay.\n             }\n-            (RefKind::Shr, Borrow::Mut(Mut::Uniq(_))) => {\n-                // A mut got transmuted to shr.  High time we freeze this location!\n-                // Make this a delayed reborrow.  Redundant reborows to shr are okay,\n-                // so we do not have to be worried about doing too much.\n-                // FIXME: Reconsider if we really want to mutate things while doing just a deref,\n-                // which, in particular, validation does.\n-                trace!(\"tag_dereference: Lazy freezing of {:?}\", ptr);\n-                return self.tag_reference(ptr, pointee_ty, size, ref_kind);\n+            (UsageKind::Read, Borrow::Mut(Mut::Uniq(_))) => {\n+                // A mut got transmuted to shr.  Can happen even from compiler transformations:\n+                // `&*x` gets optimized to `x` even when `x` is a `&mut`.\n             }\n-            (RefKind::Mut, Borrow::Frz(_)) => {\n+            (UsageKind::Write, Borrow::Frz(_)) => {\n                 // This is just invalid.\n                 // If we ever allow this, we have to consider what we do when a turn a\n                 // `Raw`-tagged `&mut` into a raw pointer pointing to a frozen location.\n@@ -472,12 +481,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         let mut stacks = alloc.extra.stacks.borrow_mut();\n         // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            // We accept &mut to a frozen location here, that is just normal.  There might\n-            // be shared reborrows that we are about to invalidate with this access.\n-            // We cannot invalidate them aggressively here because the deref might also be\n-            // to just create more shared refs.\n-            if let Err(err) = stack.reactivatable(ptr.tag, /*force_mut*/false) {\n-                return err!(MachineError(format!(\"Encountered {:?} reference with non-reactivatable tag: {}\", ref_kind, err)))\n+            // Conservatively assume that we will only read.\n+            if let Err(err) = stack.reactivatable(ptr.tag, UsageKind::Read) {\n+                return err!(MachineError(format!(\n+                    \"Encountered {} reference with non-reactivatable tag: {}\",\n+                    if usage == UsageKind::Write { \"mutable\" } else { \"shared\" },\n+                    err\n+                )))\n             }\n         }\n         // All is good.\n@@ -491,7 +501,14 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n     ) -> Borrow {\n         let mut_borrow = match kind {\n             MemoryKind::Stack => {\n-                // New unique borrow\n+                // New unique borrow. This `Uniq` is not accessible by the program,\n+                // so it will only ever be used when using the local directly (i.e.,\n+                // not through a pointer).  IOW, whenever we directly use a local this will pop\n+                // everything else off the stack, invalidating all previous pointers\n+                // and, in particular, *all* raw pointers.  This subsumes the explicit\n+                // `reset` which the blog post [1] says to perform when accessing a local.\n+                //\n+                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n                 let time = self.machine.stacked_borrows.increment_clock();\n                 Mut::Uniq(time)\n             }\n@@ -506,4 +523,28 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         alloc.extra.first_borrow(mut_borrow, size);\n         Borrow::Mut(mut_borrow)\n     }\n+\n+    fn retag(\n+        &mut self,\n+        _fn_entry: bool,\n+        place: PlaceTy<'tcx, Borrow>\n+    ) -> EvalResult<'tcx> {\n+        // For now, we only retag if the toplevel type is a reference.\n+        // TODO: Recurse into structs and enums, sharing code with validation.\n+        let mutbl = match place.layout.ty.sty {\n+            ty::Ref(_, _, mutbl) => mutbl, // go ahead\n+            _ => return Ok(()), // don't do a thing\n+        };\n+        // We want to reborrow the reference stored there. This will call the hooks\n+        // above.  First deref, which will call `tag_dereference`.\n+        // (This is somewhat redundant because validation already did the same thing,\n+        // but what can you do.)\n+        let val = self.read_value(self.place_to_op(place)?)?;\n+        let dest = self.ref_to_mplace(val)?;\n+        // Now put a new ref into the old place, which will call `tag_reference`.\n+        // FIXME: Honor `fn_entry`!\n+        let val = self.create_ref(dest, Some(mutbl))?;\n+        self.write_value(val, place)?;\n+        Ok(())\n+    }\n }"}, {"sha": "a33bca1267595cb67538c8a7e6f9009c20ae0e9c", "filename": "tests/compile-fail-fullmir/stack_free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail-fullmir%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail-fullmir%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstack_free.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation changes why we fail\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n // error-pattern: tried to deallocate Stack memory but gave Machine(Rust) as the kind\n "}, {"sha": "7ee3bc62767fb4f2076ffecbb9a209f2a43bf71f", "filename": "tests/compile-fail/cast_box_int_to_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n fn main() {\n     let b = Box::new(42);"}, {"sha": "207af4ae2cefb45a9e719f997671af2b7e961bfe", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n fn main() {\n     let g = unsafe {"}, {"sha": "295756ef0f56155c3e383888440d195c0b228412", "filename": "tests/compile-fail/execute_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n #![feature(box_syntax)]\n "}, {"sha": "9d29316fe24fe6c8499ebc05ea04ad5a4b23ae21", "filename": "tests/compile-fail/fn_ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffn_ptr_offset.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n use std::mem;\n "}, {"sha": "e80dc15efaec9e46d2f2ad632825f7092d5c6ee6", "filename": "tests/compile-fail/invalid_bool.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_bool.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n fn main() {\n     let b = unsafe { std::mem::transmute::<u8, bool>(2) };", "previous_filename": "tests/compile-fail/invalid_bool2.rs"}, {"sha": "b67ed9ba520d2cfbc9d943d1446a0c6b81642bbe", "filename": "tests/compile-fail/invalid_char.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Finvalid_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Finvalid_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_char.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n fn main() {\n     assert!(std::char::from_u32(-1_i32 as u32).is_none());", "previous_filename": "tests/compile-fail/invalid_char2.rs"}, {"sha": "bd5cb55b6c92b815cd42a5112cd8e347e95df7c4", "filename": "tests/compile-fail/invalid_enum_discriminant.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n // error-pattern: invalid enum discriminant\n ", "previous_filename": "tests/compile-fail/invalid_enum_discriminant2.rs"}, {"sha": "d7e6a8c09f64e14422881da7af65dddeaaeebe9e", "filename": "tests/compile-fail/never_say_never.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fnever_say_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fnever_say_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_say_never.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n #![feature(never_type)]\n #![allow(unreachable_code)]"}, {"sha": "169e861be0b1fb590b0d5f3356d05015d8131575", "filename": "tests/compile-fail/never_transmute_humans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fnever_transmute_humans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fnever_transmute_humans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_transmute_humans.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n #![feature(never_type)]\n #![allow(unreachable_code)]"}, {"sha": "9c0165fed222a114dc50d7851dc153ea3e84c9a0", "filename": "tests/compile-fail/never_transmute_void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fnever_transmute_void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fnever_transmute_void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_transmute_void.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n #![feature(never_type)]\n #![allow(unreachable_code)]"}, {"sha": "0d594f9bd4c3b14df93523dbc039ffb5fa74e7aa", "filename": "tests/compile-fail/panic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,3 @@\n-// FIXME: Something in panic handling fails validation with full-MIR\n-// compile-flags: -Zmir-emit-validate=0\n //error-pattern: the evaluated program panicked\n \n fn main() {"}, {"sha": "befe96f2b35d95d2b9a5d3705650a53c2480b6c5", "filename": "tests/compile-fail/reference_to_packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Freference_to_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Freference_to_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freference_to_packed.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n #![allow(dead_code, unused_variables)]\n "}, {"sha": "0b2d459366ceb56857e7d696d41ef046521a01b5", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,6 +1,3 @@\n-// With optimizations, we just store a raw in `x`, and there is no problem.\n-// compile-flags: -Zmir-opt-level=0\n-\n #![allow(unused_variables)]\n \n // This makes a ref that was passed to us via &mut alias with things it should not alias with\n@@ -14,5 +11,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR Shr reference with non-reactivatable tag\n+    let _val = *target_alias; //~ ERROR reference with non-reactivatable tag\n }"}, {"sha": "2c48404ddf364bbd010cdf1a6dd4e84fe52e2c8a", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Without retagging, optimization kills finding this problem\n-// compile-flags: -Zmir-opt-level=0\n-\n #![allow(unused_variables)]\n \n mod safe {\n@@ -17,6 +14,6 @@ fn main() {\n     let v = vec![0,1,2];\n     let v1 = safe::as_mut_slice(&v);\n     let v2 = safe::as_mut_slice(&v);\n-    v1[1] = 5; //~ ERROR Mut reference with non-reactivatable tag\n+    v1[1] = 5; //~ ERROR reference with non-reactivatable tag\n     v1[1] = 6;\n }"}, {"sha": "d8a241cab5d49265323c4442a68437fefd236fb8", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Without retagging, optimization kills finding this problem\n-// compile-flags: -Zmir-opt-level=0\n-\n #![allow(unused_variables)]\n \n mod safe {\n@@ -14,7 +11,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR Mut reference with non-reactivatable tag\n+            //~^ ERROR reference with non-reactivatable tag\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }"}, {"sha": "59190a15db440608710bf4ef199b63effaa14e8e", "filename": "tests/compile-fail/stacked_borrows/illegal_read1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,15 @@\n+// A callee may not read the destination of our `&mut` without\n+// us noticing.\n+\n+fn main() {\n+    let mut x = 15;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n+    callee(xraw);\n+    let _val = *xref; // ...but any use of raw will invalidate our ref.\n+    //~^ ERROR: mutable reference with non-reactivatable tag\n+}\n+\n+fn callee(xraw: *mut i32) {\n+    let _val = unsafe { *xraw };\n+}"}, {"sha": "594117d28ab84c54ba721248c905fe8b56105a9a", "filename": "tests/compile-fail/stacked_borrows/illegal_read2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,18 @@\n+// A callee may not read the destination of our `&mut` without\n+// us noticing.\n+\n+fn main() {\n+    let mut x = 15;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n+    callee(xraw);\n+    let _val = *xref; // ...but any use of raw will invalidate our ref.\n+    //~^ ERROR: mutable reference with non-reactivatable tag\n+}\n+\n+fn callee(xraw: *mut i32) {\n+    // We are a bit sneaky: We first create a shared ref, exploiting the reborrowing rules,\n+    // and then we read through that.\n+    let shr = unsafe { &*xraw };\n+    let _val = *shr;\n+}"}, {"sha": "ab951be5ec911b5221f77fe46a7cbce699704437", "filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let target = Box::new(42); // has an implicit raw\n     let ref_ = &*target;\n     evil(ref_); // invalidates shared ref, activates raw\n-    let _x = *ref_; //~ ERROR Shr reference with non-reactivatable tag\n+    let _x = *ref_; //~ ERROR reference with non-reactivatable tag\n }"}, {"sha": "b53655c82147e312364940ea983d14fb4102d99a", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,4 +1,5 @@\n-// The reborow gets optimized away, so we can only detect this issue without optimizations\n+// We fail to detect this when neither this nor libstd are optimized/have retagging.\n+// FIXME: Investigate that.\n // compile-flags: -Zmir-opt-level=0\n \n #![allow(unused_variables)]"}, {"sha": "12deb518b4e7ca5e51dd6b9f296e1b0e35188bc8", "filename": "tests/compile-fail/stacked_borrows/illegal_write4.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,31 +1,13 @@\n-// The compiler inserts some reborrows, enable optimizations to\n-// get rid of them.\n-// compile-flags: -Zmir-opt-level=1\n-\n use std::mem;\n \n-// This is an example of a piece of code that intuitively seems like we might\n-// want to reject it, but that doesn't turn out to be possible.\n-\n fn main() {\n-    let target = 42;\n-    // Make sure a cannot use a raw-tagged `&mut` pointing to a frozen location, not\n-    // even to create a raw.\n-    let reference = &target; // freeze\n+    let mut target = 42;\n+    // Make sure we cannot use a raw-tagged `&mut` pointing to a frozen location.\n+    // Even just creating it unfreezes.\n+    let raw = &mut target as *mut _; // let this leak to raw\n+    let reference = unsafe { &*raw }; // freeze\n     let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n-    let mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n-    // Now we have an &mut to a frozen location, but that is completely normal:\n-    // We'd just unfreeze the location if we used it.\n-    let bad_ptr = mut_ref as *mut i32; // even just creating this is like a use of `mut_ref`.\n-    // That violates the location being frozen!  However, we do not properly detect this:\n-    // We first see a `&mut` with a `Raw` tag being deref'd for a frozen location,\n-    // which can happen legitimately if the compiler optimized away an `&mut*` that\n-    // turns a raw into a `&mut`.  Next, we create a raw ref to a frozen location\n-    // from a `Raw` tag, which can happen legitimately when interior mutability\n-    // is involved.\n-    let _val = *reference; // Make sure it is still frozen.\n-\n-    // We only actually unfreeze once we muteate through the bad pointer.\n-    unsafe { *bad_ptr = 42 }; //~ ERROR does not exist on the stack\n-    let _val = *reference;\n+    let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n+    // Now we retag, making our ref top-of-stack -- and, in particular, unfreezing.\n+    let _val = *reference; //~ ERROR Location should be frozen\n }"}, {"sha": "f4704ad57161f37529ca04bada9247c412c6808f", "filename": "tests/compile-fail/stacked_borrows/illegal_write5.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,15 @@\n+// A callee may not write to the destination of our `&mut` without\n+// us noticing.\n+\n+fn main() {\n+    let mut x = 15;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n+    callee(xraw);\n+    let _val = *xref; // ...but any use of raw will invalidate our ref.\n+    //~^ ERROR: reference with non-reactivatable tag\n+}\n+\n+fn callee(xraw: *mut i32) {\n+    unsafe { *xraw = 15 };\n+}"}, {"sha": "4ea61cd606fff88ea5bbc3194b1f73e9b3436b64", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n     let _val = *x; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR Mut reference with non-reactivatable tag\n+    let _val = *xref_in_mem; //~ ERROR mutable reference with non-reactivatable tag\n }"}, {"sha": "53179c954dea28bf488c0d7f9b799fa8efa0e809", "filename": "tests/compile-fail/stacked_borrows/load_invalid_shr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -4,6 +4,6 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     let xref_in_mem = Box::new(xref);\n-    let _val = *x; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+    *x = 42; // invalidate xraw\n+    let _val = *xref_in_mem; //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n }"}, {"sha": "5e1118160a327d9069e5bbe3d6645630b8eefc9c", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let _val = *x; // invalidate xraw\n-    foo(xref); //~ ERROR Mut reference with non-reactivatable tag\n+    foo(xref); //~ ERROR mutable reference with non-reactivatable tag\n }"}, {"sha": "e4b26cfff6da421127e50893dd75897981797147", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -5,6 +5,6 @@ fn main() {\n     let x = &mut 42;\n     let xraw = &*x as *const _;\n     let xref = unsafe { &*xraw };\n-    let _val = *x; // invalidate xraw\n-    foo(xref); //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+    *x = 42; // invalidate xraw\n+    foo(xref); //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n }"}, {"sha": "949b3829ff8fe301a90a127f0e9d00e1e03329a2", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n     let _val = *x; // invalidate xraw and its children\n-    ret //~ ERROR Mut reference with non-reactivatable tag\n+    ret //~ ERROR mutable reference with non-reactivatable tag\n }\n \n fn main() {"}, {"sha": "2d34350359d13573ade633f46c9a095161d732d2", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -2,8 +2,8 @@\n fn foo(x: &mut (i32, i32)) -> &i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &(*xraw).1 };\n-    let _val = *x; // invalidate xraw and its children\n-    ret //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+    x.1 = 42; // invalidate xraw on the 2nd field\n+    ret //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n }\n \n fn main() {"}, {"sha": "624587932cb83ac8ff23cd256b0262bd4623d5d1", "filename": "tests/compile-fail/stacked_borrows/shared_confusion.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,3 +1,11 @@\n+// Optimization kills all the reborrows, enough to make this error go away.  There are\n+// no retags either because we don't retag immediately after a `&[mut]`; we rely on\n+// that creating a fresh reference.\n+// See `shared_confusion_opt.rs` for a variant that is caught even with optimizations.\n+// Keep this test to make sure that without optimizations, we do not have to actually\n+// use the `x_inner_shr`.\n+// compile-flags: -Zmir-opt-level=0\n+\n #![allow(unused_variables)]\n use std::cell::RefCell;\n \n@@ -9,11 +17,11 @@ fn test(r: &mut RefCell<i32>) {\n     {\n         let x_inner_shr = &*x_inner; // frozen\n         let y = &*r; // outer ref, not freezing\n-        let x_inner_shr2 = &*x_inner; // freezing again\n+        let x_inner_shr = &*x_inner; // freezing again\n     }\n     // Our old raw should be dead by now\n     unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n-    *x_inner = 12; //~ ERROR Mut reference with non-reactivatable tag\n+    *x_inner = 12; //~ ERROR reference with non-reactivatable tag\n }\n \n fn main() {"}, {"sha": "3030f5dd4001b9f696a226287d96188c42aef0ee", "filename": "tests/compile-fail/stacked_borrows/shared_confusion_opt.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,25 @@\n+// A variant of `shared_confusion.rs` that gets flagged even with optimizations.\n+\n+#![allow(unused_variables)]\n+use std::cell::RefCell;\n+\n+fn test(r: &mut RefCell<i32>) {\n+    let x = &*r; // not freezing because interior mutability\n+    let mut x_ref = x.borrow_mut();\n+    let x_inner : &mut i32 = &mut *x_ref; // Uniq reference\n+    let x_evil = x_inner as *mut _;\n+    {\n+        let x_inner_shr = &*x_inner; // frozen\n+        let _val = *x_inner_shr;\n+        let y = &*r; // outer ref, not freezing\n+        let x_inner_shr = &*x_inner; // freezing again\n+        let _val = *x_inner_shr;\n+    }\n+    // Our old raw should be dead by now\n+    unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n+    *x_inner = 12; //~ ERROR reference with non-reactivatable tag\n+}\n+\n+fn main() {\n+    test(&mut RefCell::new(0));\n+}"}, {"sha": "c092cbfe5098594ea79af8b5da8019842b270410", "filename": "tests/compile-fail/stacked_borrows/static_memory_modification.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,8 @@\n+static X: usize = 5;\n+\n+#[allow(mutable_transmutes)]\n+fn main() {\n+    let _x = unsafe {\n+        std::mem::transmute::<&usize, &mut usize>(&X) //~ ERROR mutable reference with frozen tag\n+    };\n+}"}, {"sha": "07a277a16f3aea1f79b5728d6f5cba218e1d37f1", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation detects that we are casting & to &mut and so it changes why we fail\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n static X: usize = 5;\n "}, {"sha": "73928f533cb708f9400ec1d7cf2192db03405d90", "filename": "tests/compile-fail/static_memory_modification2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation detects that we are casting & to &mut and so it changes why we fail\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n use std::mem::transmute;\n "}, {"sha": "280f34a5a0213b53fd61c75c5eb7c53dd4c84ea2", "filename": "tests/compile-fail/static_memory_modification3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // Validation detects that we are casting & to &mut and so it changes why we fail\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n use std::mem::transmute;\n "}, {"sha": "85c76f6f41f6ee33c1c268af204c6894bf7977ce", "filename": "tests/compile-fail/storage_dead_dangling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstorage_dead_dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fstorage_dead_dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstorage_dead_dangling.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n static mut LEAK: usize = 0;\n "}, {"sha": "ede0486be4130c5e065cd303eb85c5611f5f8f9c", "filename": "tests/compile-fail/transmute_fat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Ftransmute_fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Ftransmute_fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute_fat.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmiri-disable-validation\n \n fn main() {\n     #[cfg(target_pointer_width=\"64\")]"}, {"sha": "e64594d3e7eda966f43d95f3c69df72619189898", "filename": "tests/compile-fail/unaligned_ptr_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n fn main() {\n     let x = &2u16;"}, {"sha": "1112f2f33c148f23eea25143e2c2bb5360881fcc", "filename": "tests/compile-fail/unaligned_ptr_cast2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation\n \n fn main() {\n     let x = &2u16;"}, {"sha": "fca749ef9ccbdb37ffdee64749be4b187e818e3f", "filename": "tests/compile-fail/undefined_byte_read.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fundefined_byte_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fundefined_byte_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fundefined_byte_read.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,6 +1,3 @@\n-// This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n-\n fn main() {\n     let v: Vec<u8> = Vec::with_capacity(10);\n     let undef = unsafe { *v.get_unchecked(5) };"}, {"sha": "426a51faf8a372a2c24a2afb5d4f7caf5f57c7b2", "filename": "tests/compile-fail/validity/execute_memory.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fvalidity%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fvalidity%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fexecute_memory.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,8 @@\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let x = box 42;\n+    unsafe {\n+        let _f = std::mem::transmute::<Box<i32>, fn()>(x); //~ ERROR encountered a pointer, but expected a function pointer\n+    }\n+}"}, {"sha": "4989f4d3af7bdb7d432ea29263e06e84e73e1a84", "filename": "tests/compile-fail/validity/fn_ptr_offset.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fvalidity%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompile-fail%2Fvalidity%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Ffn_ptr_offset.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,10 @@\n+use std::mem;\n+\n+fn f() {}\n+\n+fn main() {\n+    let x : fn() = f;\n+    let y : *mut u8 = unsafe { mem::transmute(x) };\n+    let y = y.wrapping_offset(1);\n+    let _x : fn() = unsafe { mem::transmute(y) }; //~ ERROR encountered a potentially NULL pointer\n+}"}, {"sha": "98e3fde54e69e62415ea955c5c1354bcf40dc730", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -58,13 +58,11 @@ fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, need_fullm\n     let mut flags = Vec::new();\n     flags.push(format!(\"--sysroot {}\", sysroot.display()));\n     flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n-    flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     if opt {\n         // Optimizing too aggressivley makes UB detection harder, but test at least\n         // the default value.\n+        // FIXME: Opt level 3 ICEs during stack trace generation.\n         flags.push(\"-Zmir-opt-level=1\".to_owned());\n-    } else {\n-        flags.push(\"-Zmir-opt-level=0\".to_owned());\n     }\n \n     let mut config = compiletest::Config::default().tempdir();\n@@ -102,11 +100,8 @@ fn miri_pass(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir:\n     let mut flags = Vec::new();\n     flags.push(format!(\"--sysroot {}\", sysroot.display()));\n     flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n-    flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     if opt {\n         flags.push(\"-Zmir-opt-level=3\".to_owned());\n-    } else {\n-        flags.push(\"-Zmir-opt-level=0\".to_owned());\n     }\n \n     let mut config = compiletest::Config::default().tempdir();"}, {"sha": "8639a289363bad4560d30cf8b2c5910bfc5304f3", "filename": "tests/run-pass/deref_partially_dangling_raw.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1be4ee564eae748d79e11e9cbb1543cd045868c/tests%2Frun-pass%2Fderef_partially_dangling_raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1be4ee564eae748d79e11e9cbb1543cd045868c/tests%2Frun-pass%2Fderef_partially_dangling_raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fderef_partially_dangling_raw.rs?ref=b1be4ee564eae748d79e11e9cbb1543cd045868c", "patch": "@@ -1,9 +0,0 @@\n-// Deref a raw ptr to access a field of a large struct, where the field\n-// is allocated but not the entire struct is.\n-// For now, we want to allow this.\n-\n-fn main() {\n-    let x = (1, 1);\n-    let xptr = &x as *const _ as *const (i32, i32, i32);\n-    let _val = unsafe { (*xptr).1 };\n-}"}, {"sha": "73c33943a63ac65fa586292963f67df44e5da382", "filename": "tests/run-pass/move-undef-primval.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fmove-undef-primval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fmove-undef-primval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-undef-primval.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,6 +1,3 @@\n-// Moving around undef is not allowed by validation\n-// compile-flags: -Zmir-emit-validate=0\n-\n struct Foo {\n     _inner: i32,\n }"}, {"sha": "303e90742fc11d8186430611e00c272a8406c1c3", "filename": "tests/run-pass/packed_struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_struct.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zmir-emit-validate=0\n #![allow(dead_code)]\n #![feature(unsize, coerce_unsized)]\n "}, {"sha": "77f2902917a1c21e22be8376ce8c82a2e5950332", "filename": "tests/run-pass/recursive_static.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Frecursive_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Frecursive_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frecursive_static.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Disable validation until we figure out how to handle recursive statics.\n-// compile-flags: -Zmir-emit-validate=0\n-\n struct S(&'static S);\n static S1: S = S(&S2);\n static S2: S = S(&S1);"}, {"sha": "130eaa288ebefe433232a64bae3ebd33334fdd88", "filename": "tests/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fregions-mock-trans.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: We handle uninitialized storage here, which currently makes validation fail.\n-// compile-flags: -Zmir-emit-validate=0\n-\n //ignore-windows: Uses POSIX APIs\n \n #![feature(libc)]"}, {"sha": "dbe8ec9addacc5f88ac0b269c0ead95a54b038da", "filename": "tests/run-pass/slice-of-zero-size-elements.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b1be4ee564eae748d79e11e9cbb1543cd045868c/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1be4ee564eae748d79e11e9cbb1543cd045868c/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=b1be4ee564eae748d79e11e9cbb1543cd045868c", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -C debug-assertions\n-\n-use std::slice;\n-\n-fn foo<T>(v: &[T]) -> Option<&[T]> {\n-    let mut it = v.iter();\n-    for _ in 0..5 {\n-        let _ = it.next();\n-    }\n-    Some(it.as_slice())\n-}\n-\n-fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n-    let mut it = v.iter_mut();\n-    for _ in 0..5 {\n-        let _ = it.next();\n-    }\n-    Some(it.into_slice())\n-}\n-\n-pub fn main() {\n-    // In a slice of zero-size elements the pointer is meaningless.\n-    // Ensure iteration still works even if the pointer is at the end of the address space.\n-    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n-    assert_eq!(slice.len(), 10);\n-    assert_eq!(slice.iter().count(), 10);\n-\n-    // .nth() on the iterator should also behave correctly\n-    let mut it = slice.iter();\n-    assert!(it.nth(5).is_some());\n-    assert_eq!(it.count(), 4);\n-\n-    // Converting Iter to a slice should never have a null pointer\n-    assert!(foo(slice).is_some());\n-\n-    // Test mutable iterators as well\n-    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n-    assert_eq!(slice.len(), 10);\n-    assert_eq!(slice.iter_mut().count(), 10);\n-\n-    {\n-        let mut it = slice.iter_mut();\n-        assert!(it.nth(5).is_some());\n-        assert_eq!(it.count(), 4);\n-    }\n-\n-    assert!(foo_mut(slice).is_some())\n-}"}, {"sha": "119c9b90a05c16a601fa96e96dda8915be99d252", "filename": "tests/run-pass/slices.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fslices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fslices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslices.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,178 @@\n+// FIXME: Still investigating whether there is UB here\n+// compile-flags: -Zmiri-disable-validation\n+\n+use std::slice;\n+\n+fn slice_of_zst() {\n+    fn foo<T>(v: &[T]) -> Option<&[T]> {\n+        let mut it = v.iter();\n+        for _ in 0..5 {\n+            let _ = it.next();\n+        }\n+        Some(it.as_slice())\n+    }\n+\n+    fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n+        let mut it = v.iter_mut();\n+        for _ in 0..5 {\n+            let _ = it.next();\n+        }\n+        Some(it.into_slice())\n+    }\n+\n+    // In a slice of zero-size elements the pointer is meaningless.\n+    // Ensure iteration still works even if the pointer is at the end of the address space.\n+    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter().count(), 10);\n+\n+    // .nth() on the iterator should also behave correctly\n+    let mut it = slice.iter();\n+    assert!(it.nth(5).is_some());\n+    assert_eq!(it.count(), 4);\n+\n+    // Converting Iter to a slice should never have a null pointer\n+    assert!(foo(slice).is_some());\n+\n+    // Test mutable iterators as well\n+    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter_mut().count(), 10);\n+\n+    {\n+        let mut it = slice.iter_mut();\n+        assert!(it.nth(5).is_some());\n+        assert_eq!(it.count(), 4);\n+    }\n+\n+    assert!(foo_mut(slice).is_some())\n+}\n+\n+fn test_iter_ref_consistency() {\n+    use std::fmt::Debug;\n+\n+    fn test<T : Copy + Debug + PartialEq>(x : T) {\n+        let v : &[T] = &[x, x, x];\n+        let v_ptrs : [*const T; 3] = match v {\n+            [ref v1, ref v2, ref v3] => [v1 as *const _, v2 as *const _, v3 as *const _],\n+            _ => unreachable!()\n+        };\n+        let len = v.len();\n+\n+        // nth(i)\n+        for i in 0..len {\n+            assert_eq!(&v[i] as *const _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n+            let nth = v.iter().nth(i).unwrap();\n+            assert_eq!(nth as *const _, v_ptrs[i]);\n+        }\n+        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n+\n+        // stepping through with nth(0)\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let next = it.nth(0).unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.nth(0), None);\n+        }\n+\n+        // next()\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let next = it.next().unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n+        }\n+\n+        // next_back()\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let prev = it.next_back().unwrap();\n+                assert_eq!(prev as *const _, v_ptrs[remaining-1]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n+        }\n+    }\n+\n+    fn test_mut<T : Copy + Debug + PartialEq>(x : T) {\n+        let v : &mut [T] = &mut [x, x, x];\n+        let v_ptrs : [*mut T; 3] = match v {\n+            [ref v1, ref v2, ref v3] =>\n+              [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _],\n+            _ => unreachable!()\n+        };\n+        let len = v.len();\n+\n+        // nth(i)\n+        for i in 0..len {\n+            assert_eq!(&mut v[i] as *mut _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n+            let nth = v.iter_mut().nth(i).unwrap();\n+            assert_eq!(nth as *mut _, v_ptrs[i]);\n+        }\n+        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n+\n+        // stepping through with nth(0)\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let next = it.nth(0).unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.nth(0), None);\n+        }\n+\n+        // next()\n+        {\n+            let mut it = v.iter_mut();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let next = it.next().unwrap();\n+                assert_eq!(next as *mut _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n+        }\n+\n+        // next_back()\n+        {\n+            let mut it = v.iter_mut();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let prev = it.next_back().unwrap();\n+                assert_eq!(prev as *mut _, v_ptrs[remaining-1]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n+        }\n+    }\n+\n+    // Make sure iterators and slice patterns yield consistent addresses for various types,\n+    // including ZSTs.\n+    test(0u32);\n+    test(());\n+    test([0u32; 0]); // ZST with alignment > 0\n+    test_mut(0u32);\n+    test_mut(());\n+    test_mut([0u32; 0]); // ZST with alignment > 0\n+}\n+\n+fn main() {\n+    slice_of_zst();\n+    test_iter_ref_consistency();\n+}"}, {"sha": "cde6968a26415857edf04613638338e94b2a3493", "filename": "tests/run-pass/stacked-borrows.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -0,0 +1,27 @@\n+// Test various stacked-borrows-related things.\n+fn main() {\n+    deref_partially_dangling_raw();\n+    read_does_not_invalidate();\n+}\n+\n+// Deref a raw ptr to access a field of a large struct, where the field\n+// is allocated but not the entire struct is.\n+// For now, we want to allow this.\n+fn deref_partially_dangling_raw() {\n+    let x = (1, 1);\n+    let xptr = &x as *const _ as *const (i32, i32, i32);\n+    let _val = unsafe { (*xptr).1 };\n+}\n+\n+// Make sure that reading from an `&mut` does, like reborrowing to `&`,\n+// NOT invalidate other reborrows.\n+fn read_does_not_invalidate() {\n+    fn foo(x: &mut (i32, i32)) -> &i32 {\n+        let xraw = x as *mut (i32, i32);\n+        let ret = unsafe { &(*xraw).1 };\n+        let _val = x.1; // we just read, this does NOT invalidate the reborrows.\n+        ret\n+    }\n+\n+    foo(&mut (1, 2));\n+}"}, {"sha": "bb9e5068f91e8e5932f0cf4d422ff46b50b852df", "filename": "tests/run-pass/vecs.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/tests%2Frun-pass%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecs.rs?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -24,13 +24,45 @@ fn vec_into_iter() -> u8 {\n         .fold(0, |x, y| x + y)\n }\n \n+fn vec_into_iter_rev() -> u8 {\n+    vec![1, 2, 3, 4]\n+        .into_iter()\n+        .map(|x| x * x)\n+        .fold(0, |x, y| x + y)\n+}\n+\n fn vec_into_iter_zst() -> usize {\n     vec![[0u64; 0], [0u64; 0]]\n         .into_iter()\n+        .rev()\n+        .map(|x| x.len())\n+        .sum()\n+}\n+\n+fn vec_into_iter_rev_zst() -> usize {\n+    vec![[0u64; 0], [0u64; 0]]\n+        .into_iter()\n+        .rev()\n         .map(|x| x.len())\n         .sum()\n }\n \n+fn vec_iter_and_mut() {\n+    let mut v = vec![1,2,3,4];\n+    for i in v.iter_mut() {\n+        *i += 1;\n+    }\n+    assert_eq!(v.iter().sum::<i32>(), 2+3+4+5);\n+}\n+\n+fn vec_iter_and_mut_rev() {\n+    let mut v = vec![1,2,3,4];\n+    for i in v.iter_mut().rev() {\n+        *i += 1;\n+    }\n+    assert_eq!(v.iter().sum::<i32>(), 2+3+4+5);\n+}\n+\n fn vec_reallocate() -> Vec<u8> {\n     let mut v = vec![1, 2];\n     v.push(3);\n@@ -41,8 +73,14 @@ fn vec_reallocate() -> Vec<u8> {\n \n fn main() {\n     assert_eq!(vec_reallocate().len(), 5);\n+\n     assert_eq!(vec_into_iter(), 30);\n+    assert_eq!(vec_into_iter_rev(), 30);\n+    vec_iter_and_mut();\n     assert_eq!(vec_into_iter_zst(), 0);\n+    assert_eq!(vec_into_iter_rev_zst(), 0);\n+    vec_iter_and_mut_rev();\n+\n     assert_eq!(make_vec().capacity(), 4);\n     assert_eq!(make_vec_macro(), [1, 2]);\n     assert_eq!(make_vec_macro_repeat(), [42; 5]);"}, {"sha": "25c56d31ab56a4032e22e773d153064700091643", "filename": "xargo/build.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/xargo%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1d2877d773d65b5a89eb4173d7d3c98b1bd83187/xargo%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2Fbuild.sh?ref=1d2877d773d65b5a89eb4173d7d3c98b1bd83187", "patch": "@@ -1,3 +1,4 @@\n #!/bin/sh\n cd \"$(dirname \"$0\")\"\n-RUSTFLAGS='-Zalways-encode-mir -Zmir-emit-validate=1' xargo build\n+# The flags here should be kept in sync with `add_miri_default_args` in `src/lib.rs`.\n+RUSTFLAGS='-Zalways-encode-mir -Zmir-emit-retag -Zmir-opt-level=0' xargo build"}]}