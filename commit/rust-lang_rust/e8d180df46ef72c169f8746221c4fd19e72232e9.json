{"sha": "e8d180df46ef72c169f8746221c4fd19e72232e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZDE4MGRmNDZlZjcyYzE2OWY4NzQ2MjIxYzRmZDE5ZTcyMjMyZTk=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-06-08T07:30:28Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-06-08T08:32:15Z"}, "message": "std::io: expand the oneshot/periodic docs.\n\nExamples!\n\nFixes #14714.", "tree": {"sha": "19b3af0c22af0414f6ede831916ef8bf51a444fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b3af0c22af0414f6ede831916ef8bf51a444fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8d180df46ef72c169f8746221c4fd19e72232e9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d180df46ef72c169f8746221c4fd19e72232e9", "html_url": "https://github.com/rust-lang/rust/commit/e8d180df46ef72c169f8746221c4fd19e72232e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8d180df46ef72c169f8746221c4fd19e72232e9/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e9e484d7089590ce63bfe21723d7ee0c50be8f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9e484d7089590ce63bfe21723d7ee0c50be8f4", "html_url": "https://github.com/rust-lang/rust/commit/8e9e484d7089590ce63bfe21723d7ee0c50be8f4"}], "stats": {"total": 76, "additions": 68, "deletions": 8}, "files": [{"sha": "67b6d3c476c8c23093d752b6f1413f4a8e86cba0", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e8d180df46ef72c169f8746221c4fd19e72232e9/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d180df46ef72c169f8746221c4fd19e72232e9/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=e8d180df46ef72c169f8746221c4fd19e72232e9", "patch": "@@ -96,27 +96,87 @@ impl Timer {\n     }\n \n     /// Creates a oneshot receiver which will have a notification sent when\n-    /// `msecs` milliseconds has elapsed. This does *not* block the current\n-    /// task, but instead returns immediately.\n+    /// `msecs` milliseconds has elapsed.\n+    ///\n+    /// This does *not* block the current task, but instead returns immediately.\n     ///\n     /// Note that this invalidates any previous receiver which has been created\n     /// by this timer, and that the returned receiver will be invalidated once\n-    /// the timer is destroyed (when it falls out of scope).\n+    /// the timer is destroyed (when it falls out of scope). In particular, if\n+    /// this is called in method-chaining style, the receiver will be\n+    /// invalidated at the end of that statement, and all `recv` calls will\n+    /// fail.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::io::timer::Timer;\n+    ///\n+    /// let mut timer = Timer::new().unwrap();\n+    /// let ten_milliseconds = timer.oneshot(10);\n+    ///\n+    /// for _ in range(0, 100) { /* do work */ }\n+    ///\n+    /// // blocks until 10 ms after the `oneshot` call\n+    /// ten_milliseconds.recv();\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// use std::io::timer::Timer;\n+    ///\n+    /// // Incorrect, method chaining-style:\n+    /// let mut five_ms = Timer::new().unwrap().oneshot(5);\n+    /// // The timer object was destroyed, so this will always fail:\n+    /// // five_ms.recv()\n+    /// ```\n     pub fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n         let (tx, rx) = channel();\n         self.obj.oneshot(msecs, box TimerCallback { tx: tx });\n         return rx\n     }\n \n     /// Creates a receiver which will have a continuous stream of notifications\n-    /// being sent every `msecs` milliseconds. This does *not* block the\n-    /// current task, but instead returns immediately. The first notification\n-    /// will not be received immediately, but rather after `msec` milliseconds\n-    /// have passed.\n+    /// being sent every `msecs` milliseconds.\n+    ///\n+    /// This does *not* block the current task, but instead returns\n+    /// immediately. The first notification will not be received immediately,\n+    /// but rather after `msec` milliseconds have passed.\n     ///\n     /// Note that this invalidates any previous receiver which has been created\n     /// by this timer, and that the returned receiver will be invalidated once\n-    /// the timer is destroyed (when it falls out of scope).\n+    /// the timer is destroyed (when it falls out of scope). In particular, if\n+    /// this is called in method-chaining style, the receiver will be\n+    /// invalidated at the end of that statement, and all `recv` calls will\n+    /// fail.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::io::timer::Timer;\n+    ///\n+    /// let mut timer = Timer::new().unwrap();\n+    /// let ten_milliseconds = timer.periodic(10);\n+    ///\n+    /// for _ in range(0, 100) { /* do work */ }\n+    ///\n+    /// // blocks until 10 ms after the `periodic` call\n+    /// ten_milliseconds.recv();\n+    ///\n+    /// for _ in range(0, 100) { /* do work */ }\n+    ///\n+    /// // blocks until 20 ms after the `periodic` call (*not* 10ms after the\n+    /// // previous `recv`)\n+    /// ten_milliseconds.recv();\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// use std::io::timer::Timer;\n+    ///\n+    /// // Incorrect, method chaining-style.\n+    /// let mut five_ms = Timer::new().unwrap().periodic(5);\n+    /// // The timer object was destroyed, so this will always fail:\n+    /// // five_ms.recv()\n+    /// ```\n     pub fn periodic(&mut self, msecs: u64) -> Receiver<()> {\n         let (tx, rx) = channel();\n         self.obj.period(msecs, box TimerCallback { tx: tx });"}]}