{"sha": "9a30673d2b5a647af1e54bf852ee7503f6151f9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMzA2NzNkMmI1YTY0N2FmMWU1NGJmODUyZWU3NTAzZjYxNTFmOWY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-02-12T20:27:40Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-02-14T00:34:30Z"}, "message": "Add missing feature", "tree": {"sha": "0688038289221c2211d3e2caceafd228de0103ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0688038289221c2211d3e2caceafd228de0103ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a30673d2b5a647af1e54bf852ee7503f6151f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a30673d2b5a647af1e54bf852ee7503f6151f9f", "html_url": "https://github.com/rust-lang/rust/commit/9a30673d2b5a647af1e54bf852ee7503f6151f9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a30673d2b5a647af1e54bf852ee7503f6151f9f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "146b81c2c61507acf3910db421677186b01054be", "url": "https://api.github.com/repos/rust-lang/rust/commits/146b81c2c61507acf3910db421677186b01054be", "html_url": "https://github.com/rust-lang/rust/commit/146b81c2c61507acf3910db421677186b01054be"}], "stats": {"total": 488, "additions": 270, "deletions": 218}, "files": [{"sha": "dcadf830f1e3088435c197f513cd77f8c63d59dc", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 270, "deletions": 218, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/9a30673d2b5a647af1e54bf852ee7503f6151f9f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a30673d2b5a647af1e54bf852ee7503f6151f9f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9a30673d2b5a647af1e54bf852ee7503f6151f9f", "patch": "@@ -105,7 +105,8 @@ macro_rules! doc_comment {\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr) => {\n+    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr, $Feature:expr,\n+     $EndFeature:expr) => {\n         doc_comment! {\n             concat!(\"Returns the smallest value that can be represented by this integer type.\n \n@@ -114,7 +115,8 @@ macro_rules! int_impl {\n Basic usage:\n \n ```\n-assert_eq!(\", stringify!($SelfT), \"::min_value(), \", stringify!($Min), \");\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::min_value(), \", stringify!($Min), \");\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -131,7 +133,8 @@ assert_eq!(\", stringify!($SelfT), \"::min_value(), \", stringify!($Min), \");\n Basic usage:\n \n ```\n-assert_eq!(\", stringify!($SelfT), \"::max_value(), \", stringify!($Max), \");\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value(), \", stringify!($Max), \");\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -160,7 +163,8 @@ This function panics if `radix` is not in the range from 2 to 36.\n Basic usage:\n \n ```\n-assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n@@ -176,9 +180,10 @@ assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\n Basic usage:\n \n ```\n-let n = -0b1000_0000\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0b100_0000\", stringify!($SelfT), \";\n \n-assert_eq!(n.count_ones(), 1);\n+assert_eq!(n.count_ones(), 1);\",\n+$EndFeature, \"\n ```\n \"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -194,9 +199,7 @@ assert_eq!(n.count_ones(), 1);\n Basic usage:\n \n ```\n-let n = -0b1000_0000\", stringify!($SelfT), \";\n-\n-assert_eq!(n.count_zeros(), 7);\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -213,9 +216,10 @@ assert_eq!(n.count_zeros(), 7);\n Basic usage:\n \n ```\n-let n = -1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = -1\", stringify!($SelfT), \";\n \n-assert_eq!(n.leading_zeros(), 0);\n+assert_eq!(n.leading_zeros(), 0);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -232,9 +236,10 @@ assert_eq!(n.leading_zeros(), 0);\n Basic usage:\n \n ```\n-let n = -4\", stringify!($SelfT), \";\n+\", $Feature, \"let n = -4\", stringify!($SelfT), \";\n \n-assert_eq!(n.trailing_zeros(), 2);\n+assert_eq!(n.trailing_zeros(), 2);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -317,13 +322,14 @@ On big endian this is a no-op. On little endian the bytes are swapped.\n Basic usage:\n \n ```\n-let n = 0xA1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n \n if cfg!(target_endian = \\\"big\\\") {\n     assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\n } else {\n     assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\n-}\n+}\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -342,13 +348,14 @@ On little endian this is a no-op. On big endian the bytes are swapped.\n Basic usage:\n \n ```\n-let n = 0xA1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n \n if cfg!(target_endian = \\\"little\\\") {\n     assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\n } else {\n     assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\n-}\n+}\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -367,13 +374,14 @@ On big endian this is a no-op. On little endian the bytes are swapped.\n Basic usage:\n \n ```\n-let n = 0xA1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n \n if cfg!(target_endian = \\\"big\\\") {\n     assert_eq!(n.to_be(), n)\n } else {\n     assert_eq!(n.to_be(), n.swap_bytes())\n-}\n+}\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -392,13 +400,14 @@ On little endian this is a no-op. On big endian the bytes are swapped.\n Basic usage:\n \n ```\n-let n = 0xA1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n \n if cfg!(target_endian = \\\"little\\\") {\n     assert_eq!(n.to_le(), n)\n } else {\n     assert_eq!(n.to_le(), n.swap_bytes())\n-}\n+}\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -416,9 +425,10 @@ if overflow occurred.\n Basic usage:\n \n ```\n-assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(1), Some(\",\n-stringify!($SelfT), \"::max_value() - 1));\n-assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n+\"::max_value() - 2).checked_add(1), Some(\", stringify!($SelfT), \"::max_value() - 1));\n+assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -437,9 +447,10 @@ overflow occurred.\n Basic usage:\n \n ```\n-assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(1), Some(\",\n-stringify!($SelfT), \"::min_value() + 1));\n-assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(3), None);\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n+\"::min_value() + 2).checked_sub(1), Some(\", stringify!($SelfT), \"::min_value() + 1));\n+assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(3), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -458,9 +469,10 @@ overflow occurred.\n Basic usage:\n \n ```\n-assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(1), Some(\", stringify!($SelfT),\n-\"::max_value()));\n-assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT),\n+\"::max_value().checked_mul(1), Some(\", stringify!($SelfT), \"::max_value()));\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -479,10 +491,11 @@ or the division results in overflow.\n Basic usage:\n \n ```\n-assert_eq!((\", stringify!($SelfT), \"::min_value() + 1).checked_div(-1), Some(\",\n-stringify!($Max), \"));\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n+\"::min_value() + 1).checked_div(-1), Some(\", stringify!($Max), \"));\n assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div(-1), None);\n-assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\n+assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -504,11 +517,12 @@ assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\n assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\n-assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -529,10 +543,11 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -551,8 +566,9 @@ than or equal to the number of bits in `self`.\n Basic usage:\n \n ```\n-assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\n-assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(70), None);\n+\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\n+assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -571,8 +587,9 @@ larger than or equal to the number of bits in `self`.\n Basic usage:\n \n ```\n-assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\n-assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(70), None);\n+\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -591,10 +608,11 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(70), None);\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n@@ -616,9 +634,10 @@ bounds instead of overflowing.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n-\"::max_value());\n+\"::max_value());\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -640,9 +659,10 @@ numeric bounds instead of overflowing.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_sub(100), \", stringify!($SelfT),\n-\"::min_value());\n+\"::min_value());\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -664,11 +684,12 @@ numeric bounds instead of overflowing.\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\n-assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(11 << 23), \", stringify!($SelfT), \"::MAX);\n-assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(1 << 23), \", stringify!($SelfT), \"::MIN);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(10), \", stringify!($SelfT), \"::MAX);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($SelfT), \"::MIN);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -692,9 +713,10 @@ boundary of the type.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\n assert_eq!(\", stringify!($SelfT), \"::max_value().wrapping_add(2), \", stringify!($SelfT),\n-\"::min_value() + 1);\n+\"::min_value() + 1);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -714,9 +736,10 @@ boundary of the type.\n Basic usage:\n \n ```\n-assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\n-assert_eq!((-2i8).wrapping_sub(\", stringify!($SelfT), \"::max_value()), \",\n-stringify!($SelfT), \"::max_value());\n+\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\n+assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub(\", stringify!($SelfT), \"::max_value()), \",\n+stringify!($SelfT), \"::max_value());\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -736,8 +759,9 @@ the boundary of the type.\n Basic usage:\n \n ```\n-assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\n-assert_eq!(11i8.wrapping_mul(12), -124);\n+\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\n+assert_eq!(11i8.wrapping_mul(12), -124);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -765,8 +789,9 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\n-assert_eq!((-128i8).wrapping_div(-1), -128);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\n+assert_eq!((-128i8).wrapping_div(-1), -128);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -792,8 +817,9 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\n-assert_eq!((-128i8).wrapping_rem(-1), 0);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\n+assert_eq!((-128i8).wrapping_rem(-1), 0);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -815,9 +841,10 @@ in the type. In such a case, this function returns `MIN` itself.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\n assert_eq!(\", stringify!($SelfT), \"::min_value().wrapping_neg(), \", stringify!($SelfT),\n-\"::min_value());\n+\"::min_value());\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -840,8 +867,9 @@ instead.\n Basic usage:\n \n ```\n-assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\n-assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(64), -1);\n+\", $Feature, \"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\n+assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -866,8 +894,9 @@ instead.\n Basic usage:\n \n ```\n-assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\n-assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(64), -128);\n+\", $Feature, \"assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\n+assert_eq!((-128i16).wrapping_shr(64), -128);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -891,11 +920,12 @@ such a case, this function returns `MIN` itself.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\n assert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\n assert_eq!(\", stringify!($SelfT), \"::min_value().wrapping_abs(), \", stringify!($SelfT),\n \"::min_value());\n-assert_eq!((-128i8).wrapping_abs() as u8, 128);\n+assert_eq!((-128i8).wrapping_abs() as u8, 128);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n@@ -919,10 +949,11 @@ occur. If an overflow would have occurred then the wrapped value is returned.\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n-assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT), \"::MIN, true));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT),\n+\"::MIN, true));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -946,10 +977,11 @@ would occur. If an overflow would have occurred then the wrapped value is return\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT),\n+\"::MAX, true));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -973,8 +1005,9 @@ would occur. If an overflow would have occurred then the wrapped value is return\n Basic usage:\n \n ```\n-assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\n-assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\n+assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\",\n+$EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -1002,11 +1035,12 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\n-assert_eq!(i\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT),\n-\"::MIN, true));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT),\n+\"::MIN, true));\",\n+$EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -1034,10 +1068,11 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\",\n+$EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -1062,10 +1097,11 @@ minimum value will be returned again and `true` will be returned for an overflow\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT), \"::MIN, true));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT),\n+\"::MIN, true));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -1090,8 +1126,9 @@ masked (N-1) where N is the number of bits, and this value is then used to perfo\n Basic usage:\n \n ```\n-assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(4), (0x100, false));\n-assert_eq!(0x10i32.overflowing_shl(36), (0x100, true));\n+\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT),\".overflowing_shl(4), (0x10, false));\n+assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\",\n+$EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -1112,8 +1149,9 @@ masked (N-1) where N is the number of bits, and this value is then used to perfo\n Basic usage:\n \n ```\n-assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n-assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n+\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n+assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\",\n+$EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -1135,10 +1173,11 @@ for an overflow happening.\n Basic usage:\n \n ```\n-assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\n+\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\n assert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\n-assert_eq!((\", stringify!($SelfT), \"::min_value()).overflowing_abs(), (-\", stringify!($SelfT),\n-\"::min_value(), true));\n+assert_eq!((\", stringify!($SelfT), \"::min_value()).overflowing_abs(), (\", stringify!($SelfT),\n+\"::min_value(), true));\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n@@ -1159,9 +1198,10 @@ assert_eq!((\", stringify!($SelfT), \"::min_value()).overflowing_abs(), (-\", strin\n Basic usage:\n \n ```\n-let x: \", stringify!($SelfT), \" = 2; // or any other integer type\n+\", $Feature, \"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\n \n-assert_eq!(x.pow(4), 16);\n+assert_eq!(x.pow(4), 16);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1204,8 +1244,9 @@ stringify!($SelfT), \"::min_value()` without a panic.\n Basic usage:\n \n ```\n-assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\n-assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\n+\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\n+assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1234,9 +1275,10 @@ assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\n Basic usage:\n \n ```\n-assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\n+\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\n assert_eq!(0\", stringify!($SelfT), \".signum(), 0);\n-assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\n+assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1258,8 +1300,9 @@ negative.\n Basic usage:\n \n ```\n-assert!(10\", stringify!($SelfT), \".is_positive());\n-assert!(!(-10\", stringify!($SelfT), \").is_positive());\n+\", $Feature, \"assert!(10\", stringify!($SelfT), \".is_positive());\n+assert!(!(-10\", stringify!($SelfT), \").is_positive());\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1275,8 +1318,9 @@ positive.\n Basic usage:\n \n ```\n-assert!((-10\", stringify!($SelfT), \").is_negative());\n-assert!(!10\", stringify!($SelfT), \".is_negative());\n+\", $Feature, \"assert!((-10\", stringify!($SelfT), \").is_negative());\n+assert!(!10\", stringify!($SelfT), \".is_negative());\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1287,51 +1331,55 @@ assert!(!10\", stringify!($SelfT), \".is_negative());\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, i8, u8, 8, -128, 127 }\n+    int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16, i16, u16, 16, -32768, 32767 }\n+    int_impl! { i16, i16, u16, 16, -32768, 32767, \"\", \"\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647 }\n+    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, \"\", \"\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807 }\n+    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\" }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n     int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n-        170141183460469231731687303715884105727 }\n+        170141183460469231731687303715884105727, \"#![feature(i128_type)]\n+#![feature(i128)]\n+# fn main() {\n+\", \"\n+# }\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i16, u16, 16 }\n+    int_impl! { isize, i16, u16, 16, \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i32, u32, 32 }\n+    int_impl! { isize, i32, u32, 32, \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807 }\n+    int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\" }\n }\n \n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n-    ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr) => {\n+    ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr) => {\n         doc_comment! {\n             concat!(\"Returns the smallest value that can be represented by this integer type.\n \n@@ -1340,7 +1388,7 @@ macro_rules! uint_impl {\n Basic usage:\n \n ```\n-assert_eq!(\", stringify!($SelfT), \"::min_value(), 0);\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::min_value(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1355,7 +1403,8 @@ assert_eq!(\", stringify!($SelfT), \"::min_value(), 0);\n Basic usage:\n \n ```\n-assert_eq!(\", stringify!($SelfT), \"::max_value(), \", stringify!($MaxV), \");\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value(), \",\n+stringify!($MaxV), \");\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1383,7 +1432,8 @@ This function panics if `radix` is not in the range from 2 to 36.\n Basic usage:\n \n ```\n-assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n@@ -1399,9 +1449,9 @@ assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\n Basic usage:\n \n ```\n-let n = 0b01001100\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0b01001100\", stringify!($SelfT), \";\n \n-assert_eq!(n.count_ones(), 3);\n+assert_eq!(n.count_ones(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1418,9 +1468,7 @@ assert_eq!(n.count_ones(), 3);\n Basic usage:\n \n ```\n-let n = 0b01001100\", stringify!($SelfT), \";\n-\n-assert_eq!(n.count_zeros(), 5);\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1456,9 +1504,9 @@ of `self`.\n Basic usage:\n \n ```\n-let n = 0b0101000\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0b0101000\", stringify!($SelfT), \";\n \n-assert_eq!(n.trailing_zeros(), 3);\n+assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1559,13 +1607,13 @@ swapped.\n Basic usage:\n \n ```\n-let n = 0xA1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n \n if cfg!(target_endian = \\\"big\\\") {\n     assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\n } else {\n     assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\n-}\n+}\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1585,13 +1633,13 @@ swapped.\n Basic usage:\n \n ```\n-let n = 0xA1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n \n if cfg!(target_endian = \\\"little\\\") {\n-    assert_eq!(u64::from_le(n), n)\n+    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\n } else {\n-    assert_eq!(u64::from_le(n), n.swap_bytes())\n-}\n+    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\n+}\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1611,13 +1659,13 @@ swapped.\n Basic usage:\n \n ```\n-let n = 0xA1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n \n if cfg!(target_endian = \\\"big\\\") {\n     assert_eq!(n.to_be(), n)\n } else {\n     assert_eq!(n.to_be(), n.swap_bytes())\n-}\n+}\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1637,13 +1685,13 @@ swapped.\n Basic usage:\n \n ```\n-let n = 0xA1\", stringify!($SelfT), \";\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n \n if cfg!(target_endian = \\\"little\\\") {\n     assert_eq!(n.to_le(), n)\n } else {\n     assert_eq!(n.to_le(), n.swap_bytes())\n-}\n+}\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1661,9 +1709,9 @@ if overflow occurred.\n Basic usage:\n \n ```\n-assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(1), \",\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(1), \",\n \"Some(\", stringify!($SelfT), \"::max_value() - 1));\n-assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3),None);\n+assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3),None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1682,8 +1730,8 @@ assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3),None);\n Basic usage:\n \n ```\n-assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\n-assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\n+\", $Feature, \"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\n+assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1702,8 +1750,8 @@ assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\n Basic usage:\n \n ```\n-assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\n-assert_eq!(5\", stringify!($SelfT), \".checked_mul(2), None);\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1722,8 +1770,8 @@ if `rhs == 0`.\n Basic usage:\n \n ```\n-assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\n-assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\n+\", $Feature, \"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\n+assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1744,8 +1792,8 @@ if `rhs == 0`.\n Basic usage:\n \n ```\n-assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\n-assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -1769,8 +1817,8 @@ Note that negating any positive integer will overflow.\n Basic usage:\n \n ```\n-assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\n-assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\n+\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\n+assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -1789,8 +1837,8 @@ if `rhs` is larger than or equal to the number of bits in `self`.\n Basic usage:\n \n ```\n-assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(4), Some(0x100));\n-assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\n+\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -1809,8 +1857,8 @@ if `rhs` is larger than or equal to the number of bits in `self`.\n Basic usage:\n \n ```\n-assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\n-assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\n+\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -1829,8 +1877,8 @@ the numeric bounds instead of overflowing.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n-assert_eq!(200\", stringify!($SelfT), \".saturating_add(127), 255);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1851,8 +1899,8 @@ at the numeric bounds instead of overflowing.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\n-assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\n+assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1873,11 +1921,11 @@ saturating at the numeric bounds instead of overflowing.\n Basic usage:\n \n ```\n-use std::\", stringify!($SelfT), \";\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n-assert_eq!(100\", stringify!($SelfT), \".saturating_mul(127), 12700);\n-assert_eq!((1\", stringify!($SelfT), \" << 23).saturating_mul(1 << 23), \", stringify!($SelfT),\n-\"::MAX);\n+assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\n+assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\n+\"::MAX);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n             #[inline]\n@@ -1895,8 +1943,9 @@ wrapping around at the boundary of the type.\n Basic usage:\n \n ```\n-assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\n-assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::max_value()), 199);\n+\", $Feature, \"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\n+assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::max_value()), 199);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1916,8 +1965,9 @@ wrapping around at the boundary of the type.\n Basic usage:\n \n ```\n-assert_eq!(100u8.wrapping_sub(100), 0);\n-assert_eq!(100u8.wrapping_sub(\", stringify!($SelfT), \"::max_value()), 101);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::max_value()), 101);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -1959,7 +2009,7 @@ are accounted for in the wrapping operations.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -1981,7 +2031,7 @@ are accounted for in the wrapping operations.\n Basic usage:\n \n ```\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -1990,35 +2040,28 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\n             }\n         }\n \n-        doc_comment! {\n-            concat!(\"Wrapping (modular) negation. Computes `-self`,\n-wrapping around at the boundary of the type.\n-\n-Since unsigned types do not have negative equivalents\n-all applications of this function will wrap (except for `-0`).\n-For values smaller than the corresponding signed type's maximum\n-the result is the same as casting the corresponding signed value.\n-Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n-`MAX` is the corresponding signed type's maximum.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), \", stringify!($SelfT),\n-\"::max_value() - 100 + 1);\n-assert_eq!(0\", stringify!($SelfT), \".wrapping_neg(), 0);\n-assert_eq!(180\", stringify!($SelfT), \".wrapping_neg(), \", stringify!($SelfT),\n-\"::max_value() - 180 + 1);\n-assert_eq!(180\", stringify!($SelfT), \".wrapping_neg(), (\", stringify!($SelfT), \"::max_value() / 2\",\n-\"+ 1) - (180\", stringify!($SelfT), \" - (\", stringify!($SelfT), \"::max_value() / 2 + 1)));\n-```\"),\n-            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-            #[inline]\n-            pub fn wrapping_neg(self) -> Self {\n-                self.overflowing_neg().0\n-            }\n+        /// Wrapping (modular) negation. Computes `-self`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// Since unsigned types do not have negative equivalents\n+        /// all applications of this function will wrap (except for `-0`).\n+        /// For values smaller than the corresponding signed type's maximum\n+        /// the result is the same as casting the corresponding signed value.\n+        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n+        /// `MAX` is the corresponding signed type's maximum.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.wrapping_neg(), -100);\n+        /// assert_eq!((-128i8).wrapping_neg(), -128);\n+        /// ```\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline]\n+        pub fn wrapping_neg(self) -> Self {\n+            self.overflowing_neg().0\n         }\n \n         doc_comment! {\n@@ -2038,8 +2081,8 @@ be what you want instead.\n Basic usage:\n \n ```\n-assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\n-assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(\", stringify!($BITS), \"), 1);\n+\", $Feature, \"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\n+assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -2067,8 +2110,8 @@ be what you want instead.\n Basic usage:\n \n ```\n-assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\n-assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(\", stringify!($BITS), \"), 128);\n+\", $Feature, \"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\n+assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n             #[inline]\n@@ -2091,10 +2134,10 @@ have occurred then the wrapped value is returned.\n Basic usage\n \n ```\n-use std::u32;\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n-assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -2119,10 +2162,11 @@ have occurred then the wrapped value is returned.\n Basic usage\n \n ```\n-use std::u32;\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\n-assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\n+assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\",\n+$EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -2176,7 +2220,7 @@ This function will panic if `rhs` is 0.\n Basic usage\n \n ```\n-assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -2202,7 +2246,7 @@ This function will panic if `rhs` is 0.\n Basic usage\n \n ```\n-assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -2224,8 +2268,9 @@ not overflow.\n Basic usage\n \n ```\n-assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\n-assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\n+\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\n+assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT),\n+\", true));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -2248,8 +2293,8 @@ used to perform the shift.\n Basic usage\n \n ```\n-assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(4), (0x100, false));\n-assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(132), (0x100, true));\n+\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\n+assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -2272,8 +2317,8 @@ used to perform the shift.\n Basic usage\n \n ```\n-assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n-assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\n+\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n+assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n@@ -2291,7 +2336,7 @@ assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\n Basic usage:\n \n ```\n-assert_eq!(2\", stringify!($SelfT), \".pow(4), 16);\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(4), 16);\", $EndFeature, \"\n ```\"),\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -2327,8 +2372,8 @@ assert_eq!(2\", stringify!($SelfT), \".pow(4), 16);\n Basic usage:\n \n ```\n-assert!(16\", stringify!($SelfT), \".is_power_of_two());\n-assert!(!10\", stringify!($SelfT), \".is_power_of_two());\n+\", $Feature, \"assert!(16\", stringify!($SelfT), \".is_power_of_two());\n+assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -2371,8 +2416,8 @@ release mode (the only situation in which method can return 0).\n Basic usage:\n \n ```\n-assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\n-assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\n+assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n@@ -2392,9 +2437,11 @@ the next power of two is greater than the type's maximum value,\n Basic usage:\n \n ```\n-assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT),\n+\".checked_next_power_of_two(), Some(2));\n assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\n-assert_eq!(\", stringify!($SelfT), \"::max_value().checked_next_power_of_two(), None);\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_next_power_of_two(), None);\",\n+$EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             pub fn checked_next_power_of_two(self) -> Option<Self> {\n@@ -2406,7 +2453,7 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().checked_next_power_of_two(), No\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, u8, 8, 255 }\n+    uint_impl! { u8, u8, 8, 255, \"\", \"\" }\n \n \n     /// Checks if the value is within the ASCII range.\n@@ -2952,39 +2999,44 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, u16, 16, 65535 }\n+    uint_impl! { u16, u16, 16, 65535, \"\", \"\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, u32, 32, 4294967295 }\n+    uint_impl! { u32, u32, 32, 4294967295, \"\", \"\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, u64, 64, 18446744073709551615 }\n+    uint_impl! { u64, u64, 64, 18446744073709551615, \"\", \"\" }\n }\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455 }\n+    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"#![feature(i128_type)]\n+#![feature(i128)]\n+\n+# fn main() {\n+\", \"\n+# }\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u16, 16, 65536 }\n+    uint_impl! { usize, u16, 16, 65536, \"\", \"\" }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u32, 32, 4294967295 }\n+    uint_impl! { usize, u32, 32, 4294967295, \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u64, 64, 18446744073709551615 }\n+    uint_impl! { usize, u64, 64, 18446744073709551615, \"\", \"\" }\n }\n \n /// A classification of floating point numbers."}]}