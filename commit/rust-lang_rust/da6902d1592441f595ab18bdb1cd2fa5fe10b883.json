{"sha": "da6902d1592441f595ab18bdb1cd2fa5fe10b883", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNjkwMmQxNTkyNDQxZjU5NWFiMThiZGIxY2QyZmE1ZmUxMGI4ODM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-20T14:18:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-20T14:18:51Z"}, "message": "Merge #8601\n\n8601: Trigger \"Inline variable\" assist when on a use of the variable r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8530\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "eadeed71f9ed72065647b9c5657eb2cdf611b46c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eadeed71f9ed72065647b9c5657eb2cdf611b46c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da6902d1592441f595ab18bdb1cd2fa5fe10b883", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgfuLLCRBK7hj4Ov3rIwAAo9MIAB4WiBCK4lFaWJbwgKynyRwQ\nhcR3id1wpyrgpWhfYukTpPBCVLmi0vjT6UfSwv+keUR7yHd6mwfjZuaduQwcPrRj\nff6dTA5pQl4FTeFQKJ/ghN7FwCQYvI2FfSRL9Pqe1b3N/NV5iLQJGILp9xxDNL0f\n7JSsFW5IVCd1LnM7Vbf8e9rcWuvOKPyV3ItGB9otC2vsCcFoJDN2CkbT7C0Zg/wA\nbBymug7CUe5/i74n2Pj0TsZd8ezQFi3NfNaj/ozN9ar58fOZBTnPIZvx9hdiu1Hb\nhUOF4xGPJdOEPwavm03SinyxDxIVD8dLof4WFfrfXmNxd2/ySSptVWSrsHBH9bg=\n=L2TS\n-----END PGP SIGNATURE-----\n", "payload": "tree eadeed71f9ed72065647b9c5657eb2cdf611b46c\nparent 1834938d6f37c0d308e407e50514180d0f08d96f\nparent d699371f5ffe34801e002c80bbb3f75905b65ec8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618928331 +0000\ncommitter GitHub <noreply@github.com> 1618928331 +0000\n\nMerge #8601\n\n8601: Trigger \"Inline variable\" assist when on a use of the variable r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8530\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da6902d1592441f595ab18bdb1cd2fa5fe10b883", "html_url": "https://github.com/rust-lang/rust/commit/da6902d1592441f595ab18bdb1cd2fa5fe10b883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da6902d1592441f595ab18bdb1cd2fa5fe10b883/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1834938d6f37c0d308e407e50514180d0f08d96f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1834938d6f37c0d308e407e50514180d0f08d96f", "html_url": "https://github.com/rust-lang/rust/commit/1834938d6f37c0d308e407e50514180d0f08d96f"}, {"sha": "d699371f5ffe34801e002c80bbb3f75905b65ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d699371f5ffe34801e002c80bbb3f75905b65ec8", "html_url": "https://github.com/rust-lang/rust/commit/d699371f5ffe34801e002c80bbb3f75905b65ec8"}], "stats": {"total": 223, "additions": 185, "deletions": 38}, "files": [{"sha": "f5dafc8cb1fd8e05d84d2a347917fcfdf61024a6", "filename": "crates/ide_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 185, "deletions": 38, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/da6902d1592441f595ab18bdb1cd2fa5fe10b883/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6902d1592441f595ab18bdb1cd2fa5fe10b883/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=da6902d1592441f595ab18bdb1cd2fa5fe10b883", "patch": "@@ -1,7 +1,9 @@\n-use ide_db::{defs::Definition, search::FileReference};\n+use either::Either;\n+use hir::PathResolution;\n+use ide_db::{base_db::FileId, defs::Definition, search::FileReference};\n use rustc_hash::FxHashMap;\n use syntax::{\n-    ast::{self, AstNode, AstToken},\n+    ast::{self, AstNode, AstToken, NameOwner},\n     TextRange,\n };\n \n@@ -27,44 +29,28 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n-    let bind_pat = match let_stmt.pat()? {\n-        ast::Pat::IdentPat(pat) => pat,\n-        _ => return None,\n-    };\n-    if bind_pat.mut_token().is_some() {\n-        cov_mark::hit!(test_not_inline_mut_variable);\n-        return None;\n-    }\n-    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n-        cov_mark::hit!(not_applicable_outside_of_bind_pat);\n-        return None;\n-    }\n+    let InlineData { let_stmt, delete_let, replace_usages, target } =\n+        inline_let(ctx).or_else(|| inline_usage(ctx))?;\n     let initializer_expr = let_stmt.initializer()?;\n \n-    let def = ctx.sema.to_def(&bind_pat)?;\n-    let def = Definition::Local(def);\n-    let usages = def.usages(&ctx.sema).all();\n-    if usages.is_empty() {\n-        cov_mark::hit!(test_not_applicable_if_variable_unused);\n-        return None;\n-    };\n-\n-    let delete_range = if let Some(whitespace) = let_stmt\n-        .syntax()\n-        .next_sibling_or_token()\n-        .and_then(|it| ast::Whitespace::cast(it.as_token()?.clone()))\n-    {\n-        TextRange::new(\n-            let_stmt.syntax().text_range().start(),\n-            whitespace.syntax().text_range().end(),\n-        )\n+    let delete_range = if delete_let {\n+        if let Some(whitespace) = let_stmt\n+            .syntax()\n+            .next_sibling_or_token()\n+            .and_then(|it| ast::Whitespace::cast(it.as_token()?.clone()))\n+        {\n+            Some(TextRange::new(\n+                let_stmt.syntax().text_range().start(),\n+                whitespace.syntax().text_range().end(),\n+            ))\n+        } else {\n+            Some(let_stmt.syntax().text_range())\n+        }\n     } else {\n-        let_stmt.syntax().text_range()\n+        None\n     };\n \n-    let wrap_in_parens = usages\n-        .references\n+    let wrap_in_parens = replace_usages\n         .iter()\n         .map(|(&file_id, refs)| {\n             refs.iter()\n@@ -114,14 +100,20 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n \n-    let target = bind_pat.syntax().text_range();\n+    let target = match target {\n+        ast::NameOrNameRef::Name(it) => it.syntax().text_range(),\n+        ast::NameOrNameRef::NameRef(it) => it.syntax().text_range(),\n+    };\n+\n     acc.add(\n         AssistId(\"inline_local_variable\", AssistKind::RefactorInline),\n         \"Inline variable\",\n         target,\n         move |builder| {\n-            builder.delete(delete_range);\n-            for (file_id, references) in usages.references {\n+            if let Some(range) = delete_range {\n+                builder.delete(range);\n+            }\n+            for (file_id, references) in replace_usages {\n                 for (&should_wrap, reference) in wrap_in_parens[&file_id].iter().zip(references) {\n                     let replacement =\n                         if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n@@ -140,6 +132,81 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n     )\n }\n \n+struct InlineData {\n+    let_stmt: ast::LetStmt,\n+    delete_let: bool,\n+    target: ast::NameOrNameRef,\n+    replace_usages: FxHashMap<FileId, Vec<FileReference>>,\n+}\n+\n+fn inline_let(ctx: &AssistContext) -> Option<InlineData> {\n+    let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n+    let bind_pat = match let_stmt.pat()? {\n+        ast::Pat::IdentPat(pat) => pat,\n+        _ => return None,\n+    };\n+    if bind_pat.mut_token().is_some() {\n+        cov_mark::hit!(test_not_inline_mut_variable);\n+        return None;\n+    }\n+    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n+        cov_mark::hit!(not_applicable_outside_of_bind_pat);\n+        return None;\n+    }\n+\n+    let def = ctx.sema.to_def(&bind_pat)?;\n+    let def = Definition::Local(def);\n+    let usages = def.usages(&ctx.sema).all();\n+    if usages.is_empty() {\n+        cov_mark::hit!(test_not_applicable_if_variable_unused);\n+        return None;\n+    };\n+\n+    Some(InlineData {\n+        let_stmt,\n+        delete_let: true,\n+        target: ast::NameOrNameRef::Name(bind_pat.name()?),\n+        replace_usages: usages.references,\n+    })\n+}\n+\n+fn inline_usage(ctx: &AssistContext) -> Option<InlineData> {\n+    let path_expr = ctx.find_node_at_offset::<ast::PathExpr>()?;\n+    let path = path_expr.path()?;\n+    let name = match path.as_single_segment()?.kind()? {\n+        ast::PathSegmentKind::Name(name) => name,\n+        _ => return None,\n+    };\n+\n+    let local = match ctx.sema.resolve_path(&path)? {\n+        PathResolution::Local(local) => local,\n+        _ => return None,\n+    };\n+\n+    let bind_pat = match local.source(ctx.db()).value {\n+        Either::Left(ident) => ident,\n+        _ => return None,\n+    };\n+\n+    let let_stmt = ast::LetStmt::cast(bind_pat.syntax().parent()?)?;\n+\n+    let def = Definition::Local(local);\n+    let mut usages = def.usages(&ctx.sema).all();\n+\n+    let delete_let = usages.references.values().map(|v| v.len()).sum::<usize>() == 1;\n+\n+    for references in usages.references.values_mut() {\n+        references.retain(|reference| reference.name.as_name_ref() == Some(&name));\n+    }\n+\n+    Some(InlineData {\n+        let_stmt,\n+        delete_let,\n+        target: ast::NameOrNameRef::NameRef(name),\n+        replace_usages: usages.references,\n+    })\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -726,4 +793,84 @@ fn main() {\n \",\n         )\n     }\n+\n+    #[test]\n+    fn works_on_local_usage() {\n+        check_assist(\n+            inline_local_variable,\n+            r#\"\n+fn f() {\n+    let xyz = 0;\n+    xyz$0;\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_remove_let_when_multiple_usages() {\n+        check_assist(\n+            inline_local_variable,\n+            r#\"\n+fn f() {\n+    let xyz = 0;\n+    xyz$0;\n+    xyz;\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    let xyz = 0;\n+    0;\n+    xyz;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_with_non_ident_pattern() {\n+        check_assist_not_applicable(\n+            inline_local_variable,\n+            r#\"\n+fn main() {\n+    let (x, y) = (0, 1);\n+    x$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_on_local_usage_in_macro() {\n+        check_assist_not_applicable(\n+            inline_local_variable,\n+            r#\"\n+macro_rules! m {\n+    ($i:ident) => { $i }\n+}\n+fn f() {\n+    let xyz = 0;\n+    m!(xyz$0); // replacing it would break the macro\n+}\n+\"#,\n+        );\n+        check_assist_not_applicable(\n+            inline_local_variable,\n+            r#\"\n+macro_rules! m {\n+    ($i:ident) => { $i }\n+}\n+fn f() {\n+    let xyz$0 = 0;\n+    m!(xyz); // replacing it would break the macro\n+}\n+\"#,\n+        );\n+    }\n }"}]}