{"sha": "27e8a95717c9f807ea1b4fc0e85da6813433011e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZThhOTU3MTdjOWY4MDdlYTFiNGZjMGU4NWRhNjgxMzQzMzAxMWU=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-19T17:31:17Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-26T08:22:46Z"}, "message": "Generalise Query starting.", "tree": {"sha": "f4f3c94a4cf93bdff2fb5dc3593332e589cf4542", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4f3c94a4cf93bdff2fb5dc3593332e589cf4542"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27e8a95717c9f807ea1b4fc0e85da6813433011e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27e8a95717c9f807ea1b4fc0e85da6813433011e", "html_url": "https://github.com/rust-lang/rust/commit/27e8a95717c9f807ea1b4fc0e85da6813433011e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27e8a95717c9f807ea1b4fc0e85da6813433011e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ac4ccd727e8eaccae1e58b303347e7991f4d355", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac4ccd727e8eaccae1e58b303347e7991f4d355", "html_url": "https://github.com/rust-lang/rust/commit/4ac4ccd727e8eaccae1e58b303347e7991f4d355"}], "stats": {"total": 198, "additions": 122, "deletions": 76}, "files": [{"sha": "556b1479b613a2afd8f86a110bd9df73b3dc7905", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27e8a95717c9f807ea1b4fc0e85da6813433011e/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e8a95717c9f807ea1b4fc0e85da6813433011e/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=27e8a95717c9f807ea1b4fc0e85da6813433011e", "patch": "@@ -166,6 +166,10 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         self.queries.on_disk_cache.store_diagnostics(dep_node_index, diagnostics)\n     }\n \n+    fn store_diagnostics_for_anon_node(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n+        self.queries.on_disk_cache.store_diagnostics_for_anon_node(dep_node_index, diagnostics)\n+    }\n+\n     fn profiler(&self) -> &SelfProfilerRef {\n         &self.prof\n     }"}, {"sha": "91e82858b0b5a7c0ca86c92289c59d5a29f12426", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/27e8a95717c9f807ea1b4fc0e85da6813433011e/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e8a95717c9f807ea1b4fc0e85da6813433011e/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=27e8a95717c9f807ea1b4fc0e85da6813433011e", "patch": "@@ -11,7 +11,10 @@ use rustc_hir::def_id::DefId;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::HashStable;\n-use rustc_query_system::dep_graph::{DepContext, DepNode};\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::Diagnostic;\n+use rustc_query_system::dep_graph::{DepContext, DepGraph, DepNode};\n use rustc_session::Session;\n use std::borrow::Cow;\n use std::fmt::Debug;\n@@ -34,12 +37,25 @@ pub trait QueryContext: DepContext {\n     /// Get string representation from DefPath.\n     fn def_path_str(&self, def_id: DefId) -> String;\n \n+    /// Access the DepGraph.\n+    fn dep_graph(&self) -> &DepGraph<Self::DepKind>;\n+\n     /// Get the query information from the TLS context.\n     fn read_query_job<R>(&self, op: impl FnOnce(Option<QueryJobId<Self::DepKind>>) -> R) -> R;\n \n     fn try_collect_active_jobs(\n         &self,\n     ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>>;\n+\n+    /// Executes a job by changing the `ImplicitCtxt` to point to the\n+    /// new query job while it executes. It returns the diagnostics\n+    /// captured during execution and the actual result.\n+    fn start_query<R>(\n+        &self,\n+        token: QueryJobId<Self::DepKind>,\n+        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n+        compute: impl FnOnce(Self) -> R,\n+    ) -> R;\n }\n \n pub(crate) trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {"}, {"sha": "ae0ca080dac56f42111c9ca5212cce170734dd95", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 97, "deletions": 74, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/27e8a95717c9f807ea1b4fc0e85da6813433011e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e8a95717c9f807ea1b4fc0e85da6813433011e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=27e8a95717c9f807ea1b4fc0e85da6813433011e", "patch": "@@ -7,7 +7,7 @@ use crate::ty::query::caches::QueryCache;\n use crate::ty::query::config::{QueryContext, QueryDescription};\n use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n use crate::ty::query::Query;\n-use crate::ty::tls;\n+use crate::ty::tls::{self, ImplicitCtxt};\n use crate::ty::{self, TyCtxt};\n \n #[cfg(not(parallel_compiler))]\n@@ -17,7 +17,8 @@ use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, FatalError, Handler, Level};\n-use rustc_query_system::dep_graph::{DepKind, DepNode};\n+use rustc_query_system::dep_graph::{DepContext, DepGraph, DepKind, DepNode};\n+use rustc_query_system::HashStableContextProvider;\n use rustc_session::Session;\n use rustc_span::def_id::DefId;\n use rustc_span::source_map::DUMMY_SP;\n@@ -364,6 +365,10 @@ impl QueryContext for TyCtxt<'tcx> {\n         TyCtxt::def_path_str(*self, def_id)\n     }\n \n+    fn dep_graph(&self) -> &DepGraph<Self::DepKind> {\n+        &self.dep_graph\n+    }\n+\n     fn read_query_job<R>(&self, op: impl FnOnce(Option<QueryJobId<Self::DepKind>>) -> R) -> R {\n         tls::with_related_context(*self, move |icx| op(icx.query))\n     }\n@@ -373,40 +378,37 @@ impl QueryContext for TyCtxt<'tcx> {\n     ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>> {\n         self.queries.try_collect_active_jobs()\n     }\n-}\n \n-impl<'tcx> TyCtxt<'tcx> {\n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     #[inline(always)]\n-    fn start_query<F, R>(\n-        self,\n-        token: QueryJobId<crate::dep_graph::DepKind>,\n+    fn start_query<R>(\n+        &self,\n+        token: QueryJobId<Self::DepKind>,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: F,\n-    ) -> R\n-    where\n-        F: FnOnce(TyCtxt<'tcx>) -> R,\n-    {\n+        compute: impl FnOnce(Self) -> R,\n+    ) -> R {\n         // The `TyCtxt` stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n         // when accessing the `ImplicitCtxt`.\n-        tls::with_related_context(self, move |current_icx| {\n+        tls::with_related_context(*self, move |current_icx| {\n             // Update the `ImplicitCtxt` to point to our new query job.\n-            let new_icx = tls::ImplicitCtxt {\n-                tcx: self,\n+            let new_icx = ImplicitCtxt {\n+                tcx: *self,\n                 query: Some(token),\n                 diagnostics,\n                 layout_depth: current_icx.layout_depth,\n                 task_deps: current_icx.task_deps,\n             };\n \n             // Use the `ImplicitCtxt` while we execute the query.\n-            tls::enter_context(&new_icx, |_| compute(self))\n+            tls::enter_context(&new_icx, |_| compute(*self))\n         })\n     }\n+}\n \n+impl<'tcx> TyCtxt<'tcx> {\n     #[inline(never)]\n     #[cold]\n     pub(super) fn report_cycle(\n@@ -552,74 +554,80 @@ impl<'tcx> TyCtxt<'tcx> {\n                 self.dep_graph.read_index(index);\n                 value.clone()\n             },\n-            |key, lookup| self.try_execute_query::<Q>(span, key, lookup),\n+            |key, lookup| try_execute_query::<Q, _, _>(self, span, key, lookup),\n         )\n     }\n+}\n \n     #[inline(always)]\n-    fn try_execute_query<Q: QueryDescription<TyCtxt<'tcx>> + 'tcx>(\n-        self,\n+    fn try_execute_query<Q, CTX, K>(\n+        tcx: CTX,\n         span: Span,\n         key: Q::Key,\n         lookup: QueryLookup<\n             '_,\n-            TyCtxt<'tcx>,\n+            CTX,\n             Q::Key,\n-            <Q::Cache as QueryCache<TyCtxt<'tcx>>>::Sharded,\n+            <Q::Cache as QueryCache<CTX>>::Sharded,\n         >,\n-    ) -> Q::Value {\n-        let job = match JobOwner::try_start::<Q, _>(self, span, &key, lookup) {\n+    ) -> Q::Value\n+    where\n+        Q: QueryDescription<CTX>,\n+        CTX: QueryContext<DepKind = K>,\n+        CTX: HashStableContextProvider<<CTX as DepContext>::StableHashingContext>,\n+        K: DepKind,\n+    {\n+        let job = match JobOwner::try_start::<Q, _>(tcx, span, &key, lookup) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(result) => return result,\n             #[cfg(parallel_compiler)]\n             TryGetJob::JobCompleted((v, index)) => {\n-                self.dep_graph.read_index(index);\n+                tcx.dep_graph().read_index(index);\n                 return v;\n             }\n         };\n \n         // Fast path for when incr. comp. is off. `to_dep_node` is\n         // expensive for some `DepKind`s.\n-        if !self.dep_graph.is_fully_enabled() {\n+        if !tcx.dep_graph().is_fully_enabled() {\n             let null_dep_node = DepNode::new_no_params(DepKind::NULL);\n-            return self.force_query_with_job::<Q>(key, job, null_dep_node).0;\n+            return force_query_with_job::<Q, _, _>(tcx, key, job, null_dep_node).0;\n         }\n \n         if Q::ANON {\n-            let prof_timer = self.prof.query_provider();\n+            let prof_timer = tcx.profiler().query_provider();\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-                self.start_query(job.id, diagnostics, |tcx| {\n-                    tcx.dep_graph.with_anon_task(Q::DEP_KIND, || Q::compute(tcx, key))\n+                tcx.start_query(job.id, diagnostics, |tcx| {\n+                    tcx.dep_graph().with_anon_task(Q::DEP_KIND, || Q::compute(tcx, key))\n                 })\n             });\n \n             prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-            self.dep_graph.read_index(dep_node_index);\n+            tcx.dep_graph().read_index(dep_node_index);\n \n             if unlikely!(!diagnostics.is_empty()) {\n-                self.queries\n-                    .on_disk_cache\n-                    .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+                tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n             }\n \n-            job.complete(self, &result, dep_node_index);\n+            job.complete(tcx, &result, dep_node_index);\n \n             return result;\n         }\n \n-        let dep_node = Q::to_dep_node(self, &key);\n+        let dep_node = Q::to_dep_node(tcx, &key);\n \n         if !Q::EVAL_ALWAYS {\n             // The diagnostics for this query will be\n             // promoted to the current session during\n             // `try_mark_green()`, so we can ignore them here.\n-            let loaded = self.start_query(job.id, None, |tcx| {\n-                let marked = tcx.dep_graph.try_mark_green_and_read(tcx, &dep_node);\n+            let loaded = tcx.start_query(job.id, None, |tcx| {\n+                let marked = tcx.dep_graph().try_mark_green_and_read(tcx, &dep_node);\n                 marked.map(|(prev_dep_node_index, dep_node_index)| {\n                     (\n-                        tcx.load_from_disk_and_cache_in_memory::<Q>(\n+                        load_from_disk_and_cache_in_memory::<Q, _>(\n+                            tcx,\n                             key.clone(),\n                             prev_dep_node_index,\n                             dep_node_index,\n@@ -630,32 +638,36 @@ impl<'tcx> TyCtxt<'tcx> {\n                 })\n             });\n             if let Some((result, dep_node_index)) = loaded {\n-                job.complete(self, &result, dep_node_index);\n+                job.complete(tcx, &result, dep_node_index);\n                 return result;\n             }\n         }\n \n-        let (result, dep_node_index) = self.force_query_with_job::<Q>(key, job, dep_node);\n-        self.dep_graph.read_index(dep_node_index);\n+        let (result, dep_node_index) = force_query_with_job::<Q, _, _>(tcx, key, job, dep_node);\n+        tcx.dep_graph().read_index(dep_node_index);\n         result\n     }\n \n-    fn load_from_disk_and_cache_in_memory<Q: QueryDescription<TyCtxt<'tcx>>>(\n-        self,\n+    fn load_from_disk_and_cache_in_memory<Q, CTX>(\n+        tcx: CTX,\n         key: Q::Key,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node_index: DepNodeIndex,\n-        dep_node: &DepNode<crate::dep_graph::DepKind>,\n-    ) -> Q::Value {\n+        dep_node: &DepNode<CTX::DepKind>,\n+    ) -> Q::Value\n+    where\n+        CTX: QueryContext,\n+        Q: QueryDescription<CTX>,\n+    {\n         // Note this function can be called concurrently from the same query\n         // We must ensure that this is handled correctly.\n \n-        debug_assert!(self.dep_graph.is_green(dep_node));\n+        debug_assert!(tcx.dep_graph().is_green(dep_node));\n \n         // First we try to load the result from the on-disk cache.\n-        let result = if Q::cache_on_disk(self, key.clone(), None) {\n-            let prof_timer = self.prof.incr_cache_loading();\n-            let result = Q::try_load_from_disk(self, prev_dep_node_index);\n+        let result = if Q::cache_on_disk(tcx, key.clone(), None) {\n+            let prof_timer = tcx.profiler().incr_cache_loading();\n+            let result = Q::try_load_from_disk(tcx, prev_dep_node_index);\n             prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n             // We always expect to find a cached result for things that\n@@ -676,10 +688,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         } else {\n             // We could not load a result from the on-disk cache, so\n             // recompute.\n-            let prof_timer = self.prof.query_provider();\n+            let prof_timer = tcx.profiler().query_provider();\n \n             // The dep-graph for this computation is already in-place.\n-            let result = self.dep_graph.with_ignore(|| Q::compute(self, key));\n+            let result = tcx.dep_graph().with_ignore(|| Q::compute(tcx, key));\n \n             prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -688,76 +700,86 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         // If `-Zincremental-verify-ich` is specified, re-hash results from\n         // the cache and make sure that they have the expected fingerprint.\n-        if unlikely!(self.sess.opts.debugging_opts.incremental_verify_ich) {\n-            self.incremental_verify_ich::<Q>(&result, dep_node, dep_node_index);\n+        if unlikely!(tcx.session().opts.debugging_opts.incremental_verify_ich) {\n+            incremental_verify_ich::<Q, _>(tcx, &result, dep_node, dep_node_index);\n         }\n \n         result\n     }\n \n     #[inline(never)]\n     #[cold]\n-    fn incremental_verify_ich<Q: QueryDescription<TyCtxt<'tcx>>>(\n-        self,\n+    fn incremental_verify_ich<Q, CTX>(\n+        tcx: CTX,\n         result: &Q::Value,\n-        dep_node: &DepNode<crate::dep_graph::DepKind>,\n+        dep_node: &DepNode<CTX::DepKind>,\n         dep_node_index: DepNodeIndex,\n-    ) {\n+    )\n+    where\n+        CTX: QueryContext,\n+        Q: QueryDescription<CTX>,\n+    {\n         use rustc_data_structures::fingerprint::Fingerprint;\n \n         assert!(\n-            Some(self.dep_graph.fingerprint_of(dep_node_index))\n-                == self.dep_graph.prev_fingerprint_of(dep_node),\n+            Some(tcx.dep_graph().fingerprint_of(dep_node_index))\n+                == tcx.dep_graph().prev_fingerprint_of(dep_node),\n             \"fingerprint for green query instance not loaded from cache: {:?}\",\n             dep_node,\n         );\n \n         debug!(\"BEGIN verify_ich({:?})\", dep_node);\n-        let mut hcx = self.create_stable_hashing_context();\n+        let mut hcx = tcx.create_stable_hashing_context();\n \n         let new_hash = Q::hash_result(&mut hcx, result).unwrap_or(Fingerprint::ZERO);\n         debug!(\"END verify_ich({:?})\", dep_node);\n \n-        let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n+        let old_hash = tcx.dep_graph().fingerprint_of(dep_node_index);\n \n         assert!(new_hash == old_hash, \"found unstable fingerprints for {:?}\", dep_node,);\n     }\n \n     #[inline(always)]\n-    fn force_query_with_job<Q: QueryDescription<TyCtxt<'tcx>> + 'tcx>(\n-        self,\n+    fn force_query_with_job<Q, CTX, K>(\n+        tcx: CTX,\n         key: Q::Key,\n-        job: JobOwner<'tcx, Self, Q::Cache>,\n-        dep_node: DepNode<crate::dep_graph::DepKind>,\n-    ) -> (Q::Value, DepNodeIndex) {\n+        job: JobOwner<'tcx, CTX, Q::Cache>,\n+        dep_node: DepNode<CTX::DepKind>,\n+    ) -> (Q::Value, DepNodeIndex)\n+    where\n+        Q: QueryDescription<CTX>,\n+        CTX: QueryContext<DepKind = K>,\n+        CTX: HashStableContextProvider<<CTX as DepContext>::StableHashingContext>,\n+        K: DepKind,\n+    {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n         //    in `DepGraph::try_mark_green()`.\n         // 2. Two distinct query keys get mapped to the same `DepNode`\n         //    (see for example #48923).\n         assert!(\n-            !self.dep_graph.dep_node_exists(&dep_node),\n+            !tcx.dep_graph().dep_node_exists(&dep_node),\n             \"forcing query with already existing `DepNode`\\n\\\n                  - query-key: {:?}\\n\\\n                  - dep-node: {:?}\",\n             key,\n             dep_node\n         );\n \n-        let prof_timer = self.prof.query_provider();\n+        let prof_timer = tcx.profiler().query_provider();\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-            self.start_query(job.id, diagnostics, |tcx| {\n+            tcx.start_query(job.id, diagnostics, |tcx| {\n                 if Q::EVAL_ALWAYS {\n-                    tcx.dep_graph.with_eval_always_task(\n+                    tcx.dep_graph().with_eval_always_task(\n                         dep_node,\n                         tcx,\n                         key,\n                         Q::compute,\n                         Q::hash_result,\n                     )\n                 } else {\n-                    tcx.dep_graph.with_task(dep_node, tcx, key, Q::compute, Q::hash_result)\n+                    tcx.dep_graph().with_task(dep_node, tcx, key, Q::compute, Q::hash_result)\n                 }\n             })\n         });\n@@ -766,15 +788,16 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         if unlikely!(!diagnostics.is_empty()) {\n             if dep_node.kind != DepKind::NULL {\n-                self.queries.on_disk_cache.store_diagnostics(dep_node_index, diagnostics);\n+                tcx.store_diagnostics(dep_node_index, diagnostics);\n             }\n         }\n \n-        job.complete(self, &result, dep_node_index);\n+        job.complete(tcx, &result, dep_node_index);\n \n         (result, dep_node_index)\n     }\n \n+impl<'tcx> TyCtxt<'tcx> {\n     /// Ensure that either this query has all green inputs or been executed.\n     /// Executing `query::ensure(D)` is considered a read of the dep-node `D`.\n     ///\n@@ -833,7 +856,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     #[cfg(parallel_compiler)]\n                     TryGetJob::JobCompleted(_) => return,\n                 };\n-                self.force_query_with_job::<Q>(key, job, dep_node);\n+                force_query_with_job::<Q, _, _>(self, key, job, dep_node);\n             },\n         );\n     }"}, {"sha": "ca4377e783d91dd219134d0249907b0278cf07ac", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27e8a95717c9f807ea1b4fc0e85da6813433011e/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e8a95717c9f807ea1b4fc0e85da6813433011e/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=27e8a95717c9f807ea1b4fc0e85da6813433011e", "patch": "@@ -23,7 +23,7 @@ use rustc_errors::Diagnostic;\n use std::fmt;\n use std::hash::Hash;\n \n-pub trait DepContext: Copy {\n+pub trait DepContext: Copy + DepGraphSafe {\n     type DepKind: self::DepKind;\n     type StableHashingContext: crate::HashStableContext;\n \n@@ -48,6 +48,9 @@ pub trait DepContext: Copy {\n     /// Register diagnostics for the given node, for use in next session.\n     fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n \n+    /// Register diagnostics for the given node, for use in next session.\n+    fn store_diagnostics_for_anon_node(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n+\n     /// Access the profiler.\n     fn profiler(&self) -> &SelfProfilerRef;\n }"}]}