{"sha": "a09972db3545344048b90e90d1f1821b621a38b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOTk3MmRiMzU0NTM0NDA0OGI5MGU5MGQxZjE4MjFiNjIxYTM4Yjk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-22T23:52:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-25T00:07:03Z"}, "message": "std: Move dynamic borrowck code from unstable::lang to rt::borrowck", "tree": {"sha": "85467a53191b58df8f61ee1b9582aee18900aba0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85467a53191b58df8f61ee1b9582aee18900aba0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a09972db3545344048b90e90d1f1821b621a38b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a09972db3545344048b90e90d1f1821b621a38b9", "html_url": "https://github.com/rust-lang/rust/commit/a09972db3545344048b90e90d1f1821b621a38b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a09972db3545344048b90e90d1f1821b621a38b9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa9210d25afb3779e1d95722b73b62a7be6274fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa9210d25afb3779e1d95722b73b62a7be6274fe", "html_url": "https://github.com/rust-lang/rust/commit/aa9210d25afb3779e1d95722b73b62a7be6274fe"}], "stats": {"total": 523, "additions": 294, "deletions": 229}, "files": [{"sha": "dd7e85ce7e110eab68b530bd36a08a8fa6a41d6e", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a09972db3545344048b90e90d1f1821b621a38b9/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09972db3545344048b90e90d1f1821b621a38b9/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=a09972db3545344048b90e90d1f1821b621a38b9", "patch": "@@ -15,7 +15,7 @@ use ptr::mut_null;\n use repr::BoxRepr;\n use sys::TypeDesc;\n use cast::transmute;\n-#[cfg(not(test))] use unstable::lang::clear_task_borrow_list;\n+#[cfg(not(test))] use rt::borrowck::clear_task_borrow_list;\n \n #[cfg(not(test))] use ptr::to_unsafe_ptr;\n "}, {"sha": "e057f6e963714f440d025dba9a1890354e2f5451", "filename": "src/libstd/rt/borrowck.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/a09972db3545344048b90e90d1f1821b621a38b9/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09972db3545344048b90e90d1f1821b621a38b9/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=a09972db3545344048b90e90d1f1821b621a38b9", "patch": "@@ -0,0 +1,283 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast::transmute;\n+use libc::{c_char, c_void, size_t, STDERR_FILENO};\n+use io;\n+use io::{Writer, WriterUtil};\n+use managed::raw::BoxRepr;\n+use option::{Option, None, Some};\n+use uint;\n+use str;\n+use str::OwnedStr;\n+use sys;\n+use vec::ImmutableVector;\n+\n+#[allow(non_camel_case_types)]\n+type rust_task = c_void;\n+\n+pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n+pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n+static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n+\n+#[deriving(Eq)]\n+struct BorrowRecord {\n+    box: *mut BoxRepr,\n+    file: *c_char,\n+    line: size_t\n+}\n+\n+fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n+    unsafe {\n+        let cur_task: *rust_task = rust_try_get_task();\n+        if cur_task.is_not_null() {\n+            let ptr = rust_take_task_borrow_list(cur_task);\n+            if ptr.is_null() {\n+                None\n+            } else {\n+                let v: ~[BorrowRecord] = transmute(ptr);\n+                Some(v)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n+    unsafe {\n+        let cur_task: *rust_task = rust_try_get_task();\n+        if cur_task.is_not_null() {\n+            let mut borrow_list: ~[BorrowRecord] = {\n+                let ptr = rust_take_task_borrow_list(cur_task);\n+                if ptr.is_null() { ~[] } else { transmute(ptr) }\n+            };\n+            borrow_list = f(borrow_list);\n+            rust_set_task_borrow_list(cur_task, transmute(borrow_list));\n+        }\n+    }\n+}\n+\n+pub unsafe fn clear_task_borrow_list() {\n+    // pub because it is used by the box annihilator.\n+    let _ = try_take_task_borrow_list();\n+}\n+\n+unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n+    debug_borrow(\"fail_borrowed: \", box, 0, 0, file, line);\n+\n+    match try_take_task_borrow_list() {\n+        None => { // not recording borrows\n+            let msg = \"borrowed\";\n+            do str::as_buf(msg) |msg_p, _| {\n+                sys::begin_unwind_(msg_p as *c_char, file, line);\n+            }\n+        }\n+        Some(borrow_list) => { // recording borrows\n+            let mut msg = ~\"borrowed\";\n+            let mut sep = \" at \";\n+            for borrow_list.rev_iter().advance |entry| {\n+                if entry.box == box {\n+                    msg.push_str(sep);\n+                    let filename = str::raw::from_c_str(entry.file);\n+                    msg.push_str(filename);\n+                    msg.push_str(fmt!(\":%u\", entry.line as uint));\n+                    sep = \" and at \";\n+                }\n+            }\n+            do str::as_buf(msg) |msg_p, _| {\n+                sys::begin_unwind_(msg_p as *c_char, file, line)\n+            }\n+        }\n+    }\n+}\n+\n+/// Because this code is so perf. sensitive, use a static constant so that\n+/// debug printouts are compiled out most of the time.\n+static ENABLE_DEBUG: bool = false;\n+\n+#[inline]\n+unsafe fn debug_borrow<T>(tag: &'static str,\n+                          p: *const T,\n+                          old_bits: uint,\n+                          new_bits: uint,\n+                          filename: *c_char,\n+                          line: size_t) {\n+    //! A useful debugging function that prints a pointer + tag + newline\n+    //! without allocating memory.\n+\n+    if ENABLE_DEBUG && ::rt::env::get().debug_borrow {\n+        debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n+    }\n+\n+    unsafe fn debug_borrow_slow<T>(tag: &'static str,\n+                                   p: *const T,\n+                                   old_bits: uint,\n+                                   new_bits: uint,\n+                                   filename: *c_char,\n+                                   line: size_t) {\n+        let dbg = STDERR_FILENO as io::fd_t;\n+        dbg.write_str(tag);\n+        dbg.write_hex(p as uint);\n+        dbg.write_str(\" \");\n+        dbg.write_hex(old_bits);\n+        dbg.write_str(\" \");\n+        dbg.write_hex(new_bits);\n+        dbg.write_str(\" \");\n+        dbg.write_cstr(filename);\n+        dbg.write_str(\":\");\n+        dbg.write_hex(line as uint);\n+        dbg.write_str(\"\\n\");\n+    }\n+}\n+\n+trait DebugPrints {\n+    fn write_hex(&self, val: uint);\n+    unsafe fn write_cstr(&self, str: *c_char);\n+}\n+\n+impl DebugPrints for io::fd_t {\n+    fn write_hex(&self, mut i: uint) {\n+        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n+                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n+        static uint_nibbles: uint = ::uint::bytes << 1;\n+        let mut buffer = [0_u8, ..uint_nibbles+1];\n+        let mut c = uint_nibbles;\n+        while c > 0 {\n+            c -= 1;\n+            buffer[c] = letters[i & 0xF] as u8;\n+            i >>= 4;\n+        }\n+        self.write(buffer.slice(0, uint_nibbles));\n+    }\n+\n+    unsafe fn write_cstr(&self, p: *c_char) {\n+        use libc::strlen;\n+        use vec;\n+\n+        let len = strlen(p);\n+        let p: *u8 = transmute(p);\n+        do vec::raw::buf_as_slice(p, len as uint) |s| {\n+            self.write(s);\n+        }\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n+    let a: *mut BoxRepr = transmute(a);\n+    let old_ref_count = (*a).header.ref_count;\n+    let new_ref_count = old_ref_count | FROZEN_BIT;\n+\n+    debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n+\n+    if (old_ref_count & MUT_BIT) != 0 {\n+        fail_borrowed(a, file, line);\n+    }\n+\n+    (*a).header.ref_count = new_ref_count;\n+\n+    old_ref_count\n+}\n+\n+#[inline]\n+pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n+    let a: *mut BoxRepr = transmute(a);\n+    let old_ref_count = (*a).header.ref_count;\n+    let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n+\n+    debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n+\n+    if (old_ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n+        fail_borrowed(a, file, line);\n+    }\n+\n+    (*a).header.ref_count = new_ref_count;\n+\n+    old_ref_count\n+}\n+\n+pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n+                            file: *c_char, line: size_t) {\n+    if (old_ref_count & ALL_BITS) == 0 {\n+        // was not borrowed before\n+        let a: *mut BoxRepr = transmute(a);\n+        debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n+        do swap_task_borrow_list |borrow_list| {\n+            let mut borrow_list = borrow_list;\n+            borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n+            borrow_list\n+        }\n+    }\n+}\n+\n+pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n+                              file: *c_char, line: size_t) {\n+    if (old_ref_count & ALL_BITS) == 0 {\n+        // was not borrowed before, so we should find the record at\n+        // the end of the list\n+        let a: *mut BoxRepr = transmute(a);\n+        debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n+        do swap_task_borrow_list |borrow_list| {\n+            let mut borrow_list = borrow_list;\n+            assert!(!borrow_list.is_empty());\n+            let br = borrow_list.pop();\n+            if br.box != a || br.file != file || br.line != line {\n+                let err = fmt!(\"wrong borrow found, br=%?\", br);\n+                do str::as_buf(err) |msg_p, _| {\n+                    sys::begin_unwind_(msg_p as *c_char, file, line)\n+                }\n+            }\n+            borrow_list\n+        }\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n+                            file: *c_char, line: size_t) {\n+    // Sometimes the box is null, if it is conditionally frozen.\n+    // See e.g. #4904.\n+    if !a.is_null() {\n+        let a: *mut BoxRepr = transmute(a);\n+        let old_ref_count = (*a).header.ref_count;\n+        let new_ref_count =\n+            (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n+\n+        debug_borrow(\"return_to_mut:\",\n+                     a, old_ref_count, new_ref_count, file, line);\n+\n+        (*a).header.ref_count = new_ref_count;\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn check_not_borrowed(a: *u8,\n+                                 file: *c_char,\n+                                 line: size_t) {\n+    let a: *mut BoxRepr = transmute(a);\n+    let ref_count = (*a).header.ref_count;\n+    debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n+    if (ref_count & FROZEN_BIT) != 0 {\n+        fail_borrowed(a, file, line);\n+    }\n+}\n+\n+\n+extern {\n+    #[rust_stack]\n+    pub fn rust_take_task_borrow_list(task: *rust_task) -> *c_void;\n+\n+    #[rust_stack]\n+    pub fn rust_set_task_borrow_list(task: *rust_task, map: *c_void);\n+\n+    #[rust_stack]\n+    pub fn rust_try_get_task() -> *rust_task;\n+}"}, {"sha": "6c4e5742eb333ff46a8686da84371d48dc223472", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a09972db3545344048b90e90d1f1821b621a38b9/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09972db3545344048b90e90d1f1821b621a38b9/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=a09972db3545344048b90e90d1f1821b621a38b9", "patch": "@@ -162,6 +162,9 @@ pub mod util;\n // Global command line argument storage\n pub mod args;\n \n+// Support for dynamic borrowck\n+pub mod borrowck;\n+\n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This is invoked by the `start` _language item_ (unstable::lang) to"}, {"sha": "d71a672eb3552cd35e5a00c28a03b46f9004c509", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 7, "deletions": 228, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/a09972db3545344048b90e90d1f1821b621a38b9/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09972db3545344048b90e90d1f1821b621a38b9/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=a09972db3545344048b90e90d1f1821b621a38b9", "patch": "@@ -14,7 +14,6 @@ use iterator::IteratorUtil;\n use uint;\n use cast::transmute;\n use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n-use managed::raw::BoxRepr;\n use str;\n use sys;\n use rt::{context, OldTaskContext};\n@@ -23,14 +22,11 @@ use rt::local::Local;\n use option::{Option, Some, None};\n use io;\n use rt::global_heap;\n+use rt::borrowck;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n \n-pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n-pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n-static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n-\n pub mod rustrt {\n     use unstable::lang::rust_task;\n     use libc::{c_void, c_char, uintptr_t};\n@@ -50,12 +46,6 @@ pub mod rustrt {\n         #[fast_ffi]\n         unsafe fn rust_upcall_free_noswitch(ptr: *c_char);\n \n-        #[rust_stack]\n-        fn rust_take_task_borrow_list(task: *rust_task) -> *c_void;\n-\n-        #[rust_stack]\n-        fn rust_set_task_borrow_list(task: *rust_task, map: *c_void);\n-\n         #[rust_stack]\n         fn rust_try_get_task() -> *rust_task;\n \n@@ -78,156 +68,13 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n     }\n }\n \n-#[deriving(Eq)]\n-struct BorrowRecord {\n-    box: *mut BoxRepr,\n-    file: *c_char,\n-    line: size_t\n-}\n-\n-fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    unsafe {\n-        let cur_task: *rust_task = rustrt::rust_try_get_task();\n-        if cur_task.is_not_null() {\n-            let ptr = rustrt::rust_take_task_borrow_list(cur_task);\n-            if ptr.is_null() {\n-                None\n-            } else {\n-                let v: ~[BorrowRecord] = transmute(ptr);\n-                Some(v)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n-    unsafe {\n-        let cur_task: *rust_task = rustrt::rust_try_get_task();\n-        if cur_task.is_not_null() {\n-            let mut borrow_list: ~[BorrowRecord] = {\n-                let ptr = rustrt::rust_take_task_borrow_list(cur_task);\n-                if ptr.is_null() { ~[] } else { transmute(ptr) }\n-            };\n-            borrow_list = f(borrow_list);\n-            rustrt::rust_set_task_borrow_list(cur_task, transmute(borrow_list));\n-        }\n-    }\n-}\n-\n-pub unsafe fn clear_task_borrow_list() {\n-    // pub because it is used by the box annihilator.\n-    let _ = try_take_task_borrow_list();\n-}\n-\n-unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n-    debug_borrow(\"fail_borrowed: \", box, 0, 0, file, line);\n-\n-    match try_take_task_borrow_list() {\n-        None => { // not recording borrows\n-            let msg = \"borrowed\";\n-            do str::as_buf(msg) |msg_p, _| {\n-                fail_(msg_p as *c_char, file, line);\n-            }\n-        }\n-        Some(borrow_list) => { // recording borrows\n-            let mut msg = ~\"borrowed\";\n-            let mut sep = \" at \";\n-            for borrow_list.rev_iter().advance |entry| {\n-                if entry.box == box {\n-                    msg.push_str(sep);\n-                    let filename = str::raw::from_c_str(entry.file);\n-                    msg.push_str(filename);\n-                    msg.push_str(fmt!(\":%u\", entry.line as uint));\n-                    sep = \" and at \";\n-                }\n-            }\n-            do str::as_buf(msg) |msg_p, _| {\n-                fail_(msg_p as *c_char, file, line)\n-            }\n-        }\n-    }\n-}\n-\n // FIXME #4942: Make these signatures agree with exchange_alloc's signatures\n #[lang=\"exchange_malloc\"]\n #[inline]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     transmute(global_heap::malloc(transmute(td), transmute(size)))\n }\n \n-/// Because this code is so perf. sensitive, use a static constant so that\n-/// debug printouts are compiled out most of the time.\n-static ENABLE_DEBUG: bool = false;\n-\n-#[inline]\n-unsafe fn debug_borrow<T>(tag: &'static str,\n-                          p: *const T,\n-                          old_bits: uint,\n-                          new_bits: uint,\n-                          filename: *c_char,\n-                          line: size_t) {\n-    //! A useful debugging function that prints a pointer + tag + newline\n-    //! without allocating memory.\n-\n-    if ENABLE_DEBUG && ::rt::env::get().debug_borrow {\n-        debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n-    }\n-\n-    unsafe fn debug_borrow_slow<T>(tag: &'static str,\n-                                   p: *const T,\n-                                   old_bits: uint,\n-                                   new_bits: uint,\n-                                   filename: *c_char,\n-                                   line: size_t) {\n-        let dbg = STDERR_FILENO as io::fd_t;\n-        dbg.write_str(tag);\n-        dbg.write_hex(p as uint);\n-        dbg.write_str(\" \");\n-        dbg.write_hex(old_bits);\n-        dbg.write_str(\" \");\n-        dbg.write_hex(new_bits);\n-        dbg.write_str(\" \");\n-        dbg.write_cstr(filename);\n-        dbg.write_str(\":\");\n-        dbg.write_hex(line as uint);\n-        dbg.write_str(\"\\n\");\n-    }\n-}\n-\n-trait DebugPrints {\n-    fn write_hex(&self, val: uint);\n-    unsafe fn write_cstr(&self, str: *c_char);\n-}\n-\n-impl DebugPrints for io::fd_t {\n-    fn write_hex(&self, mut i: uint) {\n-        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n-        static uint_nibbles: uint = ::uint::bytes << 1;\n-        let mut buffer = [0_u8, ..uint_nibbles+1];\n-        let mut c = uint_nibbles;\n-        while c > 0 {\n-            c -= 1;\n-            buffer[c] = letters[i & 0xF] as u8;\n-            i >>= 4;\n-        }\n-        self.write(buffer.slice(0, uint_nibbles));\n-    }\n-\n-    unsafe fn write_cstr(&self, p: *c_char) {\n-        use libc::strlen;\n-        use vec;\n-\n-        let len = strlen(p);\n-        let p: *u8 = transmute(p);\n-        do vec::raw::buf_as_slice(p, len as uint) |s| {\n-            self.write(s);\n-        }\n-    }\n-}\n-\n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n@@ -273,108 +120,40 @@ pub unsafe fn local_free(ptr: *c_char) {\n #[lang=\"borrow_as_imm\"]\n #[inline]\n pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a: *mut BoxRepr = transmute(a);\n-    let old_ref_count = (*a).header.ref_count;\n-    let new_ref_count = old_ref_count | FROZEN_BIT;\n-\n-    debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n-\n-    if (old_ref_count & MUT_BIT) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-\n-    (*a).header.ref_count = new_ref_count;\n-\n-    old_ref_count\n+    borrowck::borrow_as_imm(a, file, line)\n }\n \n #[lang=\"borrow_as_mut\"]\n #[inline]\n pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a: *mut BoxRepr = transmute(a);\n-    let old_ref_count = (*a).header.ref_count;\n-    let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n-\n-    debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n-\n-    if (old_ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-\n-    (*a).header.ref_count = new_ref_count;\n-\n-    old_ref_count\n+    borrowck::borrow_as_mut(a, file, line)\n }\n \n-\n #[lang=\"record_borrow\"]\n pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n                             file: *c_char, line: size_t) {\n-    if (old_ref_count & ALL_BITS) == 0 {\n-        // was not borrowed before\n-        let a: *mut BoxRepr = transmute(a);\n-        debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n-        do swap_task_borrow_list |borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n-            borrow_list\n-        }\n-    }\n+    borrowck::record_borrow(a, old_ref_count, file, line)\n }\n \n #[lang=\"unrecord_borrow\"]\n pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n                               file: *c_char, line: size_t) {\n-    if (old_ref_count & ALL_BITS) == 0 {\n-        // was not borrowed before, so we should find the record at\n-        // the end of the list\n-        let a: *mut BoxRepr = transmute(a);\n-        debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n-        do swap_task_borrow_list |borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            assert!(!borrow_list.is_empty());\n-            let br = borrow_list.pop();\n-            if br.box != a || br.file != file || br.line != line {\n-                let err = fmt!(\"wrong borrow found, br=%?\", br);\n-                do str::as_buf(err) |msg_p, _| {\n-                    fail_(msg_p as *c_char, file, line)\n-                }\n-            }\n-            borrow_list\n-        }\n-    }\n+    borrowck::unrecord_borrow(a, old_ref_count, file, line)\n }\n \n #[lang=\"return_to_mut\"]\n #[inline]\n pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n                             file: *c_char, line: size_t) {\n-    // Sometimes the box is null, if it is conditionally frozen.\n-    // See e.g. #4904.\n-    if !a.is_null() {\n-        let a: *mut BoxRepr = transmute(a);\n-        let old_ref_count = (*a).header.ref_count;\n-        let new_ref_count =\n-            (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n-\n-        debug_borrow(\"return_to_mut:\",\n-                     a, old_ref_count, new_ref_count, file, line);\n-\n-        (*a).header.ref_count = new_ref_count;\n-    }\n+    borrowck::return_to_mut(a, orig_ref_count, file, line)\n }\n \n #[lang=\"check_not_borrowed\"]\n #[inline]\n pub unsafe fn check_not_borrowed(a: *u8,\n                                  file: *c_char,\n                                  line: size_t) {\n-    let a: *mut BoxRepr = transmute(a);\n-    let ref_count = (*a).header.ref_count;\n-    debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n-    if (ref_count & FROZEN_BIT) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n+    borrowck::check_not_borrowed(a, file, line)\n }\n \n #[lang=\"strdup_uniq\"]"}]}