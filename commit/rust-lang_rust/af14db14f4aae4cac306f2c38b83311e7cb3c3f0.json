{"sha": "af14db14f4aae4cac306f2c38b83311e7cb3c3f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMTRkYjE0ZjRhYWU0Y2FjMzA2ZjJjMzhiODMzMTFlN2NiM2MzZjA=", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-08-25T02:26:48Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-08-25T02:29:41Z"}, "message": "Review comments", "tree": {"sha": "a12575cae28ffdb83a20e3263e40b2be6c910f15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a12575cae28ffdb83a20e3263e40b2be6c910f15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af14db14f4aae4cac306f2c38b83311e7cb3c3f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af14db14f4aae4cac306f2c38b83311e7cb3c3f0", "html_url": "https://github.com/rust-lang/rust/commit/af14db14f4aae4cac306f2c38b83311e7cb3c3f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af14db14f4aae4cac306f2c38b83311e7cb3c3f0/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9891e470b10566bc77db56712afcc740ec27a184", "url": "https://api.github.com/repos/rust-lang/rust/commits/9891e470b10566bc77db56712afcc740ec27a184", "html_url": "https://github.com/rust-lang/rust/commit/9891e470b10566bc77db56712afcc740ec27a184"}], "stats": {"total": 109, "additions": 68, "deletions": 41}, "files": [{"sha": "ba9b6926526be010208f568415a9602c2043c62f", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af14db14f4aae4cac306f2c38b83311e7cb3c3f0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af14db14f4aae4cac306f2c38b83311e7cb3c3f0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=af14db14f4aae4cac306f2c38b83311e7cb3c3f0", "patch": "@@ -169,8 +169,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         {\n             // FIXME(jackh726): This is a hack. It's somewhat like\n             // `rustc_traits::normalize_after_erasing_regions`. Ideally, we'd\n-            // like to normalize *before* inserting into `local_decls`, but I\n-            // couldn't figure out where the heck that was.\n+            // like to normalize *before* inserting into `local_decls`, but\n+            // doing so ends up causing some other trouble.\n             let b = match self\n                 .infcx\n                 .at(&ObligationCause::dummy(), ty::ParamEnv::empty())"}, {"sha": "91b9ad0af356cdbf9dccb3df13f3df42be71cdcf", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/af14db14f4aae4cac306f2c38b83311e7cb3c3f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af14db14f4aae4cac306f2c38b83311e7cb3c3f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=af14db14f4aae4cac306f2c38b83311e7cb3c3f0", "patch": "@@ -363,12 +363,28 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n             return ty;\n         }\n \n-        // N.b. while we want to call `super_fold_with(self)` on `ty` before\n-        // normalization, we wait until we know whether we need to normalize the\n-        // current type. If we do, then we only fold the ty *after* replacing bound\n-        // vars with placeholders. This means that nested types don't need to replace\n-        // bound vars at the current binder level or above. A key assumption here is\n-        // that folding the type can't introduce new bound vars.\n+        // We try to be a little clever here as a performance optimization in\n+        // cases where there are nested projections under binders.\n+        // For example:\n+        // ```\n+        // for<'a> fn(<T as Foo>::One<'a, Box<dyn Bar<'a, Item=<T as Foo>::Two<'a>>>>)\n+        // ```\n+        // We normalize the substs on the projection before the projecting, but\n+        // if we're naive, we'll\n+        //   replace bound vars on inner, project inner, replace placeholders on inner,\n+        //   replace bound vars on outer, project outer, replace placeholders on outer\n+        //\n+        // However, if we're a bit more clever, we can replace the bound vars\n+        // on the entire type before normalizing nested projections, meaning we\n+        //   replace bound vars on outer, project inner,\n+        //   project outer, replace placeholders on outer\n+        //\n+        // This is possible because the inner `'a` will already be a placeholder\n+        // when we need to normalize the inner projection\n+        //\n+        // On the other hand, this does add a bit of complexity, since we only\n+        // replace bound vars if the current type is a `Projection` and we need\n+        // to make sure we don't forget to fold the substs regardless.\n \n         match *ty.kind() {\n             ty::Opaque(def_id, substs) => {\n@@ -380,7 +396,6 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                         // N.b. there is an assumption here all this code can handle\n                         // escaping bound vars.\n \n-                        let substs = substs.super_fold_with(self);\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.depth) {\n                             let obligation = Obligation::with_depth(\n@@ -392,6 +407,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                             self.selcx.infcx().report_overflow_error(&obligation, true);\n                         }\n \n+                        let substs = substs.super_fold_with(self);\n                         let generic_ty = self.tcx().type_of(def_id);\n                         let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                         self.depth += 1;\n@@ -430,12 +446,16 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n \n             ty::Projection(data) => {\n                 // If there are escaping bound vars, we temporarily replace the\n-                // bound vars with placeholders. Note though, that in the cas\n+                // bound vars with placeholders. Note though, that in the case\n                 // that we still can't project for whatever reason (e.g. self\n                 // type isn't known enough), we *can't* register an obligation\n                 // and return an inference variable (since then that obligation\n                 // would have bound vars and that's a can of worms). Instead,\n                 // we just give up and fall back to pretending like we never tried!\n+                //\n+                // Note: this isn't necessarily the final approach here; we may\n+                // want to figure out how to register obligations with escaping vars\n+                // or handle this some other way.\n \n                 let infcx = self.selcx.infcx();\n                 let (data, mapped_regions, mapped_types, mapped_consts) =\n@@ -451,16 +471,18 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 )\n                 .ok()\n                 .flatten()\n+                .map(|normalized_ty| {\n+                    PlaceholderReplacer::replace_placeholders(\n+                        infcx,\n+                        mapped_regions,\n+                        mapped_types,\n+                        mapped_consts,\n+                        &self.universes,\n+                        normalized_ty,\n+                    )\n+                })\n                 .unwrap_or_else(|| ty.super_fold_with(self));\n \n-                let normalized_ty = PlaceholderReplacer::replace_placeholders(\n-                    infcx,\n-                    mapped_regions,\n-                    mapped_types,\n-                    mapped_consts,\n-                    &self.universes,\n-                    normalized_ty,\n-                );\n                 debug!(\n                     ?self.depth,\n                     ?ty,"}, {"sha": "21e1bd8f46467e26f1801dc394184a122d9c7be8", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/af14db14f4aae4cac306f2c38b83311e7cb3c3f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af14db14f4aae4cac306f2c38b83311e7cb3c3f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=af14db14f4aae4cac306f2c38b83311e7cb3c3f0", "patch": "@@ -67,6 +67,16 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n             universes: vec![],\n         };\n \n+        // This is actually a consequence by the way `normalize_erasing_regions` works currently.\n+        // Because it needs to call the `normalize_generic_arg_after_erasing_regions`, it folds\n+        // through tys and consts in a `TypeFoldable`. Importantly, it skips binders, leaving us\n+        // with trying to normalize with escaping bound vars.\n+        //\n+        // Here, we just add the universes that we *would* have created had we passed through the binders.\n+        //\n+        // We *could* replace escaping bound vars eagerly here, but it doesn't seem really necessary.\n+        // The rest of the code is already set up to be lazy about replacing bound vars,\n+        // and only when we actually have to normalize.\n         if value.has_escaping_bound_vars() {\n             let mut max_visitor =\n                 MaxEscapingBoundVarVisitor { outer_index: ty::INNERMOST, escaping: 0 };\n@@ -183,12 +193,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             return ty;\n         }\n \n-        // N.b. while we want to call `super_fold_with(self)` on `ty` before\n-        // normalization, we wait until we know whether we need to normalize the\n-        // current type. If we do, then we only fold the ty *after* replacing bound\n-        // vars with placeholders. This means that nested types don't need to replace\n-        // bound vars at the current binder level or above. A key assumption here is\n-        // that folding the type can't introduce new bound vars.\n+        // See note in `rustc_trait_selection::traits::project` about why we\n+        // wait to fold the substs.\n \n         // Wrap this in a closure so we don't accidentally return from the outer function\n         let res = (|| match *ty.kind() {\n@@ -253,7 +259,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         // We don't expect ambiguity.\n                         if result.is_ambiguous() {\n                             self.error = true;\n-                            return ty;\n+                            return ty.super_fold_with(self);\n                         }\n \n                         match self.infcx.instantiate_query_response_and_region_obligations(\n@@ -271,14 +277,14 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n \n                             Err(_) => {\n                                 self.error = true;\n-                                ty\n+                                ty.super_fold_with(self)\n                             }\n                         }\n                     }\n \n                     Err(NoSolution) => {\n                         self.error = true;\n-                        ty\n+                        ty.super_fold_with(self)\n                     }\n                 }\n             }\n@@ -304,12 +310,12 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                let normalized_ty = match tcx.normalize_projection_ty(c_data) {\n+                match tcx.normalize_projection_ty(c_data) {\n                     Ok(result) => {\n                         // We don't expect ambiguity.\n                         if result.is_ambiguous() {\n                             self.error = true;\n-                            return ty;\n+                            return ty.super_fold_with(self);\n                         }\n                         match self.infcx.instantiate_query_response_and_region_obligations(\n                             self.cause,\n@@ -321,27 +327,26 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                                 debug!(\"QueryNormalizer: result = {:#?}\", result);\n                                 debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n                                 self.obligations.extend(obligations);\n-                                result.normalized_ty\n+                                crate::traits::project::PlaceholderReplacer::replace_placeholders(\n+                                    infcx,\n+                                    mapped_regions,\n+                                    mapped_types,\n+                                    mapped_consts,\n+                                    &self.universes,\n+                                    result.normalized_ty,\n+                                )\n                             }\n                             Err(_) => {\n                                 self.error = true;\n-                                ty\n+                                ty.super_fold_with(self)\n                             }\n                         }\n                     }\n                     Err(NoSolution) => {\n                         self.error = true;\n-                        ty\n+                        ty.super_fold_with(self)\n                     }\n-                };\n-                crate::traits::project::PlaceholderReplacer::replace_placeholders(\n-                    infcx,\n-                    mapped_regions,\n-                    mapped_types,\n-                    mapped_consts,\n-                    &self.universes,\n-                    normalized_ty,\n-                )\n+                }\n             }\n \n             _ => ty.super_fold_with(self),"}]}