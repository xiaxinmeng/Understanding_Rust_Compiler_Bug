{"sha": "8132d4e1000f012d1f25dbcedf006a9dc2f8598c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMzJkNGUxMDAwZjAxMmQxZjI1ZGJjZWRmMDA2YTlkYzJmODU5OGM=", "commit": {"author": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2018-09-20T21:13:41Z"}, "committer": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2018-09-21T01:29:34Z"}, "message": "Move is_place_expr to be a method on hir::Expr", "tree": {"sha": "5ac9a4cc3329de983eff1c8dc9cfb3a25bc71dfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ac9a4cc3329de983eff1c8dc9cfb3a25bc71dfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8132d4e1000f012d1f25dbcedf006a9dc2f8598c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8132d4e1000f012d1f25dbcedf006a9dc2f8598c", "html_url": "https://github.com/rust-lang/rust/commit/8132d4e1000f012d1f25dbcedf006a9dc2f8598c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8132d4e1000f012d1f25dbcedf006a9dc2f8598c/comments", "author": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79fcc58b24d85743d025fd880fca55748662ed3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/79fcc58b24d85743d025fd880fca55748662ed3e", "html_url": "https://github.com/rust-lang/rust/commit/79fcc58b24d85743d025fd880fca55748662ed3e"}], "stats": {"total": 122, "additions": 62, "deletions": 60}, "files": [{"sha": "b55b175cade531cc8558ced7311017406c8a3f96", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8132d4e1000f012d1f25dbcedf006a9dc2f8598c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8132d4e1000f012d1f25dbcedf006a9dc2f8598c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8132d4e1000f012d1f25dbcedf006a9dc2f8598c", "patch": "@@ -1345,6 +1345,59 @@ impl Expr {\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n         }\n     }\n+\n+    pub fn is_place_expr(&self) -> bool {\n+         match self.node {\n+            ExprKind::Path(QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            ExprKind::Type(ref e, _) => {\n+                e.is_place_expr()\n+            }\n+\n+            ExprKind::Unary(UnDeref, _) |\n+            ExprKind::Field(..) |\n+            ExprKind::Index(..) => {\n+                true\n+            }\n+\n+            // Partially qualified paths in expressions can only legally\n+            // refer to associated items which are always rvalues.\n+            ExprKind::Path(QPath::TypeRelative(..)) |\n+\n+            ExprKind::Call(..) |\n+            ExprKind::MethodCall(..) |\n+            ExprKind::Struct(..) |\n+            ExprKind::Tup(..) |\n+            ExprKind::If(..) |\n+            ExprKind::Match(..) |\n+            ExprKind::Closure(..) |\n+            ExprKind::Block(..) |\n+            ExprKind::Repeat(..) |\n+            ExprKind::Array(..) |\n+            ExprKind::Break(..) |\n+            ExprKind::Continue(..) |\n+            ExprKind::Ret(..) |\n+            ExprKind::While(..) |\n+            ExprKind::Loop(..) |\n+            ExprKind::Assign(..) |\n+            ExprKind::InlineAsm(..) |\n+            ExprKind::AssignOp(..) |\n+            ExprKind::Lit(_) |\n+            ExprKind::Unary(..) |\n+            ExprKind::Box(..) |\n+            ExprKind::AddrOf(..) |\n+            ExprKind::Binary(..) |\n+            ExprKind::Yield(..) |\n+            ExprKind::Cast(..) => {\n+                false\n+            }\n+        }\n+    }\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "6d1f5be8470be8f99398da23cfc8ac8ad91e47dd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 59, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8132d4e1000f012d1f25dbcedf006a9dc2f8598c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8132d4e1000f012d1f25dbcedf006a9dc2f8598c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8132d4e1000f012d1f25dbcedf006a9dc2f8598c", "patch": "@@ -2447,59 +2447,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn is_place_expr(&self, expr: &hir::Expr) -> bool {\n-         match expr.node {\n-            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-                match path.def {\n-                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n-                    _ => false,\n-                }\n-            }\n-\n-            hir::ExprKind::Type(ref e, _) => {\n-                self.is_place_expr(e)\n-            }\n-\n-            hir::ExprKind::Unary(hir::UnDeref, _) |\n-            hir::ExprKind::Field(..) |\n-            hir::ExprKind::Index(..) => {\n-                true\n-            }\n-\n-            // Partially qualified paths in expressions can only legally\n-            // refer to associated items which are always rvalues.\n-            hir::ExprKind::Path(hir::QPath::TypeRelative(..)) |\n-\n-            hir::ExprKind::Call(..) |\n-            hir::ExprKind::MethodCall(..) |\n-            hir::ExprKind::Struct(..) |\n-            hir::ExprKind::Tup(..) |\n-            hir::ExprKind::If(..) |\n-            hir::ExprKind::Match(..) |\n-            hir::ExprKind::Closure(..) |\n-            hir::ExprKind::Block(..) |\n-            hir::ExprKind::Repeat(..) |\n-            hir::ExprKind::Array(..) |\n-            hir::ExprKind::Break(..) |\n-            hir::ExprKind::Continue(..) |\n-            hir::ExprKind::Ret(..) |\n-            hir::ExprKind::While(..) |\n-            hir::ExprKind::Loop(..) |\n-            hir::ExprKind::Assign(..) |\n-            hir::ExprKind::InlineAsm(..) |\n-            hir::ExprKind::AssignOp(..) |\n-            hir::ExprKind::Lit(_) |\n-            hir::ExprKind::Unary(..) |\n-            hir::ExprKind::Box(..) |\n-            hir::ExprKind::AddrOf(..) |\n-            hir::ExprKind::Binary(..) |\n-            hir::ExprKind::Yield(..) |\n-            hir::ExprKind::Cast(..) => {\n-                false\n-            }\n-        }\n-    }\n-\n     /// For the overloaded place expressions (`*x`, `x[3]`), the trait\n     /// returns a type of `&T`, but the actual type we assign to the\n     /// *expression* is `T`. So this function just peels off the return\n@@ -3762,10 +3709,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n-    fn check_expr_kind(&self,\n-                       expr: &'gcx hir::Expr,\n-                       expected: Expectation<'tcx>,\n-                       needs: Needs) -> Ty<'tcx> {\n+    fn check_expr_kind(\n+        &self,\n+        expr: &'gcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n@@ -3862,7 +3811,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                            if self.is_place_expr(&oprnd) {\n+                            if oprnd.is_place_expr() {\n                                 // Places may legitimately have unsized types.\n                                 // For example, dereferences of a fat pointer and\n                                 // the last field of a struct can be unsized.\n@@ -4041,7 +3990,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => {\n                         // Only check this if not in an `if` condition, as the\n                         // mistyped comparison help is more appropriate.\n-                        if !self.is_place_expr(&lhs) {\n+                        if !lhs.is_place_expr() {\n                             struct_span_err!(self.tcx.sess, expr.span, E0070,\n                                                 \"invalid left-hand side expression\")\n                                 .span_label(expr.span, \"left-hand of expression not valid\")"}, {"sha": "304238488d8a947f18de67a6586a32546f9f3f9f", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8132d4e1000f012d1f25dbcedf006a9dc2f8598c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8132d4e1000f012d1f25dbcedf006a9dc2f8598c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=8132d4e1000f012d1f25dbcedf006a9dc2f8598c", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return_ty\n         };\n \n-        if !self.is_place_expr(lhs_expr) {\n+        if !lhs_expr.is_place_expr() {\n             struct_span_err!(\n                 self.tcx.sess, lhs_expr.span,\n                 E0067, \"invalid left-hand side expression\")"}]}