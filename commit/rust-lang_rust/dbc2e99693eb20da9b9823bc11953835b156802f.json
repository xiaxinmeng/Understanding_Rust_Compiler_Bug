{"sha": "dbc2e99693eb20da9b9823bc11953835b156802f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzJlOTk2OTNlYjIwZGE5Yjk4MjNiYzExOTUzODM1YjE1NjgwMmY=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-25T23:55:49Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-25T23:55:49Z"}, "message": "Use `///` doc-comment form instead of `/** */`", "tree": {"sha": "72b6dcb39840c2a3fac238ad3310445c294b436d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72b6dcb39840c2a3fac238ad3310445c294b436d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc2e99693eb20da9b9823bc11953835b156802f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc2e99693eb20da9b9823bc11953835b156802f", "html_url": "https://github.com/rust-lang/rust/commit/dbc2e99693eb20da9b9823bc11953835b156802f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc2e99693eb20da9b9823bc11953835b156802f/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad0b337036f2f9076852d5d6701ec302e3cce101", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad0b337036f2f9076852d5d6701ec302e3cce101", "html_url": "https://github.com/rust-lang/rust/commit/ad0b337036f2f9076852d5d6701ec302e3cce101"}], "stats": {"total": 1325, "additions": 662, "deletions": 663}, "files": [{"sha": "63e52fab7c96e23ac46252adee19e57da6ba0a90", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=dbc2e99693eb20da9b9823bc11953835b156802f", "patch": "@@ -304,13 +304,13 @@ impl Signed for f32 {\n     #[inline(always)]\n     fn abs(&self) -> f32 { abs(*self) }\n \n-    /**\n-     * # Returns\n-     *\n-     * - `1.0` if the number is positive, `+0.0` or `infinity`\n-     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-     * - `NaN` if the number is `NaN`\n-     */\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n+    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+    /// - `NaN` if the number is NaN\n+    ///\n     #[inline(always)]\n     fn signum(&self) -> f32 {\n         if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n@@ -509,52 +509,52 @@ impl Real for f32 {\n     fn tanh(&self) -> f32 { tanh(*self) }\n }\n \n-/**\n- * Section: String Conversions\n- */\n+//\n+// Section: String Conversions\n+//\n \n-/**\n- * Converts a float to a string\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in hexadecimal format\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string in hexadecimal format\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- *\n- * # Failure\n- *\n- * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n- * possible misinterpretation of the result at higher bases. If those values\n- * are expected, use `to_str_radix_special()` instead.\n- */\n+///\n+/// Converts a float to a string in a given radix\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n+/// # Failure\n+///\n+/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+/// possible misinterpretation of the result at higher bases. If those values\n+/// are expected, use `to_str_radix_special()` instead.\n+///\n #[inline(always)]\n pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n@@ -564,46 +564,46 @@ pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix, and a flag indicating\n- * whether it's a special value\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- */\n+///\n+/// Converts a float to a string in a given radix, and a flag indicating\n+/// whether it's a special value\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n #[inline(always)]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n-/**\n- * Converts a float to a string with exactly the number of\n- * provided significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with exactly the number of\n+/// provided significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n-/**\n- * Converts a float to a string with a maximum number of\n- * significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with a maximum number of\n+/// significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n@@ -623,91 +623,91 @@ impl num::ToStrRadix for f32 {\n     }\n }\n \n-/**\n- * Convert a string in base 10 to a float.\n- * Accepts a optional decimal exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * '3.14'\n- * * '+3.14', equivalent to '3.14'\n- * * '-3.14'\n- * * '2.5E10', or equivalently, '2.5e10'\n- * * '2.5E-10'\n- * * '.' (understood as 0)\n- * * '5.'\n- * * '.5', or, equivalently,  '0.5'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in base 10 to a float.\n+/// Accepts a optional decimal exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * '3.14'\n+/// * '+3.14', equivalent to '3.14'\n+/// * '-3.14'\n+/// * '2.5E10', or equivalently, '2.5e10'\n+/// * '2.5E-10'\n+/// * '.' (understood as 0)\n+/// * '5.'\n+/// * '.5', or, equivalently,  '0.5'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n }\n \n-/**\n- * Convert a string in base 16 to a float.\n- * Accepts a optional binary exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * 'a4.fe'\n- * * '+a4.fe', equivalent to 'a4.fe'\n- * * '-a4.fe'\n- * * '2b.aP128', or equivalently, '2b.ap128'\n- * * '2b.aP-128'\n- * * '.' (understood as 0)\n- * * 'c.'\n- * * '.c', or, equivalently,  '0.c'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n- */\n+///\n+/// Convert a string in base 16 to a float.\n+/// Accepts a optional binary exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * 'a4.fe'\n+/// * '+a4.fe', equivalent to 'a4.fe'\n+/// * '-a4.fe'\n+/// * '2b.aP128', or equivalently, '2b.ap128'\n+/// * '2b.aP-128'\n+/// * '.' (understood as 0)\n+/// * 'c.'\n+/// * '.c', or, equivalently,  '0.c'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+///\n #[inline(always)]\n pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n-/**\n- * Convert a string in an given base to a float.\n- *\n- * Due to possible conflicts, this function does **not** accept\n- * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n- * does it recognize exponents of any kind.\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- * * radix - The base to use. Must lie in the range [2 .. 36]\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number. Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in an given base to a float.\n+///\n+/// Due to possible conflicts, this function does **not** accept\n+/// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+/// does it recognize exponents of any kind.\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+/// * radix - The base to use. Must lie in the range [2 .. 36]\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number. Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n     strconv::from_str_common(num, rdx, true, true, false,"}, {"sha": "e6013eec2435e7163c0186a500dbc50d6035a8cd", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=dbc2e99693eb20da9b9823bc11953835b156802f", "patch": "@@ -314,13 +314,13 @@ impl Signed for f64 {\n     #[inline(always)]\n     fn abs(&self) -> f64 { abs(*self) }\n \n-    /**\n-     * # Returns\n-     *\n-     * - `1.0` if the number is positive, `+0.0` or `infinity`\n-     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-     * - `NaN` if the number is `NaN`\n-     */\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n+    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+    /// - `NaN` if the number is NaN\n+    ///\n     #[inline(always)]\n     fn signum(&self) -> f64 {\n         if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n@@ -549,52 +549,52 @@ impl RealExt for f64 {\n     fn yn(&self, n: int) -> f64 { yn(n as c_int, *self) }\n }\n \n-/**\n- * Section: String Conversions\n- */\n+//\n+// Section: String Conversions\n+//\n \n-/**\n- * Converts a float to a string\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in hexadecimal format\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string in hexadecimal format\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- *\n- * # Failure\n- *\n- * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n- * possible misinterpretation of the result at higher bases. If those values\n- * are expected, use `to_str_radix_special()` instead.\n- */\n+///\n+/// Converts a float to a string in a given radix\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n+/// # Failure\n+///\n+/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+/// possible misinterpretation of the result at higher bases. If those values\n+/// are expected, use `to_str_radix_special()` instead.\n+///\n #[inline(always)]\n pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n@@ -604,46 +604,46 @@ pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix, and a flag indicating\n- * whether it's a special value\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- */\n+///\n+/// Converts a float to a string in a given radix, and a flag indicating\n+/// whether it's a special value\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n #[inline(always)]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n-/**\n- * Converts a float to a string with exactly the number of\n- * provided significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with exactly the number of\n+/// provided significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n-/**\n- * Converts a float to a string with a maximum number of\n- * significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with a maximum number of\n+/// significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n@@ -663,91 +663,91 @@ impl num::ToStrRadix for f64 {\n     }\n }\n \n-/**\n- * Convert a string in base 10 to a float.\n- * Accepts a optional decimal exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * '3.14'\n- * * '+3.14', equivalent to '3.14'\n- * * '-3.14'\n- * * '2.5E10', or equivalently, '2.5e10'\n- * * '2.5E-10'\n- * * '.' (understood as 0)\n- * * '5.'\n- * * '.5', or, equivalently,  '0.5'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in base 10 to a float.\n+/// Accepts a optional decimal exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * '3.14'\n+/// * '+3.14', equivalent to '3.14'\n+/// * '-3.14'\n+/// * '2.5E10', or equivalently, '2.5e10'\n+/// * '2.5E-10'\n+/// * '.' (understood as 0)\n+/// * '5.'\n+/// * '.5', or, equivalently,  '0.5'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n }\n \n-/**\n- * Convert a string in base 16 to a float.\n- * Accepts a optional binary exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * 'a4.fe'\n- * * '+a4.fe', equivalent to 'a4.fe'\n- * * '-a4.fe'\n- * * '2b.aP128', or equivalently, '2b.ap128'\n- * * '2b.aP-128'\n- * * '.' (understood as 0)\n- * * 'c.'\n- * * '.c', or, equivalently,  '0.c'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n- */\n+///\n+/// Convert a string in base 16 to a float.\n+/// Accepts a optional binary exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * 'a4.fe'\n+/// * '+a4.fe', equivalent to 'a4.fe'\n+/// * '-a4.fe'\n+/// * '2b.aP128', or equivalently, '2b.ap128'\n+/// * '2b.aP-128'\n+/// * '.' (understood as 0)\n+/// * 'c.'\n+/// * '.c', or, equivalently,  '0.c'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+///\n #[inline(always)]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n-/**\n- * Convert a string in an given base to a float.\n- *\n- * Due to possible conflicts, this function does **not** accept\n- * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n- * does it recognize exponents of any kind.\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- * * radix - The base to use. Must lie in the range [2 .. 36]\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number. Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in an given base to a float.\n+///\n+/// Due to possible conflicts, this function does **not** accept\n+/// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+/// does it recognize exponents of any kind.\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+/// * radix - The base to use. Must lie in the range [2 .. 36]\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number. Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n     strconv::from_str_common(num, rdx, true, true, false,"}, {"sha": "d5f22e6b056c27dc59d3450cc6695aa5024558c3", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 155, "deletions": 155, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=dbc2e99693eb20da9b9823bc11953835b156802f", "patch": "@@ -84,52 +84,52 @@ pub mod consts {\n     pub static ln_10: float = 2.30258509299404568401799145468436421;\n }\n \n-/*\n- * Section: String Conversions\n- */\n-\n-/**\n- * Converts a float to a string\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+//\n+// Section: String Conversions\n+//\n+\n+///\n+/// Converts a float to a string\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in hexadecimal format\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string in hexadecimal format\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str_hex(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- *\n- * # Failure\n- *\n- * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n- * possible misinterpretation of the result at higher bases. If those values\n- * are expected, use `to_str_radix_special()` instead.\n- */\n+///\n+/// Converts a float to a string in a given radix\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n+/// # Failure\n+///\n+/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+/// possible misinterpretation of the result at higher bases. If those values\n+/// are expected, use `to_str_radix_special()` instead.\n+///\n #[inline(always)]\n pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n@@ -139,46 +139,46 @@ pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix, and a flag indicating\n- * whether it's a special value\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- */\n+///\n+/// Converts a float to a string in a given radix, and a flag indicating\n+/// whether it's a special value\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n #[inline(always)]\n pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, radix, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n-/**\n- * Converts a float to a string with exactly the number of\n- * provided significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with exactly the number of\n+/// provided significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n     r\n }\n \n-/**\n- * Converts a float to a string with a maximum number of\n- * significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with a maximum number of\n+/// significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_digits(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n@@ -198,91 +198,91 @@ impl num::ToStrRadix for float {\n     }\n }\n \n-/**\n- * Convert a string in base 10 to a float.\n- * Accepts a optional decimal exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * '3.14'\n- * * '+3.14', equivalent to '3.14'\n- * * '-3.14'\n- * * '2.5E10', or equivalently, '2.5e10'\n- * * '2.5E-10'\n- * * '.' (understood as 0)\n- * * '5.'\n- * * '.5', or, equivalently,  '0.5'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in base 10 to a float.\n+/// Accepts a optional decimal exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * '3.14'\n+/// * '+3.14', equivalent to '3.14'\n+/// * '-3.14'\n+/// * '2.5E10', or equivalently, '2.5e10'\n+/// * '2.5E-10'\n+/// * '.' (understood as 0)\n+/// * '5.'\n+/// * '.5', or, equivalently,  '0.5'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n }\n \n-/**\n- * Convert a string in base 16 to a float.\n- * Accepts a optional binary exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * 'a4.fe'\n- * * '+a4.fe', equivalent to 'a4.fe'\n- * * '-a4.fe'\n- * * '2b.aP128', or equivalently, '2b.ap128'\n- * * '2b.aP-128'\n- * * '.' (understood as 0)\n- * * 'c.'\n- * * '.c', or, equivalently,  '0.c'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n- */\n+///\n+/// Convert a string in base 16 to a float.\n+/// Accepts a optional binary exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * 'a4.fe'\n+/// * '+a4.fe', equivalent to 'a4.fe'\n+/// * '-a4.fe'\n+/// * '2b.aP128', or equivalently, '2b.ap128'\n+/// * '2b.aP-128'\n+/// * '.' (understood as 0)\n+/// * 'c.'\n+/// * '.c', or, equivalently,  '0.c'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+///\n #[inline(always)]\n pub fn from_str_hex(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n-/**\n- * Convert a string in an given base to a float.\n- *\n- * Due to possible conflicts, this function does **not** accept\n- * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n- * does it recognize exponents of any kind.\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- * * radix - The base to use. Must lie in the range [2 .. 36]\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number. Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in an given base to a float.\n+///\n+/// Due to possible conflicts, this function does **not** accept\n+/// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+/// does it recognize exponents of any kind.\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+/// * radix - The base to use. Must lie in the range [2 .. 36]\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number. Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n     strconv::from_str_common(num, radix, true, true, false,\n@@ -301,22 +301,22 @@ impl num::FromStrRadix for float {\n     }\n }\n \n-/**\n- * Section: Arithmetics\n- */\n-\n-/**\n- * Compute the exponentiation of an integer by another integer as a float\n- *\n- * # Arguments\n- *\n- * * x - The base\n- * * pow - The exponent\n- *\n- * # Return value\n- *\n- * `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n- */\n+//\n+// Section: Arithmetics\n+//\n+\n+///\n+/// Compute the exponentiation of an integer by another integer as a float\n+///\n+/// # Arguments\n+///\n+/// * x - The base\n+/// * pow - The exponent\n+///\n+/// # Return value\n+///\n+/// `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n+///\n pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {\n@@ -668,13 +668,13 @@ impl Signed for float {\n     #[inline(always)]\n     fn abs(&self) -> float { abs(*self) }\n \n-    /**\n-     * # Returns\n-     *\n-     * - `1.0` if the number is positive, `+0.0` or `infinity`\n-     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-     * - `NaN` if the number is NaN\n-     */\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n+    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+    /// - `NaN` if the number is NaN\n+    ///\n     #[inline(always)]\n     fn signum(&self) -> float {\n         if is_NaN(*self) { NaN } else { f64::copysign(1.0, *self as f64) as float }"}, {"sha": "75d170118e6723607a6adebbc06ee7dc599d40bd", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 136, "deletions": 136, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=dbc2e99693eb20da9b9823bc11953835b156802f", "patch": "@@ -32,26 +32,26 @@ pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n pub fn quot(x: T, y: T) -> T { x / y }\n \n-/**\n- * Returns the remainder of y / x.\n- *\n- * # Examples\n- * ~~~\n- * assert!(int::rem(5 / 2) == 1);\n- * ~~~\n- *\n- * When faced with negative numbers, the result copies the sign of the\n- * dividend.\n- *\n- * ~~~\n- * assert!(int::rem(2 / -3) ==  2);\n- * ~~~\n- *\n- * ~~~\n- * assert!(int::rem(-2 / 3) ==  -2);\n- * ~~~\n- *\n- */\n+///\n+/// Returns the remainder of y / x.\n+///\n+/// # Examples\n+/// ~~~\n+/// assert!(int::rem(5 / 2) == 1);\n+/// ~~~\n+///\n+/// When faced with negative numbers, the result copies the sign of the\n+/// dividend.\n+///\n+/// ~~~\n+/// assert!(int::rem(2 / -3) ==  2);\n+/// ~~~\n+///\n+/// ~~~\n+/// assert!(int::rem(-2 / 3) ==  -2);\n+/// ~~~\n+///\n+///\n #[inline(always)]\n pub fn rem(x: T, y: T) -> T { x % y }\n \n@@ -68,23 +68,23 @@ pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n pub fn gt(x: T, y: T) -> bool { x > y }\n \n-/**\n- * Iterate over the range [`lo`..`hi`)\n- *\n- * # Arguments\n- *\n- * * `lo` - lower bound, inclusive\n- * * `hi` - higher bound, exclusive\n- *\n- * # Examples\n- * ~~~\n- * let mut sum = 0;\n- * for int::range(1, 5) |i| {\n- *     sum += i;\n- * }\n- * assert!(sum == 10);\n- * ~~~\n- */\n+///\n+/// Iterate over the range [`lo`..`hi`)\n+///\n+/// # Arguments\n+///\n+/// * `lo` - lower bound, inclusive\n+/// * `hi` - higher bound, exclusive\n+///\n+/// # Examples\n+/// ~~~\n+/// let mut sum = 0;\n+/// for int::range(1, 5) |i| {\n+///     sum += i;\n+/// }\n+/// assert!(sum == 10);\n+/// ~~~\n+///\n #[inline(always)]\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n@@ -190,24 +190,24 @@ impl Div<T,T> for T {\n }\n #[cfg(not(stage0),notest)]\n impl Quot<T,T> for T {\n-    /**\n-     * Returns the integer quotient, truncated towards 0. As this behaviour reflects\n-     * the underlying machine implementation it is more efficient than `Natural::div`.\n-     *\n-     * # Examples\n-     *\n-     * ~~~\n-     * assert!( 8 /  3 ==  2);\n-     * assert!( 8 / -3 == -2);\n-     * assert!(-8 /  3 == -2);\n-     * assert!(-8 / -3 ==  2);\n-\n-     * assert!( 1 /  2 ==  0);\n-     * assert!( 1 / -2 ==  0);\n-     * assert!(-1 /  2 ==  0);\n-     * assert!(-1 / -2 ==  0);\n-     * ~~~\n-     */\n+    ///\n+    /// Returns the integer quotient, truncated towards 0. As this behaviour reflects\n+    /// the underlying machine implementation it is more efficient than `Natural::div`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!( 8 /  3 ==  2);\n+    /// assert!( 8 / -3 == -2);\n+    /// assert!(-8 /  3 == -2);\n+    /// assert!(-8 / -3 ==  2);\n+\n+    /// assert!( 1 /  2 ==  0);\n+    /// assert!( 1 / -2 ==  0);\n+    /// assert!(-1 /  2 ==  0);\n+    /// assert!(-1 / -2 ==  0);\n+    /// ~~~\n+    ///\n     #[inline(always)]\n     fn quot(&self, other: &T) -> T { *self / *other }\n }\n@@ -219,27 +219,27 @@ impl Modulo<T,T> for T {\n }\n #[cfg(not(stage0),notest)]\n impl Rem<T,T> for T {\n-    /**\n-     * Returns the integer remainder after division, satisfying:\n-     *\n-     * ~~~\n-     * assert!((n / d) * d + (n % d) == n)\n-     * ~~~\n-     *\n-     * # Examples\n-     *\n-     * ~~~\n-     * assert!( 8 %  3 ==  2);\n-     * assert!( 8 % -3 ==  2);\n-     * assert!(-8 %  3 == -2);\n-     * assert!(-8 % -3 == -2);\n-\n-     * assert!( 1 %  2 ==  1);\n-     * assert!( 1 % -2 ==  1);\n-     * assert!(-1 %  2 == -1);\n-     * assert!(-1 % -2 == -1);\n-     * ~~~\n-     */\n+    ///\n+    /// Returns the integer remainder after division, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!((n / d) * d + (n % d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!( 8 %  3 ==  2);\n+    /// assert!( 8 % -3 ==  2);\n+    /// assert!(-8 %  3 == -2);\n+    /// assert!(-8 % -3 == -2);\n+\n+    /// assert!( 1 %  2 ==  1);\n+    /// assert!( 1 % -2 ==  1);\n+    /// assert!(-1 %  2 == -1);\n+    /// assert!(-1 % -2 == -1);\n+    /// ~~~\n+    ///\n     #[inline(always)]\n     fn rem(&self, other: &T) -> T { *self % *other }\n }\n@@ -257,13 +257,13 @@ impl Signed for T {\n         if self.is_negative() { -*self } else { *self }\n     }\n \n-    /**\n-     * # Returns\n-     *\n-     * - `0` if the number is zero\n-     * - `1` if the number is positive\n-     * - `-1` if the number is negative\n-     */\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `0` if the number is zero\n+    /// - `1` if the number is positive\n+    /// - `-1` if the number is negative\n+    ///\n     #[inline(always)]\n     fn signum(&self) -> T {\n         match *self {\n@@ -283,23 +283,23 @@ impl Signed for T {\n }\n \n impl Integer for T {\n-    /**\n-     * Floored integer division\n-     *\n-     * # Examples\n-     *\n-     * ~~~\n-     * assert!(( 8).div( 3) ==  2);\n-     * assert!(( 8).div(-3) == -3);\n-     * assert!((-8).div( 3) == -3);\n-     * assert!((-8).div(-3) ==  2);\n-     *\n-     * assert!(( 1).div( 2) ==  0);\n-     * assert!(( 1).div(-2) == -1);\n-     * assert!((-1).div( 2) == -1);\n-     * assert!((-1).div(-2) ==  0);\n-     * ~~~\n-     */\n+    ///\n+    /// Floored integer division\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!(( 8).div( 3) ==  2);\n+    /// assert!(( 8).div(-3) == -3);\n+    /// assert!((-8).div( 3) == -3);\n+    /// assert!((-8).div(-3) ==  2);\n+    ///\n+    /// assert!(( 1).div( 2) ==  0);\n+    /// assert!(( 1).div(-2) == -1);\n+    /// assert!((-1).div( 2) == -1);\n+    /// assert!((-1).div(-2) ==  0);\n+    /// ~~~\n+    ///\n     #[inline(always)]\n     fn div(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n@@ -311,27 +311,27 @@ impl Integer for T {\n         }\n     }\n \n-    /**\n-     * Integer modulo, satisfying:\n-     *\n-     * ~~~\n-     * assert!(n.div(d) * d + n.modulo(d) == n)\n-     * ~~~\n-     *\n-     * # Examples\n-     *\n-     * ~~~\n-     * assert!(( 8).modulo( 3) ==  2);\n-     * assert!(( 8).modulo(-3) == -1);\n-     * assert!((-8).modulo( 3) ==  1);\n-     * assert!((-8).modulo(-3) == -2);\n-     *\n-     * assert!(( 1).modulo( 2) ==  1);\n-     * assert!(( 1).modulo(-2) == -1);\n-     * assert!((-1).modulo( 2) ==  1);\n-     * assert!((-1).modulo(-2) == -1);\n-     * ~~~\n-     */\n+    ///\n+    /// Integer modulo, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!(n.div(d) * d + n.modulo(d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!(( 8).modulo( 3) ==  2);\n+    /// assert!(( 8).modulo(-3) == -1);\n+    /// assert!((-8).modulo( 3) ==  1);\n+    /// assert!((-8).modulo(-3) == -2);\n+    ///\n+    /// assert!(( 1).modulo( 2) ==  1);\n+    /// assert!(( 1).modulo(-2) == -1);\n+    /// assert!((-1).modulo( 2) ==  1);\n+    /// assert!((-1).modulo(-2) == -1);\n+    /// ~~~\n+    ///\n     #[inline(always)]\n     fn modulo(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n@@ -361,11 +361,11 @@ impl Integer for T {\n         (*self / *other, *self % *other)\n     }\n \n-    /**\n-     * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-     *\n-     * The result is always positive\n-     */\n+    ///\n+    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+    ///\n+    /// The result is always positive\n+    ///\n     #[inline(always)]\n     fn gcd(&self, other: &T) -> T {\n         // Use Euclid's algorithm\n@@ -378,9 +378,9 @@ impl Integer for T {\n         n.abs()\n     }\n \n-    /**\n-     * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n-     */\n+    ///\n+    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+    ///\n     #[inline(always)]\n     fn lcm(&self, other: &T) -> T {\n         ((*self * *other) / self.gcd(other)).abs() // should not have to recaluculate abs\n@@ -545,13 +545,13 @@ mod tests {\n         assert!((-1 as T).is_negative());\n     }\n \n-    /**\n-     * Checks that the division rule holds for:\n-     *\n-     * - `n`: numerator (dividend)\n-     * - `d`: denominator (divisor)\n-     * - `qr`: quotient and remainder\n-     */\n+    ///\n+    /// Checks that the division rule holds for:\n+    ///\n+    /// - `n`: numerator (dividend)\n+    /// - `d`: denominator (divisor)\n+    /// - `qr`: quotient and remainder\n+    ///\n     #[cfg(test)]\n     fn test_division_rule(nd: (T,T), qr: (T,T)) {\n         let (n,d) = nd,"}, {"sha": "5797d86e6ec36cb0270f6dafe35439dfd122044e", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=dbc2e99693eb20da9b9823bc11953835b156802f", "patch": "@@ -153,7 +153,9 @@ pub trait Real: Signed\n     fn tanh(&self) -> Self;\n }\n \n+///\n /// Methods that are harder to implement and not commonly used.\n+///\n pub trait RealExt: Real {\n     // FIXME (#5527): usages of `int` should be replaced with an associated\n     // integer type once these are implemented\n@@ -171,24 +173,24 @@ pub trait RealExt: Real {\n     fn yn(&self, n: int) -> Self;\n }\n \n-/**\n- * Cast from one machine scalar to another\n- *\n- * # Example\n- *\n- * ~~~\n- * let twenty: f32 = num::cast(0x14);\n- * assert_eq!(twenty, 20f32);\n- * ~~~\n- */\n+///\n+/// Cast from one machine scalar to another\n+///\n+/// # Example\n+///\n+/// ~~~\n+/// let twenty: f32 = num::cast(0x14);\n+/// assert_eq!(twenty, 20f32);\n+/// ~~~\n+///\n #[inline(always)]\n pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n     NumCast::from(n)\n }\n \n-/**\n- * An interface for casting between machine scalars\n- */\n+///\n+/// An interface for casting between machine scalars\n+///\n pub trait NumCast {\n     fn from<T:NumCast>(n: T) -> Self;\n \n@@ -260,21 +262,19 @@ pub trait FromStrRadix {\n     pub fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n-// Generic math functions:\n-\n-/**\n- * Calculates a power to a given radix, optimized for uint `pow` and `radix`.\n- *\n- * Returns `radix^pow` as `T`.\n- *\n- * Note:\n- * Also returns `1` for `0^0`, despite that technically being an\n- * undefined number. The reason for this is twofold:\n- * - If code written to use this function cares about that special case, it's\n- *   probably going to catch it before making the call.\n- * - If code written to use this function doesn't care about it, it's\n- *   probably assuming that `x^0` always equals `1`.\n- */\n+///\n+/// Calculates a power to a given radix, optimized for uint `pow` and `radix`.\n+///\n+/// Returns `radix^pow` as `T`.\n+///\n+/// Note:\n+/// Also returns `1` for `0^0`, despite that technically being an\n+/// undefined number. The reason for this is twofold:\n+/// - If code written to use this function cares about that special case, it's\n+///   probably going to catch it before making the call.\n+/// - If code written to use this function doesn't care about it, it's\n+///   probably assuming that `x^0` always equals `1`.\n+///\n pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Quot<T,T>+Mul<T,T>>(\n     radix: uint, pow: uint) -> T {\n     let _0: T = Zero::zero();"}, {"sha": "ed0a5aa387684000fd8490930412745f8ac2b441", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=dbc2e99693eb20da9b9823bc11953835b156802f", "patch": "@@ -49,10 +49,9 @@ pub fn ge(x: T, y: T) -> bool { x >= y }\n pub fn gt(x: T, y: T) -> bool { x > y }\n \n #[inline(always)]\n-/**\n- * Iterate over the range [`start`,`start`+`step`..`stop`)\n- *\n- */\n+///\n+/// Iterate over the range [`start`,`start`+`step`..`stop`)\n+///\n pub fn range_step(start: T,\n                        stop: T,\n                        step: T_SIGNED,"}, {"sha": "5eaa27fb7a05df6696cfb3f474b2a5bdd8034cc2", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc2e99693eb20da9b9823bc11953835b156802f/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=dbc2e99693eb20da9b9823bc11953835b156802f", "patch": "@@ -31,74 +31,74 @@ pub mod inst {\n     #[cfg(target_arch = \"x86_64\")]\n     pub static bits: uint = 64;\n \n-    /**\n-    * Divide two numbers, return the result, rounded up.\n-    *\n-    * # Arguments\n-    *\n-    * * x - an integer\n-    * * y - an integer distinct from 0u\n-    *\n-    * # Return value\n-    *\n-    * The smallest integer `q` such that `x/y <= q`.\n-    */\n+    ///\n+    /// Divide two numbers, return the result, rounded up.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * x - an integer\n+    /// * y - an integer distinct from 0u\n+    ///\n+    /// # Return value\n+    ///\n+    /// The smallest integer `q` such that `x/y <= q`.\n+    ///\n     pub fn div_ceil(x: uint, y: uint) -> uint {\n         let div = x / y;\n         if x % y == 0u { div }\n         else { div + 1u }\n     }\n \n-    /**\n-    * Divide two numbers, return the result, rounded to the closest integer.\n-    *\n-    * # Arguments\n-    *\n-    * * x - an integer\n-    * * y - an integer distinct from 0u\n-    *\n-    * # Return value\n-    *\n-    * The integer `q` closest to `x/y`.\n-    */\n+    ///\n+    /// Divide two numbers, return the result, rounded to the closest integer.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * x - an integer\n+    /// * y - an integer distinct from 0u\n+    ///\n+    /// # Return value\n+    ///\n+    /// The integer `q` closest to `x/y`.\n+    ///\n     pub fn div_round(x: uint, y: uint) -> uint {\n         let div = x / y;\n         if x % y * 2u  < y { div }\n         else { div + 1u }\n     }\n \n-    /**\n-    * Divide two numbers, return the result, rounded down.\n-    *\n-    * Note: This is the same function as `div`.\n-    *\n-    * # Arguments\n-    *\n-    * * x - an integer\n-    * * y - an integer distinct from 0u\n-    *\n-    * # Return value\n-    *\n-    * The smallest integer `q` such that `x/y <= q`. This\n-    * is either `x/y` or `x/y + 1`.\n-    */\n+    ///\n+    /// Divide two numbers, return the result, rounded down.\n+    ///\n+    /// Note: This is the same function as `div`.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * x - an integer\n+    /// * y - an integer distinct from 0u\n+    ///\n+    /// # Return value\n+    ///\n+    /// The smallest integer `q` such that `x/y <= q`. This\n+    /// is either `x/y` or `x/y + 1`.\n+    ///\n     pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n-    /**\n-    * Iterate over the range [`lo`..`hi`), or stop when requested\n-    *\n-    * # Arguments\n-    *\n-    * * lo - The integer at which to start the loop (included)\n-    * * hi - The integer at which to stop the loop (excluded)\n-    * * it - A block to execute with each consecutive integer of the range.\n-    *        Return `true` to continue, `false` to stop.\n-    *\n-    * # Return value\n-    *\n-    * `true` If execution proceeded correctly, `false` if it was interrupted,\n-    * that is if `it` returned `false` at any point.\n-    */\n+    ///\n+    /// Iterate over the range [`lo`..`hi`), or stop when requested\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * lo - The integer at which to start the loop (included)\n+    /// * hi - The integer at which to stop the loop (excluded)\n+    /// * it - A block to execute with each consecutive integer of the range.\n+    ///        Return `true` to continue, `false` to stop.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `true` If execution proceeded correctly, `false` if it was interrupted,\n+    /// that is if `it` returned `false` at any point.\n+    ///\n     pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n         let mut i = lo;\n         while i < hi {\n@@ -110,16 +110,16 @@ pub mod inst {\n \n     impl iter::Times for uint {\n         #[inline(always)]\n-        /**\n-        * A convenience form for basic iteration. Given a uint `x`,\n-        * `for x.times { ... }` executes the given block x times.\n-        *\n-        * Equivalent to `for uint::range(0, x) |_| { ... }`.\n-        *\n-        * Not defined on all integer types to permit unambiguous\n-        * use with integer literals of inferred integer-type as\n-        * the self-value (eg. `for 100.times { ... }`).\n-        */\n+        ///\n+        /// A convenience form for basic iteration. Given a uint `x`,\n+        /// `for x.times { ... }` executes the given block x times.\n+        ///\n+        /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n+        ///\n+        /// Not defined on all integer types to permit unambiguous\n+        /// use with integer literals of inferred integer-type as\n+        /// the self-value (eg. `for 100.times { ... }`).\n+        ///\n         fn times(&self, it: &fn() -> bool) {\n             let mut i = *self;\n             while i > 0 {"}]}