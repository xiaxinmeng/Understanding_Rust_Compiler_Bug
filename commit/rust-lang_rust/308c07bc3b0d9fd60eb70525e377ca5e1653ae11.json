{"sha": "308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwOGMwN2JjM2IwZDlmZDYwZWI3MDUyNWUzNzdjYTVlMTY1M2FlMTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-12T03:42:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-12T03:42:24Z"}, "message": "Rollup merge of #58318 - taiki-e:libserialize-2018, r=Centril\n\nlibserialize => 2018\n\nTransitions `libserialize` to Rust 2018; cc #58099\n\nThis includes a commit from #58252 (thanks @h-michael!)\n\nr? @Centril", "tree": {"sha": "6cbfab31138231affb233f4f505fab758933dcec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cbfab31138231affb233f4f505fab758933dcec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcYkCgCRBK7hj4Ov3rIwAAdHIIAEbQVyUPwBcXjmR/COof0dv6\nZc1mLvpRjEjEx9IRZLfe1eRwRqneuAPnFWozQhwolH+aI5xVaVCLb4usgYowLqri\nPWAmP+e6SbjzR7+aBNLoDMcjX/D5qbOTYz4EHXsH8XaQamwMaVl1QgQnDfoZBVOO\ntSJv3Oe4pEk0pKmao5soabDhMEJLXlahdxjyv2XUJ3fNnzyLeyYwV1VzbDeZrfp9\nJgfiW4B1NjirfTjpCgY/PpGxFYn9Bm3HivuDst5gWSvnUJtxIv2KovbbcwF8VHW8\ng8x0JM3c/SwiC5Q7IM7lBRYgBtcR01Ilx0NrL+04/r1CNqZdJ0zmLYEZCddFuO8=\n=9E+F\n-----END PGP SIGNATURE-----\n", "payload": "tree 6cbfab31138231affb233f4f505fab758933dcec\nparent d9434531db3ab89207c63d97f2026c8365b28f7e\nparent 06b63046b298fad478e69007ee207396bc1a9a2d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1549942944 +0100\ncommitter GitHub <noreply@github.com> 1549942944 +0100\n\nRollup merge of #58318 - taiki-e:libserialize-2018, r=Centril\n\nlibserialize => 2018\n\nTransitions `libserialize` to Rust 2018; cc #58099\n\nThis includes a commit from #58252 (thanks @h-michael!)\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "html_url": "https://github.com/rust-lang/rust/commit/308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9434531db3ab89207c63d97f2026c8365b28f7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9434531db3ab89207c63d97f2026c8365b28f7e", "html_url": "https://github.com/rust-lang/rust/commit/d9434531db3ab89207c63d97f2026c8365b28f7e"}, {"sha": "06b63046b298fad478e69007ee207396bc1a9a2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/06b63046b298fad478e69007ee207396bc1a9a2d", "html_url": "https://github.com/rust-lang/rust/commit/06b63046b298fad478e69007ee207396bc1a9a2d"}], "stats": {"total": 3216, "additions": 1607, "deletions": 1609}, "files": [{"sha": "949af0e2b97464a9c030c054cb9fca16b004569e", "filename": "src/libserialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2FCargo.toml?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"serialize\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"serialize\""}, {"sha": "c0a8fa9d0016dba395a62aa036d90b78f6b54e9c", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -2,7 +2,7 @@\n \n use std::hash::{Hash, BuildHasher};\n \n-use {Decodable, Encodable, Decoder, Encoder};\n+use crate::{Decodable, Encodable, Decoder, Encoder};\n use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet};\n use std::rc::Rc;\n use std::sync::Arc;"}, {"sha": "73b9122b13cea679a18d6c4974b580f87d4717a7", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -60,7 +60,7 @@ pub enum FromHexError {\n }\n \n impl fmt::Display for FromHexError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             InvalidHexCharacter(ch, idx) =>\n                 write!(f, \"Invalid character '{}' at position {}\", ch, idx),\n@@ -145,8 +145,8 @@ impl FromHex for str {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use self::test::Bencher;\n-    use hex::{FromHex, ToHex};\n+    use test::Bencher;\n+    use crate::hex::{FromHex, ToHex};\n \n     #[test]\n     pub fn test_to_hex() {"}, {"sha": "5b3444b9f456f33d94ac14f6db30bb8faa26d144", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 32, "deletions": 1310, "changes": 1342, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -199,9 +199,8 @@ use std::ops::Index;\n use std::str::FromStr;\n use std::string;\n use std::{char, f64, fmt, str};\n-use std;\n \n-use Encodable;\n+use crate::Encodable;\n \n /// Represents a json value\n #[derive(Clone, PartialEq, PartialOrd, Debug)]\n@@ -221,8 +220,8 @@ pub type Object = BTreeMap<string::String, Json>;\n \n pub struct PrettyJson<'a> { inner: &'a Json }\n \n-pub struct AsJson<'a, T: 'a> { inner: &'a T }\n-pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<usize> }\n+pub struct AsJson<'a, T> { inner: &'a T }\n+pub struct AsPrettyJson<'a, T> { inner: &'a T, indent: Option<usize> }\n \n /// The errors that can arise while parsing a JSON stream.\n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -295,18 +294,18 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n }\n \n /// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: ::Decodable>(s: &str) -> DecodeResult<T> {\n+pub fn decode<T: crate::Decodable>(s: &str) -> DecodeResult<T> {\n     let json = match from_str(s) {\n         Ok(x) => x,\n         Err(e) => return Err(ParseError(e))\n     };\n \n     let mut decoder = Decoder::new(json);\n-    ::Decodable::decode(&mut decoder)\n+    crate::Decodable::decode(&mut decoder)\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n+pub fn encode<T: crate::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n     let mut s = String::new();\n     {\n         let mut encoder = Encoder::new(&mut s);\n@@ -316,7 +315,7 @@ pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError\n }\n \n impl fmt::Display for ErrorCode {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         error_str(*self).fmt(f)\n     }\n }\n@@ -326,14 +325,14 @@ fn io_error_to_error(io: io::Error) -> ParserError {\n }\n \n impl fmt::Display for ParserError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n }\n \n impl fmt::Display for DecoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n@@ -344,7 +343,7 @@ impl std::error::Error for DecoderError {\n }\n \n impl fmt::Display for EncoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n@@ -477,7 +476,7 @@ macro_rules! emit_enquoted_if_mapkey {\n     })\n }\n \n-impl<'a> ::Encoder for Encoder<'a> {\n+impl<'a> crate::Encoder for Encoder<'a> {\n     type Error = EncoderError;\n \n     fn emit_unit(&mut self) -> EncodeResult {\n@@ -727,7 +726,7 @@ impl<'a> PrettyEncoder<'a> {\n     }\n }\n \n-impl<'a> ::Encoder for PrettyEncoder<'a> {\n+impl<'a> crate::Encoder for PrettyEncoder<'a> {\n     type Error = EncoderError;\n \n     fn emit_unit(&mut self) -> EncodeResult {\n@@ -997,7 +996,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n }\n \n impl Encodable for Json {\n-    fn encode<E: ::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode<E: crate::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         match *self {\n             Json::I64(v) => v.encode(e),\n             Json::U64(v) => v.encode(e),\n@@ -1013,20 +1012,20 @@ impl Encodable for Json {\n \n /// Create an `AsJson` wrapper which can be used to print a value as JSON\n /// on-the-fly via `write!`\n-pub fn as_json<T>(t: &T) -> AsJson<T> {\n+pub fn as_json<T>(t: &T) -> AsJson<'_, T> {\n     AsJson { inner: t }\n }\n \n /// Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\n /// on-the-fly via `write!`\n-pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<T> {\n+pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<'_, T> {\n     AsPrettyJson { inner: t, indent: None }\n }\n \n impl Json {\n     /// Borrow this json object as a pretty object to generate a pretty\n     /// representation for it via `Display`.\n-    pub fn pretty(&self) -> PrettyJson {\n+    pub fn pretty(&self) -> PrettyJson<'_> {\n         PrettyJson { inner: self }\n     }\n \n@@ -1300,7 +1299,7 @@ impl Stack {\n     /// Provides access to the StackElement at a given index.\n     /// lower indices are at the bottom of the stack while higher indices are\n     /// at the top.\n-    pub fn get(&self, idx: usize) -> StackElement {\n+    pub fn get(&self, idx: usize) -> StackElement<'_> {\n         match self.stack[idx] {\n             InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n@@ -1311,8 +1310,8 @@ impl Stack {\n         }\n     }\n \n-    /// Compares this stack with an array of StackElements.\n-    pub fn is_equal_to(&self, rhs: &[StackElement]) -> bool {\n+    /// Compares this stack with an array of StackElement<'_>s.\n+    pub fn is_equal_to(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() != rhs.len() { return false; }\n         for (i, r) in rhs.iter().enumerate() {\n             if self.get(i) != *r { return false; }\n@@ -1322,7 +1321,7 @@ impl Stack {\n \n     /// Returns true if the bottom-most elements of this stack are the same as\n     /// the ones passed as parameter.\n-    pub fn starts_with(&self, rhs: &[StackElement]) -> bool {\n+    pub fn starts_with(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n         for (i, r) in rhs.iter().enumerate() {\n             if self.get(i) != *r { return false; }\n@@ -1332,7 +1331,7 @@ impl Stack {\n \n     /// Returns true if the top-most elements of this stack are the same as\n     /// the ones passed as parameter.\n-    pub fn ends_with(&self, rhs: &[StackElement]) -> bool {\n+    pub fn ends_with(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n         let offset = self.stack.len() - rhs.len();\n         for (i, r) in rhs.iter().enumerate() {\n@@ -1342,7 +1341,7 @@ impl Stack {\n     }\n \n     /// Returns the top-most element (if any).\n-    pub fn top(&self) -> Option<StackElement> {\n+    pub fn top(&self) -> Option<StackElement<'_>> {\n         match self.stack.last() {\n             None => None,\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n@@ -2115,7 +2114,7 @@ macro_rules! read_primitive {\n     }\n }\n \n-impl ::Decoder for Decoder {\n+impl crate::Decoder for Decoder {\n     type Error = DecoderError;\n \n     fn read_nil(&mut self) -> DecodeResult<()> {\n@@ -2172,7 +2171,7 @@ impl ::Decoder for Decoder {\n         Err(ExpectedError(\"single character string\".to_owned(), s.to_string()))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<Cow<str>> {\n+    fn read_str(&mut self) -> DecodeResult<Cow<'_, str>> {\n         expect!(self.pop(), String).map(Cow::Owned)\n     }\n \n@@ -2518,7 +2517,7 @@ impl<'a, 'b> fmt::Write for FormatShim<'a, 'b> {\n \n impl fmt::Display for Json {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = Encoder::new(&mut shim);\n         match self.encode(&mut encoder) {\n@@ -2530,7 +2529,7 @@ impl fmt::Display for Json {\n \n impl<'a> fmt::Display for PrettyJson<'a> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = PrettyEncoder::new(&mut shim);\n         match self.inner.encode(&mut encoder) {\n@@ -2542,7 +2541,7 @@ impl<'a> fmt::Display for PrettyJson<'a> {\n \n impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = Encoder::new(&mut shim);\n         match self.inner.encode(&mut encoder) {\n@@ -2562,7 +2561,7 @@ impl<'a, T> AsPrettyJson<'a, T> {\n \n impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = PrettyEncoder::new(&mut shim);\n         if let Some(n) = self.indent {\n@@ -2584,1220 +2583,13 @@ impl FromStr for Json {\n \n #[cfg(test)]\n mod tests {\n+    // Benchmarks and tests that require private items\n+\n     extern crate test;\n-    use self::Animal::*;\n-    use self::test::Bencher;\n-    use {Encodable, Decodable};\n-    use super::Json::*;\n-    use super::ErrorCode::*;\n-    use super::ParserError::*;\n-    use super::DecoderError::*;\n-    use super::JsonEvent::*;\n-    use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n-                StackElement, Stack, Decoder, Encoder, EncoderError};\n-    use std::{i64, u64, f32, f64};\n-    use std::io::prelude::*;\n-    use std::collections::BTreeMap;\n+    use test::Bencher;\n+    use super::{from_str, Parser, StackElement, Stack};\n     use std::string;\n \n-    #[derive(RustcDecodable, Eq, PartialEq, Debug)]\n-    struct OptionData {\n-        opt: Option<usize>,\n-    }\n-\n-    #[test]\n-    fn test_decode_option_none() {\n-        let s =\"{}\";\n-        let obj: OptionData = super::decode(s).unwrap();\n-        assert_eq!(obj, OptionData { opt: None });\n-    }\n-\n-    #[test]\n-    fn test_decode_option_some() {\n-        let s = \"{ \\\"opt\\\": 10 }\";\n-        let obj: OptionData = super::decode(s).unwrap();\n-        assert_eq!(obj, OptionData { opt: Some(10) });\n-    }\n-\n-    #[test]\n-    fn test_decode_option_malformed() {\n-        check_err::<OptionData>(\"{ \\\"opt\\\": [] }\",\n-                                ExpectedError(\"Number\".to_string(), \"[]\".to_string()));\n-        check_err::<OptionData>(\"{ \\\"opt\\\": false }\",\n-                                ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n-    }\n-\n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-    enum Animal {\n-        Dog,\n-        Frog(string::String, isize)\n-    }\n-\n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-    struct Inner {\n-        a: (),\n-        b: usize,\n-        c: Vec<string::String>,\n-    }\n-\n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-    struct Outer {\n-        inner: Vec<Inner>,\n-    }\n-\n-    fn mk_object(items: &[(string::String, Json)]) -> Json {\n-        let mut d = BTreeMap::new();\n-\n-        for item in items {\n-            match *item {\n-                (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n-            }\n-        };\n-\n-        Object(d)\n-    }\n-\n-    #[test]\n-    fn test_from_str_trait() {\n-        let s = \"null\";\n-        assert!(s.parse::<Json>().unwrap() == s.parse().unwrap());\n-    }\n-\n-    #[test]\n-    fn test_write_null() {\n-        assert_eq!(Null.to_string(), \"null\");\n-        assert_eq!(Null.pretty().to_string(), \"null\");\n-    }\n-\n-    #[test]\n-    fn test_write_i64() {\n-        assert_eq!(U64(0).to_string(), \"0\");\n-        assert_eq!(U64(0).pretty().to_string(), \"0\");\n-\n-        assert_eq!(U64(1234).to_string(), \"1234\");\n-        assert_eq!(U64(1234).pretty().to_string(), \"1234\");\n-\n-        assert_eq!(I64(-5678).to_string(), \"-5678\");\n-        assert_eq!(I64(-5678).pretty().to_string(), \"-5678\");\n-\n-        assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n-        assert_eq!(U64(7650007200025252000).pretty().to_string(), \"7650007200025252000\");\n-    }\n-\n-    #[test]\n-    fn test_write_f64() {\n-        assert_eq!(F64(3.0).to_string(), \"3.0\");\n-        assert_eq!(F64(3.0).pretty().to_string(), \"3.0\");\n-\n-        assert_eq!(F64(3.1).to_string(), \"3.1\");\n-        assert_eq!(F64(3.1).pretty().to_string(), \"3.1\");\n-\n-        assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n-        assert_eq!(F64(-1.5).pretty().to_string(), \"-1.5\");\n-\n-        assert_eq!(F64(0.5).to_string(), \"0.5\");\n-        assert_eq!(F64(0.5).pretty().to_string(), \"0.5\");\n-\n-        assert_eq!(F64(f64::NAN).to_string(), \"null\");\n-        assert_eq!(F64(f64::NAN).pretty().to_string(), \"null\");\n-\n-        assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n-        assert_eq!(F64(f64::INFINITY).pretty().to_string(), \"null\");\n-\n-        assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n-        assert_eq!(F64(f64::NEG_INFINITY).pretty().to_string(), \"null\");\n-    }\n-\n-    #[test]\n-    fn test_write_str() {\n-        assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n-        assert_eq!(String(\"\".to_string()).pretty().to_string(), \"\\\"\\\"\");\n-\n-        assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n-        assert_eq!(String(\"madoka\".to_string()).pretty().to_string(), \"\\\"madoka\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_string(), \"true\");\n-        assert_eq!(Boolean(true).pretty().to_string(), \"true\");\n-\n-        assert_eq!(Boolean(false).to_string(), \"false\");\n-        assert_eq!(Boolean(false).pretty().to_string(), \"false\");\n-    }\n-\n-    #[test]\n-    fn test_write_array() {\n-        assert_eq!(Array(vec![]).to_string(), \"[]\");\n-        assert_eq!(Array(vec![]).pretty().to_string(), \"[]\");\n-\n-        assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n-        assert_eq!(\n-            Array(vec![Boolean(true)]).pretty().to_string(),\n-            \"\\\n-            [\\n  \\\n-                true\\n\\\n-            ]\"\n-        );\n-\n-        let long_test_array = Array(vec![\n-            Boolean(false),\n-            Null,\n-            Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n-\n-        assert_eq!(long_test_array.to_string(),\n-            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n-        assert_eq!(\n-            long_test_array.pretty().to_string(),\n-            \"\\\n-            [\\n  \\\n-                false,\\n  \\\n-                null,\\n  \\\n-                [\\n    \\\n-                    \\\"foo\\\\nbar\\\",\\n    \\\n-                    3.5\\n  \\\n-                ]\\n\\\n-            ]\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_write_object() {\n-        assert_eq!(mk_object(&[]).to_string(), \"{}\");\n-        assert_eq!(mk_object(&[]).pretty().to_string(), \"{}\");\n-\n-        assert_eq!(\n-            mk_object(&[\n-                (\"a\".to_string(), Boolean(true))\n-            ]).to_string(),\n-            \"{\\\"a\\\":true}\"\n-        );\n-        assert_eq!(\n-            mk_object(&[(\"a\".to_string(), Boolean(true))]).pretty().to_string(),\n-            \"\\\n-            {\\n  \\\n-                \\\"a\\\": true\\n\\\n-            }\"\n-        );\n-\n-        let complex_obj = mk_object(&[\n-                (\"b\".to_string(), Array(vec![\n-                    mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                    mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n-                ]))\n-            ]);\n-\n-        assert_eq!(\n-            complex_obj.to_string(),\n-            \"{\\\n-                \\\"b\\\":[\\\n-                    {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n-                    {\\\"d\\\":\\\"\\\"}\\\n-                ]\\\n-            }\"\n-        );\n-        assert_eq!(\n-            complex_obj.pretty().to_string(),\n-            \"\\\n-            {\\n  \\\n-                \\\"b\\\": [\\n    \\\n-                    {\\n      \\\n-                        \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n-                    },\\n    \\\n-                    {\\n      \\\n-                        \\\"d\\\": \\\"\\\"\\n    \\\n-                    }\\n  \\\n-                ]\\n\\\n-            }\"\n-        );\n-\n-        let a = mk_object(&[\n-            (\"a\".to_string(), Boolean(true)),\n-            (\"b\".to_string(), Array(vec![\n-                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n-            ]))\n-        ]);\n-\n-        // We can't compare the strings directly because the object fields be\n-        // printed in a different order.\n-        assert_eq!(a.clone(), a.to_string().parse().unwrap());\n-        assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());\n-    }\n-\n-    #[test]\n-    fn test_write_enum() {\n-        let animal = Dog;\n-        assert_eq!(\n-            super::as_json(&animal).to_string(),\n-            \"\\\"Dog\\\"\"\n-        );\n-        assert_eq!(\n-            super::as_pretty_json(&animal).to_string(),\n-            \"\\\"Dog\\\"\"\n-        );\n-\n-        let animal = Frog(\"Henry\".to_string(), 349);\n-        assert_eq!(\n-            super::as_json(&animal).to_string(),\n-            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n-        );\n-        assert_eq!(\n-            super::as_pretty_json(&animal).to_string(),\n-            \"{\\n  \\\n-               \\\"variant\\\": \\\"Frog\\\",\\n  \\\n-               \\\"fields\\\": [\\n    \\\n-                 \\\"Henry\\\",\\n    \\\n-                 349\\n  \\\n-               ]\\n\\\n-             }\"\n-        );\n-    }\n-\n-    macro_rules! check_encoder_for_simple {\n-        ($value:expr, $expected:expr) => ({\n-            let s = super::as_json(&$value).to_string();\n-            assert_eq!(s, $expected);\n-\n-            let s = super::as_pretty_json(&$value).to_string();\n-            assert_eq!(s, $expected);\n-        })\n-    }\n-\n-    #[test]\n-    fn test_write_some() {\n-        check_encoder_for_simple!(Some(\"jodhpurs\".to_string()), \"\\\"jodhpurs\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_none() {\n-        check_encoder_for_simple!(None::<string::String>, \"null\");\n-    }\n-\n-    #[test]\n-    fn test_write_char() {\n-        check_encoder_for_simple!('a', \"\\\"a\\\"\");\n-        check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n-        check_encoder_for_simple!('\\u{0000}', \"\\\"\\\\u0000\\\"\");\n-        check_encoder_for_simple!('\\u{001b}', \"\\\"\\\\u001b\\\"\");\n-        check_encoder_for_simple!('\\u{007f}', \"\\\"\\\\u007f\\\"\");\n-        check_encoder_for_simple!('\\u{00a0}', \"\\\"\\u{00a0}\\\"\");\n-        check_encoder_for_simple!('\\u{abcd}', \"\\\"\\u{abcd}\\\"\");\n-        check_encoder_for_simple!('\\u{10ffff}', \"\\\"\\u{10ffff}\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_trailing_characters() {\n-        assert_eq!(from_str(\"nulla\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n-        assert_eq!(from_str(\"truea\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n-        assert_eq!(from_str(\"falsea\"), Err(SyntaxError(TrailingCharacters, 1, 6)));\n-        assert_eq!(from_str(\"1a\"),     Err(SyntaxError(TrailingCharacters, 1, 2)));\n-        assert_eq!(from_str(\"[]a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n-        assert_eq!(from_str(\"{}a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n-    }\n-\n-    #[test]\n-    fn test_read_identifiers() {\n-        assert_eq!(from_str(\"n\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(from_str(\"nul\"),  Err(SyntaxError(InvalidSyntax, 1, 4)));\n-        assert_eq!(from_str(\"t\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(from_str(\"truz\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-        assert_eq!(from_str(\"f\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(from_str(\"faz\"),  Err(SyntaxError(InvalidSyntax, 1, 3)));\n-\n-        assert_eq!(from_str(\"null\"), Ok(Null));\n-        assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n-        assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n-        assert_eq!(from_str(\" null \"), Ok(Null));\n-        assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n-        assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n-    }\n-\n-    #[test]\n-    fn test_decode_identifiers() {\n-        let v: () = super::decode(\"null\").unwrap();\n-        assert_eq!(v, ());\n-\n-        let v: bool = super::decode(\"true\").unwrap();\n-        assert_eq!(v, true);\n-\n-        let v: bool = super::decode(\"false\").unwrap();\n-        assert_eq!(v, false);\n-    }\n-\n-    #[test]\n-    fn test_read_number() {\n-        assert_eq!(from_str(\"+\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n-        assert_eq!(from_str(\".\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n-        assert_eq!(from_str(\"NaN\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n-        assert_eq!(from_str(\"-\"),   Err(SyntaxError(InvalidNumber, 1, 2)));\n-        assert_eq!(from_str(\"00\"),  Err(SyntaxError(InvalidNumber, 1, 2)));\n-        assert_eq!(from_str(\"1.\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n-        assert_eq!(from_str(\"1e\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n-        assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n-\n-        assert_eq!(from_str(\"18446744073709551616\"), Err(SyntaxError(InvalidNumber, 1, 20)));\n-        assert_eq!(from_str(\"-9223372036854775809\"), Err(SyntaxError(InvalidNumber, 1, 21)));\n-\n-        assert_eq!(from_str(\"3\"), Ok(U64(3)));\n-        assert_eq!(from_str(\"3.1\"), Ok(F64(3.1)));\n-        assert_eq!(from_str(\"-1.2\"), Ok(F64(-1.2)));\n-        assert_eq!(from_str(\"0.4\"), Ok(F64(0.4)));\n-        assert_eq!(from_str(\"0.4e5\"), Ok(F64(0.4e5)));\n-        assert_eq!(from_str(\"0.4e+15\"), Ok(F64(0.4e15)));\n-        assert_eq!(from_str(\"0.4e-01\"), Ok(F64(0.4e-01)));\n-        assert_eq!(from_str(\" 3 \"), Ok(U64(3)));\n-\n-        assert_eq!(from_str(\"-9223372036854775808\"), Ok(I64(i64::MIN)));\n-        assert_eq!(from_str(\"9223372036854775807\"), Ok(U64(i64::MAX as u64)));\n-        assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n-    }\n-\n-    #[test]\n-    fn test_decode_numbers() {\n-        let v: f64 = super::decode(\"3\").unwrap();\n-        assert_eq!(v, 3.0);\n-\n-        let v: f64 = super::decode(\"3.1\").unwrap();\n-        assert_eq!(v, 3.1);\n-\n-        let v: f64 = super::decode(\"-1.2\").unwrap();\n-        assert_eq!(v, -1.2);\n-\n-        let v: f64 = super::decode(\"0.4\").unwrap();\n-        assert_eq!(v, 0.4);\n-\n-        let v: f64 = super::decode(\"0.4e5\").unwrap();\n-        assert_eq!(v, 0.4e5);\n-\n-        let v: f64 = super::decode(\"0.4e15\").unwrap();\n-        assert_eq!(v, 0.4e15);\n-\n-        let v: f64 = super::decode(\"0.4e-01\").unwrap();\n-        assert_eq!(v, 0.4e-01);\n-\n-        let v: u64 = super::decode(\"0\").unwrap();\n-        assert_eq!(v, 0);\n-\n-        let v: u64 = super::decode(\"18446744073709551615\").unwrap();\n-        assert_eq!(v, u64::MAX);\n-\n-        let v: i64 = super::decode(\"-9223372036854775808\").unwrap();\n-        assert_eq!(v, i64::MIN);\n-\n-        let v: i64 = super::decode(\"9223372036854775807\").unwrap();\n-        assert_eq!(v, i64::MAX);\n-\n-        let res: DecodeResult<i64> = super::decode(\"765.25\");\n-        assert_eq!(res, Err(ExpectedError(\"Integer\".to_string(),\n-                                          \"765.25\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test_read_str() {\n-        assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n-        assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n-\n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u{12ab}\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test_decode_str() {\n-        let s = [(\"\\\"\\\"\", \"\"),\n-                 (\"\\\"foo\\\"\", \"foo\"),\n-                 (\"\\\"\\\\\\\"\\\"\", \"\\\"\"),\n-                 (\"\\\"\\\\b\\\"\", \"\\x08\"),\n-                 (\"\\\"\\\\n\\\"\", \"\\n\"),\n-                 (\"\\\"\\\\r\\\"\", \"\\r\"),\n-                 (\"\\\"\\\\t\\\"\", \"\\t\"),\n-                 (\"\\\"\\\\u12ab\\\"\", \"\\u{12ab}\"),\n-                 (\"\\\"\\\\uAB12\\\"\", \"\\u{AB12}\")];\n-\n-        for &(i, o) in &s {\n-            let v: string::String = super::decode(i).unwrap();\n-            assert_eq!(v, o);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_array() {\n-        assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n-        assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n-        assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n-        assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n-\n-        assert_eq!(from_str(\"[]\"), Ok(Array(vec![])));\n-        assert_eq!(from_str(\"[ ]\"), Ok(Array(vec![])));\n-        assert_eq!(from_str(\"[true]\"), Ok(Array(vec![Boolean(true)])));\n-        assert_eq!(from_str(\"[ false ]\"), Ok(Array(vec![Boolean(false)])));\n-        assert_eq!(from_str(\"[null]\"), Ok(Array(vec![Null])));\n-        assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(Array(vec![U64(3), U64(1)])));\n-        assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(Array(vec![U64(3), U64(2)])));\n-        assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n-    }\n-\n-    #[test]\n-    fn test_decode_array() {\n-        let v: Vec<()> = super::decode(\"[]\").unwrap();\n-        assert_eq!(v, []);\n-\n-        let v: Vec<()> = super::decode(\"[null]\").unwrap();\n-        assert_eq!(v, [()]);\n-\n-        let v: Vec<bool> = super::decode(\"[true]\").unwrap();\n-        assert_eq!(v, [true]);\n-\n-        let v: Vec<isize> = super::decode(\"[3, 1]\").unwrap();\n-        assert_eq!(v, [3, 1]);\n-\n-        let v: Vec<Vec<usize>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n-        assert_eq!(v, [vec![3], vec![1, 2]]);\n-    }\n-\n-    #[test]\n-    fn test_decode_tuple() {\n-        let t: (usize, usize, usize) = super::decode(\"[1, 2, 3]\").unwrap();\n-        assert_eq!(t, (1, 2, 3));\n-\n-        let t: (usize, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n-        assert_eq!(t, (1, \"two\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_decode_tuple_malformed_types() {\n-        assert!(super::decode::<(usize, string::String)>(\"[1, 2]\").is_err());\n-    }\n-\n-    #[test]\n-    fn test_decode_tuple_malformed_length() {\n-        assert!(super::decode::<(usize, usize)>(\"[1, 2, 3]\").is_err());\n-    }\n-\n-    #[test]\n-    fn test_read_object() {\n-        assert_eq!(from_str(\"{\"),       Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n-        assert_eq!(from_str(\"{ \"),      Err(SyntaxError(EOFWhileParsingObject, 1, 3)));\n-        assert_eq!(from_str(\"{1\"),      Err(SyntaxError(KeyMustBeAString,      1, 2)));\n-        assert_eq!(from_str(\"{ \\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-        assert_eq!(from_str(\"{\\\"a\\\"\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 5)));\n-        assert_eq!(from_str(\"{\\\"a\\\" \"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-\n-        assert_eq!(from_str(\"{\\\"a\\\" 1\"),   Err(SyntaxError(ExpectedColon,         1, 6)));\n-        assert_eq!(from_str(\"{\\\"a\\\":\"),    Err(SyntaxError(EOFWhileParsingValue,  1, 6)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1\"),   Err(SyntaxError(EOFWhileParsingObject, 1, 7)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1 1\"), Err(SyntaxError(InvalidSyntax,         1, 8)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1,\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 8)));\n-\n-        assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n-        assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object(&[(\"a\".to_string(), U64(3))]));\n-\n-        assert_eq!(from_str(\n-                      \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n-                  mk_object(&[\n-                      (\"a\".to_string(), Null),\n-                      (\"b\".to_string(), Boolean(true))]));\n-        assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n-                  mk_object(&[\n-                      (\"a\".to_string(), Null),\n-                      (\"b\".to_string(), Boolean(true))]));\n-        assert_eq!(from_str(\n-                      \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n-                  mk_object(&[\n-                      (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), Array(vec![Boolean(true)]))\n-                  ]));\n-        assert_eq!(from_str(\n-                      \"{\\\n-                          \\\"a\\\": 1.0, \\\n-                          \\\"b\\\": [\\\n-                              true,\\\n-                              \\\"foo\\\\nbar\\\", \\\n-                              { \\\"c\\\": {\\\"d\\\": null} } \\\n-                          ]\\\n-                      }\").unwrap(),\n-                  mk_object(&[\n-                      (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), Array(vec![\n-                          Boolean(true),\n-                          String(\"foo\\nbar\".to_string()),\n-                          mk_object(&[\n-                              (\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))\n-                          ])\n-                      ]))\n-                  ]));\n-    }\n-\n-    #[test]\n-    fn test_decode_struct() {\n-        let s = \"{\n-            \\\"inner\\\": [\n-                { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n-            ]\n-        }\";\n-\n-        let v: Outer = super::decode(s).unwrap();\n-        assert_eq!(\n-            v,\n-            Outer {\n-                inner: vec![\n-                    Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n-                ]\n-            }\n-        );\n-    }\n-\n-    #[derive(RustcDecodable)]\n-    struct FloatStruct {\n-        f: f64,\n-        a: Vec<f64>\n-    }\n-    #[test]\n-    fn test_decode_struct_with_nan() {\n-        let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n-        let obj: FloatStruct = super::decode(s).unwrap();\n-        assert!(obj.f.is_nan());\n-        assert!(obj.a[0].is_nan());\n-        assert_eq!(obj.a[1], 123f64);\n-    }\n-\n-    #[test]\n-    fn test_decode_option() {\n-        let value: Option<string::String> = super::decode(\"null\").unwrap();\n-        assert_eq!(value, None);\n-\n-        let value: Option<string::String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n-        assert_eq!(value, Some(\"jodhpurs\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_decode_enum() {\n-        let value: Animal = super::decode(\"\\\"Dog\\\"\").unwrap();\n-        assert_eq!(value, Dog);\n-\n-        let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-        let value: Animal = super::decode(s).unwrap();\n-        assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n-    }\n-\n-    #[test]\n-    fn test_decode_map() {\n-        let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n-                  \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut map: BTreeMap<string::String, Animal> = super::decode(s).unwrap();\n-\n-        assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n-        assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n-    }\n-\n-    #[test]\n-    fn test_multiline_errors() {\n-        assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n-            Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n-    }\n-\n-    #[derive(RustcDecodable)]\n-    #[allow(dead_code)]\n-    struct DecodeStruct {\n-        x: f64,\n-        y: bool,\n-        z: string::String,\n-        w: Vec<DecodeStruct>\n-    }\n-    #[derive(RustcDecodable)]\n-    enum DecodeEnum {\n-        A(f64),\n-        B(string::String)\n-    }\n-    fn check_err<T: Decodable>(to_parse: &'static str, expected: DecoderError) {\n-        let res: DecodeResult<T> = match from_str(to_parse) {\n-            Err(e) => Err(ParseError(e)),\n-            Ok(json) => Decodable::decode(&mut Decoder::new(json))\n-        };\n-        match res {\n-            Ok(_) => panic!(\"`{:?}` parsed & decoded ok, expecting error `{:?}`\",\n-                              to_parse, expected),\n-            Err(ParseError(e)) => panic!(\"`{:?}` is not valid json: {:?}\",\n-                                           to_parse, e),\n-            Err(e) => {\n-                assert_eq!(e, expected);\n-            }\n-        }\n-    }\n-    #[test]\n-    fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Number\".to_string(), \"true\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(\"w\".to_string()));\n-    }\n-    #[test]\n-    fn test_decode_errors_enum() {\n-        check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(\"variant\".to_string()));\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(\"String\".to_string(), \"1\".to_string()));\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(\"fields\".to_string()));\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(\"C\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_find(){\n-        let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(\"dog\");\n-        assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n-    }\n-\n-    #[test]\n-    fn test_find_path(){\n-        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n-        assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n-    }\n-\n-    #[test]\n-    fn test_search(){\n-        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n-        assert!(found_str.unwrap() == \"cheese\");\n-    }\n-\n-    #[test]\n-    fn test_index(){\n-        let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n-        let ref array = json_value[\"animals\"];\n-        assert_eq!(array[0].as_string().unwrap(), \"dog\");\n-        assert_eq!(array[1].as_string().unwrap(), \"cat\");\n-        assert_eq!(array[2].as_string().unwrap(), \"mouse\");\n-    }\n-\n-    #[test]\n-    fn test_is_object(){\n-        let json_value = from_str(\"{}\").unwrap();\n-        assert!(json_value.is_object());\n-    }\n-\n-    #[test]\n-    fn test_as_object(){\n-        let json_value = from_str(\"{}\").unwrap();\n-        let json_object = json_value.as_object();\n-        assert!(json_object.is_some());\n-    }\n-\n-    #[test]\n-    fn test_is_array(){\n-        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        assert!(json_value.is_array());\n-    }\n-\n-    #[test]\n-    fn test_as_array(){\n-        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        let json_array = json_value.as_array();\n-        let expected_length = 3;\n-        assert!(json_array.is_some() && json_array.unwrap().len() == expected_length);\n-    }\n-\n-    #[test]\n-    fn test_is_string(){\n-        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-        assert!(json_value.is_string());\n-    }\n-\n-    #[test]\n-    fn test_as_string(){\n-        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-        let json_str = json_value.as_string();\n-        let expected_str = \"dog\";\n-        assert_eq!(json_str, Some(expected_str));\n-    }\n-\n-    #[test]\n-    fn test_is_number(){\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(json_value.is_number());\n-    }\n-\n-    #[test]\n-    fn test_is_i64(){\n-        let json_value = from_str(\"-12\").unwrap();\n-        assert!(json_value.is_i64());\n-\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(!json_value.is_i64());\n-\n-        let json_value = from_str(\"12.0\").unwrap();\n-        assert!(!json_value.is_i64());\n-    }\n-\n-    #[test]\n-    fn test_is_u64(){\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(json_value.is_u64());\n-\n-        let json_value = from_str(\"-12\").unwrap();\n-        assert!(!json_value.is_u64());\n-\n-        let json_value = from_str(\"12.0\").unwrap();\n-        assert!(!json_value.is_u64());\n-    }\n-\n-    #[test]\n-    fn test_is_f64(){\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(!json_value.is_f64());\n-\n-        let json_value = from_str(\"-12\").unwrap();\n-        assert!(!json_value.is_f64());\n-\n-        let json_value = from_str(\"12.0\").unwrap();\n-        assert!(json_value.is_f64());\n-\n-        let json_value = from_str(\"-12.0\").unwrap();\n-        assert!(json_value.is_f64());\n-    }\n-\n-    #[test]\n-    fn test_as_i64(){\n-        let json_value = from_str(\"-12\").unwrap();\n-        let json_num = json_value.as_i64();\n-        assert_eq!(json_num, Some(-12));\n-    }\n-\n-    #[test]\n-    fn test_as_u64(){\n-        let json_value = from_str(\"12\").unwrap();\n-        let json_num = json_value.as_u64();\n-        assert_eq!(json_num, Some(12));\n-    }\n-\n-    #[test]\n-    fn test_as_f64(){\n-        let json_value = from_str(\"12.0\").unwrap();\n-        let json_num = json_value.as_f64();\n-        assert_eq!(json_num, Some(12f64));\n-    }\n-\n-    #[test]\n-    fn test_is_boolean(){\n-        let json_value = from_str(\"false\").unwrap();\n-        assert!(json_value.is_boolean());\n-    }\n-\n-    #[test]\n-    fn test_as_boolean(){\n-        let json_value = from_str(\"false\").unwrap();\n-        let json_bool = json_value.as_boolean();\n-        let expected_bool = false;\n-        assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n-    }\n-\n-    #[test]\n-    fn test_is_null(){\n-        let json_value = from_str(\"null\").unwrap();\n-        assert!(json_value.is_null());\n-    }\n-\n-    #[test]\n-    fn test_as_null(){\n-        let json_value = from_str(\"null\").unwrap();\n-        let json_null = json_value.as_null();\n-        let expected_null = ();\n-        assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n-    }\n-\n-    #[test]\n-    fn test_encode_hashmap_with_numeric_key() {\n-        use std::str::from_utf8;\n-        use std::collections::HashMap;\n-        let mut hm: HashMap<usize, bool> = HashMap::new();\n-        hm.insert(1, true);\n-        let mut mem_buf = Vec::new();\n-        write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(&mem_buf[..]).unwrap();\n-        match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-            _ => {} // it parsed and we are good to go\n-        }\n-    }\n-\n-    #[test]\n-    fn test_prettyencode_hashmap_with_numeric_key() {\n-        use std::str::from_utf8;\n-        use std::collections::HashMap;\n-        let mut hm: HashMap<usize, bool> = HashMap::new();\n-        hm.insert(1, true);\n-        let mut mem_buf = Vec::new();\n-        write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(&mem_buf[..]).unwrap();\n-        match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-            _ => {} // it parsed and we are good to go\n-        }\n-    }\n-\n-    #[test]\n-    fn test_prettyencoder_indent_level_param() {\n-        use std::str::from_utf8;\n-        use std::collections::BTreeMap;\n-\n-        let mut tree = BTreeMap::new();\n-\n-        tree.insert(\"hello\".to_string(), String(\"guten tag\".to_string()));\n-        tree.insert(\"goodbye\".to_string(), String(\"sayonara\".to_string()));\n-\n-        let json = Array(\n-            // The following layout below should look a lot like\n-            // the pretty-printed JSON (indent * x)\n-            vec!\n-            ( // 0x\n-                String(\"greetings\".to_string()), // 1x\n-                Object(tree), // 1x + 2x + 2x + 1x\n-            ) // 0x\n-            // End JSON array (7 lines)\n-        );\n-\n-        // Helper function for counting indents\n-        fn indents(source: &str) -> usize {\n-            let trimmed = source.trim_start_matches(' ');\n-            source.len() - trimmed.len()\n-        }\n-\n-        // Test up to 4 spaces of indents (more?)\n-        for i in 0..4 {\n-            let mut writer = Vec::new();\n-            write!(&mut writer, \"{}\",\n-                   super::as_pretty_json(&json).indent(i)).unwrap();\n-\n-            let printed = from_utf8(&writer[..]).unwrap();\n-\n-            // Check for indents at each line\n-            let lines: Vec<&str> = printed.lines().collect();\n-            assert_eq!(lines.len(), 7); // JSON should be 7 lines\n-\n-            assert_eq!(indents(lines[0]), 0 * i); // [\n-            assert_eq!(indents(lines[1]), 1 * i); //   \"greetings\",\n-            assert_eq!(indents(lines[2]), 1 * i); //   {\n-            assert_eq!(indents(lines[3]), 2 * i); //     \"hello\": \"guten tag\",\n-            assert_eq!(indents(lines[4]), 2 * i); //     \"goodbye\": \"sayonara\"\n-            assert_eq!(indents(lines[5]), 1 * i); //   },\n-            assert_eq!(indents(lines[6]), 0 * i); // ]\n-\n-            // Finally, test that the pretty-printed JSON is valid\n-            from_str(printed).ok().expect(\"Pretty-printed JSON is invalid!\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hashmap_with_enum_key() {\n-        use std::collections::HashMap;\n-        use json;\n-        #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Debug)]\n-        enum Enum {\n-            Foo,\n-            #[allow(dead_code)]\n-            Bar,\n-        }\n-        let mut map = HashMap::new();\n-        map.insert(Enum::Foo, 0);\n-        let result = json::encode(&map).unwrap();\n-        assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n-        let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();\n-        assert_eq!(map, decoded);\n-    }\n-\n-    #[test]\n-    fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n-        use std::collections::HashMap;\n-        use Decodable;\n-        let json_str = \"{\\\"1\\\":true}\";\n-        let json_obj = match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-            Ok(o) => o\n-        };\n-        let mut decoder = Decoder::new(json_obj);\n-        let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n-        use std::collections::HashMap;\n-        use Decodable;\n-        let json_str = \"{\\\"a\\\":true}\";\n-        let json_obj = match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-            Ok(o) => o\n-        };\n-        let mut decoder = Decoder::new(json_obj);\n-        let result: Result<HashMap<usize, bool>, DecoderError> = Decodable::decode(&mut decoder);\n-        assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n-    }\n-\n-    fn assert_stream_equal(src: &str,\n-                           expected: Vec<(JsonEvent, Vec<StackElement>)>) {\n-        let mut parser = Parser::new(src.chars());\n-        let mut i = 0;\n-        loop {\n-            let evt = match parser.next() {\n-                Some(e) => e,\n-                None => { break; }\n-            };\n-            let (ref expected_evt, ref expected_stack) = expected[i];\n-            if !parser.stack().is_equal_to(expected_stack) {\n-                panic!(\"Parser stack is not equal to {:?}\", expected_stack);\n-            }\n-            assert_eq!(&evt, expected_evt);\n-            i+=1;\n-        }\n-    }\n-    #[test]\n-    fn test_streaming_parser() {\n-        assert_stream_equal(\n-            r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n-            vec![\n-                (ObjectStart,             vec![]),\n-                  (StringValue(\"bar\".to_string()),   vec![StackElement::Key(\"foo\")]),\n-                  (ArrayStart,            vec![StackElement::Key(\"array\")]),\n-                    (U64Value(0),         vec![StackElement::Key(\"array\"), StackElement::Index(0)]),\n-                    (U64Value(1),         vec![StackElement::Key(\"array\"), StackElement::Index(1)]),\n-                    (U64Value(2),         vec![StackElement::Key(\"array\"), StackElement::Index(2)]),\n-                    (U64Value(3),         vec![StackElement::Key(\"array\"), StackElement::Index(3)]),\n-                    (U64Value(4),         vec![StackElement::Key(\"array\"), StackElement::Index(4)]),\n-                    (U64Value(5),         vec![StackElement::Key(\"array\"), StackElement::Index(5)]),\n-                  (ArrayEnd,              vec![StackElement::Key(\"array\")]),\n-                  (ArrayStart,            vec![StackElement::Key(\"idents\")]),\n-                    (NullValue,           vec![StackElement::Key(\"idents\"),\n-                                               StackElement::Index(0)]),\n-                    (BooleanValue(true),  vec![StackElement::Key(\"idents\"),\n-                                               StackElement::Index(1)]),\n-                    (BooleanValue(false), vec![StackElement::Key(\"idents\"),\n-                                               StackElement::Index(2)]),\n-                  (ArrayEnd,              vec![StackElement::Key(\"idents\")]),\n-                (ObjectEnd,               vec![]),\n-            ]\n-        );\n-    }\n-    fn last_event(src: &str) -> JsonEvent {\n-        let mut parser = Parser::new(src.chars());\n-        let mut evt = NullValue;\n-        loop {\n-            evt = match parser.next() {\n-                Some(e) => e,\n-                None => return evt,\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_object_streaming() {\n-        assert_eq!(last_event(\"{ \"),      Error(SyntaxError(EOFWhileParsingObject, 1, 3)));\n-        assert_eq!(last_event(\"{1\"),      Error(SyntaxError(KeyMustBeAString,      1, 2)));\n-        assert_eq!(last_event(\"{ \\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-        assert_eq!(last_event(\"{\\\"a\\\"\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 5)));\n-        assert_eq!(last_event(\"{\\\"a\\\" \"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-\n-        assert_eq!(last_event(\"{\\\"a\\\" 1\"),   Error(SyntaxError(ExpectedColon,         1, 6)));\n-        assert_eq!(last_event(\"{\\\"a\\\":\"),    Error(SyntaxError(EOFWhileParsingValue,  1, 6)));\n-        assert_eq!(last_event(\"{\\\"a\\\":1\"),   Error(SyntaxError(EOFWhileParsingObject, 1, 7)));\n-        assert_eq!(last_event(\"{\\\"a\\\":1 1\"), Error(SyntaxError(InvalidSyntax,         1, 8)));\n-        assert_eq!(last_event(\"{\\\"a\\\":1,\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 8)));\n-        assert_eq!(last_event(\"{\\\"a\\\":1,}\"), Error(SyntaxError(TrailingComma, 1, 8)));\n-\n-        assert_stream_equal(\n-            \"{}\",\n-            vec![(ObjectStart, vec![]), (ObjectEnd, vec![])]\n-        );\n-        assert_stream_equal(\n-            \"{\\\"a\\\": 3}\",\n-            vec![\n-                (ObjectStart,        vec![]),\n-                  (U64Value(3),      vec![StackElement::Key(\"a\")]),\n-                (ObjectEnd,          vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n-            vec![\n-                (ObjectStart,           vec![]),\n-                  (NullValue,           vec![StackElement::Key(\"a\")]),\n-                  (BooleanValue(true),  vec![StackElement::Key(\"b\")]),\n-                (ObjectEnd,             vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n-            vec![\n-                (ObjectStart,           vec![]),\n-                  (F64Value(1.0),       vec![StackElement::Key(\"a\")]),\n-                  (ArrayStart,          vec![StackElement::Key(\"b\")]),\n-                    (BooleanValue(true),vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n-                  (ArrayEnd,            vec![StackElement::Key(\"b\")]),\n-                (ObjectEnd,             vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            r#\"{\n-                \"a\": 1.0,\n-                \"b\": [\n-                    true,\n-                    \"foo\\nbar\",\n-                    { \"c\": {\"d\": null} }\n-                ]\n-            }\"#,\n-            vec![\n-                (ObjectStart,                   vec![]),\n-                  (F64Value(1.0),               vec![StackElement::Key(\"a\")]),\n-                  (ArrayStart,                  vec![StackElement::Key(\"b\")]),\n-                    (BooleanValue(true),        vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_string()),  vec![StackElement::Key(\"b\"),\n-                                                                StackElement::Index(1)]),\n-                    (ObjectStart,               vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2)]),\n-                      (ObjectStart,             vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2),\n-                                                     StackElement::Key(\"c\")]),\n-                        (NullValue,             vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2),\n-                                                     StackElement::Key(\"c\"),\n-                                                     StackElement::Key(\"d\")]),\n-                      (ObjectEnd,               vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2),\n-                                                     StackElement::Key(\"c\")]),\n-                    (ObjectEnd,                 vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2)]),\n-                  (ArrayEnd,                    vec![StackElement::Key(\"b\")]),\n-                (ObjectEnd,                     vec![]),\n-            ]\n-        );\n-    }\n-    #[test]\n-    fn test_read_array_streaming() {\n-        assert_stream_equal(\n-            \"[]\",\n-            vec![\n-                (ArrayStart, vec![]),\n-                (ArrayEnd,   vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[ ]\",\n-            vec![\n-                (ArrayStart, vec![]),\n-                (ArrayEnd,   vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[true]\",\n-            vec![\n-                (ArrayStart,             vec![]),\n-                    (BooleanValue(true), vec![StackElement::Index(0)]),\n-                (ArrayEnd,               vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[ false ]\",\n-            vec![\n-                (ArrayStart,              vec![]),\n-                    (BooleanValue(false), vec![StackElement::Index(0)]),\n-                (ArrayEnd,                vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[null]\",\n-            vec![\n-                (ArrayStart,    vec![]),\n-                    (NullValue, vec![StackElement::Index(0)]),\n-                (ArrayEnd,      vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[3, 1]\",\n-            vec![\n-                (ArrayStart,      vec![]),\n-                    (U64Value(3), vec![StackElement::Index(0)]),\n-                    (U64Value(1), vec![StackElement::Index(1)]),\n-                (ArrayEnd,        vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"\\n[3, 2]\\n\",\n-            vec![\n-                (ArrayStart,      vec![]),\n-                    (U64Value(3), vec![StackElement::Index(0)]),\n-                    (U64Value(2), vec![StackElement::Index(1)]),\n-                (ArrayEnd,        vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[2, [4, 1]]\",\n-            vec![\n-                (ArrayStart,           vec![]),\n-                    (U64Value(2),      vec![StackElement::Index(0)]),\n-                    (ArrayStart,       vec![StackElement::Index(1)]),\n-                        (U64Value(4),  vec![StackElement::Index(1), StackElement::Index(0)]),\n-                        (U64Value(1),  vec![StackElement::Index(1), StackElement::Index(1)]),\n-                    (ArrayEnd,         vec![StackElement::Index(1)]),\n-                (ArrayEnd,             vec![]),\n-            ]\n-        );\n-\n-        assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1,  2)));\n-\n-        assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n-        assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n-        assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n-        assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n-\n-    }\n-    #[test]\n-    fn test_trailing_characters_streaming() {\n-        assert_eq!(last_event(\"nulla\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n-        assert_eq!(last_event(\"truea\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n-        assert_eq!(last_event(\"falsea\"), Error(SyntaxError(TrailingCharacters, 1, 6)));\n-        assert_eq!(last_event(\"1a\"),     Error(SyntaxError(TrailingCharacters, 1, 2)));\n-        assert_eq!(last_event(\"[]a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n-        assert_eq!(last_event(\"{}a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n-    }\n-    #[test]\n-    fn test_read_identifiers_streaming() {\n-        assert_eq!(Parser::new(\"null\".chars()).next(), Some(NullValue));\n-        assert_eq!(Parser::new(\"true\".chars()).next(), Some(BooleanValue(true)));\n-        assert_eq!(Parser::new(\"false\".chars()).next(), Some(BooleanValue(false)));\n-\n-        assert_eq!(last_event(\"n\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(last_event(\"nul\"),  Error(SyntaxError(InvalidSyntax, 1, 4)));\n-        assert_eq!(last_event(\"t\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(last_event(\"truz\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n-        assert_eq!(last_event(\"f\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(last_event(\"faz\"),  Error(SyntaxError(InvalidSyntax, 1, 3)));\n-    }\n-\n     #[test]\n     fn test_stack() {\n         let mut stack = Stack::new();\n@@ -3862,76 +2654,6 @@ mod tests {\n         assert!(stack.get(1) == StackElement::Key(\"foo\"));\n     }\n \n-    #[test]\n-    fn test_to_json() {\n-        use std::collections::{HashMap,BTreeMap};\n-        use super::ToJson;\n-\n-        let array2 = Array(vec![U64(1), U64(2)]);\n-        let array3 = Array(vec![U64(1), U64(2), U64(3)]);\n-        let object = {\n-            let mut tree_map = BTreeMap::new();\n-            tree_map.insert(\"a\".to_string(), U64(1));\n-            tree_map.insert(\"b\".to_string(), U64(2));\n-            Object(tree_map)\n-        };\n-\n-        assert_eq!(array2.to_json(), array2);\n-        assert_eq!(object.to_json(), object);\n-        assert_eq!(3_isize.to_json(), I64(3));\n-        assert_eq!(4_i8.to_json(), I64(4));\n-        assert_eq!(5_i16.to_json(), I64(5));\n-        assert_eq!(6_i32.to_json(), I64(6));\n-        assert_eq!(7_i64.to_json(), I64(7));\n-        assert_eq!(8_usize.to_json(), U64(8));\n-        assert_eq!(9_u8.to_json(), U64(9));\n-        assert_eq!(10_u16.to_json(), U64(10));\n-        assert_eq!(11_u32.to_json(), U64(11));\n-        assert_eq!(12_u64.to_json(), U64(12));\n-        assert_eq!(13.0_f32.to_json(), F64(13.0_f64));\n-        assert_eq!(14.0_f64.to_json(), F64(14.0_f64));\n-        assert_eq!(().to_json(), Null);\n-        assert_eq!(f32::INFINITY.to_json(), Null);\n-        assert_eq!(f64::NAN.to_json(), Null);\n-        assert_eq!(true.to_json(), Boolean(true));\n-        assert_eq!(false.to_json(), Boolean(false));\n-        assert_eq!(\"abc\".to_json(), String(\"abc\".to_string()));\n-        assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n-        assert_eq!((1_usize, 2_usize).to_json(), array2);\n-        assert_eq!((1_usize, 2_usize, 3_usize).to_json(), array3);\n-        assert_eq!([1_usize, 2_usize].to_json(), array2);\n-        assert_eq!((&[1_usize, 2_usize, 3_usize]).to_json(), array3);\n-        assert_eq!((vec![1_usize, 2_usize]).to_json(), array2);\n-        assert_eq!(vec![1_usize, 2_usize, 3_usize].to_json(), array3);\n-        let mut tree_map = BTreeMap::new();\n-        tree_map.insert(\"a\".to_string(), 1 as usize);\n-        tree_map.insert(\"b\".to_string(), 2);\n-        assert_eq!(tree_map.to_json(), object);\n-        let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".to_string(), 1 as usize);\n-        hash_map.insert(\"b\".to_string(), 2);\n-        assert_eq!(hash_map.to_json(), object);\n-        assert_eq!(Some(15).to_json(), I64(15));\n-        assert_eq!(Some(15 as usize).to_json(), U64(15));\n-        assert_eq!(None::<isize>.to_json(), Null);\n-    }\n-\n-    #[test]\n-    fn test_encode_hashmap_with_arbitrary_key() {\n-        use std::collections::HashMap;\n-        #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n-        struct ArbitraryType(usize);\n-        let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n-        hm.insert(ArbitraryType(1), true);\n-        let mut mem_buf = string::String::new();\n-        let mut encoder = Encoder::new(&mut mem_buf);\n-        let result = hm.encode(&mut encoder);\n-        match result.unwrap_err() {\n-            EncoderError::BadHashmapKey => (),\n-            _ => panic!(\"expected bad hash map key\")\n-        }\n-    }\n-\n     #[bench]\n     fn bench_streaming_small(b: &mut Bencher) {\n         b.iter( || {"}, {"sha": "b8eeb4d2b34af30c1bf25db7ca5661687612a8d9", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -8,6 +8,8 @@ Core encoding and decoding interfaces.\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(specialization)]\n@@ -20,8 +22,6 @@ pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};\n pub use self::serialize::{UseSpecializedEncodable, UseSpecializedDecodable};\n \n-extern crate smallvec;\n-\n mod serialize;\n mod collection_impls;\n \n@@ -30,7 +30,3 @@ pub mod json;\n \n pub mod opaque;\n pub mod leb128;\n-\n-mod rustc_serialize {\n-    pub use serialize::*;\n-}"}, {"sha": "a6a5c318079f1ccb1c74db6ba60d9d3fc6436174", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 3, "deletions": 288, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -1,6 +1,6 @@\n-use leb128::{self, read_signed_leb128, write_signed_leb128};\n+use crate::leb128::{self, read_signed_leb128, write_signed_leb128};\n+use crate::serialize;\n use std::borrow::Cow;\n-use serialize;\n \n // -----------------------------------------------------------------------------\n // Encoder\n@@ -312,7 +312,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     }\n \n     #[inline]\n-    fn read_str(&mut self) -> Result<Cow<str>, Self::Error> {\n+    fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error> {\n         let len = self.read_usize()?;\n         let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n         self.position += len;\n@@ -324,288 +324,3 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         err.to_string()\n     }\n }\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use serialize::{Encodable, Decodable};\n-    use std::fmt::Debug;\n-    use super::{Encoder, Decoder};\n-\n-    #[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n-    struct Struct {\n-        a: (),\n-        b: u8,\n-        c: u16,\n-        d: u32,\n-        e: u64,\n-        f: usize,\n-\n-        g: i8,\n-        h: i16,\n-        i: i32,\n-        j: i64,\n-        k: isize,\n-\n-        l: char,\n-        m: String,\n-        n: f32,\n-        o: f64,\n-        p: bool,\n-        q: Option<u32>,\n-    }\n-\n-\n-    fn check_round_trip<T: Encodable + Decodable + PartialEq + Debug>(values: Vec<T>) {\n-        let mut encoder = Encoder::new(Vec::new());\n-\n-        for value in &values {\n-            Encodable::encode(&value, &mut encoder).unwrap();\n-        }\n-\n-        let data = encoder.into_inner();\n-        let mut decoder = Decoder::new(&data[..], 0);\n-\n-        for value in values {\n-            let decoded = Decodable::decode(&mut decoder).unwrap();\n-            assert_eq!(value, decoded);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unit() {\n-        check_round_trip(vec![(), (), (), ()]);\n-    }\n-\n-    #[test]\n-    fn test_u8() {\n-        let mut vec = vec![];\n-        for i in ::std::u8::MIN..::std::u8::MAX {\n-            vec.push(i);\n-        }\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_u16() {\n-        for i in ::std::u16::MIN..::std::u16::MAX {\n-            check_round_trip(vec![1, 2, 3, i, i, i]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_u32() {\n-        check_round_trip(vec![1, 2, 3, ::std::u32::MIN, 0, 1, ::std::u32::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_u64() {\n-        check_round_trip(vec![1, 2, 3, ::std::u64::MIN, 0, 1, ::std::u64::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_usize() {\n-        check_round_trip(vec![1, 2, 3, ::std::usize::MIN, 0, 1, ::std::usize::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_i8() {\n-        let mut vec = vec![];\n-        for i in ::std::i8::MIN..::std::i8::MAX {\n-            vec.push(i);\n-        }\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_i16() {\n-        for i in ::std::i16::MIN..::std::i16::MAX {\n-            check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_i32() {\n-        check_round_trip(vec![-1, 2, -3, ::std::i32::MIN, 0, 1, ::std::i32::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_i64() {\n-        check_round_trip(vec![-1, 2, -3, ::std::i64::MIN, 0, 1, ::std::i64::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_isize() {\n-        check_round_trip(vec![-1, 2, -3, ::std::isize::MIN, 0, 1, ::std::isize::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_bool() {\n-        check_round_trip(vec![false, true, true, false, false]);\n-    }\n-\n-    #[test]\n-    fn test_f32() {\n-        let mut vec = vec![];\n-        for i in -100..100 {\n-            vec.push((i as f32) / 3.0);\n-        }\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_f64() {\n-        let mut vec = vec![];\n-        for i in -100..100 {\n-            vec.push((i as f64) / 3.0);\n-        }\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_char() {\n-        let vec = vec!['a', 'b', 'c', 'd', 'A', 'X', ' ', '#', '\u00d6', '\u00c4', '\u00b5', '\u20ac'];\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_string() {\n-        let vec = vec![\"abcbu\u00d6eiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmeabpnvapeapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganei\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5nvapeapmaebn\".to_string()];\n-\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_option() {\n-        check_round_trip(vec![Some(-1i8)]);\n-        check_round_trip(vec![Some(-2i16)]);\n-        check_round_trip(vec![Some(-3i32)]);\n-        check_round_trip(vec![Some(-4i64)]);\n-        check_round_trip(vec![Some(-5isize)]);\n-\n-        let none_i8: Option<i8> = None;\n-        check_round_trip(vec![none_i8]);\n-\n-        let none_i16: Option<i16> = None;\n-        check_round_trip(vec![none_i16]);\n-\n-        let none_i32: Option<i32> = None;\n-        check_round_trip(vec![none_i32]);\n-\n-        let none_i64: Option<i64> = None;\n-        check_round_trip(vec![none_i64]);\n-\n-        let none_isize: Option<isize> = None;\n-        check_round_trip(vec![none_isize]);\n-    }\n-\n-    #[test]\n-    fn test_struct() {\n-        check_round_trip(vec![Struct {\n-                                  a: (),\n-                                  b: 10,\n-                                  c: 11,\n-                                  d: 12,\n-                                  e: 13,\n-                                  f: 14,\n-\n-                                  g: 15,\n-                                  h: 16,\n-                                  i: 17,\n-                                  j: 18,\n-                                  k: 19,\n-\n-                                  l: 'x',\n-                                  m: \"abc\".to_string(),\n-                                  n: 20.5,\n-                                  o: 21.5,\n-                                  p: false,\n-                                  q: None,\n-                              }]);\n-\n-        check_round_trip(vec![Struct {\n-                                  a: (),\n-                                  b: 101,\n-                                  c: 111,\n-                                  d: 121,\n-                                  e: 131,\n-                                  f: 141,\n-\n-                                  g: -15,\n-                                  h: -16,\n-                                  i: -17,\n-                                  j: -18,\n-                                  k: -19,\n-\n-                                  l: 'y',\n-                                  m: \"def\".to_string(),\n-                                  n: -20.5,\n-                                  o: -21.5,\n-                                  p: true,\n-                                  q: Some(1234567),\n-                              }]);\n-    }\n-\n-    #[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n-    enum Enum {\n-        Variant1,\n-        Variant2(usize, f32),\n-        Variant3 {\n-            a: i32,\n-            b: char,\n-            c: bool,\n-        },\n-    }\n-\n-    #[test]\n-    fn test_enum() {\n-        check_round_trip(vec![Enum::Variant1,\n-                              Enum::Variant2(1, 2.5),\n-                              Enum::Variant3 {\n-                                  a: 3,\n-                                  b: 'b',\n-                                  c: false,\n-                              },\n-                              Enum::Variant3 {\n-                                  a: -4,\n-                                  b: 'f',\n-                                  c: true,\n-                              }]);\n-    }\n-\n-    #[test]\n-    fn test_sequence() {\n-        let mut vec = vec![];\n-        for i in -100i64..100i64 {\n-            vec.push(i * 100000);\n-        }\n-\n-        check_round_trip(vec![vec]);\n-    }\n-\n-    #[test]\n-    fn test_hash_map() {\n-        use std::collections::HashMap;\n-        let mut map = HashMap::new();\n-        for i in -100i64..100i64 {\n-            map.insert(i * 100000, i * 10000);\n-        }\n-\n-        check_round_trip(vec![map]);\n-    }\n-\n-    #[test]\n-    fn test_tuples() {\n-        check_round_trip(vec![('x', (), false, 0.5f32)]);\n-        check_round_trip(vec![(9i8, 10u16, 1.5f64)]);\n-        check_round_trip(vec![(-12i16, 11u8, 12usize)]);\n-        check_round_trip(vec![(1234567isize, 100000000000000u64, 99999999999999i64)]);\n-        check_round_trip(vec![(String::new(), \"some string\".to_string())]);\n-    }\n-}"}, {"sha": "977a36a220fdd9d22293d18910a6652bddd3581b", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -175,7 +175,7 @@ pub trait Decoder {\n     fn read_f64(&mut self) -> Result<f64, Self::Error>;\n     fn read_f32(&mut self) -> Result<f32, Self::Error>;\n     fn read_char(&mut self) -> Result<char, Self::Error>;\n-    fn read_str(&mut self) -> Result<Cow<str>, Self::Error>;\n+    fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error>;\n \n     // Compound types:\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>"}, {"sha": "3fb6bda679bc1173522da11c328c8acb5465a9ff", "filename": "src/libserialize/tests/json.rs", "status": "added", "additions": 1282, "deletions": 0, "changes": 1282, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Ftests%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Ftests%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Ftests%2Fjson.rs?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -0,0 +1,1282 @@\n+extern crate serialize as rustc_serialize;\n+\n+use rustc_serialize::{Encodable, Decodable};\n+use rustc_serialize::json;\n+use json::Json::*;\n+use json::ErrorCode::*;\n+use json::ParserError::*;\n+use json::DecoderError::*;\n+use json::JsonEvent::*;\n+use json::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser, StackElement,\n+           Decoder, Encoder, EncoderError};\n+\n+use Animal::*;\n+use std::{i64, u64, f32, f64};\n+use std::io::prelude::*;\n+use std::collections::BTreeMap;\n+use std::string;\n+\n+#[derive(RustcDecodable, Eq, PartialEq, Debug)]\n+struct OptionData {\n+    opt: Option<usize>,\n+}\n+\n+#[test]\n+fn test_decode_option_none() {\n+    let s =\"{}\";\n+    let obj: OptionData = json::decode(s).unwrap();\n+    assert_eq!(obj, OptionData { opt: None });\n+}\n+\n+#[test]\n+fn test_decode_option_some() {\n+    let s = \"{ \\\"opt\\\": 10 }\";\n+    let obj: OptionData = json::decode(s).unwrap();\n+    assert_eq!(obj, OptionData { opt: Some(10) });\n+}\n+\n+#[test]\n+fn test_decode_option_malformed() {\n+    check_err::<OptionData>(\"{ \\\"opt\\\": [] }\",\n+                            ExpectedError(\"Number\".to_string(), \"[]\".to_string()));\n+    check_err::<OptionData>(\"{ \\\"opt\\\": false }\",\n+                            ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n+}\n+\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+enum Animal {\n+    Dog,\n+    Frog(string::String, isize)\n+}\n+\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+struct Inner {\n+    a: (),\n+    b: usize,\n+    c: Vec<string::String>,\n+}\n+\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+struct Outer {\n+    inner: Vec<Inner>,\n+}\n+\n+fn mk_object(items: &[(string::String, Json)]) -> Json {\n+    let mut d = BTreeMap::new();\n+\n+    for item in items {\n+        match *item {\n+            (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n+        }\n+    };\n+\n+    Object(d)\n+}\n+\n+#[test]\n+fn test_from_str_trait() {\n+    let s = \"null\";\n+    assert!(s.parse::<Json>().unwrap() == s.parse().unwrap());\n+}\n+\n+#[test]\n+fn test_write_null() {\n+    assert_eq!(Null.to_string(), \"null\");\n+    assert_eq!(Null.pretty().to_string(), \"null\");\n+}\n+\n+#[test]\n+fn test_write_i64() {\n+    assert_eq!(U64(0).to_string(), \"0\");\n+    assert_eq!(U64(0).pretty().to_string(), \"0\");\n+\n+    assert_eq!(U64(1234).to_string(), \"1234\");\n+    assert_eq!(U64(1234).pretty().to_string(), \"1234\");\n+\n+    assert_eq!(I64(-5678).to_string(), \"-5678\");\n+    assert_eq!(I64(-5678).pretty().to_string(), \"-5678\");\n+\n+    assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n+    assert_eq!(U64(7650007200025252000).pretty().to_string(), \"7650007200025252000\");\n+}\n+\n+#[test]\n+fn test_write_f64() {\n+    assert_eq!(F64(3.0).to_string(), \"3.0\");\n+    assert_eq!(F64(3.0).pretty().to_string(), \"3.0\");\n+\n+    assert_eq!(F64(3.1).to_string(), \"3.1\");\n+    assert_eq!(F64(3.1).pretty().to_string(), \"3.1\");\n+\n+    assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n+    assert_eq!(F64(-1.5).pretty().to_string(), \"-1.5\");\n+\n+    assert_eq!(F64(0.5).to_string(), \"0.5\");\n+    assert_eq!(F64(0.5).pretty().to_string(), \"0.5\");\n+\n+    assert_eq!(F64(f64::NAN).to_string(), \"null\");\n+    assert_eq!(F64(f64::NAN).pretty().to_string(), \"null\");\n+\n+    assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n+    assert_eq!(F64(f64::INFINITY).pretty().to_string(), \"null\");\n+\n+    assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n+    assert_eq!(F64(f64::NEG_INFINITY).pretty().to_string(), \"null\");\n+}\n+\n+#[test]\n+fn test_write_str() {\n+    assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n+    assert_eq!(String(\"\".to_string()).pretty().to_string(), \"\\\"\\\"\");\n+\n+    assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n+    assert_eq!(String(\"madoka\".to_string()).pretty().to_string(), \"\\\"madoka\\\"\");\n+}\n+\n+#[test]\n+fn test_write_bool() {\n+    assert_eq!(Boolean(true).to_string(), \"true\");\n+    assert_eq!(Boolean(true).pretty().to_string(), \"true\");\n+\n+    assert_eq!(Boolean(false).to_string(), \"false\");\n+    assert_eq!(Boolean(false).pretty().to_string(), \"false\");\n+}\n+\n+#[test]\n+fn test_write_array() {\n+    assert_eq!(Array(vec![]).to_string(), \"[]\");\n+    assert_eq!(Array(vec![]).pretty().to_string(), \"[]\");\n+\n+    assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n+    assert_eq!(\n+        Array(vec![Boolean(true)]).pretty().to_string(),\n+        \"\\\n+        [\\n  \\\n+            true\\n\\\n+        ]\"\n+    );\n+\n+    let long_test_array = Array(vec![\n+        Boolean(false),\n+        Null,\n+        Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n+\n+    assert_eq!(long_test_array.to_string(),\n+        \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n+    assert_eq!(\n+        long_test_array.pretty().to_string(),\n+        \"\\\n+        [\\n  \\\n+            false,\\n  \\\n+            null,\\n  \\\n+            [\\n    \\\n+                \\\"foo\\\\nbar\\\",\\n    \\\n+                3.5\\n  \\\n+            ]\\n\\\n+        ]\"\n+    );\n+}\n+\n+#[test]\n+fn test_write_object() {\n+    assert_eq!(mk_object(&[]).to_string(), \"{}\");\n+    assert_eq!(mk_object(&[]).pretty().to_string(), \"{}\");\n+\n+    assert_eq!(\n+        mk_object(&[\n+            (\"a\".to_string(), Boolean(true))\n+        ]).to_string(),\n+        \"{\\\"a\\\":true}\"\n+    );\n+    assert_eq!(\n+        mk_object(&[(\"a\".to_string(), Boolean(true))]).pretty().to_string(),\n+        \"\\\n+        {\\n  \\\n+            \\\"a\\\": true\\n\\\n+        }\"\n+    );\n+\n+    let complex_obj = mk_object(&[\n+            (\"b\".to_string(), Array(vec![\n+                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n+            ]))\n+        ]);\n+\n+    assert_eq!(\n+        complex_obj.to_string(),\n+        \"{\\\n+            \\\"b\\\":[\\\n+                {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n+                {\\\"d\\\":\\\"\\\"}\\\n+            ]\\\n+        }\"\n+    );\n+    assert_eq!(\n+        complex_obj.pretty().to_string(),\n+        \"\\\n+        {\\n  \\\n+            \\\"b\\\": [\\n    \\\n+                {\\n      \\\n+                    \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n+                },\\n    \\\n+                {\\n      \\\n+                    \\\"d\\\": \\\"\\\"\\n    \\\n+                }\\n  \\\n+            ]\\n\\\n+        }\"\n+    );\n+\n+    let a = mk_object(&[\n+        (\"a\".to_string(), Boolean(true)),\n+        (\"b\".to_string(), Array(vec![\n+            mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+            mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n+        ]))\n+    ]);\n+\n+    // We can't compare the strings directly because the object fields be\n+    // printed in a different order.\n+    assert_eq!(a.clone(), a.to_string().parse().unwrap());\n+    assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());\n+}\n+\n+#[test]\n+fn test_write_enum() {\n+    let animal = Dog;\n+    assert_eq!(\n+        json::as_json(&animal).to_string(),\n+        \"\\\"Dog\\\"\"\n+    );\n+    assert_eq!(\n+        json::as_pretty_json(&animal).to_string(),\n+        \"\\\"Dog\\\"\"\n+    );\n+\n+    let animal = Frog(\"Henry\".to_string(), 349);\n+    assert_eq!(\n+        json::as_json(&animal).to_string(),\n+        \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n+    );\n+    assert_eq!(\n+        json::as_pretty_json(&animal).to_string(),\n+        \"{\\n  \\\n+           \\\"variant\\\": \\\"Frog\\\",\\n  \\\n+           \\\"fields\\\": [\\n    \\\n+             \\\"Henry\\\",\\n    \\\n+             349\\n  \\\n+           ]\\n\\\n+         }\"\n+    );\n+}\n+\n+macro_rules! check_encoder_for_simple {\n+    ($value:expr, $expected:expr) => ({\n+        let s = json::as_json(&$value).to_string();\n+        assert_eq!(s, $expected);\n+\n+        let s = json::as_pretty_json(&$value).to_string();\n+        assert_eq!(s, $expected);\n+    })\n+}\n+\n+#[test]\n+fn test_write_some() {\n+    check_encoder_for_simple!(Some(\"jodhpurs\".to_string()), \"\\\"jodhpurs\\\"\");\n+}\n+\n+#[test]\n+fn test_write_none() {\n+    check_encoder_for_simple!(None::<string::String>, \"null\");\n+}\n+\n+#[test]\n+fn test_write_char() {\n+    check_encoder_for_simple!('a', \"\\\"a\\\"\");\n+    check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n+    check_encoder_for_simple!('\\u{0000}', \"\\\"\\\\u0000\\\"\");\n+    check_encoder_for_simple!('\\u{001b}', \"\\\"\\\\u001b\\\"\");\n+    check_encoder_for_simple!('\\u{007f}', \"\\\"\\\\u007f\\\"\");\n+    check_encoder_for_simple!('\\u{00a0}', \"\\\"\\u{00a0}\\\"\");\n+    check_encoder_for_simple!('\\u{abcd}', \"\\\"\\u{abcd}\\\"\");\n+    check_encoder_for_simple!('\\u{10ffff}', \"\\\"\\u{10ffff}\\\"\");\n+}\n+\n+#[test]\n+fn test_trailing_characters() {\n+    assert_eq!(from_str(\"nulla\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n+    assert_eq!(from_str(\"truea\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n+    assert_eq!(from_str(\"falsea\"), Err(SyntaxError(TrailingCharacters, 1, 6)));\n+    assert_eq!(from_str(\"1a\"),     Err(SyntaxError(TrailingCharacters, 1, 2)));\n+    assert_eq!(from_str(\"[]a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n+    assert_eq!(from_str(\"{}a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n+}\n+\n+#[test]\n+fn test_read_identifiers() {\n+    assert_eq!(from_str(\"n\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(from_str(\"nul\"),  Err(SyntaxError(InvalidSyntax, 1, 4)));\n+    assert_eq!(from_str(\"t\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(from_str(\"truz\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n+    assert_eq!(from_str(\"f\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(from_str(\"faz\"),  Err(SyntaxError(InvalidSyntax, 1, 3)));\n+\n+    assert_eq!(from_str(\"null\"), Ok(Null));\n+    assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n+    assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n+    assert_eq!(from_str(\" null \"), Ok(Null));\n+    assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n+    assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n+}\n+\n+#[test]\n+fn test_decode_identifiers() {\n+    let v: () = json::decode(\"null\").unwrap();\n+    assert_eq!(v, ());\n+\n+    let v: bool = json::decode(\"true\").unwrap();\n+    assert_eq!(v, true);\n+\n+    let v: bool = json::decode(\"false\").unwrap();\n+    assert_eq!(v, false);\n+}\n+\n+#[test]\n+fn test_read_number() {\n+    assert_eq!(from_str(\"+\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n+    assert_eq!(from_str(\".\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n+    assert_eq!(from_str(\"NaN\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n+    assert_eq!(from_str(\"-\"),   Err(SyntaxError(InvalidNumber, 1, 2)));\n+    assert_eq!(from_str(\"00\"),  Err(SyntaxError(InvalidNumber, 1, 2)));\n+    assert_eq!(from_str(\"1.\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n+    assert_eq!(from_str(\"1e\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n+    assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n+\n+    assert_eq!(from_str(\"18446744073709551616\"), Err(SyntaxError(InvalidNumber, 1, 20)));\n+    assert_eq!(from_str(\"-9223372036854775809\"), Err(SyntaxError(InvalidNumber, 1, 21)));\n+\n+    assert_eq!(from_str(\"3\"), Ok(U64(3)));\n+    assert_eq!(from_str(\"3.1\"), Ok(F64(3.1)));\n+    assert_eq!(from_str(\"-1.2\"), Ok(F64(-1.2)));\n+    assert_eq!(from_str(\"0.4\"), Ok(F64(0.4)));\n+    assert_eq!(from_str(\"0.4e5\"), Ok(F64(0.4e5)));\n+    assert_eq!(from_str(\"0.4e+15\"), Ok(F64(0.4e15)));\n+    assert_eq!(from_str(\"0.4e-01\"), Ok(F64(0.4e-01)));\n+    assert_eq!(from_str(\" 3 \"), Ok(U64(3)));\n+\n+    assert_eq!(from_str(\"-9223372036854775808\"), Ok(I64(i64::MIN)));\n+    assert_eq!(from_str(\"9223372036854775807\"), Ok(U64(i64::MAX as u64)));\n+    assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n+}\n+\n+#[test]\n+fn test_decode_numbers() {\n+    let v: f64 = json::decode(\"3\").unwrap();\n+    assert_eq!(v, 3.0);\n+\n+    let v: f64 = json::decode(\"3.1\").unwrap();\n+    assert_eq!(v, 3.1);\n+\n+    let v: f64 = json::decode(\"-1.2\").unwrap();\n+    assert_eq!(v, -1.2);\n+\n+    let v: f64 = json::decode(\"0.4\").unwrap();\n+    assert_eq!(v, 0.4);\n+\n+    let v: f64 = json::decode(\"0.4e5\").unwrap();\n+    assert_eq!(v, 0.4e5);\n+\n+    let v: f64 = json::decode(\"0.4e15\").unwrap();\n+    assert_eq!(v, 0.4e15);\n+\n+    let v: f64 = json::decode(\"0.4e-01\").unwrap();\n+    assert_eq!(v, 0.4e-01);\n+\n+    let v: u64 = json::decode(\"0\").unwrap();\n+    assert_eq!(v, 0);\n+\n+    let v: u64 = json::decode(\"18446744073709551615\").unwrap();\n+    assert_eq!(v, u64::MAX);\n+\n+    let v: i64 = json::decode(\"-9223372036854775808\").unwrap();\n+    assert_eq!(v, i64::MIN);\n+\n+    let v: i64 = json::decode(\"9223372036854775807\").unwrap();\n+    assert_eq!(v, i64::MAX);\n+\n+    let res: DecodeResult<i64> = json::decode(\"765.25\");\n+    assert_eq!(res, Err(ExpectedError(\"Integer\".to_string(),\n+                                      \"765.25\".to_string())));\n+}\n+\n+#[test]\n+fn test_read_str() {\n+    assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n+    assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n+\n+    assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n+    assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n+    assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u{12ab}\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n+}\n+\n+#[test]\n+fn test_decode_str() {\n+    let s = [(\"\\\"\\\"\", \"\"),\n+             (\"\\\"foo\\\"\", \"foo\"),\n+             (\"\\\"\\\\\\\"\\\"\", \"\\\"\"),\n+             (\"\\\"\\\\b\\\"\", \"\\x08\"),\n+             (\"\\\"\\\\n\\\"\", \"\\n\"),\n+             (\"\\\"\\\\r\\\"\", \"\\r\"),\n+             (\"\\\"\\\\t\\\"\", \"\\t\"),\n+             (\"\\\"\\\\u12ab\\\"\", \"\\u{12ab}\"),\n+             (\"\\\"\\\\uAB12\\\"\", \"\\u{AB12}\")];\n+\n+    for &(i, o) in &s {\n+        let v: string::String = json::decode(i).unwrap();\n+        assert_eq!(v, o);\n+    }\n+}\n+\n+#[test]\n+fn test_read_array() {\n+    assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n+    assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n+    assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n+    assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n+    assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n+\n+    assert_eq!(from_str(\"[]\"), Ok(Array(vec![])));\n+    assert_eq!(from_str(\"[ ]\"), Ok(Array(vec![])));\n+    assert_eq!(from_str(\"[true]\"), Ok(Array(vec![Boolean(true)])));\n+    assert_eq!(from_str(\"[ false ]\"), Ok(Array(vec![Boolean(false)])));\n+    assert_eq!(from_str(\"[null]\"), Ok(Array(vec![Null])));\n+    assert_eq!(from_str(\"[3, 1]\"),\n+                 Ok(Array(vec![U64(3), U64(1)])));\n+    assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n+                 Ok(Array(vec![U64(3), U64(2)])));\n+    assert_eq!(from_str(\"[2, [4, 1]]\"),\n+           Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n+}\n+\n+#[test]\n+fn test_decode_array() {\n+    let v: Vec<()> = json::decode(\"[]\").unwrap();\n+    assert_eq!(v, []);\n+\n+    let v: Vec<()> = json::decode(\"[null]\").unwrap();\n+    assert_eq!(v, [()]);\n+\n+    let v: Vec<bool> = json::decode(\"[true]\").unwrap();\n+    assert_eq!(v, [true]);\n+\n+    let v: Vec<isize> = json::decode(\"[3, 1]\").unwrap();\n+    assert_eq!(v, [3, 1]);\n+\n+    let v: Vec<Vec<usize>> = json::decode(\"[[3], [1, 2]]\").unwrap();\n+    assert_eq!(v, [vec![3], vec![1, 2]]);\n+}\n+\n+#[test]\n+fn test_decode_tuple() {\n+    let t: (usize, usize, usize) = json::decode(\"[1, 2, 3]\").unwrap();\n+    assert_eq!(t, (1, 2, 3));\n+\n+    let t: (usize, string::String) = json::decode(\"[1, \\\"two\\\"]\").unwrap();\n+    assert_eq!(t, (1, \"two\".to_string()));\n+}\n+\n+#[test]\n+fn test_decode_tuple_malformed_types() {\n+    assert!(json::decode::<(usize, string::String)>(\"[1, 2]\").is_err());\n+}\n+\n+#[test]\n+fn test_decode_tuple_malformed_length() {\n+    assert!(json::decode::<(usize, usize)>(\"[1, 2, 3]\").is_err());\n+}\n+\n+#[test]\n+fn test_read_object() {\n+    assert_eq!(from_str(\"{\"),       Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n+    assert_eq!(from_str(\"{ \"),      Err(SyntaxError(EOFWhileParsingObject, 1, 3)));\n+    assert_eq!(from_str(\"{1\"),      Err(SyntaxError(KeyMustBeAString,      1, 2)));\n+    assert_eq!(from_str(\"{ \\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+    assert_eq!(from_str(\"{\\\"a\\\"\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 5)));\n+    assert_eq!(from_str(\"{\\\"a\\\" \"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+\n+    assert_eq!(from_str(\"{\\\"a\\\" 1\"),   Err(SyntaxError(ExpectedColon,         1, 6)));\n+    assert_eq!(from_str(\"{\\\"a\\\":\"),    Err(SyntaxError(EOFWhileParsingValue,  1, 6)));\n+    assert_eq!(from_str(\"{\\\"a\\\":1\"),   Err(SyntaxError(EOFWhileParsingObject, 1, 7)));\n+    assert_eq!(from_str(\"{\\\"a\\\":1 1\"), Err(SyntaxError(InvalidSyntax,         1, 8)));\n+    assert_eq!(from_str(\"{\\\"a\\\":1,\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 8)));\n+\n+    assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n+    assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n+                mk_object(&[(\"a\".to_string(), U64(3))]));\n+\n+    assert_eq!(from_str(\n+                    \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n+                mk_object(&[\n+                    (\"a\".to_string(), Null),\n+                    (\"b\".to_string(), Boolean(true))]));\n+    assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n+                mk_object(&[\n+                    (\"a\".to_string(), Null),\n+                    (\"b\".to_string(), Boolean(true))]));\n+    assert_eq!(from_str(\n+                    \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n+                mk_object(&[\n+                    (\"a\".to_string(), F64(1.0)),\n+                    (\"b\".to_string(), Array(vec![Boolean(true)]))\n+                ]));\n+    assert_eq!(from_str(\n+                    \"{\\\n+                        \\\"a\\\": 1.0, \\\n+                        \\\"b\\\": [\\\n+                            true,\\\n+                            \\\"foo\\\\nbar\\\", \\\n+                            { \\\"c\\\": {\\\"d\\\": null} } \\\n+                        ]\\\n+                    }\").unwrap(),\n+                mk_object(&[\n+                    (\"a\".to_string(), F64(1.0)),\n+                    (\"b\".to_string(), Array(vec![\n+                        Boolean(true),\n+                        String(\"foo\\nbar\".to_string()),\n+                        mk_object(&[\n+                            (\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))\n+                        ])\n+                    ]))\n+                ]));\n+}\n+\n+#[test]\n+fn test_decode_struct() {\n+    let s = \"{\n+        \\\"inner\\\": [\n+            { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n+        ]\n+    }\";\n+\n+    let v: Outer = json::decode(s).unwrap();\n+    assert_eq!(\n+        v,\n+        Outer {\n+            inner: vec![\n+                Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n+            ]\n+        }\n+    );\n+}\n+\n+#[derive(RustcDecodable)]\n+struct FloatStruct {\n+    f: f64,\n+    a: Vec<f64>\n+}\n+#[test]\n+fn test_decode_struct_with_nan() {\n+    let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n+    let obj: FloatStruct = json::decode(s).unwrap();\n+    assert!(obj.f.is_nan());\n+    assert!(obj.a[0].is_nan());\n+    assert_eq!(obj.a[1], 123f64);\n+}\n+\n+#[test]\n+fn test_decode_option() {\n+    let value: Option<string::String> = json::decode(\"null\").unwrap();\n+    assert_eq!(value, None);\n+\n+    let value: Option<string::String> = json::decode(\"\\\"jodhpurs\\\"\").unwrap();\n+    assert_eq!(value, Some(\"jodhpurs\".to_string()));\n+}\n+\n+#[test]\n+fn test_decode_enum() {\n+    let value: Animal = json::decode(\"\\\"Dog\\\"\").unwrap();\n+    assert_eq!(value, Dog);\n+\n+    let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n+    let value: Animal = json::decode(s).unwrap();\n+    assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n+}\n+\n+#[test]\n+fn test_decode_map() {\n+    let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n+              \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n+    let mut map: BTreeMap<string::String, Animal> = json::decode(s).unwrap();\n+\n+    assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n+    assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n+}\n+\n+#[test]\n+fn test_multiline_errors() {\n+    assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n+        Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n+}\n+\n+#[derive(RustcDecodable)]\n+#[allow(dead_code)]\n+struct DecodeStruct {\n+    x: f64,\n+    y: bool,\n+    z: string::String,\n+    w: Vec<DecodeStruct>\n+}\n+#[derive(RustcDecodable)]\n+enum DecodeEnum {\n+    A(f64),\n+    B(string::String)\n+}\n+fn check_err<T: Decodable>(to_parse: &'static str, expected: DecoderError) {\n+    let res: DecodeResult<T> = match from_str(to_parse) {\n+        Err(e) => Err(ParseError(e)),\n+        Ok(json) => Decodable::decode(&mut Decoder::new(json))\n+    };\n+    match res {\n+        Ok(_) => panic!(\"`{:?}` parsed & decoded ok, expecting error `{:?}`\",\n+                           to_parse, expected),\n+        Err(ParseError(e)) => panic!(\"`{:?}` is not valid json: {:?}\",\n+                                        to_parse, e),\n+        Err(e) => {\n+            assert_eq!(e, expected);\n+        }\n+    }\n+}\n+#[test]\n+fn test_decode_errors_struct() {\n+    check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n+                              ExpectedError(\"Number\".to_string(), \"true\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n+                              ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n+                              ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n+                              ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n+                              MissingFieldError(\"w\".to_string()));\n+}\n+#[test]\n+fn test_decode_errors_enum() {\n+    check_err::<DecodeEnum>(\"{}\",\n+                            MissingFieldError(\"variant\".to_string()));\n+    check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n+                            ExpectedError(\"String\".to_string(), \"1\".to_string()));\n+    check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n+                            MissingFieldError(\"fields\".to_string()));\n+    check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n+                            ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n+    check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n+                            UnknownVariantError(\"C\".to_string()));\n+}\n+\n+#[test]\n+fn test_find(){\n+    let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n+    let found_str = json_value.find(\"dog\");\n+    assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n+}\n+\n+#[test]\n+fn test_find_path(){\n+    let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+    let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n+    assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n+}\n+\n+#[test]\n+fn test_search(){\n+    let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+    let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n+    assert!(found_str.unwrap() == \"cheese\");\n+}\n+\n+#[test]\n+fn test_index(){\n+    let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n+    let ref array = json_value[\"animals\"];\n+    assert_eq!(array[0].as_string().unwrap(), \"dog\");\n+    assert_eq!(array[1].as_string().unwrap(), \"cat\");\n+    assert_eq!(array[2].as_string().unwrap(), \"mouse\");\n+}\n+\n+#[test]\n+fn test_is_object(){\n+    let json_value = from_str(\"{}\").unwrap();\n+    assert!(json_value.is_object());\n+}\n+\n+#[test]\n+fn test_as_object(){\n+    let json_value = from_str(\"{}\").unwrap();\n+    let json_object = json_value.as_object();\n+    assert!(json_object.is_some());\n+}\n+\n+#[test]\n+fn test_is_array(){\n+    let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+    assert!(json_value.is_array());\n+}\n+\n+#[test]\n+fn test_as_array(){\n+    let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+    let json_array = json_value.as_array();\n+    let expected_length = 3;\n+    assert!(json_array.is_some() && json_array.unwrap().len() == expected_length);\n+}\n+\n+#[test]\n+fn test_is_string(){\n+    let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+    assert!(json_value.is_string());\n+}\n+\n+#[test]\n+fn test_as_string(){\n+    let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+    let json_str = json_value.as_string();\n+    let expected_str = \"dog\";\n+    assert_eq!(json_str, Some(expected_str));\n+}\n+\n+#[test]\n+fn test_is_number(){\n+    let json_value = from_str(\"12\").unwrap();\n+    assert!(json_value.is_number());\n+}\n+\n+#[test]\n+fn test_is_i64(){\n+    let json_value = from_str(\"-12\").unwrap();\n+    assert!(json_value.is_i64());\n+\n+    let json_value = from_str(\"12\").unwrap();\n+    assert!(!json_value.is_i64());\n+\n+    let json_value = from_str(\"12.0\").unwrap();\n+    assert!(!json_value.is_i64());\n+}\n+\n+#[test]\n+fn test_is_u64(){\n+    let json_value = from_str(\"12\").unwrap();\n+    assert!(json_value.is_u64());\n+\n+    let json_value = from_str(\"-12\").unwrap();\n+    assert!(!json_value.is_u64());\n+\n+    let json_value = from_str(\"12.0\").unwrap();\n+    assert!(!json_value.is_u64());\n+}\n+\n+#[test]\n+fn test_is_f64(){\n+    let json_value = from_str(\"12\").unwrap();\n+    assert!(!json_value.is_f64());\n+\n+    let json_value = from_str(\"-12\").unwrap();\n+    assert!(!json_value.is_f64());\n+\n+    let json_value = from_str(\"12.0\").unwrap();\n+    assert!(json_value.is_f64());\n+\n+    let json_value = from_str(\"-12.0\").unwrap();\n+    assert!(json_value.is_f64());\n+}\n+\n+#[test]\n+fn test_as_i64(){\n+    let json_value = from_str(\"-12\").unwrap();\n+    let json_num = json_value.as_i64();\n+    assert_eq!(json_num, Some(-12));\n+}\n+\n+#[test]\n+fn test_as_u64(){\n+    let json_value = from_str(\"12\").unwrap();\n+    let json_num = json_value.as_u64();\n+    assert_eq!(json_num, Some(12));\n+}\n+\n+#[test]\n+fn test_as_f64(){\n+    let json_value = from_str(\"12.0\").unwrap();\n+    let json_num = json_value.as_f64();\n+    assert_eq!(json_num, Some(12f64));\n+}\n+\n+#[test]\n+fn test_is_boolean(){\n+    let json_value = from_str(\"false\").unwrap();\n+    assert!(json_value.is_boolean());\n+}\n+\n+#[test]\n+fn test_as_boolean(){\n+    let json_value = from_str(\"false\").unwrap();\n+    let json_bool = json_value.as_boolean();\n+    let expected_bool = false;\n+    assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n+}\n+\n+#[test]\n+fn test_is_null(){\n+    let json_value = from_str(\"null\").unwrap();\n+    assert!(json_value.is_null());\n+}\n+\n+#[test]\n+fn test_as_null(){\n+    let json_value = from_str(\"null\").unwrap();\n+    let json_null = json_value.as_null();\n+    let expected_null = ();\n+    assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n+}\n+\n+#[test]\n+fn test_encode_hashmap_with_numeric_key() {\n+    use std::str::from_utf8;\n+    use std::collections::HashMap;\n+    let mut hm: HashMap<usize, bool> = HashMap::new();\n+    hm.insert(1, true);\n+    let mut mem_buf = Vec::new();\n+    write!(&mut mem_buf, \"{}\", json::as_pretty_json(&hm)).unwrap();\n+    let json_str = from_utf8(&mem_buf[..]).unwrap();\n+    match from_str(json_str) {\n+        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n+        _ => {} // it parsed and we are good to go\n+    }\n+}\n+\n+#[test]\n+fn test_prettyencode_hashmap_with_numeric_key() {\n+    use std::str::from_utf8;\n+    use std::collections::HashMap;\n+    let mut hm: HashMap<usize, bool> = HashMap::new();\n+    hm.insert(1, true);\n+    let mut mem_buf = Vec::new();\n+    write!(&mut mem_buf, \"{}\", json::as_pretty_json(&hm)).unwrap();\n+    let json_str = from_utf8(&mem_buf[..]).unwrap();\n+    match from_str(json_str) {\n+        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n+        _ => {} // it parsed and we are good to go\n+    }\n+}\n+\n+#[test]\n+fn test_prettyencoder_indent_level_param() {\n+    use std::str::from_utf8;\n+    use std::collections::BTreeMap;\n+\n+    let mut tree = BTreeMap::new();\n+\n+    tree.insert(\"hello\".to_string(), String(\"guten tag\".to_string()));\n+    tree.insert(\"goodbye\".to_string(), String(\"sayonara\".to_string()));\n+\n+    let json = Array(\n+        // The following layout below should look a lot like\n+        // the pretty-printed JSON (indent * x)\n+        vec!\n+        ( // 0x\n+            String(\"greetings\".to_string()), // 1x\n+            Object(tree), // 1x + 2x + 2x + 1x\n+        ) // 0x\n+        // End JSON array (7 lines)\n+    );\n+\n+    // Helper function for counting indents\n+    fn indents(source: &str) -> usize {\n+        let trimmed = source.trim_start_matches(' ');\n+        source.len() - trimmed.len()\n+    }\n+\n+    // Test up to 4 spaces of indents (more?)\n+    for i in 0..4 {\n+        let mut writer = Vec::new();\n+        write!(&mut writer, \"{}\",\n+                json::as_pretty_json(&json).indent(i)).unwrap();\n+\n+        let printed = from_utf8(&writer[..]).unwrap();\n+\n+        // Check for indents at each line\n+        let lines: Vec<&str> = printed.lines().collect();\n+        assert_eq!(lines.len(), 7); // JSON should be 7 lines\n+\n+        assert_eq!(indents(lines[0]), 0 * i); // [\n+        assert_eq!(indents(lines[1]), 1 * i); //   \"greetings\",\n+        assert_eq!(indents(lines[2]), 1 * i); //   {\n+        assert_eq!(indents(lines[3]), 2 * i); //     \"hello\": \"guten tag\",\n+        assert_eq!(indents(lines[4]), 2 * i); //     \"goodbye\": \"sayonara\"\n+        assert_eq!(indents(lines[5]), 1 * i); //   },\n+        assert_eq!(indents(lines[6]), 0 * i); // ]\n+\n+        // Finally, test that the pretty-printed JSON is valid\n+        from_str(printed).ok().expect(\"Pretty-printed JSON is invalid!\");\n+    }\n+}\n+\n+#[test]\n+fn test_hashmap_with_enum_key() {\n+    use std::collections::HashMap;\n+    #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Debug)]\n+    enum Enum {\n+        Foo,\n+        #[allow(dead_code)]\n+        Bar,\n+    }\n+    let mut map = HashMap::new();\n+    map.insert(Enum::Foo, 0);\n+    let result = json::encode(&map).unwrap();\n+    assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n+    let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();\n+    assert_eq!(map, decoded);\n+}\n+\n+#[test]\n+fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n+    use std::collections::HashMap;\n+    let json_str = \"{\\\"1\\\":true}\";\n+    let json_obj = match from_str(json_str) {\n+        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n+        Ok(o) => o\n+    };\n+    let mut decoder = Decoder::new(json_obj);\n+    let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder).unwrap();\n+}\n+\n+#[test]\n+fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n+    use std::collections::HashMap;\n+    let json_str = \"{\\\"a\\\":true}\";\n+    let json_obj = match from_str(json_str) {\n+        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n+        Ok(o) => o\n+    };\n+    let mut decoder = Decoder::new(json_obj);\n+    let result: Result<HashMap<usize, bool>, DecoderError> = Decodable::decode(&mut decoder);\n+    assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n+}\n+\n+fn assert_stream_equal(src: &str,\n+                        expected: Vec<(JsonEvent, Vec<StackElement<'_>>)>) {\n+    let mut parser = Parser::new(src.chars());\n+    let mut i = 0;\n+    loop {\n+        let evt = match parser.next() {\n+            Some(e) => e,\n+            None => { break; }\n+        };\n+        let (ref expected_evt, ref expected_stack) = expected[i];\n+        if !parser.stack().is_equal_to(expected_stack) {\n+            panic!(\"Parser stack is not equal to {:?}\", expected_stack);\n+        }\n+        assert_eq!(&evt, expected_evt);\n+        i+=1;\n+    }\n+}\n+#[test]\n+fn test_streaming_parser() {\n+    assert_stream_equal(\n+        r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n+        vec![\n+            (ObjectStart,             vec![]),\n+              (StringValue(\"bar\".to_string()),   vec![StackElement::Key(\"foo\")]),\n+              (ArrayStart,            vec![StackElement::Key(\"array\")]),\n+                (U64Value(0),         vec![StackElement::Key(\"array\"), StackElement::Index(0)]),\n+                (U64Value(1),         vec![StackElement::Key(\"array\"), StackElement::Index(1)]),\n+                (U64Value(2),         vec![StackElement::Key(\"array\"), StackElement::Index(2)]),\n+                (U64Value(3),         vec![StackElement::Key(\"array\"), StackElement::Index(3)]),\n+                (U64Value(4),         vec![StackElement::Key(\"array\"), StackElement::Index(4)]),\n+                (U64Value(5),         vec![StackElement::Key(\"array\"), StackElement::Index(5)]),\n+              (ArrayEnd,              vec![StackElement::Key(\"array\")]),\n+              (ArrayStart,            vec![StackElement::Key(\"idents\")]),\n+                (NullValue,           vec![StackElement::Key(\"idents\"),\n+                                           StackElement::Index(0)]),\n+                (BooleanValue(true),  vec![StackElement::Key(\"idents\"),\n+                                           StackElement::Index(1)]),\n+                (BooleanValue(false), vec![StackElement::Key(\"idents\"),\n+                                           StackElement::Index(2)]),\n+              (ArrayEnd,              vec![StackElement::Key(\"idents\")]),\n+            (ObjectEnd,               vec![]),\n+        ]\n+    );\n+}\n+fn last_event(src: &str) -> JsonEvent {\n+    let mut parser = Parser::new(src.chars());\n+    let mut evt = NullValue;\n+    loop {\n+        evt = match parser.next() {\n+            Some(e) => e,\n+            None => return evt,\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_read_object_streaming() {\n+    assert_eq!(last_event(\"{ \"),      Error(SyntaxError(EOFWhileParsingObject, 1, 3)));\n+    assert_eq!(last_event(\"{1\"),      Error(SyntaxError(KeyMustBeAString,      1, 2)));\n+    assert_eq!(last_event(\"{ \\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+    assert_eq!(last_event(\"{\\\"a\\\"\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 5)));\n+    assert_eq!(last_event(\"{\\\"a\\\" \"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+\n+    assert_eq!(last_event(\"{\\\"a\\\" 1\"),   Error(SyntaxError(ExpectedColon,         1, 6)));\n+    assert_eq!(last_event(\"{\\\"a\\\":\"),    Error(SyntaxError(EOFWhileParsingValue,  1, 6)));\n+    assert_eq!(last_event(\"{\\\"a\\\":1\"),   Error(SyntaxError(EOFWhileParsingObject, 1, 7)));\n+    assert_eq!(last_event(\"{\\\"a\\\":1 1\"), Error(SyntaxError(InvalidSyntax,         1, 8)));\n+    assert_eq!(last_event(\"{\\\"a\\\":1,\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 8)));\n+    assert_eq!(last_event(\"{\\\"a\\\":1,}\"), Error(SyntaxError(TrailingComma, 1, 8)));\n+\n+    assert_stream_equal(\n+        \"{}\",\n+        vec![(ObjectStart, vec![]), (ObjectEnd, vec![])]\n+    );\n+    assert_stream_equal(\n+        \"{\\\"a\\\": 3}\",\n+        vec![\n+            (ObjectStart,        vec![]),\n+              (U64Value(3),      vec![StackElement::Key(\"a\")]),\n+            (ObjectEnd,          vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n+        vec![\n+            (ObjectStart,           vec![]),\n+              (NullValue,           vec![StackElement::Key(\"a\")]),\n+              (BooleanValue(true),  vec![StackElement::Key(\"b\")]),\n+            (ObjectEnd,             vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n+        vec![\n+            (ObjectStart,           vec![]),\n+              (F64Value(1.0),       vec![StackElement::Key(\"a\")]),\n+              (ArrayStart,          vec![StackElement::Key(\"b\")]),\n+                (BooleanValue(true),vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n+              (ArrayEnd,            vec![StackElement::Key(\"b\")]),\n+            (ObjectEnd,             vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        r#\"{\n+            \"a\": 1.0,\n+            \"b\": [\n+                true,\n+                \"foo\\nbar\",\n+                { \"c\": {\"d\": null} }\n+            ]\n+        }\"#,\n+        vec![\n+            (ObjectStart,                   vec![]),\n+              (F64Value(1.0),               vec![StackElement::Key(\"a\")]),\n+              (ArrayStart,                  vec![StackElement::Key(\"b\")]),\n+                (BooleanValue(true),        vec![StackElement::Key(\"b\"),\n+                                                StackElement::Index(0)]),\n+                (StringValue(\"foo\\nbar\".to_string()),  vec![StackElement::Key(\"b\"),\n+                                                            StackElement::Index(1)]),\n+                (ObjectStart,               vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2)]),\n+                  (ObjectStart,             vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2),\n+                                                 StackElement::Key(\"c\")]),\n+                    (NullValue,             vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2),\n+                                                 StackElement::Key(\"c\"),\n+                                                 StackElement::Key(\"d\")]),\n+                  (ObjectEnd,               vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2),\n+                                                 StackElement::Key(\"c\")]),\n+                (ObjectEnd,                 vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2)]),\n+              (ArrayEnd,                    vec![StackElement::Key(\"b\")]),\n+            (ObjectEnd,                     vec![]),\n+        ]\n+    );\n+}\n+#[test]\n+fn test_read_array_streaming() {\n+    assert_stream_equal(\n+        \"[]\",\n+        vec![\n+            (ArrayStart, vec![]),\n+            (ArrayEnd,   vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[ ]\",\n+        vec![\n+            (ArrayStart, vec![]),\n+            (ArrayEnd,   vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[true]\",\n+        vec![\n+            (ArrayStart,             vec![]),\n+                (BooleanValue(true), vec![StackElement::Index(0)]),\n+            (ArrayEnd,               vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[ false ]\",\n+        vec![\n+            (ArrayStart,              vec![]),\n+                (BooleanValue(false), vec![StackElement::Index(0)]),\n+            (ArrayEnd,                vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[null]\",\n+        vec![\n+            (ArrayStart,    vec![]),\n+                (NullValue, vec![StackElement::Index(0)]),\n+            (ArrayEnd,      vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[3, 1]\",\n+        vec![\n+            (ArrayStart,      vec![]),\n+                (U64Value(3), vec![StackElement::Index(0)]),\n+                (U64Value(1), vec![StackElement::Index(1)]),\n+            (ArrayEnd,        vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"\\n[3, 2]\\n\",\n+        vec![\n+            (ArrayStart,      vec![]),\n+                (U64Value(3), vec![StackElement::Index(0)]),\n+                (U64Value(2), vec![StackElement::Index(1)]),\n+            (ArrayEnd,        vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[2, [4, 1]]\",\n+        vec![\n+            (ArrayStart,           vec![]),\n+                (U64Value(2),      vec![StackElement::Index(0)]),\n+                (ArrayStart,       vec![StackElement::Index(1)]),\n+                    (U64Value(4),  vec![StackElement::Index(1), StackElement::Index(0)]),\n+                    (U64Value(1),  vec![StackElement::Index(1), StackElement::Index(1)]),\n+                (ArrayEnd,         vec![StackElement::Index(1)]),\n+            (ArrayEnd,             vec![]),\n+        ]\n+    );\n+\n+    assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1,  2)));\n+\n+    assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n+    assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n+    assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n+    assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n+    assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n+\n+}\n+#[test]\n+fn test_trailing_characters_streaming() {\n+    assert_eq!(last_event(\"nulla\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n+    assert_eq!(last_event(\"truea\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n+    assert_eq!(last_event(\"falsea\"), Error(SyntaxError(TrailingCharacters, 1, 6)));\n+    assert_eq!(last_event(\"1a\"),     Error(SyntaxError(TrailingCharacters, 1, 2)));\n+    assert_eq!(last_event(\"[]a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n+    assert_eq!(last_event(\"{}a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n+}\n+#[test]\n+fn test_read_identifiers_streaming() {\n+    assert_eq!(Parser::new(\"null\".chars()).next(), Some(NullValue));\n+    assert_eq!(Parser::new(\"true\".chars()).next(), Some(BooleanValue(true)));\n+    assert_eq!(Parser::new(\"false\".chars()).next(), Some(BooleanValue(false)));\n+\n+    assert_eq!(last_event(\"n\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(last_event(\"nul\"),  Error(SyntaxError(InvalidSyntax, 1, 4)));\n+    assert_eq!(last_event(\"t\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(last_event(\"truz\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n+    assert_eq!(last_event(\"f\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(last_event(\"faz\"),  Error(SyntaxError(InvalidSyntax, 1, 3)));\n+}\n+\n+#[test]\n+fn test_to_json() {\n+    use std::collections::{HashMap,BTreeMap};\n+    use json::ToJson;\n+\n+    let array2 = Array(vec![U64(1), U64(2)]);\n+    let array3 = Array(vec![U64(1), U64(2), U64(3)]);\n+    let object = {\n+        let mut tree_map = BTreeMap::new();\n+        tree_map.insert(\"a\".to_string(), U64(1));\n+        tree_map.insert(\"b\".to_string(), U64(2));\n+        Object(tree_map)\n+    };\n+\n+    assert_eq!(array2.to_json(), array2);\n+    assert_eq!(object.to_json(), object);\n+    assert_eq!(3_isize.to_json(), I64(3));\n+    assert_eq!(4_i8.to_json(), I64(4));\n+    assert_eq!(5_i16.to_json(), I64(5));\n+    assert_eq!(6_i32.to_json(), I64(6));\n+    assert_eq!(7_i64.to_json(), I64(7));\n+    assert_eq!(8_usize.to_json(), U64(8));\n+    assert_eq!(9_u8.to_json(), U64(9));\n+    assert_eq!(10_u16.to_json(), U64(10));\n+    assert_eq!(11_u32.to_json(), U64(11));\n+    assert_eq!(12_u64.to_json(), U64(12));\n+    assert_eq!(13.0_f32.to_json(), F64(13.0_f64));\n+    assert_eq!(14.0_f64.to_json(), F64(14.0_f64));\n+    assert_eq!(().to_json(), Null);\n+    assert_eq!(f32::INFINITY.to_json(), Null);\n+    assert_eq!(f64::NAN.to_json(), Null);\n+    assert_eq!(true.to_json(), Boolean(true));\n+    assert_eq!(false.to_json(), Boolean(false));\n+    assert_eq!(\"abc\".to_json(), String(\"abc\".to_string()));\n+    assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n+    assert_eq!((1_usize, 2_usize).to_json(), array2);\n+    assert_eq!((1_usize, 2_usize, 3_usize).to_json(), array3);\n+    assert_eq!([1_usize, 2_usize].to_json(), array2);\n+    assert_eq!((&[1_usize, 2_usize, 3_usize]).to_json(), array3);\n+    assert_eq!((vec![1_usize, 2_usize]).to_json(), array2);\n+    assert_eq!(vec![1_usize, 2_usize, 3_usize].to_json(), array3);\n+    let mut tree_map = BTreeMap::new();\n+    tree_map.insert(\"a\".to_string(), 1 as usize);\n+    tree_map.insert(\"b\".to_string(), 2);\n+    assert_eq!(tree_map.to_json(), object);\n+    let mut hash_map = HashMap::new();\n+    hash_map.insert(\"a\".to_string(), 1 as usize);\n+    hash_map.insert(\"b\".to_string(), 2);\n+    assert_eq!(hash_map.to_json(), object);\n+    assert_eq!(Some(15).to_json(), I64(15));\n+    assert_eq!(Some(15 as usize).to_json(), U64(15));\n+    assert_eq!(None::<isize>.to_json(), Null);\n+}\n+\n+#[test]\n+fn test_encode_hashmap_with_arbitrary_key() {\n+    use std::collections::HashMap;\n+    #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n+    struct ArbitraryType(usize);\n+    let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n+    hm.insert(ArbitraryType(1), true);\n+    let mut mem_buf = string::String::new();\n+    let mut encoder = Encoder::new(&mut mem_buf);\n+    let result = hm.encode(&mut encoder);\n+    match result.unwrap_err() {\n+        EncoderError::BadHashmapKey => (),\n+        _ => panic!(\"expected bad hash map key\")\n+    }\n+}"}, {"sha": "fff6fc69e78428301107b5c101cf70b6d0f47ff3", "filename": "src/libserialize/tests/opaque.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308c07bc3b0d9fd60eb70525e377ca5e1653ae11/src%2Flibserialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Ftests%2Fopaque.rs?ref=308c07bc3b0d9fd60eb70525e377ca5e1653ae11", "patch": "@@ -0,0 +1,282 @@\n+extern crate serialize as rustc_serialize;\n+\n+use rustc_serialize::{Encodable, Decodable};\n+use rustc_serialize::opaque::{Encoder, Decoder};\n+use std::fmt::Debug;\n+\n+#[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+struct Struct {\n+    a: (),\n+    b: u8,\n+    c: u16,\n+    d: u32,\n+    e: u64,\n+    f: usize,\n+\n+    g: i8,\n+    h: i16,\n+    i: i32,\n+    j: i64,\n+    k: isize,\n+\n+    l: char,\n+    m: String,\n+    n: f32,\n+    o: f64,\n+    p: bool,\n+    q: Option<u32>,\n+}\n+\n+\n+fn check_round_trip<T: Encodable + Decodable + PartialEq + Debug>(values: Vec<T>) {\n+    let mut encoder = Encoder::new(Vec::new());\n+\n+    for value in &values {\n+        Encodable::encode(&value, &mut encoder).unwrap();\n+    }\n+\n+    let data = encoder.into_inner();\n+    let mut decoder = Decoder::new(&data[..], 0);\n+\n+    for value in values {\n+        let decoded = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(value, decoded);\n+    }\n+}\n+\n+#[test]\n+fn test_unit() {\n+    check_round_trip(vec![(), (), (), ()]);\n+}\n+\n+#[test]\n+fn test_u8() {\n+    let mut vec = vec![];\n+    for i in ::std::u8::MIN..::std::u8::MAX {\n+        vec.push(i);\n+    }\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_u16() {\n+    for i in ::std::u16::MIN..::std::u16::MAX {\n+        check_round_trip(vec![1, 2, 3, i, i, i]);\n+    }\n+}\n+\n+#[test]\n+fn test_u32() {\n+    check_round_trip(vec![1, 2, 3, ::std::u32::MIN, 0, 1, ::std::u32::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_u64() {\n+    check_round_trip(vec![1, 2, 3, ::std::u64::MIN, 0, 1, ::std::u64::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_usize() {\n+    check_round_trip(vec![1, 2, 3, ::std::usize::MIN, 0, 1, ::std::usize::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_i8() {\n+    let mut vec = vec![];\n+    for i in ::std::i8::MIN..::std::i8::MAX {\n+        vec.push(i);\n+    }\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_i16() {\n+    for i in ::std::i16::MIN..::std::i16::MAX {\n+        check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n+    }\n+}\n+\n+#[test]\n+fn test_i32() {\n+    check_round_trip(vec![-1, 2, -3, ::std::i32::MIN, 0, 1, ::std::i32::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_i64() {\n+    check_round_trip(vec![-1, 2, -3, ::std::i64::MIN, 0, 1, ::std::i64::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_isize() {\n+    check_round_trip(vec![-1, 2, -3, ::std::isize::MIN, 0, 1, ::std::isize::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_bool() {\n+    check_round_trip(vec![false, true, true, false, false]);\n+}\n+\n+#[test]\n+fn test_f32() {\n+    let mut vec = vec![];\n+    for i in -100..100 {\n+        vec.push((i as f32) / 3.0);\n+    }\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_f64() {\n+    let mut vec = vec![];\n+    for i in -100..100 {\n+        vec.push((i as f64) / 3.0);\n+    }\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_char() {\n+    let vec = vec!['a', 'b', 'c', 'd', 'A', 'X', ' ', '#', '\u00d6', '\u00c4', '\u00b5', '\u20ac'];\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_string() {\n+    let vec = vec![\"abcbu\u00d6eiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmeabpnvapeapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganei\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5nvapeapmaebn\".to_string()];\n+\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_option() {\n+    check_round_trip(vec![Some(-1i8)]);\n+    check_round_trip(vec![Some(-2i16)]);\n+    check_round_trip(vec![Some(-3i32)]);\n+    check_round_trip(vec![Some(-4i64)]);\n+    check_round_trip(vec![Some(-5isize)]);\n+\n+    let none_i8: Option<i8> = None;\n+    check_round_trip(vec![none_i8]);\n+\n+    let none_i16: Option<i16> = None;\n+    check_round_trip(vec![none_i16]);\n+\n+    let none_i32: Option<i32> = None;\n+    check_round_trip(vec![none_i32]);\n+\n+    let none_i64: Option<i64> = None;\n+    check_round_trip(vec![none_i64]);\n+\n+    let none_isize: Option<isize> = None;\n+    check_round_trip(vec![none_isize]);\n+}\n+\n+#[test]\n+fn test_struct() {\n+    check_round_trip(vec![Struct {\n+                              a: (),\n+                              b: 10,\n+                              c: 11,\n+                              d: 12,\n+                              e: 13,\n+                              f: 14,\n+\n+                              g: 15,\n+                              h: 16,\n+                              i: 17,\n+                              j: 18,\n+                              k: 19,\n+\n+                              l: 'x',\n+                              m: \"abc\".to_string(),\n+                              n: 20.5,\n+                              o: 21.5,\n+                              p: false,\n+                              q: None,\n+                          }]);\n+\n+    check_round_trip(vec![Struct {\n+                              a: (),\n+                              b: 101,\n+                              c: 111,\n+                              d: 121,\n+                              e: 131,\n+                              f: 141,\n+\n+                              g: -15,\n+                              h: -16,\n+                              i: -17,\n+                              j: -18,\n+                              k: -19,\n+\n+                              l: 'y',\n+                              m: \"def\".to_string(),\n+                              n: -20.5,\n+                              o: -21.5,\n+                              p: true,\n+                              q: Some(1234567),\n+                          }]);\n+}\n+\n+#[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+enum Enum {\n+    Variant1,\n+    Variant2(usize, f32),\n+    Variant3 {\n+        a: i32,\n+        b: char,\n+        c: bool,\n+    },\n+}\n+\n+#[test]\n+fn test_enum() {\n+    check_round_trip(vec![Enum::Variant1,\n+                          Enum::Variant2(1, 2.5),\n+                          Enum::Variant3 {\n+                              a: 3,\n+                              b: 'b',\n+                              c: false,\n+                          },\n+                          Enum::Variant3 {\n+                              a: -4,\n+                              b: 'f',\n+                              c: true,\n+                          }]);\n+}\n+\n+#[test]\n+fn test_sequence() {\n+    let mut vec = vec![];\n+    for i in -100i64..100i64 {\n+        vec.push(i * 100000);\n+    }\n+\n+    check_round_trip(vec![vec]);\n+}\n+\n+#[test]\n+fn test_hash_map() {\n+    use std::collections::HashMap;\n+    let mut map = HashMap::new();\n+    for i in -100i64..100i64 {\n+        map.insert(i * 100000, i * 10000);\n+    }\n+\n+    check_round_trip(vec![map]);\n+}\n+\n+#[test]\n+fn test_tuples() {\n+    check_round_trip(vec![('x', (), false, 0.5f32)]);\n+    check_round_trip(vec![(9i8, 10u16, 1.5f64)]);\n+    check_round_trip(vec![(-12i16, 11u8, 12usize)]);\n+    check_round_trip(vec![(1234567isize, 100000000000000u64, 99999999999999i64)]);\n+    check_round_trip(vec![(String::new(), \"some string\".to_string())]);\n+}"}]}