{"sha": "35ebf0348905a3a78025af4019e23ab97c86ec34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZWJmMDM0ODkwNWEzYTc4MDI1YWY0MDE5ZTIzYWI5N2M4NmVjMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T21:32:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T21:32:43Z"}, "message": "auto merge of #10312 : thestinger/rust/thread_local, r=alexcritchton\n\nThis provides a building block for fast thread-local storage. It does\r\nnot change the safety semantics of `static mut`.\r\n\r\nCloses #10310", "tree": {"sha": "3a1a084d2e09d55ed9023320fd8d8b242a35a4d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a1a084d2e09d55ed9023320fd8d8b242a35a4d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35ebf0348905a3a78025af4019e23ab97c86ec34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35ebf0348905a3a78025af4019e23ab97c86ec34", "html_url": "https://github.com/rust-lang/rust/commit/35ebf0348905a3a78025af4019e23ab97c86ec34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35ebf0348905a3a78025af4019e23ab97c86ec34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9a1869a5f4164d5311963b1b25b05f003d43699", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9a1869a5f4164d5311963b1b25b05f003d43699", "html_url": "https://github.com/rust-lang/rust/commit/e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "a5af479bb479a2a4d3289f9feed9ac3ff299a395", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5af479bb479a2a4d3289f9feed9ac3ff299a395", "html_url": "https://github.com/rust-lang/rust/commit/a5af479bb479a2a4d3289f9feed9ac3ff299a395"}], "stats": {"total": 139, "additions": 132, "deletions": 7}, "files": [{"sha": "852feef46516ceace329e9c1795a33229525442c", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35ebf0348905a3a78025af4019e23ab97c86ec34/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/35ebf0348905a3a78025af4019e23ab97c86ec34/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=35ebf0348905a3a78025af4019e23ab97c86ec34", "patch": "@@ -1754,6 +1754,8 @@ names are effectively reserved. Some significant attributes include:\n * The `deriving` attribute, for automatically generating\n   implementations of certain traits.\n * The `static_assert` attribute, for asserting that a static bool is true at compiletime\n+* The `thread_local` attribute, for defining a `static mut` as a thread-local. Note that this is\n+  only a low-level building block, and is not local to a *task*, nor does it provide safety.\n \n Other attributes may be added or removed during development of the language.\n "}, {"sha": "be35a309c44a24899a44a2fdf60b42211ee413be", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=35ebf0348905a3a78025af4019e23ab97c86ec34", "patch": "@@ -38,6 +38,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"asm\", Active),\n     (\"managed_boxes\", Active),\n     (\"non_ascii_idents\", Active),\n+    (\"thread_local\", Active),\n \n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n@@ -107,6 +108,17 @@ impl Visitor<()> for Context {\n     }\n \n     fn visit_item(&mut self, i: @ast::item, _:()) {\n+        // NOTE: uncomment after snapshot\n+        /*\n+        for attr in i.attrs.iter() {\n+            if \"thread_local\" == attr.name() {\n+                self.gate_feature(\"thread_local\", i.span,\n+                                  \"`#[thread_local]` is an experimental feature, and does not \\\n+                                  currently handle destructors. There is no corresponding \\\n+                                  `#[task_local]` mapping to the task model\");\n+            }\n+        }\n+        */\n         match i.node {\n             ast::item_enum(ref def, _) => {\n                 for variant in def.variants.iter() {\n@@ -152,8 +164,8 @@ impl Visitor<()> for Context {\n             },\n             ast::ty_box(_) => {\n                 self.gate_feature(\"managed_boxes\", t.span,\n-                                  \"The managed box syntax is being replaced by the `std::gc::Gc`\n-                                  and `std::rc::Rc` types. Equivalent functionality to managed\n+                                  \"The managed box syntax is being replaced by the `std::gc::Gc` \\\n+                                  and `std::rc::Rc` types. Equivalent functionality to managed \\\n                                   trait objects will be implemented but is currently missing.\");\n             }\n             _ => {}"}, {"sha": "7890f0033104f854b1749ab1f456bbebdc3cfd6d", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=35ebf0348905a3a78025af4019e23ab97c86ec34", "patch": "@@ -1749,6 +1749,12 @@ pub fn SetUnnamedAddr(Global: ValueRef, Unnamed: bool) {\n     }\n }\n \n+pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n+    unsafe {\n+        llvm::LLVMSetThreadLocal(global, is_thread_local as Bool);\n+    }\n+}\n+\n pub fn ConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef {\n     unsafe {\n         llvm::LLVMConstICmp(Pred as c_ushort, V1, V2)"}, {"sha": "90280292a87bd4109daec0430ad27967909148ea", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=35ebf0348905a3a78025af4019e23ab97c86ec34", "patch": "@@ -816,6 +816,7 @@ static obsolete_attrs: &'static [(&'static str, &'static str)] = &[\n static other_attrs: &'static [&'static str] = &[\n     // item-level\n     \"address_insignificant\", // can be crate-level too\n+    \"thread_local\", // for statics\n     \"allow\", \"deny\", \"forbid\", \"warn\", // lint options\n     \"deprecated\", \"experimental\", \"unstable\", \"stable\", \"locked\", \"frozen\", //item stability\n     \"crate_map\", \"cfg\", \"doc\", \"export_name\", \"link_section\", \"no_freeze\","}, {"sha": "29dff75eeebcd064421e8ca44781e4dda587bce1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=35ebf0348905a3a78025af4019e23ab97c86ec34", "patch": "@@ -2544,6 +2544,10 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                     inlineable = true;\n                                 }\n \n+                                if attr::contains_name(i.attrs, \"thread_local\") {\n+                                    lib::llvm::set_thread_local(g, true);\n+                                }\n+\n                                 if !inlineable {\n                                     debug!(\"{} not inlined\", sym);\n                                     ccx.non_inlineable_statics.insert(id);"}, {"sha": "e0e8750e146fc308c47eb690418b2d13742fd969", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 101, "deletions": 5, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=35ebf0348905a3a78025af4019e23ab97c86ec34", "patch": "@@ -17,16 +17,35 @@\n \n use libc::c_void;\n use cast;\n+#[cfg(stage0)]\n+#[cfg(windows)]\n use ptr;\n use cell::Cell;\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n+#[cfg(stage0)]\n+#[cfg(windows)]\n use unstable::mutex::{Mutex, MUTEX_INIT};\n+#[cfg(stage0)]\n+#[cfg(windows)]\n use tls = rt::thread_local_storage;\n \n+#[cfg(not(stage0), not(windows), test)]\n+#[thread_local]\n+pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;\n+\n+#[cfg(not(stage0), not(windows), not(test))]\n+#[thread_local]\n+pub static mut RT_TLS_PTR: *mut c_void = 0 as *mut c_void;\n+\n+#[cfg(stage0)]\n+#[cfg(windows)]\n static mut RT_TLS_KEY: tls::Key = -1;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n+#[inline(never)]\n+#[cfg(stage0)]\n+#[cfg(windows)]\n pub fn init_tls_key() {\n     static mut lock: Mutex = MUTEX_INIT;\n     static mut initialized: bool = false;\n@@ -41,24 +60,42 @@ pub fn init_tls_key() {\n     }\n }\n \n+#[cfg(not(stage0), not(windows))]\n+pub fn init_tls_key() {}\n+\n /// Give a pointer to thread-local storage.\n ///\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n #[inline]\n+#[cfg(stage0)]\n+#[cfg(windows)]\n pub unsafe fn put<T>(sched: ~T) {\n     let key = tls_key();\n     let void_ptr: *mut c_void = cast::transmute(sched);\n     tls::set(key, void_ptr);\n }\n \n+/// Give a pointer to thread-local storage.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+#[inline]\n+#[cfg(not(stage0), not(windows))]\n+pub unsafe fn put<T>(sched: ~T) {\n+    RT_TLS_PTR = cast::transmute(sched)\n+}\n+\n /// Take ownership of a pointer from thread-local storage.\n ///\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n #[inline]\n+#[cfg(stage0)]\n+#[cfg(windows)]\n pub unsafe fn take<T>() -> ~T {\n     let key = tls_key();\n     let void_ptr: *mut c_void = tls::get(key);\n@@ -70,13 +107,28 @@ pub unsafe fn take<T>() -> ~T {\n     return ptr;\n }\n \n+/// Take ownership of a pointer from thread-local storage.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+#[inline]\n+#[cfg(not(stage0), not(windows))]\n+pub unsafe fn take<T>() -> ~T {\n+    let ptr: ~T = cast::transmute(RT_TLS_PTR);\n+    RT_TLS_PTR = cast::transmute(0); // can't use `as`, due to type not matching with `cfg(test)`\n+    ptr\n+}\n+\n /// Take ownership of a pointer from thread-local storage.\n ///\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n /// Leaves the old pointer in TLS for speed.\n #[inline]\n+#[cfg(stage0)]\n+#[cfg(windows)]\n pub unsafe fn unsafe_take<T>() -> ~T {\n     let key = tls_key();\n     let void_ptr: *mut c_void = tls::get(key);\n@@ -87,7 +139,21 @@ pub unsafe fn unsafe_take<T>() -> ~T {\n     return ptr;\n }\n \n+/// Take ownership of a pointer from thread-local storage.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+/// Leaves the old pointer in TLS for speed.\n+#[inline]\n+#[cfg(not(stage0), not(windows))]\n+pub unsafe fn unsafe_take<T>() -> ~T {\n+    cast::transmute(RT_TLS_PTR)\n+}\n+\n /// Check whether there is a thread-local pointer installed.\n+#[cfg(stage0)]\n+#[cfg(windows)]\n pub fn exists() -> bool {\n     unsafe {\n         match maybe_tls_key() {\n@@ -97,6 +163,14 @@ pub fn exists() -> bool {\n     }\n }\n \n+/// Check whether there is a thread-local pointer installed.\n+#[cfg(not(stage0), not(windows))]\n+pub fn exists() -> bool {\n+    unsafe {\n+        RT_TLS_PTR.is_not_null()\n+    }\n+}\n+\n /// Borrow the thread-local value from thread-local storage.\n /// While the value is borrowed it is not available in TLS.\n ///\n@@ -119,6 +193,8 @@ pub unsafe fn borrow<T>(f: |&mut T|) {\n ///\n /// Because this leaves the value in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n+#[cfg(stage0)]\n+#[cfg(windows)]\n pub unsafe fn unsafe_borrow<T>() -> *mut T {\n     let key = tls_key();\n     let void_ptr = tls::get(key);\n@@ -128,6 +204,16 @@ pub unsafe fn unsafe_borrow<T>() -> *mut T {\n     void_ptr as *mut T\n }\n \n+#[cfg(not(stage0), not(windows))]\n+pub unsafe fn unsafe_borrow<T>() -> *mut T {\n+    if RT_TLS_PTR.is_null() {\n+        rtabort!(\"thread-local pointer is null. bogus!\");\n+    }\n+    RT_TLS_PTR as *mut T\n+}\n+\n+#[cfg(stage0)]\n+#[cfg(windows)]\n pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n     match maybe_tls_key() {\n         Some(key) => {\n@@ -142,7 +228,18 @@ pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n     }\n }\n \n+#[cfg(not(stage0), not(windows))]\n+pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n+    if RT_TLS_PTR.is_null() {\n+        None\n+    } else {\n+        Some(RT_TLS_PTR as *mut T)\n+    }\n+}\n+\n #[inline]\n+#[cfg(stage0)]\n+#[cfg(windows)]\n fn tls_key() -> tls::Key {\n     match maybe_tls_key() {\n         Some(key) => key,\n@@ -151,7 +248,8 @@ fn tls_key() -> tls::Key {\n }\n \n #[inline]\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n+#[cfg(not(test), windows)]\n pub fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n         // NB: This is a little racy because, while the key is\n@@ -172,11 +270,9 @@ pub fn maybe_tls_key() -> Option<tls::Key> {\n     }\n }\n \n-// XXX: The boundary between the running runtime and the testing runtime\n-// seems to be fuzzy at the moment, and trying to use two different keys\n-// results in disaster. This should not be necessary.\n #[inline]\n-#[cfg(test)]\n+#[cfg(test, stage0)]\n+#[cfg(test, windows)]\n pub fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe { ::cast::transmute(::realstd::rt::shouldnt_be_public::maybe_tls_key()) }\n }"}, {"sha": "860b65b20c6654100fb707fecf20ef91afba8b56", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ebf0348905a3a78025af4019e23ab97c86ec34/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=35ebf0348905a3a78025af4019e23ab97c86ec34", "patch": "@@ -95,7 +95,11 @@ pub use self::kill::BlockedTask;\n pub mod shouldnt_be_public {\n     pub use super::select::SelectInner;\n     pub use super::select::{SelectInner, SelectPortInner};\n+    #[cfg(stage0)]\n+    #[cfg(windows)]\n     pub use super::local_ptr::maybe_tls_key;\n+    #[cfg(not(stage0), not(windows))]\n+    pub use super::local_ptr::RT_TLS_PTR;\n }\n \n // Internal macros used by the runtime."}]}