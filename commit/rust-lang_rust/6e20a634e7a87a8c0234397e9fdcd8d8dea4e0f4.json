{"sha": "6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "node_id": "C_kwDOAAsO6NoAKDZlMjBhNjM0ZTdhODdhOGMwMjM0Mzk3ZTlmZGNkOGQ4ZGVhNGUwZjQ", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-06T13:26:59Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-06T14:12:30Z"}, "message": "Don't lint `manual_non_exhaustive` when the enum variant is used", "tree": {"sha": "bdd1a54d87be09fef504661f46ef3474bf9a6f37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd1a54d87be09fef504661f46ef3474bf9a6f37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "html_url": "https://github.com/rust-lang/rust/commit/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a095064062b3a832eea919efdc4761a697803b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a095064062b3a832eea919efdc4761a697803b4", "html_url": "https://github.com/rust-lang/rust/commit/9a095064062b3a832eea919efdc4761a697803b4"}], "stats": {"total": 420, "additions": 246, "deletions": 174}, "files": [{"sha": "b4a70988286ae4e614fa93a7750a5b2c95e036dc", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "patch": "@@ -575,7 +575,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(approx_const::ApproxConstant::new(msrv)));\n     store.register_late_pass(move || Box::new(methods::Methods::new(avoid_breaking_exported_api, msrv)));\n     store.register_late_pass(move || Box::new(matches::Matches::new(msrv)));\n-    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustive::new(msrv)));\n+    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n+    store.register_late_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_strip::ManualStrip::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_field_names::RedundantFieldNames::new(msrv)));"}, {"sha": "7b4b8d6bffa0cfb969da6372833fac41febe1cdc", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 115, "deletions": 62, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "patch": "@@ -1,13 +1,18 @@\n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{meets_msrv, msrvs};\n+use clippy_utils::{is_lint_allowed, meets_msrv, msrvs};\n use if_chain::if_chain;\n-use rustc_ast::ast::{FieldDef, Item, ItemKind, Variant, VariantData, VisibilityKind};\n+use rustc_ast::ast::{self, FieldDef, VisibilityKind};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{self as hir, Expr, ExprKind, QPath};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::DefIdTree;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n@@ -58,55 +63,84 @@ declare_clippy_lint! {\n     \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\"\n }\n \n-#[derive(Clone)]\n-pub struct ManualNonExhaustive {\n+#[allow(clippy::module_name_repetitions)]\n+pub struct ManualNonExhaustiveStruct {\n     msrv: Option<RustcVersion>,\n }\n \n-impl ManualNonExhaustive {\n+impl ManualNonExhaustiveStruct {\n     #[must_use]\n     pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self { msrv }\n     }\n }\n \n-impl_lint_pass!(ManualNonExhaustive => [MANUAL_NON_EXHAUSTIVE]);\n+impl_lint_pass!(ManualNonExhaustiveStruct => [MANUAL_NON_EXHAUSTIVE]);\n \n-impl EarlyLintPass for ManualNonExhaustive {\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+#[allow(clippy::module_name_repetitions)]\n+pub struct ManualNonExhaustiveEnum {\n+    msrv: Option<RustcVersion>,\n+    constructed_enum_variants: FxHashSet<(DefId, DefId)>,\n+    potential_enums: Vec<(LocalDefId, LocalDefId, Span, Span)>,\n+}\n+\n+impl ManualNonExhaustiveEnum {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            constructed_enum_variants: FxHashSet::default(),\n+            potential_enums: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(ManualNonExhaustiveEnum => [MANUAL_NON_EXHAUSTIVE]);\n+\n+impl EarlyLintPass for ManualNonExhaustiveStruct {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n             return;\n         }\n \n-        match &item.kind {\n-            ItemKind::Enum(def, _) => {\n-                check_manual_non_exhaustive_enum(cx, item, &def.variants);\n-            },\n-            ItemKind::Struct(variant_data, _) => {\n-                if let VariantData::Unit(..) = variant_data {\n-                    return;\n-                }\n-\n-                check_manual_non_exhaustive_struct(cx, item, variant_data);\n-            },\n-            _ => {},\n+        if let ast::ItemKind::Struct(variant_data, _) = &item.kind {\n+            if let ast::VariantData::Unit(..) = variant_data {\n+                return;\n+            }\n+\n+            check_manual_non_exhaustive_struct(cx, item, variant_data);\n         }\n     }\n \n     extract_msrv_attr!(EarlyContext);\n }\n \n-fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants: &[Variant]) {\n-    fn is_non_exhaustive_marker(variant: &Variant) -> bool {\n-        matches!(variant.data, VariantData::Unit(_))\n-            && variant.ident.as_str().starts_with('_')\n-            && is_doc_hidden(&variant.attrs)\n+fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &ast::Item, data: &ast::VariantData) {\n+    fn is_private(field: &FieldDef) -> bool {\n+        matches!(field.vis.kind, VisibilityKind::Inherited)\n+    }\n+\n+    fn is_non_exhaustive_marker(field: &FieldDef) -> bool {\n+        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n+    }\n+\n+    fn find_header_span(cx: &EarlyContext<'_>, item: &ast::Item, data: &ast::VariantData) -> Span {\n+        let delimiter = match data {\n+            ast::VariantData::Struct(..) => '{',\n+            ast::VariantData::Tuple(..) => '(',\n+            ast::VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n+        };\n+\n+        cx.sess().source_map().span_until_char(item.span, delimiter)\n     }\n \n-    let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n+    let fields = data.fields();\n+    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n+    let public_fields = fields.iter().filter(|f| f.vis.kind.is_pub()).count();\n+\n     if_chain! {\n-        if let Some(marker) = markers.next();\n-        if markers.count() == 0 && variants.len() > 1;\n+        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n+        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n         then {\n             span_lint_and_then(\n                 cx,\n@@ -116,7 +150,7 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n                 |diag| {\n                     if_chain! {\n                         if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = cx.sess().source_map().span_until_char(item.span, '{');\n+                        let header_span = find_header_span(cx, item, data);\n                         if let Some(snippet) = snippet_opt(cx, header_span);\n                         then {\n                             diag.span_suggestion(\n@@ -127,60 +161,79 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n                             );\n                         }\n                     }\n-                    diag.span_help(marker.span, \"remove this variant\");\n+                    diag.span_help(marker.span, \"remove this field\");\n                 });\n         }\n     }\n }\n \n-fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) {\n-    fn is_private(field: &FieldDef) -> bool {\n-        matches!(field.vis.kind, VisibilityKind::Inherited)\n-    }\n+impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n+            return;\n+        }\n \n-    fn is_non_exhaustive_marker(field: &FieldDef) -> bool {\n-        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n+        if let hir::ItemKind::Enum(def, _) = &item.kind\n+            && def.variants.len() > 1\n+        {\n+            let mut iter = def.variants.iter().filter_map(|v| {\n+                let id = cx.tcx.hir().local_def_id(v.id);\n+                (matches!(v.data, hir::VariantData::Unit(_))\n+                    && v.ident.as_str().starts_with('_')\n+                    && is_doc_hidden(cx.tcx.get_attrs(id.to_def_id())))\n+                .then(|| (id, v.span))\n+            });\n+            if let Some((id, span)) = iter.next()\n+                && iter.next().is_none()\n+            {\n+                self.potential_enums.push((item.def_id, id, item.span, span));\n+            }\n+        }\n     }\n \n-    fn find_header_span(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) -> Span {\n-        let delimiter = match data {\n-            VariantData::Struct(..) => '{',\n-            VariantData::Tuple(..) => '(',\n-            VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n-        };\n-\n-        cx.sess().source_map().span_until_char(item.span, delimiter)\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Path(QPath::Resolved(None, p)) = &e.kind\n+            && let [.., name] = p.segments\n+            && let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = p.res\n+            && name.ident.as_str().starts_with('_')\n+            && let Some(variant_id) = cx.tcx.parent(id)\n+            && let Some(enum_id) = cx.tcx.parent(variant_id)\n+        {\n+            self.constructed_enum_variants.insert((enum_id, variant_id));\n+        }\n     }\n \n-    let fields = data.fields();\n-    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n-    let public_fields = fields.iter().filter(|f| f.vis.kind.is_pub()).count();\n-\n-    if_chain! {\n-        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n-        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n-        then {\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        for &(enum_id, _, enum_span, variant_span) in\n+            self.potential_enums.iter().filter(|&&(enum_id, variant_id, _, _)| {\n+                !self\n+                    .constructed_enum_variants\n+                    .contains(&(enum_id.to_def_id(), variant_id.to_def_id()))\n+                    && !is_lint_allowed(cx, MANUAL_NON_EXHAUSTIVE, cx.tcx.hir().local_def_id_to_hir_id(enum_id))\n+            })\n+        {\n             span_lint_and_then(\n                 cx,\n                 MANUAL_NON_EXHAUSTIVE,\n-                item.span,\n+                enum_span,\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n-                    if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = find_header_span(cx, item, data);\n-                        if let Some(snippet) = snippet_opt(cx, header_span);\n-                        then {\n+                    if !cx.tcx.adt_def(enum_id).is_variant_list_non_exhaustive()\n+                        && let header_span = cx.sess().source_map().span_until_char(enum_span, '{')\n+                        && let Some(snippet) = snippet_opt(cx, header_span)\n+                    {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n                                 format!(\"#[non_exhaustive] {}\", snippet),\n                                 Applicability::Unspecified,\n                             );\n-                        }\n                     }\n-                    diag.span_help(marker.span, \"remove this field\");\n-                });\n+                    diag.span_help(variant_span, \"remove this variant\");\n+                },\n+            );\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }"}, {"sha": "f23c6d69b4c6a4142c008597588e656711c4e2bd", "filename": "tests/ui/manual_non_exhaustive_enum.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/tests%2Fui%2Fmanual_non_exhaustive_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/tests%2Fui%2Fmanual_non_exhaustive_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_enum.rs?ref=6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "patch": "@@ -0,0 +1,78 @@\n+#![warn(clippy::manual_non_exhaustive)]\n+#![allow(unused)]\n+\n+enum E {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// user forgot to remove the marker\n+#[non_exhaustive]\n+enum Ep {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// marker variant does not have doc hidden attribute, should be ignored\n+enum NoDocHidden {\n+    A,\n+    B,\n+    _C,\n+}\n+\n+// name of variant with doc hidden does not start with underscore, should be ignored\n+enum NoUnderscore {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    C,\n+}\n+\n+// variant with doc hidden is not unit, should be ignored\n+enum NotUnit {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C(bool),\n+}\n+\n+// variant with doc hidden is the only one, should be ignored\n+enum OnlyMarker {\n+    #[doc(hidden)]\n+    _A,\n+}\n+\n+// variant with multiple markers, should be ignored\n+enum MultipleMarkers {\n+    A,\n+    #[doc(hidden)]\n+    _B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// already non_exhaustive and no markers, should be ignored\n+#[non_exhaustive]\n+enum NonExhaustive {\n+    A,\n+    B,\n+}\n+\n+// marked is used, don't lint\n+enum UsedHidden {\n+    #[doc(hidden)]\n+    _A,\n+    B,\n+    C,\n+}\n+fn foo(x: &mut UsedHidden) {\n+    if matches!(*x, UsedHidden::B) {\n+        *x = UsedHidden::_A;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "317a45d2cbd596ab306cae15880279b1c49d8dff", "filename": "tests/ui/manual_non_exhaustive_enum.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr?ref=6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "patch": "@@ -0,0 +1,41 @@\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive_enum.rs:4:1\n+   |\n+LL |   enum E {\n+   |   ^-----\n+   |   |\n+   |  _help: add the attribute: `#[non_exhaustive] enum E`\n+   | |\n+LL | |     A,\n+LL | |     B,\n+LL | |     #[doc(hidden)]\n+LL | |     _C,\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive_enum.rs:8:5\n+   |\n+LL |     _C,\n+   |     ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive_enum.rs:13:1\n+   |\n+LL | / enum Ep {\n+LL | |     A,\n+LL | |     B,\n+LL | |     #[doc(hidden)]\n+LL | |     _C,\n+LL | | }\n+   | |_^\n+   |\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive_enum.rs:17:5\n+   |\n+LL |     _C,\n+   |     ^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "498eee4447b8841cf275d462abf3d957e3c8403f", "filename": "tests/ui/manual_non_exhaustive_struct.rs", "status": "renamed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/tests%2Fui%2Fmanual_non_exhaustive_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/tests%2Fui%2Fmanual_non_exhaustive_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_struct.rs?ref=6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "patch": "@@ -1,69 +1,6 @@\n #![warn(clippy::manual_non_exhaustive)]\n #![allow(unused)]\n \n-mod enums {\n-    enum E {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // user forgot to remove the marker\n-    #[non_exhaustive]\n-    enum Ep {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // marker variant does not have doc hidden attribute, should be ignored\n-    enum NoDocHidden {\n-        A,\n-        B,\n-        _C,\n-    }\n-\n-    // name of variant with doc hidden does not start with underscore, should be ignored\n-    enum NoUnderscore {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        C,\n-    }\n-\n-    // variant with doc hidden is not unit, should be ignored\n-    enum NotUnit {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C(bool),\n-    }\n-\n-    // variant with doc hidden is the only one, should be ignored\n-    enum OnlyMarker {\n-        #[doc(hidden)]\n-        _A,\n-    }\n-\n-    // variant with multiple markers, should be ignored\n-    enum MultipleMarkers {\n-        A,\n-        #[doc(hidden)]\n-        _B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // already non_exhaustive and no markers, should be ignored\n-    #[non_exhaustive]\n-    enum NonExhaustive {\n-        A,\n-        B,\n-    }\n-}\n-\n mod structs {\n     struct S {\n         pub a: i32,", "previous_filename": "tests/ui/manual_non_exhaustive.rs"}, {"sha": "e0766c17b758038c5cbf7a4ef007a3005c91f5c9", "filename": "tests/ui/manual_non_exhaustive_struct.stderr", "status": "renamed", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr?ref=6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "patch": "@@ -1,44 +1,5 @@\n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:5:5\n-   |\n-LL |       enum E {\n-   |       ^-----\n-   |       |\n-   |  _____help: add the attribute: `#[non_exhaustive] enum E`\n-   | |\n-LL | |         A,\n-LL | |         B,\n-LL | |         #[doc(hidden)]\n-LL | |         _C,\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n-help: remove this variant\n-  --> $DIR/manual_non_exhaustive.rs:9:9\n-   |\n-LL |         _C,\n-   |         ^^\n-\n-error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:14:5\n-   |\n-LL | /     enum Ep {\n-LL | |         A,\n-LL | |         B,\n-LL | |         #[doc(hidden)]\n-LL | |         _C,\n-LL | |     }\n-   | |_____^\n-   |\n-help: remove this variant\n-  --> $DIR/manual_non_exhaustive.rs:18:9\n-   |\n-LL |         _C,\n-   |         ^^\n-\n-error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:68:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:5:5\n    |\n LL |       struct S {\n    |       ^-------\n@@ -51,14 +12,15 @@ LL | |         _c: (),\n LL | |     }\n    | |_____^\n    |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:71:9\n+  --> $DIR/manual_non_exhaustive_struct.rs:8:9\n    |\n LL |         _c: (),\n    |         ^^^^^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:76:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:13:5\n    |\n LL | /     struct Sp {\n LL | |         pub a: i32,\n@@ -68,36 +30,36 @@ LL | |     }\n    | |_____^\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:79:9\n+  --> $DIR/manual_non_exhaustive_struct.rs:16:9\n    |\n LL |         _c: (),\n    |         ^^^^^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:117:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:54:5\n    |\n LL |     struct T(pub i32, pub i32, ());\n    |     --------^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     help: add the attribute: `#[non_exhaustive] struct T`\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:117:32\n+  --> $DIR/manual_non_exhaustive_struct.rs:54:32\n    |\n LL |     struct T(pub i32, pub i32, ());\n    |                                ^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:121:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:58:5\n    |\n LL |     struct Tp(pub i32, pub i32, ());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:121:33\n+  --> $DIR/manual_non_exhaustive_struct.rs:58:33\n    |\n LL |     struct Tp(pub i32, pub i32, ());\n    |                                 ^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n ", "previous_filename": "tests/ui/manual_non_exhaustive.stderr"}]}