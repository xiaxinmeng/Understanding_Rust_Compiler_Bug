{"sha": "6189e6cdba6d12ab65baafd95c5f8a6e0cc37937", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxODllNmNkYmE2ZDEyYWI2NWJhYWZkOTVjNWY4YTZlMGNjMzc5Mzc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-02T09:01:21Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-12T04:31:13Z"}, "message": "Clean up statement parsing without changing the semantics of `parse_stmt`.", "tree": {"sha": "68ce7a7ccc4d4ca3cc70c10f935a5ecb0055951b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68ce7a7ccc4d4ca3cc70c10f935a5ecb0055951b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937", "html_url": "https://github.com/rust-lang/rust/commit/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3265bd54b5b3f32d038273afec7554f007a5ce1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3265bd54b5b3f32d038273afec7554f007a5ce1d", "html_url": "https://github.com/rust-lang/rust/commit/3265bd54b5b3f32d038273afec7554f007a5ce1d"}], "stats": {"total": 171, "additions": 59, "deletions": 112}, "files": [{"sha": "99e37ec80c0817802e2abeb08b4bfbef9583308b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6189e6cdba6d12ab65baafd95c5f8a6e0cc37937", "patch": "@@ -804,6 +804,19 @@ pub struct Stmt {\n     pub span: Span,\n }\n \n+impl Stmt {\n+    pub fn add_trailing_semicolon(mut self) -> Self {\n+        self.node = match self.node {\n+            StmtKind::Expr(expr) => StmtKind::Semi(expr),\n+            StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, _style, attrs)| {\n+                (mac, MacStmtStyle::Semicolon, attrs)\n+            })),\n+            node @ _ => node,\n+        };\n+        self\n+    }\n+}\n+\n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"stmt({}: {})\", self.id.to_string(), pprust::stmt_to_string(self))"}, {"sha": "220e0a753c30b5b1e7f2c53e1adbc775590274df", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6189e6cdba6d12ab65baafd95c5f8a6e0cc37937", "patch": "@@ -444,14 +444,7 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     // semicolon to the final statement produced by expansion.\n     if style == MacStmtStyle::Semicolon {\n         if let Some(stmt) = fully_expanded.pop() {\n-            fully_expanded.push(Stmt {\n-                id: stmt.id,\n-                node: match stmt.node {\n-                    StmtKind::Expr(expr) => StmtKind::Semi(expr),\n-                    _ => stmt.node /* might already have a semi */\n-                },\n-                span: stmt.span,\n-            });\n+            fully_expanded.push(stmt.add_trailing_semicolon());\n         }\n     }\n "}, {"sha": "0dd8c199827d29ed4a53a9fdc726747f2b2e360b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 45, "deletions": 104, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6189e6cdba6d12ab65baafd95c5f8a6e0cc37937/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6189e6cdba6d12ab65baafd95c5f8a6e0cc37937", "patch": "@@ -3789,7 +3789,13 @@ impl<'a> Parser<'a> {\n         self.span_err(self.last_span, message);\n     }\n \n-    /// Parse a statement. may include decl.\n+    /// Parse a statement. This stops just before trailing semicolons on everything but items.\n+    /// e.g. a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n+    ///\n+    /// Also, if a macro begins an expression statement, this only parses the macro. For example,\n+    /// ```rust\n+    /// vec![1].into_iter(); //< `parse_stmt` only parses the \"vec![1]\"\n+    /// ```\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n         Ok(self.parse_stmt_())\n     }\n@@ -4038,36 +4044,14 @@ impl<'a> Parser<'a> {\n         let mut stmts = vec![];\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let Stmt {node, span, ..} = if let Some(s) = self.parse_stmt_() {\n-                s\n+            if let Some(stmt) = self.parse_stmt_() {\n+                stmts.push(self.finish_parsing_statement(stmt)?);\n             } else if self.token == token::Eof {\n                 break;\n             } else {\n                 // Found only `;` or `}`.\n                 continue;\n             };\n-\n-            match node {\n-                StmtKind::Expr(e) => {\n-                    self.handle_expression_like_statement(e, span, &mut stmts)?;\n-                }\n-                StmtKind::Mac(mac) => {\n-                    self.handle_macro_in_block(mac.unwrap(), span, &mut stmts)?;\n-                }\n-                _ => { // all other kinds of statements:\n-                    let mut hi = span.hi;\n-                    if classify::stmt_ends_with_semi(&node) {\n-                        self.expect(&token::Semi)?;\n-                        hi = self.last_span.hi;\n-                    }\n-\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: node,\n-                        span: mk_sp(span.lo, hi)\n-                    });\n-                }\n-            }\n         }\n \n         Ok(P(ast::Block {\n@@ -4078,93 +4062,50 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn handle_macro_in_block(&mut self,\n-                             (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinVec<Attribute>),\n-                             span: Span,\n-                             stmts: &mut Vec<Stmt>)\n-                             -> PResult<'a, ()> {\n-        if style == MacStmtStyle::NoBraces {\n-            // statement macro without braces; might be an\n-            // expr depending on whether a semicolon follows\n-            match self.token {\n-                token::Semi => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n-                        span: mk_sp(span.lo, self.span.hi),\n-                    });\n-                    self.bump();\n-                }\n-                _ => {\n-                    let e = self.mk_mac_expr(span.lo, span.hi, mac.node, ThinVec::new());\n-                    let lo = e.span.lo;\n-                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                    self.handle_expression_like_statement(e, span, stmts)?;\n-                }\n-            }\n-        } else {\n-            // statement macro; might be an expr\n-            match self.token {\n-                token::Semi => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n-                        span: mk_sp(span.lo, self.span.hi),\n-                    });\n-                    self.bump();\n-                }\n-                _ => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, style, attrs))),\n-                        span: span\n-                    });\n-                }\n+    /// Finish parsing expressions that start with macros and handle trailing semicolons\n+    /// (or the lack thereof) -- c.f. `parse_stmt`.\n+    fn finish_parsing_statement(&mut self, mut stmt: Stmt) -> PResult<'a, Stmt> {\n+        if let StmtKind::Mac(mac) = stmt.node {\n+            if mac.1 != MacStmtStyle::NoBraces || self.token == token::Semi {\n+                stmt.node = StmtKind::Mac(mac);\n+            } else {\n+                let (mac, _style, attrs) = mac.unwrap();\n+                let e = self.mk_mac_expr(stmt.span.lo, stmt.span.hi, mac.node, ThinVec::new());\n+                let e = self.parse_dot_or_call_expr_with(e, stmt.span.lo, attrs)?;\n+                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                stmt.node = StmtKind::Expr(e);\n             }\n         }\n-        Ok(())\n+\n+        self.handle_trailing_semicolon(stmt)\n     }\n \n-    fn handle_expression_like_statement(&mut self,\n-                                        e: P<Expr>,\n-                                        span: Span,\n-                                        stmts: &mut Vec<Stmt>)\n-                                        -> PResult<'a, ()> {\n-        // expression without semicolon\n-        if classify::expr_requires_semi_to_be_stmt(&e) {\n-            // Just check for errors and recover; do not eat semicolon yet.\n-            if let Err(mut e) =\n-                self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n-            {\n-                e.emit();\n-                self.recover_stmt();\n+    fn handle_trailing_semicolon(&mut self, mut stmt: Stmt) -> PResult<'a, Stmt> {\n+        match stmt.node {\n+            StmtKind::Expr(ref expr) => {\n+                // expression without semicolon\n+                if classify::expr_requires_semi_to_be_stmt(expr) {\n+                    // Just check for errors and recover; do not eat semicolon yet.\n+                    if let Err(mut e) =\n+                        self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                    {\n+                        e.emit();\n+                        self.recover_stmt();\n+                    }\n+                }\n             }\n+            StmtKind::Local(..) => {\n+                self.expect_one_of(&[token::Semi], &[])?;\n+            }\n+            _ => {}\n         }\n \n-        match self.token {\n-            token::Semi => {\n-                self.bump();\n-                let span_with_semi = Span {\n-                    lo: span.lo,\n-                    hi: self.last_span.hi,\n-                    expn_id: span.expn_id,\n-                };\n-                stmts.push(Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Semi(e),\n-                    span: span_with_semi,\n-                });\n-            }\n-            _ => {\n-                stmts.push(Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Expr(e),\n-                    span: span\n-                });\n-            }\n+        if self.eat(&token::Semi) {\n+            stmt = stmt.add_trailing_semicolon();\n         }\n-        Ok(())\n+\n+        stmt.span.hi = self.last_span.hi;\n+        Ok(stmt)\n     }\n \n     // Parses a sequence of bounds if a `:` is found,"}]}