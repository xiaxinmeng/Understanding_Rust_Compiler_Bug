{"sha": "5139b538367eb094d48fd150cd2d719a2885b56c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMzliNTM4MzY3ZWIwOTRkNDhmZDE1MGNkMmQ3MTlhMjg4NWI1NmM=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-11-27T21:28:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-27T21:28:34Z"}, "message": "Rollup merge of #66399 - eddyb:rmeta-table-cleanup, r=Mark-Simulacrum\n\nrustc_metadata: simplify the interactions between Lazy and Table.\n\nThese are small post-#59953 cleanups (including undoing some contrivances from that PR).\n\nr? @michaelwoerister", "tree": {"sha": "7a39b0d42046e8c531b96eb96d4cf1d7084e133b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a39b0d42046e8c531b96eb96d4cf1d7084e133b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5139b538367eb094d48fd150cd2d719a2885b56c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd3uqCCRBK7hj4Ov3rIwAAdHIIAEE4jqnqTaD8ZC7Gvi6UITvU\nAXdjtkbjd5XRP+VvVSyx/+evhY7RTBn3dnVqsYxd7582fl0nAMe8BhGCQSJokxDX\nf8JoNTfYCWC5OY+9f0/P3uXRUtjgx6tAzDexxGzME8pxIrEabSTo5ph2ax0IUbM2\n+YDnyWPSRrOLFXkRUuo1mnjz0EwZdpyDN0AN0ujfqNI6E3NpdFl3z9eBAk0x8kig\nMlEb5kBwRitztMKEJP6IuRWn4YR2kk4QM18H379zahg3ZmtuPyOfKegR+tKn4KkO\ncG8IBT65D1QH5smT33vaFqwtMR++Om+U5Uz0Zba8OoFFcGY2cFuBgARl8L5KUpc=\n=Jbc/\n-----END PGP SIGNATURE-----\n", "payload": "tree 7a39b0d42046e8c531b96eb96d4cf1d7084e133b\nparent 2f1a4b3748d4632b0519097ee993136c3d5dc6ed\nparent a0556b3b79328c598a4f1539bbe81ceebc4a5b59\nauthor Tyler Mandry <tmandry@gmail.com> 1574890114 -0600\ncommitter GitHub <noreply@github.com> 1574890114 -0600\n\nRollup merge of #66399 - eddyb:rmeta-table-cleanup, r=Mark-Simulacrum\n\nrustc_metadata: simplify the interactions between Lazy and Table.\n\nThese are small post-#59953 cleanups (including undoing some contrivances from that PR).\n\nr? @michaelwoerister\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5139b538367eb094d48fd150cd2d719a2885b56c", "html_url": "https://github.com/rust-lang/rust/commit/5139b538367eb094d48fd150cd2d719a2885b56c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5139b538367eb094d48fd150cd2d719a2885b56c/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f1a4b3748d4632b0519097ee993136c3d5dc6ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1a4b3748d4632b0519097ee993136c3d5dc6ed", "html_url": "https://github.com/rust-lang/rust/commit/2f1a4b3748d4632b0519097ee993136c3d5dc6ed"}, {"sha": "a0556b3b79328c598a4f1539bbe81ceebc4a5b59", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0556b3b79328c598a4f1539bbe81ceebc4a5b59", "html_url": "https://github.com/rust-lang/rust/commit/a0556b3b79328c598a4f1539bbe81ceebc4a5b59"}], "stats": {"total": 258, "additions": 98, "deletions": 160}, "files": [{"sha": "e6ccbf5c38bf3839cd1a07273b787929164d3885", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5139b538367eb094d48fd150cd2d719a2885b56c/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5139b538367eb094d48fd150cd2d719a2885b56c/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=5139b538367eb094d48fd150cd2d719a2885b56c", "patch": "@@ -1,9 +1,9 @@\n // Decoding metadata from a single crate's metadata\n \n use crate::rmeta::*;\n-use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n+use crate::rmeta::table::{FixedSizeEncoding, Table};\n \n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_data_structures::sync::{Lrc, Lock, Once, AtomicCell};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -32,7 +32,7 @@ use std::mem;\n use std::num::NonZeroUsize;\n use std::u32;\n \n-use rustc_serialize::{Decodable, Decoder, Encodable, SpecializedDecoder, opaque};\n+use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map::{self, respan, Spanned};\n@@ -217,15 +217,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx, T: Encodable + Decodable> Lazy<T> {\n+impl<'a, 'tcx, T: Decodable> Lazy<T> {\n     fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Encodable + Decodable> Lazy<[T]> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n     fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         metadata: M,\n@@ -324,13 +324,13 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n         self.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n         let len = self.read_usize()?;\n         if len == 0 {\n@@ -341,10 +341,10 @@ impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a,\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<PerDefTable<T>>> for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, I: Idx, T> SpecializedDecoder<Lazy<Table<I, T>>> for DecodeContext<'a, 'tcx>\n     where Option<T>: FixedSizeEncoding,\n {\n-    fn specialized_decode(&mut self) -> Result<Lazy<PerDefTable<T>>, Self::Error> {\n+    fn specialized_decode(&mut self) -> Result<Lazy<Table<I, T>>, Self::Error> {\n         let len = self.read_usize()?;\n         self.read_lazy_with_meta(len)\n     }"}, {"sha": "8074bde61237d546853fb24f021b4dccee115d5e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 56, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5139b538367eb094d48fd150cd2d719a2885b56c/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5139b538367eb094d48fd150cd2d719a2885b56c/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=5139b538367eb094d48fd150cd2d719a2885b56c", "patch": "@@ -1,5 +1,5 @@\n use crate::rmeta::*;\n-use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n+use crate::rmeta::table::FixedSizeEncoding;\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n@@ -8,7 +8,7 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId,\n use rustc::hir::{GenericParamKind, AnonConst};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::Idx;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n                                       metadata_symbol_name};\n@@ -47,7 +47,7 @@ struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n \n-    per_def: PerDefTables<'tcx>,\n+    per_def: PerDefTableBuilders<'tcx>,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -60,30 +60,6 @@ struct EncodeContext<'tcx> {\n     source_file_cache: Lrc<SourceFile>,\n }\n \n-#[derive(Default)]\n-struct PerDefTables<'tcx> {\n-    kind: PerDefTable<Lazy<EntryKind<'tcx>>>,\n-    visibility: PerDefTable<Lazy<ty::Visibility>>,\n-    span: PerDefTable<Lazy<Span>>,\n-    attributes: PerDefTable<Lazy<[ast::Attribute]>>,\n-    children: PerDefTable<Lazy<[DefIndex]>>,\n-    stability: PerDefTable<Lazy<attr::Stability>>,\n-    deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n-\n-    ty: PerDefTable<Lazy<Ty<'tcx>>>,\n-    fn_sig: PerDefTable<Lazy<ty::PolyFnSig<'tcx>>>,\n-    impl_trait_ref: PerDefTable<Lazy<ty::TraitRef<'tcx>>>,\n-    inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n-    variances: PerDefTable<Lazy<[ty::Variance]>>,\n-    generics: PerDefTable<Lazy<ty::Generics>>,\n-    explicit_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n-    inferred_outlives: PerDefTable<Lazy<&'tcx [(ty::Predicate<'tcx>, Span)]>>,\n-    super_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n-\n-    mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n-    promoted_mir: PerDefTable<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n-}\n-\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n@@ -122,13 +98,13 @@ impl<'tcx> Encoder for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n+impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n         self.emit_lazy_distance(*lazy)\n     }\n }\n \n-impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n+impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n         self.emit_usize(lazy.meta)?;\n         if lazy.meta == 0 {\n@@ -138,10 +114,10 @@ impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<PerDefTable<T>>> for EncodeContext<'tcx>\n+impl<'tcx, I: Idx, T> SpecializedEncoder<Lazy<Table<I, T>>> for EncodeContext<'tcx>\n     where Option<T>: FixedSizeEncoding,\n {\n-    fn specialized_encode(&mut self, lazy: &Lazy<PerDefTable<T>>) -> Result<(), Self::Error> {\n+    fn specialized_encode(&mut self, lazy: &Lazy<Table<I, T>>) -> Result<(), Self::Error> {\n         self.emit_usize(lazy.meta)?;\n         self.emit_lazy_distance(*lazy)\n     }\n@@ -307,14 +283,14 @@ impl<I, T: Encodable> EncodeContentsForLazy<[T]> for I\n     }\n }\n \n-// Shorthand for `$self.$tables.$table.set($key, $self.lazy($value))`, which would\n+// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record {\n-    ($self:ident.$tables:ident.$table:ident[$key:expr] <- $value:expr) => {{\n+    ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n         {\n             let value = $value;\n             let lazy = $self.lazy(value);\n-            $self.$tables.$table.set($key, lazy);\n+            $self.$tables.$table.set($def_id.index, lazy);\n         }\n     }}\n }\n@@ -509,28 +485,7 @@ impl<'tcx> EncodeContext<'tcx> {\n \n \n         i = self.position();\n-        let per_def = LazyPerDefTables {\n-            kind: self.per_def.kind.encode(&mut self.opaque),\n-            visibility: self.per_def.visibility.encode(&mut self.opaque),\n-            span: self.per_def.span.encode(&mut self.opaque),\n-            attributes: self.per_def.attributes.encode(&mut self.opaque),\n-            children: self.per_def.children.encode(&mut self.opaque),\n-            stability: self.per_def.stability.encode(&mut self.opaque),\n-            deprecation: self.per_def.deprecation.encode(&mut self.opaque),\n-\n-            ty: self.per_def.ty.encode(&mut self.opaque),\n-            fn_sig: self.per_def.fn_sig.encode(&mut self.opaque),\n-            impl_trait_ref: self.per_def.impl_trait_ref.encode(&mut self.opaque),\n-            inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n-            variances: self.per_def.variances.encode(&mut self.opaque),\n-            generics: self.per_def.generics.encode(&mut self.opaque),\n-            explicit_predicates: self.per_def.explicit_predicates.encode(&mut self.opaque),\n-            inferred_outlives: self.per_def.inferred_outlives.encode(&mut self.opaque),\n-            super_predicates: self.per_def.super_predicates.encode(&mut self.opaque),\n-\n-            mir: self.per_def.mir.encode(&mut self.opaque),\n-            promoted_mir: self.per_def.promoted_mir.encode(&mut self.opaque),\n-        };\n+        let per_def = self.per_def.encode(&mut self.opaque);\n         let per_def_bytes = self.position() - i;\n \n         // Encode the proc macro data"}, {"sha": "1bca2836a3a07c22cd7eb7be5ff5caf5f6a25cc2", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 49, "deletions": 28, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5139b538367eb094d48fd150cd2d719a2885b56c/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5139b538367eb094d48fd150cd2d719a2885b56c/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=5139b538367eb094d48fd150cd2d719a2885b56c", "patch": "@@ -1,5 +1,5 @@\n use decoder::Metadata;\n-use table::PerDefTable;\n+use table::{Table, TableBuilder};\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n@@ -15,7 +15,7 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc_serialize::Encodable;\n+use rustc_serialize::opaque::Encoder;\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n@@ -59,7 +59,7 @@ trait LazyMeta {\n     fn min_size(meta: Self::Meta) -> usize;\n }\n \n-impl<T: Encodable> LazyMeta for T {\n+impl<T> LazyMeta for T {\n     type Meta = ();\n \n     fn min_size(_: ()) -> usize {\n@@ -68,7 +68,7 @@ impl<T: Encodable> LazyMeta for T {\n     }\n }\n \n-impl<T: Encodable> LazyMeta for [T] {\n+impl<T> LazyMeta for [T] {\n     type Meta = usize;\n \n     fn min_size(len: usize) -> usize {\n@@ -124,13 +124,13 @@ impl<T: ?Sized + LazyMeta> Lazy<T> {\n     }\n }\n \n-impl<T: Encodable> Lazy<T> {\n+impl<T> Lazy<T> {\n     fn from_position(position: NonZeroUsize) -> Lazy<T> {\n         Lazy::from_position_and_meta(position, ())\n     }\n }\n \n-impl<T: Encodable> Lazy<[T]> {\n+impl<T> Lazy<[T]> {\n     fn empty() -> Lazy<[T]> {\n         Lazy::from_position_and_meta(NonZeroUsize::new(1).unwrap(), 0)\n     }\n@@ -166,8 +166,7 @@ enum LazyState {\n // manually, instead of relying on the default, to get the correct variance.\n // Only needed when `T` itself contains a parameter (e.g. `'tcx`).\n macro_rules! Lazy {\n-    (Table<$T:ty>) => {Lazy<Table<$T>, usize>};\n-    (PerDefTable<$T:ty>) => {Lazy<PerDefTable<$T>, usize>};\n+    (Table<$I:ty, $T:ty>) => {Lazy<Table<$I, $T>, usize>};\n     ([$T:ty]) => {Lazy<[$T], usize>};\n     ($T:ty) => {Lazy<$T, ()>};\n }\n@@ -232,31 +231,53 @@ crate struct TraitImpls {\n     impls: Lazy<[DefIndex]>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct LazyPerDefTables<'tcx> {\n-    kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n-    visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n-    span: Lazy!(PerDefTable<Lazy<Span>>),\n-    attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n-    children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n-    deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n-    ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n-    fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n-    impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n-    inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n-    generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n-    explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+/// Define `LazyPerDefTables` and `PerDefTableBuilders` at the same time.\n+macro_rules! define_per_def_tables {\n+    ($($name:ident: Table<DefIndex, $T:ty>),+ $(,)?) => {\n+        #[derive(RustcEncodable, RustcDecodable)]\n+        crate struct LazyPerDefTables<'tcx> {\n+            $($name: Lazy!(Table<DefIndex, $T>)),+\n+        }\n+\n+        #[derive(Default)]\n+        struct PerDefTableBuilders<'tcx> {\n+            $($name: TableBuilder<DefIndex, $T>),+\n+        }\n+\n+        impl PerDefTableBuilders<'tcx> {\n+            fn encode(&self, buf: &mut Encoder) -> LazyPerDefTables<'tcx> {\n+                LazyPerDefTables {\n+                    $($name: self.$name.encode(buf)),+\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+define_per_def_tables! {\n+    kind: Table<DefIndex, Lazy!(EntryKind<'tcx>)>,\n+    visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n+    span: Table<DefIndex, Lazy<Span>>,\n+    attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n+    children: Table<DefIndex, Lazy<[DefIndex]>>,\n+    stability: Table<DefIndex, Lazy<attr::Stability>>,\n+    deprecation: Table<DefIndex, Lazy<attr::Deprecation>>,\n+    ty: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n+    fn_sig: Table<DefIndex, Lazy!(ty::PolyFnSig<'tcx>)>,\n+    impl_trait_ref: Table<DefIndex, Lazy!(ty::TraitRef<'tcx>)>,\n+    inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n+    variances: Table<DefIndex, Lazy<[ty::Variance]>>,\n+    generics: Table<DefIndex, Lazy<ty::Generics>>,\n+    explicit_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n     // doesn't handle shorthands in its own (de)serialization impls,\n     // as it's an `enum` for which we want to derive (de)serialization,\n     // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n     // Also, as an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n-    super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-    mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n-    promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n+    inferred_outlives: Table<DefIndex, Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>,\n+    super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n+    mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n+    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "10122fbba1fd47f79f5b7ac56cc28d910c9603cb", "filename": "src/librustc_metadata/rmeta/table.rs", "status": "modified", "additions": 29, "deletions": 67, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5139b538367eb094d48fd150cd2d719a2885b56c/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5139b538367eb094d48fd150cd2d719a2885b56c/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs?ref=5139b538367eb094d48fd150cd2d719a2885b56c", "patch": "@@ -1,6 +1,6 @@\n use crate::rmeta::*;\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc_index::vec::Idx;\n use rustc_serialize::{Encodable, opaque::Encoder};\n use std::convert::TryInto;\n use std::marker::PhantomData;\n@@ -117,37 +117,46 @@ impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n     }\n }\n \n-/// Random-access table (i.e. offeringconstant-time `get`/`set`), similar to\n+/// Random-access table (i.e. offering constant-time `get`/`set`), similar to\n /// `Vec<Option<T>>`, but without requiring encoding or decoding all the values\n /// eagerly and in-order.\n /// A total of `(max_idx + 1) * <Option<T> as FixedSizeEncoding>::BYTE_LEN` bytes\n-/// are used for a table, where `max_idx` is the largest index passed to `set`.\n-// FIXME(eddyb) replace `Vec` with `[_]` here, such that `Box<Table<T>>` would be used\n-// when building it, and `Lazy<Table<T>>` or `&Table<T>` when reading it.\n-// (not sure if that is possible given that the `Vec` is being resized now)\n-pub(super) struct Table<T> where Option<T>: FixedSizeEncoding {\n-    // FIXME(eddyb) store `[u8; <Option<T>>::BYTE_LEN]` instead of `u8` in `Vec`,\n-    // once that starts being allowed by the compiler (i.e. lazy normalization).\n+/// are used for a table, where `max_idx` is the largest index passed to\n+/// `TableBuilder::set`.\n+pub(super) struct Table<I: Idx, T> where Option<T>: FixedSizeEncoding {\n+    _marker: PhantomData<(fn(&I), T)>,\n+    // NOTE(eddyb) this makes `Table` not implement `Sized`, but no\n+    // value of `Table` is ever created (it's always behind `Lazy`).\n+    _bytes: [u8],\n+}\n+\n+/// Helper for constructing a table's serialization (also see `Table`).\n+pub(super) struct TableBuilder<I: Idx, T> where Option<T>: FixedSizeEncoding {\n+    // FIXME(eddyb) use `IndexVec<I, [u8; <Option<T>>::BYTE_LEN]>` instead of\n+    // `Vec<u8>`, once that starts working (i.e. lazy normalization).\n+    // Then again, that has the downside of not allowing `TableBuilder::encode` to\n+    // obtain a `&[u8]` entirely in safe code, for writing the bytes out.\n     bytes: Vec<u8>,\n-    _marker: PhantomData<T>,\n+    _marker: PhantomData<(fn(&I), T)>,\n }\n \n-impl<T> Default for Table<T> where Option<T>: FixedSizeEncoding {\n+impl<I: Idx, T> Default for TableBuilder<I, T> where Option<T>: FixedSizeEncoding {\n     fn default() -> Self {\n-        Table {\n+        TableBuilder {\n             bytes: vec![],\n             _marker: PhantomData,\n         }\n     }\n }\n \n-impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n-    fn set(&mut self, i: usize, value: T) {\n+impl<I: Idx, T> TableBuilder<I, T> where Option<T>: FixedSizeEncoding {\n+    pub(super) fn set(&mut self, i: I, value: T) {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n         // > trick (i.e. divide things into buckets of 32 or 64 items and then\n         // > store bit-masks of which item in each bucket is actually serialized).\n+        let i = i.index();\n         let needed = (i + 1) * <Option<T>>::BYTE_LEN;\n         if self.bytes.len() < needed {\n             self.bytes.resize(needed, 0);\n@@ -156,7 +165,7 @@ impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n         Some(value).write_to_bytes_at(&mut self.bytes, i);\n     }\n \n-    fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+    pub(super) fn encode(&self, buf: &mut Encoder) -> Lazy<Table<I, T>> {\n         let pos = buf.position();\n         buf.emit_raw_bytes(&self.bytes);\n         Lazy::from_position_and_meta(\n@@ -166,73 +175,26 @@ impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n     }\n }\n \n-impl<T> LazyMeta for Table<T> where Option<T>: FixedSizeEncoding {\n+impl<I: Idx, T> LazyMeta for Table<I, T> where Option<T>: FixedSizeEncoding {\n     type Meta = usize;\n \n     fn min_size(len: usize) -> usize {\n         len\n     }\n }\n \n-impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n+impl<I: Idx, T> Lazy<Table<I, T>> where Option<T>: FixedSizeEncoding {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n         &self,\n         metadata: M,\n-        i: usize,\n+        i: I,\n     ) -> Option<T> {\n         debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n \n         let start = self.position.get();\n         let bytes = &metadata.raw_bytes()[start..start + self.meta];\n-        <Option<T>>::maybe_read_from_bytes_at(bytes, i)?\n-    }\n-}\n-\n-/// Like a `Table` but using `DefIndex` instead of `usize` as keys.\n-// FIXME(eddyb) replace by making `Table` behave like `IndexVec`,\n-// and by using `newtype_index!` to define `DefIndex`.\n-pub(super) struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n-\n-impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    fn default() -> Self {\n-        PerDefTable(Table::default())\n-    }\n-}\n-\n-impl<T> PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    pub(super) fn set(&mut self, def_id: DefId, value: T) {\n-        assert!(def_id.is_local());\n-        self.0.set(def_id.index.index(), value);\n-    }\n-\n-    pub(super) fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n-        let lazy = self.0.encode(buf);\n-        Lazy::from_position_and_meta(lazy.position, lazy.meta)\n-    }\n-}\n-\n-impl<T> LazyMeta for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    type Meta = <Table<T> as LazyMeta>::Meta;\n-\n-    fn min_size(meta: Self::Meta) -> usize {\n-        Table::<T>::min_size(meta)\n-    }\n-}\n-\n-impl<T> Lazy<PerDefTable<T>> where Option<T>: FixedSizeEncoding {\n-    fn as_table(&self) -> Lazy<Table<T>> {\n-        Lazy::from_position_and_meta(self.position, self.meta)\n-    }\n-\n-    /// Given the metadata, extract out the value at a particular DefIndex (if any).\n-    #[inline(never)]\n-    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n-        &self,\n-        metadata: M,\n-        def_index: DefIndex,\n-    ) -> Option<T> {\n-        self.as_table().get(metadata, def_index.index())\n+        <Option<T>>::maybe_read_from_bytes_at(bytes, i.index())?\n     }\n }"}]}