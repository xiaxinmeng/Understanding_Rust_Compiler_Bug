{"sha": "863216eb1f57eac3d16347c15a83a183d5975577", "node_id": "C_kwDOAAsO6NoAKDg2MzIxNmViMWY1N2VhYzNkMTYzNDdjMTVhODNhMTgzZDU5NzU1Nzc", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-02-09T12:14:42Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-02-13T14:59:16Z"}, "message": "rustdoc: Stop textually replacing `Self` in doc links before resolving them\n\nResolve it directly to a type / def-id instead.\n\nAlso never pass `Self` to `Resolver`, it is useless because it's guaranteed that no resolution will be found.", "tree": {"sha": "5e8e23cb159ae2b41cd9a4f3f24a5c576704d767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e8e23cb159ae2b41cd9a4f3f24a5c576704d767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/863216eb1f57eac3d16347c15a83a183d5975577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/863216eb1f57eac3d16347c15a83a183d5975577", "html_url": "https://github.com/rust-lang/rust/commit/863216eb1f57eac3d16347c15a83a183d5975577", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/863216eb1f57eac3d16347c15a83a183d5975577/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "482b753d66bed635dcd14c86950850e91beefd8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/482b753d66bed635dcd14c86950850e91beefd8d", "html_url": "https://github.com/rust-lang/rust/commit/482b753d66bed635dcd14c86950850e91beefd8d"}], "stats": {"total": 209, "additions": 117, "deletions": 92}, "files": [{"sha": "9707b0bba133a5c2dc053a5f2329048e73879e3a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 117, "deletions": 92, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/863216eb1f57eac3d16347c15a83a183d5975577/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/863216eb1f57eac3d16347c15a83a183d5975577/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=863216eb1f57eac3d16347c15a83a183d5975577", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::def::{\n     PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n-use rustc_middle::ty::{DefIdTree, Ty, TyCtxt, TyKind};\n+use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n use rustc_session::lint::Lint;\n use rustc_span::hygiene::MacroKind;\n@@ -26,7 +26,8 @@ use std::fmt::Write;\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n+use crate::clean::{self, utils::find_nearest_parent_module};\n+use crate::clean::{Crate, Item, ItemId, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n@@ -177,6 +178,8 @@ enum ResolutionFailure<'a> {\n     /// The link failed to resolve. [`resolution_failure`] should look to see if there's\n     /// a more helpful error that can be given.\n     NotResolved {\n+        /// Item on which the link is resolved, used for resolving `Self`.\n+        item_id: ItemId,\n         /// The scope the link was resolved in.\n         module_id: DefId,\n         /// If part of the link resolved, this has the `Res`.\n@@ -343,6 +346,7 @@ impl ItemFragment {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n+    item_id: ItemId,\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n@@ -384,10 +388,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn variant_field<'path>(\n         &self,\n         path_str: &'path str,\n+        item_id: ItemId,\n         module_id: DefId,\n     ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n         let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n+            item_id,\n             module_id,\n             partial_res: None,\n             unresolved: path_str.into(),\n@@ -410,13 +416,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n             // So there's no partial res.\n             .ok_or_else(no_res)?;\n-        let ty_res = self\n-            .cx\n-            .enter_resolver(|resolver| {\n-                resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n-            })\n-            .and_then(|(_, res)| res.try_into())\n-            .map_err(|()| no_res())?;\n+        let ty_res = self.resolve_path(&path, TypeNS, item_id, module_id).ok_or_else(no_res)?;\n \n         match ty_res {\n             Res::Def(DefKind::Enum, did) => {\n@@ -437,6 +437,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             Ok((ty_res, Some(ItemFragment(FragmentKind::VariantField, field.did))))\n                         } else {\n                             Err(ResolutionFailure::NotResolved {\n+                                item_id,\n                                 module_id,\n                                 partial_res: Some(Res::Def(DefKind::Enum, def.did)),\n                                 unresolved: variant_field_name.to_string().into(),\n@@ -448,6 +449,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             }\n             _ => Err(ResolutionFailure::NotResolved {\n+                item_id,\n                 module_id,\n                 partial_res: Some(ty_res),\n                 unresolved: variant_name.to_string().into(),\n@@ -481,6 +483,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve_macro(\n         &self,\n         path_str: &'a str,\n+        item_id: ItemId,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n         self.cx.enter_resolver(|resolver| {\n@@ -499,19 +502,67 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 return Ok(res.try_into().unwrap());\n             }\n             Err(ResolutionFailure::NotResolved {\n+                item_id,\n                 module_id,\n                 partial_res: None,\n                 unresolved: path_str.into(),\n             })\n         })\n     }\n \n+    fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: ItemId) -> Option<Res> {\n+        if ns != TypeNS || path_str != \"Self\" {\n+            return None;\n+        }\n+\n+        let self_id = match item_id.as_def_id() {\n+            None => None,\n+            Some(did)\n+                if (matches!(self.cx.tcx.def_kind(did), DefKind::Field)\n+                    && matches!(\n+                        self.cx.tcx.def_kind(self.cx.tcx.parent(did).unwrap()),\n+                        DefKind::Variant\n+                    )) =>\n+            {\n+                self.cx.tcx.parent(did).and_then(|item_id| self.cx.tcx.parent(item_id))\n+            }\n+            Some(did)\n+                if matches!(\n+                    self.cx.tcx.def_kind(did),\n+                    DefKind::AssocConst\n+                        | DefKind::AssocFn\n+                        | DefKind::AssocTy\n+                        | DefKind::Variant\n+                        | DefKind::Field\n+                ) =>\n+            {\n+                self.cx.tcx.parent(did)\n+            }\n+            Some(did) => Some(did),\n+        };\n+\n+        self_id.and_then(|self_id| match self.cx.tcx.def_kind(self_id) {\n+            DefKind::Impl => self.def_id_to_res(self_id),\n+            def_kind => Some(Res::Def(def_kind, self_id)),\n+        })\n+    }\n+\n     /// Convenience wrapper around `resolve_str_path_error`.\n     ///\n     /// This also handles resolving `true` and `false` as booleans.\n     /// NOTE: `resolve_str_path_error` knows only about paths, not about types.\n     /// Associated items will never be resolved by this function.\n-    fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n+    fn resolve_path(\n+        &self,\n+        path_str: &str,\n+        ns: Namespace,\n+        item_id: ItemId,\n+        module_id: DefId,\n+    ) -> Option<Res> {\n+        if let res @ Some(..) = self.resolve_self_ty(path_str, ns, item_id) {\n+            return res;\n+        }\n+\n         let result = self.cx.enter_resolver(|resolver| {\n             resolver\n                 .resolve_str_path_error(DUMMY_SP, path_str, ns, module_id)\n@@ -532,10 +583,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n+        item_id: ItemId,\n         module_id: DefId,\n         user_fragment: &Option<String>,\n     ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n-        let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, module_id)?;\n+        let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, item_id, module_id)?;\n         let chosen_fragment = match (user_fragment, rustdoc_fragment) {\n             (Some(_), Some(r_frag)) => {\n                 let diag_res = match r_frag {\n@@ -555,9 +607,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n+        item_id: ItemId,\n         module_id: DefId,\n     ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n-        if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n+        if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n                 // item a separate function.\n@@ -585,6 +638,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .ok_or_else(|| {\n                 debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n                 ResolutionFailure::NotResolved {\n+                    item_id,\n                     module_id,\n                     partial_res: None,\n                     unresolved: item_str.into(),\n@@ -596,7 +650,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // error instead and special case *only* modules with `#[doc(primitive)]`, not all\n         // primitives.\n         resolve_primitive(&path_root, TypeNS)\n-            .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n+            .or_else(|| self.resolve_path(&path_root, TypeNS, item_id, module_id))\n             .and_then(|ty_res| {\n                 let (res, fragment) =\n                     self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n@@ -605,9 +659,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })\n             .unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, module_id)\n+                    self.variant_field(path_str, item_id, module_id)\n                 } else {\n                     Err(ResolutionFailure::NotResolved {\n+                        item_id,\n                         module_id,\n                         partial_res: None,\n                         unresolved: path_root.into(),\n@@ -730,7 +785,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // Checks if item_name is a variant of the `SomeItem` enum\n                 if ns == TypeNS && def_kind == DefKind::Enum {\n                     match tcx.type_of(did).kind() {\n-                        TyKind::Adt(adt_def, _) => {\n+                        ty::Adt(adt_def, _) => {\n                             for variant in &adt_def.variants {\n                                 if variant.name == item_name {\n                                     return Some((\n@@ -830,17 +885,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         ns: Namespace,\n         path_str: &str,\n+        item_id: ItemId,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n             Namespace::MacroNS => self\n-                .resolve_macro(path_str, module_id)\n+                .resolve_macro(path_str, item_id, module_id)\n                 .map(|res| (res, None))\n                 .map_err(ErrorKind::from),\n             Namespace::TypeNS | Namespace::ValueNS => {\n-                self.resolve(path_str, ns, module_id, extra_fragment)\n+                self.resolve(path_str, ns, item_id, module_id, extra_fragment)\n             }\n         };\n \n@@ -987,53 +1043,6 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n             trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n-        // find item's parent to resolve `Self` in item's docs below\n-        debug!(\"looking for the `Self` type\");\n-        let self_id = match item.def_id.as_def_id() {\n-            None => None,\n-            Some(did)\n-                if (matches!(self.cx.tcx.def_kind(did), DefKind::Field)\n-                    && matches!(\n-                        self.cx.tcx.def_kind(self.cx.tcx.parent(did).unwrap()),\n-                        DefKind::Variant\n-                    )) =>\n-            {\n-                self.cx.tcx.parent(did).and_then(|item_id| self.cx.tcx.parent(item_id))\n-            }\n-            Some(did)\n-                if matches!(\n-                    self.cx.tcx.def_kind(did),\n-                    DefKind::AssocConst\n-                        | DefKind::AssocFn\n-                        | DefKind::AssocTy\n-                        | DefKind::Variant\n-                        | DefKind::Field\n-                ) =>\n-            {\n-                self.cx.tcx.parent(did)\n-            }\n-            Some(did) => Some(did),\n-        };\n-\n-        // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n-        let self_name = self_id.and_then(|self_id| {\n-            if matches!(self.cx.tcx.def_kind(self_id), DefKind::Impl) {\n-                // using `ty.to_string()` (or any variant) has issues with raw idents\n-                let ty = self.cx.tcx.type_of(self_id);\n-                let name = match ty.kind() {\n-                    ty::Adt(def, _) => Some(self.cx.tcx.item_name(def.did).to_string()),\n-                    other if other.is_primitive() => Some(ty.to_string()),\n-                    _ => None,\n-                };\n-                debug!(\"using type_of(): {:?}\", name);\n-                name\n-            } else {\n-                let name = self.cx.tcx.opt_item_name(self_id).map(|sym| sym.to_string());\n-                debug!(\"using item_name(): {:?}\", name);\n-                name\n-            }\n-        });\n-\n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n@@ -1055,7 +1064,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n             for md_link in markdown_links(&doc) {\n-                let link = self.resolve_link(&item, &doc, &self_name, parent_node, krate, md_link);\n+                let link = self.resolve_link(&item, &doc, parent_node, krate, md_link);\n                 if let Some(link) = link {\n                     self.cx.cache.intra_doc_links.entry(item.def_id).or_default().push(link);\n                 }\n@@ -1189,7 +1198,6 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         item: &Item,\n         dox: &str,\n-        self_name: &Option<String>,\n         parent_node: Option<DefId>,\n         krate: CrateNum,\n         ori_link: MarkdownLink,\n@@ -1259,19 +1267,8 @@ impl LinkCollector<'_, '_> {\n         };\n \n         let resolved_self;\n-        // replace `Self` with suitable item's parent name\n-        let is_lone_self = path_str == \"Self\";\n         let is_lone_crate = path_str == \"crate\";\n-        if path_str.starts_with(\"Self::\") || is_lone_self {\n-            if let Some(ref name) = self_name {\n-                if is_lone_self {\n-                    path_str = name;\n-                } else {\n-                    resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n-                    path_str = &resolved_self;\n-                }\n-            }\n-        } else if path_str.starts_with(\"crate::\") || is_lone_crate {\n+        if path_str.starts_with(\"crate::\") || is_lone_crate {\n             use rustc_span::def_id::CRATE_DEF_INDEX;\n \n             // HACK(jynelson): rustc_resolve thinks that `crate` is the crate currently being documented.\n@@ -1291,6 +1288,7 @@ impl LinkCollector<'_, '_> {\n \n         let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n+                item_id: item.def_id,\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n@@ -1533,12 +1531,13 @@ impl LinkCollector<'_, '_> {\n     ) -> Option<(Res, Option<UrlFragment>)> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n+        let item_id = key.item_id;\n         let base_node = key.module_id;\n         let extra_fragment = &key.extra_fragment;\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, expected_ns, base_node, extra_fragment) {\n+                match self.resolve(path_str, expected_ns, item_id, base_node, extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1547,9 +1546,13 @@ impl LinkCollector<'_, '_> {\n                             // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n                             // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for new_ns in [other_ns, MacroNS] {\n-                                if let Some(res) =\n-                                    self.check_full_res(new_ns, path_str, base_node, extra_fragment)\n-                                {\n+                                if let Some(res) = self.check_full_res(\n+                                    new_ns,\n+                                    path_str,\n+                                    item_id,\n+                                    base_node,\n+                                    extra_fragment,\n+                                ) {\n                                     kind = ResolutionFailure::WrongNamespace { res, expected_ns };\n                                     break;\n                                 }\n@@ -1571,9 +1574,15 @@ impl LinkCollector<'_, '_> {\n                 // Try everything!\n                 let mut candidates = PerNS {\n                     macro_ns: self\n-                        .resolve_macro(path_str, base_node)\n+                        .resolve_macro(path_str, item_id, base_node)\n                         .map(|res| (res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n-                    type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n+                    type_ns: match self.resolve(\n+                        path_str,\n+                        TypeNS,\n+                        item_id,\n+                        base_node,\n+                        extra_fragment,\n+                    ) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n@@ -1584,7 +1593,13 @@ impl LinkCollector<'_, '_> {\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(path_str, ValueNS, base_node, extra_fragment) {\n+                    value_ns: match self.resolve(\n+                        path_str,\n+                        ValueNS,\n+                        item_id,\n+                        base_node,\n+                        extra_fragment,\n+                    ) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n                             anchor_failure(self.cx, diag, msg);\n@@ -1643,14 +1658,18 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             Some(MacroNS) => {\n-                match self.resolve_macro(path_str, base_node) {\n+                match self.resolve_macro(path_str, item_id, base_node) {\n                     Ok(res) => Some((res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for ns in [TypeNS, ValueNS] {\n-                            if let Some(res) =\n-                                self.check_full_res(ns, path_str, base_node, extra_fragment)\n-                            {\n+                            if let Some(res) = self.check_full_res(\n+                                ns,\n+                                path_str,\n+                                item_id,\n+                                base_node,\n+                                extra_fragment,\n+                            ) {\n                                 kind =\n                                     ResolutionFailure::WrongNamespace { res, expected_ns: MacroNS };\n                                 break;\n@@ -1977,11 +1996,16 @@ fn resolution_failure(\n                 }\n                 variants_seen.push(variant);\n \n-                if let ResolutionFailure::NotResolved { module_id, partial_res, unresolved } =\n-                    &mut failure\n+                if let ResolutionFailure::NotResolved {\n+                    item_id,\n+                    module_id,\n+                    partial_res,\n+                    unresolved,\n+                } = &mut failure\n                 {\n                     use DefKind::*;\n \n+                    let item_id = *item_id;\n                     let module_id = *module_id;\n                     // FIXME(jynelson): this might conflict with my `Self` fix in #76467\n                     // FIXME: maybe use itertools `collect_tuple` instead?\n@@ -2005,7 +2029,8 @@ fn resolution_failure(\n                         };\n                         name = start;\n                         for ns in [TypeNS, ValueNS, MacroNS] {\n-                            if let Some(res) = collector.check_full_res(ns, start, module_id, &None)\n+                            if let Some(res) =\n+                                collector.check_full_res(ns, start, item_id, module_id, &None)\n                             {\n                                 debug!(\"found partial_res={:?}\", res);\n                                 *partial_res = Some(res);"}]}