{"sha": "8e96adedd56993eec0609276124ff17d4866b94b", "node_id": "C_kwDOAAsO6NoAKDhlOTZhZGVkZDU2OTkzZWVjMDYwOTI3NjEyNGZmMTdkNDg2NmI5NGI", "commit": {"author": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2023-02-14T03:31:42Z"}, "committer": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2023-02-14T03:31:42Z"}, "message": "fix [`needless_return`] incorrect suggestion when returning if sequence", "tree": {"sha": "865f04e593f40749c742e77885207a25457f0bbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/865f04e593f40749c742e77885207a25457f0bbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e96adedd56993eec0609276124ff17d4866b94b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e96adedd56993eec0609276124ff17d4866b94b", "html_url": "https://github.com/rust-lang/rust/commit/8e96adedd56993eec0609276124ff17d4866b94b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e96adedd56993eec0609276124ff17d4866b94b/comments", "author": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "298f1397982a4e7cf718931bff399fcc6bffd9e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/298f1397982a4e7cf718931bff399fcc6bffd9e1", "html_url": "https://github.com/rust-lang/rust/commit/298f1397982a4e7cf718931bff399fcc6bffd9e1"}], "stats": {"total": 114, "additions": 72, "deletions": 42}, "files": [{"sha": "84bcef856d06c6dab48f7bd16954b744cc6be946", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 55, "deletions": 41, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8e96adedd56993eec0609276124ff17d4866b94b/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e96adedd56993eec0609276124ff17d4866b94b/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=8e96adedd56993eec0609276124ff17d4866b94b", "patch": "@@ -69,31 +69,35 @@ declare_clippy_lint! {\n     \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n-#[derive(PartialEq, Eq, Copy, Clone)]\n+#[derive(PartialEq, Eq, Clone)]\n enum RetReplacement {\n     Empty,\n     Block,\n     Unit,\n+    IfSequence(String),\n+    Expr(String),\n }\n \n impl RetReplacement {\n     fn sugg_help(self) -> &'static str {\n         match self {\n-            Self::Empty => \"remove `return`\",\n+            Self::Empty | Self::Expr(_) => \"remove `return`\",\n             Self::Block => \"replace `return` with an empty block\",\n             Self::Unit => \"replace `return` with a unit value\",\n+            Self::IfSequence(_) => \"remove `return` and wrap the sequence with parentheses\",\n         }\n     }\n }\n \n impl ToString for RetReplacement {\n     fn to_string(&self) -> String {\n-        match *self {\n-            Self::Empty => \"\",\n-            Self::Block => \"{}\",\n-            Self::Unit => \"()\",\n+        match self {\n+            Self::Empty => String::new(),\n+            Self::Block => \"{}\".to_string(),\n+            Self::Unit => \"()\".to_string(),\n+            Self::IfSequence(inner) => format!(\"({inner})\"),\n+            Self::Expr(inner) => inner.clone(),\n         }\n-        .to_string()\n     }\n }\n \n@@ -210,28 +214,46 @@ fn check_final_expr<'tcx>(\n     match &peeled_drop_expr.kind {\n         // simple return is always \"bad\"\n         ExprKind::Ret(ref inner) => {\n-            // if desugar of `do yeet`, don't lint\n-            if let Some(inner_expr) = inner\n-                && let ExprKind::Call(path_expr, _) = inner_expr.kind\n-                && let ExprKind::Path(QPath::LangItem(LangItem::TryTraitFromYeet, _, _)) = path_expr.kind\n-            {\n-                return;\n-            }\n+            // check if expr return nothing\n+            let ret_span = if inner.is_none() && replacement == RetReplacement::Empty {\n+                extend_span_to_previous_non_ws(cx, peeled_drop_expr.span)\n+            } else {\n+                peeled_drop_expr.span\n+            };\n+\n+            let replacement = if let Some(inner_expr) = inner {\n+                // if desugar of `do yeet`, don't lint\n+                if let ExprKind::Call(path_expr, _) = inner_expr.kind\n+                    && let ExprKind::Path(QPath::LangItem(LangItem::TryTraitFromYeet, _, _)) = path_expr.kind\n+                {\n+                    return;\n+                }\n+\n+                let (snippet, _) = snippet_with_context(\n+                    cx,\n+                    inner_expr.span,\n+                    ret_span.ctxt(),\n+                    \"..\",\n+                    &mut Applicability::MachineApplicable,\n+                );\n+                if expr_contains_if(inner_expr) {\n+                    RetReplacement::IfSequence(snippet.to_string())\n+                } else {\n+                    RetReplacement::Expr(snippet.to_string())\n+                }\n+            } else {\n+                replacement\n+            };\n+\n             if !cx.tcx.hir().attrs(expr.hir_id).is_empty() {\n                 return;\n             }\n             let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n             if borrows {\n                 return;\n             }\n-            // check if expr return nothing\n-            let ret_span = if inner.is_none() && replacement == RetReplacement::Empty {\n-                extend_span_to_previous_non_ws(cx, peeled_drop_expr.span)\n-            } else {\n-                peeled_drop_expr.span\n-            };\n \n-            emit_return_lint(cx, ret_span, semi_spans, inner.as_ref().map(|i| i.span), replacement);\n+            emit_return_lint(cx, ret_span, semi_spans, replacement);\n         },\n         ExprKind::If(_, then, else_clause_opt) => {\n             check_block_return(cx, &then.kind, peeled_drop_expr.span, semi_spans.clone());\n@@ -253,29 +275,21 @@ fn check_final_expr<'tcx>(\n     }\n }\n \n-fn emit_return_lint(\n-    cx: &LateContext<'_>,\n-    ret_span: Span,\n-    semi_spans: Vec<Span>,\n-    inner_span: Option<Span>,\n-    replacement: RetReplacement,\n-) {\n+fn expr_contains_if<'tcx>(expr: &'tcx Expr<'tcx>) -> bool {\n+    match expr.kind {\n+        ExprKind::If(..) => true,\n+        ExprKind::Binary(_, left, right) => expr_contains_if(left) || expr_contains_if(right),\n+        _ => false,\n+    }\n+}\n+\n+fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, semi_spans: Vec<Span>, replacement: RetReplacement) {\n     if ret_span.from_expansion() {\n         return;\n     }\n-    let mut applicability = Applicability::MachineApplicable;\n-    let return_replacement = inner_span.map_or_else(\n-        || replacement.to_string(),\n-        |inner_span| {\n-            let (snippet, _) = snippet_with_context(cx, inner_span, ret_span.ctxt(), \"..\", &mut applicability);\n-            snippet.to_string()\n-        },\n-    );\n-    let sugg_help = if inner_span.is_some() {\n-        \"remove `return`\"\n-    } else {\n-        replacement.sugg_help()\n-    };\n+    let applicability = Applicability::MachineApplicable;\n+    let return_replacement = replacement.to_string();\n+    let sugg_help = replacement.sugg_help();\n     span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n         diag.span_suggestion_hidden(ret_span, sugg_help, return_replacement, applicability);\n         // for each parent statement, we need to remove the semicolon"}, {"sha": "c77554fb47b252790f59a0670d6ad8c6dc695cd4", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e96adedd56993eec0609276124ff17d4866b94b/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8e96adedd56993eec0609276124ff17d4866b94b/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=8e96adedd56993eec0609276124ff17d4866b94b", "patch": "@@ -297,4 +297,8 @@ fn issue10051() -> Result<String, String> {\n     }\n }\n \n+fn issue10049(b1: bool, b2: bool, b3: bool) -> u32 {\n+    (if b1 { 0 } else { 1 } | if b2 { 2 } else { 3 } | if b3 { 4 } else { 5 })\n+}\n+\n fn main() {}"}, {"sha": "8fed64ac6e3b4c2a30577e53ac281c9d32c0aa53", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e96adedd56993eec0609276124ff17d4866b94b/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e96adedd56993eec0609276124ff17d4866b94b/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=8e96adedd56993eec0609276124ff17d4866b94b", "patch": "@@ -307,4 +307,8 @@ fn issue10051() -> Result<String, String> {\n     }\n }\n \n+fn issue10049(b1: bool, b2: bool, b3: bool) -> u32 {\n+    return if b1 { 0 } else { 1 } | if b2 { 2 } else { 3 } | if b3 { 4 } else { 5 };\n+}\n+\n fn main() {}"}, {"sha": "18edbce2f44bad0c8039cd3b18c0d1fa2dc7365d", "filename": "tests/ui/needless_return.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e96adedd56993eec0609276124ff17d4866b94b/tests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e96adedd56993eec0609276124ff17d4866b94b/tests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.stderr?ref=8e96adedd56993eec0609276124ff17d4866b94b", "patch": "@@ -418,5 +418,13 @@ LL |         return Err(format!(\"err!\"));\n    |\n    = help: remove `return`\n \n-error: aborting due to 50 previous errors\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:311:5\n+   |\n+LL |     return if b1 { 0 } else { 1 } | if b2 { 2 } else { 3 } | if b3 { 4 } else { 5 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: remove `return` and wrap the sequence with parentheses\n+\n+error: aborting due to 51 previous errors\n "}]}