{"sha": "9c001af07c658b9583bde8d138d1d9408274d741", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMDAxYWYwN2M2NThiOTU4M2JkZThkMTM4ZDFkOTQwODI3NGQ3NDE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-08T01:15:56Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-08T17:46:46Z"}, "message": "Implemented computing prestates and poststates for a few expression forms.\n\nThe typestate checker (if it's uncommented) now correctly rejects a\ntrivial example program that has an uninitialized variable.", "tree": {"sha": "adbc1327204422bfbd3c30e36e951a01d7df0c6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adbc1327204422bfbd3c30e36e951a01d7df0c6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c001af07c658b9583bde8d138d1d9408274d741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c001af07c658b9583bde8d138d1d9408274d741", "html_url": "https://github.com/rust-lang/rust/commit/9c001af07c658b9583bde8d138d1d9408274d741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c001af07c658b9583bde8d138d1d9408274d741/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6109dba305d68db42865c07881d7ffb6d71a1127", "url": "https://api.github.com/repos/rust-lang/rust/commits/6109dba305d68db42865c07881d7ffb6d71a1127", "html_url": "https://github.com/rust-lang/rust/commit/6109dba305d68db42865c07881d7ffb6d71a1127"}], "stats": {"total": 332, "additions": 268, "deletions": 64}, "files": [{"sha": "22ffcc35053b80fe5c89a5437541916d9adf9d99", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 224, "deletions": 63, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/9c001af07c658b9583bde8d138d1d9408274d741/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c001af07c658b9583bde8d138d1d9408274d741/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=9c001af07c658b9583bde8d138d1d9408274d741", "patch": "@@ -19,6 +19,8 @@ import front.ast.def_id;\n import front.ast.ann;\n import front.ast.expr;\n import front.ast.expr_call;\n+import front.ast.expr_vec;\n+import front.ast.expr_tup;\n import front.ast.expr_path;\n import front.ast.expr_log;\n import front.ast.expr_block;\n@@ -59,6 +61,8 @@ import util.common.span;\n import util.common.spanned;\n import util.common.new_str_hash;\n import util.common.new_def_hash;\n+import util.common.uistr;\n+import util.common.elt_exprs;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n import util.typestate_ann.empty_pre_post;\n@@ -75,6 +79,8 @@ import util.typestate_ann.ann_precond;\n import util.typestate_ann.ann_prestate;\n import util.typestate_ann.set_precondition;\n import util.typestate_ann.set_postcondition;\n+import util.typestate_ann.set_prestate;\n+import util.typestate_ann.set_poststate;\n import util.typestate_ann.set_in_postcond;\n import util.typestate_ann.implies;\n import util.typestate_ann.pre_and_post_state;\n@@ -92,6 +98,7 @@ import middle.ty.ty_to_str;\n \n import pretty.pprust.print_block;\n import pretty.pprust.print_expr;\n+import pretty.pprust.print_decl;\n import pretty.pp.mkstate;\n import std.io.stdout;\n import std.io.str_writer;\n@@ -102,11 +109,14 @@ import std._vec.len;\n import std._vec.pop;\n import std._vec.push;\n import std._vec.slice;\n+import std._vec.unzip;\n import std.option;\n import std.option.t;\n import std.option.some;\n import std.option.none;\n import std.option.from_maybe;\n+import std.option.is_none;\n+import std.option.get;\n import std.map.hashmap;\n import std.list;\n import std.list.list;\n@@ -137,6 +147,36 @@ fn log_expr(@expr e) -> () {\n   log(s.get_str());\n }\n \n+fn log_stmt(stmt st) -> () {\n+  let str_writer s = string_writer();\n+  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out = @rec(s=out_,\n+                  comments=option.none[vec[front.lexer.cmnt]],\n+                  mutable cur_cmnt=0u);\n+  alt (st.node) {\n+    case (ast.stmt_decl(?decl,_)) {\n+      print_decl(out, decl);\n+    }\n+    case (ast.stmt_expr(?ex,_)) {\n+      print_expr(out, ex);\n+    }\n+    case (_) { /* do nothing */ }\n+  }\n+  log(s.get_str());\n+}\n+\n+fn log_bitv(fn_info enclosing, bitv.t v) {\n+  auto s = \"\";\n+\n+  for each (@tup(def_id, tup(uint, ident)) p in enclosing.items()) {\n+    if (bitv.get(v, p._1._0)) {\n+      s += \" \" + p._1._1 + \" \";\n+    }\n+  }\n+\n+  log(s);\n+}\n+\n fn log_cond(vec[uint] v) -> () {\n   auto res = \"\";\n   for (uint i in v) {\n@@ -173,14 +213,16 @@ fn print_idents(vec[ident] idents) -> () {\n }\n /**********************************************************************/\n /* mapping from variable name (def_id is assumed to be for a local\n-   variable in a given function) to bit number */\n-type fn_info      = std.map.hashmap[def_id, uint];\n+   variable in a given function) to bit number \n+   (also remembers the ident for error-logging purposes) */\n+type var_info     = tup(uint, ident);\n+type fn_info      = std.map.hashmap[def_id, var_info];\n /* mapping from function name to fn_info map */\n type _fn_info_map = std.map.hashmap[def_id, fn_info];\n  \n fn bit_num(def_id v, fn_info m) -> uint {\n   check (m.contains_key(v));\n-  ret m.get(v);\n+  ret m.get(v)._0;\n }\n \n fn var_is_local(def_id v, fn_info m) -> bool {\n@@ -191,14 +233,14 @@ fn num_locals(fn_info m) -> uint {\n   ret m.size();\n }\n \n-fn find_locals(_fn f) -> vec[def_id] {\n-  auto res = _vec.alloc[def_id](0u);\n+fn find_locals(_fn f) -> vec[tup(ident,def_id)] {\n+  auto res = _vec.alloc[tup(ident,def_id)](0u);\n \n   for each (@tup(ident, block_index_entry) p\n           in f.body.node.index.items()) {\n     alt (p._1) {\n       case (ast.bie_local(?loc)) {\n-        res += vec(loc.id);\n+        res += vec(tup(loc.ident,loc.id));\n       }\n       case (_) { }\n     }\n@@ -207,26 +249,25 @@ fn find_locals(_fn f) -> vec[def_id] {\n   ret res;\n }\n \n-fn add_var(def_id v, uint next, fn_info tbl) -> uint {\n-  tbl.insert(v, next);\n-  // log(v + \" |-> \" + _uint.to_str(next, 10u));\n+fn add_var(def_id v, ident nm, uint next, fn_info tbl) -> uint {\n+  tbl.insert(v, tup(next,nm));\n   ret (next + 1u);\n }\n \n /* builds a table mapping each local var defined in f\n  to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(_fn f) -> fn_info {\n-  auto res = new_def_hash[uint]();\n+  auto res = new_def_hash[var_info]();\n   let uint next = 0u;\n   let vec[ast.arg] f_args = f.decl.inputs;\n \n   for (ast.arg v in f_args) {\n-    next = add_var(v.id, next, res);\n+    next = add_var(v.id, v.ident, next, res);\n   }\n \n-  let vec[def_id] locals = find_locals(f);\n-  for (def_id v in locals) {\n-    next = add_var(v, next, res);\n+  let vec[tup(ident,def_id)] locals = find_locals(f);\n+  for (tup(ident,def_id) p in locals) {\n+    next = add_var(p._1, p._0, next, res);\n   }\n \n   ret res;\n@@ -403,7 +444,7 @@ fn expr_states(&expr e) -> pre_and_post_state {\n           fail;\n         }\n         case (some[@ts_ann](?p)) {\n-          // ret p.states;\n+          ret p.states;\n         }\n       }\n     }\n@@ -691,7 +732,7 @@ fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n \n impure fn gen(&fn_info enclosing, ts_ann a, def_id id) {\n   check(enclosing.contains_key(id));\n-  let uint i = enclosing.get(id);\n+  let uint i = (enclosing.get(id))._0;\n \n   set_in_postcond(i, a.conditions);\n }\n@@ -804,42 +845,152 @@ fn check_item_fn(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n }\n \n /* FIXME */\n-fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n-                            &prestate pres, expr e)\n-  -> tup(bool, @expr) {\n-  log(\"Implement find_pre_post_state_expr!\");\n+fn find_pre_post_state_item(_fn_info_map fm, @item i) -> bool {\n+  log(\"Implement find_pre_post_item!\");\n   fail;\n }\n \n-/* FIXME: This isn't done yet. */\n+impure fn set_prestate_ann(ann a, prestate pre) -> () {\n+  alt (a) {\n+    case (ann_type(_,_,?ts_a)) {\n+      check (! is_none[@ts_ann](ts_a));\n+      set_prestate(*get[@ts_ann](ts_a), pre);\n+    }\n+    case (ann_none) {\n+      log(\"set_prestate_ann: expected an ann_type here\");\n+      fail;\n+    }\n+  }\n+}\n+\n+impure fn set_poststate_ann(ann a, poststate post) -> () {\n+  alt (a) {\n+    case (ann_type(_,_,?ts_a)) {\n+      check (! is_none[@ts_ann](ts_a));\n+      set_poststate(*get[@ts_ann](ts_a), post);\n+    }\n+    case (ann_none) {\n+      log(\"set_poststate_ann: expected an ann_type here\");\n+      fail;\n+    }\n+  }\n+}\n+\n+fn seq_states(&_fn_info_map fm, &fn_info enclosing,\n+    prestate pres, vec[@expr] exprs) -> tup(bool, poststate) {\n+  auto changed = false;\n+  auto post = pres;\n+\n+  for (@expr e in exprs) {\n+    changed = find_pre_post_state_expr(fm, enclosing, post, e) || changed;\n+    post = expr_poststate(*e);\n+  }\n+\n+  ret tup(changed, post);\n+}\n+\n+fn find_pre_post_state_exprs(&_fn_info_map fm,\n+\t\t\t     &fn_info enclosing,\n+\t\t\t     &prestate pres,\n+\t\t\t     &ann a, &vec[@expr] es) -> bool {\n+  auto res = seq_states(fm, enclosing, pres, es);\n+  set_prestate_ann(a, pres);\n+  set_poststate_ann(a, res._1);\n+  ret res._0;\n+}\n+\n+impure fn pure_exp(&ann a, &prestate p) -> () {\n+  set_prestate_ann(a, p);\n+  set_poststate_ann(a, p);\n+}\n+\n+fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n+                            &prestate pres, &@expr e) -> bool {\n+  auto changed = false;\n+\n+  alt (e.node) {\n+    case (expr_vec(?elts, _, ?a)) {\n+      be find_pre_post_state_exprs(fm, enclosing, pres, a, elts); \n+    }\n+    case (expr_tup(?elts, ?a)) {\n+      be find_pre_post_state_exprs(fm, enclosing, pres, a, elt_exprs(elts));\n+    }\n+    case (expr_call(?operator, ?operands, ?a)) {\n+      /* do the prestate for the rator */\n+      changed = find_pre_post_state_expr(fm, enclosing, pres, operator)\n+\t|| changed;\n+      /* rands go left-to-right */\n+      ret(find_pre_post_state_exprs(fm, enclosing,\n+\t\t\t\t    expr_poststate(*operator), a, operands)\n+\t  || changed);\n+    }\n+    case (expr_path(_,_,?a)) {\n+      pure_exp(a, pres);\n+      ret false;\n+    }\n+    case (expr_log(?e,?a)) {\n+\tchanged = find_pre_post_state_expr(fm, enclosing, pres, e);\n+\tset_prestate_ann(a, pres);\n+\tset_poststate_ann(a, expr_poststate(*e));\n+\tret changed;\n+    }\n+    case (_) {\n+      log(\"find_pre_post_state_expr: implement this case!\");\n+      fail;\n+    }\n+  }\n+\n+}\n+\n fn find_pre_post_state_stmt(&_fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, @stmt s) -> bool {\n   auto changed = false;\n   alt (s.node) {\n     case (stmt_decl(?adecl, ?a)) {\n+      /* a must be some(a') at this point */\n+      check (! is_none[@ts_ann](a));\n+      auto stmt_ann = *(get[@ts_ann](a));\n       alt (adecl.node) {\n         case (ast.decl_local(?alocal)) {\n           alt (alocal.init) {\n             case (some[ast.initializer](?an_init)) {\n-              auto p = find_pre_post_state_expr(fm, enclosing,\n-                                                pres, *an_init.expr);\n-              fail; /* FIXME */\n-              /* Next: copy pres into a's prestate;\n-                 find the poststate by taking p's poststate\n-                 and setting the bit for alocal.id */\n-            }\n+\t      changed = find_pre_post_state_expr\n+\t\t(fm, enclosing,\tpres, an_init.expr) || changed;\n+\t      set_prestate(stmt_ann, expr_prestate(*an_init.expr));\n+\t      set_poststate(stmt_ann, expr_poststate(*an_init.expr));\n+\t      gen(enclosing, stmt_ann, alocal.id);\n+\t      ret changed;\n+\t    }\n+\t    case (none[ast.initializer]) {\n+\t      set_prestate(stmt_ann, pres);\n+\t      set_poststate(stmt_ann, pres);\n+\t      ret false;\n+\t    }\n           }\n         }\n+\tcase (ast.decl_item(?an_item)) {\n+\t  be find_pre_post_state_item(fm, an_item);\n+\t}\n       }\n     }\n+    case (stmt_expr(?e, ?a)) {\n+      check (! is_none[@ts_ann](a));\n+      auto stmt_ann = *(get[@ts_ann](a));\n+      changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+      set_prestate(stmt_ann, expr_prestate(*e));\n+      set_poststate(stmt_ann, expr_poststate(*e));\n+      ret changed;\n+    }\n+    case (_) { ret false; }\n   }\n }\n \n-/* Returns a pair of a new block, with possibly a changed pre- or\n-   post-state, and a boolean flag saying whether the function's pre- or \n-   poststate changed */\n+/* Updates the pre- and post-states of statements in the block,\n+   returns a boolean flag saying whether any pre- or poststates changed */\n fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing, block b)\n-  -> tup(bool, block) {\n+  -> bool {\n+  log(\"pre_post_state_block: \" + uistr(fm.size()) + \" \" + uistr(enclosing.size()));\n+\n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n \n@@ -857,43 +1008,35 @@ fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing, block b)\n     extend_prestate(pres, stmt_poststate(*s, num_local_vars));\n   }\n \n-  fn do_inner_(_fn_info_map fm, fn_info i, prestate p, &@expr e)\n-    -> tup (bool, @expr) {\n-    ret find_pre_post_state_expr(fm, i, p, *e);\n+  alt (b.node.expr) {\n+    case (none[@expr]) {}\n+    case (some[@expr](?e)) {\n+      changed = changed || find_pre_post_state_expr(fm, enclosing, pres, e);\n+    }\n   }\n-  auto do_inner = bind do_inner_(fm, enclosing, pres, _);\n-  let option.t[tup(bool, @expr)] e_ =\n-    option.map[@expr, tup(bool, @expr)](do_inner, b.node.expr);\n-  auto s = snd[bool, @expr];\n-  auto f = fst[bool, @expr];\n-  changed = changed ||\n-    from_maybe[bool](false,\n-                     option.map[tup(bool, @expr), bool](f, e_));\n-  let block_ b_res = rec(stmts=b.node.stmts,\n-                         expr=option.map[tup(bool, @expr), @expr](s, e_),\n-                         index=b.node.index);\n-  ret tup(changed, respan(b.span, b_res));\n+  ret changed;\n }\n \n-fn find_pre_post_state_fn(_fn_info_map f_info, fn_info fi, &ast._fn f)\n-  -> tup(bool, ast._fn) {\n-  auto p = find_pre_post_state_block(f_info, fi, f.body);\n-  ret tup(p._0, rec(decl=f.decl, proto=f.proto, body=p._1));\n+fn find_pre_post_state_fn(&_fn_info_map f_info, &fn_info fi, &ast._fn f)\n+  -> bool {\n+  be find_pre_post_state_block(f_info, fi, f.body);\n }\n \n fn fixed_point_states(_fn_info_map fm, fn_info f_info,\n-                      fn (_fn_info_map, fn_info, &ast._fn)\n-                           -> tup(bool, ast._fn) f,\n-                      &ast._fn start) -> ast._fn {\n-  auto next = f(fm, f_info, start);\n+\t\t      // with no ampersands for the first two args, and likewise for find_pre_post_state_fn,\n+\t\t      // I got a segfault\n+                      fn (&_fn_info_map, &fn_info, &ast._fn) -> bool f,\n+                      &ast._fn start) -> () {\n+  log(\"fixed_point_states: \" + uistr(fm.size()) + \" \" + uistr(f_info.size()));\n \n-  if (next._0) {\n-    // something changed\n-    be fixed_point_states(fm, f_info, f, next._1);\n+  auto changed = f(fm, f_info, start);\n+\n+  if (changed) {\n+    be fixed_point_states(fm, f_info, f, start);\n   }\n   else {\n     // we're done!\n-    ret next._1;\n+    ret;\n   }\n }\n \n@@ -917,7 +1060,12 @@ fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n       let prestate pres   = ann_prestate(*a);\n \n       if (!implies(pres, prec)) {\n-        log(\"check_states_stmt: unsatisfied precondition\");\n+        log(\"check_states_stmt: unsatisfied precondition for \");\n+\tlog_stmt(s);\n+\tlog(\"Precondition: \");\n+\tlog_bitv(enclosing, prec);\n+\tlog(\"Prestate: \");\n+\tlog_bitv(enclosing, pres);\n         fail;\n       }\n     }\n@@ -947,16 +1095,18 @@ fn check_item_fn_state(&_fn_info_map f_info_map, &span sp, ident i,\n   check(f_info_map.contains_key(id));\n   auto f_info = f_info_map.get(id);\n \n+  log(\"check_item_fn_state: id = \" + i + \" \" + uistr(f_info_map.size()) + \" \" + uistr(f_info.size()));\n+\n   /* Compute the pre- and post-states for this function */\n   auto g = find_pre_post_state_fn;\n-  auto res_f = fixed_point_states(f_info_map, f_info, g, f);\n+  fixed_point_states(f_info_map, f_info, g, f);\n \n   /* Now compare each expr's pre-state to its precondition\n      and post-state to its postcondition */\n-  check_states_against_conditions(f_info, res_f);\n+  check_states_against_conditions(f_info, f);\n \n   /* Rebuild the same function */\n-  ret @respan(sp, ast.item_fn(i, res_f, ty_params, id, a));\n+  ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n fn check_crate(@ast.crate crate) -> @ast.crate {\n@@ -978,3 +1128,14 @@ fn check_crate(@ast.crate crate) -> @ast.crate {\n   ret fold.fold_crate[_fn_info_map](fn_info_map, fld1,\n                                     with_pre_postconditions);\n }\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "14efb6671b024e021ef54f88f6ba0ba1d039f7e8", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c001af07c658b9583bde8d138d1d9408274d741/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9c001af07c658b9583bde8d138d1d9408274d741/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=9c001af07c658b9583bde8d138d1d9408274d741", "patch": "@@ -65,10 +65,14 @@ auth lib.llvm = unsafe;\n auth pretty.pprust = impure;\n auth middle.typestate_check.find_pre_post_block = impure;\n auth middle.typestate_check.find_pre_post_state_block = impure;\n+auth middle.typestate_check.find_pre_post_state_stmt = impure;\n+auth middle.typestate_check.find_pre_post_state_expr = impure;\n+auth middle.typestate_check.find_pre_post_state_exprs = impure;\n auth middle.typestate_check.find_pre_post_expr  = impure;\n auth middle.typestate_check.find_pre_post_stmt  = impure;\n auth middle.typestate_check.check_states_against_conditions = impure;\n auth middle.typestate_check.check_states_stmt   = impure;\n+auth middle.typestate_check.log_stmt            = impure;\n auth util.typestate_ann.implies = impure;\n \n mod lib {"}, {"sha": "6dec6c00947379e1f2f4292de5d4e423c9fb35c8", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c001af07c658b9583bde8d138d1d9408274d741/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c001af07c658b9583bde8d138d1d9408274d741/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=9c001af07c658b9583bde8d138d1d9408274d741", "patch": "@@ -1,5 +1,6 @@\n import std._uint;\n import std._int;\n+import std._vec;\n import front.ast;\n \n \n@@ -75,6 +76,17 @@ fn istr(int i) -> str {\n     ret _int.to_str(i, 10u);\n }\n \n+fn uistr(uint i) -> str {\n+    ret _uint.to_str(i, 10u);\n+}\n+\n+fn elt_expr(&ast.elt e) -> @ast.expr { ret e.expr; }\n+\n+fn elt_exprs(vec[ast.elt] elts) -> vec[@ast.expr] {\n+    auto f = elt_expr;\n+    be _vec.map[ast.elt, @ast.expr](f, elts);\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "c8d233216206b88a782df9bfd6ede46e614557b8", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c001af07c658b9583bde8d138d1d9408274d741/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c001af07c658b9583bde8d138d1d9408274d741/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=9c001af07c658b9583bde8d138d1d9408274d741", "patch": "@@ -104,6 +104,18 @@ impure fn set_postcondition(&ts_ann a, &postcond p) -> () {\n   bitv.copy(p, a.conditions.postcondition);\n }\n \n+// Sets all the bits in a's prestate to equal the\n+// corresponding bit in p's prestate.\n+impure fn set_prestate(&ts_ann a, &prestate p) -> () {\n+  bitv.copy(p, a.states.prestate);\n+}\n+\n+// Sets all the bits in a's postcondition to equal the\n+// corresponding bit in p's postcondition.\n+impure fn set_poststate(&ts_ann a, &poststate p) -> () {\n+  bitv.copy(p, a.states.poststate);\n+}\n+\n // Set all the bits in p that are set in new\n impure fn extend_prestate(&prestate p, &poststate new) -> () {\n   bitv.union(p, new);\n@@ -119,5 +131,5 @@ fn ann_prestate(&ts_ann a) -> prestate {\n \n impure fn implies(bitv.t a, bitv.t b) -> bool {\n   bitv.difference(b, a);\n-  be bitv.is_false(b);\n+  ret bitv.is_false(b);\n }"}, {"sha": "75254ce75e8cbad6d6806e1f65aa19e40616ce6b", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c001af07c658b9583bde8d138d1d9408274d741/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c001af07c658b9583bde8d138d1d9408274d741/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=9c001af07c658b9583bde8d138d1d9408274d741", "patch": "@@ -170,6 +170,21 @@ fn to_vec(&t v) -> vec[uint] {\n     ret _vec.init_fn[uint](sub, v.nbits);\n }\n \n+fn to_str(&t v) -> str {\n+    auto res = \"\";\n+\n+    for(uint i in v.storage) {\n+        if (i == 1u) {\n+            res += \"1\";\n+        }\n+        else {\n+            res += \"0\";\n+        }\n+    }\n+\n+    ret res;\n+}\n+\n // FIXME: can we just use structural equality on to_vec?\n fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n     check (v0.nbits == _vec.len[uint](v1));"}]}