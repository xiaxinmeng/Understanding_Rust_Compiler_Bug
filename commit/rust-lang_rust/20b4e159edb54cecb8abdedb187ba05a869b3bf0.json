{"sha": "20b4e159edb54cecb8abdedb187ba05a869b3bf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYjRlMTU5ZWRiNTRjZWNiOGFiZGVkYjE4N2JhMDVhODY5YjNiZjA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-06T17:24:11Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-13T12:21:45Z"}, "message": "Implement automatic overloaded dereference.\nCloses #7141.", "tree": {"sha": "d473bd66612ad8d1f8849cd2dced63d5e4023dab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d473bd66612ad8d1f8849cd2dced63d5e4023dab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20b4e159edb54cecb8abdedb187ba05a869b3bf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20b4e159edb54cecb8abdedb187ba05a869b3bf0", "html_url": "https://github.com/rust-lang/rust/commit/20b4e159edb54cecb8abdedb187ba05a869b3bf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20b4e159edb54cecb8abdedb187ba05a869b3bf0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdc18b96d6aa38c22b4fa9715c974ef986ad250d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdc18b96d6aa38c22b4fa9715c974ef986ad250d", "html_url": "https://github.com/rust-lang/rust/commit/cdc18b96d6aa38c22b4fa9715c974ef986ad250d"}], "stats": {"total": 1792, "additions": 871, "deletions": 921}, "files": [{"sha": "b226e773dbb880f6a9f87f44b0a948aa967a5116", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -101,7 +101,7 @@ impl<T: Clone + Float> Cmplx<T> {\n     /// Convert a polar representation into a complex number.\n     #[inline]\n     pub fn from_polar(r: &T, theta: &T) -> Cmplx<T> {\n-        Cmplx::new(r * theta.cos(), r * theta.sin())\n+        Cmplx::new(*r * theta.cos(), *r * theta.sin())\n     }\n }\n "}, {"sha": "fed35922a90c0ffbc02d73df78da0d16b094d981", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -21,7 +21,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n                          RegionParameter};\n use metadata::tyencode;\n-use middle::typeck::{MethodCallee, MethodOrigin};\n+use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n@@ -1039,7 +1039,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    for &method in maps.method_map.borrow().get().find(&id).iter() {\n+    let method_call = MethodCall::expr(id);\n+    for &method in maps.method_map.borrow().get().find(&method_call).iter() {\n         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -1385,7 +1386,8 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_method_map => {\n                         let method = val_dsr.read_method_callee(xcx);\n-                        dcx.maps.method_map.borrow_mut().get().insert(id, method);\n+                        let method_call = MethodCall::expr(id);\n+                        dcx.maps.method_map.borrow_mut().get().insert(method_call, method);\n                     }\n                     c::tag_table_vtable_map => {\n                         let vtable_res ="}, {"sha": "e50d24560701ee25da81b481bba6873da5646432", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -22,6 +22,7 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n+use middle::typeck::MethodCall;\n use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n@@ -838,11 +839,11 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n         this.check_call(expr, None, expr.span, args.as_slice());\n       }\n       ast::ExprIndex(_, rval) | ast::ExprBinary(_, _, rval)\n-      if method_map.get().contains_key(&expr.id) => {\n+      if method_map.get().contains_key(&MethodCall::expr(expr.id)) => {\n         this.check_call(expr, None, expr.span, [rval]);\n       }\n       ast::ExprUnary(_, _) | ast::ExprIndex(_, _)\n-      if method_map.get().contains_key(&expr.id) => {\n+      if method_map.get().contains_key(&MethodCall::expr(expr.id)) => {\n         this.check_call(expr, None, expr.span, []);\n       }\n       ast::ExprInlineAsm(ref ia) => {"}, {"sha": "d2fcee79fc03189fc3bbdd1acdca9fbc949dc5a5", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -23,6 +23,7 @@ use middle::moves;\n use middle::pat_util;\n use middle::ty::{ty_region};\n use middle::ty;\n+use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n@@ -242,7 +243,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n       ast::ExprIndex(_, arg) |\n       ast::ExprBinary(_, _, arg)\n-      if method_map.get().contains_key(&ex.id) => {\n+      if method_map.get().contains_key(&MethodCall::expr(ex.id)) => {\n           // Arguments in method calls are always passed by ref.\n           //\n           // Currently these do not use adjustments, so we have to"}, {"sha": "44a5acc7f1b54dabdc0194f5bf0b33ab9858ed1d", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -556,7 +556,8 @@ impl BorrowckCtxt {\n             move_data::MoveExpr => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, expr,\n+                                              self.method_map.borrow().get()), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to {:?}, not Expr\",\n                                                    move.id, r))\n@@ -582,7 +583,8 @@ impl BorrowckCtxt {\n             move_data::Captured => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, expr,\n+                                              self.method_map.borrow().get()), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"Captured({:?}) maps to {:?}, not Expr\",\n                                                    move.id, r))\n@@ -922,8 +924,8 @@ impl mc::Typer for TcxTyper {\n         Ok(ty::node_id_to_type(self.tcx, id))\n     }\n \n-    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t> {\n-        self.method_map.borrow().get().find(&id).map(|method| method.ty)\n+    fn node_method_ty(&mut self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+        self.method_map.borrow().get().find(&method_call).map(|method| method.ty)\n     }\n \n     fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n@@ -932,7 +934,7 @@ impl mc::Typer for TcxTyper {\n     }\n \n     fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n-        self.method_map.borrow().get().contains_key(&id)\n+        self.method_map.borrow().get().contains_key(&typeck::MethodCall::expr(id))\n     }\n \n     fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {"}, {"sha": "0100a82a9d5aa56aad2ce3dbf0b55e239acd8619", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -523,7 +523,7 @@ impl CFGBuilder {\n     }\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_map = self.method_map.borrow();\n-        method_map.get().contains_key(&expr.id)\n+        let method_call = typeck::MethodCall::expr(expr.id);\n+        self.method_map.borrow().get().contains_key(&method_call)\n     }\n }"}, {"sha": "6841e09f7f2db661e2296cda0677c918f418695a", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -117,8 +117,8 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           }\n           ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n-            let method_map = method_map.borrow();\n-            if method_map.get().contains_key(&e.id) {\n+              let method_call = typeck::MethodCall::expr(e.id);\n+            if method_map.borrow().get().contains_key(&method_call) {\n                 sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");\n             }"}, {"sha": "1f675b7bb4a688e0400b6809970e8ef7d848649c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -16,7 +16,7 @@ use middle::astencode;\n use middle::ty;\n use middle::typeck::astconv;\n use middle;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use syntax::ast::*;\n use syntax::parse::token::InternedString;\n@@ -136,7 +136,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(NodeMap::new()),\n+            method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n             capture_map: @RefCell::new(NodeMap::new())\n         };\n@@ -186,7 +186,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(NodeMap::new()),\n+            method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n             capture_map: @RefCell::new(NodeMap::new())\n         };"}, {"sha": "57b5be4e96069b5742dde20c524c170cfbbf92fe", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -810,8 +810,8 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     }\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_map = self.dfcx.method_map.borrow();\n-        method_map.get().contains_key(&expr.id)\n+        let method_call = typeck::MethodCall::expr(expr.id);\n+        self.dfcx.method_map.borrow().get().contains_key(&method_call)\n     }\n \n     fn reset(&mut self, bits: &mut [uint]) {"}, {"sha": "310feb88892d71e43ea6b5d02b583d2af8d8cb74", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -92,9 +92,10 @@ impl MarkSymbolVisitor {\n         }\n     }\n \n-    fn lookup_and_handle_method(&mut self, id: &ast::NodeId,\n+    fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n                                 span: codemap::Span) {\n-        match self.method_map.borrow().get().find(id) {\n+        let method_call = typeck::MethodCall::expr(id);\n+        match self.method_map.borrow().get().find(&method_call) {\n             Some(method) => {\n                 match method.origin {\n                     typeck::MethodStatic(def_id) => {\n@@ -179,7 +180,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n             ast::ExprMethodCall(..) => {\n-                self.lookup_and_handle_method(&expr.id, expr.span);\n+                self.lookup_and_handle_method(expr.id, expr.span);\n             }\n             _ => ()\n         }"}, {"sha": "d3ec7044040ccabf513cdd09d0d034dff2c28b4d", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -12,7 +12,7 @@\n /// `unsafe`.\n \n use middle::ty;\n-use middle::typeck::MethodMap;\n+use middle::typeck::{MethodCall, MethodMap};\n use util::ppaux;\n \n use syntax::ast;\n@@ -138,7 +138,8 @@ impl Visitor<()> for EffectCheckVisitor {\n     fn visit_expr(&mut self, expr: &ast::Expr, _:()) {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n-                let base_type = self.method_map.borrow().get().get(&expr.id).ty;\n+                let method_call = MethodCall::expr(expr.id);\n+                let base_type = self.method_map.borrow().get().get(&method_call).ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "7771cb0ab3c14d1b6775dcfde9cde2fca26c4fe3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -267,7 +267,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     // Handle any kind bounds on type parameters\n     {\n         let method_map = cx.method_map.borrow();\n-        let method = method_map.get().find(&e.id);\n+        let method = method_map.get().find(&typeck::MethodCall::expr(e.id));\n         let node_type_substs = cx.tcx.node_type_substs.borrow();\n         let r = match method {\n             Some(method) => Some(&method.substs.tps),\n@@ -341,7 +341,8 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n             match **adjustment {\n                 ty::AutoObject(..) => {\n                     let source_ty = ty::expr_ty(cx.tcx, e);\n-                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n+                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e,\n+                                                         cx.method_map.borrow().get());\n                     check_trait_cast(cx, source_ty, target_ty, e.span);\n                 }\n                 ty::AutoAddEnv(..) |"}, {"sha": "31d705dc6aa933e9330975d727a684165d870166", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -1491,7 +1491,8 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            match cx.method_map.borrow().get().find(&e.id) {\n+            let method_call = typeck::MethodCall::expr(e.id);\n+            match cx.method_map.borrow().get().find(&method_call) {\n                 Some(method) => {\n                     match method.origin {\n                         typeck::MethodStatic(def_id) => {"}, {"sha": "c07cd2570a30b3b08e4e65f234384aaddc21a06e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 47, "deletions": 50, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -63,6 +63,7 @@\n #[allow(non_camel_case_types)];\n \n use middle::ty;\n+use middle::typeck;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n \n use std::vec_ng::Vec;\n@@ -268,7 +269,7 @@ pub type McResult<T> = Result<T, ()>;\n pub trait Typer {\n     fn tcx(&self) -> ty::ctxt;\n     fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n-    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t>;\n+    fn node_method_ty(&mut self, method_call: typeck::MethodCall) -> Option<ty::t>;\n     fn adjustment(&mut self, node_id: ast::NodeId) -> Option<@ty::AutoAdjustment>;\n     fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n@@ -365,7 +366,8 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n     fn expr_ty_adjusted(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n         let adjustment = self.adjustment(expr.id);\n-        Ok(ty::adjust_ty(self.tcx(), expr.span, unadjusted_ty, adjustment))\n+        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty, adjustment,\n+                         |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n     fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t> {\n@@ -435,21 +437,11 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, e_base) => {\n-            let base_cmt = match self.typer.node_method_ty(expr.id) {\n-                Some(method_ty) => {\n-                    let ref_ty = ty::ty_fn_ret(method_ty);\n-                    self.cat_rvalue_node(expr.id(), expr.span(), ref_ty)\n-                }\n-                None => if_ok!(self.cat_expr(e_base))\n-            };\n+            let base_cmt = if_ok!(self.cat_expr(e_base));\n             Ok(self.cat_deref(expr, base_cmt, 0))\n           }\n \n           ast::ExprField(base, f_name, _) => {\n-            // Method calls are now a special syntactic form,\n-            // so `a.b` should always be a field.\n-            assert!(!self.typer.is_method_call(expr.id));\n-\n             let base_cmt = if_ok!(self.cat_expr(base));\n             Ok(self.cat_field(expr, base_cmt, f_name, expr_ty))\n           }\n@@ -725,59 +717,64 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         // `()` (the empty tuple).\n \n         let opaque_ty = ty::mk_tup(self.tcx(), Vec::new());\n-        return self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty);\n+        self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty)\n     }\n \n-    pub fn cat_deref<N:ast_node>(&mut self,\n-                                 node: &N,\n-                                 base_cmt: cmt,\n-                                 deref_cnt: uint)\n-                                 -> cmt {\n-        let mt = match ty::deref(base_cmt.ty, true) {\n-            Some(mt) => mt,\n+    fn cat_deref<N:ast_node>(&mut self,\n+                             node: &N,\n+                             base_cmt: cmt,\n+                             deref_cnt: uint)\n+                             -> cmt {\n+        let method_call = typeck::MethodCall {\n+            expr_id: node.id(),\n+            autoderef: deref_cnt as u32\n+        };\n+        let method_ty = self.typer.node_method_ty(method_call);\n+\n+        debug!(\"cat_deref: method_call={:?} method_ty={}\",\n+            method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n+\n+        let base_cmt = match method_ty {\n+            Some(method_ty) => {\n+                let ref_ty = ty::ty_fn_ret(method_ty);\n+                self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n+            }\n+            None => base_cmt\n+        };\n+        match ty::deref(base_cmt.ty, true) {\n+            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty),\n             None => {\n                 self.tcx().sess.span_bug(\n                     node.span(),\n                     format!(\"Explicit deref of non-derefable type: {}\",\n                             base_cmt.ty.repr(self.tcx())));\n             }\n-        };\n-\n-        return self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty);\n+        }\n     }\n \n-    pub fn cat_deref_common<N:ast_node>(&mut self,\n-                                        node: &N,\n-                                        base_cmt: cmt,\n-                                        deref_cnt: uint,\n-                                        deref_ty: ty::t)\n-                                        -> cmt {\n-        match deref_kind(self.tcx(), base_cmt.ty) {\n+    fn cat_deref_common<N:ast_node>(&mut self,\n+                                    node: &N,\n+                                    base_cmt: cmt,\n+                                    deref_cnt: uint,\n+                                    deref_ty: ty::t)\n+                                    -> cmt {\n+        let (m, cat) = match deref_kind(self.tcx(), base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n-                let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl,\n-                                                              ptr);\n-\n-                @cmt_ {\n-                    id:node.id(),\n-                    span:node.span(),\n-                    cat:cat_deref(base_cmt, deref_cnt, ptr),\n-                    mutbl:m,\n-                    ty:deref_ty\n-                }\n+                (MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n+                 cat_deref(base_cmt, deref_cnt, ptr))\n             }\n-\n             deref_interior(interior) => {\n-                let m = base_cmt.mutbl.inherit();\n-                @cmt_ {\n-                    id:node.id(),\n-                    span:node.span(),\n-                    cat:cat_interior(base_cmt, interior),\n-                    mutbl:m,\n-                    ty:deref_ty\n-                }\n+                (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n+        };\n+        @cmt_ {\n+            id: node.id(),\n+            span: node.span(),\n+            cat: cat,\n+            mutbl: m,\n+            ty: deref_ty\n         }\n     }\n "}, {"sha": "b52ec7be631143b24e4d59a77bb1c027c1e81465", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -130,7 +130,7 @@ and so on.\n use middle::pat_util::{pat_bindings};\n use middle::freevars;\n use middle::ty;\n-use middle::typeck::MethodMap;\n+use middle::typeck::{MethodCall, MethodMap};\n use util::ppaux;\n use util::ppaux::Repr;\n use util::common::indenter;\n@@ -281,12 +281,10 @@ impl VisitContext {\n         debug!(\"consume_expr(expr={})\",\n                expr.repr(self.tcx));\n \n-        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr,\n+                                           self.method_map.borrow().get());\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n-            {\n-                let mut moves_map = self.move_maps.moves_map.borrow_mut();\n-                moves_map.get().insert(expr.id);\n-            }\n+            self.move_maps.moves_map.borrow_mut().get().insert(expr.id);\n             self.use_expr(expr, Move);\n         } else {\n             self.use_expr(expr, Read);\n@@ -608,8 +606,8 @@ impl VisitContext {\n                                    receiver_expr: @Expr,\n                                    arg_exprs: &[@Expr])\n                                    -> bool {\n-        let method_map = self.method_map.borrow();\n-        if !method_map.get().contains_key(&expr.id) {\n+        let method_call = MethodCall::expr(expr.id);\n+        if !self.method_map.borrow().get().contains_key(&method_call) {\n             return false;\n         }\n "}, {"sha": "b8a40f623d947088a56ebe9eb98b7d28e1299aba", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -19,7 +19,7 @@ use metadata::csearch;\n use middle::lint;\n use middle::resolve;\n use middle::ty;\n-use middle::typeck::{MethodMap, MethodOrigin, MethodParam};\n+use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodObject};\n use util::nodemap::{NodeMap, NodeSet};\n \n@@ -772,40 +772,26 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n             ast::ExprField(base, ident, _) => {\n-                // Method calls are now a special syntactic form,\n-                // so `a.b` should always be a field.\n-                let method_map = self.method_map.borrow();\n-                assert!(!method_map.get().contains_key(&expr.id));\n-\n-                // With type_autoderef, make sure we don't\n-                // allow pointers to violate privacy\n-                let t = ty::type_autoderef(ty::expr_ty(self.tcx, base));\n-                match ty::get(t).sty {\n+                match ty::get(ty::expr_ty_adjusted(self.tcx, base,\n+                                                   self.method_map.borrow().get())).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, ident, None);\n                     }\n                     _ => {}\n                 }\n             }\n-            ast::ExprMethodCall(ident, _, ref args) => {\n-                // see above\n-                let t = ty::type_autoderef(ty::expr_ty(self.tcx,\n-                                                       *args.get(0)));\n-                match ty::get(t).sty {\n-                    ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n-                        match self.method_map.borrow().get().find(&expr.id) {\n-                            None => {\n-                                self.tcx.sess.span_bug(expr.span,\n-                                                       \"method call not in \\\n-                                                        method map\");\n-                            }\n-                            Some(method) => {\n-                                debug!(\"(privacy checking) checking impl method\");\n-                                self.check_method(expr.span, method.origin, ident);\n-                            }\n-                        }\n+            ast::ExprMethodCall(ident, _, _) => {\n+                let method_call = MethodCall::expr(expr.id);\n+                match self.method_map.borrow().get().find(&method_call) {\n+                    None => {\n+                        self.tcx.sess.span_bug(expr.span,\n+                                                \"method call not in \\\n+                                                method map\");\n+                    }\n+                    Some(method) => {\n+                        debug!(\"(privacy checking) checking impl method\");\n+                        self.check_method(expr.span, method.origin, ident);\n                     }\n-                    _ => {}\n                 }\n             }\n             ast::ExprStruct(_, ref fields, _) => {"}, {"sha": "e9d01713e1c271942601b8cf8dc1b173cbd48db3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -149,24 +149,17 @@ impl Visitor<()> for MarkSymbolVisitor {\n                 }\n             }\n             ast::ExprMethodCall(..) => {\n-                match self.method_map.borrow().get().get(&expr.id).origin {\n+                let method_call = typeck::MethodCall::expr(expr.id);\n+                match self.method_map.borrow().get().get(&method_call).origin {\n                     typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if ReachableContext::\n                                 def_id_represents_local_inlined_item(\n                                     self.tcx,\n                                     def_id) {\n-                                {\n-                                    let mut worklist = self.worklist\n-                                                           .borrow_mut();\n-                                    worklist.get().push(def_id.node)\n-                                }\n-                            }\n-                            {\n-                                let mut reachable_symbols =\n-                                    self.reachable_symbols.borrow_mut();\n-                                reachable_symbols.get().insert(def_id.node);\n+                                self.worklist.borrow_mut().get().push(def_id.node)\n                             }\n+                            self.reachable_symbols.borrow_mut().get().insert(def_id.node);\n                         }\n                     }\n                     _ => {}"}, {"sha": "1a398a7377100a7cc097e11ecd06c74414f63947", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -50,10 +50,11 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     let inputs = ia.inputs.map(|&(ref c, input)| {\n         constraints.push((*c).clone());\n \n+        let in_datum = unpack_datum!(bcx, expr::trans(bcx, input));\n         unpack_result!(bcx, {\n-            callee::trans_arg_expr(bcx,\n+            callee::trans_arg_datum(bcx,\n                                    expr_ty(bcx, input),\n-                                   input,\n+                                   in_datum,\n                                    cleanup::CustomScope(temp_scope),\n                                    callee::DontAutorefArg)\n         })"}, {"sha": "5e2a8792abf86fd3321a2c23aa12da709a9ce64d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -44,6 +44,7 @@ use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n+use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n@@ -120,7 +121,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         match def {\n             ast::DefFn(did, _) |\n             ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n-                fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id, false))\n+                fn_callee(bcx, trans_fn_ref(bcx, did, ExprId(ref_expr.id)))\n             }\n             ast::DefStaticMethod(impl_did,\n                                    ast::FromTrait(trait_did),\n@@ -134,10 +135,10 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n                 assert!(ty::enum_variant_with_id(bcx.tcx(),\n                                                       tid,\n                                                       vid).args.len() > 0u);\n-                fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id, false))\n+                fn_callee(bcx, trans_fn_ref(bcx, vid, ExprId(ref_expr.id)))\n             }\n             ast::DefStruct(def_id) => {\n-                fn_callee(bcx, trans_fn_ref(bcx, def_id, ref_expr.id, false))\n+                fn_callee(bcx, trans_fn_ref(bcx, def_id, ExprId(ref_expr.id)))\n             }\n             ast::DefStatic(..) |\n             ast::DefArg(..) |\n@@ -160,9 +161,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     }\n }\n \n-pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId,\n-                    ref_id: ast::NodeId, is_method: bool)\n-                    -> ValueRef {\n+pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) -> ValueRef {\n     /*!\n      *\n      * Translates a reference (with id `ref_id`) to the fn/method\n@@ -171,15 +170,18 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId,\n \n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n-    let type_params = node_id_type_params(bcx, ref_id, is_method);\n-    let vtables = node_vtables(bcx, ref_id);\n-    debug!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n-           def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n+    let type_params = node_id_type_params(bcx, node);\n+    let vtables = match node {\n+        ExprId(id) => node_vtables(bcx, id),\n+        MethodCall(method_call) if method_call.autoderef == 0 => {\n+            node_vtables(bcx, method_call.expr_id)\n+        }\n+        _ => None\n+    };\n+    debug!(\"trans_fn_ref(def_id={}, node={:?}, type_params={}, vtables={})\",\n+           def_id.repr(bcx.tcx()), node, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n-    trans_fn_ref_with_vtables(bcx,\n-                              def_id,\n-                              ref_id,\n-                              is_method,\n+    trans_fn_ref_with_vtables(bcx, def_id, node,\n                               type_params.as_slice(),\n                               vtables)\n }\n@@ -191,7 +193,7 @@ fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n                                            vtables: Option<typeck::vtable_res>)\n                                            -> Callee<'a> {\n     Callee {bcx: bcx,\n-            data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ref_id, false,\n+            data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ExprId(ref_id),\n                                                type_params, vtables))}\n }\n \n@@ -241,8 +243,7 @@ fn resolve_default_method_vtables(bcx: &Block,\n pub fn trans_fn_ref_with_vtables(\n         bcx: &Block,       //\n         def_id: ast::DefId,   // def id of fn\n-        ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n-        is_method: bool,\n+        node: ExprOrMethodCall,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> ValueRef {\n@@ -254,7 +255,7 @@ pub fn trans_fn_ref_with_vtables(\n      *\n      * - `bcx`: the current block where the reference to the fn occurs\n      * - `def_id`: def id of the fn or method item being referenced\n-     * - `ref_id`: node id of the reference to the fn/method, if applicable.\n+     * - `node`: node id of the reference to the fn/method, if applicable.\n      *   This parameter may be zero; but, if so, the resulting value may not\n      *   have the right type, so it must be cast before being used.\n      * - `type_params`: values for each of the fn/method's type parameters\n@@ -265,11 +266,11 @@ pub fn trans_fn_ref_with_vtables(\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, ref_id={:?}, \\\n+    debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, node={:?}, \\\n             type_params={}, vtables={})\",\n            bcx.to_str(),\n            def_id.repr(bcx.tcx()),\n-           ref_id,\n+           node,\n            type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n \n@@ -380,19 +381,25 @@ pub fn trans_fn_ref_with_vtables(\n         // Should be either intra-crate or inlined.\n         assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n+        let ref_id = match node {\n+            ExprId(id) if id != 0 => Some(id),\n+            _ => None\n+        };\n+\n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n                                          vtables, self_vtables,\n-                                         Some(ref_id));\n+                                         ref_id);\n         let mut val = val;\n-        if must_cast && ref_id != 0 {\n+        if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)\n-            let ref_ty = if is_method {\n-                let t = bcx.ccx().maps.method_map.borrow().get().get(&ref_id).ty;\n-                monomorphize_type(bcx, t)\n-            } else {\n-                node_id_type(bcx, ref_id)\n+            let ref_ty = match node {\n+                ExprId(id) => node_id_type(bcx, id),\n+                MethodCall(method_call) => {\n+                    let t = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n+                    monomorphize_type(bcx, t)\n+                }\n             };\n \n             val = PointerCast(\n@@ -472,13 +479,14 @@ pub fn trans_method_call<'a>(\n                          -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n-    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&call_ex.id).ty;\n+    let method_call = MethodCall::expr(call_ex.id);\n+    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n     trans_call_inner(\n         bcx,\n         Some(common::expr_info(call_ex)),\n         monomorphize_type(bcx, method_ty),\n         |cx, arg_cleanup_scope| {\n-            meth::trans_method_callee(cx, call_ex.id, rcvr, arg_cleanup_scope)\n+            meth::trans_method_callee(cx, method_call, Some(rcvr), arg_cleanup_scope)\n         },\n         args,\n         Some(dest)).bcx\n@@ -717,19 +725,16 @@ pub fn trans_call_inner<'a>(\n         assert!(dest.is_some());\n \n         let mut llargs = Vec::new();\n-        bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope), false);\n-        fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n         let arg_tys = match args {\n             ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n             _ => fail!(\"expected arg exprs.\")\n         };\n-        bcx = foreign::trans_native_call(bcx,\n-                                         callee_ty,\n-                                         llfn,\n-                                         opt_llretslot.unwrap(),\n-                                         llargs.as_slice(),\n-                                         arg_tys);\n+        bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n+                         cleanup::CustomScope(arg_cleanup_scope), false);\n+        fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n+        bcx = foreign::trans_native_call(bcx, callee_ty,\n+                                         llfn, opt_llretslot.unwrap(),\n+                                         llargs.as_slice(), arg_tys);\n     }\n \n     // If the caller doesn't care about the result of this fn call,\n@@ -754,8 +759,7 @@ pub fn trans_call_inner<'a>(\n \n pub enum CallArgs<'a> {\n     ArgExprs(&'a [@ast::Expr]),\n-    // HACK used only by trans_overloaded_op.\n-    ArgAutorefSecond(&'a ast::Expr, Option<&'a ast::Expr>),\n+    ArgOverloadedOp(Datum<Expr>, Option<(Datum<Expr>, ast::NodeId)>),\n     ArgVals(&'a [ValueRef])\n }\n \n@@ -778,40 +782,42 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n     match args {\n         ArgExprs(arg_exprs) => {\n             let num_formal_args = arg_tys.len();\n-            for (i, arg_expr) in arg_exprs.iter().enumerate() {\n+            for (i, &arg_expr) in arg_exprs.iter().enumerate() {\n                 if i == 0 && ignore_self {\n                     continue;\n                 }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n-                    expr_ty_adjusted(cx, *arg_expr)\n+                    expr_ty_adjusted(cx, arg_expr)\n                 } else {\n                     *arg_tys.get(i)\n                 };\n+\n+                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_expr));\n                 llargs.push(unpack_result!(bcx, {\n-                    trans_arg_expr(bcx, arg_ty, *arg_expr,\n-                                   arg_cleanup_scope,\n-                                   DontAutorefArg)\n+                    trans_arg_datum(bcx, arg_ty, arg_datum,\n+                                    arg_cleanup_scope,\n+                                    DontAutorefArg)\n                 }));\n             }\n         }\n-        ArgAutorefSecond(arg_expr, arg2) => {\n+        ArgOverloadedOp(lhs, rhs) => {\n             assert!(!variadic);\n \n             llargs.push(unpack_result!(bcx, {\n-                trans_arg_expr(bcx, *arg_tys.get(0), arg_expr,\n-                               arg_cleanup_scope,\n-                               DontAutorefArg)\n+                trans_arg_datum(bcx, *arg_tys.get(0), lhs,\n+                                arg_cleanup_scope,\n+                                DontAutorefArg)\n             }));\n \n-            match arg2 {\n-                Some(arg2_expr) => {\n+            match rhs {\n+                Some((rhs, rhs_id)) => {\n                     assert_eq!(arg_tys.len(), 2);\n \n                     llargs.push(unpack_result!(bcx, {\n-                        trans_arg_expr(bcx, *arg_tys.get(1), arg2_expr,\n-                                       arg_cleanup_scope,\n-                                       DoAutorefArg)\n+                        trans_arg_datum(bcx, *arg_tys.get(1), rhs,\n+                                        arg_cleanup_scope,\n+                                        DoAutorefArg(rhs_id))\n                     }));\n                 }\n                 None => assert_eq!(arg_tys.len(), 1)\n@@ -827,26 +833,23 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n \n pub enum AutorefArg {\n     DontAutorefArg,\n-    DoAutorefArg\n+    DoAutorefArg(ast::NodeId)\n }\n \n-pub fn trans_arg_expr<'a>(\n+pub fn trans_arg_datum<'a>(\n                       bcx: &'a Block<'a>,\n                       formal_arg_ty: ty::t,\n-                      arg_expr: &ast::Expr,\n+                      arg_datum: Datum<Expr>,\n                       arg_cleanup_scope: cleanup::ScopeId,\n                       autoref_arg: AutorefArg)\n                       -> Result<'a> {\n-    let _icx = push_ctxt(\"trans_arg_expr\");\n+    let _icx = push_ctxt(\"trans_arg_datum\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_arg_ty=({}), arg_expr={})\",\n-           formal_arg_ty.repr(bcx.tcx()),\n-           arg_expr.repr(bcx.tcx()));\n+    debug!(\"trans_arg_datum({})\",\n+           formal_arg_ty.repr(bcx.tcx()));\n \n-    // translate the arg expr to a datum\n-    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_expr));\n     let arg_datum_ty = arg_datum.ty;\n \n     debug!(\"   arg datum: {}\", arg_datum.to_str(bcx.ccx()));\n@@ -864,11 +867,11 @@ pub fn trans_arg_expr<'a>(\n     } else {\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n-            DoAutorefArg => {\n+            DoAutorefArg(arg_id) => {\n                 // We will pass argument by reference\n                 // We want an lvalue, so that we can pass by reference and\n                 let arg_datum = unpack_datum!(\n-                    bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_expr.id));\n+                    bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_id));\n                 val = arg_datum.val;\n             }\n             DontAutorefArg => {\n@@ -898,6 +901,6 @@ pub fn trans_arg_expr<'a>(\n         }\n     }\n \n-    debug!(\"--- trans_arg_expr passing {}\", bcx.val_to_str(val));\n-    return rslt(bcx, val);\n+    debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_str(val));\n+    rslt(bcx, val)\n }"}, {"sha": "d249bd8a894cc8be40d43a9049a3c2f4d3770d43", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -19,7 +19,7 @@ use middle::trans::base;\n use middle::trans::build;\n use middle::trans::callee;\n use middle::trans::common;\n-use middle::trans::common::{Block, FunctionContext};\n+use middle::trans::common::{Block, FunctionContext, ExprId};\n use middle::trans::glue;\n use middle::trans::type_::Type;\n use middle::ty;\n@@ -673,7 +673,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n \n         // The exception handling personality function.\n         let def_id = common::langcall(pad_bcx, None, \"\", EhPersonalityLangItem);\n-        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, 0, false);\n+        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, ExprId(0));\n \n         // The only landing pad clause will be 'cleanup'\n         let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1u);"}, {"sha": "759e5e872d4be85236dc0e837e929f012a27f289", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -805,22 +805,29 @@ pub fn expr_ty(bcx: &Block, ex: &ast::Expr) -> ty::t {\n \n pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     let tcx = bcx.tcx();\n-    let t = ty::expr_ty_adjusted(tcx, ex);\n+    let t = ty::expr_ty_adjusted(tcx, ex, bcx.ccx().maps.method_map.borrow().get());\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> Vec<ty::t> {\n+#[deriving(Eq)]\n+pub enum ExprOrMethodCall {\n+    ExprId(ast::NodeId),\n+    MethodCall(typeck::MethodCall)\n+}\n+\n+pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n     let tcx = bcx.tcx();\n-    let params = if is_method {\n-        bcx.ccx().maps.method_map.borrow().get().get(&id).substs.tps.clone()\n-    } else {\n-        ty::node_id_to_type_params(tcx, id)\n+    let params = match node {\n+        ExprId(id) => ty::node_id_to_type_params(tcx, id),\n+        MethodCall(method_call) => {\n+            bcx.ccx().maps.method_map.borrow().get().get(&method_call).substs.tps.clone()\n+        }\n     };\n \n     if !params.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n-            format!(\"type parameters for node {} include inference types: {}\",\n-                 id, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));\n+            format!(\"type parameters for node {:?} include inference types: {}\",\n+                 node, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));\n     }\n \n     match bcx.fcx.param_substs {"}, {"sha": "9d55084c7f4e7ed95db6b8a859e909a8de4c3f1e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -190,7 +190,8 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx, e);\n-    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e);\n+    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e,\n+                                            cx.maps.method_map.borrow().get());\n     let adjustment = {\n         let adjustments = cx.tcx.adjustments.borrow();\n         adjustments.get().find_copy(&e.id)\n@@ -422,7 +423,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n             }, true)\n           }\n           ast::ExprField(base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx, base);\n+              let bt = ty::expr_ty_adjusted(cx.tcx, base,\n+                                            cx.maps.method_map.borrow().get());\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               expr::with_field_tys(cx.tcx, bt, None, |discr, field_tys| {\n@@ -432,7 +434,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n           }\n \n           ast::ExprIndex(base, index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx, base);\n+              let bt = ty::expr_ty_adjusted(cx.tcx, base,\n+                                            cx.maps.method_map.borrow().get());\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n                   const_eval::const_int(i) => i as u64,"}, {"sha": "056ac62183f90d560fa42d1fcf474cb93af293e1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 103, "deletions": 147, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -64,6 +64,7 @@ use middle::ty::struct_fields;\n use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use middle::ty;\n+use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n@@ -211,8 +212,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                     unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n                 }\n                 Some(AutoBorrowFn(..)) => {\n-                    let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span,\n-                                                    datum.ty, Some(adjustment));\n+                    let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span, expr.id, datum.ty,\n+                                                    Some(adjustment), |method_call| {\n+                        bcx.ccx().maps.method_map.borrow().get()\n+                           .find(&method_call).map(|method| method.ty)\n+                    });\n                     unpack_datum!(bcx, auto_borrow_fn(bcx, adjusted_ty, datum))\n                 }\n                 Some(AutoBorrowObj(..)) => {\n@@ -221,7 +225,8 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             };\n         }\n         AutoObject(..) => {\n-            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr);\n+            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr,\n+                                                   bcx.ccx().maps.method_map.borrow().get());\n             let scratch = rvalue_scratch_datum(bcx, adjusted_ty, \"__adjust\");\n             bcx = meth::trans_trait_cast(\n                 bcx, datum, expr.id, SaveIn(scratch.val));\n@@ -231,30 +236,6 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_ref<'a>(bcx: &'a Block<'a>,\n-                    datum: Datum<Expr>,\n-                    expr: &ast::Expr)\n-                    -> DatumBlock<'a, Expr> {\n-        let mut bcx = bcx;\n-\n-        // Ensure cleanup of `datum` if not already scheduled and obtain\n-        // a \"by ref\" pointer.\n-        let lv_datum = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"autoref\", expr.id));\n-\n-        // Compute final type. Note that we are loose with the region and\n-        // mutability, since those things don't matter in trans.\n-        let referent_ty = lv_datum.ty;\n-        let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic, referent_ty);\n-\n-        // Get the pointer.\n-        let llref = lv_datum.to_llref();\n-\n-        // Construct the resulting datum, using what was the \"by ref\"\n-        // ValueRef of type `referent_ty` to be the \"by value\" ValueRef\n-        // of type `&referent_ty`.\n-        DatumBlock(bcx, Datum(llref, ptr_ty, RvalueExpr(Rvalue(ByValue))))\n-    }\n-\n     fn auto_borrow_fn<'a>(\n                       bcx: &'a Block<'a>,\n                       adjusted_ty: ty::t,\n@@ -462,13 +443,10 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n         ast::ExprBinary(op, lhs, rhs) => {\n-            // if overloaded, would be RvalueDpsExpr\n-            assert!(!bcx.ccx().maps.method_map.borrow().get().contains_key(&expr.id));\n-\n             trans_binary(bcx, expr, op, lhs, rhs)\n         }\n         ast::ExprUnary(op, x) => {\n-            trans_unary_datum(bcx, expr, op, x)\n+            trans_unary(bcx, expr, op, x)\n         }\n         ast::ExprAddrOf(_, x) => {\n             trans_addr_of(bcx, expr, x)\n@@ -789,15 +767,23 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprBinary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, lhs, Some(&*rhs), Some(dest)).bcx\n+            let lhs = unpack_datum!(bcx, trans(bcx, lhs));\n+            let rhs_datum = unpack_datum!(bcx, trans(bcx, rhs));\n+            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n+                                Some((rhs_datum, rhs.id)), Some(dest)).bcx\n         }\n         ast::ExprUnary(_, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, subexpr, None, Some(dest)).bcx\n+            let arg = unpack_datum!(bcx, trans(bcx, subexpr));\n+            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n+                                arg, None, Some(dest)).bcx\n         }\n         ast::ExprIndex(base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, base, Some(&*idx), Some(dest)).bcx\n+            let base = unpack_datum!(bcx, trans(bcx, base));\n+            let idx_datum = unpack_datum!(bcx, trans(bcx, idx));\n+            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n+                                Some((idx_datum, idx.id)), Some(dest)).bcx\n         }\n         ast::ExprCast(val, _) => {\n             // DPS output mode means this is a trait cast:\n@@ -848,7 +834,7 @@ fn trans_def_dps_unadjusted<'a>(\n             let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n-                let llfn = callee::trans_fn_ref(bcx, vid, ref_expr.id, false);\n+                let llfn = callee::trans_fn_ref(bcx, vid, ExprId(ref_expr.id));\n                 Store(bcx, llfn, lldest);\n                 return bcx;\n             } else {\n@@ -888,7 +874,7 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::DefFn(did, _) |\n         ast::DefStruct(did) | ast::DefVariant(_, did, _) |\n         ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n-            callee::trans_fn_ref(bcx, did, ref_expr.id, false)\n+            callee::trans_fn_ref(bcx, did, ExprId(ref_expr.id))\n         }\n         ast::DefStaticMethod(impl_did, ast::FromTrait(trait_did), _) => {\n             meth::trans_static_method_callee(bcx, impl_did,\n@@ -1165,25 +1151,22 @@ fn trans_immediate_lit<'a>(bcx: &'a Block<'a>,\n     immediate_rvalue_bcx(bcx, v, ty).to_expr_datumblock()\n }\n \n-fn trans_unary_datum<'a>(\n-                     bcx: &'a Block<'a>,\n-                     un_expr: &ast::Expr,\n-                     op: ast::UnOp,\n-                     sub_expr: &ast::Expr)\n-                     -> DatumBlock<'a, Expr> {\n+fn trans_unary<'a>(bcx: &'a Block<'a>,\n+                   expr: &ast::Expr,\n+                   op: ast::UnOp,\n+                   sub_expr: &ast::Expr)\n+                   -> DatumBlock<'a, Expr> {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n-    let overloaded = {\n-        let method_map = bcx.ccx().maps.method_map.borrow();\n-        method_map.get().contains_key(&un_expr.id)\n-    };\n+    let method_call = MethodCall::expr(expr.id);\n+    let overloaded = bcx.ccx().maps.method_map.borrow().get().contains_key(&method_call);\n     // if overloaded, would be RvalueDpsExpr\n     assert!(!overloaded || op == ast::UnDeref);\n \n-    let un_ty = expr_ty(bcx, un_expr);\n+    let un_ty = expr_ty(bcx, expr);\n \n-    return match op {\n+    match op {\n         ast::UnNot => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n             let llresult = if ty::type_is_bool(un_ty) {\n@@ -1218,15 +1201,10 @@ fn trans_unary_datum<'a>(\n             trans_boxed_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr), heap_exchange)\n         }\n         ast::UnDeref => {\n-            if overloaded {\n-                let r = trans_overloaded_op(bcx, un_expr, sub_expr, None, None);\n-                DatumBlock(r.bcx, Datum(r.val, un_ty, LvalueExpr))\n-            } else {\n-                let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-                deref_once(bcx, un_expr, datum, 0)\n-            }\n+            let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n+            deref_once(bcx, expr, datum, 0)\n         }\n-    };\n+    }\n }\n \n fn trans_boxed_expr<'a>(bcx: &'a Block<'a>,\n@@ -1451,41 +1429,43 @@ fn trans_lazy_binop<'a>(\n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n }\n \n-fn trans_binary<'a>(\n-                bcx: &'a Block<'a>,\n-                binop_expr: &ast::Expr,\n-                op: ast::BinOp,\n-                lhs: &ast::Expr,\n-                rhs: &ast::Expr)\n-                -> DatumBlock<'a, Expr> {\n+fn trans_binary<'a>(bcx: &'a Block<'a>,\n+                    expr: &ast::Expr,\n+                    op: ast::BinOp,\n+                    lhs: &ast::Expr,\n+                    rhs: &ast::Expr)\n+                    -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_binary\");\n     let ccx = bcx.ccx();\n \n+    // if overloaded, would be RvalueDpsExpr\n+    assert!(!ccx.maps.method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)));\n+\n     match op {\n         ast::BiAnd => {\n-            trans_lazy_binop(bcx, binop_expr, lazy_and, lhs, rhs)\n+            trans_lazy_binop(bcx, expr, lazy_and, lhs, rhs)\n         }\n         ast::BiOr => {\n-            trans_lazy_binop(bcx, binop_expr, lazy_or, lhs, rhs)\n+            trans_lazy_binop(bcx, expr, lazy_or, lhs, rhs)\n         }\n         _ => {\n             let mut bcx = bcx;\n             let lhs_datum = unpack_datum!(bcx, trans(bcx, lhs));\n             let rhs_datum = unpack_datum!(bcx, trans(bcx, rhs));\n-            let binop_ty = expr_ty(bcx, binop_expr);\n+            let binop_ty = expr_ty(bcx, expr);\n \n             debug!(\"trans_binary (expr {}): lhs_datum={}\",\n-                   binop_expr.id,\n+                   expr.id,\n                    lhs_datum.to_str(ccx));\n             let lhs_ty = lhs_datum.ty;\n             let lhs = lhs_datum.to_llscalarish(bcx);\n \n             debug!(\"trans_binary (expr {}): rhs_datum={}\",\n-                   binop_expr.id,\n+                   expr.id,\n                    rhs_datum.to_str(ccx));\n             let rhs_ty = rhs_datum.ty;\n             let rhs = rhs_datum.to_llscalarish(bcx);\n-            trans_eager_binop(bcx, binop_expr, binop_ty, op,\n+            trans_eager_binop(bcx, expr, binop_ty, op,\n                               lhs_ty, lhs, rhs_ty, rhs)\n         }\n     }\n@@ -1494,21 +1474,22 @@ fn trans_binary<'a>(\n fn trans_overloaded_op<'a, 'b>(\n                        bcx: &'a Block<'a>,\n                        expr: &ast::Expr,\n-                       rcvr: &'b ast::Expr,\n-                       arg: Option<&'b ast::Expr>,\n+                       method_call: MethodCall,\n+                       lhs: Datum<Expr>,\n+                       rhs: Option<(Datum<Expr>, ast::NodeId)>,\n                        dest: Option<Dest>)\n                        -> Result<'a> {\n-    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&expr.id).ty;\n+    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n                              monomorphize_type(bcx, method_ty),\n                              |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n-                                                          expr.id,\n-                                                          rcvr,\n+                                                          method_call,\n+                                                          None,\n                                                           arg_cleanup_scope)\n                              },\n-                             callee::ArgAutorefSecond(rcvr, arg),\n+                             callee::ArgOverloadedOp(lhs, rhs),\n                              dest)\n }\n \n@@ -1666,10 +1647,7 @@ fn trans_assign_op<'a>(\n     debug!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!({\n-            let method_map = bcx.ccx().maps.method_map.borrow();\n-            !method_map.get().find(&expr.id).is_some()\n-        });\n+    assert!(!bcx.ccx().maps.method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n@@ -1748,6 +1726,30 @@ fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a, Expr> {\n     immediate_rvalue_bcx(bcx, Load(bcx, global), ty::mk_u32()).to_expr_datumblock()\n }\n \n+fn auto_ref<'a>(bcx: &'a Block<'a>,\n+                datum: Datum<Expr>,\n+                expr: &ast::Expr)\n+                -> DatumBlock<'a, Expr> {\n+    let mut bcx = bcx;\n+\n+    // Ensure cleanup of `datum` if not already scheduled and obtain\n+    // a \"by ref\" pointer.\n+    let lv_datum = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"autoref\", expr.id));\n+\n+    // Compute final type. Note that we are loose with the region and\n+    // mutability, since those things don't matter in trans.\n+    let referent_ty = lv_datum.ty;\n+    let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic, referent_ty);\n+\n+    // Get the pointer.\n+    let llref = lv_datum.to_llref();\n+\n+    // Construct the resulting datum, using what was the \"by ref\"\n+    // ValueRef of type `referent_ty` to be the \"by value\" ValueRef\n+    // of type `&referent_ty`.\n+    DatumBlock(bcx, Datum(llref, ptr_ty, RvalueExpr(Rvalue(ByValue))))\n+}\n+\n fn deref_multiple<'a>(bcx: &'a Block<'a>,\n                       expr: &ast::Expr,\n                       datum: Datum<Expr>,\n@@ -1777,6 +1779,28 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     let mut bcx = bcx;\n \n+    let method_call = MethodCall {\n+        expr_id: expr.id,\n+        autoderef: derefs as u32\n+    };\n+    let method_ty = ccx.maps.method_map.borrow().get()\n+                       .find(&method_call).map(|method| method.ty);\n+    let datum = match method_ty {\n+        Some(method_ty) => {\n+            let datum = if derefs == 0 {\n+                datum\n+            } else {\n+                // Always perform an AutoPtr when applying an overloaded auto-deref.\n+                unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n+            };\n+            let val = unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n+                                                              datum, None, None));\n+            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n+            Datum(val, ref_ty, RvalueExpr(Rvalue(ByValue)))\n+        }\n+        None => datum\n+    };\n+\n     let r = match ty::get(datum.ty).sty {\n         ty::ty_uniq(content_ty) => {\n             deref_owned_pointer(bcx, expr, datum, content_ty)\n@@ -1805,55 +1829,6 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             DatumBlock(bcx, Datum(ptr, content_ty, LvalueExpr))\n         }\n \n-        ty::ty_enum(..) |\n-        ty::ty_struct(..) => {\n-            // Subtle efficiency note: In the case where we have a\n-            // newtype struct where the struct itself does not have a\n-            // dtor, but the contents do, we could avoid forcing the\n-            // data into Lvalue and instead return an Rvalue. But it\n-            // doesn't seem worth the trouble.\n-            let datum = unpack_datum!(bcx, ensure_cleanup(bcx, expr, datum));\n-\n-            // Unlike the pointer case above, we generate an\n-            // rvalue datum if we are given an rvalue. There are\n-            // two reasons that this makes sense here:\n-            //\n-            // 1. dereferencing a struct does not actually perform a\n-            //    pointer load and hence the resulting value is not\n-            //    naturally by reference, as would be required by an\n-            //    lvalue result.\n-            //\n-            // 2. the struct always owns its contents, and hence and does not\n-            //    itself have a dtor (else it would be in lvalue mode).\n-            let repr = adt::represent_type(ccx, datum.ty);\n-            let ty = adt::deref_ty(ccx, repr);\n-            let Datum { val, kind, .. } = datum;\n-            let r = match kind {\n-                LvalueExpr => {\n-                    Datum {\n-                        val: adt::trans_field_ptr(bcx, repr, val, 0, 0),\n-                        ty: ty,\n-                        kind: LvalueExpr\n-                    }\n-                }\n-                RvalueExpr(Rvalue { mode: ByRef }) => {\n-                    Datum {\n-                        val: adt::trans_field_ptr(bcx, repr, val, 0, 0),\n-                        ty: ty,\n-                        kind: RvalueExpr(Rvalue(ByValue))\n-                    }\n-                }\n-                RvalueExpr(Rvalue { mode: ByValue }) => {\n-                    Datum {\n-                        val: ExtractValue(bcx, val, 0),\n-                        ty: ty,\n-                        kind: RvalueExpr(Rvalue(ByValue))\n-                    }\n-                }\n-            };\n-            DatumBlock(bcx, r)\n-        }\n-\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n@@ -1867,25 +1842,6 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     return r;\n \n-    fn ensure_cleanup<'a>(mut bcx: &'a Block<'a>,\n-                          expr: &ast::Expr,\n-                          datum: Datum<Expr>)\n-                          -> DatumBlock<'a, Expr> {\n-        /*!\n-         * If the datum contains data that needs to be dropped,\n-         * convert it to an lvalue, thus ensuring that cleanup\n-         * is scheduled.\n-         */\n-\n-        if ty::type_needs_drop(bcx.tcx(), datum.ty) {\n-            let lv_datum = unpack_datum!(\n-                bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n-            DatumBlock(bcx, lv_datum.to_expr_datum())\n-        } else {\n-            DatumBlock(bcx, datum)\n-        }\n-    }\n-\n     fn deref_owned_pointer<'a>(bcx: &'a Block<'a>,\n                                expr: &ast::Expr,\n                                datum: Datum<Expr>,"}, {"sha": "b3d69043d33e397ddcda5506d3cbba927416bfa9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -29,6 +29,7 @@ use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n use middle::typeck;\n+use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n@@ -93,29 +94,30 @@ pub fn trans_method(ccx: @CrateContext, method: &ast::Method,\n \n pub fn trans_method_callee<'a>(\n                            bcx: &'a Block<'a>,\n-                           expr_id: ast::NodeId,\n-                           this: &ast::Expr,\n+                           method_call: MethodCall,\n+                           self_expr: Option<&ast::Expr>,\n                            arg_cleanup_scope: cleanup::ScopeId)\n                            -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n     let (origin, method_ty) = match bcx.ccx().maps.method_map\n-                                       .borrow().get().find(&expr_id) {\n+                                       .borrow().get().find(&method_call) {\n         Some(method) => {\n-            debug!(\"trans_method_callee(expr_id={:?}, method={})\",\n-                expr_id, method.repr(bcx.tcx()));\n+            debug!(\"trans_method_callee({:?}, method={})\",\n+                   method_call, method.repr(bcx.tcx()));\n             (method.origin, method.ty)\n         }\n         None => {\n-            bcx.tcx().sess.span_bug(this.span, \"method call expr wasn't in method map\")\n+            bcx.tcx().sess.span_bug(bcx.tcx().map.span(method_call.expr_id),\n+                                    \"method call expr wasn't in method map\")\n         }\n     };\n \n     match origin {\n         typeck::MethodStatic(did) => {\n             Callee {\n                 bcx: bcx,\n-                data: Fn(callee::trans_fn_ref(bcx, did, expr_id, true))\n+                data: Fn(callee::trans_fn_ref(bcx, did, MethodCall(method_call)))\n             }\n         }\n         typeck::MethodParam(typeck::MethodParam {\n@@ -131,7 +133,7 @@ pub fn trans_method_callee<'a>(\n                         trait_id);\n \n                     let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n-                    trans_monomorphized_callee(bcx, expr_id,\n+                    trans_monomorphized_callee(bcx, method_call,\n                                                trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n@@ -140,10 +142,18 @@ pub fn trans_method_callee<'a>(\n         }\n \n         typeck::MethodObject(ref mt) => {\n+            let self_expr = match self_expr {\n+                Some(self_expr) => self_expr,\n+                None => {\n+                    bcx.tcx().sess.span_bug(bcx.tcx().map.span(method_call.expr_id),\n+                                            \"self expr wasn't provided for trait object \\\n+                                            callee (trying to call overloaded op?)\")\n+                }\n+            };\n             trans_trait_callee(bcx,\n                                monomorphize_type(bcx, method_ty),\n                                mt.real_index,\n-                               this,\n+                               self_expr,\n                                arg_cleanup_scope)\n         }\n     }\n@@ -209,13 +219,10 @@ pub fn trans_static_method_callee(bcx: &Block,\n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n-                    bcx, mth_id, expr_id, false,\n+                    bcx, mth_id, ExprId(expr_id),\n                     rcvr_substs.as_slice(), rcvr_origins);\n \n-            let llfn = trans_fn_ref_with_vtables(bcx,\n-                                                 mth_id,\n-                                                 expr_id,\n-                                                 false,\n+            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, ExprId(expr_id),\n                                                  callee_substs.as_slice(),\n                                                  Some(callee_origins));\n \n@@ -254,7 +261,7 @@ pub fn method_with_name(ccx: &CrateContext,\n }\n \n fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n-                                  expr_id: ast::NodeId,\n+                                  method_call: MethodCall,\n                                   trait_id: ast::DefId,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n@@ -270,14 +277,13 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           // those from the impl and those from the method:\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n-                  bcx, mth_id, expr_id, true,\n+                  bcx, mth_id,  MethodCall(method_call),\n                   rcvr_substs.as_slice(), rcvr_origins);\n \n           // translate the function\n           let llfn = trans_fn_ref_with_vtables(bcx,\n                                                mth_id,\n-                                               expr_id,\n-                                               true,\n+                                               MethodCall(method_call),\n                                                callee_substs.as_slice(),\n                                                Some(callee_origins));\n \n@@ -291,8 +297,7 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n \n fn combine_impl_and_methods_tps(bcx: &Block,\n                                 mth_did: ast::DefId,\n-                                expr_id: ast::NodeId,\n-                                is_method: bool,\n+                                node: ExprOrMethodCall,\n                                 rcvr_substs: &[ty::t],\n                                 rcvr_origins: typeck::vtable_res)\n                                 -> (Vec<ty::t> , typeck::vtable_res) {\n@@ -316,7 +321,7 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     let ccx = bcx.ccx();\n     let method = ty::method(ccx.tcx, mth_did);\n     let n_m_tps = method.generics.type_param_defs().len();\n-    let node_substs = node_id_type_params(bcx, expr_id, is_method);\n+    let node_substs = node_id_type_params(bcx, node);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n         = vec_ng::append(Vec::from_slice(rcvr_substs),\n@@ -328,7 +333,14 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n \n     // Now, do the same work for the vtables.  The vtables might not\n     // exist, in which case we need to make them.\n-    let r_m_origins = match node_vtables(bcx, expr_id) {\n+    let vtables = match node {\n+        ExprId(id) => node_vtables(bcx, id),\n+        MethodCall(method_call) if method_call.autoderef == 0 => {\n+            node_vtables(bcx, method_call.expr_id)\n+        }\n+        _ => None\n+    };\n+    let r_m_origins = match vtables {\n         Some(vt) => vt,\n         None => @Vec::from_elem(node_substs.len(), @Vec::new())\n     };\n@@ -555,7 +567,7 @@ fn emit_vtable_methods(bcx: &Block,\n                    token::get_ident(ident));\n             C_null(Type::nil().ptr_to())\n         } else {\n-            trans_fn_ref_with_vtables(bcx, m_id, 0, false, substs, Some(vtables))\n+            trans_fn_ref_with_vtables(bcx, m_id, ExprId(0), substs, Some(vtables))\n         }\n     })\n }"}, {"sha": "33b246539341b3ff210730c75aef95e73f6d8108", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 45, "deletions": 76, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -23,14 +23,15 @@ use middle::resolve_lifetime;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n+use middle::typeck::{MethodCall, MethodCallee, MethodMap};\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n \n use std::cast;\n use std::cell::{Cell, RefCell};\n@@ -258,10 +259,7 @@ pub struct ctxt_ {\n     diag: @syntax::diagnostic::SpanHandler,\n     // Specifically use a speedy hash algorithm for this hash map, it's used\n     // quite often.\n-    #[cfg(stage0)]\n-    interner: RefCell<HashMap<intern_key, ~t_box_>>,\n-    #[cfg(not(stage0))]\n-    interner: RefCell<HashMap<intern_key, ~t_box_, ::util::nodemap::FnvHasher>>,\n+    interner: RefCell<FnvHashMap<intern_key, ~t_box_>>,\n     next_id: Cell<uint>,\n     cstore: @metadata::cstore::CStore,\n     sess: session::Session,\n@@ -1091,19 +1089,11 @@ pub fn mk_ctxt(s: session::Session,\n                region_maps: middle::region::RegionMaps,\n                lang_items: @middle::lang_items::LanguageItems)\n             -> ctxt {\n-    #[cfg(stage0)]\n-    fn hasher() -> HashMap<intern_key, ~t_box_> {\n-        HashMap::new()\n-    }\n-    #[cfg(not(stage0))]\n-    fn hasher() -> HashMap<intern_key, ~t_box_, ::util::nodemap::FnvHasher> {\n-        HashMap::with_hasher(::util::nodemap::FnvHasher)\n-    }\n     @ctxt_ {\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         diag: s.diagnostic(),\n-        interner: RefCell::new(hasher()),\n+        interner: RefCell::new(FnvHashMap::new()),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         cstore: s.cstore,\n         sess: s,\n@@ -2710,50 +2700,23 @@ pub fn type_param(ty: t) -> Option<uint> {\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n pub fn deref(t: t, explicit: bool) -> Option<mt> {\n-    deref_sty(&get(t).sty, explicit)\n-}\n-\n-pub fn deref_sty(sty: &sty, explicit: bool) -> Option<mt> {\n-    match *sty {\n-        ty_box(typ) | ty_uniq(typ) => {\n-            Some(mt {\n-                ty: typ,\n-                mutbl: ast::MutImmutable,\n-            })\n-        }\n-\n-        ty_rptr(_, mt) => {\n-            Some(mt)\n-        }\n-\n-        ty_ptr(mt) if explicit => {\n-            Some(mt)\n-        }\n-\n+    match get(t).sty {\n+        ty_box(typ) | ty_uniq(typ) => Some(mt {\n+            ty: typ,\n+            mutbl: ast::MutImmutable,\n+        }),\n+        ty_rptr(_, mt) => Some(mt),\n+        ty_ptr(mt) if explicit => Some(mt),\n         _ => None\n     }\n }\n \n-pub fn type_autoderef(t: t) -> t {\n-    let mut t = t;\n-    loop {\n-        match deref(t, false) {\n-          None => return t,\n-          Some(mt) => t = mt.ty\n-        }\n-    }\n-}\n-\n // Returns the type and mutability of t[i]\n pub fn index(t: t) -> Option<mt> {\n-    index_sty(&get(t).sty)\n-}\n-\n-pub fn index_sty(sty: &sty) -> Option<mt> {\n-    match *sty {\n-      ty_vec(mt, _) => Some(mt),\n-      ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n-      _ => None\n+    match get(t).sty {\n+        ty_vec(mt, _) => Some(mt),\n+        ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n+        _ => None\n     }\n }\n \n@@ -2964,7 +2927,10 @@ pub fn expr_ty_opt(cx: ctxt, expr: &ast::Expr) -> Option<t> {\n     return node_id_to_type_opt(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n+pub fn expr_ty_adjusted(cx: ctxt,\n+                        expr: &ast::Expr,\n+                        method_map: &FnvHashMap<MethodCall, MethodCallee>)\n+                        -> t {\n     /*!\n      *\n      * Returns the type of `expr`, considering any `AutoAdjustment`\n@@ -2979,11 +2945,10 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n      */\n \n     let unadjusted_ty = expr_ty(cx, expr);\n-    let adjustment = {\n-        let adjustments = cx.adjustments.borrow();\n-        adjustments.get().find_copy(&expr.id)\n-    };\n-    adjust_ty(cx, expr.span, unadjusted_ty, adjustment)\n+    let adjustment = cx.adjustments.borrow().get().find_copy(&expr.id);\n+    adjust_ty(cx, expr.span, expr.id, unadjusted_ty, adjustment, |method_call| {\n+        method_map.find(&method_call).map(|method| method.ty)\n+    })\n }\n \n pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n@@ -3026,14 +2991,14 @@ pub fn local_var_name_str(cx: ctxt, id: NodeId) -> InternedString {\n \n pub fn adjust_ty(cx: ctxt,\n                  span: Span,\n+                 expr_id: ast::NodeId,\n                  unadjusted_ty: ty::t,\n-                 adjustment: Option<@AutoAdjustment>)\n+                 adjustment: Option<@AutoAdjustment>,\n+                 method_type: |MethodCall| -> Option<ty::t>)\n                  -> ty::t {\n     /*! See `expr_ty_adjusted` */\n \n     return match adjustment {\n-        None => unadjusted_ty,\n-\n         Some(adjustment) => {\n             match *adjustment {\n                 AutoAddEnv(r, s) => {\n@@ -3062,7 +3027,13 @@ pub fn adjust_ty(cx: ctxt,\n \n                     if !ty::type_is_error(adjusted_ty) {\n                         for i in range(0, adj.autoderefs) {\n-                            match ty::deref(adjusted_ty, true) {\n+                            match method_type(MethodCall::autoderef(expr_id, i as u32)) {\n+                                Some(method_ty) => {\n+                                    adjusted_ty = ty_fn_ret(method_ty);\n+                                }\n+                                None => {}\n+                            }\n+                            match deref(adjusted_ty, true) {\n                                 Some(mt) => { adjusted_ty = mt.ty; }\n                                 None => {\n                                     cx.sess.span_bug(\n@@ -3130,6 +3101,7 @@ pub fn adjust_ty(cx: ctxt,\n                 }\n             }\n         }\n+        None => unadjusted_ty\n     };\n \n     fn borrow_vec(cx: ctxt, span: Span,\n@@ -3274,7 +3246,7 @@ pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n }\n \n pub fn expr_is_lval(tcx: ctxt,\n-                    method_map: typeck::MethodMap,\n+                    method_map: MethodMap,\n                     e: &ast::Expr) -> bool {\n     match expr_kind(tcx, method_map, e) {\n         LvalueExpr => true,\n@@ -3295,20 +3267,17 @@ pub enum ExprKind {\n }\n \n pub fn expr_kind(tcx: ctxt,\n-                 method_map: typeck::MethodMap,\n+                 method_map: MethodMap,\n                  expr: &ast::Expr) -> ExprKind {\n-    {\n-        let method_map = method_map.borrow();\n-        if method_map.get().contains_key(&expr.id) {\n-            // Overloaded operations are generally calls, and hence they are\n-            // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n-            // exception, as its result is always unit.\n-            return match expr.node {\n-                ast::ExprAssignOp(..) => RvalueStmtExpr,\n-                ast::ExprUnary(ast::UnDeref, _) => LvalueExpr,\n-                _ => RvalueDpsExpr\n-            };\n-        }\n+    if method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)) {\n+        // Overloaded operations are generally calls, and hence they are\n+        // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n+        // exception, as its result is always unit.\n+        return match expr.node {\n+            ast::ExprAssignOp(..) => RvalueStmtExpr,\n+            ast::ExprUnary(ast::UnDeref, _) => LvalueExpr,\n+            _ => RvalueDpsExpr\n+        };\n     }\n \n     match expr.node {"}, {"sha": "89658b32be89a9764b23b2dd49000e163ca89c95", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 155, "deletions": 148, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -84,9 +84,7 @@ use middle::subst::Subst;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n-use middle::typeck::check::{FnCtxt, impl_self_ty};\n-use middle::typeck::check::{structurally_resolved_type};\n-use middle::typeck::check::vtable;\n+use middle::typeck::check::{FnCtxt, PreferMutLvalue, impl_self_ty};\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n@@ -106,6 +104,7 @@ use syntax::ast::{DefId, SelfValue, SelfRegion};\n use syntax::ast::{SelfUniq, SelfStatic};\n use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n+use syntax::codemap::Span;\n use syntax::parse::token;\n \n #[deriving(Eq)]\n@@ -120,23 +119,23 @@ pub enum AutoderefReceiverFlag {\n     DontAutoderefReceiver,\n }\n \n-pub fn lookup(\n+pub fn lookup<'a>(\n         fcx: @FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: &ast::Expr,                   // The expression `a.b(...)`.\n-        self_expr: &ast::Expr,              // The expression `a`.\n+        self_expr: &'a ast::Expr,           // The expression `a`.\n         m_name: ast::Name,                  // The name `b`.\n         self_ty: ty::t,                     // The type of `a`.\n-        supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n+        supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<MethodCallee> {\n     let lcx = LookupContext {\n         fcx: fcx,\n-        expr: expr,\n-        self_expr: self_expr,\n+        span: expr.span,\n+        self_expr: Some(self_expr),\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: @RefCell::new(HashSet::new()),\n@@ -147,7 +146,6 @@ pub fn lookup(\n         autoderef_receiver: autoderef_receiver,\n     };\n \n-    let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n     debug!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n            self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n@@ -162,25 +160,25 @@ pub fn lookup(\n     debug!(\"searching extension candidates\");\n     lcx.reset_candidates();\n     lcx.push_bound_candidates(self_ty, None);\n-    lcx.push_extension_candidates();\n+    lcx.push_extension_candidates(expr.id);\n     return lcx.search(self_ty);\n }\n \n-pub fn lookup_in_trait(\n+pub fn lookup_in_trait<'a>(\n         fcx: @FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: &ast::Expr,                   // The expression `a.b(...)`.\n-        self_expr: &ast::Expr,              // The expression `a`.\n+        span: Span,                         // The expression `a.b(...)`'s span.\n+        self_expr: Option<&'a ast::Expr>,   // The expression `a`, if available.\n         m_name: ast::Name,                  // The name `b`.\n         trait_did: DefId,                   // The trait to limit the lookup to.\n         self_ty: ty::t,                     // The type of `a`.\n-        supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n+        supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<MethodCallee> {\n     let lcx = LookupContext {\n         fcx: fcx,\n-        expr: expr,\n+        span: span,\n         self_expr: self_expr,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n@@ -192,20 +190,18 @@ pub fn lookup_in_trait(\n         autoderef_receiver: autoderef_receiver,\n     };\n \n-    let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n-    debug!(\"method lookup_in_trait(self_ty={}, expr={}, self_expr={})\",\n-           self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n-           self_expr.repr(fcx.tcx()));\n+    debug!(\"method lookup_in_trait(self_ty={}, self_expr={})\",\n+           self_ty.repr(fcx.tcx()), self_expr.map(|e| e.repr(fcx.tcx())));\n \n     lcx.push_bound_candidates(self_ty, Some(trait_did));\n     lcx.push_extension_candidate(trait_did);\n     lcx.search(self_ty)\n }\n \n-pub struct LookupContext<'a> {\n+struct LookupContext<'a> {\n     fcx: @FnCtxt,\n-    expr: &'a ast::Expr,\n-    self_expr: &'a ast::Expr,\n+    span: Span,\n+    self_expr: Option<&'a ast::Expr>,\n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n     impl_dups: @RefCell<HashSet<DefId>>,\n@@ -221,7 +217,7 @@ pub struct LookupContext<'a> {\n  * is of a suitable type.\n  */\n #[deriving(Clone)]\n-pub struct Candidate {\n+struct Candidate {\n     rcvr_match_condition: RcvrMatchCondition,\n     rcvr_substs: ty::substs,\n     method_ty: @ty::Method,\n@@ -244,67 +240,51 @@ pub enum RcvrMatchCondition {\n \n impl<'a> LookupContext<'a> {\n     fn search(&self, self_ty: ty::t) -> Option<MethodCallee> {\n-        let mut self_ty = self_ty;\n-        let mut autoderefs = 0;\n-        loop {\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        let self_expr_id = self.self_expr.map(|e| e.id);\n+        let (self_ty, autoderefs, result) =\n+            check::autoderef(self.fcx, span, self_ty, self_expr_id,\n+                             PreferMutLvalue, |self_ty, autoderefs| {\n+\n             debug!(\"loop: self_ty={} autoderefs={}\",\n                    self.ty_to_str(self_ty), autoderefs);\n \n             match self.deref_args {\n                 check::DontDerefArgs => {\n-                    match self.search_for_autoderefd_method(self_ty,\n-                                                            autoderefs) {\n-                        Some(mme) => { return Some(mme); }\n+                    match self.search_for_autoderefd_method(self_ty, autoderefs) {\n+                        Some(result) => return Some(Some(result)),\n                         None => {}\n                     }\n \n-                    match self.search_for_autoptrd_method(self_ty,\n-                                                          autoderefs) {\n-                        Some(mme) => { return Some(mme); }\n+                    match self.search_for_autoptrd_method(self_ty, autoderefs) {\n+                        Some(result) => return Some(Some(result)),\n                         None => {}\n                     }\n                 }\n                 check::DoDerefArgs => {\n-                    match self.search_for_autoptrd_method(self_ty,\n-                                                          autoderefs) {\n-                        Some(mme) => { return Some(mme); }\n+                    match self.search_for_autoptrd_method(self_ty, autoderefs) {\n+                        Some(result) => return Some(Some(result)),\n                         None => {}\n                     }\n \n-                    match self.search_for_autoderefd_method(self_ty,\n-                                                            autoderefs) {\n-                        Some(mme) => { return Some(mme); }\n+                    match self.search_for_autoderefd_method(self_ty, autoderefs) {\n+                        Some(result) => return Some(Some(result)),\n                         None => {}\n                     }\n                 }\n             }\n \n             // Don't autoderef if we aren't supposed to.\n             if self.autoderef_receiver == DontAutoderefReceiver {\n-                break;\n-            }\n-\n-            // Otherwise, perform autoderef.\n-            match self.deref(self_ty) {\n-                None => { break; }\n-                Some(ty) => {\n-                    self_ty = ty;\n-                    autoderefs += 1;\n-                }\n+                Some(None)\n+            } else {\n+                None\n             }\n-        }\n-\n-        self.search_for_autosliced_method(self_ty, autoderefs)\n-    }\n+        });\n \n-    fn deref(&self, ty: ty::t) -> Option<ty::t> {\n-        match ty::deref(ty, false) {\n-            None => None,\n-            Some(t) => {\n-                Some(structurally_resolved_type(self.fcx,\n-                                                self.self_expr.span,\n-                                                t.ty))\n-            }\n+        match result {\n+            Some(Some(result)) => Some(result),\n+            _ => self.search_for_autosliced_method(self_ty, autoderefs)\n         }\n     }\n \n@@ -326,8 +306,8 @@ impl<'a> LookupContext<'a> {\n          * we'll want to find the inherent impls for `C`.\n          */\n \n-        let mut self_ty = self_ty;\n-        loop {\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n                 ty_trait(did, ref substs, _, _, _) => {\n                     self.push_inherent_candidates_from_object(did, substs);\n@@ -341,19 +321,18 @@ impl<'a> LookupContext<'a> {\n                 _ => { /* No inherent methods in these types */ }\n             }\n \n-            // n.b.: Generally speaking, we only loop if we hit the\n-            // fallthrough case in the match above.  The exception\n-            // would be newtype enums.\n-            self_ty = match self.deref(self_ty) {\n-                None => { return; }\n-                Some(ty) => { ty }\n+            // Don't autoderef if we aren't supposed to.\n+            if self.autoderef_receiver == DontAutoderefReceiver {\n+                Some(())\n+            } else {\n+                None\n             }\n-        }\n+        });\n     }\n \n     fn push_bound_candidates(&self, self_ty: ty::t, restrict_to: Option<DefId>) {\n-        let mut self_ty = self_ty;\n-        loop {\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n@@ -366,11 +345,13 @@ impl<'a> LookupContext<'a> {\n                 _ => { /* No bound methods in these types */ }\n             }\n \n-            self_ty = match self.deref(self_ty) {\n-                None => { return; }\n-                Some(ty) => { ty }\n+            // Don't autoderef if we aren't supposed to.\n+            if self.autoderef_receiver == DontAutoderefReceiver {\n+                Some(())\n+            } else {\n+                None\n             }\n-        }\n+        });\n     }\n \n     fn push_extension_candidate(&self, trait_did: DefId) {\n@@ -386,11 +367,11 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn push_extension_candidates(&self) {\n+    fn push_extension_candidates(&self, expr_id: ast::NodeId) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.find(&self.expr.id);\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.find(&expr_id);\n         for applicable_traits in opt_applicable_traits.move_iter() {\n             for trait_did in applicable_traits.iter() {\n                 self.push_extension_candidate(*trait_did);\n@@ -591,8 +572,8 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn push_candidates_from_impl(&self,\n-                                     candidates: &mut Vec<Candidate> ,\n-                                     impl_info: &ty::Impl) {\n+                                 candidates: &mut Vec<Candidate>,\n+                                 impl_info: &ty::Impl) {\n         {\n             let mut impl_dups = self.impl_dups.borrow_mut();\n             if !impl_dups.get().insert(impl_info.did) {\n@@ -619,12 +600,12 @@ impl<'a> LookupContext<'a> {\n \n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n-        let location_info = &vtable::location_info_for_expr(self.self_expr);\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n         let vcx = self.fcx.vtable_context();\n         let ty::ty_param_substs_and_ty {\n             substs: impl_substs,\n             ty: impl_ty\n-        } = impl_self_ty(&vcx, location_info, impl_info.did);\n+        } = impl_self_ty(&vcx, span, impl_info.did);\n \n         candidates.push(Candidate {\n             rcvr_match_condition: RcvrMatchesIfSubtype(impl_ty),\n@@ -638,28 +619,45 @@ impl<'a> LookupContext<'a> {\n     // Candidate selection (see comment at start of file)\n \n     fn search_for_autoderefd_method(&self,\n-                                        self_ty: ty::t,\n-                                        autoderefs: uint)\n-                                        -> Option<MethodCallee> {\n-        let (self_ty, autoadjust) =\n+                                    self_ty: ty::t,\n+                                    autoderefs: uint)\n+                                    -> Option<MethodCallee> {\n+        let (self_ty, auto_deref_ref) =\n             self.consider_reborrow(self_ty, autoderefs);\n+\n+        // HACK(eddyb) only overloaded auto-deref calls should be missing\n+        // adjustments, because we imply an AutoPtr adjustment for them.\n+        let adjustment = match auto_deref_ref {\n+            ty::AutoDerefRef {\n+                autoderefs: 0,\n+                autoref: Some(ty::AutoPtr(..))\n+            } => None,\n+            _ => match self.self_expr {\n+                Some(expr) => Some((expr.id, @ty::AutoDerefRef(auto_deref_ref))),\n+                None => return None\n+            }\n+        };\n+\n         match self.search_for_method(self_ty) {\n             None => None,\n-            Some(mme) => {\n+            Some(method) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment ({}) to {}\",\n-                       autoderefs,\n-                       self.self_expr.id);\n-                self.fcx.write_adjustment(self.self_expr.id, @autoadjust);\n-                Some(mme)\n+                       adjustment {:?}\", adjustment);\n+                match adjustment {\n+                    Some((self_expr_id, adj)) => {\n+                        self.fcx.write_adjustment(self_expr_id, adj);\n+                    }\n+                    None => {}\n+                }\n+                Some(method)\n             }\n         }\n     }\n \n     fn consider_reborrow(&self,\n-                             self_ty: ty::t,\n-                             autoderefs: uint)\n-                             -> (ty::t, ty::AutoAdjustment) {\n+                         self_ty: ty::t,\n+                         autoderefs: uint)\n+                         -> (ty::t, ty::AutoDerefRef) {\n         /*!\n          * In the event that we are invoking a method with a receiver\n          * of a borrowed type like `&T`, `&mut T`, or `&mut [T]`,\n@@ -681,44 +679,41 @@ impl<'a> LookupContext<'a> {\n         return match ty::get(self_ty).sty {\n             ty::ty_rptr(_, self_mt) if default_method_hack(self_mt) => {\n                 (self_ty,\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: None}))\n+                     autoref: None})\n             }\n             ty::ty_rptr(_, self_mt) => {\n                 let region =\n-                    self.infcx().next_region_var(\n-                        infer::Autoref(self.expr.span));\n+                    self.infcx().next_region_var(infer::Autoref(self.span));\n                 (ty::mk_rptr(tcx, region, self_mt),\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs+1,\n-                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl))}))\n+                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl))})\n             }\n             ty::ty_vec(self_mt, vstore_slice(_)) => {\n                 let region =\n-                    self.infcx().next_region_var(\n-                        infer::Autoref(self.expr.span));\n+                    self.infcx().next_region_var(infer::Autoref(self.span));\n                 (ty::mk_vec(tcx, self_mt, vstore_slice(region)),\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))}))\n+                     autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))})\n             }\n-            ty_trait(did, ref substs, ty::RegionTraitStore(_), mutbl, bounds) => {\n+            ty::ty_trait(did, ref substs, ty::RegionTraitStore(_), mutbl, bounds) => {\n                 let region =\n-                    self.infcx().next_region_var(\n-                        infer::Autoref(self.expr.span));\n+                    self.infcx().next_region_var(infer::Autoref(self.span));\n                 (ty::mk_trait(tcx, did, substs.clone(),\n                               ty::RegionTraitStore(region),\n                               mutbl, bounds),\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: Some(ty::AutoBorrowObj(region, mutbl))}))\n+                     autoref: Some(ty::AutoBorrowObj(region, mutbl))})\n             }\n             _ => {\n                 (self_ty,\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: None}))\n+                     autoref: None})\n             }\n         };\n \n@@ -848,30 +843,43 @@ impl<'a> LookupContext<'a> {\n             mutbls: &[ast::Mutability],\n             mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n             -> Option<MethodCallee> {\n+        // HACK(eddyb) only overloaded auto-deref calls should be missing\n+        // adjustments, because we imply an AutoPtr adjustment for them.\n+        let self_expr_id = match self.self_expr {\n+            Some(expr) => Some(expr.id),\n+            None => match kind(ty::ReEmpty, ast::MutImmutable) {\n+                ty::AutoPtr(..) if autoderefs == 0 => None,\n+                _ => return None\n+            }\n+        };\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region =\n-            self.infcx().next_region_var(\n-                infer::Autoref(self.expr.span));\n+            self.infcx().next_region_var(infer::Autoref(self.span));\n         for mutbl in mutbls.iter() {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n                 None => {}\n-                Some(mme) => {\n-                    self.fcx.write_adjustment(\n-                        self.self_expr.id,\n-                        @ty::AutoDerefRef(ty::AutoDerefRef {\n-                            autoderefs: autoderefs,\n-                            autoref: Some(kind(region, *mutbl))}));\n-                    return Some(mme);\n+                Some(method) => {\n+                    match self_expr_id {\n+                        Some(self_expr_id) => {\n+                            self.fcx.write_adjustment(\n+                                self_expr_id,\n+                                @ty::AutoDerefRef(ty::AutoDerefRef {\n+                                    autoderefs: autoderefs,\n+                                    autoref: Some(kind(region, *mutbl))\n+                                }));\n+                        }\n+                        None => {}\n+                    }\n+                    return Some(method);\n                 }\n             }\n         }\n-        return None;\n+        None\n     }\n \n-    fn search_for_method(&self, rcvr_ty: ty::t)\n-                         -> Option<MethodCallee> {\n+    fn search_for_method(&self, rcvr_ty: ty::t) -> Option<MethodCallee> {\n         debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n@@ -900,9 +908,8 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn consider_candidates(&self,\n-                           rcvr_ty: ty::t,\n-                           candidates: &mut Vec<Candidate> )\n+    fn consider_candidates(&self, rcvr_ty: ty::t,\n+                           candidates: &mut Vec<Candidate>)\n                            -> Option<MethodCallee> {\n         // FIXME(pcwalton): Do we need to clone here?\n         let relevant_candidates: Vec<Candidate> =\n@@ -918,7 +925,7 @@ impl<'a> LookupContext<'a> {\n \n         if relevant_candidates.len() > 1 {\n             self.tcx().sess.span_err(\n-                self.expr.span,\n+                self.span,\n                 \"multiple applicable methods in scope\");\n             for (idx, candidate) in relevant_candidates.iter().enumerate() {\n                 self.report_candidate(idx, &candidate.origin);\n@@ -986,8 +993,7 @@ impl<'a> LookupContext<'a> {\n \n         let tcx = self.tcx();\n \n-        debug!(\"confirm_candidate(expr={}, rcvr_ty={}, candidate={})\",\n-               self.expr.repr(tcx),\n+        debug!(\"confirm_candidate(rcvr_ty={}, candidate={})\",\n                self.ty_to_str(rcvr_ty),\n                candidate.repr(self.tcx()));\n \n@@ -1007,12 +1013,12 @@ impl<'a> LookupContext<'a> {\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_method_tps == 0u {\n                 tcx.sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"this method does not take type parameters\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_supplied_tps != num_method_tps {\n                 tcx.sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"incorrect number of type \\\n                      parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n@@ -1025,11 +1031,11 @@ impl<'a> LookupContext<'a> {\n         // FIXME -- permit users to manually specify lifetimes\n         let mut all_regions = match candidate.rcvr_substs.regions {\n             NonerasedRegions(ref v) => v.clone(),\n-            ErasedRegions => tcx.sess.span_bug(self.expr.span, \"ErasedRegions\")\n+            ErasedRegions => tcx.sess.span_bug(self.span, \"ErasedRegions\")\n         };\n         let m_regions =\n             self.fcx.infcx().region_vars_for_defs(\n-                self.expr.span,\n+                self.span,\n                 candidate.method_ty.generics.region_param_defs.deref().as_slice());\n         for &r in m_regions.iter() {\n             all_regions.push(r);\n@@ -1077,7 +1083,7 @@ impl<'a> LookupContext<'a> {\n         let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(\n             tcx, &fn_sig,\n             |br| self.fcx.infcx().next_region_var(\n-                infer::LateBoundRegion(self.expr.span, br)));\n+                infer::LateBoundRegion(self.span, br)));\n         let transformed_self_ty = *fn_sig.inputs.get(0);\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n@@ -1091,7 +1097,8 @@ impl<'a> LookupContext<'a> {\n         // variables to unify etc).  Since we checked beforehand, and\n         // nothing has changed in the meantime, this unification\n         // should never fail.\n-        match self.fcx.mk_subty(false, infer::Misc(self.self_expr.span),\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        match self.fcx.mk_subty(false, infer::Misc(span),\n                                 rcvr_ty, transformed_self_ty) {\n             result::Ok(_) => {}\n             result::Err(_) => {\n@@ -1112,8 +1119,7 @@ impl<'a> LookupContext<'a> {\n         &self,\n         trait_def_id: ast::DefId,\n         rcvr_substs: &ty::substs,\n-        method_ty: &ty::Method) -> ty::t\n-    {\n+        method_ty: &ty::Method) -> ty::t {\n         /*!\n          * This is a bit tricky. We have a match against a trait method\n          * being invoked on an object, and we want to generate the\n@@ -1140,7 +1146,7 @@ impl<'a> LookupContext<'a> {\n                                  tps: rcvr_substs.tps.clone()};\n         match method_ty.explicit_self {\n             ast::SelfStatic => {\n-                self.bug(~\"static method for object type receiver\");\n+                self.bug(\"static method for object type receiver\");\n             }\n             ast::SelfValue => {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n@@ -1187,14 +1193,14 @@ impl<'a> LookupContext<'a> {\n         match candidate.method_ty.explicit_self {\n             ast::SelfStatic => { // reason (a) above\n                 self.tcx().sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"cannot call a method without a receiver \\\n                      through an object\");\n             }\n \n             ast::SelfValue => { // reason (a) above\n                 self.tcx().sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"cannot call a method with a by-value receiver \\\n                      through an object\");\n             }\n@@ -1206,7 +1212,7 @@ impl<'a> LookupContext<'a> {\n         let check_for_self_ty = |ty| {\n             if ty::type_has_self(ty) {\n                 self.tcx().sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"cannot call a method whose type contains a \\\n                      self-type through an object\");\n                 true\n@@ -1228,7 +1234,7 @@ impl<'a> LookupContext<'a> {\n \n         if candidate.method_ty.generics.has_type_params() { // reason (b) above\n             self.tcx().sess.span_err(\n-                self.expr.span,\n+                self.span,\n                 \"cannot call a generic method through an object\");\n         }\n     }\n@@ -1253,7 +1259,7 @@ impl<'a> LookupContext<'a> {\n         }\n \n         if bad {\n-            self.tcx().sess.span_err(self.expr.span,\n+            self.tcx().sess.span_err(self.span,\n                                      \"explicit call to destructor\");\n         }\n     }\n@@ -1364,7 +1370,7 @@ impl<'a> LookupContext<'a> {\n         let span = if did.krate == ast::LOCAL_CRATE {\n             self.tcx().map.span(did.node)\n         } else {\n-            self.expr.span\n+            self.span\n         };\n         self.tcx().sess.span_note(\n             span,\n@@ -1375,15 +1381,15 @@ impl<'a> LookupContext<'a> {\n \n     fn report_param_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n-            self.expr.span,\n+            self.span,\n             format!(\"candidate \\\\#{} derives from the bound `{}`\",\n                  idx+1u,\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_trait_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n-            self.expr.span,\n+            self.span,\n             format!(\"candidate \\\\#{} derives from the type of the receiver, \\\n                   which is the trait `{}`\",\n                  idx+1u,\n@@ -1406,8 +1412,9 @@ impl<'a> LookupContext<'a> {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    fn bug(&self, s: ~str) -> ! {\n-        self.tcx().sess.span_bug(self.self_expr.span, s)\n+    fn bug(&self, s: &str) -> ! {\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        self.tcx().sess.span_bug(span, s)\n     }\n }\n "}, {"sha": "7a51a2cc23177b0daea1f96a1e9a064eaa684e8e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 98, "deletions": 109, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -99,19 +99,20 @@ use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{DontAutoderefReceiver};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::check::regionmanip::relate_free_regions;\n-use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n+use middle::typeck::check::vtable::VtableContext;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n use middle::typeck::{lookup_def_ccx};\n use middle::typeck::no_params;\n-use middle::typeck::{require_same_types, MethodMap, vtable_map};\n+use middle::typeck::{require_same_types, vtable_map};\n+use middle::typeck::{MethodCall, MethodMap};\n use middle::lang_items::TypeIdLangItem;\n use util::common::{block_query, indenter, loop_query};\n use util::ppaux;\n use util::ppaux::{UserString, Repr};\n-use util::nodemap::NodeMap;\n+use util::nodemap::{FnvHashMap, NodeMap};\n \n use std::cell::{Cell, RefCell};\n use collections::HashMap;\n@@ -266,7 +267,7 @@ impl Inherited {\n             node_types: RefCell::new(NodeMap::new()),\n             node_type_substs: RefCell::new(NodeMap::new()),\n             adjustments: RefCell::new(NodeMap::new()),\n-            method_map: @RefCell::new(NodeMap::new()),\n+            method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n         }\n@@ -1108,18 +1109,6 @@ impl FnCtxt {\n         }\n     }\n \n-    pub fn method_ty(&self, id: ast::NodeId) -> ty::t {\n-        match self.inh.method_map.borrow().get().find(&id) {\n-            Some(method) => method.ty,\n-            None => {\n-                self.tcx().sess.bug(\n-                    format!(\"no method entry for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_str(id),\n-                            self.tag()));\n-            }\n-        }\n-    }\n-\n     pub fn node_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n         match self.inh.node_type_substs.borrow().get().find(&id) {\n             Some(ts) => (*ts).clone(),\n@@ -1133,7 +1122,7 @@ impl FnCtxt {\n     }\n \n     pub fn method_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n-        match self.inh.method_map.borrow().get().find(&id) {\n+        match self.inh.method_map.borrow().get().find(&MethodCall::expr(id)) {\n             Some(method) => method.substs.clone(),\n             None => {\n                 self.tcx().sess.bug(\n@@ -1252,98 +1241,99 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n-pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n+pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, t: ty::t,\n+                    expr_id: Option<ast::NodeId>,\n+                    mut lvalue_pref: LvaluePreference,\n+                    should_stop: |ty::t, uint| -> Option<T>)\n+                    -> (ty::t, uint, Option<T>) {\n     /*!\n      *\n-     * Autoderefs the type `t` as many times as possible, returning\n-     * a new type and a counter for how many times the type was\n-     * deref'd.  If the counter is non-zero, the receiver is responsible\n-     * for inserting an AutoAdjustment record into `tcx.adjustments`\n+     * Autoderefs the type `t` as many times as possible, returning a new type\n+     * and an autoderef count. If the count is not zero, the receiver is\n+     * responsible for inserting an AutoAdjustment record into `tcx.adjustments`\n      * so that trans/borrowck/etc know about this autoderef. */\n \n-    let mut t1 = t;\n-    let mut enum_dids = Vec::new();\n+    let mut t = t;\n     let mut autoderefs = 0;\n     loop {\n-        let sty = structure_of(fcx, sp, t1);\n+        let resolved_t = structurally_resolved_type(fcx, sp, t);\n \n         // Some extra checks to detect weird cycles and so forth:\n-        match *sty {\n-            ty::ty_box(inner) | ty::ty_uniq(inner) => {\n-                match ty::get(t1).sty {\n+        match ty::get(resolved_t).sty {\n+            ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(_, _) => {\n+                match ty::get(t).sty {\n                     ty::ty_infer(ty::TyVar(v1)) => {\n-                        ty::occurs_check(fcx.ccx.tcx, sp, v1,\n-                                         ty::mk_box(fcx.ccx.tcx, inner));\n+                        ty::occurs_check(fcx.ccx.tcx, sp, v1, resolved_t);\n                     }\n-                    _ => ()\n-                }\n-            }\n-            ty::ty_rptr(_, inner) => {\n-                match ty::get(t1).sty {\n-                    ty::ty_infer(ty::TyVar(v1)) => {\n-                        ty::occurs_check(fcx.ccx.tcx, sp, v1,\n-                                         ty::mk_box(fcx.ccx.tcx, inner.ty));\n-                    }\n-                    _ => ()\n-                }\n-            }\n-            ty::ty_enum(ref did, _) => {\n-                // Watch out for a type like `enum t = @t`.  Such a\n-                // type would otherwise infinitely auto-deref.  Only\n-                // autoderef loops during typeck (basically, this one\n-                // and the loops in typeck::check::method) need to be\n-                // concerned with this, as an error will be reported\n-                // on the enum definition as well because the enum is\n-                // not instantiable.\n-                if enum_dids.contains(did) {\n-                    return (t1, autoderefs);\n+                    _ => {}\n                 }\n-                enum_dids.push(*did);\n             }\n             _ => { /*ok*/ }\n         }\n \n+        match should_stop(resolved_t, autoderefs) {\n+            Some(x) => return (resolved_t, autoderefs, Some(x)),\n+            None => {}\n+        }\n+\n         // Otherwise, deref if type is derefable:\n-        match ty::deref_sty(sty, false) {\n+        let mt = match ty::deref(resolved_t, false) {\n+            Some(mt) => Some(mt),\n             None => {\n-                return (t1, autoderefs);\n+                let method_call =\n+                    expr_id.map(|id| MethodCall::autoderef(id, autoderefs as u32));\n+                try_overloaded_deref(fcx, sp, method_call, None, resolved_t, lvalue_pref)\n             }\n+        };\n+        match mt {\n             Some(mt) => {\n+                t = mt.ty;\n+                if mt.mutbl == ast::MutImmutable {\n+                    lvalue_pref = NoPreference;\n+                }\n                 autoderefs += 1;\n-                t1 = mt.ty\n             }\n+            None => return (resolved_t, autoderefs, None)\n         }\n-    };\n+    }\n }\n \n fn try_overloaded_deref(fcx: @FnCtxt,\n-                        expr: &ast::Expr,\n-                        base_expr: &ast::Expr,\n+                        span: Span,\n+                        method_call: Option<MethodCall>,\n+                        base_expr: Option<&ast::Expr>,\n                         base_ty: ty::t,\n                         lvalue_pref: LvaluePreference)\n                         -> Option<ty::mt> {\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, expr, base_expr, token::intern(\"deref_mut\"),\n-                                    trait_did, base_ty, [], DontAutoderefReceiver)\n+            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+                                    token::intern(\"deref_mut\"), trait_did,\n+                                    base_ty, [], DontAutoderefReceiver)\n         }\n         _ => None\n     };\n \n     // Otherwise, fall back to Deref.\n     let method = match (method, fcx.tcx().lang_items.deref_trait()) {\n         (None, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, expr, base_expr, token::intern(\"deref\"),\n-                                    trait_did, base_ty, [], DontAutoderefReceiver)\n+            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+                                    token::intern(\"deref\"), trait_did,\n+                                    base_ty, [], DontAutoderefReceiver)\n         }\n         (method, _) => method\n     };\n \n     match method {\n         Some(method) => {\n             let ref_ty = ty::ty_fn_ret(method.ty);\n-            fcx.inh.method_map.borrow_mut().get().insert(expr.id, method);\n+            match method_call {\n+                Some(method_call) => {\n+                    fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n+                }\n+                None => {}\n+            }\n             ty::deref(ref_ty, true)\n         }\n         None => None\n@@ -1434,8 +1424,7 @@ fn check_expr_with_lvalue_pref(fcx: @FnCtxt, expr: &ast::Expr,\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n pub fn impl_self_ty(vcx: &VtableContext,\n-                    location_info: &LocationInfo, // (potential) receiver for\n-                                                  // this impl\n+                    span: Span, // (potential) receiver for this impl\n                     did: ast::DefId)\n                  -> ty_param_substs_and_ty {\n     let tcx = vcx.tcx();\n@@ -1446,7 +1435,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n          ity.generics.region_param_defs(),\n          ity.ty);\n \n-    let rps = vcx.infcx.region_vars_for_defs(location_info.span, rps);\n+    let rps = vcx.infcx.region_vars_for_defs(span, rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n     let substs = substs {\n@@ -1921,7 +1910,8 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                          AutoderefReceiver) {\n             Some(method) => {\n                 let method_ty = method.ty;\n-                fcx.inh.method_map.borrow_mut().get().insert(expr.id, method);\n+                let method_call = MethodCall::expr(expr.id);\n+                fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n                 method_ty\n             }\n             None => {\n@@ -2001,15 +1991,17 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                         unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n             Some(trait_did) => {\n-                method::lookup_in_trait(fcx, op_ex, args[0], opname, trait_did,\n-                                        self_t, [], autoderef_receiver)\n+                method::lookup_in_trait(fcx, op_ex.span, Some(&*args[0]), opname,\n+                                        trait_did, self_t, [], autoderef_receiver)\n             }\n             None => None\n         };\n         match method {\n             Some(method) => {\n                 let method_ty = method.ty;\n-                fcx.inh.method_map.borrow_mut().get().insert(op_ex.id, method);\n+                // HACK(eddyb) Fully qualified path to work around a resolve bug.\n+                let method_call = ::middle::typeck::MethodCall::expr(op_ex.id);\n+                fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n                 check_method_argument_types(fcx, op_ex.span,\n                                             method_ty, op_ex,\n                                             args, DoDerefArgs)\n@@ -2293,32 +2285,28 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                    field: ast::Name,\n                    tys: &[ast::P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n-        let bot = check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n+        check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n-        let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n-\n-        match *structure_of(fcx, expr.span, base_t) {\n-            ty::ty_struct(base_id, ref substs) => {\n-                // This is just for fields -- the same code handles\n-                // methods in both classes and traits\n-\n-                // (1) verify that the class id actually has a field called\n-                // field\n-                debug!(\"class named {}\", ppaux::ty_to_str(tcx, base_t));\n-                let cls_items = ty::lookup_struct_fields(tcx, base_id);\n-                match lookup_field_ty(tcx, base_id, cls_items.as_slice(),\n-                                      field, &(*substs)) {\n-                    Some(field_ty) => {\n-                        // (2) look up what field's type is, and return it\n-                        fcx.write_ty(expr.id, field_ty);\n-                        fcx.write_autoderef_adjustment(base.id, derefs);\n-                        return bot;\n-                    }\n-                    None => ()\n+        // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n+        let (_, autoderefs, field_ty) =\n+            autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n+            match ty::get(base_t).sty {\n+                ty::ty_struct(base_id, ref substs) => {\n+                    debug!(\"struct named {}\", ppaux::ty_to_str(tcx, base_t));\n+                    let fields = ty::lookup_struct_fields(tcx, base_id);\n+                    lookup_field_ty(tcx, base_id, fields.as_slice(), field, &(*substs))\n                 }\n+                _ => None\n+            }\n+        });\n+        match field_ty {\n+            Some(field_ty) => {\n+                fcx.write_ty(expr.id, field_ty);\n+                fcx.write_autoderef_adjustment(base.id, autoderefs);\n+                return;\n             }\n-            _ => ()\n+            None => {}\n         }\n \n         let tps: Vec<ty::t> = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n@@ -2738,8 +2726,9 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                     oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n                     oprnd_t = match ty::deref(oprnd_t, true) {\n                         Some(mt) => mt.ty,\n-                        None => match try_overloaded_deref(fcx, expr, oprnd,\n-                                                           oprnd_t, lvalue_pref) {\n+                        None => match try_overloaded_deref(fcx, expr.span,\n+                                                           Some(MethodCall::expr(expr.id)),\n+                                                           Some(&*oprnd), oprnd_t, lvalue_pref) {\n                             Some(mt) => mt.ty,\n                             None => {\n                                 let is_newtype = match ty::get(oprnd_t).sty {\n@@ -3175,19 +3164,27 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n           } else if ty::type_is_error(idx_t) || ty::type_is_bot(idx_t) {\n               fcx.write_ty(id, idx_t);\n           } else {\n-              let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n-              let base_sty = structure_of(fcx, expr.span, base_t);\n-              match ty::index_sty(base_sty) {\n+              let (base_t, autoderefs, field_ty) =\n+                autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n+                          lvalue_pref, |base_t, _| ty::index(base_t));\n+              match field_ty {\n                   Some(mt) => {\n                       require_integral(fcx, idx.span, idx_t);\n                       fcx.write_ty(id, mt.ty);\n-                      fcx.write_autoderef_adjustment(base.id, derefs);\n+                      fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n                   None => {\n                       let resolved = structurally_resolved_type(fcx,\n                                                                 expr.span,\n                                                                 raw_base_t);\n-                      let error_message = || {\n+                      let ret_ty = lookup_op_method(fcx,\n+                                                    expr,\n+                                                    resolved,\n+                                                    token::intern(\"index\"),\n+                                                    tcx.lang_items.index_trait(),\n+                                                    [base, idx],\n+                                                    AutoderefReceiver,\n+                                                    || {\n                         fcx.type_error_message(expr.span,\n                                                |actual| {\n                                                 format!(\"cannot index a value \\\n@@ -3196,15 +3193,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                },\n                                                base_t,\n                                                None);\n-                      };\n-                      let ret_ty = lookup_op_method(fcx,\n-                                                    expr,\n-                                                    resolved,\n-                                                    token::intern(\"index\"),\n-                                                    tcx.lang_items.index_trait(),\n-                                                    [base, idx],\n-                                                    AutoderefReceiver,\n-                                                    error_message);\n+                      });\n                       fcx.write_ty(id, ret_ty);\n                   }\n               }"}, {"sha": "169a7cfc90e71a08c0f7c099f65ce881406445db", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 58, "deletions": 60, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -129,6 +129,7 @@ use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n+use middle::typeck::MethodCall;\n use middle::pat_util;\n use util::ppaux::{ty_to_str, region_to_str, Repr};\n \n@@ -221,23 +222,27 @@ impl Rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_node_type(&mut self, id: ast::NodeId) -> ty::t {\n+    fn resolve_node_type(&mut self, id: ast::NodeId) -> ty::t {\n         let t = self.fcx.node_ty(id);\n         self.resolve_type(t)\n     }\n \n+    fn resolve_method_type(&mut self, method_call: MethodCall) -> Option<ty::t> {\n+        let method_ty = self.fcx.inh.method_map.borrow().get()\n+                            .find(&method_call).map(|method| method.ty);\n+        method_ty.map(|method_ty| self.resolve_type(method_ty))\n+    }\n+\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n             ty_unadjusted\n         } else {\n             let tcx = self.fcx.tcx();\n-            let adjustment = {\n-                let adjustments = self.fcx.inh.adjustments.borrow();\n-                adjustments.get().find_copy(&expr.id)\n-            };\n-            ty::adjust_ty(tcx, expr.span, ty_unadjusted, adjustment)\n+            let adjustment = self.fcx.inh.adjustments.borrow().get().find_copy(&expr.id);\n+            ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted, adjustment,\n+                          |method_call| self.resolve_method_type(method_call))\n         }\n     }\n }\n@@ -252,10 +257,8 @@ impl<'a> mc::Typer for &'a mut Rcx {\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n \n-    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t> {\n-        self.fcx.inh.method_map.borrow().get().find(&id).map(|method| {\n-            self.resolve_type(method.ty)\n-        })\n+    fn node_method_ty(&mut self, method_call: MethodCall) -> Option<ty::t> {\n+        self.resolve_method_type(method_call)\n     }\n \n     fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n@@ -264,7 +267,7 @@ impl<'a> mc::Typer for &'a mut Rcx {\n     }\n \n     fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n-        self.fcx.inh.method_map.borrow().get().contains_key(&id)\n+        self.fcx.inh.method_map.borrow().get().contains_key(&MethodCall::expr(id))\n     }\n \n     fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n@@ -383,53 +386,48 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n-    let has_method_map = rcx.fcx.inh.method_map.get().contains_key(&expr.id);\n+    let method_call = MethodCall::expr(expr.id);\n+    let has_method_map = rcx.fcx.inh.method_map.get().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    {\n-        let adjustments = rcx.fcx.inh.adjustments.borrow();\n-        let r = adjustments.get().find(&expr.id);\n-        for &adjustment in r.iter() {\n-            debug!(\"adjustment={:?}\", adjustment);\n-            match **adjustment {\n-                ty::AutoDerefRef(\n-                    ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n-                {\n-                    let expr_ty = rcx.resolve_node_type(expr.id);\n-                    constrain_derefs(rcx, expr, autoderefs, expr_ty);\n-                    for autoref in opt_autoref.iter() {\n-                        link_autoref(rcx, expr, autoderefs, autoref);\n-\n-                        // Require that the resulting region encompasses\n-                        // the current node.\n-                        //\n-                        // FIXME(#6268) remove to support nested method calls\n-                        constrain_regions_in_type_of_node(\n-                            rcx, expr.id, ty::ReScope(expr.id),\n-                            infer::AutoBorrow(expr.span));\n-                    }\n-                }\n-                ty::AutoObject(ast::BorrowedSigil, Some(trait_region), _, _, _, _) => {\n-                    // Determine if we are casting `expr` to an trait\n-                    // instance.  If so, we have to be sure that the type of\n-                    // the source obeys the trait's region bound.\n+    for &adjustment in rcx.fcx.inh.adjustments.borrow().get().find(&expr.id).iter() {\n+        debug!(\"adjustment={:?}\", adjustment);\n+        match **adjustment {\n+            ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: opt_autoref}) => {\n+                let expr_ty = rcx.resolve_node_type(expr.id);\n+                constrain_derefs(rcx, expr, autoderefs, expr_ty);\n+                for autoref in opt_autoref.iter() {\n+                    link_autoref(rcx, expr, autoderefs, autoref);\n+\n+                    // Require that the resulting region encompasses\n+                    // the current node.\n                     //\n-                    // Note: there is a subtle point here concerning type\n-                    // parameters.  It is possible that the type of `source`\n-                    // contains type parameters, which in turn may contain\n-                    // regions that are not visible to us (only the caller\n-                    // knows about them).  The kind checker is ultimately\n-                    // responsible for guaranteeing region safety in that\n-                    // particular case.  There is an extensive comment on the\n-                    // function check_cast_for_escaping_regions() in kind.rs\n-                    // explaining how it goes about doing that.\n-\n-                    let source_ty = rcx.fcx.expr_ty(expr);\n-                    constrain_regions_in_type(rcx, trait_region,\n-                                              infer::RelateObjectBound(expr.span), source_ty);\n+                    // FIXME(#6268) remove to support nested method calls\n+                    constrain_regions_in_type_of_node(\n+                        rcx, expr.id, ty::ReScope(expr.id),\n+                        infer::AutoBorrow(expr.span));\n                 }\n-                _ => {}\n             }\n+            ty::AutoObject(ast::BorrowedSigil, Some(trait_region), _, _, _, _) => {\n+                // Determine if we are casting `expr` to an trait\n+                // instance.  If so, we have to be sure that the type of\n+                // the source obeys the trait's region bound.\n+                //\n+                // Note: there is a subtle point here concerning type\n+                // parameters.  It is possible that the type of `source`\n+                // contains type parameters, which in turn may contain\n+                // regions that are not visible to us (only the caller\n+                // knows about them).  The kind checker is ultimately\n+                // responsible for guaranteeing region safety in that\n+                // particular case.  There is an extensive comment on the\n+                // function check_cast_for_escaping_regions() in kind.rs\n+                // explaining how it goes about doing that.\n+\n+                let source_ty = rcx.fcx.expr_ty(expr);\n+                constrain_regions_in_type(rcx, trait_region,\n+                                            infer::RelateObjectBound(expr.span), source_ty);\n+            }\n+            _ => {}\n         }\n     }\n \n@@ -488,7 +486,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprUnary(ast::UnDeref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n-            let base_ty = match rcx.fcx.inh.method_map.get().find(&expr.id) {\n+            let method_call = MethodCall::expr(expr.id);\n+            let base_ty = match rcx.fcx.inh.method_map.get().find(&method_call) {\n                 Some(method) => {\n                     constrain_call(rcx, None, expr, Some(base), [], true);\n                     ty::ty_fn_ret(method.ty)\n@@ -769,7 +768,8 @@ fn constrain_call(rcx: &mut Rcx,\n             implicitly_ref_args);\n     let callee_ty = match fn_expr_id {\n         Some(id) => rcx.resolve_node_type(id),\n-        None => rcx.resolve_type(rcx.fcx.method_ty(call_expr.id))\n+        None => rcx.resolve_method_type(MethodCall::expr(call_expr.id))\n+                   .expect(\"call should have been to a method\")\n     };\n     if ty::type_is_error(callee_ty) {\n         // Bail, as function type is unknown\n@@ -904,11 +904,9 @@ fn constrain_regions_in_type_of_node(\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n-    let adjustment = {\n-        let adjustments = rcx.fcx.inh.adjustments.borrow();\n-        adjustments.get().find_copy(&id)\n-    };\n-    let ty = ty::adjust_ty(tcx, origin.span(), ty0, adjustment);\n+    let adjustment = rcx.fcx.inh.adjustments.borrow().get().find_copy(&id);\n+    let ty = ty::adjust_ty(tcx, origin.span(), id, ty0, adjustment,\n+                           |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?}, adjustment={:?})\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),"}, {"sha": "3fee30bc4988cc93aeed1641304bf9b1a45e475f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 48, "deletions": 93, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -21,6 +21,7 @@ use middle::typeck::infer;\n use middle::typeck::{vtable_origin, vtable_res, vtable_param_res};\n use middle::typeck::{vtable_static, vtable_param, impl_res};\n use middle::typeck::{param_numbered, param_self, param_index};\n+use middle::typeck::MethodCall;\n use middle::subst::Subst;\n use util::common::indenter;\n use util::ppaux;\n@@ -62,15 +63,6 @@ use syntax::visit::Visitor;\n // It may be better to do something more clever, like processing fully\n // resolved types first.\n \n-\n-/// Location info records the span and ID of the expression or item that is\n-/// responsible for this vtable instantiation. (This may not be an expression\n-/// if the vtable instantiation is being performed as part of \"deriving\".)\n-pub struct LocationInfo {\n-    span: Span,\n-    id: ast::NodeId\n-}\n-\n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n pub struct VtableContext<'a> {\n@@ -88,14 +80,14 @@ fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n }\n \n fn lookup_vtables(vcx: &VtableContext,\n-                  location_info: &LocationInfo,\n+                  span: Span,\n                   type_param_defs: &[ty::TypeParameterDef],\n                   substs: &ty::substs,\n                   is_early: bool) -> vtable_res {\n-    debug!(\"lookup_vtables(location_info={:?}, \\\n+    debug!(\"lookup_vtables(span={:?}, \\\n             type_param_defs={}, \\\n             substs={}\",\n-           location_info,\n+           span,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()));\n \n@@ -105,26 +97,26 @@ fn lookup_vtables(vcx: &VtableContext,\n         substs.tps.rev_iter()\n         .zip(type_param_defs.rev_iter())\n         .map(|(ty, def)|\n-                   lookup_vtables_for_param(vcx, location_info, Some(substs),\n-                                            &*def.bounds, *ty, is_early))\n+            lookup_vtables_for_param(vcx, span, Some(substs),\n+                                     &*def.bounds, *ty, is_early))\n         .collect();\n     result.reverse();\n \n     assert_eq!(substs.tps.len(), result.len());\n     debug!(\"lookup_vtables result(\\\n-            location_info={:?}, \\\n+            span={:?}, \\\n             type_param_defs={}, \\\n             substs={}, \\\n             result={})\",\n-           location_info,\n+           span,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()),\n            result.repr(vcx.tcx()));\n     @result\n }\n \n fn lookup_vtables_for_param(vcx: &VtableContext,\n-                            location_info: &LocationInfo,\n+                            span: Span,\n                             // None for substs means the identity\n                             substs: Option<&ty::substs>,\n                             type_param_bounds: &ty::ParamBounds,\n@@ -155,11 +147,10 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n \n         debug!(\"after subst: {}\", trait_ref.repr(tcx));\n \n-        match lookup_vtable(vcx, location_info, ty, trait_ref, is_early) {\n+        match lookup_vtable(vcx, span, ty, trait_ref, is_early) {\n             Some(vtable) => param_result.push(vtable),\n             None => {\n-                vcx.tcx().sess.span_fatal(\n-                    location_info.span,\n+                vcx.tcx().sess.span_fatal(span,\n                     format!(\"failed to find an implementation of \\\n                           trait {} for {}\",\n                          vcx.infcx.trait_ref_to_str(trait_ref),\n@@ -170,11 +161,11 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     });\n \n     debug!(\"lookup_vtables_for_param result(\\\n-            location_info={:?}, \\\n+            span={:?}, \\\n             type_param_bounds={}, \\\n             ty={}, \\\n             result={})\",\n-           location_info,\n+           span,\n            type_param_bounds.repr(vcx.tcx()),\n            ty.repr(vcx.tcx()),\n            param_result.repr(vcx.tcx()));\n@@ -183,10 +174,9 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n }\n \n fn relate_trait_refs(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n+                     span: Span,\n                      act_trait_ref: @ty::TraitRef,\n-                     exp_trait_ref: @ty::TraitRef)\n-{\n+                     exp_trait_ref: @ty::TraitRef) {\n     /*!\n      *\n      * Checks that an implementation of `act_trait_ref` is suitable\n@@ -196,10 +186,9 @@ fn relate_trait_refs(vcx: &VtableContext,\n \n     match infer::mk_sub_trait_refs(vcx.infcx,\n                                    false,\n-                                   infer::RelateTraitRefs(location_info.span),\n+                                   infer::RelateTraitRefs(span),\n                                    act_trait_ref,\n-                                   exp_trait_ref)\n-    {\n+                                   exp_trait_ref) {\n         result::Ok(()) => {} // Ok.\n         result::Err(ref err) => {\n             // There is an error, but we need to do some work to make\n@@ -215,8 +204,7 @@ fn relate_trait_refs(vcx: &VtableContext,\n                 !ty::trait_ref_contains_error(&r_exp_trait_ref)\n             {\n                 let tcx = vcx.tcx();\n-                tcx.sess.span_err(\n-                    location_info.span,\n+                tcx.sess.span_err(span,\n                     format!(\"expected {}, but found {} ({})\",\n                          ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n                          ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n@@ -228,18 +216,17 @@ fn relate_trait_refs(vcx: &VtableContext,\n \n // Look up the vtable implementing the trait `trait_ref` at type `t`\n fn lookup_vtable(vcx: &VtableContext,\n-                 location_info: &LocationInfo,\n+                 span: Span,\n                  ty: ty::t,\n                  trait_ref: @ty::TraitRef,\n                  is_early: bool)\n-    -> Option<vtable_origin>\n-{\n+                 -> Option<vtable_origin> {\n     debug!(\"lookup_vtable(ty={}, trait_ref={})\",\n            vcx.infcx.ty_to_str(ty),\n            vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n \n-    let ty = match fixup_ty(vcx, location_info, ty, is_early) {\n+    let ty = match fixup_ty(vcx, span, ty, is_early) {\n         Some(ty) => ty,\n         None => {\n             // fixup_ty can only fail if this is early resolution\n@@ -261,17 +248,15 @@ fn lookup_vtable(vcx: &VtableContext,\n                    .get(n)\n                    .trait_bounds\n                    .as_slice();\n-            lookup_vtable_from_bounds(vcx,\n-                                      location_info,\n+            lookup_vtable_from_bounds(vcx, span,\n                                       type_param_bounds,\n                                       param_numbered(n),\n                                       trait_ref)\n         }\n \n         ty::ty_self(_) => {\n             let self_param_bound = vcx.param_env.self_param_bound.unwrap();\n-            lookup_vtable_from_bounds(vcx,\n-                                      location_info,\n+            lookup_vtable_from_bounds(vcx, span,\n                                       [self_param_bound],\n                                       param_self,\n                                       trait_ref)\n@@ -285,14 +270,13 @@ fn lookup_vtable(vcx: &VtableContext,\n \n     // If we aren't a self type or param, or it was, but we didn't find it,\n     // do a search.\n-    return search_for_vtable(vcx, location_info,\n-                             ty, trait_ref, is_early)\n+    search_for_vtable(vcx, span, ty, trait_ref, is_early)\n }\n \n // Given a list of bounds on a type, search those bounds to see if any\n // of them are the vtable we are looking for.\n fn lookup_vtable_from_bounds(vcx: &VtableContext,\n-                             location_info: &LocationInfo,\n+                             span: Span,\n                              bounds: &[@ty::TraitRef],\n                              param: param_index,\n                              trait_ref: @ty::TraitRef)\n@@ -306,10 +290,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                bound_trait_ref.repr(vcx.tcx()));\n \n         if bound_trait_ref.def_id == trait_ref.def_id {\n-            relate_trait_refs(vcx,\n-                              location_info,\n-                              bound_trait_ref,\n-                              trait_ref);\n+            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref);\n             let vtable = vtable_param(param, n_bound);\n             debug!(\"found param vtable: {:?}\",\n                    vtable);\n@@ -324,7 +305,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n }\n \n fn search_for_vtable(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n+                     span: Span,\n                      ty: ty::t,\n                      trait_ref: @ty::TraitRef,\n                      is_early: bool)\n@@ -385,11 +366,10 @@ fn search_for_vtable(vcx: &VtableContext,\n         let ty::ty_param_substs_and_ty {\n             substs: substs,\n             ty: for_ty\n-        } = impl_self_ty(vcx, location_info, im.did);\n+        } = impl_self_ty(vcx, span, im.did);\n         match infer::mk_subty(vcx.infcx,\n                               false,\n-                              infer::RelateSelfType(\n-                                  location_info.span),\n+                              infer::RelateSelfType(span),\n                               ty,\n                               for_ty) {\n             result::Err(_) => continue,\n@@ -418,7 +398,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n         let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n-        relate_trait_refs(vcx, location_info, of_trait_ref, trait_ref);\n+        relate_trait_refs(vcx, span, of_trait_ref, trait_ref);\n \n \n         // Recall that trait_ref -- the trait type we're casting to --\n@@ -430,15 +410,14 @@ fn search_for_vtable(vcx: &VtableContext,\n         // process of looking up bounds might constrain some of them.\n         let im_generics =\n             ty::lookup_item_type(tcx, im.did).generics;\n-        let subres = lookup_vtables(vcx, location_info,\n+        let subres = lookup_vtables(vcx, span,\n                                     im_generics.type_param_defs(), &substs,\n                                     is_early);\n \n \n         // substs might contain type variables, so we call\n         // fixup_substs to resolve them.\n-        let substs_f = match fixup_substs(vcx,\n-                                          location_info,\n+        let substs_f = match fixup_substs(vcx, span,\n                                           trait_ref.def_id,\n                                           substs,\n                                           is_early) {\n@@ -463,7 +442,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // I am a little confused about this, since it seems to be\n         // very similar to the relate_trait_refs we already do,\n         // but problems crop up if it is removed, so... -sully\n-        connect_trait_tps(vcx, location_info, &substs_f, trait_ref, im.did);\n+        connect_trait_tps(vcx, span, &substs_f, trait_ref, im.did);\n \n         // Finally, we register that we found a matching impl, and\n         // record the def ID of the impl as well as the resolved list\n@@ -476,9 +455,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         1 => return Some(found.get(0).clone()),\n         _ => {\n             if !is_early {\n-                vcx.tcx().sess.span_err(\n-                    location_info.span,\n-                    \"multiple applicable methods in scope\");\n+                vcx.tcx().sess.span_err(span, \"multiple applicable methods in scope\");\n             }\n             return Some(found.get(0).clone());\n         }\n@@ -487,7 +464,7 @@ fn search_for_vtable(vcx: &VtableContext,\n \n \n fn fixup_substs(vcx: &VtableContext,\n-                location_info: &LocationInfo,\n+                span: Span,\n                 id: ast::DefId,\n                 substs: ty::substs,\n                 is_early: bool)\n@@ -499,7 +476,7 @@ fn fixup_substs(vcx: &VtableContext,\n                          ty::RegionTraitStore(ty::ReStatic),\n                          ast::MutImmutable,\n                          ty::EmptyBuiltinBounds());\n-    fixup_ty(vcx, location_info, t, is_early).map(|t_f| {\n+    fixup_ty(vcx, span, t, is_early).map(|t_f| {\n         match ty::get(t_f).sty {\n           ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n           _ => fail!(\"t_f should be a trait\")\n@@ -508,16 +485,15 @@ fn fixup_substs(vcx: &VtableContext,\n }\n \n fn fixup_ty(vcx: &VtableContext,\n-            location_info: &LocationInfo,\n+            span: Span,\n             ty: ty::t,\n             is_early: bool)\n             -> Option<ty::t> {\n     let tcx = vcx.tcx();\n     match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n         Err(e) if !is_early => {\n-            tcx.sess.span_fatal(\n-                location_info.span,\n+            tcx.sess.span_fatal(span,\n                 format!(\"cannot determine a type \\\n                       for this bounded type parameter: {}\",\n                      fixup_err_to_str(e)))\n@@ -529,20 +505,20 @@ fn fixup_ty(vcx: &VtableContext,\n }\n \n fn connect_trait_tps(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n+                     span: Span,\n                      impl_substs: &ty::substs,\n                      trait_ref: @ty::TraitRef,\n                      impl_did: ast::DefId) {\n     let tcx = vcx.tcx();\n \n     let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {\n         Some(t) => t,\n-        None => vcx.tcx().sess.span_bug(location_info.span,\n+        None => vcx.tcx().sess.span_bug(span,\n                                   \"connect_trait_tps invoked on a type impl\")\n     };\n \n     let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n-    relate_trait_refs(vcx, location_info, impl_trait_ref, trait_ref);\n+    relate_trait_refs(vcx, span, impl_trait_ref, trait_ref);\n }\n \n fn insert_vtables(fcx: &FnCtxt, expr_id: ast::NodeId, vtables: vtable_res) {\n@@ -551,19 +527,6 @@ fn insert_vtables(fcx: &FnCtxt, expr_id: ast::NodeId, vtables: vtable_res) {\n     fcx.inh.vtable_map.borrow_mut().get().insert(expr_id, vtables);\n }\n \n-pub fn location_info_for_expr(expr: &ast::Expr) -> LocationInfo {\n-    LocationInfo {\n-        span: expr.span,\n-        id: expr.id\n-    }\n-}\n-pub fn location_info_for_item(item: &ast::Item) -> LocationInfo {\n-    LocationInfo {\n-        span: item.span,\n-        id: item.id\n-    }\n-}\n-\n pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex));\n@@ -608,8 +571,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                         _ => fail!(\"shouldn't get here\"),\n                     };\n \n-                      let location_info =\n-                          &location_info_for_expr(ex);\n                       let vcx = fcx.vtable_context();\n                       let target_trait_ref = @ty::TraitRef {\n                           def_id: target_def_id,\n@@ -626,7 +587,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                       };\n                       let vtables =\n                             lookup_vtables_for_param(&vcx,\n-                                                     location_info,\n+                                                     ex.span,\n                                                      None,\n                                                      &param_bounds,\n                                                      typ,\n@@ -687,7 +648,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                 debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n                        item_ty.generics.type_param_defs().repr(fcx.tcx()));\n                 let vcx = fcx.vtable_context();\n-                let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n+                let vtbls = lookup_vtables(&vcx, ex.span,\n                                            item_ty.generics.type_param_defs(),\n                                            substs, is_early);\n                 if !is_early {\n@@ -704,15 +665,15 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       ast::ExprAssignOp(_, _, _) |\n       ast::ExprIndex(_, _) |\n       ast::ExprMethodCall(_, _, _) => {\n-        match fcx.inh.method_map.borrow().get().find(&ex.id) {\n+        match fcx.inh.method_map.borrow().get().find(&MethodCall::expr(ex.id)) {\n           Some(method) => {\n             debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n             let type_param_defs = ty::method_call_type_param_defs(cx.tcx, method.origin);\n             if has_trait_bounds(type_param_defs.deref().as_slice()) {\n                 let substs = fcx.method_ty_substs(ex.id);\n                 let vcx = fcx.vtable_context();\n-                let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n+                let vtbls = lookup_vtables(&vcx, ex.span,\n                                            type_param_defs.deref()\n                                                           .as_slice(),\n                                            &substs, is_early);\n@@ -782,13 +743,11 @@ pub fn resolve_impl(tcx: ty::ctxt,\n \n     let infcx = &infer::new_infer_ctxt(tcx);\n     let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n-    let loc_info = location_info_for_item(impl_item);\n \n     // First, check that the impl implements any trait bounds\n     // on the trait.\n     let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);\n-    let vtbls = lookup_vtables(&vcx,\n-                               &loc_info,\n+    let vtbls = lookup_vtables(&vcx, impl_item.span,\n                                trait_def.generics.type_param_defs(),\n                                &impl_trait_ref.substs,\n                                false);\n@@ -808,7 +767,7 @@ pub fn resolve_impl(tcx: ty::ctxt,\n     // We will need to make one so we can use this information\n     // for compiling default methods that refer to supertraits.\n     let self_vtable_res =\n-        lookup_vtables_for_param(&vcx, &loc_info, None,\n+        lookup_vtables_for_param(&vcx, impl_item.span, None,\n                                  &param_bounds, t, false);\n \n \n@@ -833,13 +792,9 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n             infcx: &infer::new_infer_ctxt(tcx),\n             param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], [], id)\n         };\n-        let loc_info = LocationInfo {\n-            id: id,\n-            span: tcx.map.span(id)\n-        };\n \n         Some(lookup_vtables(&vcx,\n-                            &loc_info,\n+                            tcx.map.span(id),\n                             type_param_defs.as_slice(),\n                             substs,\n                             false))"}, {"sha": "7659842aff4119e3b4055fcf3c6cf081ed1e992f", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -20,7 +20,7 @@ use middle::typeck::check::FnCtxt;\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n-use middle::typeck::MethodCallee;\n+use middle::typeck::{MethodCall, MethodCallee};\n use middle::typeck::{vtable_res, vtable_origin};\n use middle::typeck::{vtable_static, vtable_param};\n use middle::typeck::write_substs_to_tcx;\n@@ -63,15 +63,15 @@ fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n     }).collect()\n }\n \n-fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall) {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any method map entry\n-    match fcx.inh.method_map.borrow().get().find(&id) {\n+    match fcx.inh.method_map.borrow().get().find(&method_call) {\n         Some(method) => {\n-            debug!(\"writeback::resolve_method_map_entry(id={:?}, entry={:?})\",\n-                   id, method.repr(tcx));\n+            debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n+                   method_call, method.repr(tcx));\n             let method_ty = match resolve_type_vars_in_type(fcx, sp, method.ty) {\n                 Some(t) => t,\n                 None => {\n@@ -95,7 +95,7 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n                     self_ty: None\n                 }\n             };\n-            fcx.ccx.method_map.borrow_mut().get().insert(id, new_method);\n+            fcx.ccx.method_map.borrow_mut().get().insert(method_call, new_method);\n         }\n         None => {}\n     }\n@@ -142,10 +142,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    let adjustment = {\n-        let adjustments = fcx.inh.adjustments.borrow();\n-        adjustments.get().find_copy(&id)\n-    };\n+    let adjustment = fcx.inh.adjustments.borrow().get().find_copy(&id);\n     match adjustment {\n         None => (),\n \n@@ -167,30 +164,29 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                             // FIXME(eddyb) #2190 Allow only statically resolved\n                             // bare functions to coerce to a closure to avoid\n                             // constructing (slower) indirect call wrappers.\n-                            {\n-                                let def_map = tcx.def_map.borrow();\n-                                match def_map.get().find(&id) {\n-                                    Some(&ast::DefFn(..)) |\n-                                    Some(&ast::DefStaticMethod(..)) |\n-                                    Some(&ast::DefVariant(..)) |\n-                                    Some(&ast::DefStruct(_)) => {}\n-                                    _ => tcx.sess.span_err(sp,\n-                                            \"cannot coerce non-statically resolved bare fn\")\n-                                }\n+                            match tcx.def_map.borrow().get().find(&id) {\n+                                Some(&ast::DefFn(..)) |\n+                                Some(&ast::DefStaticMethod(..)) |\n+                                Some(&ast::DefVariant(..)) |\n+                                Some(&ast::DefStruct(_)) => {}\n+                                _ => tcx.sess.span_err(sp,\n+                                        \"cannot coerce non-statically resolved bare fn\")\n                             }\n \n                             let resolved_adj = @ty::AutoAddEnv(r1, s);\n                             debug!(\"Adjustments for node {}: {:?}\",\n-                                   id,\n-                                   resolved_adj);\n-                            let mut adjustments = tcx.adjustments\n-                                                     .borrow_mut();\n-                            adjustments.get().insert(id, resolved_adj);\n+                                   id, resolved_adj);\n+                            tcx.adjustments.borrow_mut().get().insert(id, resolved_adj);\n                         }\n                     }\n                 }\n \n                 ty::AutoDerefRef(adj) => {\n+                    for autoderef in range(0, adj.autoderefs) {\n+                        let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                        resolve_method_map_entry(wbcx, sp, method_call);\n+                    }\n+\n                     let fixup_region = |r| {\n                         match resolve_region(fcx.infcx(),\n                                              r,\n@@ -218,14 +214,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                         autoref: resolved_autoref,\n                     });\n                     debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-                    let mut adjustments = tcx.adjustments.borrow_mut();\n-                    adjustments.get().insert(id, resolved_adj);\n+                    tcx.adjustments.borrow_mut().get().insert(id, resolved_adj);\n                 }\n \n                 ty::AutoObject(..) => {\n                     debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n-                    let mut adjustments = tcx.adjustments.borrow_mut();\n-                    adjustments.get().insert(id, adjustment);\n+                    tcx.adjustments.borrow_mut().get().insert(id, adjustment);\n                 }\n             }\n         }\n@@ -280,7 +274,7 @@ fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n     }\n \n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n-    resolve_method_map_entry(wbcx, e.span, e.id);\n+    resolve_method_map_entry(wbcx, e.span, MethodCall::expr(e.id));\n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n \n     match e.node {"}, {"sha": "726f89048984c9f9f8954f89a6075158407febe1", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -68,7 +68,7 @@ use middle::ty;\n use util::common::time;\n use util::ppaux::Repr;\n use util::ppaux;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -149,9 +149,31 @@ pub struct MethodCallee {\n     substs: ty::substs\n }\n \n+#[deriving(Clone, Eq, Hash)]\n+pub struct MethodCall {\n+    expr_id: ast::NodeId,\n+    autoderef: u32\n+}\n+\n+impl MethodCall {\n+    pub fn expr(id: ast::NodeId) -> MethodCall {\n+        MethodCall {\n+            expr_id: id,\n+            autoderef: 0\n+        }\n+    }\n+\n+    pub fn autoderef(expr_id: ast::NodeId, autoderef: u32) -> MethodCall {\n+        MethodCall {\n+            expr_id: expr_id,\n+            autoderef: 1 + autoderef\n+        }\n+    }\n+}\n+\n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap = @RefCell<NodeMap<MethodCallee>>;\n+pub type MethodMap = @RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n \n pub type vtable_param_res = @Vec<vtable_origin> ;\n // Resolutions for bounds of all parameters, left to right, for a given path.\n@@ -442,7 +464,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     let time_passes = tcx.sess.time_passes();\n     let ccx = @CrateCtxt {\n         trait_map: trait_map,\n-        method_map: @RefCell::new(NodeMap::new()),\n+        method_map: @RefCell::new(FnvHashMap::new()),\n         vtable_map: @RefCell::new(NodeMap::new()),\n         tcx: tcx\n     };"}, {"sha": "7507fd579ebc174e02a5a0e592cf45bb230281a9", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -16,22 +16,35 @@ use std::io;\n use syntax::ast;\n \n #[cfg(not(stage0))]\n-pub type NodeMap<T> = HashMap<ast::NodeId, T, FnvHasher>;\n-#[cfg(not(stage0))]\n-pub type DefIdMap<T> = HashMap<ast::DefId, T, FnvHasher>;\n+pub type FnvHashMap<K, V> = HashMap<K, V, FnvHasher>;\n+\n+pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n+pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n+\n #[cfg(not(stage0))]\n pub type NodeSet = HashSet<ast::NodeId, FnvHasher>;\n #[cfg(not(stage0))]\n pub type DefIdSet = HashSet<ast::DefId, FnvHasher>;\n \n // Hacks to get good names\n #[cfg(not(stage0))]\n-pub mod NodeMap {\n+pub mod FnvHashMap {\n+    use std::hash::Hash;\n     use collections::HashMap;\n-    pub fn new<T>() -> super::NodeMap<T> {\n+    pub fn new<K: Hash<super::FnvState> + Eq, V>() -> super::FnvHashMap<K, V> {\n         HashMap::with_hasher(super::FnvHasher)\n     }\n }\n+pub mod NodeMap {\n+    pub fn new<T>() -> super::NodeMap<T> {\n+        super::FnvHashMap::new()\n+    }\n+}\n+pub mod DefIdMap {\n+    pub fn new<T>() -> super::DefIdMap<T> {\n+        super::FnvHashMap::new()\n+    }\n+}\n #[cfg(not(stage0))]\n pub mod NodeSet {\n     use collections::HashSet;\n@@ -40,13 +53,6 @@ pub mod NodeSet {\n     }\n }\n #[cfg(not(stage0))]\n-pub mod DefIdMap {\n-    use collections::HashMap;\n-    pub fn new<T>() -> super::DefIdMap<T> {\n-        HashMap::with_hasher(super::FnvHasher)\n-    }\n-}\n-#[cfg(not(stage0))]\n pub mod DefIdSet {\n     use collections::HashSet;\n     pub fn new() -> super::DefIdSet {\n@@ -55,19 +61,19 @@ pub mod DefIdSet {\n }\n \n #[cfg(stage0)]\n-pub type NodeMap<T> = HashMap<ast::NodeId, T>;\n-#[cfg(stage0)]\n-pub type DefIdMap<T> = HashMap<ast::DefId, T>;\n+pub type FnvHashMap<K, V> = HashMap<K, V>;\n+\n #[cfg(stage0)]\n pub type NodeSet = HashSet<ast::NodeId>;\n #[cfg(stage0)]\n pub type DefIdSet = HashSet<ast::DefId>;\n \n // Hacks to get good names\n #[cfg(stage0)]\n-pub mod NodeMap {\n+pub mod FnvHashMap {\n+    use std::hash::Hash;\n     use collections::HashMap;\n-    pub fn new<T>() -> super::NodeMap<T> {\n+    pub fn new<K: Hash + Eq, V>() -> super::FnvHashMap<K, V> {\n         HashMap::new()\n     }\n }\n@@ -79,13 +85,6 @@ pub mod NodeSet {\n     }\n }\n #[cfg(stage0)]\n-pub mod DefIdMap {\n-    use collections::HashMap;\n-    pub fn new<T>() -> super::DefIdMap<T> {\n-        HashMap::new()\n-    }\n-}\n-#[cfg(stage0)]\n pub mod DefIdSet {\n     use collections::HashSet;\n     pub fn new() -> super::DefIdSet {"}, {"sha": "6b347b3833e46822fdcf1e484fefdda0fa91576d", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b4e159edb54cecb8abdedb187ba05a869b3bf0/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=20b4e159edb54cecb8abdedb187ba05a869b3bf0", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+#[deriving(Eq, Show)]\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+pub fn main() {\n+    assert_eq!(Rc::new(5u).to_uint(), Some(5));\n+    assert_eq!((~&~&Rc::new(~~&~5u)).to_uint(), Some(5));\n+    let point = Rc::new(Point {x: 2, y: 4});\n+    assert_eq!(point.x, 2);\n+    assert_eq!(point.y, 4);\n+\n+    let i = Rc::new(RefCell::new(2));\n+    let i_value = *i.borrow();\n+    *i.borrow_mut() = 5;\n+    assert_eq!((i_value, *i.borrow()), (2, 5));\n+\n+    let s = Rc::new(~\"foo\");\n+    assert!(s.equiv(&(\"foo\")));\n+    assert_eq!(s.as_slice(), \"foo\");\n+\n+    let mut_s = Rc::new(RefCell::new(~\"foo\"));\n+    mut_s.borrow_mut().push_str(\"bar\");\n+    // HACK assert_eq! would fail here because it stores the LHS and RHS in two locals.\n+    assert!(mut_s.borrow().as_slice() == \"foobar\");\n+    assert!(mut_s.borrow_mut().as_slice() == \"foobar\");\n+\n+    let p = Rc::new(RefCell::new(Point {x: 1, y: 2}));\n+    p.borrow_mut().x = 3;\n+    p.borrow_mut().y += 3;\n+    assert_eq!(*p.borrow(), Point {x: 3, y: 5});\n+\n+    let v = Rc::new(RefCell::new(~[1, 2, 3]));\n+    v.borrow_mut()[0] = 3;\n+    v.borrow_mut()[1] += 3;\n+    assert_eq!((v.borrow()[0], v.borrow()[1], v.borrow()[2]), (3, 5, 3));\n+}"}]}