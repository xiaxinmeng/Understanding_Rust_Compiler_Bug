{"sha": "829df69f9f7a0dd0adbf072a47fd7c7600e75211", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyOWRmNjlmOWY3YTBkZDBhZGJmMDcyYTQ3ZmQ3Yzc2MDBlNzUyMTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-05T23:19:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-13T07:24:20Z"}, "message": "Add basic backtrace functionality\n\nWhenever a failure happens, if a program is run with\n`RUST_LOG=std::rt::backtrace` a backtrace will be printed to the task's stderr\nhandle. Stack traces are uncondtionally printed on double-failure and\nrtabort!().\n\nThis ended up having a nontrivial implementation, and here's some highlights of\nit:\n\n* We're bundling libbacktrace for everything but OSX and Windows\n* We use libgcc_s and its libunwind apis to get a backtrace of instruction\n  pointers\n* On OSX we use dladdr() to go from an instruction pointer to a symbol\n* On unix that isn't OSX, we use libbacktrace to get symbols\n* Windows, as usual, has an entirely separate implementation\n\nLots more fun details and comments can be found in the source itself.\n\nCloses #10128", "tree": {"sha": "74d6759c446dadbd121d2ae9470a9b173045be0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74d6759c446dadbd121d2ae9470a9b173045be0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/829df69f9f7a0dd0adbf072a47fd7c7600e75211", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/829df69f9f7a0dd0adbf072a47fd7c7600e75211", "html_url": "https://github.com/rust-lang/rust/commit/829df69f9f7a0dd0adbf072a47fd7c7600e75211", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/829df69f9f7a0dd0adbf072a47fd7c7600e75211/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a21b9007775343b7ca59245380b38d5b41a2e2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a21b9007775343b7ca59245380b38d5b41a2e2b", "html_url": "https://github.com/rust-lang/rust/commit/9a21b9007775343b7ca59245380b38d5b41a2e2b"}], "stats": {"total": 1195, "additions": 1094, "deletions": 101}, "files": [{"sha": "16485b9e6b52990d05493a7ee4f1e5d5fb3779e2", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -55,7 +55,7 @@ HOST_CRATES := syntax rustc rustdoc fourcc hexfloat\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n-DEPS_std := native:rustrt native:compiler-rt\n+DEPS_std := native:rustrt native:compiler-rt native:backtrace\n DEPS_extra := std term sync serialize getopts collections time rand\n DEPS_green := std rand native:context_switch\n DEPS_rustuv := std native:uv native:uv_support"}, {"sha": "01667352c676d5b0291a3d5b1643edcbc453afc0", "filename": "mk/rt.mk", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -249,6 +249,73 @@ $$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS) $$(MKFILE_DEPS)\n \t\ttriple-runtime\n \t$$(Q)cp $$(COMPRT_BUILD_DIR_$(1))/triple/runtime/libcompiler_rt.a $$(COMPRT_LIB_$(1))\n \n+################################################################################\n+# libbacktrace\n+#\n+# We use libbacktrace on linux to get symbols in backtraces, but only on linux.\n+# Elsewhere we use other system utilities, so this library is only built on\n+# linux.\n+################################################################################\n+\n+BACKTRACE_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),backtrace)\n+BACKTRACE_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(BACKTRACE_NAME_$(1))\n+BACKTRACE_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/libbacktrace\n+\n+ifeq ($$(findstring darwin,$$(OSTYPE_$(1))),darwin)\n+\n+# We don't use this on platforms that aren't linux-based, so just make the file\n+# available, the compilation of libstd won't actually build it.\n+$$(BACKTRACE_LIB_$(1)):\n+\ttouch $$@\n+\n+else\n+ifeq ($$(CFG_WINDOWSY_$(1)),1)\n+$$(BACKTRACE_LIB_$(1)):\n+\ttouch $$@\n+else\n+\n+ifdef CFG_ENABLE_FAST_MAKE\n+BACKTRACE_DEPS := $(S)/.gitmodules\n+else\n+BACKTRACE_DEPS := $(wildcard $(S)src/libbacktrace/*)\n+endif\n+\n+# We need to export CFLAGS because otherwise it doesn't pick up cross compile\n+# builds. If libbacktrace doesn't realize this, it will attempt to read 64-bit\n+# elf headers when compiled for a 32-bit system, yielding blank backtraces.\n+#\n+# This also removes the -Werror flag specifically to prevent errors during\n+# configuration.\n+#\n+# Down below you'll also see echos into the config.h generated by the\n+# ./configure script. This is done to force libbacktrace to *not* use the\n+# atomic/sync functionality because it pulls in unnecessary dependencies and we\n+# never use it anyway.\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: \\\n+\t\texport CFLAGS:=$$(CFG_GCCISH_CFLAGS_$(1):-Werror=) \\\n+\t\t\t\t-fno-stack-protector\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: export CC:=$$(CC_$(1))\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: export AR:=$$(AR_$(1))\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: export RANLIB:=$$(AR_$(1)) s\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: $$(BACKTRACE_DEPS) $$(MKFILE_DEPS)\n+\t$$(Q)rm -rf $$(BACKTRACE_BUILD_DIR_$(1))\n+\t$$(Q)mkdir -p $$(BACKTRACE_BUILD_DIR_$(1))\n+\t$$(Q)(cd $$(BACKTRACE_BUILD_DIR_$(1)) && \\\n+\t      $(S)src/libbacktrace/configure --target=$(1) --host=$(CFG_BUILD))\n+\t$$(Q)echo '#undef HAVE_ATOMIC_FUNCTIONS' >> \\\n+\t      $$(BACKTRACE_BUILD_DIR_$(1))/config.h\n+\t$$(Q)echo '#undef HAVE_SYNC_FUNCTIONS' >> \\\n+\t      $$(BACKTRACE_BUILD_DIR_$(1))/config.h\n+\n+$$(BACKTRACE_LIB_$(1)): $$(BACKTRACE_BUILD_DIR_$(1))/Makefile $$(MKFILE_DEPS)\n+\t@$$(call E, make: libbacktrace)\n+\t$$(Q)$$(MAKE) -C $$(BACKTRACE_BUILD_DIR_$(1)) \\\n+\t\tINCDIR=$(S)src/libbacktrace\n+\t$$(Q)cp $$(BACKTRACE_BUILD_DIR_$(1))/.libs/libbacktrace.a $$@\n+\n+endif # endif for windowsy\n+endif # endif for darwin\n+\n endef\n \n # Instantiate template for all stages/targets"}, {"sha": "22d686b1b0e24a6ae94f23a65a22d4b9a583f107", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -240,6 +240,7 @@ tidy:\n \t\t| grep '^$(S)src/libuv' -v \\\n \t\t| grep '^$(S)src/llvm' -v \\\n \t\t| grep '^$(S)src/gyp' -v \\\n+\t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n \t\t$(Q)find $(S)src/etc -name '*.py' \\\n \t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n@@ -266,6 +267,7 @@ tidy:\n \t\t| grep '^$(S)src/etc' -v \\\n \t\t| grep '^$(S)src/doc' -v \\\n \t\t| grep '^$(S)src/compiler-rt' -v \\\n+\t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n \n endif"}, {"sha": "fc91d8189f017baba88d08338fe5938a1e2513d8", "filename": "src/libstd/rt/backtrace.rs", "status": "added", "additions": 714, "deletions": 0, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -0,0 +1,714 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(non_camel_case_types)];\n+\n+use char::Char;\n+use container::Container;\n+use from_str::from_str;\n+use io::{IoResult, Writer};\n+use iter::Iterator;\n+use option::{Some, None};\n+use result::{Ok, Err};\n+use str::StrSlice;\n+\n+pub use self::imp::write;\n+\n+// This function is defined in this module so that the way to enable logging of\n+// backtraces has the word 'backtrace' in it: std::rt::backtrace.\n+pub fn log_enabled() -> bool {\n+    log_enabled!(::logging::DEBUG)\n+}\n+\n+#[cfg(target_word_size = \"64\")] static HEX_WIDTH: uint = 18;\n+#[cfg(target_word_size = \"32\")] static HEX_WIDTH: uint = 10;\n+\n+// All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n+// assemblers, however, can't handle these characters in symbol names. To get\n+// around this, we use C++-style mangling. The mangling method is:\n+//\n+// 1. Prefix the symbol with \"_ZN\"\n+// 2. For each element of the path, emit the length plus the element\n+// 3. End the path with \"E\"\n+//\n+// For example, \"_ZN4testE\" => \"test\" and \"_ZN3foo3bar\" => \"foo::bar\".\n+//\n+// We're the ones printing our backtraces, so we can't rely on anything else to\n+// demangle our symbols. It's *much* nicer to look at demangled symbols, so\n+// this function is implemented to give us nice pretty output.\n+//\n+// Note that this demangler isn't quite as fancy as it could be. We have lots\n+// of other information in our symbols like hashes, version, type information,\n+// etc. Additionally, this doesn't handle glue symbols at all.\n+fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n+    // First validate the symbol. If it doesn't look like anything we're\n+    // expecting, we just print it literally. Note that we must handle non-rust\n+    // symbols because we could have any function in the backtrace.\n+    let mut valid = true;\n+    if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n+        let mut chars = s.slice(3, s.len() - 1).chars();\n+        while valid {\n+            let mut i = 0;\n+            for c in chars {\n+                if c.is_digit() {\n+                    i = i * 10 + c as uint - '0' as uint;\n+                } else {\n+                    break\n+                }\n+            }\n+            if i == 0 {\n+                valid = chars.next().is_none();\n+                break\n+            } else if chars.by_ref().take(i - 1).len() != i - 1 {\n+                valid = false;\n+            }\n+        }\n+    } else {\n+        valid = false;\n+    }\n+\n+    // Alright, let's do this.\n+    if !valid {\n+        try!(writer.write_str(s));\n+    } else {\n+        let mut s = s.slice_from(3);\n+        let mut first = true;\n+        while s.len() > 1 {\n+            if !first {\n+                try!(writer.write_str(\"::\"));\n+            } else {\n+                first = false;\n+            }\n+            let mut rest = s;\n+            while rest.char_at(0).is_digit() {\n+                rest = rest.slice_from(1);\n+            }\n+            let i: uint = from_str(s.slice_to(s.len() - rest.len())).unwrap();\n+            try!(writer.write_str(rest.slice_to(i)));\n+            s = rest.slice_from(i);\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Backtrace support built on libgcc with some extra OS-specific support\n+///\n+/// Some methods of getting a backtrace:\n+///\n+/// * The backtrace() functions on unix. It turns out this doesn't work very\n+///   well for green threads on OSX, and the address to symbol portion of it\n+///   suffers problems that are described below.\n+///\n+/// * Using libunwind. This is more difficult than it sounds because libunwind\n+///   isn't installed everywhere by default. It's also a bit of a hefty library,\n+///   so possibly not the best option. When testing, libunwind was excellent at\n+///   getting both accurate backtraces and accurate symbols across platforms.\n+///   This route was not chosen in favor of the next option, however.\n+///\n+/// * We're already using libgcc_s for exceptions in rust (triggering task\n+///   unwinding and running destructors on the stack), and it turns out that it\n+///   conveniently comes with a function that also gives us a backtrace. All of\n+///   these functions look like _Unwind_*, but it's not quite the full\n+///   repertoire of the libunwind API. Due to it already being in use, this was\n+///   the chosen route of getting a backtrace.\n+///\n+/// After choosing libgcc_s for backtraces, the sad part is that it will only\n+/// give us a stack trace of instruction pointers. Thankfully these instruction\n+/// pointers are accurate (they work for green and native threads), but it's\n+/// then up to us again to figure out how to translate these addresses to\n+/// symbols. As with before, we have a few options. Before, that, a little bit\n+/// of an interlude about symbols. This is my very limited knowledge about\n+/// symbol tables, and this information is likely slightly wrong, but the\n+/// general idea should be correct.\n+///\n+/// When talking about symbols, it's helpful to know a few things about where\n+/// symbols are located. Some symbols are located in the dynamic symbol table\n+/// of the executable which in theory means that they're available for dynamic\n+/// linking and lookup. Other symbols end up only in the local symbol table of\n+/// the file. This loosely corresponds to pub and priv functions in Rust.\n+///\n+/// Armed with this knowledge, we know that our solution for address to symbol\n+/// translation will need to consult both the local and dynamic symbol tables.\n+/// With that in mind, here's our options of translating an address to\n+/// a symbol.\n+///\n+/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n+///   behind the scenes to translate, and this is why backtrace() was not used.\n+///   Conveniently, this method works fantastically on OSX. It appears dladdr()\n+///   uses magic to consult the local symbol table, or we're putting everything\n+///   in the dynamic symbol table anyway. Regardless, for OSX, this is the\n+///   method used for translation. It's provided by the system and easy to do.o\n+///\n+///   Sadly, all other systems have a dladdr() implementation that does not\n+///   consult the local symbol table. This means that most functions are blank\n+///   because they don't have symbols. This means that we need another solution.\n+///\n+/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n+///   libgcc_s version of the libunwind api), but involves taking a dependency\n+///   to libunwind. We may pursue this route in the future if we bundle\n+///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n+///   this time to provide this functionality.\n+///\n+/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n+///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n+///   so in theory it could invoke readelf, parse the output, and consult the\n+///   local/dynamic symbol tables from there. This ended up not getting chosen\n+///   due to the craziness of the idea plus the advent of the next option.\n+///\n+/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n+///   the gcc repository which provides backtrace and symbol translation\n+///   functionality. All we really need from it is the backtrace functionality,\n+///   and we only really need this on everything that's not OSX, so this is the\n+///   chosen route for now.\n+///\n+/// In summary, the current situation uses libgcc_s to get a trace of stack\n+/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n+/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n+/// all unix platforms we support right now, so it at least gets the job done.\n+#[cfg(unix)]\n+mod imp {\n+    use c_str::CString;\n+    use cast;\n+    use io::{IoResult, IoError, Writer};\n+    use libc;\n+    use option::{Some, None, Option};\n+    use result::{Ok, Err};\n+    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use uw = rt::libunwind;\n+\n+    struct Context<'a> {\n+        idx: int,\n+        writer: &'a mut Writer,\n+        last_error: Option<IoError>,\n+    }\n+\n+    #[inline(never)] // if we know this is a function call, we can skip it when\n+                     // tracing\n+    pub fn write(w: &mut Writer) -> IoResult<()> {\n+        // When using libbacktrace, we use some necessary global state, so we\n+        // need to prevent more than one thread from entering this block. This\n+        // is semi-reasonable in terms of printing anyway, and we know that all\n+        // I/O done here is blocking I/O, not green I/O, so we don't have to\n+        // worry about this being a native vs green mutex.\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        let _g = unsafe { LOCK.lock() };\n+\n+        try!(writeln!(w, \"stack backtrace:\"));\n+\n+        let mut cx = Context { writer: w, last_error: None, idx: 0 };\n+        return match unsafe {\n+            uw::_Unwind_Backtrace(trace_fn,\n+                                  &mut cx as *mut Context as *libc::c_void)\n+        } {\n+            uw::_URC_NO_REASON => {\n+                match cx.last_error {\n+                    Some(err) => Err(err),\n+                    None => Ok(())\n+                }\n+            }\n+            _ => Ok(()),\n+        };\n+\n+        extern fn trace_fn(ctx: *uw::_Unwind_Context,\n+                           arg: *libc::c_void) -> uw::_Unwind_Reason_Code {\n+            let cx: &mut Context = unsafe { cast::transmute(arg) };\n+            let ip = unsafe { uw::_Unwind_GetIP(ctx) as *libc::c_void };\n+            // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n+            // it appears to work fine without it, so we only use\n+            // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n+            // slightly more accurate stack trace in the process.\n+            //\n+            // This is often because failure involves the last instruction of a\n+            // function being \"call std::rt::begin_unwind\", with no ret\n+            // instructions after it. This means that the return instruction\n+            // pointer points *outside* of the calling function, and by\n+            // unwinding it we go back to the original function.\n+            let ip = if cfg!(target_os = \"macos\") {\n+                ip\n+            } else {\n+                unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n+            };\n+\n+            // Don't print out the first few frames (they're not user frames)\n+            cx.idx += 1;\n+            if cx.idx <= 0 { return uw::_URC_NO_REASON }\n+            // Don't print ginormous backtraces\n+            if cx.idx > 100 {\n+                match write!(cx.writer, \" ... <frames omitted>\\n\") {\n+                    Ok(()) => {}\n+                    Err(e) => { cx.last_error = Some(e); }\n+                }\n+                return uw::_URC_FAILURE\n+            }\n+\n+            // Once we hit an error, stop trying to print more frames\n+            if cx.last_error.is_some() { return uw::_URC_FAILURE }\n+\n+            match print(cx.writer, cx.idx, ip) {\n+                Ok(()) => {}\n+                Err(e) => { cx.last_error = Some(e); }\n+            }\n+\n+            // keep going\n+            return uw::_URC_NO_REASON\n+        }\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n+        use intrinsics;\n+        struct Dl_info {\n+            dli_fname: *libc::c_char,\n+            dli_fbase: *libc::c_void,\n+            dli_sname: *libc::c_char,\n+            dli_saddr: *libc::c_void,\n+        }\n+        extern {\n+            fn dladdr(addr: *libc::c_void,\n+                      info: *mut Dl_info) -> libc::c_int;\n+        }\n+\n+        let mut info: Dl_info = unsafe { intrinsics::init() };\n+        if unsafe { dladdr(addr, &mut info) == 0 } {\n+            output(w, idx,addr, None)\n+        } else {\n+            output(w, idx, addr, Some(unsafe {\n+                CString::new(info.dli_sname, false)\n+            }))\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"macos\"))]\n+    fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n+        use container::Container;\n+        use iter::Iterator;\n+        use os;\n+        use path::GenericPath;\n+        use ptr::RawPtr;\n+        use ptr;\n+        use vec::{ImmutableVector, MutableVector};\n+\n+        ////////////////////////////////////////////////////////////////////////\n+        // libbacktrace.h API\n+        ////////////////////////////////////////////////////////////////////////\n+        type backtrace_syminfo_callback =\n+            extern \"C\" fn(data: *mut libc::c_void,\n+                          pc: libc::uintptr_t,\n+                          symname: *libc::c_char,\n+                          symval: libc::uintptr_t,\n+                          symsize: libc::uintptr_t);\n+        type backtrace_error_callback =\n+            extern \"C\" fn(data: *mut libc::c_void,\n+                          msg: *libc::c_char,\n+                          errnum: libc::c_int);\n+        enum backtrace_state {}\n+        #[link(name = \"backtrace\", kind = \"static\")]\n+        extern {\n+            fn backtrace_create_state(filename: *libc::c_char,\n+                                      threaded: libc::c_int,\n+                                      error: backtrace_error_callback,\n+                                      data: *mut libc::c_void)\n+                                            -> *mut backtrace_state;\n+            fn backtrace_syminfo(state: *mut backtrace_state,\n+                                 addr: libc::uintptr_t,\n+                                 cb: backtrace_syminfo_callback,\n+                                 error: backtrace_error_callback,\n+                                 data: *mut libc::c_void) -> libc::c_int;\n+        }\n+\n+        ////////////////////////////////////////////////////////////////////////\n+        // helper callbacks\n+        ////////////////////////////////////////////////////////////////////////\n+\n+        extern fn error_cb(_data: *mut libc::c_void, _msg: *libc::c_char,\n+                           _errnum: libc::c_int) {\n+            // do nothing for now\n+        }\n+        extern fn syminfo_cb(data: *mut libc::c_void,\n+                             _pc: libc::uintptr_t,\n+                             symname: *libc::c_char,\n+                             _symval: libc::uintptr_t,\n+                             _symsize: libc::uintptr_t) {\n+            let slot = data as *mut *libc::c_char;\n+            unsafe { *slot = symname; }\n+        }\n+\n+        // The libbacktrace API supports creating a state, but it does not\n+        // support destroying a state. I personally take this to mean that a\n+        // state is meant to be created and then live forever.\n+        //\n+        // I would love to register an at_exit() handler which cleans up this\n+        // state, but libbacktrace provides no way to do so.\n+        //\n+        // With these constraints, this function has a statically cached state\n+        // that is calculated the first time this is requested. Remember that\n+        // backtracing all happens serially (one global lock).\n+        //\n+        // An additionally oddity in this function is that we initialize the\n+        // filename via self_exe_name() to pass to libbacktrace. It turns out\n+        // that on linux libbacktrace seamlessly gets the filename of the\n+        // current executable, but this fails on freebsd. by always providing\n+        // it, we make sure that libbacktrace never has a reason to not look up\n+        // the symbols. The libbacktrace API also states that the filename must\n+        // be in \"permanent memory\", so we copy it to a static and then use the\n+        // static as the pointer.\n+        unsafe fn init_state() -> *mut backtrace_state {\n+            static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n+            static mut LAST_FILENAME: [libc::c_char, ..256] = [0, ..256];\n+            if !STATE.is_null() { return STATE }\n+            let selfname = if cfg!(target_os = \"freebsd\") {\n+                os::self_exe_name()\n+            } else {\n+                None\n+            };\n+            let filename = match selfname {\n+                Some(path) => {\n+                    let bytes = path.as_vec();\n+                    if bytes.len() < LAST_FILENAME.len() {\n+                        let i = bytes.iter();\n+                        for (slot, val) in LAST_FILENAME.mut_iter().zip(i) {\n+                            *slot = *val as libc::c_char;\n+                        }\n+                        LAST_FILENAME.as_ptr()\n+                    } else {\n+                        ptr::null()\n+                    }\n+                }\n+                None => ptr::null(),\n+            };\n+            STATE = backtrace_create_state(filename, 0, error_cb,\n+                                           ptr::mut_null());\n+            return STATE\n+        }\n+\n+        ////////////////////////////////////////////////////////////////////////\n+        // translation\n+        ////////////////////////////////////////////////////////////////////////\n+\n+        // backtrace errors are currently swept under the rug, only I/O\n+        // errors are reported\n+        let state = unsafe { init_state() };\n+        if state.is_null() {\n+            return output(w, idx, addr, None)\n+        }\n+        let mut data = 0 as *libc::c_char;\n+        let data_addr = &mut data as *mut *libc::c_char;\n+        let ret = unsafe {\n+            backtrace_syminfo(state, addr as libc::uintptr_t,\n+                              syminfo_cb, error_cb,\n+                              data_addr as *mut libc::c_void)\n+        };\n+        if ret == 0 || data.is_null() {\n+            output(w, idx, addr, None)\n+        } else {\n+            output(w, idx, addr, Some(unsafe { CString::new(data, false) }))\n+        }\n+    }\n+\n+    // Finally, after all that work above, we can emit a symbol.\n+    fn output(w: &mut Writer, idx: int, addr: *libc::c_void,\n+              s: Option<CString>) -> IoResult<()> {\n+        try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, super::HEX_WIDTH));\n+        match s.as_ref().and_then(|c| c.as_str()) {\n+            Some(string) => try!(super::demangle(w, string)),\n+            None => try!(write!(w, \"<unknown>\")),\n+        }\n+        w.write(['\\n' as u8])\n+    }\n+}\n+\n+/// As always, windows has something very different than unix, we mainly want\n+/// to avoid having to depend too much on libunwind for windows.\n+///\n+/// If you google around, you'll find a fair bit of references to built-in\n+/// functions to get backtraces on windows. It turns out that most of these are\n+/// in an external library called dbghelp. I was unable to find this library\n+/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n+/// of it.\n+///\n+/// You'll also find that there's a function called CaptureStackBackTrace\n+/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n+/// copy of that function in my mingw install (maybe it was broken?). Instead,\n+/// this takes the route of using StackWalk64 in order to walk the stack.\n+#[cfg(windows)]\n+#[allow(dead_code, uppercase_variables)]\n+mod imp {\n+    use c_str::CString;\n+    use container::Container;\n+    use io::{IoResult, Writer};\n+    use iter::Iterator;\n+    use libc;\n+    use mem;\n+    use ops::Drop;\n+    use option::{Some, None};\n+    use path::Path;\n+    use result::{Ok, Err};\n+    use str::StrSlice;\n+    use unstable::dynamic_lib::DynamicLibrary;\n+    use intrinsics;\n+    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use vec::ImmutableVector;\n+\n+    extern \"system\" {\n+        fn GetCurrentProcess() -> libc::HANDLE;\n+        fn GetCurrentThread() -> libc::HANDLE;\n+        fn RtlCaptureContext(ctx: *mut arch::CONTEXT);\n+    }\n+\n+    type SymFromAddrFn =\n+        extern \"system\" fn(libc::HANDLE, u64, *mut u64,\n+                           *mut SYMBOL_INFO) -> libc::BOOL;\n+    type SymInitializeFn =\n+        extern \"system\" fn(libc::HANDLE, *libc::c_void,\n+                           libc::BOOL) -> libc::BOOL;\n+    type SymCleanupFn =\n+        extern \"system\" fn(libc::HANDLE) -> libc::BOOL;\n+\n+    type StackWalk64Fn =\n+        extern \"system\" fn(libc::DWORD, libc::HANDLE, libc::HANDLE,\n+                           *mut STACKFRAME64, *mut arch::CONTEXT,\n+                           *libc::c_void, *libc::c_void,\n+                           *libc::c_void, *libc::c_void) -> libc::BOOL;\n+\n+    static MAX_SYM_NAME: uint = 2000;\n+    static IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n+    static IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n+    static IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n+\n+    #[packed]\n+    struct SYMBOL_INFO {\n+        SizeOfStruct: libc::c_ulong,\n+        TypeIndex: libc::c_ulong,\n+        Reserved: [u64, ..2],\n+        Index: libc::c_ulong,\n+        Size: libc::c_ulong,\n+        ModBase: u64,\n+        Flags: libc::c_ulong,\n+        Value: u64,\n+        Address: u64,\n+        Register: libc::c_ulong,\n+        Scope: libc::c_ulong,\n+        Tag: libc::c_ulong,\n+        NameLen: libc::c_ulong,\n+        MaxNameLen: libc::c_ulong,\n+        // note that windows has this as 1, but it basically just means that\n+        // the name is inline at the end of the struct. For us, we just bump\n+        // the struct size up to MAX_SYM_NAME.\n+        Name: [libc::c_char, ..MAX_SYM_NAME],\n+    }\n+\n+    #[repr(C)]\n+    enum ADDRESS_MODE {\n+        AddrMode1616,\n+        AddrMode1632,\n+        AddrModeReal,\n+        AddrModeFlat,\n+    }\n+\n+    struct ADDRESS64 {\n+        Offset: u64,\n+        Segment: u16,\n+        Mode: ADDRESS_MODE,\n+    }\n+\n+    struct STACKFRAME64 {\n+        AddrPC: ADDRESS64,\n+        AddrReturn: ADDRESS64,\n+        AddrFrame: ADDRESS64,\n+        AddrStack: ADDRESS64,\n+        AddrBStore: ADDRESS64,\n+        FuncTableEntry: *libc::c_void,\n+        Params: [u64, ..4],\n+        Far: libc::BOOL,\n+        Virtual: libc::BOOL,\n+        Reserved: [u64, ..3],\n+        KdHelp: KDHELP64,\n+    }\n+\n+    struct KDHELP64 {\n+        Thread: u64,\n+        ThCallbackStack: libc::DWORD,\n+        ThCallbackBStore: libc::DWORD,\n+        NextCallback: libc::DWORD,\n+        FramePointer: libc::DWORD,\n+        KiCallUserMode: u64,\n+        KeUserCallbackDispatcher: u64,\n+        SystemRangeStart: u64,\n+        KiUserExceptionDispatcher: u64,\n+        StackBase: u64,\n+        StackLimit: u64,\n+        Reserved: [u64, ..5],\n+    }\n+\n+    #[cfg(target_arch = \"x86\")]\n+    mod arch {\n+        use libc;\n+\n+        static MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n+\n+        pub struct CONTEXT {\n+            ContextFlags: libc::DWORD,\n+            Dr0: libc::DWORD,\n+            Dr1: libc::DWORD,\n+            Dr2: libc::DWORD,\n+            Dr3: libc::DWORD,\n+            Dr6: libc::DWORD,\n+            Dr7: libc::DWORD,\n+            FloatSave: FLOATING_SAVE_AREA,\n+            SegGs: libc::DWORD,\n+            SegFs: libc::DWORD,\n+            SegEs: libc::DWORD,\n+            SegDs: libc::DWORD,\n+            Edi: libc::DWORD,\n+            Esi: libc::DWORD,\n+            Ebx: libc::DWORD,\n+            Edx: libc::DWORD,\n+            Ecx: libc::DWORD,\n+            Eax: libc::DWORD,\n+            Ebp: libc::DWORD,\n+            Eip: libc::DWORD,\n+            SegCs: libc::DWORD,\n+            EFlags: libc::DWORD,\n+            Esp: libc::DWORD,\n+            SegSs: libc::DWORD,\n+            ExtendedRegisters: [u8, ..MAXIMUM_SUPPORTED_EXTENSION],\n+        }\n+\n+        pub struct FLOATING_SAVE_AREA {\n+            ControlWord: libc::DWORD,\n+            StatusWord: libc::DWORD,\n+            TagWord: libc::DWORD,\n+            ErrorOffset: libc::DWORD,\n+            ErrorSelector: libc::DWORD,\n+            DataOffset: libc::DWORD,\n+            DataSelector: libc::DWORD,\n+            RegisterArea: [u8, ..80],\n+            Cr0NpxState: libc::DWORD,\n+        }\n+\n+        pub fn init_frame(frame: &mut super::STACKFRAME64,\n+                          ctx: &CONTEXT) -> libc::DWORD {\n+            frame.AddrPC.Offset = ctx.Eip as u64;\n+            frame.AddrPC.Mode = super::AddrModeFlat;\n+            frame.AddrStack.Offset = ctx.Esp as u64;\n+            frame.AddrStack.Mode = super::AddrModeFlat;\n+            frame.AddrFrame.Offset = ctx.Ebp as u64;\n+            frame.AddrFrame.Mode = super::AddrModeFlat;\n+            super::IMAGE_FILE_MACHINE_I386\n+        }\n+    }\n+\n+    struct Cleanup {\n+        handle: libc::HANDLE,\n+        SymCleanup: SymCleanupFn,\n+    }\n+\n+    impl Drop for Cleanup {\n+        fn drop(&mut self) { (self.SymCleanup)(self.handle); }\n+    }\n+\n+    pub fn write(w: &mut Writer) -> IoResult<()> {\n+        // According to windows documentation, all dbghelp functions are\n+        // single-threaded.\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        let _g = unsafe { LOCK.lock() };\n+\n+        // Open up dbghelp.dll, we don't link to it explicitly because it can't\n+        // always be found. Additionally, it's nice having fewer dependencies.\n+        let path = Path::new(\"dbghelp.dll\");\n+        let lib = match DynamicLibrary::open(Some(&path)) {\n+            Ok(lib) => lib,\n+            Err(..) => return Ok(()),\n+        };\n+\n+        macro_rules! sym( ($e:expr, $t:ident) => (\n+            match unsafe { lib.symbol::<$t>($e) } {\n+                Ok(f) => f,\n+                Err(..) => return Ok(())\n+            }\n+        ) )\n+\n+        // Fetch the symbols necessary from dbghelp.dll\n+        let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);\n+        let SymInitialize = sym!(\"SymInitialize\", SymInitializeFn);\n+        let SymCleanup = sym!(\"SymCleanup\", SymCleanupFn);\n+        let StackWalk64 = sym!(\"StackWalk64\", StackWalk64Fn);\n+\n+        // Allocate necessary structures for doing the stack walk\n+        let process = unsafe { GetCurrentProcess() };\n+        let thread = unsafe { GetCurrentThread() };\n+        let mut context: arch::CONTEXT = unsafe { intrinsics::init() };\n+        unsafe { RtlCaptureContext(&mut context); }\n+        let mut frame: STACKFRAME64 = unsafe { intrinsics::init() };\n+        let image = arch::init_frame(&mut frame, &context);\n+\n+        // Initialize this process's symbols\n+        let ret = SymInitialize(process, 0 as *libc::c_void, libc::TRUE);\n+        if ret != libc::TRUE { return Ok(()) }\n+        let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n+\n+        // And now that we're done with all the setup, do the stack walking!\n+        let mut i = 0;\n+        try!(write!(w, \"stack backtrace:\\n\"));\n+        while StackWalk64(image, process, thread, &mut frame, &mut context,\n+                          0 as *libc::c_void, 0 as *libc::c_void,\n+                          0 as *libc::c_void, 0 as *libc::c_void) == libc::TRUE{\n+            let addr = frame.AddrPC.Offset;\n+            if addr == frame.AddrReturn.Offset || addr == 0 ||\n+               frame.AddrReturn.Offset == 0 { break }\n+\n+            i += 1;\n+            try!(write!(w, \"  {:2}: {:#2$x}\", i, addr, super::HEX_WIDTH));\n+            let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n+            info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n+            info.SizeOfStruct = (mem::size_of::<SYMBOL_INFO>() -\n+                                 info.Name.len() + 1) as libc::c_ulong;\n+\n+            let mut displacement = 0u64;\n+            let ret = SymFromAddr(process, addr as u64, &mut displacement,\n+                                  &mut info);\n+\n+            if ret == libc::TRUE {\n+                try!(write!(w, \" - \"));\n+                let cstr = unsafe { CString::new(info.Name.as_ptr(), false) };\n+                let bytes = cstr.as_bytes();\n+                match cstr.as_str() {\n+                    Some(s) => try!(super::demangle(w, s)),\n+                    None => try!(w.write(bytes.slice_to(bytes.len() - 1))),\n+                }\n+            }\n+            try!(w.write(['\\n' as u8]));\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use io::MemWriter;\n+    use str;\n+\n+    #[test]\n+    fn demangle() {\n+        macro_rules! t( ($a:expr, $b:expr) => ({\n+            let mut m = MemWriter::new();\n+            super::demangle(&mut m, $a);\n+            assert_eq!(str::from_utf8_owned(m.unwrap()).unwrap(), $b.to_owned());\n+        }) )\n+\n+        t!(\"test\", \"test\");\n+        t!(\"_ZN4testE\", \"test\");\n+        t!(\"_ZN4test\", \"_ZN4test\");\n+        t!(\"_ZN4test1a2bcE\", \"test::a::bc\");\n+    }\n+}"}, {"sha": "bdb049fbb5f7fe30b4a8c6a646785e4d60580252", "filename": "src/libstd/rt/libunwind.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unwind library interface\n+\n+#[allow(non_camel_case_types)];\n+#[allow(dead_code)]; // these are just bindings\n+\n+use libc;\n+\n+#[cfg(not(target_arch = \"arm\"))]\n+#[repr(C)]\n+pub enum _Unwind_Action\n+{\n+    _UA_SEARCH_PHASE = 1,\n+    _UA_CLEANUP_PHASE = 2,\n+    _UA_HANDLER_FRAME = 4,\n+    _UA_FORCE_UNWIND = 8,\n+    _UA_END_OF_STACK = 16,\n+}\n+\n+#[cfg(target_arch = \"arm\")]\n+#[repr(C)]\n+pub enum _Unwind_State\n+{\n+  _US_VIRTUAL_UNWIND_FRAME = 0,\n+  _US_UNWIND_FRAME_STARTING = 1,\n+  _US_UNWIND_FRAME_RESUME = 2,\n+  _US_ACTION_MASK = 3,\n+  _US_FORCE_UNWIND = 8,\n+  _US_END_OF_STACK = 16\n+}\n+\n+#[repr(C)]\n+pub enum _Unwind_Reason_Code {\n+    _URC_NO_REASON = 0,\n+    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+    _URC_FATAL_PHASE2_ERROR = 2,\n+    _URC_FATAL_PHASE1_ERROR = 3,\n+    _URC_NORMAL_STOP = 4,\n+    _URC_END_OF_STACK = 5,\n+    _URC_HANDLER_FOUND = 6,\n+    _URC_INSTALL_CONTEXT = 7,\n+    _URC_CONTINUE_UNWIND = 8,\n+    _URC_FAILURE = 9, // used only by ARM EABI\n+}\n+\n+pub type _Unwind_Exception_Class = u64;\n+\n+pub type _Unwind_Word = libc::uintptr_t;\n+\n+#[cfg(target_arch = \"x86\")]\n+pub static unwinder_private_data_size: int = 5;\n+\n+#[cfg(target_arch = \"x86_64\")]\n+pub static unwinder_private_data_size: int = 2;\n+\n+#[cfg(target_arch = \"arm\")]\n+pub static unwinder_private_data_size: int = 20;\n+\n+pub struct _Unwind_Exception {\n+    exception_class: _Unwind_Exception_Class,\n+    exception_cleanup: _Unwind_Exception_Cleanup_Fn,\n+    private: [_Unwind_Word, ..unwinder_private_data_size],\n+}\n+\n+pub enum _Unwind_Context {}\n+\n+pub type _Unwind_Exception_Cleanup_Fn =\n+        extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n+                      exception: *_Unwind_Exception);\n+\n+pub type _Unwind_Trace_Fn =\n+        extern \"C\" fn(ctx: *_Unwind_Context,\n+                      arg: *libc::c_void) -> _Unwind_Reason_Code;\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"win32\")]\n+#[link(name = \"gcc_s\")]\n+extern {}\n+\n+#[cfg(target_os = \"android\")]\n+#[link(name = \"gcc\")]\n+extern {}\n+\n+extern \"C\" {\n+    pub fn _Unwind_RaiseException(exception: *_Unwind_Exception)\n+                -> _Unwind_Reason_Code;\n+    pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n+    pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                             trace_argument: *libc::c_void)\n+                -> _Unwind_Reason_Code;\n+    #[cfg(not(target_os = \"android\"))]\n+    pub fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t;\n+    #[cfg(not(target_os = \"android\"))]\n+    pub fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void;\n+}\n+\n+// On android, the function _Unwind_GetIP is a macro, and this is the expansion\n+// of the macro. This is all copy/pasted directly from the header file with the\n+// definition of _Unwind_GetIP.\n+#[cfg(target_os = \"android\")]\n+pub unsafe fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t {\n+    #[repr(C)]\n+    enum _Unwind_VRS_Result {\n+        _UVRSR_OK = 0,\n+        _UVRSR_NOT_IMPLEMENTED = 1,\n+        _UVRSR_FAILED = 2,\n+    }\n+    #[repr(C)]\n+    enum _Unwind_VRS_RegClass {\n+        _UVRSC_CORE = 0,\n+        _UVRSC_VFP = 1,\n+        _UVRSC_FPA = 2,\n+        _UVRSC_WMMXD = 3,\n+        _UVRSC_WMMXC = 4,\n+    }\n+    #[repr(C)]\n+    enum _Unwind_VRS_DataRepresentation {\n+        _UVRSD_UINT32 = 0,\n+        _UVRSD_VFPX = 1,\n+        _UVRSD_FPAX = 2,\n+        _UVRSD_UINT64 = 3,\n+        _UVRSD_FLOAT = 4,\n+        _UVRSD_DOUBLE = 5,\n+    }\n+\n+    type _Unwind_Word = libc::c_uint;\n+    extern {\n+        fn _Unwind_VRS_Get(ctx: *_Unwind_Context,\n+                           klass: _Unwind_VRS_RegClass,\n+                           word: _Unwind_Word,\n+                           repr: _Unwind_VRS_DataRepresentation,\n+                           data: *mut libc::c_void) -> _Unwind_VRS_Result;\n+    }\n+\n+    let mut val: _Unwind_Word = 0;\n+    let ptr = &mut val as *mut _Unwind_Word;\n+    let _ = _Unwind_VRS_Get(ctx, _UVRSC_CORE, 15, _UVRSD_UINT32,\n+                            ptr as *mut libc::c_void);\n+    (val & !1) as libc::uintptr_t\n+}\n+\n+// This function also doesn't exist on android, so make it a no-op\n+#[cfg(target_os = \"android\")]\n+pub unsafe fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void{\n+    pc\n+}"}, {"sha": "a58826daa494e24f4d385cbd428ae9cf88e39ca8", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -119,6 +119,12 @@ mod thread_local_storage;\n /// Stack unwinding\n pub mod unwind;\n \n+/// The interface to libunwind that rust is using.\n+mod libunwind;\n+\n+/// Simple backtrace functionality (to print on failure)\n+pub mod backtrace;\n+\n /// Just stuff\n mod util;\n "}, {"sha": "3a06075ce484568faee7200188128fb396cc2168", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 22, "deletions": 89, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -65,99 +65,14 @@ use option::{Some, None, Option};\n use prelude::drop;\n use ptr::RawPtr;\n use result::{Err, Ok};\n+use rt::backtrace;\n use rt::local::Local;\n use rt::task::Task;\n use str::Str;\n use task::TaskResult;\n use intrinsics;\n \n-use uw = self::libunwind;\n-\n-#[allow(dead_code)]\n-mod libunwind {\n-    //! Unwind library interface\n-\n-    #[allow(non_camel_case_types)];\n-    #[allow(dead_code)]; // these are just bindings\n-\n-    use libc::{uintptr_t};\n-\n-    #[cfg(not(target_arch = \"arm\"))]\n-    #[repr(C)]\n-    pub enum _Unwind_Action\n-    {\n-        _UA_SEARCH_PHASE = 1,\n-        _UA_CLEANUP_PHASE = 2,\n-        _UA_HANDLER_FRAME = 4,\n-        _UA_FORCE_UNWIND = 8,\n-        _UA_END_OF_STACK = 16,\n-    }\n-\n-    #[cfg(target_arch = \"arm\")]\n-    #[repr(C)]\n-    pub enum _Unwind_State\n-    {\n-      _US_VIRTUAL_UNWIND_FRAME = 0,\n-      _US_UNWIND_FRAME_STARTING = 1,\n-      _US_UNWIND_FRAME_RESUME = 2,\n-      _US_ACTION_MASK = 3,\n-      _US_FORCE_UNWIND = 8,\n-      _US_END_OF_STACK = 16\n-    }\n-\n-    #[repr(C)]\n-    pub enum _Unwind_Reason_Code {\n-        _URC_NO_REASON = 0,\n-        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n-        _URC_FATAL_PHASE2_ERROR = 2,\n-        _URC_FATAL_PHASE1_ERROR = 3,\n-        _URC_NORMAL_STOP = 4,\n-        _URC_END_OF_STACK = 5,\n-        _URC_HANDLER_FOUND = 6,\n-        _URC_INSTALL_CONTEXT = 7,\n-        _URC_CONTINUE_UNWIND = 8,\n-        _URC_FAILURE = 9, // used only by ARM EABI\n-    }\n-\n-    pub type _Unwind_Exception_Class = u64;\n-\n-    pub type _Unwind_Word = uintptr_t;\n-\n-    #[cfg(target_arch = \"x86\")]\n-    pub static unwinder_private_data_size: int = 5;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub static unwinder_private_data_size: int = 2;\n-\n-    #[cfg(target_arch = \"arm\")]\n-    pub static unwinder_private_data_size: int = 20;\n-\n-    pub struct _Unwind_Exception {\n-        exception_class: _Unwind_Exception_Class,\n-        exception_cleanup: _Unwind_Exception_Cleanup_Fn,\n-        private: [_Unwind_Word, ..unwinder_private_data_size],\n-    }\n-\n-    pub enum _Unwind_Context {}\n-\n-    pub type _Unwind_Exception_Cleanup_Fn = extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n-                                                          exception: *_Unwind_Exception);\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    #[cfg(target_os = \"win32\")]\n-    #[link(name = \"gcc_s\")]\n-    extern {}\n-\n-    #[cfg(target_os = \"android\")]\n-    #[link(name = \"gcc\")]\n-    extern {}\n-\n-    extern \"C\" {\n-        pub fn _Unwind_RaiseException(exception: *_Unwind_Exception) -> _Unwind_Reason_Code;\n-        pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n-    }\n-}\n+use uw = rt::libunwind;\n \n pub struct Unwinder {\n     priv unwinding: bool,\n@@ -282,7 +197,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n #[doc(hidden)]\n #[allow(visible_private_types)]\n pub mod eabi {\n-    use uw = super::libunwind;\n+    use uw = rt::libunwind;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -336,7 +251,7 @@ pub mod eabi {\n #[cfg(target_arch = \"arm\", not(test))]\n #[allow(visible_private_types)]\n pub mod eabi {\n-    use uw = super::libunwind;\n+    use uw = rt::libunwind;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -480,6 +395,10 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n             Some(t) => t,\n             None => {\n                 rterrln!(\"failed at '{}', {}:{}\", msg_s, file, line);\n+                if backtrace::log_enabled() {\n+                    let mut err = ::rt::util::Stderr;\n+                    let _err = backtrace::write(&mut err);\n+                }\n                 unsafe { intrinsics::abort() }\n             }\n         };\n@@ -499,6 +418,9 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n                     let _err = format_args!(|args| ::fmt::writeln(stderr, args),\n                                             \"task '{}' failed at '{}', {}:{}\",\n                                             n, msg_s, file, line);\n+                    if backtrace::log_enabled() {\n+                        let _err = backtrace::write(stderr);\n+                    }\n                     task = Local::take();\n \n                     match mem::replace(&mut task.stderr, Some(stderr)) {\n@@ -513,6 +435,10 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n                 None => {\n                     rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg_s,\n                              file, line);\n+                    if backtrace::log_enabled() {\n+                        let mut err = ::rt::util::Stderr;\n+                        let _err = backtrace::write(&mut err);\n+                    }\n                 }\n             }\n         }\n@@ -525,6 +451,13 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n             // unwinding or otherwise exiting the task cleanly.\n             rterrln!(\"task failed during unwinding (double-failure - total drag!)\")\n             rterrln!(\"rust must abort now. so sorry.\");\n+\n+            // Don't print the backtrace twice (it would have already been\n+            // printed if logging was enabled).\n+            if !backtrace::log_enabled() {\n+                let mut err = ::rt::util::Stderr;\n+                let _err = backtrace::write(&mut err);\n+            }\n             unsafe { intrinsics::abort() }\n         }\n     }"}, {"sha": "6fe4db5494463cdbca291dc266c339aaeee2797a", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -12,6 +12,7 @@ use container::Container;\n use fmt;\n use from_str::FromStr;\n use io::IoResult;\n+use io;\n use iter::Iterator;\n use libc;\n use option::{Some, None, Option};\n@@ -70,20 +71,20 @@ pub fn default_sched_threads() -> uint {\n     }\n }\n \n-pub fn dumb_println(args: &fmt::Arguments) {\n-    use io;\n+pub struct Stderr;\n \n-    struct Stderr;\n-    impl io::Writer for Stderr {\n-        fn write(&mut self, data: &[u8]) -> IoResult<()> {\n-            unsafe {\n-                libc::write(libc::STDERR_FILENO,\n-                            data.as_ptr() as *libc::c_void,\n-                            data.len() as libc::size_t);\n-            }\n-            Ok(()) // yes, we're lying\n+impl io::Writer for Stderr {\n+    fn write(&mut self, data: &[u8]) -> IoResult<()> {\n+        unsafe {\n+            libc::write(libc::STDERR_FILENO,\n+                        data.as_ptr() as *libc::c_void,\n+                        data.len() as libc::size_t);\n         }\n+        Ok(()) // yes, we're lying\n     }\n+}\n+\n+pub fn dumb_println(args: &fmt::Arguments) {\n     let mut w = Stderr;\n     let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n }\n@@ -140,6 +141,10 @@ memory and partly incapable of presentation to others.\",\n     rterrln!(\"{}\", \"\");\n     rterrln!(\"fatal runtime error: {}\", msg);\n \n+    {\n+        let mut err = Stderr;\n+        let _err = ::rt::backtrace::write(&mut err);\n+    }\n     abort();\n \n     fn abort() -> ! {"}, {"sha": "0e3b33a91d4dc3e99422b8d514fa8a1c5550adc5", "filename": "src/test/run-pass/backtrace.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829df69f9f7a0dd0adbf072a47fd7c7600e75211/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=829df69f9f7a0dd0adbf072a47fd7c7600e75211", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast this is executing itself\n+#[no_uv];\n+\n+extern crate native;\n+\n+use std::os;\n+use std::io::process::{Process, ProcessConfig};\n+use std::unstable::finally::Finally;\n+use std::str;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+\n+#[inline(never)]\n+fn foo() {\n+    fail!()\n+}\n+\n+#[inline(never)]\n+fn double() {\n+    (|| {\n+        fail!(\"once\");\n+    }).finally(|| {\n+        fail!(\"twice\");\n+    })\n+}\n+\n+fn runtest(me: &str) {\n+    let mut env = os::env();\n+    match env.iter().position(|&(ref s, _)| \"RUST_LOG\" == *s) {\n+        Some(i) => { env.remove(i); }\n+        None => {}\n+    }\n+    env.push((~\"RUST_LOG\", ~\"std::rt::backtrace\"));\n+\n+    // Make sure that the stack trace is printed\n+    let mut p = Process::configure(ProcessConfig {\n+        program: me,\n+        args: [~\"fail\"],\n+        env: Some(env.as_slice()),\n+        .. ProcessConfig::new()\n+    }).unwrap();\n+    let out = p.wait_with_output();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(out.error).unwrap();\n+    assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n+            \"bad output: {}\", s);\n+\n+    // Make sure the stack trace is *not* printed\n+    let mut p = Process::configure(ProcessConfig {\n+        program: me,\n+        args: [~\"fail\"],\n+        .. ProcessConfig::new()\n+    }).unwrap();\n+    let out = p.wait_with_output();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(out.error).unwrap();\n+    assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n+            \"bad output2: {}\", s);\n+\n+    // Make sure a stack trace is printed\n+    let mut p = Process::configure(ProcessConfig {\n+        program: me,\n+        args: [~\"double-fail\"],\n+        .. ProcessConfig::new()\n+    }).unwrap();\n+    let out = p.wait_with_output();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(out.error).unwrap();\n+    assert!(s.contains(\"stack backtrace\") && s.contains(\"double::h\"),\n+            \"bad output3: {}\", s);\n+\n+    // Make sure a stack trace isn't printed too many times\n+    let mut p = Process::configure(ProcessConfig {\n+        program: me,\n+        args: [~\"double-fail\"],\n+        env: Some(env.as_slice()),\n+        .. ProcessConfig::new()\n+    }).unwrap();\n+    let out = p.wait_with_output();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(out.error).unwrap();\n+    let mut i = 0;\n+    for _ in range(0, 2) {\n+        i += s.slice_from(i + 10).find_str(\"stack backtrace\").unwrap() + 10;\n+    }\n+    assert!(s.slice_from(i + 10).find_str(\"stack backtrace\").is_none(),\n+            \"bad output4: {}\", s);\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    if args.len() >= 2 && args[1].as_slice() == \"fail\" {\n+        foo();\n+    } else if args.len() >= 2 && args[1].as_slice() == \"double-fail\" {\n+        double();\n+    } else {\n+        runtest(args[0]);\n+    }\n+}"}]}