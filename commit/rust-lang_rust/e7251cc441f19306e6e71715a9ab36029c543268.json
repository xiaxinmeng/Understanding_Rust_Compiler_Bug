{"sha": "e7251cc441f19306e6e71715a9ab36029c543268", "node_id": "C_kwDOAAsO6NoAKGU3MjUxY2M0NDFmMTkzMDZlNmU3MTcxNWE5YWIzNjAyOWM1NDMyNjg", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-12T18:44:28Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-22T15:25:50Z"}, "message": "Extract subdiagnostic attribute parsing", "tree": {"sha": "1949b20e93ff17ec1ece40e3592913b5cdd013f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1949b20e93ff17ec1ece40e3592913b5cdd013f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7251cc441f19306e6e71715a9ab36029c543268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7251cc441f19306e6e71715a9ab36029c543268", "html_url": "https://github.com/rust-lang/rust/commit/e7251cc441f19306e6e71715a9ab36029c543268", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7251cc441f19306e6e71715a9ab36029c543268/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4a1a6f6986fd722506f7019d4ad669e46f15129", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a1a6f6986fd722506f7019d4ad669e46f15129", "html_url": "https://github.com/rust-lang/rust/commit/d4a1a6f6986fd722506f7019d4ad669e46f15129"}], "stats": {"total": 717, "additions": 402, "deletions": 315}, "files": [{"sha": "9ea03e186e72a8fa11c27b7814458e3fe5abf92c", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 42, "deletions": 231, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/e7251cc441f19306e6e71715a9ab36029c543268/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7251cc441f19306e6e71715a9ab36029c543268/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=e7251cc441f19306e6e71715a9ab36029c543268", "patch": "@@ -4,100 +4,16 @@ use crate::diagnostics::error::{\n     span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span,\n-    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n+    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span, FieldInfo,\n+    FieldInnerTy, HasFieldMap, SetOnce,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n-use std::fmt;\n-use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n-use super::utils::SpannedOption;\n-\n-/// Which kind of suggestion is being created?\n-#[derive(Clone, Copy)]\n-enum SubdiagnosticSuggestionKind {\n-    /// `#[suggestion]`\n-    Normal,\n-    /// `#[suggestion_short]`\n-    Short,\n-    /// `#[suggestion_hidden]`\n-    Hidden,\n-    /// `#[suggestion_verbose]`\n-    Verbose,\n-}\n-\n-impl FromStr for SubdiagnosticSuggestionKind {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"\" => Ok(SubdiagnosticSuggestionKind::Normal),\n-            \"_short\" => Ok(SubdiagnosticSuggestionKind::Short),\n-            \"_hidden\" => Ok(SubdiagnosticSuggestionKind::Hidden),\n-            \"_verbose\" => Ok(SubdiagnosticSuggestionKind::Verbose),\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n-impl SubdiagnosticSuggestionKind {\n-    pub fn to_suggestion_style(&self) -> TokenStream {\n-        match self {\n-            SubdiagnosticSuggestionKind::Normal => {\n-                quote! { rustc_errors::SuggestionStyle::ShowCode }\n-            }\n-            SubdiagnosticSuggestionKind::Short => {\n-                quote! { rustc_errors::SuggestionStyle::HideCodeInline }\n-            }\n-            SubdiagnosticSuggestionKind::Hidden => {\n-                quote! { rustc_errors::SuggestionStyle::HideCodeAlways }\n-            }\n-            SubdiagnosticSuggestionKind::Verbose => {\n-                quote! { rustc_errors::SuggestionStyle::ShowAlways }\n-            }\n-        }\n-    }\n-}\n-\n-/// Which kind of subdiagnostic is being created from a variant?\n-#[derive(Clone)]\n-enum SubdiagnosticKind {\n-    /// `#[label(...)]`\n-    Label,\n-    /// `#[note(...)]`\n-    Note,\n-    /// `#[help(...)]`\n-    Help,\n-    /// `#[warning(...)]`\n-    Warn,\n-    /// `#[suggestion{,_short,_hidden,_verbose}]`\n-    Suggestion { suggestion_kind: SubdiagnosticSuggestionKind, code: TokenStream },\n-    /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n-    MultipartSuggestion { suggestion_kind: SubdiagnosticSuggestionKind },\n-}\n-\n-impl quote::IdentFragment for SubdiagnosticKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            SubdiagnosticKind::Label => write!(f, \"label\"),\n-            SubdiagnosticKind::Note => write!(f, \"note\"),\n-            SubdiagnosticKind::Help => write!(f, \"help\"),\n-            SubdiagnosticKind::Warn => write!(f, \"warn\"),\n-            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n-            SubdiagnosticKind::MultipartSuggestion { .. } => {\n-                write!(f, \"multipart_suggestion_with_style\")\n-            }\n-        }\n-    }\n-\n-    fn span(&self) -> Option<proc_macro2::Span> {\n-        None\n-    }\n-}\n+use super::utils::{SpannedOption, SubdiagnosticKind};\n \n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDerive<'a> {\n@@ -198,8 +114,8 @@ struct SubdiagnosticDeriveBuilder<'a> {\n \n     /// Identifier for the binding to the `#[primary_span]` field.\n     span_field: SpannedOption<proc_macro2::Ident>,\n-    /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n-    /// `rustc_errors::Applicability::*` variant directly.\n+\n+    /// The binding to the `#[applicability]` field, if present.\n     applicability: SpannedOption<TokenStream>,\n \n     /// Set to true when a `#[suggestion_part]` field is encountered, used to generate an error\n@@ -219,6 +135,7 @@ struct KindsStatistics {\n     has_multipart_suggestion: bool,\n     all_multipart_suggestions: bool,\n     has_normal_suggestion: bool,\n+    all_applicabilities_static: bool,\n }\n \n impl<'a> FromIterator<&'a SubdiagnosticKind> for KindsStatistics {\n@@ -227,8 +144,15 @@ impl<'a> FromIterator<&'a SubdiagnosticKind> for KindsStatistics {\n             has_multipart_suggestion: false,\n             all_multipart_suggestions: true,\n             has_normal_suggestion: false,\n+            all_applicabilities_static: true,\n         };\n+\n         for kind in kinds {\n+            if let SubdiagnosticKind::MultipartSuggestion { applicability: None, .. }\n+            | SubdiagnosticKind::Suggestion { applicability: None, .. } = kind\n+            {\n+                ret.all_applicabilities_static = false;\n+            }\n             if let SubdiagnosticKind::MultipartSuggestion { .. } = kind {\n                 ret.has_multipart_suggestion = true;\n             } else {\n@@ -248,151 +172,22 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n         let mut kind_slugs = vec![];\n \n         for attr in self.variant.ast().attrs {\n-            let span = attr.span().unwrap();\n-\n-            let name = attr.path.segments.last().unwrap().ident.to_string();\n-            let name = name.as_str();\n-\n-            let meta = attr.parse_meta()?;\n-            let Meta::List(MetaList { ref nested, .. }) = meta else {\n-                throw_invalid_attr!(attr, &meta);\n-            };\n-\n-            let mut kind = match name {\n-                \"label\" => SubdiagnosticKind::Label,\n-                \"note\" => SubdiagnosticKind::Note,\n-                \"help\" => SubdiagnosticKind::Help,\n-                \"warning\" => SubdiagnosticKind::Warn,\n-                _ => {\n-                    if let Some(suggestion_kind) =\n-                        name.strip_prefix(\"suggestion\").and_then(|s| s.parse().ok())\n-                    {\n-                        SubdiagnosticKind::Suggestion { suggestion_kind, code: TokenStream::new() }\n-                    } else if let Some(suggestion_kind) =\n-                        name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n-                    {\n-                        SubdiagnosticKind::MultipartSuggestion { suggestion_kind }\n-                    } else {\n-                        throw_invalid_attr!(attr, &meta);\n-                    }\n-                }\n-            };\n-\n-            let mut slug = None;\n-            let mut code = None;\n-\n-            let mut nested_iter = nested.into_iter();\n-            if let Some(nested_attr) = nested_iter.next() {\n-                match nested_attr {\n-                    NestedMeta::Meta(Meta::Path(path)) => {\n-                        slug.set_once(path.clone(), span);\n-                    }\n-                    NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                        if matches!(\n-                            meta.path().segments.last().unwrap().ident.to_string().as_str(),\n-                            \"code\" | \"applicability\"\n-                        ) =>\n-                    {\n-                        // Don't error for valid follow-up attributes.\n-                    }\n-                    nested_attr => {\n-                        throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                            diag.help(\n-                                \"first argument of the attribute should be the diagnostic \\\n-                                 slug\",\n-                            )\n-                        })\n-                    }\n-                };\n-            }\n+            let (kind, slug) = SubdiagnosticKind::from_attr(attr, self)?;\n \n-            for nested_attr in nested_iter {\n-                let meta = match nested_attr {\n-                    NestedMeta::Meta(ref meta) => meta,\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-                };\n-\n-                let span = meta.span().unwrap();\n-                let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                let nested_name = nested_name.as_str();\n-\n-                let value = match meta {\n-                    Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n-                    Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                    }),\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-                };\n-\n-                match nested_name {\n-                    \"code\" => {\n-                        if matches!(kind, SubdiagnosticKind::Suggestion { .. }) {\n-                            let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once(formatted_str, span);\n-                        } else {\n-                            span_err(\n-                                span,\n-                                &format!(\n-                                    \"`code` is not a valid nested attribute of a `{}` attribute\",\n-                                    name\n-                                ),\n-                            )\n-                            .emit();\n-                        }\n-                    }\n-                    \"applicability\" => {\n-                        if matches!(\n-                            kind,\n-                            SubdiagnosticKind::Suggestion { .. }\n-                                | SubdiagnosticKind::MultipartSuggestion { .. }\n-                        ) {\n-                            let value =\n-                                Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n-                                    span_err(span, \"invalid applicability\").emit();\n-                                    Applicability::Unspecified\n-                                });\n-                            self.applicability.set_once(quote! { #value }, span);\n-                        } else {\n-                            span_err(\n-                                span,\n-                                &format!(\n-                                    \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n-                                    name\n-                                )\n-                            ).emit();\n-                        }\n-                    }\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                        diag.help(\"only `code` and `applicability` are valid nested attributes\")\n-                    }),\n-                }\n-            }\n+            let Some(slug) = slug else {\n+                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = name.as_str();\n \n-            let Some((slug, _)) = slug else {\n                 throw_span_err!(\n-                    span,\n+                    attr.span().unwrap(),\n                     &format!(\n                         \"diagnostic slug must be first argument of a `#[{}(...)]` attribute\",\n                         name\n                     )\n                 );\n             };\n \n-            match kind {\n-                SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n-                    let Some((code, _)) = code else {\n-                        throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\");\n-                    };\n-                    *code_field = code;\n-                }\n-                SubdiagnosticKind::Label\n-                | SubdiagnosticKind::Note\n-                | SubdiagnosticKind::Help\n-                | SubdiagnosticKind::Warn\n-                | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n-            }\n-\n-            kind_slugs.push((kind, slug))\n+            kind_slugs.push((kind, slug));\n         }\n \n         Ok(kind_slugs)\n@@ -510,6 +305,15 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                 if kind_stats.has_multipart_suggestion || kind_stats.has_normal_suggestion {\n                     report_error_if_not_applied_to_applicability(attr, &info)?;\n \n+                    if kind_stats.all_applicabilities_static {\n+                        span_err(\n+                            span,\n+                            \"`#[applicability]` has no effect if all `#[suggestion]`/\\\n+                             `#[multipart_suggestion]` attributes have a static \\\n+                             `applicability = \\\"...\\\"`\",\n+                        )\n+                        .emit();\n+                    }\n                     let binding = info.binding.binding.clone();\n                     self.applicability.set_once(quote! { #binding }, span);\n                 } else {\n@@ -638,19 +442,20 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n             .collect();\n \n         let span_field = self.span_field.value_ref();\n-        let applicability = self\n-            .applicability\n-            .take()\n-            .value()\n-            .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n \n         let diag = &self.diag;\n         let mut calls = TokenStream::new();\n         for (kind, slug) in kind_slugs {\n             let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n             let message = quote! { rustc_errors::fluent::#slug };\n             let call = match kind {\n-                SubdiagnosticKind::Suggestion { suggestion_kind, code } => {\n+                SubdiagnosticKind::Suggestion { suggestion_kind, applicability, code } => {\n+                    let applicability = applicability\n+                        .value()\n+                        .map(|a| quote! { #a })\n+                        .or_else(|| self.applicability.take().value())\n+                        .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n+\n                     if let Some(span) = span_field {\n                         let style = suggestion_kind.to_suggestion_style();\n \n@@ -660,7 +465,13 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                         quote! { unreachable!(); }\n                     }\n                 }\n-                SubdiagnosticKind::MultipartSuggestion { suggestion_kind } => {\n+                SubdiagnosticKind::MultipartSuggestion { suggestion_kind, applicability } => {\n+                    let applicability = applicability\n+                        .value()\n+                        .map(|a| quote! { #a })\n+                        .or_else(|| self.applicability.take().value())\n+                        .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n+\n                     if !self.has_suggestion_parts {\n                         span_err(\n                             self.span,"}, {"sha": "a31bda9ca0def7dfab11df273586e4fc4e5156e0", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 255, "deletions": 1, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/e7251cc441f19306e6e71715a9ab36029c543268/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7251cc441f19306e6e71715a9ab36029c543268/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=e7251cc441f19306e6e71715a9ab36029c543268", "patch": "@@ -1,12 +1,18 @@\n-use crate::diagnostics::error::{span_err, throw_span_err, DiagnosticDeriveError};\n+use crate::diagnostics::error::{\n+    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n+};\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n use std::collections::{BTreeSet, HashMap};\n+use std::fmt;\n use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Meta, Type, TypeTuple};\n+use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure};\n \n+use super::error::invalid_nested_attr;\n+\n /// Checks whether the type name of `ty` matches `name`.\n ///\n /// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n@@ -311,6 +317,7 @@ pub(crate) trait HasFieldMap {\n \n /// `Applicability` of a suggestion - mirrors `rustc_errors::Applicability` - and used to represent\n /// the user's selection of applicability if specified in an attribute.\n+#[derive(Clone, Copy)]\n pub(crate) enum Applicability {\n     MachineApplicable,\n     MaybeIncorrect,\n@@ -367,3 +374,250 @@ pub(crate) fn build_field_mapping<'a>(structure: &Structure<'a>) -> HashMap<Stri\n \n     fields_map\n }\n+\n+/// Possible styles for suggestion subdiagnostics.\n+#[derive(Clone, Copy)]\n+pub(super) enum SuggestionKind {\n+    /// `#[suggestion]`\n+    Normal,\n+    /// `#[suggestion_short]`\n+    Short,\n+    /// `#[suggestion_hidden]`\n+    Hidden,\n+    /// `#[suggestion_verbose]`\n+    Verbose,\n+}\n+\n+impl FromStr for SuggestionKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"\" => Ok(SuggestionKind::Normal),\n+            \"_short\" => Ok(SuggestionKind::Short),\n+            \"_hidden\" => Ok(SuggestionKind::Hidden),\n+            \"_verbose\" => Ok(SuggestionKind::Verbose),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl SuggestionKind {\n+    pub fn to_suggestion_style(&self) -> TokenStream {\n+        match self {\n+            SuggestionKind::Normal => {\n+                quote! { rustc_errors::SuggestionStyle::ShowCode }\n+            }\n+            SuggestionKind::Short => {\n+                quote! { rustc_errors::SuggestionStyle::HideCodeInline }\n+            }\n+            SuggestionKind::Hidden => {\n+                quote! { rustc_errors::SuggestionStyle::HideCodeAlways }\n+            }\n+            SuggestionKind::Verbose => {\n+                quote! { rustc_errors::SuggestionStyle::ShowAlways }\n+            }\n+        }\n+    }\n+}\n+\n+/// Types of subdiagnostics that can be created using attributes\n+#[derive(Clone)]\n+pub(super) enum SubdiagnosticKind {\n+    /// `#[label(...)]`\n+    Label,\n+    /// `#[note(...)]`\n+    Note,\n+    /// `#[help(...)]`\n+    Help,\n+    /// `#[warning(...)]`\n+    Warn,\n+    /// `#[suggestion{,_short,_hidden,_verbose}]`\n+    Suggestion {\n+        suggestion_kind: SuggestionKind,\n+        applicability: SpannedOption<Applicability>,\n+        code: TokenStream,\n+    },\n+    /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n+    MultipartSuggestion {\n+        suggestion_kind: SuggestionKind,\n+        applicability: SpannedOption<Applicability>,\n+    },\n+}\n+\n+impl SubdiagnosticKind {\n+    /// Constructs a `SubdiagnosticKind` from a field or type attribute such as `#[note]`,\n+    /// `#[error(parser::add_paren)]` or `#[suggestion(code = \"...\")]`. Returns the\n+    /// `SubdiagnosticKind` and the diagnostic slug, if specified.\n+    pub(super) fn from_attr(\n+        attr: &Attribute,\n+        fields: &impl HasFieldMap,\n+    ) -> Result<(SubdiagnosticKind, Option<Path>), DiagnosticDeriveError> {\n+        let span = attr.span().unwrap();\n+\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+\n+        let meta = attr.parse_meta()?;\n+        let mut kind = match name {\n+            \"label\" => SubdiagnosticKind::Label,\n+            \"note\" => SubdiagnosticKind::Note,\n+            \"help\" => SubdiagnosticKind::Help,\n+            \"warning\" => SubdiagnosticKind::Warn,\n+            _ => {\n+                if let Some(suggestion_kind) =\n+                    name.strip_prefix(\"suggestion\").and_then(|s| s.parse().ok())\n+                {\n+                    SubdiagnosticKind::Suggestion {\n+                        suggestion_kind,\n+                        applicability: None,\n+                        code: TokenStream::new(),\n+                    }\n+                } else if let Some(suggestion_kind) =\n+                    name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n+                {\n+                    SubdiagnosticKind::MultipartSuggestion { suggestion_kind, applicability: None }\n+                } else {\n+                    throw_invalid_attr!(attr, &meta);\n+                }\n+            }\n+        };\n+\n+        let nested = match meta {\n+            Meta::List(MetaList { ref nested, .. }) => {\n+                // An attribute with properties, such as `#[suggestion(code = \"...\")]` or\n+                // `#[error(some::slug)]`\n+                nested\n+            }\n+            Meta::Path(_) => {\n+                // An attribute without a slug or other properties, such as `#[note]` - return\n+                // without further processing.\n+                //\n+                // Only allow this if there are no mandatory properties, such as `code = \"...\"` in\n+                // `#[suggestion(...)]`\n+                match kind {\n+                    SubdiagnosticKind::Label\n+                    | SubdiagnosticKind::Note\n+                    | SubdiagnosticKind::Help\n+                    | SubdiagnosticKind::Warn\n+                    | SubdiagnosticKind::MultipartSuggestion { .. } => return Ok((kind, None)),\n+                    SubdiagnosticKind::Suggestion { .. } => {\n+                        throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\")\n+                    }\n+                }\n+            }\n+            _ => {\n+                throw_invalid_attr!(attr, &meta)\n+            }\n+        };\n+\n+        let mut code = None;\n+\n+        let mut nested_iter = nested.into_iter().peekable();\n+\n+        // Peek at the first nested attribute: if it's a slug path, consume it.\n+        let slug = if let Some(NestedMeta::Meta(Meta::Path(path))) = nested_iter.peek() {\n+            let path = path.clone();\n+            // Advance the iterator.\n+            nested_iter.next();\n+            Some(path)\n+        } else {\n+            None\n+        };\n+\n+        for nested_attr in nested_iter {\n+            let meta = match nested_attr {\n+                NestedMeta::Meta(ref meta) => meta,\n+                NestedMeta::Lit(_) => {\n+                    invalid_nested_attr(attr, &nested_attr).emit();\n+                    continue;\n+                }\n+            };\n+\n+            let span = meta.span().unwrap();\n+            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+            let nested_name = nested_name.as_str();\n+\n+            let value = match meta {\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n+                Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n+                }),\n+                _ => {\n+                    invalid_nested_attr(attr, &nested_attr).emit();\n+                    continue;\n+                }\n+            };\n+\n+            match (nested_name, &mut kind) {\n+                (\"code\", SubdiagnosticKind::Suggestion { .. }) => {\n+                    let formatted_str = fields.build_format(&value.value(), value.span());\n+                    code.set_once(formatted_str, span);\n+                }\n+                (\n+                    \"applicability\",\n+                    SubdiagnosticKind::Suggestion { ref mut applicability, .. }\n+                    | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n+                ) => {\n+                    let value = Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n+                        span_err(span, \"invalid applicability\").emit();\n+                        Applicability::Unspecified\n+                    });\n+                    applicability.set_once(value, span);\n+                }\n+\n+                // Invalid nested attribute\n+                (_, SubdiagnosticKind::Suggestion { .. }) => {\n+                    invalid_nested_attr(attr, &nested_attr)\n+                        .help(\"only `code` and `applicability` are valid nested attributes\")\n+                        .emit();\n+                }\n+                (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n+                    invalid_nested_attr(attr, &nested_attr)\n+                        .help(\"only `applicability` is a valid nested attributes\")\n+                        .emit()\n+                }\n+                _ => {\n+                    invalid_nested_attr(attr, &nested_attr).emit();\n+                }\n+            }\n+        }\n+\n+        match kind {\n+            SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n+                *code_field = if let Some((code, _)) = code {\n+                    code\n+                } else {\n+                    span_err(span, \"suggestion without `code = \\\"...\\\"`\").emit();\n+                    quote! { \"\" }\n+                }\n+            }\n+            SubdiagnosticKind::Label\n+            | SubdiagnosticKind::Note\n+            | SubdiagnosticKind::Help\n+            | SubdiagnosticKind::Warn\n+            | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n+        }\n+\n+        Ok((kind, slug))\n+    }\n+}\n+\n+impl quote::IdentFragment for SubdiagnosticKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            SubdiagnosticKind::Label => write!(f, \"label\"),\n+            SubdiagnosticKind::Note => write!(f, \"note\"),\n+            SubdiagnosticKind::Help => write!(f, \"help\"),\n+            SubdiagnosticKind::Warn => write!(f, \"warn\"),\n+            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n+            SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                write!(f, \"multipart_suggestion_with_style\")\n+            }\n+        }\n+    }\n+\n+    fn span(&self) -> Option<proc_macro2::Span> {\n+        None\n+    }\n+}"}, {"sha": "606b3b5e5ebca1943bc5e3a74347bf9b75d48d71", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7251cc441f19306e6e71715a9ab36029c543268/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7251cc441f19306e6e71715a9ab36029c543268/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=e7251cc441f19306e6e71715a9ab36029c543268", "patch": "@@ -52,7 +52,7 @@ struct C {\n \n #[derive(Subdiagnostic)]\n #[label]\n-//~^ ERROR `#[label]` is not a valid attribute\n+//~^ ERROR diagnostic slug must be first argument\n struct D {\n     #[primary_span]\n     span: Span,\n@@ -81,6 +81,7 @@ struct F {\n #[derive(Subdiagnostic)]\n #[label(bug = \"...\")]\n //~^ ERROR `#[label(bug = ...)]` is not a valid attribute\n+//~| ERROR diagnostic slug must be first argument\n struct G {\n     #[primary_span]\n     span: Span,\n@@ -90,6 +91,7 @@ struct G {\n #[derive(Subdiagnostic)]\n #[label(\"...\")]\n //~^ ERROR `#[label(\"...\")]` is not a valid attribute\n+//~| ERROR diagnostic slug must be first argument\n struct H {\n     #[primary_span]\n     span: Span,\n@@ -99,6 +101,7 @@ struct H {\n #[derive(Subdiagnostic)]\n #[label(slug = 4)]\n //~^ ERROR `#[label(slug = ...)]` is not a valid attribute\n+//~| ERROR diagnostic slug must be first argument\n struct J {\n     #[primary_span]\n     span: Span,\n@@ -108,6 +111,7 @@ struct J {\n #[derive(Subdiagnostic)]\n #[label(slug(\"...\"))]\n //~^ ERROR `#[label(slug(...))]` is not a valid attribute\n+//~| ERROR diagnostic slug must be first argument\n struct K {\n     #[primary_span]\n     span: Span,\n@@ -135,7 +139,7 @@ struct M {\n \n #[derive(Subdiagnostic)]\n #[label(parser::add_paren, code = \"...\")]\n-//~^ ERROR `code` is not a valid nested attribute of a `label` attribute\n+//~^ ERROR `#[label(code = ...)]` is not a valid attribute\n struct N {\n     #[primary_span]\n     span: Span,\n@@ -144,7 +148,7 @@ struct N {\n \n #[derive(Subdiagnostic)]\n #[label(parser::add_paren, applicability = \"machine-applicable\")]\n-//~^ ERROR `applicability` is not a valid nested attribute of a `label` attribute\n+//~^ ERROR `#[label(applicability = ...)]` is not a valid attribute\n struct O {\n     #[primary_span]\n     span: Span,\n@@ -216,6 +220,7 @@ enum T {\n enum U {\n     #[label(code = \"...\")]\n     //~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n+    //~| ERROR `#[label(code = ...)]` is not a valid attribute\n     A {\n         #[primary_span]\n         span: Span,\n@@ -531,7 +536,7 @@ struct BA {\n #[derive(Subdiagnostic)]\n #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n //~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n-//~| ERROR `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n+//~| ERROR `#[multipart_suggestion(code = ...)]` is not a valid attribute\n struct BBa {\n     var: String,\n }\n@@ -612,10 +617,9 @@ struct BG {\n \n #[derive(Subdiagnostic)]\n #[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-//~^ NOTE previously specified here\n struct BH {\n     #[applicability]\n-    //~^ ERROR specified multiple times\n+    //~^ ERROR `#[applicability]` has no effect\n     appl: Applicability,\n     #[suggestion_part(code = \"(\")]\n     first: Span,"}, {"sha": "171b89e657d81eb12d03766c8ef3325995fc526b", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 95, "deletions": 77, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e7251cc441f19306e6e71715a9ab36029c543268/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7251cc441f19306e6e71715a9ab36029c543268/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=e7251cc441f19306e6e71715a9ab36029c543268", "patch": "@@ -8,7 +8,7 @@ LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: `#[label]` is not a valid attribute\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n   --> $DIR/subdiagnostic-derive.rs:54:1\n    |\n LL | #[label]\n@@ -31,101 +31,123 @@ error: `#[label(bug = ...)]` is not a valid attribute\n    |\n LL | #[label(bug = \"...\")]\n    |         ^^^^^^^^^^^\n+\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:82:1\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[label(bug = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(\"...\")]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:91:9\n+  --> $DIR/subdiagnostic-derive.rs:92:9\n    |\n LL | #[label(\"...\")]\n    |         ^^^^^\n+\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:92:1\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[label(\"...\")]\n+   | ^^^^^^^^^^^^^^^\n \n error: `#[label(slug = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:100:9\n+  --> $DIR/subdiagnostic-derive.rs:102:9\n    |\n LL | #[label(slug = 4)]\n    |         ^^^^^^^^\n+\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:102:1\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[label(slug = 4)]\n+   | ^^^^^^^^^^^^^^^^^^\n \n error: `#[label(slug(...))]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:109:9\n+  --> $DIR/subdiagnostic-derive.rs:112:9\n    |\n LL | #[label(slug(\"...\"))]\n    |         ^^^^^^^^^^^\n+\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:112:1\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[label(slug(\"...\"))]\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:128:1\n+  --> $DIR/subdiagnostic-derive.rs:132:1\n    |\n LL | #[label()]\n    | ^^^^^^^^^^\n \n-error: `code` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:137:28\n+error: `#[label(code = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:141:28\n    |\n LL | #[label(parser::add_paren, code = \"...\")]\n    |                            ^^^^^^^^^^^^\n \n-error: `applicability` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:146:28\n+error: `#[label(applicability = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:150:28\n    |\n LL | #[label(parser::add_paren, applicability = \"machine-applicable\")]\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:155:1\n+  --> $DIR/subdiagnostic-derive.rs:159:1\n    |\n LL | #[foo]\n    | ^^^^^^\n \n error: `#[bar]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:169:5\n+  --> $DIR/subdiagnostic-derive.rs:173:5\n    |\n LL |     #[bar]\n    |     ^^^^^^\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:181:5\n+  --> $DIR/subdiagnostic-derive.rs:185:5\n    |\n LL |     #[bar = \"...\"]\n    |     ^^^^^^^^^^^^^^\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:193:5\n+  --> $DIR/subdiagnostic-derive.rs:197:5\n    |\n LL |     #[bar = 4]\n    |     ^^^^^^^^^^\n \n error: `#[bar(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:205:5\n+  --> $DIR/subdiagnostic-derive.rs:209:5\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n \n+error: `#[label(code = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:221:13\n+   |\n+LL |     #[label(code = \"...\")]\n+   |             ^^^^^^^^^^^^\n+\n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:217:5\n+  --> $DIR/subdiagnostic-derive.rs:221:5\n    |\n LL |     #[label(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:234:5\n+  --> $DIR/subdiagnostic-derive.rs:239:5\n    |\n LL |     B {\n    |     ^\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:246:5\n+  --> $DIR/subdiagnostic-derive.rs:251:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: label without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:243:1\n+  --> $DIR/subdiagnostic-derive.rs:248:1\n    |\n LL | / #[label(parser::add_paren)]\n LL | |\n@@ -137,35 +159,35 @@ LL | | }\n    | |_^\n \n error: `#[applicability]` is only valid on suggestions\n-  --> $DIR/subdiagnostic-derive.rs:256:5\n+  --> $DIR/subdiagnostic-derive.rs:261:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `#[bar]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:266:5\n+  --> $DIR/subdiagnostic-derive.rs:271:5\n    |\n LL |     #[bar]\n    |     ^^^^^^\n    |\n    = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:277:5\n+  --> $DIR/subdiagnostic-derive.rs:282:5\n    |\n LL |     #[bar = \"...\"]\n    |     ^^^^^^^^^^^^^^\n \n error: `#[bar(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:288:5\n+  --> $DIR/subdiagnostic-derive.rs:293:5\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n    |\n    = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: unexpected unsupported untagged union\n-  --> $DIR/subdiagnostic-derive.rs:304:1\n+  --> $DIR/subdiagnostic-derive.rs:309:1\n    |\n LL | / union AC {\n LL | |\n@@ -175,75 +197,75 @@ LL | | }\n    | |_^\n \n error: `#[label(parser::add_paren)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:319:28\n+  --> $DIR/subdiagnostic-derive.rs:324:28\n    |\n LL | #[label(parser::add_paren, parser::add_paren)]\n    |                            ^^^^^^^^^^^^^^^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:332:5\n+  --> $DIR/subdiagnostic-derive.rs:337:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:329:5\n+  --> $DIR/subdiagnostic-derive.rs:334:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:338:8\n+  --> $DIR/subdiagnostic-derive.rs:343:8\n    |\n LL | struct AG {\n    |        ^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:375:47\n+  --> $DIR/subdiagnostic-derive.rs:380:47\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                               ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:375:33\n+  --> $DIR/subdiagnostic-derive.rs:380:33\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                 ^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:393:5\n+  --> $DIR/subdiagnostic-derive.rs:398:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:390:5\n+  --> $DIR/subdiagnostic-derive.rs:395:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n-  --> $DIR/subdiagnostic-derive.rs:403:5\n+  --> $DIR/subdiagnostic-derive.rs:408:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:416:1\n+  --> $DIR/subdiagnostic-derive.rs:421:1\n    |\n LL | #[suggestion(parser::add_paren)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/subdiagnostic-derive.rs:426:46\n+  --> $DIR/subdiagnostic-derive.rs:431:46\n    |\n LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n    |                                              ^^^^^^^^^^^^^^^^^^^^^\n \n error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:444:1\n+  --> $DIR/subdiagnostic-derive.rs:449:1\n    |\n LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n@@ -253,41 +275,41 @@ LL | | }\n    | |_^\n \n error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:458:1\n+  --> $DIR/subdiagnostic-derive.rs:463:1\n    |\n LL | #[label]\n    | ^^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:478:39\n+  --> $DIR/subdiagnostic-derive.rs:483:39\n    |\n LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n    |                                       ^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:497:43\n+  --> $DIR/subdiagnostic-derive.rs:502:43\n    |\n LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n    |                                           ^^^^^^^\n \n error: `#[suggestion_part]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:520:5\n+  --> $DIR/subdiagnostic-derive.rs:525:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\n \n error: `#[suggestion_part(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:523:5\n+  --> $DIR/subdiagnostic-derive.rs:528:5\n    |\n LL |     #[suggestion_part(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[suggestion_part(...)]` is only valid in multipart suggestions\n \n error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:517:1\n+  --> $DIR/subdiagnostic-derive.rs:522:1\n    |\n LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n@@ -298,14 +320,16 @@ LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n-  --> $DIR/subdiagnostic-derive.rs:532:43\n+error: `#[multipart_suggestion(code = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:537:43\n    |\n LL | #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n    |                                           ^^^^^^^^^^^^\n+   |\n+   = help: only `applicability` is a valid nested attributes\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n-  --> $DIR/subdiagnostic-derive.rs:532:1\n+  --> $DIR/subdiagnostic-derive.rs:537:1\n    |\n LL | / #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n LL | |\n@@ -316,27 +340,27 @@ LL | | }\n    | |_^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:542:5\n+  --> $DIR/subdiagnostic-derive.rs:547:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:550:5\n+  --> $DIR/subdiagnostic-derive.rs:555:5\n    |\n LL |     #[suggestion_part()]\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:559:5\n+  --> $DIR/subdiagnostic-derive.rs:564:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: multipart suggestions use one or more `#[suggestion_part]`s rather than one `#[primary_span]`\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n-  --> $DIR/subdiagnostic-derive.rs:556:1\n+  --> $DIR/subdiagnostic-derive.rs:561:1\n    |\n LL | / #[multipart_suggestion(parser::add_paren)]\n LL | |\n@@ -348,60 +372,54 @@ LL | | }\n    | |_^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:567:5\n+  --> $DIR/subdiagnostic-derive.rs:572:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:570:5\n+  --> $DIR/subdiagnostic-derive.rs:575:5\n    |\n LL |     #[suggestion_part()]\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion_part(foo = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:573:23\n+  --> $DIR/subdiagnostic-derive.rs:578:23\n    |\n LL |     #[suggestion_part(foo = \"bar\")]\n    |                       ^^^^^^^^^^^\n    |\n    = help: `code` is the only valid nested attribute\n \n error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:576:5\n+  --> $DIR/subdiagnostic-derive.rs:581:5\n    |\n LL |     #[suggestion_part(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:579:5\n+  --> $DIR/subdiagnostic-derive.rs:584:5\n    |\n LL |     #[suggestion_part()]\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:587:37\n+  --> $DIR/subdiagnostic-derive.rs:592:37\n    |\n LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n    |                                     ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:587:23\n+  --> $DIR/subdiagnostic-derive.rs:592:23\n    |\n LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n    |                       ^^^^^^^^^^^^\n \n-error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:617:5\n+error: `#[applicability]` has no effect if all `#[suggestion]`/`#[multipart_suggestion]` attributes have a static `applicability = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:621:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n-   |\n-note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:614:43\n-   |\n-LL | #[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n@@ -410,59 +428,59 @@ LL | #[foo]\n    |   ^^^\n \n error: cannot find attribute `foo` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:155:3\n+  --> $DIR/subdiagnostic-derive.rs:159:3\n    |\n LL | #[foo]\n    |   ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:169:7\n+  --> $DIR/subdiagnostic-derive.rs:173:7\n    |\n LL |     #[bar]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:181:7\n+  --> $DIR/subdiagnostic-derive.rs:185:7\n    |\n LL |     #[bar = \"...\"]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:193:7\n+  --> $DIR/subdiagnostic-derive.rs:197:7\n    |\n LL |     #[bar = 4]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:205:7\n+  --> $DIR/subdiagnostic-derive.rs:209:7\n    |\n LL |     #[bar(\"...\")]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:266:7\n+  --> $DIR/subdiagnostic-derive.rs:271:7\n    |\n LL |     #[bar]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:277:7\n+  --> $DIR/subdiagnostic-derive.rs:282:7\n    |\n LL |     #[bar = \"...\"]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:288:7\n+  --> $DIR/subdiagnostic-derive.rs:293:7\n    |\n LL |     #[bar(\"...\")]\n    |       ^^^\n \n error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n-  --> $DIR/subdiagnostic-derive.rs:118:9\n+  --> $DIR/subdiagnostic-derive.rs:122:9\n    |\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 63 previous errors\n+error: aborting due to 68 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}]}