{"sha": "90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwY2JiMzlkNzRkYmU3MDY1ZjlhMGJhNTVjZTEzZjdlOTlkMTNiNDM=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T20:55:00Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T22:32:14Z"}, "message": "Moved more types into upvar.rs (now named closure.rs)", "tree": {"sha": "61769a9d499a91eed01117f934e66be5eaa91a09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61769a9d499a91eed01117f934e66be5eaa91a09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43", "html_url": "https://github.com/rust-lang/rust/commit/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "html_url": "https://github.com/rust-lang/rust/commit/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1"}], "stats": {"total": 339, "additions": 170, "deletions": 169}, "files": [{"sha": "18c8a0932f9e4f7879624344c2f3436b8471aeb9", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43", "patch": "@@ -0,0 +1,167 @@\n+use crate::hir::place::{Place as HirPlace, PlaceBase as HirPlaceBase};\n+use crate::ty;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::lang_items::LangItem;\n+use rustc_span::Span;\n+\n+use super::{BorrowKind, CaptureInfo, Ty, TyCtxt};\n+\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n+pub struct UpvarPath {\n+    pub hir_id: hir::HirId,\n+}\n+\n+/// Upvars do not get their own `NodeId`. Instead, we use the pair of\n+/// the original var ID (that is, the root variable that is referenced\n+/// by the upvar) and the ID of the closure expression.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub struct UpvarId {\n+    pub var_path: UpvarPath,\n+    pub closure_expr_id: LocalDefId,\n+}\n+\n+impl UpvarId {\n+    pub fn new(var_hir_id: hir::HirId, closure_def_id: LocalDefId) -> UpvarId {\n+        UpvarId { var_path: UpvarPath { hir_id: var_hir_id }, closure_expr_id: closure_def_id }\n+    }\n+}\n+\n+/// Information describing the capture of an upvar. This is computed\n+/// during `typeck`, specifically by `regionck`.\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub enum UpvarCapture<'tcx> {\n+    /// Upvar is captured by value. This is always true when the\n+    /// closure is labeled `move`, but can also be true in other cases\n+    /// depending on inference.\n+    ///\n+    /// If the upvar was inferred to be captured by value (e.g. `move`\n+    /// was not used), then the `Span` points to a usage that\n+    /// required it. There may be more than one such usage\n+    /// (e.g. `|| { a; a; }`), in which case we pick an\n+    /// arbitrary one.\n+    ByValue(Option<Span>),\n+\n+    /// Upvar is captured by reference.\n+    ByRef(UpvarBorrow<'tcx>),\n+}\n+\n+#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub struct UpvarBorrow<'tcx> {\n+    /// The kind of borrow: by-ref upvars have access to shared\n+    /// immutable borrows, which are not part of the normal language\n+    /// syntax.\n+    pub kind: BorrowKind,\n+\n+    /// Region of the resulting reference.\n+    pub region: ty::Region<'tcx>,\n+}\n+\n+pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n+pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n+\n+/// Given the closure DefId this map provides a map of root variables to minimum\n+/// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n+pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n+\n+/// Part of `MinCaptureInformationMap`; Maps a root variable to the list of `CapturedPlace`.\n+/// Used to track the minimum set of `Place`s that need to be captured to support all\n+/// Places captured by the closure starting at a given root variable.\n+///\n+/// This provides a convenient and quick way of checking if a variable being used within\n+/// a closure is a capture of a local variable.\n+pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureList<'tcx>>;\n+\n+/// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n+pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n+\n+/// Represents the various closure traits in the language. This\n+/// will determine the type of the environment (`self`, in the\n+/// desugaring) argument that the closure expects.\n+///\n+/// You can get the environment type of a closure using\n+/// `tcx.closure_env_ty()`.\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n+#[derive(HashStable)]\n+pub enum ClosureKind {\n+    // Warning: Ordering is significant here! The ordering is chosen\n+    // because the trait Fn is a subtrait of FnMut and so in turn, and\n+    // hence we order it so that Fn < FnMut < FnOnce.\n+    Fn,\n+    FnMut,\n+    FnOnce,\n+}\n+\n+impl<'tcx> ClosureKind {\n+    // This is the initial value used when doing upvar inference.\n+    pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n+\n+    pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+        match *self {\n+            ClosureKind::Fn => tcx.require_lang_item(LangItem::Fn, None),\n+            ClosureKind::FnMut => tcx.require_lang_item(LangItem::FnMut, None),\n+            ClosureKind::FnOnce => tcx.require_lang_item(LangItem::FnOnce, None),\n+        }\n+    }\n+\n+    /// Returns `true` if a type that impls this closure kind\n+    /// must also implement `other`.\n+    pub fn extends(self, other: ty::ClosureKind) -> bool {\n+        matches!(\n+            (self, other),\n+            (ClosureKind::Fn, ClosureKind::Fn)\n+                | (ClosureKind::Fn, ClosureKind::FnMut)\n+                | (ClosureKind::Fn, ClosureKind::FnOnce)\n+                | (ClosureKind::FnMut, ClosureKind::FnMut)\n+                | (ClosureKind::FnMut, ClosureKind::FnOnce)\n+                | (ClosureKind::FnOnce, ClosureKind::FnOnce)\n+        )\n+    }\n+\n+    /// Returns the representative scalar type for this closure kind.\n+    /// See `TyS::to_opt_closure_kind` for more details.\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match self {\n+            ty::ClosureKind::Fn => tcx.types.i8,\n+            ty::ClosureKind::FnMut => tcx.types.i16,\n+            ty::ClosureKind::FnOnce => tcx.types.i32,\n+        }\n+    }\n+}\n+\n+/// A composite describing a `Place` that is captured by a closure.\n+#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub struct CapturedPlace<'tcx> {\n+    /// The `Place` that is captured.\n+    pub place: HirPlace<'tcx>,\n+\n+    /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n+    pub info: CaptureInfo<'tcx>,\n+\n+    /// Represents if `place` can be mutated or not.\n+    pub mutability: hir::Mutability,\n+}\n+\n+impl CapturedPlace<'tcx> {\n+    /// Returns the hir-id of the root variable for the captured place.\n+    /// e.g., if `a.b.c` was captured, would return the hir-id for `a`.\n+    pub fn get_root_variable(&self) -> hir::HirId {\n+        match self.place.base {\n+            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            base => bug!(\"Expected upvar, found={:?}\", base),\n+        }\n+    }\n+}"}, {"sha": "8eb2ec2f80959a0bb30d1f1d12d9868dab6c7168", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 97, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43", "patch": "@@ -16,8 +16,8 @@ pub use self::IntVarValue::*;\n pub use self::Variance::*;\n pub use adt::*;\n pub use assoc::*;\n+pub use closure::*;\n pub use generics::*;\n-pub use upvar::*;\n \n use crate::hir::exports::ExportMap;\n use crate::hir::place::{\n@@ -33,14 +33,13 @@ use crate::ty::util::Discr;\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, par_iter, ParallelIterator};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Constness, Node};\n use rustc_macros::HashStable;\n use rustc_span::hygiene::ExpnId;\n@@ -103,6 +102,7 @@ pub mod walk;\n \n mod adt;\n mod assoc;\n+mod closure;\n mod consts;\n mod context;\n mod diagnostics;\n@@ -112,7 +112,6 @@ mod instance;\n mod list;\n mod structural_impls;\n mod sty;\n-mod upvar;\n \n // Data types\n \n@@ -405,45 +404,6 @@ pub enum BorrowKind {\n     MutBorrow,\n }\n \n-/// Given the closure DefId this map provides a map of root variables to minimum\n-/// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n-pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n-\n-/// Part of `MinCaptureInformationMap`; Maps a root variable to the list of `CapturedPlace`.\n-/// Used to track the minimum set of `Place`s that need to be captured to support all\n-/// Places captured by the closure starting at a given root variable.\n-///\n-/// This provides a convenient and quick way of checking if a variable being used within\n-/// a closure is a capture of a local variable.\n-pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureList<'tcx>>;\n-\n-/// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n-pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n-\n-/// A composite describing a `Place` that is captured by a closure.\n-#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct CapturedPlace<'tcx> {\n-    /// The `Place` that is captured.\n-    pub place: HirPlace<'tcx>,\n-\n-    /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n-    pub info: CaptureInfo<'tcx>,\n-\n-    /// Represents if `place` can be mutated or not.\n-    pub mutability: hir::Mutability,\n-}\n-\n-impl CapturedPlace<'tcx> {\n-    /// Returns the hir-id of the root variable for the captured place.\n-    /// e.g., if `a.b.c` was captured, would return the hir-id for `a`.\n-    pub fn get_root_variable(&self) -> hir::HirId {\n-        match self.place.base {\n-            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-            base => bug!(\"Expected upvar, found={:?}\", base),\n-        }\n-    }\n-}\n-\n pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {\n     let name = match place.base {\n         HirPlaceBase::Upvar(upvar_id) => tcx.hir().name(upvar_id.var_path.hir_id).to_string(),\n@@ -1695,60 +1655,6 @@ impl<'tcx> FieldDef {\n     }\n }\n \n-/// Represents the various closure traits in the language. This\n-/// will determine the type of the environment (`self`, in the\n-/// desugaring) argument that the closure expects.\n-///\n-/// You can get the environment type of a closure using\n-/// `tcx.closure_env_ty()`.\n-#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable)]\n-pub enum ClosureKind {\n-    // Warning: Ordering is significant here! The ordering is chosen\n-    // because the trait Fn is a subtrait of FnMut and so in turn, and\n-    // hence we order it so that Fn < FnMut < FnOnce.\n-    Fn,\n-    FnMut,\n-    FnOnce,\n-}\n-\n-impl<'tcx> ClosureKind {\n-    // This is the initial value used when doing upvar inference.\n-    pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n-\n-    pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n-        match *self {\n-            ClosureKind::Fn => tcx.require_lang_item(LangItem::Fn, None),\n-            ClosureKind::FnMut => tcx.require_lang_item(LangItem::FnMut, None),\n-            ClosureKind::FnOnce => tcx.require_lang_item(LangItem::FnOnce, None),\n-        }\n-    }\n-\n-    /// Returns `true` if a type that impls this closure kind\n-    /// must also implement `other`.\n-    pub fn extends(self, other: ty::ClosureKind) -> bool {\n-        matches!(\n-            (self, other),\n-            (ClosureKind::Fn, ClosureKind::Fn)\n-                | (ClosureKind::Fn, ClosureKind::FnMut)\n-                | (ClosureKind::Fn, ClosureKind::FnOnce)\n-                | (ClosureKind::FnMut, ClosureKind::FnMut)\n-                | (ClosureKind::FnMut, ClosureKind::FnOnce)\n-                | (ClosureKind::FnOnce, ClosureKind::FnOnce)\n-        )\n-    }\n-\n-    /// Returns the representative scalar type for this closure kind.\n-    /// See `TyS::to_opt_closure_kind` for more details.\n-    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self {\n-            ty::ClosureKind::Fn => tcx.types.i8,\n-            ty::ClosureKind::FnMut => tcx.types.i16,\n-            ty::ClosureKind::FnOnce => tcx.types.i32,\n-        }\n-    }\n-}\n-\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {"}, {"sha": "fe8ea6d51c4e0641a29e4d2c3eaaa5a183858d6f", "filename": "compiler/rustc_middle/src/ty/upvar.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fupvar.rs?ref=0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "patch": "@@ -1,72 +0,0 @@\n-use crate::ty;\n-\n-use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_span::Span;\n-\n-use super::BorrowKind;\n-\n-#[derive(\n-    Clone,\n-    Copy,\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    Hash,\n-    TyEncodable,\n-    TyDecodable,\n-    TypeFoldable,\n-    HashStable\n-)]\n-pub struct UpvarPath {\n-    pub hir_id: hir::HirId,\n-}\n-\n-/// Upvars do not get their own `NodeId`. Instead, we use the pair of\n-/// the original var ID (that is, the root variable that is referenced\n-/// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct UpvarId {\n-    pub var_path: UpvarPath,\n-    pub closure_expr_id: LocalDefId,\n-}\n-\n-impl UpvarId {\n-    pub fn new(var_hir_id: hir::HirId, closure_def_id: LocalDefId) -> UpvarId {\n-        UpvarId { var_path: UpvarPath { hir_id: var_hir_id }, closure_expr_id: closure_def_id }\n-    }\n-}\n-\n-/// Information describing the capture of an upvar. This is computed\n-/// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub enum UpvarCapture<'tcx> {\n-    /// Upvar is captured by value. This is always true when the\n-    /// closure is labeled `move`, but can also be true in other cases\n-    /// depending on inference.\n-    ///\n-    /// If the upvar was inferred to be captured by value (e.g. `move`\n-    /// was not used), then the `Span` points to a usage that\n-    /// required it. There may be more than one such usage\n-    /// (e.g. `|| { a; a; }`), in which case we pick an\n-    /// arbitrary one.\n-    ByValue(Option<Span>),\n-\n-    /// Upvar is captured by reference.\n-    ByRef(UpvarBorrow<'tcx>),\n-}\n-\n-#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct UpvarBorrow<'tcx> {\n-    /// The kind of borrow: by-ref upvars have access to shared\n-    /// immutable borrows, which are not part of the normal language\n-    /// syntax.\n-    pub kind: BorrowKind,\n-\n-    /// Region of the resulting reference.\n-    pub region: ty::Region<'tcx>,\n-}\n-\n-pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n-pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;"}]}