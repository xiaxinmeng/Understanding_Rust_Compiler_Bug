{"sha": "007abe935209ab35d85e1b7fa0bfc88460340560", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwN2FiZTkzNTIwOWFiMzVkODVlMWI3ZmEwYmZjODg0NjAzNDA1NjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-27T14:26:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-05T09:36:02Z"}, "message": "Rather than storing a list of ty::method per trait, store one ty::method\nper method and list of def-ids per trait.", "tree": {"sha": "cbd1739e258a264c8c35cb1af2edb7412a8788c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbd1739e258a264c8c35cb1af2edb7412a8788c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/007abe935209ab35d85e1b7fa0bfc88460340560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/007abe935209ab35d85e1b7fa0bfc88460340560", "html_url": "https://github.com/rust-lang/rust/commit/007abe935209ab35d85e1b7fa0bfc88460340560", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/007abe935209ab35d85e1b7fa0bfc88460340560/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d94830830f81bde37124efd6b4c8b6c9649180e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d94830830f81bde37124efd6b4c8b6c9649180e0", "html_url": "https://github.com/rust-lang/rust/commit/d94830830f81bde37124efd6b4c8b6c9649180e0"}], "stats": {"total": 737, "additions": 414, "deletions": 323}, "files": [{"sha": "d3b06009d727e1f88c64a34490e2755883946c22", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -102,6 +102,7 @@ pub static tag_item_dtor: uint = 0x49u;\n pub static tag_item_trait_method_self_ty: uint = 0x4b;\n pub static tag_item_trait_method_self_ty_region: uint = 0x4c;\n \n+\n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n pub static tag_items_data_item_reexport: uint = 0x4d;\n@@ -159,6 +160,9 @@ pub static tag_items_data_item_visibility: uint = 0x78;\n pub static tag_link_args: uint = 0x79;\n pub static tag_link_args_arg: uint = 0x7a;\n \n+pub static tag_item_method_tps: uint = 0x7b;\n+pub static tag_item_method_fty: uint = 0x7c;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "8e7ecdec638b1dc7732ff6f10ff63565a1a73aeb", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -111,12 +111,24 @@ pub fn get_impls_for_mod(cstore: @mut cstore::CStore, def: ast::def_id,\n     }\n }\n \n-pub fn get_trait_methods(tcx: ty::ctxt,\n-                         def: ast::def_id)\n-                      -> @~[ty::method] {\n-    let cstore = tcx.cstore;\n+pub fn get_method(tcx: ty::ctxt,\n+                  def: ast::def_id) -> ty::method\n+{\n+    let cdata = cstore::get_crate_data(tcx.cstore, def.crate);\n+    decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n+}\n+\n+pub fn get_method_name_and_self_ty(cstore: @mut cstore::CStore,\n+                                   def: ast::def_id) -> (ast::ident, ast::self_ty_)\n+{\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_method_name_and_self_ty(cstore.intr, cdata, def.node)\n+}\n+\n+pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n+                                def: ast::def_id) -> ~[ast::def_id] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_trait_methods(cstore.intr, cdata, def.node, tcx)\n+    decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n@@ -133,13 +145,6 @@ pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n-pub fn get_method_names_if_trait(cstore: @mut cstore::CStore,\n-                                 def: ast::def_id)\n-                              -> Option<~[(ast::ident, ast::self_ty_)]> {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n-}\n-\n pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::def_id)\n                           -> Option<ast::ident> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "800df628bc23a1233b5522d1a2a1362ca3b5c7a7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -19,7 +19,8 @@ use metadata::csearch::{ProvidedTraitMethodInfo, StaticMethodInfo};\n use metadata::csearch;\n use metadata::cstore;\n use metadata::decoder;\n-use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n+use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n+                         parse_bare_fn_ty_data};\n use middle::{ty, resolve};\n \n use core::hash::HashUtil;\n@@ -229,6 +230,12 @@ fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n                   |_, did| translate_def_id(cdata, did))\n }\n \n+fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::BareFnTy {\n+    let tp = reader::get_doc(doc, tag_item_method_fty);\n+    parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n+                          |_, did| translate_def_id(cdata, did))\n+}\n+\n pub fn item_type(item_id: ast::def_id, item: ebml::Doc,\n                  tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let t = doc_type(item, tcx, cdata);\n@@ -247,10 +254,11 @@ fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n     results\n }\n \n-fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n+fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n+                        tag: uint)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    for reader::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n+    for reader::tagged_docs(item, tag) |p| {\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx,\n                                    |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n@@ -338,7 +346,8 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n             dl_def(ast::def_variant(enum_did, did))\n         }\n-        Trait | Enum => dl_def(ast::def_ty(did)),\n+        Trait => dl_def(ast::def_trait(did)),\n+        Enum => dl_def(ast::def_ty(did)),\n         Impl => dl_impl(did),\n         PublicField | PrivateField | InheritedField => dl_field,\n     }\n@@ -359,7 +368,7 @@ pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let t = item_type(ast::def_id { crate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n     let tp_bounds = if family_has_type_params(item_family(item)) {\n-        item_ty_param_bounds(item, tcx, cdata)\n+        item_ty_param_bounds(item, tcx, cdata, tag_items_data_item_ty_param_bounds)\n     } else { @~[] };\n     let rp = item_ty_region_param(item);\n     ty::ty_param_bounds_and_ty {\n@@ -690,36 +699,46 @@ pub fn get_impls_for_mod(intr: @ident_interner,\n     @result\n }\n \n-/* Works for both classes and traits */\n-pub fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                         tcx: ty::ctxt) -> @~[ty::method] {\n+pub fn get_method_name_and_self_ty(\n+    intr: @ident_interner,\n+    cdata: cmd,\n+    id: ast::node_id) -> (ast::ident, ast::self_ty_)\n+{\n+    let method_doc = lookup_item(id, cdata.data);\n+    let name = item_name(intr, method_doc);\n+    let self_ty = get_self_ty(method_doc);\n+    (name, self_ty)\n+}\n+\n+pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n+                  tcx: ty::ctxt) -> ty::method\n+{\n+    let method_doc = lookup_item(id, cdata.data);\n+    let bounds = item_ty_param_bounds(method_doc, tcx, cdata,\n+                                      tag_item_method_tps);\n+    let name = item_name(intr, method_doc);\n+    let def_id = item_def_id(method_doc, cdata);\n+    let fty = doc_method_fty(method_doc, tcx, cdata);\n+    let self_ty = get_self_ty(method_doc);\n+    ty::method {\n+        ident: name,\n+        tps: bounds,\n+        fty: fty,\n+        self_ty: self_ty,\n+        vis: ast::public,\n+        def_id: def_id\n+    }\n+}\n+\n+pub fn get_trait_method_def_ids(cdata: cmd,\n+                                id: ast::node_id) -> ~[ast::def_id] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n     for reader::tagged_docs(item, tag_item_trait_method) |mth| {\n-        let bounds = item_ty_param_bounds(mth, tcx, cdata);\n-        let name = item_name(intr, mth);\n-        let ty = doc_type(mth, tcx, cdata);\n-        let def_id = item_def_id(mth, cdata);\n-        let fty = match ty::get(ty).sty {\n-            ty::ty_bare_fn(ref f) => copy *f,\n-            _ => {\n-                tcx.diag.handler().bug(\n-                    ~\"get_trait_methods: id has non-function type\");\n-            }\n-        };\n-        let self_ty = get_self_ty(mth);\n-        result.push(ty::method {\n-            ident: name,\n-            tps: bounds,\n-            fty: fty,\n-            self_ty: self_ty,\n-            vis: ast::public,\n-            def_id: def_id\n-        });\n+        result.push(item_def_id(mth, cdata));\n     }\n-    debug!(\"get_trait_methods: }\");\n-    @result\n+    result\n }\n \n pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n@@ -734,7 +753,8 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n         let did = item_def_id(mth, cdata);\n \n-        let bounds = item_ty_param_bounds(mth, tcx, cdata);\n+        let bounds = item_ty_param_bounds(mth, tcx, cdata,\n+                                          tag_items_data_item_ty_param_bounds);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n \n@@ -777,26 +797,6 @@ pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     return results;\n }\n \n-// If the item in question is a trait, returns its set of methods and\n-// their self types. Otherwise, returns none. This overlaps in an\n-// annoying way with get_trait_methods.\n-pub fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n-                                 node_id: ast::node_id)\n-                              -> Option<~[(ast::ident, ast::self_ty_)]> {\n-\n-    let item = lookup_item(node_id, cdata.data);\n-    if item_family(item) != Trait {\n-        return None;\n-    }\n-\n-    let mut resulting_methods = ~[];\n-    for reader::tagged_docs(item, tag_item_trait_method) |method| {\n-        resulting_methods.push(\n-            (item_name(intr, method), get_self_ty(method)));\n-    }\n-    return Some(resulting_methods);\n-}\n-\n pub fn get_type_name_if_impl(intr: @ident_interner,\n                              cdata: cmd,\n                              node_id: ast::node_id) -> Option<ast::ident> {"}, {"sha": "61501d8308331ff3034e41133a3fede76db4dc40", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 93, "deletions": 82, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -170,16 +170,18 @@ fn encode_family(ebml_w: writer::Encoder, c: char) {\n \n pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @EncodeContext,\n-                               params: @~[ty::param_bounds]) {\n+fn encode_ty_type_param_bounds(ebml_w: writer::Encoder,\n+                               ecx: @EncodeContext,\n+                               params: @~[ty::param_bounds],\n+                               tag: uint) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n         reachable: |a| reachable(ecx, a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each |param| {\n-        ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n+        ebml_w.start_tag(tag);\n         tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, *param);\n         ebml_w.end_tag();\n     }\n@@ -190,7 +192,8 @@ fn encode_type_param_bounds(ebml_w: writer::Encoder,\n                             params: &OptVec<TyParam>) {\n     let ty_param_bounds =\n         @params.map_to_vec(|param| *ecx.tcx.ty_param_bounds.get(&param.id));\n-    encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n+    encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds,\n+                                tag_items_data_item_ty_param_bounds);\n }\n \n \n@@ -227,6 +230,23 @@ fn encode_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n     ebml_w.end_tag();\n }\n \n+fn encode_method_fty(ecx: @EncodeContext,\n+                     ebml_w: writer::Encoder,\n+                     typ: &ty::BareFnTy)\n+{\n+    ebml_w.start_tag(tag_item_method_fty);\n+\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n+\n+    ebml_w.end_tag();\n+}\n+\n fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n@@ -868,8 +888,6 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         }\n       }\n       item_trait(ref generics, ref traits, ref ms) => {\n-        let mut provided_methods = ~[];\n-\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -879,96 +897,89 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        let mut i = 0u;\n-        for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n-            match (*ms)[i] {\n-              required(ref ty_m) => {\n-                ebml_w.start_tag(tag_item_trait_method);\n-                encode_def_id(ebml_w, local_def((*ty_m).id));\n-                encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx,\n-                                         &ty_m.generics.ty_params);\n-                encode_type(ecx, ebml_w,\n-                            ty::mk_bare_fn(tcx, copy mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n-                encode_self_type(ebml_w, mty.self_ty);\n-                encode_method_sort(ebml_w, 'r');\n-                encode_visibility(ebml_w, ast::public);\n-                ebml_w.end_tag();\n-              }\n-              provided(m) => {\n-                provided_methods.push(m);\n-\n-                ebml_w.start_tag(tag_item_trait_method);\n-                encode_def_id(ebml_w, local_def(m.id));\n-                encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx,\n-                                         &m.generics.ty_params);\n-                encode_type(ecx, ebml_w,\n-                            ty::mk_bare_fn(tcx, copy mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n-                encode_self_type(ebml_w, mty.self_ty);\n-                encode_method_sort(ebml_w, 'p');\n-                encode_visibility(ebml_w, m.vis);\n-                ebml_w.end_tag();\n-              }\n-            }\n-            i += 1;\n+        for ty::trait_method_def_ids(tcx, local_def(item.id)).each |&method_def_id| {\n+            ebml_w.start_tag(tag_item_trait_method);\n+            encode_def_id(ebml_w, method_def_id);\n+            ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         for traits.each |associated_trait| {\n-           encode_trait_ref(ebml_w, ecx, *associated_trait)\n+            encode_trait_ref(ebml_w, ecx, *associated_trait);\n         }\n-\n         ebml_w.end_tag();\n \n-        // Now, output all of the static methods as items.  Note that for the\n-        // method info, we output static methods with type signatures as\n-        // written. Here, we output the *real* type signatures. I feel like\n-        // maybe we should only ever handle the real type signatures.\n-        for ms.each |m| {\n-            let ty_m = ast_util::trait_method_to_ty_method(m);\n-            if ty_m.self_ty.node != ast::sty_static { loop; }\n+        // Now output the method info for each method.\n+        //\n+        // Note: for the moment, the data structures here are *slightly*\n+        // different from those expected by `encode_info_for_method()`,\n+        // but I do plan to refactor this later in this patch to avoid the\n+        // duplication.\n+        for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n+            assert!(method_def_id.crate == ast::local_crate);\n \n-            index.push(entry { val: ty_m.id, pos: ebml_w.writer.tell() });\n+            let method_ty: @ty::method = ty::method(tcx, method_def_id);\n+\n+            index.push(entry {val: method_def_id.node, pos: ebml_w.writer.tell()});\n \n             ebml_w.start_tag(tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(ty_m.id));\n+\n+            encode_def_id(ebml_w, method_def_id);\n             encode_parent_item(ebml_w, local_def(item.id));\n-            encode_name(ecx, ebml_w, ty_m.ident);\n-            encode_family(ebml_w,\n-                          purity_static_method_family(ty_m.purity));\n-            let polyty = ecx.tcx.tcache.get(&local_def(ty_m.id));\n-            encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n-            encode_type(ecx, ebml_w, polyty.ty);\n-            let mut m_path = vec::append(~[], path); // :-(\n-            m_path += [ast_map::path_name(item.ident)];\n-            encode_path(ecx, ebml_w, m_path, ast_map::path_name(ty_m.ident));\n-\n-            // For now, use the item visibility until trait methods can have\n-            // real visibility in the AST.\n-            encode_visibility(ebml_w, item.vis);\n+            encode_name(ecx, ebml_w, method_ty.ident);\n+\n+            match method_ty.self_ty {\n+                sty_static => {\n+                    encode_family(ebml_w,\n+                                  purity_static_method_family(\n+                                      method_ty.fty.purity));\n+\n+                    let tpt = ty::lookup_item_type(tcx, method_def_id);\n+                    encode_ty_type_param_bounds(ebml_w, ecx, tpt.bounds,\n+                                                tag_items_data_item_ty_param_bounds);\n+                    encode_type(ecx, ebml_w, tpt.ty);\n+                }\n \n-            ebml_w.end_tag();\n-        }\n+                _ => {\n+                    encode_family(ebml_w,\n+                                  purity_fn_family(\n+                                      method_ty.fty.purity));\n+                }\n+            }\n \n-        // Finally, output all the provided methods as items.\n-        for provided_methods.each |m| {\n-            index.push(entry { val: m.id, pos: ebml_w.writer.tell() });\n+            encode_ty_type_param_bounds(ebml_w, ecx, method_ty.tps,\n+                                        tag_item_method_tps);\n+            encode_method_fty(ecx, ebml_w, &method_ty.fty);\n+            encode_visibility(ebml_w, method_ty.vis);\n+            encode_self_type(ebml_w, method_ty.self_ty);\n+            let mut trait_path = vec::append(~[], path);\n+            trait_path.push(ast_map::path_name(item.ident));\n+            encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n+\n+            match ms[i] {\n+                required(_) => {\n+                    encode_method_sort(ebml_w, 'r');\n+                }\n \n-            // We do not concatenate the generics of the owning impl and that\n-            // of provided methods.  I am not sure why this is. -ndm\n-            let owner_generics = ast_util::empty_generics();\n+                provided(m) => {\n+                    // This is obviously a bogus assert but I don't think this\n+                    // ever worked before anyhow...near as I can tell, before\n+                    // we would emit two items.\n+                    if method_ty.self_ty == sty_static {\n+                        tcx.sess.span_unimpl(\n+                            item.span,\n+                            fmt!(\"Method %s is both provided and static\",\n+                                 *tcx.sess.intr().get(method_ty.ident)));\n+                    }\n+                    encode_type_param_bounds(ebml_w, ecx,\n+                                             &m.generics.ty_params);\n+                    encode_method_sort(ebml_w, 'p');\n+                    (ecx.encode_inlined_item)(\n+                        ecx, ebml_w, path,\n+                        ii_method(local_def(item.id), m));\n+                }\n+            }\n \n-            encode_info_for_method(ecx,\n-                                   ebml_w,\n-                                   /*bad*/copy path,\n-                                   true,\n-                                   item.id,\n-                                   *m,\n-                                   item.vis,\n-                                   &owner_generics,\n-                                   &m.generics);\n+            ebml_w.end_tag();\n         }\n       }\n       item_mac(*) => fail!(~\"item macros unimplemented\")"}, {"sha": "2982ed268770d530669a7f6e6174e826a066e741", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -119,6 +119,12 @@ pub fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n     parse_ty(st, conv)\n }\n \n+pub fn parse_bare_fn_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+                             conv: conv_did) -> ty::BareFnTy {\n+    let st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_bare_fn_ty(st, conv)\n+}\n+\n pub fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                       conv: conv_did) -> ty::arg {\n     let st = parse_state_from_data(data, crate_num, pos, tcx);"}, {"sha": "419219d411d893722b5909ce5ce760dba4b68912", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -384,7 +384,7 @@ fn enc_onceness(w: @io::Writer, o: Onceness) {\n     }\n }\n \n-fn enc_bare_fn_ty(w: @io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty(w: @io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n     enc_abi_set(w, ft.abis);\n     enc_fn_sig(w, cx, &ft.sig);"}, {"sha": "6fc74c9a7130dfe7216caf27193ad9c205cfd841", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -417,6 +417,7 @@ impl tr for ast::def {\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n           }\n+          ast::def_trait(did) => ast::def_trait(did.tr(xcx)),\n           ast::def_ty(did) => ast::def_ty(did.tr(xcx)),\n           ast::def_prim_ty(p) => ast::def_prim_ty(p),\n           ast::def_ty_param(did, v) => ast::def_ty_param(did.tr(xcx), v),"}, {"sha": "6473cb8e8e00668b3ddf21de2845fa22132e04ee", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -462,7 +462,7 @@ pub impl mem_categorization_ctxt {\n           ast::def_fn(*) | ast::def_static_method(*) | ast::def_mod(_) |\n           ast::def_foreign_mod(_) | ast::def_const(_) |\n           ast::def_use(_) | ast::def_variant(*) |\n-          ast::def_ty(_) | ast::def_prim_ty(_) |\n+          ast::def_trait(_) | ast::def_ty(_) | ast::def_prim_ty(_) |\n           ast::def_ty_param(*) | ast::def_struct(*) |\n           ast::def_typaram_binder(*) | ast::def_region(_) |\n           ast::def_label(_) | ast::def_self_ty(*) => {"}, {"sha": "ed7ca441b984b008f06cc3885c6507aac51e08f9", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -211,7 +211,7 @@ use core::prelude::*;\n use middle::pat_util::{pat_bindings};\n use middle::freevars;\n use middle::ty;\n-use middle::typeck::method_map;\n+use middle::typeck::{method_map, method_map_entry};\n use util::ppaux;\n use util::common::indenter;\n "}, {"sha": "1c60c37ed12a04b71d537181a192b2f9448a062e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -690,7 +690,9 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     match ty.node {\n       ast::ty_path(path, id) => {\n         match cx.def_map.find(&id) {\n-          Some(&ast::def_ty(did)) | Some(&ast::def_struct(did)) => {\n+          Some(&ast::def_ty(did)) |\n+          Some(&ast::def_trait(did)) |\n+          Some(&ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n                 if cx.region_is_relevant(path.rp) {\n                     cx.add_dep(did.node);"}, {"sha": "7232e99bf2206d4a7a0bdfe0db113a9627474d22", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -12,7 +12,8 @@ use core::prelude::*;\n \n use driver::session;\n use driver::session::Session;\n-use metadata::csearch::{each_path, get_method_names_if_trait};\n+use metadata::csearch::{each_path, get_trait_method_def_ids};\n+use metadata::csearch::get_method_name_and_self_ty;\n use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n@@ -31,7 +32,7 @@ use syntax::ast::{crate, decl_item, def, def_arg, def_binding};\n use syntax::ast::{def_const, def_foreign_mod, def_fn, def_id, def_label};\n use syntax::ast::{def_local, def_mod, def_prim_ty, def_region, def_self};\n use syntax::ast::{def_self_ty, def_static_method, def_struct, def_ty};\n-use syntax::ast::{def_ty_param, def_typaram_binder};\n+use syntax::ast::{def_ty_param, def_typaram_binder, def_trait};\n use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n use syntax::ast::{expr_binary, expr_break, expr_field};\n use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n@@ -1341,7 +1342,7 @@ pub impl Resolver {\n                 let def_id = local_def(item.id);\n                 self.trait_info.insert(def_id, method_names);\n \n-                name_bindings.define_type(privacy, def_ty(def_id), sp);\n+                name_bindings.define_type(privacy, def_trait(def_id), sp);\n                 visit_item(item, new_parent, visitor);\n             }\n \n@@ -1611,36 +1612,40 @@ pub impl Resolver {\n                     crate) building value %s\", final_ident);\n             child_name_bindings.define_value(Public, def, dummy_sp());\n           }\n-          def_ty(def_id) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building type %s\", final_ident);\n-\n-            // If this is a trait, add all the method names\n-            // to the trait info.\n-\n-            match get_method_names_if_trait(self.session.cstore, def_id) {\n-              None => {\n-                // Nothing to do.\n-              }\n-              Some(method_names) => {\n-                let mut interned_method_names = HashSet::new();\n-                for method_names.each |method_data| {\n-                    let (method_name, self_ty) = *method_data;\n-                    debug!(\"(building reduced graph for \\\n-                            external crate) ... adding \\\n-                            trait method '%s'\",\n-                           *self.session.str_of(method_name));\n-\n-                    // Add it to the trait info if not static.\n-                    if self_ty != sty_static {\n-                        interned_method_names.insert(method_name);\n-                    }\n-                }\n-                self.trait_info.insert(def_id, interned_method_names);\n+          def_trait(def_id) => {\n+              debug!(\"(building reduced graph for external \\\n+                      crate) building type %s\", final_ident);\n+\n+              // If this is a trait, add all the method names\n+              // to the trait info.\n+\n+              let method_def_ids = get_trait_method_def_ids(self.session.cstore,\n+                                                            def_id);\n+              let mut interned_method_names = HashSet::new();\n+              for method_def_ids.each |&method_def_id| {\n+                  let (method_name, self_ty) =\n+                      get_method_name_and_self_ty(self.session.cstore,\n+                                                  method_def_id);\n+\n+                  debug!(\"(building reduced graph for \\\n+                          external crate) ... adding \\\n+                          trait method '%s'\",\n+                         *self.session.str_of(method_name));\n+\n+                  // Add it to the trait info if not static.\n+                  if self_ty != sty_static {\n+                      interned_method_names.insert(method_name);\n+                  }\n               }\n-            }\n+              self.trait_info.insert(def_id, interned_method_names);\n \n-            child_name_bindings.define_type(Public, def, dummy_sp());\n+              child_name_bindings.define_type(Public, def, dummy_sp());\n+          }\n+          def_ty(_) => {\n+              debug!(\"(building reduced graph for external \\\n+                      crate) building type %s\", final_ident);\n+\n+              child_name_bindings.define_type(Public, def, dummy_sp());\n           }\n           def_struct(def_id) => {\n             debug!(\"(building reduced graph for external \\\n@@ -4952,7 +4957,7 @@ pub impl Resolver {\n                 match child_name_bindings.def_for_namespace(TypeNS) {\n                     Some(def) => {\n                         match def {\n-                            def_ty(trait_def_id) => {\n+                            def_trait(trait_def_id) => {\n                                 self.add_trait_info_if_containing_method(\n                                     &mut found_traits, trait_def_id, name);\n                             }\n@@ -4979,7 +4984,7 @@ pub impl Resolver {\n                         match target.bindings.def_for_namespace(TypeNS) {\n                             Some(def) => {\n                                 match def {\n-                                    def_ty(trait_def_id) => {\n+                                    def_trait(trait_def_id) => {\n                                         let added = self.\n                                         add_trait_info_if_containing_method(\n                                             &mut found_traits,"}, {"sha": "b8b0bddcf051215f01ed2dc565d7c93735fd0b20", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -148,7 +148,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             ast::def_self(*) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            ast::def_mod(*) | ast::def_foreign_mod(*) |\n+            ast::def_mod(*) | ast::def_foreign_mod(*) | ast::def_trait(*) |\n             ast::def_const(*) | ast::def_ty(*) | ast::def_prim_ty(*) |\n             ast::def_use(*) | ast::def_typaram_binder(*) |\n             ast::def_region(*) | ast::def_label(*) | ast::def_ty_param(*) |"}, {"sha": "accdb6557501e5a335a4ef3a4dfc5c40ce0c4d22", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -174,6 +174,7 @@ pub fn trans_method_callee(bcx: block,\n                            mentry: typeck::method_map_entry)\n                         -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n+    let tcx = bcx.tcx();\n \n     debug!(\"trans_method_callee(callee_id=%?, self=%s, mentry=%?)\",\n            callee_id, bcx.expr_to_str(self), mentry);\n@@ -189,33 +190,33 @@ pub fn trans_method_callee(bcx: block,\n \n             // Get the ID of the method we're calling.\n             let method_name =\n-                ty::trait_methods(bcx.tcx(), trait_id)[method_index].ident;\n-            let method_id = method_with_name(bcx.ccx(), impl_def_id,\n-                                             method_name);\n+                ty::trait_method(tcx, trait_id, method_index).ident;\n+            let method_id =\n+                method_with_name(bcx.ccx(), impl_def_id, method_name);\n             origin = typeck::method_static(method_id);\n         }\n         typeck::method_super(trait_id, method_index) => {\n             // <self_ty> is the self type for this method call\n             let self_ty = node_id_type(bcx, self.id);\n-            let tcx = bcx.tcx();\n             // <impl_id> is the ID of the implementation of\n             // trait <trait_id> for type <self_ty>\n             let impl_id = ty::get_impl_id(tcx, trait_id, self_ty);\n             // Get the supertrait's methods\n-            let supertrait_methods = ty::trait_methods(tcx, trait_id);\n+            let supertrait_method_def_ids = ty::trait_method_def_ids(tcx, trait_id);\n             // Make sure to fail with a readable error message if\n             // there's some internal error here\n-            if !(method_index < supertrait_methods.len()) {\n+            if !(method_index < supertrait_method_def_ids.len()) {\n                 tcx.sess.bug(~\"trans_method_callee: supertrait method \\\n                                index is out of bounds\");\n             }\n             // Get the method name using the method index in the origin\n-            let method_name = supertrait_methods[method_index].ident;\n+            let method_name =\n+                ty::method(tcx, supertrait_method_def_ids[method_index]).ident;\n             // Now that we know the impl ID, we can look up the method\n             // ID from its name\n             origin = typeck::method_static(method_with_name(bcx.ccx(),\n-                                              impl_id,\n-                                              method_name));\n+                                                            impl_id,\n+                                                            method_name));\n         }\n         typeck::method_static(*) | typeck::method_param(*) |\n         typeck::method_trait(*) => {}\n@@ -448,7 +449,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n     return match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n-          let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;\n+          let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n           let mth_id = method_with_name_or_default(\n               bcx.ccx(), impl_did, mname);\n \n@@ -791,10 +792,11 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n         || ~\"make_impl_vtable: non-trait-type implemented\");\n \n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n-    make_vtable(ccx, vec::map(*ty::trait_methods(tcx, trt_id), |im| {\n+    make_vtable(ccx, ty::trait_method_def_ids(tcx, trt_id).map(|method_def_id| {\n+        let im = ty::method(tcx, *method_def_id);\n         let fty = ty::subst_tps(tcx, substs, None,\n                                 ty::mk_bare_fn(tcx, copy im.fty));\n-        if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n+        if im.tps.len() > 0u || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    *tcx.sess.str_of(im.ident));\n             C_null(T_ptr(T_nil()))"}, {"sha": "224981d6e759aaaca939eb29422526f6806537f8", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -31,7 +31,7 @@ use syntax::ast;\n \n pub struct Reflector {\n     visitor_val: ValueRef,\n-    visitor_methods: @~[ty::method],\n+    visitor_methods: @~[@ty::method],\n     final_bcx: block,\n     tydesc_ty: TypeRef,\n     bcx: block"}, {"sha": "fcdd5a650af81f8e138cbdef4c39102d13707b95", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 75, "deletions": 40, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -255,6 +255,15 @@ struct ctxt_ {\n     // other items.\n     node_type_substs: @mut HashMap<node_id, ~[t]>,\n \n+    // Maps from a method to the method \"descriptor\"\n+    methods: @mut HashMap<def_id, @method>,\n+\n+    // Maps from a trait def-id to a list of the def-ids of its methods\n+    trait_method_def_ids: @mut HashMap<def_id, @~[def_id]>,\n+\n+    // A cache for the trait_methods() routine\n+    trait_methods_cache: @mut HashMap<def_id, @~[@method]>,\n+\n     items: ast_map::map,\n     intrinsic_defs: @mut HashMap<ast::ident, (ast::def_id, t)>,\n     freevars: freevars::freevar_map,\n@@ -266,7 +275,6 @@ struct ctxt_ {\n     tc_cache: @mut HashMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: @mut HashMap<def_id, @~[VariantInfo]>,\n-    trait_method_cache: @mut HashMap<def_id, @~[method]>,\n     ty_param_bounds: @mut HashMap<ast::node_id, param_bounds>,\n     inferred_modes: @mut HashMap<ast::node_id, ast::mode>,\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n@@ -831,7 +839,9 @@ pub fn mk_ctxt(s: session::Session,\n         tc_cache: @mut HashMap::new(),\n         ast_ty_to_ty_cache: @mut HashMap::new(),\n         enum_var_cache: @mut HashMap::new(),\n-        trait_method_cache: @mut HashMap::new(),\n+        methods: @mut HashMap::new(),\n+        trait_method_def_ids: @mut HashMap::new(),\n+        trait_methods_cache: @mut HashMap::new(),\n         ty_param_bounds: @mut HashMap::new(),\n         inferred_modes: @mut HashMap::new(),\n         adjustments: @mut HashMap::new(),\n@@ -3028,7 +3038,7 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n             let trt_bounds =\n                 ty::lookup_item_type(tcx, trt_id).bounds;\n             @(vec::append(/*bad*/copy *trt_bounds,\n-                          *ty::trait_methods(tcx, trt_id)[n_mth].tps))\n+                          *ty::trait_method(tcx, trt_id, n_mth).tps))\n           }\n         }\n     }\n@@ -3213,10 +3223,8 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n-pub fn method_idx(id: ast::ident, meths: &[method]) -> Option<uint> {\n-    let mut i = 0u;\n-    for meths.each |m| { if m.ident == id { return Some(i); } i += 1u; }\n-    return None;\n+pub fn method_idx(id: ast::ident, meths: &[@method]) -> Option<uint> {\n+    vec::position(meths, |m| m.ident == id)\n }\n \n /// Returns a vector containing the indices of all type parameters that appear\n@@ -3537,10 +3545,6 @@ pub fn def_has_ty_params(def: ast::def) -> bool {\n     }\n }\n \n-pub fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n-    cx.trait_method_cache.insert(ast_util::local_def(id), ms);\n-}\n-\n pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     if is_local(id) {\n         match cx.items.find(&id.node) {\n@@ -3594,25 +3598,66 @@ pub fn trait_supertraits(cx: ctxt,\n     return @result;\n }\n \n-pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n-    match cx.trait_method_cache.find(&id) {\n-      // Local traits are supposed to have been added explicitly.\n-      Some(&ms) => ms,\n-      _ => {\n-        // If the lookup in trait_method_cache fails, assume that the trait\n-        // method we're trying to look up is in a different crate, and look\n-        // for it there.\n-        assert!(id.crate != ast::local_crate);\n-        let result = csearch::get_trait_methods(cx, id);\n-\n-        // Store the trait method in the local trait_method_cache so that\n-        // future lookups succeed.\n-        cx.trait_method_cache.insert(id, result);\n-        result\n-      }\n+fn lookup_locally_or_in_crate_store<V:Copy>(\n+    descr: &str,\n+    def_id: ast::def_id,\n+    map: &mut HashMap<ast::def_id, V>,\n+    load_external: &fn() -> V) -> V\n+{\n+    /*!\n+     *\n+     * Helper for looking things up in the various maps\n+     * that are populated during typeck::collect (e.g.,\n+     * `cx.methods`, `cx.tcache`, etc).  All of these share\n+     * the pattern that if the id is local, it should have\n+     * been loaded into the map by the `typeck::collect` phase.\n+     * If the def-id is external, then we have to go consult\n+     * the crate loading code (and cache the result for the future).\n+     */\n+\n+    match map.find(&def_id) {\n+        Some(&v) => { return v; }\n+        None => { }\n+    }\n+\n+    if def_id.crate == ast::local_crate {\n+        fail!(fmt!(\"No def'n found for %? in tcx.%s\",\n+                   def_id, descr));\n+    }\n+    let v = load_external();\n+    map.insert(def_id, v);\n+    return v;\n+}\n+\n+pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @method {\n+    let method_def_id = ty::trait_method_def_ids(cx, trait_did)[idx];\n+    ty::method(cx, method_def_id)\n+}\n+\n+pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@method] {\n+    match cx.trait_methods_cache.find(&trait_did) {\n+        Some(&methods) => methods,\n+        None => {\n+            let def_ids = ty::trait_method_def_ids(cx, trait_did);\n+            let methods = @def_ids.map(|d| ty::method(cx, *d));\n+            cx.trait_methods_cache.insert(trait_did, methods);\n+            methods\n+        }\n     }\n }\n \n+pub fn method(cx: ctxt, id: ast::def_id) -> @method {\n+    lookup_locally_or_in_crate_store(\n+        \"methods\", id, cx.methods,\n+        || @csearch::get_method(cx, id))\n+}\n+\n+pub fn trait_method_def_ids(cx: ctxt, id: ast::def_id) -> @~[def_id] {\n+    lookup_locally_or_in_crate_store(\n+        \"methods\", id, cx.trait_method_def_ids,\n+        || @csearch::get_trait_method_def_ids(cx.cstore, id))\n+}\n+\n /*\n   Could this return a list of (def_id, substs) pairs?\n  */\n@@ -3916,19 +3961,9 @@ pub fn enum_variant_with_id(cx: ctxt,\n pub fn lookup_item_type(cx: ctxt,\n                         did: ast::def_id)\n                      -> ty_param_bounds_and_ty {\n-    match cx.tcache.find(&did) {\n-      Some(&tpt) => {\n-        // The item is in this crate. The caller should have added it to the\n-        // type cache already\n-        return tpt;\n-      }\n-      None => {\n-        assert!(did.crate != ast::local_crate);\n-        let tyt = csearch::get_type(cx, did);\n-        cx.tcache.insert(did, tyt);\n-        return tyt;\n-      }\n-    }\n+    lookup_locally_or_in_crate_store(\n+        \"tcache\", did, cx.tcache,\n+        || csearch::get_type(cx, did))\n }\n \n // Look up a field ID, whether or not it's local"}, {"sha": "c54e76b9c0579c6de412eec8a23ba552d8b790cb", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -243,7 +243,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n                     }\n-                    Some(&ast::def_ty(type_def_id)) => {\n+                    Some(&ast::def_trait(type_def_id)) => {\n                         let result = ast_path_to_substs_and_ty(\n                             self, rscope,\n                             type_def_id, path);\n@@ -271,7 +271,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                                                     trait_store);\n \n                             }\n-                            _ => {}\n+                            _ => {\n+                                tcx.sess.span_bug(\n+                                    a_seq_ty.ty.span,\n+                                    fmt!(\"def_trait but not ty_trait\"));\n+                            }\n                         }\n                     }\n                     _ => {}\n@@ -372,7 +376,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n           Some(&d) => d\n         };\n         match a_def {\n-          ast::def_ty(did) | ast::def_struct(did) => {\n+          ast::def_trait(did) | ast::def_ty(did) | ast::def_struct(did) => {\n             ast_path_to_ty(self, rscope, did, path).ty\n           }\n           ast::def_prim_ty(nty) => {"}, {"sha": "c8b274e456916c7030b3dd85b4ead886bc4ad8eb", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -2126,11 +2126,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::expr_vstore(ev, vst) => {\n         let typ = match ev.node {\n           ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, s.len(), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             ty::mk_estr(tcx, tt)\n           }\n           ast::expr_vec(ref args, mutbl) => {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, args.len(), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability;\n             let mut any_error = false;\n             let mut any_bot = false;\n@@ -2164,7 +2164,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           ast::expr_repeat(element, count_expr, mutbl) => {\n             let count = ty::eval_repeat_count(tcx, count_expr);\n             check_expr_with_hint(fcx, count_expr, ty::mk_uint(tcx));\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability = match vst {\n                 ast::expr_vstore_mut_box | ast::expr_vstore_mut_slice => {\n                     ast::m_mutbl\n@@ -3173,7 +3173,10 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::def_upvar(_, inner, _, _) => {\n         return ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n-      ast::def_ty(_) | ast::def_prim_ty(_) | ast::def_ty_param(*)=> {\n+      ast::def_trait(_) |\n+      ast::def_ty(_) |\n+      ast::def_prim_ty(_) |\n+      ast::def_ty_param(*)=> {\n         fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found type\");\n       }\n       ast::def_mod(*) | ast::def_foreign_mod(*) => {\n@@ -3211,6 +3214,10 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     let ty_param_count = vec::len(*tpt.bounds);\n     let ty_substs_len = vec::len(pth.types);\n \n+    debug!(\"ty_param_count=%? ty_substs_len=%?\",\n+           ty_param_count,\n+           ty_substs_len);\n+\n     // determine the region bound, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n     let self_r = match pth.rp {\n@@ -3306,7 +3313,6 @@ pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n \n pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n                                  e: @ast::expr,\n-                                 _n: uint,\n                                  v: ast::expr_vstore)\n                               -> ty::vstore {\n     match v {"}, {"sha": "ab99aa20d648756c41b9d611a9b0dc881c3a4aa2", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -38,7 +38,7 @@ use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n-use syntax::ast::{crate, def_id, def_mod, def_ty};\n+use syntax::ast::{crate, def_id, def_mod, def_ty, def_trait};\n use syntax::ast::{item, item_impl, item_mod, local_crate, method, trait_ref};\n use syntax::ast;\n use syntax::ast_map::node_item;\n@@ -507,7 +507,7 @@ pub impl CoherenceChecker {\n             provided_method_idents.insert(*ident);\n         }\n \n-        for ty::trait_methods(tcx, trait_did).each |method| {\n+        for ty::trait_methods(tcx, trait_did).each |&method| {\n             if provided_method_idents.contains(&method.ident) {\n                 if !f(method) {\n                     break;\n@@ -947,7 +947,7 @@ pub impl CoherenceChecker {\n                                                   crate_store,\n                                                   def_id);\n                     }\n-                    dl_def(def_ty(def_id)) => {\n+                    dl_def(def_trait(def_id)) => {\n                         let tcx = self.crate_context.tcx;\n                         let polytype = csearch::get_type(tcx, def_id);\n                         match ty::get(polytype.ty).sty {"}, {"sha": "d89d1c407d7bae4d2c25ccc568f39a995f5c2a07", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 81, "deletions": 72, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -53,7 +53,6 @@ use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n-use syntax::ast_util::{trait_method_to_ty_method};\n use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n@@ -221,19 +220,61 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n }\n \n pub fn ensure_trait_methods(ccx: &CrateCtxt,\n-                            id: ast::node_id,\n-                            trait_ty: ty::t) {\n-    fn store_methods<T>(ccx: &CrateCtxt,\n-                        id: ast::node_id,\n-                        stuff: &[T],\n-                        f: &fn(v: &T) -> ty::method) {\n-        ty::store_trait_methods(ccx.tcx, id, @stuff.map(f));\n+                            trait_id: ast::node_id,\n+                            trait_ty: ty::t)\n+{\n+    let tcx = ccx.tcx;\n+    let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|&x| *x);\n+    match *tcx.items.get(&trait_id) {\n+        ast_map::node_item(@ast::item {\n+            node: ast::item_trait(ref generics, _, ref ms),\n+            _\n+        }, _) => {\n+            let trait_bounds = ty_param_bounds(ccx, generics);\n+\n+            // For each method, construct a suitable ty::method and\n+            // store it into the `tcx.methods` table:\n+            for ms.each |m| {\n+                let ty_method = @match m {\n+                    &ast::required(ref m) => {\n+                        ty_method_of_trait_method(ccx, region_paramd, generics,\n+                                                  &m.id, &m.ident, &m.self_ty,\n+                                                  &m.generics, &m.purity, &m.decl)\n+                    }\n+\n+                    &ast::provided(ref m) => {\n+                        ty_method_of_trait_method(ccx, region_paramd, generics,\n+                                                  &m.id, &m.ident, &m.self_ty,\n+                                                  &m.generics, &m.purity, &m.decl)\n+                    }\n+                };\n+\n+                if ty_method.self_ty == ast::sty_static {\n+                    make_static_method_ty(ccx, region_paramd,\n+                                          ty_method, trait_ty,\n+                                          trait_bounds);\n+                }\n+\n+                tcx.methods.insert(ty_method.def_id, ty_method);\n+            }\n+\n+            // Add an entry mapping\n+            let method_def_ids = @ms.map(|m| {\n+                match m {\n+                    &ast::required(ref ty_method) => local_def(ty_method.id),\n+                    &ast::provided(ref method) => local_def(method.id)\n+                }\n+            });\n+\n+            let trait_def_id = local_def(trait_id);\n+            tcx.trait_method_def_ids.insert(trait_def_id, method_def_ids);\n+        }\n+        _ => { /* Ignore things that aren't traits */ }\n     }\n \n     fn make_static_method_ty(ccx: &CrateCtxt,\n-                             am: &ast::ty_method,\n                              rp: Option<ty::region_variance>,\n-                             m: ty::method,\n+                             m: &ty::method,\n                              // Take this as an argument b/c we may check\n                              // the impl before the trait.\n                              trait_ty: ty::t,\n@@ -267,48 +308,39 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                            ty::mk_bare_fn(ccx.tcx, copy m.fty));\n         let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n                        + *m.tps);\n-        ccx.tcx.tcache.insert(local_def(am.id),\n+        ccx.tcx.tcache.insert(m.def_id,\n                               ty_param_bounds_and_ty {\n                                 bounds: bounds,\n                                 region_param: rp,\n                                 ty: ty});\n     }\n \n \n-    let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(&id).map_consume(|x| *x);\n-    match *tcx.items.get(&id) {\n-      ast_map::node_item(@ast::item {\n-                node: ast::item_trait(ref generics, _, ref ms),\n-                _\n-            }, _) => {\n-        store_methods::<ast::trait_method>(ccx, id, *ms, |m| {\n-            let def_id;\n-            match *m {\n-                ast::required(ref ty_method) => {\n-                    def_id = local_def((*ty_method).id)\n-                }\n-                ast::provided(method) => def_id = local_def(method.id)\n-            }\n-\n-            let trait_bounds = ty_param_bounds(ccx, generics);\n-            let ty_m = trait_method_to_ty_method(m);\n-            let method_ty = ty_of_ty_method(\n-                ccx,\n-                &ty_m,\n-                region_paramd,\n-                def_id,\n-                generics\n-            );\n-            if ty_m.self_ty.node == ast::sty_static {\n-                make_static_method_ty(ccx, &ty_m, region_paramd,\n-                                      method_ty, trait_ty,\n-                                      trait_bounds);\n-            }\n-            method_ty\n-        });\n-      }\n-      _ => { /* Ignore things that aren't traits */ }\n+    fn ty_method_of_trait_method(self: &CrateCtxt,\n+                                 trait_rp: Option<ty::region_variance>,\n+                                 trait_generics: &ast::Generics,\n+                                 m_id: &ast::node_id,\n+                                 m_ident: &ast::ident,\n+                                 m_self_ty: &ast::self_ty,\n+                                 m_generics: &ast::Generics,\n+                                 m_purity: &ast::purity,\n+                                 m_decl: &ast::fn_decl) -> ty::method\n+    {\n+        let rscope = MethodRscope::new(m_self_ty.node, trait_rp, trait_generics);\n+        ty::method {\n+            ident: *m_ident,\n+            tps: ty_param_bounds(self, m_generics),\n+            fty: astconv::ty_of_bare_fn(self,\n+                                        &rscope,\n+                                        *m_purity,\n+                                        AbiSet::Rust(),\n+                                        &m_generics.lifetimes,\n+                                        m_decl),\n+            // assume public, because this is only invoked on trait methods\n+            self_ty: m_self_ty.node,\n+            vis: ast::public,\n+            def_id: local_def(*m_id)\n+        }\n     }\n }\n \n@@ -501,8 +533,8 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                                    rp: Option<ty::region_variance>,\n                                    selfty: ty::t,\n                                    a_trait_ty: @ast::trait_ref,\n-                                   impl_ms: &[ConvertedMethod]) {\n-\n+                                   impl_ms: &[ConvertedMethod])\n+{\n     let tcx = ccx.tcx;\n     let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp, generics);\n \n@@ -530,7 +562,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     let trait_ms = ty::trait_methods(tcx, did);\n     for impl_ms.each |impl_m| {\n         match trait_ms.find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n-            Some(ref trait_m) => {\n+            Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method(\n                     ccx.tcx, num_impl_tps, impl_m, trait_m,\n@@ -786,29 +818,6 @@ pub fn ty_of_method(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn ty_of_ty_method(self: &CrateCtxt,\n-                       m: &ast::ty_method,\n-                       rp: Option<ty::region_variance>,\n-                       id: ast::def_id,\n-                       generics: &ast::Generics)\n-                    -> ty::method {\n-    let rscope = MethodRscope::new(m.self_ty.node, rp, generics);\n-    ty::method {\n-        ident: m.ident,\n-        tps: ty_param_bounds(self, &m.generics),\n-        fty: astconv::ty_of_bare_fn(self,\n-                                    &rscope,\n-                                    m.purity,\n-                                    AbiSet::Rust(),\n-                                    &m.generics.lifetimes,\n-                                    &m.decl),\n-        // assume public, because this is only invoked on trait methods\n-        self_ty: m.self_ty.node,\n-        vis: ast::public,\n-        def_id: id\n-    }\n-}\n-\n /*\n   Instantiates the path for the given trait reference, assuming that\n   it's bound to a valid trait type. Returns the def_id for the defining\n@@ -828,7 +837,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     let rscope = type_rscope(rp);\n \n     match lookup_def_tcx(ccx.tcx, t.path.span, t.ref_id) {\n-      ast::def_ty(t_id) => {\n+      ast::def_trait(t_id) => {\n         let tpt = astconv::ast_path_to_ty(ccx, &rscope, t_id, t.path);\n \n         write_tpt_to_tcx(ccx.tcx, t.ref_id, &tpt);"}, {"sha": "238ecf7acea279d01bfb825eb516fbb26c5bc9b9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -443,7 +443,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                    str::from_bytes(~[('a' as u8) + (id as u8)]))\n           }\n       }\n-      ty_self(*) => ~\"self\",\n+      ty_self(*) => ~\"Self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());"}, {"sha": "31dc476cbe49ea51d646df8271ab5d54c9fd594e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -194,6 +194,7 @@ pub enum def {\n     def_local(node_id, bool /* is_mutbl */),\n     def_variant(def_id /* enum */, def_id /* variant */),\n     def_ty(def_id),\n+    def_trait(def_id),\n     def_prim_ty(prim_ty),\n     def_ty_param(def_id, uint),\n     def_binding(node_id, binding_mode),"}, {"sha": "c7227fa17687c3f961bff1e3b2c61a8c554533a9", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -61,7 +61,7 @@ pub fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_struct(id) => {\n+      def_use(id) | def_struct(id) | def_trait(id) => {\n         id\n       }\n       def_arg(id, _, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)"}, {"sha": "58649f3209bb1cb4e7f0abd494e51582ee3476cb", "filename": "src/test/compile-fail/extern-no-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:expected function or foreign function but found `*u8`\n+// error-pattern:expected function but found `*u8`\n extern fn f() {\n }\n "}, {"sha": "d56cb0d51d234e962e1cb5c7dbb3e3c830acb8b4", "filename": "src/test/compile-fail/issue-3563.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007abe935209ab35d85e1b7fa0bfc88460340560/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs?ref=007abe935209ab35d85e1b7fa0bfc88460340560", "patch": "@@ -10,7 +10,7 @@\n \n trait A {\n   fn a(&self) {\n-      || self.b() //~ ERROR type `&'self self` does not implement any method in scope named `b`\n+      || self.b() //~ ERROR type `&'self Self` does not implement any method in scope named `b`\n   }\n }\n fn main() {}"}]}