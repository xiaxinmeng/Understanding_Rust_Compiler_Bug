{"sha": "b35a587da144848e6f2ebe16018df3cf1c1b2a0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNWE1ODdkYTE0NDg0OGU2ZjJlYmUxNjAxOGRmM2NmMWMxYjJhMGU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-13T23:44:26Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T10:17:08Z"}, "message": "Reviewer comments", "tree": {"sha": "f3368d3bf3ce26c39373d9de583c6d4c8e9317b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3368d3bf3ce26c39373d9de583c6d4c8e9317b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b35a587da144848e6f2ebe16018df3cf1c1b2a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b35a587da144848e6f2ebe16018df3cf1c1b2a0e", "html_url": "https://github.com/rust-lang/rust/commit/b35a587da144848e6f2ebe16018df3cf1c1b2a0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ad4363870246040a69c18dad217b235113ecd1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ad4363870246040a69c18dad217b235113ecd1c", "html_url": "https://github.com/rust-lang/rust/commit/4ad4363870246040a69c18dad217b235113ecd1c"}], "stats": {"total": 113, "additions": 66, "deletions": 47}, "files": [{"sha": "5235bbdf9cf00f67479357b1752b8824a9a0a03f", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b35a587da144848e6f2ebe16018df3cf1c1b2a0e", "patch": "@@ -848,26 +848,16 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n         self.walk_autoderefs(expr, adj.autoderefs);\n \n-        // Weird hacky special case: AutoUnsizeUniq, which converts\n-        // from a ~T to a ~Trait etc, always comes in a stylized\n-        // fashion. In particular, we want to consume the ~ pointer\n-        // being dereferenced, not the dereferenced content (as the\n-        // content is, at least for upcasts, unsized).\n-        if let Some(ty) = adj.unsize {\n-            if let ty::ty_uniq(_) = ty.sty {\n-                assert!(adj.autoderefs == 0,\n-                        format!(\"Expected no derefs with unsize AutoRefs, found: {}\",\n-                                 adj.repr(self.tcx())));\n-                let cmt_unadjusted =\n-                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n-                self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n-                return;\n-            }\n-        }\n+        let cmt_derefd =\n+            return_if_err!(self.mc.cat_expr_autoderefd(expr, adj.autoderefs));\n \n-        let cmt_derefd = return_if_err!(\n-            self.mc.cat_expr_autoderefd(expr, adj.autoderefs));\n-        self.walk_autoref(expr, cmt_derefd, adj.autoref);\n+        let cmt_refd =\n+            self.walk_autoref(expr, cmt_derefd, adj.autoref);\n+\n+        if adj.unsize.is_some() {\n+            // Unsizing consumes the thin pointer and produces a fat one.\n+            self.delegate_consume(expr.id, expr.span, cmt_refd);\n+        }\n     }\n \n "}, {"sha": "be126b0b54c833b245676325449a28159d455154", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b35a587da144848e6f2ebe16018df3cf1c1b2a0e", "patch": "@@ -283,58 +283,84 @@ pub enum Variance {\n \n #[derive(Copy, Clone, Debug)]\n pub enum AutoAdjustment<'tcx> {\n-    AdjustReifyFnPointer, // go from a fn-item type to a fn-pointer type\n-    AdjustUnsafeFnPointer, // go from a safe fn pointer to an unsafe fn pointer\n+    AdjustReifyFnPointer,   // go from a fn-item type to a fn-pointer type\n+    AdjustUnsafeFnPointer,  // go from a safe fn pointer to an unsafe fn pointer\n     AdjustDerefRef(AutoDerefRef<'tcx>),\n }\n \n /// Represents coercing a pointer to a different kind of pointer - where 'kind'\n /// here means either or both of raw vs borrowed vs unique and fat vs thin.\n-/// The simplest cases are where the pointer is not adjusted fat vs thin. Here\n-/// the pointer will be dereferenced N times (where a dereference can happen to\n-/// to raw or borrowed pointers or any smart pointer which implements Deref,\n-/// including Box<_>). The number of dereferences is given by `autoderefs`.\n-/// It can then be auto-referenced zero or one times, indicated by `autoref`, to\n-/// either a raw or borrowed pointer. In these cases unsize is None.\n ///\n-/// A DST coercon involves unsizing the underlying data. We start with a thin\n-/// pointer, deref a number of times, unsize the underlying data, then autoref.\n-/// The 'unsize' phase may change a fixed length array to a dynamically sized one,\n-/// a concrete object to a trait object, or statically sized struct to a dyncamically\n-/// sized one.\n-/// E.g., &[i32; 4] -> &[i32] is represented by:\n+/// We transform pointers by following the following steps in order:\n+/// 1. Deref the pointer `self.autoderefs` times (may be 0).\n+/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n+///    `&` or `*` pointer.\n+/// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n+///    which will do things like convert thin pointers to fat\n+///    pointers, or convert structs containing thin pointers to\n+///    structs containing fat pointers, or convert between fat\n+///    pointers.  We don't store the details of how the transform is\n+///    done (in fact, we don't know that, because it might depend on\n+///    the precise type parameters). We just store the target\n+///    type. Trans figures out what has to be done at monomorphization\n+///    time based on the precise source/target type at hand.\n+///\n+/// To make that more concrete, here are some common scenarios:\n+///\n+/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+/// Here the pointer will be dereferenced N times (where a dereference can\n+/// happen to to raw or borrowed pointers or any smart pointer which implements\n+/// Deref, including Box<_>). The number of dereferences is given by\n+/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+/// None.\n+///\n+/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+/// with a thin pointer, deref a number of times, unsize the underlying data,\n+/// then autoref. The 'unsize' phase may change a fixed length array to a\n+/// dynamically sized one, a concrete object to a trait object, or statically\n+/// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n+/// represented by:\n+///\n+/// ```\n /// AutoDerefRef {\n ///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n-///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n ///     autoref: Some(AutoPtr), // [i32] -> &[i32]\n+///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n /// }\n+/// ```\n+///\n /// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n /// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n /// The autoderef and -ref are the same as in the above example, but the type\n /// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n /// the underlying conversions from `[i32; 4]` to `[i32]`.\n ///\n-/// Box pointers are treated somewhat differently, the last deref is not counted,\n-/// nor is the 'ref' to a `Box<_>`. Imagine them more like structs.\n-/// E.g., Box<[i32; 4]> -> Box<[i32]> is represented by:\n+/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+/// that case, we have the pointer we need coming in, so there are no\n+/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+/// At some point, of course, `Box` should move out of the compiler, in which\n+/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+/// Box<[i32]> is represented by:\n+///\n+/// ```\n /// AutoDerefRef {\n ///     autoderefs: 0,\n-///     unsize: Some(Box<[i32]>),\n ///     autoref: None,\n+///     unsize: Some(Box<[i32]>),\n /// }\n+/// ```\n #[derive(Copy, Clone, Debug)]\n pub struct AutoDerefRef<'tcx> {\n-    // FIXME with more powerful date structures we could have a better design\n-    // here.\n-\n-    /// Apply a number of dereferences, producing an lvalue.\n+    /// Step 1. Apply a number of dereferences, producing an lvalue.\n     pub autoderefs: usize,\n \n-    /// Produce a pointer/reference from the value.\n+    /// Step 2. Optionally produce a pointer/reference from the value.\n     pub autoref: Option<AutoRef<'tcx>>,\n \n-    /// Unsize a pointer/reference value, e.g. &[T; n] to &[T].\n-    /// The stored type is the target pointer type.\n+    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n+    /// `&[T]`. The stored type is the target pointer type. Note that\n+    /// the source could be a thin or fat pointer.\n     pub unsize: Option<Ty<'tcx>>,\n }\n "}, {"sha": "7eb15a147963477a002de0e89c3443f51ea87ed3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b35a587da144848e6f2ebe16018df3cf1c1b2a0e", "patch": "@@ -143,7 +143,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 ty::adjust_ty_for_autoref(self.tcx(), target, Some(autoref))\n             }))\n         } else {\n-            // No unsizing should be performed without autoref.\n+            // No unsizing should be performed without autoref (at\n+            // least during method dispach). This is because we\n+            // currently only unsize `[T;N]` to `[T]`, and naturally\n+            // that must occur being a reference.\n             assert!(pick.unsize.is_none());\n             (None, None)\n         };"}, {"sha": "900ad5ce812e3dfb96018862da620d4a9a985c8f", "filename": "src/test/compile-fail/issue-21950.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35a587da144848e6f2ebe16018df3cf1c1b2a0e/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs?ref=b35a587da144848e6f2ebe16018df3cf1c1b2a0e", "patch": "@@ -14,7 +14,7 @@ use std::ops::Add;\n \n fn main() {\n     let x = &10 as\n-            //~^ ERROR the value of the associated type `Output` (from the trait `core::ops::Add`) must be specified\n             &Add;\n             //~^ ERROR the type parameter `RHS` must be explicitly specified in an object type because its default value `Self` references the type `Self`\n+            //~^^ ERROR the value of the associated type `Output` (from the trait `core::ops::Add`) must be specified\n }"}]}