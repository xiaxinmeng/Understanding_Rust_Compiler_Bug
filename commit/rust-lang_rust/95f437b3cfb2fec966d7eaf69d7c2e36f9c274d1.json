{"sha": "95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZjQzN2IzY2ZiMmZlYzk2NmQ3ZWFmNjlkN2MyZTM2ZjljMjc0ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-27T16:15:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-27T16:15:40Z"}, "message": "Auto merge of #65869 - Centril:rollup-bzlo74f, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #65566 (Use heuristics to suggest assignment)\n - #65738 (Coherence should allow fundamental types to impl traits when they are local)\n - #65777 (Don't ICE for completely unexpandable `impl Trait` types)\n - #65834 (Remove lint callback from driver)\n - #65839 (Clean up `check_consts` now that new promotion pass is implemented)\n - #65855 (Add long error explaination for E0666)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1dad208402573cc80f29f813948c3bea01cdd775", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dad208402573cc80f29f813948c3bea01cdd775"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "html_url": "https://github.com/rust-lang/rust/commit/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "html_url": "https://github.com/rust-lang/rust/commit/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6"}, {"sha": "b5b4f9b3041ba4ec72bced538d69e4cd26a01735", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b4f9b3041ba4ec72bced538d69e4cd26a01735", "html_url": "https://github.com/rust-lang/rust/commit/b5b4f9b3041ba4ec72bced538d69e4cd26a01735"}], "stats": {"total": 979, "additions": 520, "deletions": 459}, "files": [{"sha": "2734fce4ea55ab9e3ea64fad1aa24ba724ad9fab", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -378,15 +378,21 @@ fn orphan_check_trait_ref<'tcx>(\n         //      Let Ti be the first such type.\n         //     - No uncovered type parameters P1..=Pn may appear in T0..Ti (excluding Ti)\n         //\n-        fn uncover_fundamental_ty(ty: Ty<'_>) -> Vec<Ty<'_>> {\n-            if fundamental_ty(ty) {\n-                ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(ty)).collect()\n+        fn uncover_fundamental_ty<'a>(\n+            tcx: TyCtxt<'_>,\n+            ty: Ty<'a>,\n+            in_crate: InCrate,\n+        ) -> Vec<Ty<'a>> {\n+            if fundamental_ty(ty) && !ty_is_local(tcx, ty, in_crate) {\n+                ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).collect()\n             } else {\n                 vec![ty]\n             }\n         }\n \n-        for input_ty in trait_ref.input_types().flat_map(uncover_fundamental_ty) {\n+        for input_ty in\n+            trait_ref.input_types().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n+        {\n             debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n             if ty_is_local(tcx, input_ty, in_crate) {\n                 debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);"}, {"sha": "6e8bc11162f66b351571e30fb08f606dd3c9aa4a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -106,8 +106,6 @@ pub fn abort_on_err<T>(result: Result<T, ErrorReported>, sess: &Session) -> T {\n pub trait Callbacks {\n     /// Called before creating the compiler instance\n     fn config(&mut self, _config: &mut interface::Config) {}\n-    /// Called early during compilation to allow other drivers to easily register lints.\n-    fn extra_lints(&mut self, _ls: &mut lint::LintStore) {}\n     /// Called after parsing. Return value instructs the compiler whether to\n     /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n     fn after_parsing(&mut self, _compiler: &interface::Compiler) -> Compilation {"}, {"sha": "364e23ed8d0f94d9117357119f69c0ab19b14e71", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 79, "deletions": 30, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -4,26 +4,27 @@\n //! has interior mutability or needs to be dropped, as well as the visitor that emits errors when\n //! it finds operations that are invalid in a certain context.\n \n-use rustc::hir::def_id::DefId;\n+use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt};\n \n+use std::fmt;\n+\n pub use self::qualifs::Qualif;\n \n pub mod ops;\n pub mod qualifs;\n mod resolver;\n pub mod validation;\n \n-/// Information about the item currently being validated, as well as a reference to the global\n+/// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n pub struct Item<'mir, 'tcx> {\n-    body: &'mir mir::Body<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    mode: validation::Mode,\n-    for_promotion: bool,\n+    pub body: &'mir mir::Body<'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n+    pub def_id: DefId,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub const_kind: Option<ConstKind>,\n }\n \n impl Item<'mir, 'tcx> {\n@@ -33,43 +34,91 @@ impl Item<'mir, 'tcx> {\n         body: &'mir mir::Body<'tcx>,\n     ) -> Self {\n         let param_env = tcx.param_env(def_id);\n-        let mode = validation::Mode::for_item(tcx, def_id)\n-            .expect(\"const validation must only be run inside a const context\");\n+        let const_kind = ConstKind::for_item(tcx, def_id);\n \n         Item {\n             body,\n             tcx,\n             def_id,\n             param_env,\n-            mode,\n-            for_promotion: false,\n+            const_kind,\n         }\n     }\n \n-    // HACK(eddyb) this is to get around the panic for a runtime fn from `Item::new`.\n-    // Also, it allows promoting `&mut []`.\n-    pub fn for_promotion(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        body: &'mir mir::Body<'tcx>,\n-    ) -> Self {\n-        let param_env = tcx.param_env(def_id);\n-        let mode = validation::Mode::for_item(tcx, def_id)\n-            .unwrap_or(validation::Mode::ConstFn);\n+    /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.).\n+    ///\n+    /// Panics if this `Item` is not const.\n+    pub fn const_kind(&self) -> ConstKind {\n+        self.const_kind.expect(\"`const_kind` must not be called on a non-const fn\")\n+    }\n+}\n \n-        Item {\n-            body,\n-            tcx,\n-            def_id,\n-            param_env,\n-            mode,\n-            for_promotion: true,\n+/// The kinds of items which require compile-time evaluation.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ConstKind {\n+    /// A `static` item.\n+    Static,\n+    /// A `static mut` item.\n+    StaticMut,\n+    /// A `const fn` item.\n+    ConstFn,\n+    /// A `const` item or an anonymous constant (e.g. in array lengths).\n+    Const,\n+}\n+\n+impl ConstKind {\n+    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n+    /// does not require validation (e.g. a non-const `fn`).\n+    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n+        use hir::BodyOwnerKind as HirKind;\n+\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+\n+        let mode = match tcx.hir().body_owner_kind(hir_id) {\n+            HirKind::Closure => return None,\n+\n+            HirKind::Fn if tcx.is_const_fn(def_id) => ConstKind::ConstFn,\n+            HirKind::Fn => return None,\n+\n+            HirKind::Const => ConstKind::Const,\n+\n+            HirKind::Static(hir::MutImmutable) => ConstKind::Static,\n+            HirKind::Static(hir::MutMutable) => ConstKind::StaticMut,\n+        };\n+\n+        Some(mode)\n+    }\n+\n+    pub fn is_static(self) -> bool {\n+        match self {\n+            ConstKind::Static | ConstKind::StaticMut => true,\n+            ConstKind::ConstFn | ConstKind::Const => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the value returned by this item must be `Sync`.\n+    ///\n+    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n+    pub fn requires_sync(self) -> bool {\n+        match self {\n+            ConstKind::Static => true,\n+            ConstKind::ConstFn | ConstKind::Const |  ConstKind::StaticMut => false,\n         }\n     }\n }\n \n+impl fmt::Display for ConstKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ConstKind::Const => write!(f, \"constant\"),\n+            ConstKind::Static | ConstKind::StaticMut => write!(f, \"static\"),\n+            ConstKind::ConstFn => write!(f, \"constant function\"),\n+        }\n+    }\n+}\n \n-fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+/// Returns `true` if this `DefId` points to one of the official `panic` lang items.\n+pub fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     Some(def_id) == tcx.lang_items().panic_fn() ||\n     Some(def_id) == tcx.lang_items().begin_panic_fn()\n }"}, {"sha": "4b374cff8093067807e131f1cfa392ad0d5360a7", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -8,8 +8,7 @@ use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n use syntax_pos::{Span, Symbol};\n \n-use super::Item;\n-use super::validation::Mode;\n+use super::{ConstKind, Item};\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n@@ -36,7 +35,7 @@ pub trait NonConstOp: std::fmt::Debug {\n             span,\n             E0019,\n             \"{} contains unimplemented expression type\",\n-            item.mode\n+            item.const_kind()\n         );\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\"A function call isn't allowed in the const's initialization expression \\\n@@ -76,7 +75,7 @@ impl NonConstOp for FnCallNonConst {\n             E0015,\n             \"calls in {}s are limited to constant functions, \\\n              tuple structs and tuple variants\",\n-            item.mode,\n+            item.const_kind(),\n         );\n         err.emit();\n     }\n@@ -121,8 +120,8 @@ impl NonConstOp for HeapAllocation {\n \n     fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(item.tcx.sess, span, E0010,\n-                                       \"allocations are not allowed in {}s\", item.mode);\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", item.mode));\n+                                       \"allocations are not allowed in {}s\", item.const_kind());\n+        err.span_label(span, format!(\"allocation not allowed in {}s\", item.const_kind()));\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"The value of statics and constants must be known at compile time, \\\n@@ -146,7 +145,7 @@ impl NonConstOp for LiveDrop {\n         struct_span_err!(item.tcx.sess, span, E0493,\n                          \"destructors cannot be evaluated at compile-time\")\n             .span_label(span, format!(\"{}s cannot evaluate destructors\",\n-                                      item.mode))\n+                                      item.const_kind()))\n             .emit();\n     }\n }\n@@ -163,9 +162,9 @@ impl NonConstOp for MutBorrow {\n         if let BorrowKind::Mut { .. } = kind {\n             let mut err = struct_span_err!(item.tcx.sess, span, E0017,\n                                            \"references in {}s may only refer \\\n-                                            to immutable values\", item.mode);\n+                                            to immutable values\", item.const_kind());\n             err.span_label(span, format!(\"{}s require immutable values\",\n-                                                item.mode));\n+                                                item.const_kind()));\n             if item.tcx.sess.teach(&err.get_code().unwrap()) {\n                 err.note(\"References in statics and constants may only refer \\\n                           to immutable values.\\n\\n\\\n@@ -202,7 +201,7 @@ impl NonConstOp for Panic {\n             sym::const_panic,\n             span,\n             GateIssue::Language,\n-            &format!(\"panicking in {}s is unstable\", item.mode),\n+            &format!(\"panicking in {}s is unstable\", item.const_kind()),\n         );\n     }\n }\n@@ -220,7 +219,7 @@ impl NonConstOp for RawPtrComparison {\n             sym::const_compare_raw_pointers,\n             span,\n             GateIssue::Language,\n-            &format!(\"comparing raw pointers inside {}\", item.mode),\n+            &format!(\"comparing raw pointers inside {}\", item.const_kind()),\n         );\n     }\n }\n@@ -238,7 +237,7 @@ impl NonConstOp for RawPtrDeref {\n             span, GateIssue::Language,\n             &format!(\n                 \"dereferencing raw pointers in {}s is unstable\",\n-                item.mode,\n+                item.const_kind(),\n             ),\n         );\n     }\n@@ -257,7 +256,7 @@ impl NonConstOp for RawPtrToIntCast {\n             span, GateIssue::Language,\n             &format!(\n                 \"casting pointers to integers in {}s is unstable\",\n-                item.mode,\n+                item.const_kind(),\n             ),\n         );\n     }\n@@ -268,13 +267,13 @@ impl NonConstOp for RawPtrToIntCast {\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n     fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        item.mode.is_static()\n+        item.const_kind().is_static()\n     }\n \n     fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(item.tcx.sess, span, E0013,\n                                         \"{}s cannot refer to statics, use \\\n-                                        a constant instead\", item.mode);\n+                                        a constant instead\", item.const_kind());\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"Static and const variables can refer to other const variables. \\\n@@ -313,7 +312,7 @@ impl NonConstOp for Transmute {\n             &item.tcx.sess.parse_sess, sym::const_transmute,\n             span, GateIssue::Language,\n             &format!(\"The use of std::mem::transmute() \\\n-            is gated in {}s\", item.mode));\n+            is gated in {}s\", item.const_kind()));\n     }\n }\n \n@@ -322,7 +321,7 @@ pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n     fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n         // Union accesses are stable in all contexts except `const fn`.\n-        item.mode != Mode::ConstFn || Self::feature_gate(item.tcx).unwrap()\n+        item.const_kind() != ConstKind::ConstFn || Self::feature_gate(item.tcx).unwrap()\n     }\n \n     fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {"}, {"sha": "840ad303016074239ea2b81202ae91a1c5f29b07", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -5,8 +5,7 @@ use rustc::mir::interpret::ConstValue;\n use rustc::ty::{self, Ty};\n use syntax_pos::DUMMY_SP;\n \n-use super::Item as ConstCx;\n-use super::validation::Mode;\n+use super::{ConstKind, Item as ConstCx};\n \n #[derive(Clone, Copy)]\n pub struct QualifSet(u8);\n@@ -236,13 +235,17 @@ impl Qualif for HasMutInterior {\n                     // mutably without consequences.\n                     match ty.kind {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n-                        ty::Array(..) | ty::Slice(_) if cx.mode == Mode::StaticMut => {},\n-\n-                        // FIXME(eddyb) the `cx.for_promotion` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n-                        ty::Array(_, len)\n-                            if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n-                                && cx.for_promotion => {},\n+                        | ty::Array(..)\n+                        | ty::Slice(_)\n+                        if cx.const_kind == Some(ConstKind::StaticMut)\n+                        => {},\n+\n+                        // FIXME(eddyb): We only return false for `&mut []` outside a const\n+                        // context which seems unnecessary given that this is merely a ZST.\n+                        | ty::Array(_, len)\n+                        if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                            && cx.const_kind == None\n+                        => {},\n \n                         _ => return true,\n                     }"}, {"sha": "8909ef7db683d17f2682a5a01acb480ccd3227bd", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 9, "deletions": 144, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -1,21 +1,18 @@\n //! Propagate `Qualif`s between locals and query the results.\n //!\n-//! This also contains the dataflow analysis used to track `Qualif`s on complex control-flow\n-//! graphs.\n+//! This contains the dataflow analysis used to track `Qualif`s on complex control-flow graphs.\n \n use rustc::mir::visit::Visitor;\n use rustc::mir::{self, BasicBlock, Local, Location};\n use rustc_index::bit_set::BitSet;\n \n-use std::cell::RefCell;\n use std::marker::PhantomData;\n \n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n use super::{Item, Qualif};\n-use self::old_dataflow::IndirectlyMutableLocals;\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n-/// `FlowSensitiveAnalysis` as well as the logic underlying `TempPromotionResolver`.\n+/// `FlowSensitiveAnalysis`.\n ///\n /// This transfer does nothing when encountering an indirect assignment. Consumers should rely on\n /// the `IndirectlyMutableLocals` dataflow pass to see if a `Local` may have become qualified via\n@@ -147,145 +144,6 @@ where\n     }\n }\n \n-/// Types that can compute the qualifs of each local at each location in a `mir::Body`.\n-///\n-/// Code that wishes to use a `QualifResolver` must call `visit_{statement,terminator}` for each\n-/// statement or terminator, processing blocks in reverse post-order beginning from the\n-/// `START_BLOCK`. Calling code may optionally call `get` after visiting each statement or\n-/// terminator to query the qualification state immediately before that statement or terminator.\n-///\n-/// These conditions are much more restrictive than woud be required by `FlowSensitiveResolver`\n-/// alone. This is to allow a linear, on-demand `TempPromotionResolver` that can operate\n-/// efficiently on simple CFGs.\n-pub trait QualifResolver<Q> {\n-    /// Get the qualifs of each local at the last location visited.\n-    ///\n-    /// This takes `&mut self` so qualifs can be computed lazily.\n-    fn get(&mut self) -> &BitSet<Local>;\n-\n-    /// A convenience method for `self.get().contains(local)`.\n-    fn contains(&mut self, local: Local) -> bool {\n-        self.get().contains(local)\n-    }\n-\n-    /// Resets the resolver to the `START_BLOCK`. This allows a resolver to be reused\n-    /// for multiple passes over a `mir::Body`.\n-    fn reset(&mut self);\n-}\n-\n-pub type IndirectlyMutableResults<'mir, 'tcx> =\n-    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n-\n-/// A resolver for qualifs that works on arbitrarily complex CFGs.\n-///\n-/// As soon as a `Local` becomes writable through a reference (as determined by the\n-/// `IndirectlyMutableLocals` dataflow pass), we must assume that it takes on all other qualifs\n-/// possible for its type. This is because no effort is made to track qualifs across indirect\n-/// assignments (e.g. `*p = x` or calls to opaque functions).\n-///\n-/// It is possible to be more precise here by waiting until an indirect assignment actually occurs\n-/// before marking a borrowed `Local` as qualified.\n-pub struct FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n-where\n-    Q: Qualif,\n-{\n-    location: Location,\n-    indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n-    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n-    qualifs_per_local: BitSet<Local>,\n-\n-    /// The value of `Q::in_any_value_of_ty` for each local.\n-    qualifs_in_any_value_of_ty: BitSet<Local>,\n-}\n-\n-impl<Q> FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n-where\n-    Q: Qualif,\n-{\n-    pub fn new(\n-        _: Q,\n-        item: &'a Item<'mir, 'tcx>,\n-        indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n-        dead_unwinds: &BitSet<BasicBlock>,\n-    ) -> Self {\n-        let analysis = FlowSensitiveAnalysis {\n-            item,\n-            _qualif: PhantomData,\n-        };\n-        let results =\n-            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n-                .iterate_to_fixpoint();\n-        let cursor = dataflow::ResultsCursor::new(item.body, results);\n-\n-        let mut qualifs_in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n-        for (local, decl) in item.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(item, decl.ty) {\n-                qualifs_in_any_value_of_ty.insert(local);\n-            }\n-        }\n-\n-        FlowSensitiveResolver {\n-            cursor,\n-            indirectly_mutable_locals,\n-            qualifs_per_local: BitSet::new_empty(item.body.local_decls.len()),\n-            qualifs_in_any_value_of_ty,\n-            location: Location { block: mir::START_BLOCK, statement_index: 0 },\n-        }\n-    }\n-}\n-\n-impl<Q> Visitor<'tcx> for FlowSensitiveResolver<'_, '_, 'tcx, Q>\n-where\n-    Q: Qualif\n-{\n-    fn visit_statement(&mut self, _: &mir::Statement<'tcx>, location: Location) {\n-        self.location = location;\n-    }\n-\n-    fn visit_terminator(&mut self, _: &mir::Terminator<'tcx>, location: Location) {\n-        self.location = location;\n-    }\n-}\n-\n-impl<Q> QualifResolver<Q> for FlowSensitiveResolver<'_, '_, '_, Q>\n-where\n-    Q: Qualif\n-{\n-    fn get(&mut self) -> &BitSet<Local> {\n-        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n-\n-        indirectly_mutable_locals.seek(self.location);\n-        self.cursor.seek_before(self.location);\n-\n-        self.qualifs_per_local.overwrite(indirectly_mutable_locals.get());\n-        self.qualifs_per_local.union(self.cursor.get());\n-        self.qualifs_per_local.intersect(&self.qualifs_in_any_value_of_ty);\n-        &self.qualifs_per_local\n-    }\n-\n-    fn contains(&mut self, local: Local) -> bool {\n-        // No need to update the cursor if we know that `Local` cannot possibly be qualified.\n-        if !self.qualifs_in_any_value_of_ty.contains(local) {\n-            return false;\n-        }\n-\n-        // Otherwise, return `true` if this local is qualified or was indirectly mutable at any\n-        // point before this statement.\n-        self.cursor.seek_before(self.location);\n-        if self.cursor.get().contains(local) {\n-            return true;\n-        }\n-\n-        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n-        indirectly_mutable_locals.seek(self.location);\n-        indirectly_mutable_locals.get().contains(local)\n-    }\n-\n-    fn reset(&mut self)  {\n-        self.location = Location { block: mir::START_BLOCK, statement_index: 0 };\n-    }\n-}\n-\n /// The dataflow analysis used to propagate qualifs on arbitrary CFGs.\n pub(super) struct FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q> {\n     item: &'a Item<'mir, 'tcx>,\n@@ -296,6 +154,13 @@ impl<'a, 'mir, 'tcx, Q> FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n+    pub(super) fn new(_: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n+        FlowSensitiveAnalysis {\n+            item,\n+            _qualif: PhantomData,\n+        }\n+    }\n+\n     fn transfer_function(\n         &self,\n         state: &'a mut BitSet<Local>,"}, {"sha": "244d434a51eabc8c96c2a37e697b831a698dfab4", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 92, "deletions": 115, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -1,24 +1,23 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n-use rustc::hir::{self, def_id::DefId};\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n use rustc::ty::cast::CastTy;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc_index::bit_set::BitSet;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use std::cell::RefCell;\n use std::fmt;\n use std::ops::Deref;\n \n-use crate::dataflow as old_dataflow;\n-use super::{Item, Qualif, is_lang_panic_fn};\n-use super::resolver::{FlowSensitiveResolver, IndirectlyMutableResults, QualifResolver};\n-use super::qualifs::{HasMutInterior, NeedsDrop};\n+use crate::dataflow::{self as old_dataflow, generic as dataflow};\n+use self::old_dataflow::IndirectlyMutableLocals;\n use super::ops::{self, NonConstOp};\n+use super::qualifs::{HasMutInterior, NeedsDrop};\n+use super::resolver::FlowSensitiveAnalysis;\n+use super::{ConstKind, Item, Qualif, is_lang_panic_fn};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum CheckOpResult {\n@@ -27,73 +26,75 @@ pub enum CheckOpResult {\n     Allowed,\n }\n \n-/// What kind of item we are in.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Mode {\n-    /// A `static` item.\n-    Static,\n-    /// A `static mut` item.\n-    StaticMut,\n-    /// A `const fn` item.\n-    ConstFn,\n-    /// A `const` item or an anonymous constant (e.g. in array lengths).\n-    Const,\n-}\n-\n-impl Mode {\n-    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n-    /// does not require validation (e.g. a non-const `fn`).\n-    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n-        use hir::BodyOwnerKind as HirKind;\n-\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+pub type IndirectlyMutableResults<'mir, 'tcx> =\n+    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n \n-        let mode = match tcx.hir().body_owner_kind(hir_id) {\n-            HirKind::Closure => return None,\n-\n-            HirKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n-            HirKind::Fn => return None,\n-\n-            HirKind::Const => Mode::Const,\n+struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n+    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n+    in_any_value_of_ty: BitSet<Local>,\n+}\n \n-            HirKind::Static(hir::MutImmutable) => Mode::Static,\n-            HirKind::Static(hir::MutMutable) => Mode::StaticMut,\n-        };\n+impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n+    pub fn new(\n+        q: Q,\n+        item: &'a Item<'mir, 'tcx>,\n+        dead_unwinds: &BitSet<BasicBlock>,\n+    ) -> Self {\n+        let analysis = FlowSensitiveAnalysis::new(q, item);\n+        let results =\n+            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n+                .iterate_to_fixpoint();\n+        let cursor = dataflow::ResultsCursor::new(item.body, results);\n+\n+        let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n+        for (local, decl) in item.body.local_decls.iter_enumerated() {\n+            if Q::in_any_value_of_ty(item, decl.ty) {\n+                in_any_value_of_ty.insert(local);\n+            }\n+        }\n \n-        Some(mode)\n+        QualifCursor {\n+            cursor,\n+            in_any_value_of_ty,\n+        }\n     }\n+}\n \n-    pub fn is_static(self) -> bool {\n-        match self {\n-            Mode::Static | Mode::StaticMut => true,\n-            Mode::ConstFn | Mode::Const => false,\n-        }\n+pub struct Qualifs<'a, 'mir, 'tcx> {\n+    has_mut_interior: QualifCursor<'a, 'mir, 'tcx, HasMutInterior>,\n+    needs_drop: QualifCursor<'a, 'mir, 'tcx, NeedsDrop>,\n+    indirectly_mutable: IndirectlyMutableResults<'mir, 'tcx>,\n+}\n+\n+impl Qualifs<'a, 'mir, 'tcx> {\n+    fn indirectly_mutable(&mut self, local: Local, location: Location) -> bool {\n+        self.indirectly_mutable.seek(location);\n+        self.indirectly_mutable.get().contains(local)\n     }\n \n-    /// Returns `true` if the value returned by this item must be `Sync`.\n+    /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n-    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n-    pub fn requires_sync(self) -> bool {\n-        match self {\n-            Mode::Static => true,\n-            Mode::ConstFn | Mode::Const |  Mode::StaticMut => false,\n+    /// Only updates the cursor if absolutely necessary\n+    fn needs_drop_lazy_seek(&mut self, local: Local, location: Location) -> bool {\n+        if !self.needs_drop.in_any_value_of_ty.contains(local) {\n+            return false;\n         }\n+\n+        self.needs_drop.cursor.seek_before(location);\n+        self.needs_drop.cursor.get().contains(local)\n+            || self.indirectly_mutable(local, location)\n     }\n-}\n \n-impl fmt::Display for Mode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Mode::Const => write!(f, \"constant\"),\n-            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n-            Mode::ConstFn => write!(f, \"constant function\"),\n+    /// Returns `true` if `local` is `HasMutInterior`, but requires the `has_mut_interior` and\n+    /// `indirectly_mutable` cursors to be updated beforehand.\n+    fn has_mut_interior_eager_seek(&self, local: Local) -> bool {\n+        if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n+            return false;\n         }\n-    }\n-}\n \n-pub struct Qualifs<'a, 'mir, 'tcx> {\n-    has_mut_interior: FlowSensitiveResolver<'a, 'mir, 'tcx, HasMutInterior>,\n-    needs_drop: FlowSensitiveResolver<'a, 'mir, 'tcx, NeedsDrop>,\n+        self.has_mut_interior.cursor.get().contains(local)\n+            || self.indirectly_mutable.get().contains(local)\n+    }\n }\n \n pub struct Validator<'a, 'mir, 'tcx> {\n@@ -128,53 +129,43 @@ impl Deref for Validator<'_, 'mir, 'tcx> {\n     }\n }\n \n-pub fn compute_indirectly_mutable_locals<'mir, 'tcx>(\n-    item: &Item<'mir, 'tcx>,\n-) -> RefCell<IndirectlyMutableResults<'mir, 'tcx>> {\n-    let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n-\n-    let indirectly_mutable_locals = old_dataflow::do_dataflow(\n-        item.tcx,\n-        item.body,\n-        item.def_id,\n-        &item.tcx.get_attrs(item.def_id),\n-        &dead_unwinds,\n-        old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n-        |_, local| old_dataflow::DebugFormatted::new(&local),\n-    );\n-\n-    let indirectly_mutable_locals = old_dataflow::DataflowResultsCursor::new(\n-        indirectly_mutable_locals,\n-        item.body,\n-    );\n-\n-    RefCell::new(indirectly_mutable_locals)\n-}\n-\n impl Validator<'a, 'mir, 'tcx> {\n     pub fn new(\n         item: &'a Item<'mir, 'tcx>,\n-        indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n     ) -> Self {\n         let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n \n-        let needs_drop = FlowSensitiveResolver::new(\n+        let needs_drop = QualifCursor::new(\n             NeedsDrop,\n             item,\n-            indirectly_mutable_locals,\n             &dead_unwinds,\n         );\n \n-        let has_mut_interior = FlowSensitiveResolver::new(\n+        let has_mut_interior = QualifCursor::new(\n             HasMutInterior,\n             item,\n-            indirectly_mutable_locals,\n             &dead_unwinds,\n         );\n \n+        let indirectly_mutable = old_dataflow::do_dataflow(\n+            item.tcx,\n+            item.body,\n+            item.def_id,\n+            &item.tcx.get_attrs(item.def_id),\n+            &dead_unwinds,\n+            old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n+            |_, local| old_dataflow::DebugFormatted::new(&local),\n+        );\n+\n+        let indirectly_mutable = old_dataflow::DataflowResultsCursor::new(\n+            indirectly_mutable,\n+            item.body,\n+        );\n+\n         let qualifs = Qualifs {\n             needs_drop,\n             has_mut_interior,\n+            indirectly_mutable,\n         };\n \n         Validator {\n@@ -187,14 +178,6 @@ impl Validator<'a, 'mir, 'tcx> {\n         }\n     }\n \n-    /// Resets the `QualifResolver`s used by this `Validator` and returns them so they can be\n-    /// reused.\n-    pub fn into_qualifs(mut self) -> Qualifs<'a, 'mir, 'tcx> {\n-        self.qualifs.needs_drop.reset();\n-        self.qualifs.has_mut_interior.reset();\n-        self.qualifs\n-    }\n-\n     pub fn take_errors(&mut self) -> Vec<(Span, String)> {\n         std::mem::replace(&mut self.errors, vec![])\n     }\n@@ -343,7 +326,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n                 if is_thread_local {\n                     self.check_op(ops::ThreadLocalAccess);\n-                } else if self.mode == Mode::Static && context.is_mutating_use() {\n+                } else if self.const_kind() == ConstKind::Static && context.is_mutating_use() {\n                     // this is not strictly necessary as miri will also bail out\n                     // For interior mutability we can't really catch this statically as that\n                     // goes through raw pointers and intermediate temporaries, so miri has\n@@ -369,10 +352,16 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n         // interior mutability.\n         if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            let rvalue_has_mut_interior = {\n-                let has_mut_interior = self.qualifs.has_mut_interior.get();\n-                HasMutInterior::in_rvalue(&self.item, &|l| has_mut_interior.contains(l), rvalue)\n-            };\n+            // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually seek\n+            // the cursors beforehand.\n+            self.qualifs.has_mut_interior.cursor.seek_before(location);\n+            self.qualifs.indirectly_mutable.seek(location);\n+\n+            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n+                &self.item,\n+                &|local| self.qualifs.has_mut_interior_eager_seek(local),\n+                rvalue,\n+            );\n \n             if rvalue_has_mut_interior {\n                 let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n@@ -467,9 +456,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n \n-        self.qualifs.needs_drop.visit_statement(statement, location);\n-        self.qualifs.has_mut_interior.visit_statement(statement, location);\n-\n         match statement.kind {\n             StatementKind::Assign(..) => {\n                 self.super_statement(statement, location);\n@@ -489,15 +475,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n-\n-        self.qualifs.needs_drop.visit_terminator(terminator, location);\n-        self.qualifs.has_mut_interior.visit_terminator(terminator, location);\n-\n-        self.super_terminator(terminator, location);\n-    }\n-\n     fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n         trace!(\"visit_terminator_kind: kind={:?} location={:?}\", kind, location);\n         self.super_terminator_kind(kind, location);\n@@ -576,7 +553,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n-                    self.qualifs.needs_drop.contains(local)\n+                    self.qualifs.needs_drop_lazy_seek(local, location)\n                 } else {\n                     true\n                 };"}, {"sha": "3af08090853a6bfa46754ae2b350d8a855ee0b36", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 31, "deletions": 54, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -12,7 +12,6 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n-use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n@@ -30,7 +29,7 @@ use rustc_target::spec::abi::Abi;\n \n use std::{iter, mem, usize};\n \n-use crate::transform::check_consts::{qualifs, Item as ConstCx};\n+use crate::transform::check_consts::{qualifs, Item, ConstKind, is_lang_panic_fn};\n \n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -224,18 +223,13 @@ pub fn collect_temps_and_candidates(\n     (collector.temps, collector.candidates)\n }\n \n+/// Checks whether locals that appear in a promotion context (`Candidate`) are actually promotable.\n+///\n+/// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n-    is_static: bool,\n-    is_static_mut: bool,\n-    is_non_const_fn: bool,\n+    item: Item<'a, 'tcx>,\n     temps: &'a IndexVec<Local, TempState>,\n \n-    // FIXME(eddyb) deduplicate the data in this vs other fields.\n-    const_cx: ConstCx<'a, 'tcx>,\n-\n     /// Explicit promotion happens e.g. for constant arguments declared via\n     /// `rustc_args_required_const`.\n     /// Implicit promotion has almost the same rules, except that disallows `const fn`\n@@ -245,14 +239,17 @@ struct Validator<'a, 'tcx> {\n     explicit: bool,\n }\n \n-struct Unpromotable;\n+impl std::ops::Deref for Validator<'a, 'tcx> {\n+    type Target = Item<'a, 'tcx>;\n \n-impl<'tcx> Validator<'_, 'tcx> {\n-    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n-        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n-        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+    fn deref(&self) -> &Self::Target {\n+        &self.item\n     }\n+}\n+\n+struct Unpromotable;\n \n+impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n         match candidate {\n             Candidate::Ref(loc) => {\n@@ -317,13 +314,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         if self.qualif_local::<qualifs::NeedsDrop>(base) {\n                             return Err(Unpromotable);\n                         }\n+\n                         if let BorrowKind::Mut { .. } = kind {\n                             let ty = place.ty(self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n                             // is allowed right now, and only in functions.\n-                            if self.is_static_mut {\n+                            if self.const_kind == Some(ConstKind::StaticMut) {\n                                 // Inside a `static mut`, &mut [...] is also allowed.\n                                 match ty.kind {\n                                     ty::Array(..) | ty::Slice(_) => {}\n@@ -333,7 +331,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 // FIXME(eddyb) the `self.is_non_const_fn` condition\n                                 // seems unnecessary, given that this is merely a ZST.\n                                 match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) if self.is_non_const_fn => {},\n+                                    Some(0) if self.const_kind.is_none() => {},\n                                     _ => return Err(Unpromotable),\n                                 }\n                             } else {\n@@ -386,7 +384,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box(_, rhs)) => {\n-                        Q::in_rvalue(&self.const_cx, per_local, rhs)\n+                        Q::in_rvalue(&self.item, per_local, rhs)\n                     }\n                     _ => {\n                         span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n@@ -398,7 +396,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 match &terminator.kind {\n                     TerminatorKind::Call { func, args, .. } => {\n                         let return_ty = self.body.local_decls[local].ty;\n-                        Q::in_call(&self.const_cx, per_local, func, args, return_ty)\n+                        Q::in_call(&self.item, per_local, func, args, return_ty)\n                     }\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n@@ -462,8 +460,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n             } => {\n                 // Only allow statics (not consts) to refer to other statics.\n                 // FIXME(eddyb) does this matter at all for promotion?\n-                let allowed = self.is_static || self.is_static_mut;\n-                if !allowed {\n+                let is_static = self.const_kind.map_or(false, |k| k.is_static());\n+                if !is_static {\n                     return Err(Unpromotable);\n                 }\n \n@@ -490,7 +488,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n \n                     ProjectionElem::Field(..) => {\n-                        if self.is_non_const_fn {\n+                        if self.const_kind.is_none() {\n                             let base_ty =\n                                 Place::ty_from(place.base, proj_base, self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n@@ -545,7 +543,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.is_non_const_fn => {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n@@ -559,7 +557,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) if self.is_non_const_fn => {\n+            Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n@@ -600,17 +598,17 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions.\n-                    if self.is_static_mut {\n+                    if self.const_kind == Some(ConstKind::StaticMut) {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.kind {\n                             ty::Array(..) | ty::Slice(_) => {}\n                             _ => return Err(Unpromotable),\n                         }\n                     } else if let ty::Array(_, len) = ty.kind {\n-                        // FIXME(eddyb) the `self.is_non_const_fn` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n+                        // FIXME(eddyb): We only return `Unpromotable` for `&mut []` inside a\n+                        // const context which seems unnecessary given that this is merely a ZST.\n                         match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) if self.is_non_const_fn => {},\n+                            Some(0) if self.const_kind.is_none() => {},\n                             _ => return Err(Unpromotable),\n                         }\n                     } else {\n@@ -683,7 +681,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     ) -> Result<(), Unpromotable> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n-        if !self.explicit && self.is_non_const_fn {\n+        if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`.\n@@ -697,7 +695,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             ty::FnDef(def_id, _) => {\n                 self.tcx.is_const_fn(def_id) ||\n                 self.tcx.is_unstable_const_fn(def_id).is_some() ||\n-                self.is_const_panic_fn(def_id)\n+                is_lang_panic_fn(self.tcx, self.def_id)\n             }\n             _ => false,\n         };\n@@ -714,6 +712,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n }\n \n+// FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n@@ -722,33 +721,11 @@ pub fn validate_candidates(\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n     let mut validator = Validator {\n-        tcx,\n-        param_env: tcx.param_env(def_id),\n-        body,\n-        is_static: false,\n-        is_static_mut: false,\n-        is_non_const_fn: false,\n+        item: Item::new(tcx, def_id, body),\n         temps,\n-\n-        const_cx: ConstCx::for_promotion(tcx, def_id, body),\n-\n         explicit: false,\n     };\n \n-    // FIXME(eddyb) remove the distinctions that make this necessary.\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().body_owner_kind(id) {\n-        hir::BodyOwnerKind::Closure => validator.is_non_const_fn = true,\n-        hir::BodyOwnerKind::Fn => {\n-            if !tcx.is_const_fn(def_id) {\n-                validator.is_non_const_fn = true;\n-            }\n-        },\n-        hir::BodyOwnerKind::Static(hir::MutImmutable) => validator.is_static = true,\n-        hir::BodyOwnerKind::Static(hir::MutMutable) => validator.is_static_mut = true,\n-        _ => {}\n-    }\n-\n     candidates.iter().copied().filter(|&candidate| {\n         validator.explicit = match candidate {\n             Candidate::Ref(_) |"}, {"sha": "2f77cd5ddf71634aa427c40f238da5f6dc5eaf7f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -968,8 +968,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         }\n \n         let item = new_checker::Item::new(self.tcx, self.def_id, self.body);\n-        let mut_borrowed_locals = new_checker::validation::compute_indirectly_mutable_locals(&item);\n-        let mut validator = new_checker::validation::Validator::new(&item, &mut_borrowed_locals);\n+        let mut validator = new_checker::validation::Validator::new(&item);\n \n         validator.suppress_errors = !use_new_validator;\n         self.suppress_errors = use_new_validator;"}, {"sha": "e22e69a0697378cd516dbbcb0643eee24385a038", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -552,6 +552,30 @@ trait Foo {\n ```\n \"##,\n \n+E0666: r##\"\n+`impl Trait` types cannot appear nested in the\n+generic arguments of other `impl Trait` types.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0666\n+trait MyGenericTrait<T> {}\n+trait MyInnerTrait {}\n+\n+fn foo(bar: impl MyGenericTrait<impl MyInnerTrait>) {}\n+```\n+\n+Type parameters for `impl Trait` types must be\n+explicitly defined as named generic parameters:\n+\n+```\n+trait MyGenericTrait<T> {}\n+trait MyInnerTrait {}\n+\n+fn foo<T: MyInnerTrait>(bar: impl MyGenericTrait<T>) {}\n+```\n+\"##,\n+\n E0695: r##\"\n A `break` statement without a label appeared inside a labeled block.\n \n@@ -605,7 +629,6 @@ Switch to the Rust 2018 edition to use `async fn`.\n ;\n     E0226, // only a single explicit lifetime bound is permitted\n     E0472, // asm! is unsupported on this target\n-    E0666, // nested `impl Trait` is illegal\n     E0667, // `impl Trait` in projections\n     E0696, // `continue` pointing to a labeled block\n     E0706, // `async fn` in trait"}, {"sha": "9b254ab7ec1a2d2fb085faecee3541aacb350cef", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -316,22 +316,8 @@ impl<'a> PathSource<'a> {\n     }\n }\n \n-struct LateResolutionVisitor<'a, 'b> {\n-    r: &'b mut Resolver<'a>,\n-\n-    /// The module that represents the current item scope.\n-    parent_scope: ParentScope<'a>,\n-\n-    /// The current set of local scopes for types and values.\n-    /// FIXME #4948: Reuse ribs to avoid allocation.\n-    ribs: PerNS<Vec<Rib<'a>>>,\n-\n-    /// The current set of local scopes, for labels.\n-    label_ribs: Vec<Rib<'a, NodeId>>,\n-\n-    /// The trait that the current context can refer to.\n-    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n-\n+#[derive(Default)]\n+struct DiagnosticMetadata {\n     /// The current trait's associated types' ident, used for diagnostic suggestions.\n     current_trait_assoc_types: Vec<Ident>,\n \n@@ -350,6 +336,29 @@ struct LateResolutionVisitor<'a, 'b> {\n \n     /// Only used for better errors on `fn(): fn()`.\n     current_type_ascription: Vec<Span>,\n+\n+    /// Only used for better errors on `let <pat>: <expr, not type>;`.\n+    current_let_binding: Option<(Span, Option<Span>, Option<Span>)>,\n+}\n+\n+struct LateResolutionVisitor<'a, 'b> {\n+    r: &'b mut Resolver<'a>,\n+\n+    /// The module that represents the current item scope.\n+    parent_scope: ParentScope<'a>,\n+\n+    /// The current set of local scopes for types and values.\n+    /// FIXME #4948: Reuse ribs to avoid allocation.\n+    ribs: PerNS<Vec<Rib<'a>>>,\n+\n+    /// The current set of local scopes, for labels.\n+    label_ribs: Vec<Rib<'a, NodeId>>,\n+\n+    /// The trait that the current context can refer to.\n+    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n+\n+    /// Fields used to add information to diagnostic errors.\n+    diagnostic_metadata: DiagnosticMetadata,\n }\n \n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n@@ -373,7 +382,18 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         self.resolve_expr(expr, None);\n     }\n     fn visit_local(&mut self, local: &'tcx Local) {\n+        let local_spans = match local.pat.kind {\n+            // We check for this to avoid tuple struct fields.\n+            PatKind::Wild => None,\n+            _ => Some((\n+                local.pat.span,\n+                local.ty.as_ref().map(|ty| ty.span),\n+                local.init.as_ref().map(|init| init.span),\n+            )),\n+        };\n+        let original = replace(&mut self.diagnostic_metadata.current_let_binding, local_spans);\n         self.resolve_local(local);\n+        self.diagnostic_metadata.current_let_binding = original;\n     }\n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n         match ty.kind {\n@@ -415,7 +435,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         }\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, sp: Span, _: NodeId) {\n-        let previous_value = replace(&mut self.current_function, Some(sp));\n+        let previous_value = replace(&mut self.diagnostic_metadata.current_function, Some(sp));\n         debug!(\"(resolving function) entering function\");\n         let rib_kind = match fn_kind {\n             FnKind::ItemFn(..) => FnItemRibKind,\n@@ -441,7 +461,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 debug!(\"(resolving function) leaving function\");\n             })\n         });\n-        self.current_function = previous_value;\n+        self.diagnostic_metadata.current_function = previous_value;\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx Generics) {\n@@ -475,7 +495,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         // (We however cannot ban `Self` for defaults on *all* generic\n         // lists; e.g. trait generics can usefully refer to `Self`,\n         // such as in the case of `trait Add<Rhs = Self>`.)\n-        if self.current_self_item.is_some() { // (`Some` if + only if we are in ADT's generics.)\n+        if self.diagnostic_metadata.current_self_item.is_some() {\n+            // (`Some` if + only if we are in ADT's generics.)\n             default_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n         }\n \n@@ -527,12 +548,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             },\n             label_ribs: Vec::new(),\n             current_trait_ref: None,\n-            current_trait_assoc_types: Vec::new(),\n-            current_self_type: None,\n-            current_self_item: None,\n-            current_function: None,\n-            unused_labels: Default::default(),\n-            current_type_ascription: Vec::new(),\n+            diagnostic_metadata: DiagnosticMetadata::default(),\n         }\n     }\n \n@@ -892,16 +908,22 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn with_current_self_type<T>(&mut self, self_type: &Ty, f: impl FnOnce(&mut Self) -> T) -> T {\n         // Handle nested impls (inside fn bodies)\n-        let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n+        let previous_value = replace(\n+            &mut self.diagnostic_metadata.current_self_type,\n+            Some(self_type.clone()),\n+        );\n         let result = f(self);\n-        self.current_self_type = previous_value;\n+        self.diagnostic_metadata.current_self_type = previous_value;\n         result\n     }\n \n     fn with_current_self_item<T>(&mut self, self_item: &Item, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n+        let previous_value = replace(\n+            &mut self.diagnostic_metadata.current_self_item,\n+            Some(self_item.id),\n+        );\n         let result = f(self);\n-        self.current_self_item = previous_value;\n+        self.diagnostic_metadata.current_self_item = previous_value;\n         result\n     }\n \n@@ -912,14 +934,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         let trait_assoc_types = replace(\n-            &mut self.current_trait_assoc_types,\n+            &mut self.diagnostic_metadata.current_trait_assoc_types,\n             trait_items.iter().filter_map(|item| match &item.kind {\n                 TraitItemKind::Type(bounds, _) if bounds.len() == 0 => Some(item.ident),\n                 _ => None,\n             }).collect(),\n         );\n         let result = f(self);\n-        self.current_trait_assoc_types = trait_assoc_types;\n+        self.diagnostic_metadata.current_trait_assoc_types = trait_assoc_types;\n         result\n     }\n \n@@ -1746,7 +1768,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn with_resolved_label(&mut self, label: Option<Label>, id: NodeId, f: impl FnOnce(&mut Self)) {\n         if let Some(label) = label {\n-            self.unused_labels.insert(id, label.ident.span);\n+            self.diagnostic_metadata.unused_labels.insert(id, label.ident.span);\n             self.with_label_rib(NormalRibKind, |this| {\n                 let ident = label.ident.modern_and_legacy();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n@@ -1850,7 +1872,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     Some(node_id) => {\n                         // Since this res is a label, it is never read.\n                         self.r.label_res_map.insert(expr.id, node_id);\n-                        self.unused_labels.remove(&node_id);\n+                        self.diagnostic_metadata.unused_labels.remove(&node_id);\n                     }\n                 }\n \n@@ -1912,9 +1934,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 }\n             }\n             ExprKind::Type(ref type_expr, _) => {\n-                self.current_type_ascription.push(type_expr.span);\n+                self.diagnostic_metadata.current_type_ascription.push(type_expr.span);\n                 visit::walk_expr(self, expr);\n-                self.current_type_ascription.pop();\n+                self.diagnostic_metadata.current_type_ascription.pop();\n             }\n             // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n             // resolve the arguments within the proper scopes so that usages of them inside the\n@@ -2073,7 +2095,7 @@ impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n-        for (id, span) in late_resolution_visitor.unused_labels.iter() {\n+        for (id, span) in late_resolution_visitor.diagnostic_metadata.unused_labels.iter() {\n             self.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n         }\n     }"}, {"sha": "07f44e0742e34b2745a616a00cf102d4d5a5c316", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -72,10 +72,26 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         let path_str = Segment::names_to_string(path);\n         let item_str = path.last().unwrap().ident;\n         let code = source.error_code(res.is_some());\n-        let (base_msg, fallback_label, base_span) = if let Some(res) = res {\n+        let (base_msg, fallback_label, base_span, could_be_expr) = if let Some(res) = res {\n             (format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n                 format!(\"not a {}\", expected),\n-                span)\n+                span,\n+                match res {\n+                    Res::Def(DefKind::Fn, _) => {\n+                        // Verify whether this is a fn call or an Fn used as a type.\n+                        self.r.session.source_map().span_to_snippet(span).map(|snippet| {\n+                            snippet.ends_with(')')\n+                        }).unwrap_or(false)\n+                    }\n+                    Res::Def(DefKind::Ctor(..), _) |\n+                    Res::Def(DefKind::Method, _) |\n+                    Res::Def(DefKind::Const, _) |\n+                    Res::Def(DefKind::AssocConst, _) |\n+                    Res::SelfCtor(_) |\n+                    Res::PrimTy(_) |\n+                    Res::Local(_) => true,\n+                    _ => false,\n+                })\n         } else {\n             let item_span = path.last().unwrap().ident.span;\n             let (mod_prefix, mod_str) = if path.len() == 1 {\n@@ -94,7 +110,8 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             };\n             (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n                 format!(\"not found in {}\", mod_str),\n-                item_span)\n+                item_span,\n+                false)\n         };\n \n         let code = DiagnosticId::Error(code.into());\n@@ -134,7 +151,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                     \"`self` value is a keyword only available in methods with a `self` parameter\",\n                 ),\n             });\n-            if let Some(span) = &self.current_function {\n+            if let Some(span) = &self.diagnostic_metadata.current_function {\n                 err.span_label(*span, \"this function doesn't have a `self` parameter\");\n             }\n             return (err, Vec::new());\n@@ -257,6 +274,18 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         if !levenshtein_worked {\n             err.span_label(base_span, fallback_label);\n             self.type_ascription_suggestion(&mut err, base_span);\n+            match self.diagnostic_metadata.current_let_binding {\n+                Some((pat_sp, Some(ty_sp), None))\n+                if ty_sp.contains(base_span) && could_be_expr => {\n+                    err.span_suggestion_short(\n+                        pat_sp.between(ty_sp),\n+                        \"use `=` if you meant to assign\",\n+                        \" = \".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {}\n+            }\n         }\n         (err, candidates)\n     }\n@@ -491,7 +520,9 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n         // Fields are generally expected in the same contexts as locals.\n         if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n-            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n+            if let Some(node_id) = self.diagnostic_metadata.current_self_type.as_ref()\n+                .and_then(extract_node_id)\n+            {\n                 // Look for a field with the same name in the current self_type.\n                 if let Some(resolution) = self.r.partial_res_map.get(&node_id) {\n                     match resolution.base_res() {\n@@ -510,7 +541,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             }\n         }\n \n-        for assoc_type_ident in &self.current_trait_assoc_types {\n+        for assoc_type_ident in &self.diagnostic_metadata.current_trait_assoc_types {\n             if *assoc_type_ident == ident {\n                 return Some(AssocSuggestion::AssocItem);\n             }\n@@ -644,11 +675,9 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         err: &mut DiagnosticBuilder<'_>,\n         base_span: Span,\n     ) {\n-        debug!(\"type_ascription_suggetion {:?}\", base_span);\n         let cm = self.r.session.source_map();\n         let base_snippet = cm.span_to_snippet(base_span);\n-        debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n-        if let Some(sp) = self.current_type_ascription.last() {\n+        if let Some(sp) = self.diagnostic_metadata.current_type_ascription.last() {\n             let mut sp = *sp;\n             loop {\n                 // Try to find the `:`; bail on first non-':' / non-whitespace."}, {"sha": "3d380a5f1826cf585f4829e0a8034fe052569c3f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -479,10 +479,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let mut skip_add = false;\n \n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.kind {\n-                if def_id == defin_ty_def_id {\n-                    debug!(\"Skipping adding concrete definition for opaque type {:?} {:?}\",\n-                           opaque_defn, defin_ty_def_id);\n-                    skip_add = true;\n+                if let hir::OpaqueTyOrigin::TypeAlias = opaque_defn.origin {\n+                    if def_id == defin_ty_def_id {\n+                        debug!(\"Skipping adding concrete definition for opaque type {:?} {:?}\",\n+                               opaque_defn, defin_ty_def_id);\n+                        skip_add = true;\n+                    }\n                 }\n             }\n "}, {"sha": "ea7e4c05ea1ae2ad9846c71797e522bdd2fc8f67", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -239,7 +239,7 @@ impl<'a> Parser<'a> {\n                 err.span_suggestion_short(\n                     colon_sp,\n                     \"use `=` if you meant to assign\",\n-                    \"=\".to_string(),\n+                    \" =\".to_string(),\n                     Applicability::MachineApplicable\n                 );\n                 err.emit();"}, {"sha": "d461b5abd60ff849f03a568b89443c43e739b878", "filename": "src/test/ui/coherence/impl-foreign-for-locally-defined-fundamental.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -0,0 +1,16 @@\n+#![feature(fundamental)]\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+\n+#[fundamental]\n+struct Local;\n+\n+impl Remote for Local {}\n+\n+fn main() {}"}, {"sha": "0a3d9e2e0e89c3a8aa884cb119f78475de810b73", "filename": "src/test/ui/coherence/impl-foreign-for-locally-defined-fundamental[foreign].rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental%5Bforeign%5D.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental%5Bforeign%5D.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental%5Bforeign%5D.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -0,0 +1,16 @@\n+#![feature(fundamental)]\n+#![feature(re_rebalance_coherence)]\n+\n+// compile-flags:--crate-name=test\n+// aux-build:coherence_lib.rs\n+// check-pass\n+\n+extern crate coherence_lib as lib;\n+use lib::*;\n+\n+#[fundamental]\n+struct MyBox<T>(T);\n+\n+impl<T> Remote for MyBox<T> {}\n+\n+fn main() {}"}, {"sha": "2b6f15e6d3eb2b47ac10b846adf7f8b32f4c919b", "filename": "src/test/ui/impl-trait/issues/issue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -27,3 +27,4 @@ LL |     pub fn demo(_: impl Quux<Assoc=super::Deeper<impl Foo<impl Bar>>>) { }\n \n error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0666`."}, {"sha": "2b4f5e0975ac3d8ed9ac83915dc22733b825f525", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -0,0 +1,7 @@\n+// Test that an `impl Trait` type that expands to itself is an error.\n+\n+fn test() -> impl Sized { //~ ERROR E0720\n+    test()\n+}\n+\n+fn main() {}"}, {"sha": "1b5dbd814a481be35c175343e10dd2dd27eb396f", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -0,0 +1,11 @@\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type-direct.rs:3:14\n+   |\n+LL | fn test() -> impl Sized {\n+   |              ^^^^^^^^^^ expands to a recursive type\n+   |\n+   = note: type resolves to itself\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "2428b560b7001184fac39f554ad2c28188b8b68e", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "previous_filename": "src/test/ui/impl-trait/recursive-impl-trait-type.rs"}, {"sha": "b7ba0d6ab177cee0d46ca1ba9f8484b6e9d2822b", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.stderr", "status": "renamed", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -1,109 +1,109 @@\n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:6:22\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:6:22\n    |\n LL | fn option(i: i32) -> impl Sized {\n    |                      ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `std::option::Option<(impl Sized, i32)>`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:14:15\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:14:15\n    |\n LL | fn tuple() -> impl Sized {\n    |               ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `(impl Sized,)`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:18:15\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:18:15\n    |\n LL | fn array() -> impl Sized {\n    |               ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `[impl Sized; 1]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:22:13\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:22:13\n    |\n LL | fn ptr() -> impl Sized {\n    |             ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `*const impl Sized`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:26:16\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:26:16\n    |\n LL | fn fn_ptr() -> impl Sized {\n    |                ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `fn() -> impl Sized`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:30:25\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:30:25\n    |\n LL | fn closure_capture() -> impl Sized {\n    |                         ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type.rs:32:5: 32:19 x:impl Sized]`\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:32:5: 32:19 x:impl Sized]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:35:29\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:35:29\n    |\n LL | fn closure_ref_capture() -> impl Sized {\n    |                             ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type.rs:37:5: 37:20 x:impl Sized]`\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:37:5: 37:20 x:impl Sized]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:40:21\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:40:21\n    |\n LL | fn closure_sig() -> impl Sized {\n    |                     ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type.rs:41:5: 41:21]`\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:41:5: 41:21]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:44:23\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:44:23\n    |\n LL | fn generator_sig() -> impl Sized {\n    |                       ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type.rs:45:5: 45:23]`\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:45:5: 45:23]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:48:27\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:48:27\n    |\n LL | fn generator_capture() -> impl Sized {\n    |                           ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type.rs:50:5: 50:26 x:impl Sized {()}]`\n+   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:26 x:impl Sized {()}]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:53:26\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:53:26\n    |\n LL | fn substs_change<T>() -> impl Sized {\n    |                          ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `(impl Sized,)`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:57:24\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:57:24\n    |\n LL | fn generator_hold() -> impl Sized {\n    |                        ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type.rs:58:5: 62:6 {impl Sized, ()}]`\n+   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:58:5: 62:6 {impl Sized, ()}]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:69:26\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:69:26\n    |\n LL | fn mutual_recursion() -> impl Sync {\n    |                          ^^^^^^^^^ expands to a recursive type\n    |\n    = note: type resolves to itself\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type.rs:73:28\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:73:28\n    |\n LL | fn mutual_recursion_b() -> impl Sized {\n    |                            ^^^^^^^^^^ expands to a recursive type", "previous_filename": "src/test/ui/impl-trait/recursive-impl-trait-type.stderr"}, {"sha": "cfd9c0ec5b45bab47c0813922f7ec11902452e3a", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-through-non-recursive.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "previous_filename": "src/test/ui/impl-trait/recursive-impl-trait-type--through-non-recursize.rs"}, {"sha": "73c12f6137d24bad6697f1b97d1fcc1ba5733a10", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-through-non-recursive.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -1,29 +1,29 @@\n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type--through-non-recursize.rs:7:22\n+  --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:7:22\n    |\n LL | fn recursive_id() -> impl Sized {\n    |                      ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: type resolves to itself\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type--through-non-recursize.rs:11:23\n+  --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:11:23\n    |\n LL | fn recursive_id2() -> impl Sized {\n    |                       ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: type resolves to itself\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type--through-non-recursize.rs:17:24\n+  --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:17:24\n    |\n LL | fn recursive_wrap() -> impl Sized {\n    |                        ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `((impl Sized,),)`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type--through-non-recursize.rs:21:25\n+  --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:21:25\n    |\n LL | fn recursive_wrap2() -> impl Sized {\n    |                         ^^^^^^^^^^ expands to a recursive type", "previous_filename": "src/test/ui/impl-trait/recursive-impl-trait-type--through-non-recursize.stderr"}, {"sha": "b01095f15a978a097522d2a538cf9f4c32349640", "filename": "src/test/ui/impl-trait/where-allowed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -272,5 +272,5 @@ LL |     type Out = impl Debug;\n \n error: aborting due to 43 previous errors\n \n-Some errors have detailed explanations: E0282, E0562, E0658.\n+Some errors have detailed explanations: E0282, E0562, E0658, E0666.\n For more information about an error, try `rustc --explain E0282`."}, {"sha": "3749c268a68b345e935cd57fd2d551d9a693d0a8", "filename": "src/test/ui/nested_impl_trait.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fnested_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fnested_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnested_impl_trait.stderr?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -48,4 +48,5 @@ LL | fn allowed_in_ret_type() -> impl Fn() -> impl Into<u32> {\n \n error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0562`.\n+Some errors have detailed explanations: E0562, E0666.\n+For more information about an error, try `rustc --explain E0562`."}, {"sha": "61fcebd787e5142da2d509fb01e628f7dc4f2f78", "filename": "src/test/ui/privacy/privacy-ns2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -39,6 +39,7 @@ fn test_single2() {\n     use foo2::Bar;\n \n     let _x : Box<Bar>; //~ ERROR expected type, found function `Bar`\n+    let _x : Bar(); //~ ERROR expected type, found function `Bar`\n }\n \n fn test_list2() {"}, {"sha": "58671addecdedbb32c46f24b4510e1b97f4f4fc5", "filename": "src/test/ui/privacy/privacy-ns2.stderr", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -48,7 +48,26 @@ LL | use foo3::Bar;\n    |\n \n error[E0573]: expected type, found function `Bar`\n-  --> $DIR/privacy-ns2.rs:47:17\n+  --> $DIR/privacy-ns2.rs:42:14\n+   |\n+LL |     let _x : Bar();\n+   |              ^^^^^ not a type\n+   |\n+help: use `=` if you meant to assign\n+   |\n+LL |     let _x = Bar();\n+   |            ^\n+help: possible better candidates are found in other modules, you can import them into scope\n+   |\n+LL | use foo1::Bar;\n+   |\n+LL | use foo2::Bar;\n+   |\n+LL | use foo3::Bar;\n+   |\n+\n+error[E0573]: expected type, found function `Bar`\n+  --> $DIR/privacy-ns2.rs:48:17\n    |\n LL |     let _x: Box<Bar>;\n    |                 ^^^\n@@ -67,24 +86,24 @@ LL | use foo3::Bar;\n    |\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:60:15\n+  --> $DIR/privacy-ns2.rs:61:15\n    |\n LL |     use foo3::Bar;\n    |               ^^^\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:64:15\n+  --> $DIR/privacy-ns2.rs:65:15\n    |\n LL |     use foo3::Bar;\n    |               ^^^\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:71:16\n+  --> $DIR/privacy-ns2.rs:72:16\n    |\n LL |     use foo3::{Bar,Baz};\n    |                ^^^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0423, E0573, E0603.\n For more information about an error, try `rustc --explain E0423`."}, {"sha": "beea951a18a2931d8af4d8c76ddd3e7d843118db", "filename": "src/test/ui/suggestions/let-binding-init-expr-as-ty.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.rs?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -0,0 +1,12 @@\n+pub fn foo(num: i32) -> i32 {\n+    let foo: i32::from_be(num);\n+    //~^ ERROR expected type, found local variable `num`\n+    //~| ERROR parenthesized type parameters may only be used with a `Fn` trait\n+    //~| ERROR ambiguous associated type\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+    foo\n+}\n+\n+fn main() {\n+    let _ = foo(42);\n+}"}, {"sha": "a7c784fe82788402f3a14468bb1a79b00149eb36", "filename": "src/test/ui/suggestions/let-binding-init-expr-as-ty.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr?ref=95f437b3cfb2fec966d7eaf69d7c2e36f9c274d1", "patch": "@@ -0,0 +1,28 @@\n+error[E0573]: expected type, found local variable `num`\n+  --> $DIR/let-binding-init-expr-as-ty.rs:2:27\n+   |\n+LL |     let foo: i32::from_be(num);\n+   |            --             ^^^ not a type\n+   |            |\n+   |            help: use `=` if you meant to assign\n+\n+error: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/let-binding-init-expr-as-ty.rs:2:19\n+   |\n+LL |     let foo: i32::from_be(num);\n+   |                   ^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(parenthesized_params_in_types_and_modules)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #42238 <https://github.com/rust-lang/rust/issues/42238>\n+\n+error[E0223]: ambiguous associated type\n+  --> $DIR/let-binding-init-expr-as-ty.rs:2:14\n+   |\n+LL |     let foo: i32::from_be(num);\n+   |              ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<i32 as Trait>::from_be`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0223, E0573.\n+For more information about an error, try `rustc --explain E0223`."}]}