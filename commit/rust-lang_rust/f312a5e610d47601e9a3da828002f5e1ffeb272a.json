{"sha": "f312a5e610d47601e9a3da828002f5e1ffeb272a", "node_id": "C_kwDOAAsO6NoAKGYzMTJhNWU2MTBkNDc2MDFlOWEzZGE4MjgwMDJmNWUxZmZlYjI3MmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-14T03:17:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-14T03:17:11Z"}, "message": "Auto merge of #92844 - matthiaskrgr:rollup-z5wb6yi, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #90001 (Make rlib metadata strip works with MIPSr6 architecture)\n - #91687 (rustdoc: do not emit tuple variant fields if none are documented)\n - #91938 (Add `std::error::Report` type)\n - #92006 (Welcome opaque types into the fold)\n - #92142 ([code coverage] Fix missing dead code in modules that are never called)\n - #92277 (rustc_metadata: Stop passing `CrateMetadataRef` by reference (step 1))\n - #92334 (rustdoc: Preserve rendering of macro_rules matchers when possible)\n - #92807 (Update cargo)\n - #92832 (Update RELEASES for 1.58.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e0b0afdadcfa568cb67cdc17d31014c75b83971b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0b0afdadcfa568cb67cdc17d31014c75b83971b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f312a5e610d47601e9a3da828002f5e1ffeb272a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f312a5e610d47601e9a3da828002f5e1ffeb272a", "html_url": "https://github.com/rust-lang/rust/commit/f312a5e610d47601e9a3da828002f5e1ffeb272a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f312a5e610d47601e9a3da828002f5e1ffeb272a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22e491ac7ed454d34669151a8b6464cb643c9b41", "url": "https://api.github.com/repos/rust-lang/rust/commits/22e491ac7ed454d34669151a8b6464cb643c9b41", "html_url": "https://github.com/rust-lang/rust/commit/22e491ac7ed454d34669151a8b6464cb643c9b41"}, {"sha": "1a95aa9a8bb00fb22f15f2392f8d8e4bf9226d0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a95aa9a8bb00fb22f15f2392f8d8e4bf9226d0f", "html_url": "https://github.com/rust-lang/rust/commit/1a95aa9a8bb00fb22f15f2392f8d8e4bf9226d0f"}], "stats": {"total": 1870, "additions": 1514, "deletions": 356}, "files": [{"sha": "ce644f2dbc09d79177f6617c20d674f6077e54c9", "filename": "Cargo.lock", "status": "modified", "additions": 70, "deletions": 12, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -24,6 +24,17 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"ahash\"\n+version = \"0.7.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"43bb833f0bf979d8475d38fbf09ed3b8a55e1885fe93ad3f93239fc6a4f17b98\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+ \"once_cell\",\n+ \"version_check\",\n+]\n+\n [[package]]\n name = \"aho-corasick\"\n version = \"0.7.18\"\n@@ -324,7 +335,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap\",\n+ \"clap 3.0.6\",\n  \"crates-io\",\n  \"crossbeam-utils 0.8.3\",\n  \"curl\",\n@@ -604,13 +615,28 @@ dependencies = [\n  \"ansi_term 0.12.1\",\n  \"atty\",\n  \"bitflags\",\n- \"strsim\",\n- \"textwrap\",\n+ \"strsim 0.8.0\",\n+ \"textwrap 0.11.0\",\n  \"unicode-width\",\n  \"vec_map\",\n  \"yaml-rust 0.3.5\",\n ]\n \n+[[package]]\n+name = \"clap\"\n+version = \"3.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1957aa4a5fb388f0a0a73ce7556c5b42025b874e5cdc2c670775e346e97adec0\"\n+dependencies = [\n+ \"atty\",\n+ \"bitflags\",\n+ \"indexmap\",\n+ \"os_str_bytes\",\n+ \"strsim 0.10.0\",\n+ \"termcolor\",\n+ \"textwrap 0.14.2\",\n+]\n+\n [[package]]\n name = \"clippy\"\n version = \"0.1.59\"\n@@ -641,7 +667,7 @@ version = \"0.0.1\"\n dependencies = [\n  \"bytecount\",\n  \"cargo_metadata 0.14.0\",\n- \"clap\",\n+ \"clap 2.34.0\",\n  \"indoc\",\n  \"itertools 0.10.1\",\n  \"opener\",\n@@ -1579,6 +1605,7 @@ version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"362385356d610bd1e5a408ddf8d022041774b683f345a1d2cfcb4f60f8ae2db5\"\n dependencies = [\n+ \"ahash\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -1746,7 +1773,7 @@ name = \"installer\"\n version = \"0.0.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap\",\n+ \"clap 2.34.0\",\n  \"flate2\",\n  \"lazy_static\",\n  \"num_cpus\",\n@@ -2191,7 +2218,7 @@ dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap\",\n+ \"clap 2.34.0\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.7.1\",\n  \"handlebars\",\n@@ -2396,8 +2423,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"39f37e50073ccad23b6d09bcb5b263f4e76d3bb6038e4a3c08e52162ffa8abc2\"\n dependencies = [\n  \"compiler_builtins\",\n- \"crc32fast\",\n- \"indexmap\",\n  \"memchr\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -2415,6 +2440,18 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.28.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7ce8b38d41f9f3618fc23f908faae61510f8d8ce2d99cbe910641e8f1971f084\"\n+dependencies = [\n+ \"crc32fast\",\n+ \"hashbrown\",\n+ \"indexmap\",\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"odht\"\n version = \"0.3.1\"\n@@ -2512,6 +2549,15 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"os_str_bytes\"\n+version = \"6.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8e22443d1643a904602595ba1cd8f7d896afe56d26712531c5ff73a15b2fbf64\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"output_vt100\"\n version = \"0.1.2\"\n@@ -2916,7 +2962,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fec2e85e7a30f8fd31b7cf288ad363b5e51fd2cb6f53b416b0cfaabd84e1ccb\"\n dependencies = [\n  \"bitflags\",\n- \"clap\",\n+ \"clap 2.34.0\",\n  \"derive_more\",\n  \"env_logger 0.7.1\",\n  \"humantime 2.0.1\",\n@@ -3271,7 +3317,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap\",\n+ \"clap 2.34.0\",\n  \"env_logger 0.7.1\",\n  \"mdbook\",\n ]\n@@ -3801,7 +3847,7 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n- \"object 0.26.2\",\n+ \"object 0.28.1\",\n  \"pathdiff\",\n  \"regex\",\n  \"rustc_apfloat\",\n@@ -5133,13 +5179,19 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \n+[[package]]\n+name = \"strsim\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n+\n [[package]]\n name = \"structopt\"\n version = \"0.3.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"40b9788f4202aa75c240ecc9c15c65185e6a39ccdeb0fd5d008b98825464c87c\"\n dependencies = [\n- \"clap\",\n+ \"clap 2.34.0\",\n  \"lazy_static\",\n  \"structopt-derive\",\n ]\n@@ -5310,6 +5362,12 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n+[[package]]\n+name = \"textwrap\"\n+version = \"0.14.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0066c8d12af8b5acd21e00547c3797fde4e8677254a7ee429176ccebbe93dd80\"\n+\n [[package]]\n name = \"thiserror\"\n version = \"1.0.30\""}, {"sha": "fc0a5d35f30f3595295d2f01620ab7fea0780527", "filename": "RELEASES.md", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -43,7 +43,6 @@ Stabilized APIs\n - [`Option::unwrap_unchecked`]\n - [`Result::unwrap_unchecked`]\n - [`Result::unwrap_err_unchecked`]\n-- [`NonZero{unsigned}::is_power_of_two`]\n - [`File::options`]\n \n These APIs are now usable in const contexts:\n@@ -56,10 +55,6 @@ These APIs are now usable in const contexts:\n - [`Duration::checked_mul`]\n - [`Duration::saturating_mul`]\n - [`Duration::checked_div`]\n-- [`MaybeUninit::as_ptr`]\n-- [`MaybeUninit::as_mut_ptr`]\n-- [`MaybeUninit::assume_init`]\n-- [`MaybeUninit::assume_init_ref`]\n \n Cargo\n -----\n@@ -141,7 +136,6 @@ and related tools.\n [`Option::unwrap_unchecked`]: https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_unchecked\n [`Result::unwrap_unchecked`]: https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.unwrap_unchecked\n [`Result::unwrap_err_unchecked`]: https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.unwrap_err_unchecked\n-[`NonZero{unsigned}::is_power_of_two`]: https://doc.rust-lang.org/stable/std/num/struct.NonZeroU8.html#method.is_power_of_two\n [`File::options`]: https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.options\n [`unix::process::ExitStatusExt::core_dumped`]: https://doc.rust-lang.org/stable/std/os/unix/process/trait.ExitStatusExt.html#tymethod.core_dumped\n [`unix::process::ExitStatusExt::stopped_signal`]: https://doc.rust-lang.org/stable/std/os/unix/process/trait.ExitStatusExt.html#tymethod.stopped_signal\n@@ -165,10 +159,6 @@ and related tools.\n [`Duration::div_f32`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_f32\n [`Duration::div_duration_f64`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_duration_f64\n [`Duration::div_duration_f32`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_duration_f32\n-[`MaybeUninit::as_ptr`]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.as_ptr\n-[`MaybeUninit::as_mut_ptr`]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.as_mut_ptr\n-[`MaybeUninit::assume_init`]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init\n-[`MaybeUninit::assume_init_ref`]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_ref\n \n Version 1.57.0 (2021-12-02)\n =========================="}, {"sha": "32f18419753e9827fb02ab6966c4ad2b246e163f", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 34, "deletions": 86, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -5,12 +5,13 @@ use crate::llvm;\n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n-use rustc_hir::def_id::{DefId, DefIdSet};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefIdSet;\n use rustc_llvm::RustString;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::Symbol;\n \n use std::ffi::CString;\n \n@@ -46,7 +47,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     // functions exist. Generate synthetic functions with a (required) single counter, and add the\n     // MIR `Coverage` code regions to the `function_coverage_map`, before calling\n     // `ctx.take_function_coverage_map()`.\n-    if !tcx.sess.instrument_coverage_except_unused_functions() {\n+    if cx.codegen_unit.is_code_coverage_dead_code_cgu() {\n         add_unused_functions(cx);\n     }\n \n@@ -271,26 +272,35 @@ fn save_function_record(\n /// `DefId`s (`tcx` query `mir_keys`) minus the codegenned `DefId`s (`tcx` query\n /// `codegened_and_inlined_items`).\n ///\n-/// *HOWEVER* the codegenned `DefId`s are partitioned across multiple `CodegenUnit`s (CGUs), and\n-/// this function is processing a `function_coverage_map` for the functions (`Instance`/`DefId`)\n-/// allocated to only one of those CGUs. We must NOT inject any unused functions's `CodeRegion`s\n-/// more than once, so we have to pick a CGUs `function_coverage_map` into which the unused\n-/// function will be inserted.\n+/// These unused functions are then codegen'd in one of the CGUs which is marked as the\n+/// \"code coverage dead code cgu\" during the partitioning process. This prevents us from generating\n+/// code regions for the same function more than once which can lead to linker errors regarding\n+/// duplicate symbols.\n fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let tcx = cx.tcx;\n+    assert!(cx.codegen_unit.is_code_coverage_dead_code_cgu());\n \n-    // FIXME(#79622): Can this solution be simplified and/or improved? Are there other sources\n-    // of compiler state data that might help (or better sources that could be exposed, but\n-    // aren't yet)?\n+    let tcx = cx.tcx;\n \n     let ignore_unused_generics = tcx.sess.instrument_coverage_except_unused_generics();\n \n-    let all_def_ids: DefIdSet = tcx\n+    let eligible_def_ids: DefIdSet = tcx\n         .mir_keys(())\n         .iter()\n         .filter_map(|local_def_id| {\n             let def_id = local_def_id.to_def_id();\n-            if ignore_unused_generics && tcx.generics_of(def_id).requires_monomorphization(tcx) {\n+            let kind = tcx.def_kind(def_id);\n+            // `mir_keys` will give us `DefId`s for all kinds of things, not\n+            // just \"functions\", like consts, statics, etc. Filter those out.\n+            // If `ignore_unused_generics` was specified, filter out any\n+            // generic functions from consideration as well.\n+            if !matches!(\n+                kind,\n+                DefKind::Fn | DefKind::AssocFn | DefKind::Closure | DefKind::Generator\n+            ) {\n+                return None;\n+            } else if ignore_unused_generics\n+                && tcx.generics_of(def_id).requires_monomorphization(tcx)\n+            {\n                 return None;\n             }\n             Some(local_def_id.to_def_id())\n@@ -299,79 +309,17 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n \n     let codegenned_def_ids = tcx.codegened_and_inlined_items(());\n \n-    let mut unused_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n-    for &non_codegenned_def_id in all_def_ids.difference(codegenned_def_ids) {\n-        // Make sure the non-codegenned (unused) function has at least one MIR\n-        // `Coverage` statement with a code region, and return its file name.\n-        if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n-            let def_ids =\n-                unused_def_ids_by_file.entry(*non_codegenned_file_name).or_insert_with(Vec::new);\n-            def_ids.push(non_codegenned_def_id);\n-        }\n-    }\n+    for &non_codegenned_def_id in eligible_def_ids.difference(codegenned_def_ids) {\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(non_codegenned_def_id);\n \n-    if unused_def_ids_by_file.is_empty() {\n-        // There are no unused functions with file names to add (in any CGU)\n-        return;\n-    }\n-\n-    // Each `CodegenUnit` (CGU) has its own function_coverage_map, and generates a specific binary\n-    // with its own coverage map.\n-    //\n-    // Each covered function `Instance` can be included in only one coverage map, produced from a\n-    // specific function_coverage_map, from a specific CGU.\n-    //\n-    // Since unused functions did not generate code, they are not associated with any CGU yet.\n-    //\n-    // To avoid injecting the unused functions in multiple coverage maps (for multiple CGUs)\n-    // determine which function_coverage_map has the responsibility for publishing unreachable\n-    // coverage, based on file name: For each unused function, find the CGU that generates the\n-    // first function (based on sorted `DefId`) from the same file.\n-    //\n-    // Add a new `FunctionCoverage` to the `function_coverage_map`, with unreachable code regions\n-    // for each region in it's MIR.\n-\n-    // Convert the `HashSet` of `codegenned_def_ids` to a sortable vector, and sort them.\n-    let mut sorted_codegenned_def_ids: Vec<DefId> = codegenned_def_ids.iter().copied().collect();\n-    sorted_codegenned_def_ids.sort_unstable();\n-\n-    let mut first_covered_def_id_by_file: FxHashMap<Symbol, DefId> = FxHashMap::default();\n-    for &def_id in sorted_codegenned_def_ids.iter() {\n-        if let Some(covered_file_name) = tcx.covered_file_name(def_id) {\n-            // Only add files known to have unused functions\n-            if unused_def_ids_by_file.contains_key(covered_file_name) {\n-                first_covered_def_id_by_file.entry(*covered_file_name).or_insert(def_id);\n-            }\n+        // If a function is marked `#[no_coverage]`, then skip generating a\n+        // dead code stub for it.\n+        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_COVERAGE) {\n+            debug!(\"skipping unused fn marked #[no_coverage]: {:?}\", non_codegenned_def_id);\n+            continue;\n         }\n-    }\n-\n-    // Get the set of def_ids with coverage regions, known by *this* CoverageContext.\n-    let cgu_covered_def_ids: DefIdSet = match cx.coverage_context() {\n-        Some(ctx) => ctx\n-            .function_coverage_map\n-            .borrow()\n-            .keys()\n-            .map(|&instance| instance.def.def_id())\n-            .collect(),\n-        None => return,\n-    };\n \n-    let cgu_covered_files: FxHashSet<Symbol> = first_covered_def_id_by_file\n-        .iter()\n-        .filter_map(\n-            |(&file_name, def_id)| {\n-                if cgu_covered_def_ids.contains(def_id) { Some(file_name) } else { None }\n-            },\n-        )\n-        .collect();\n-\n-    // For each file for which this CGU is responsible for adding unused function coverage,\n-    // get the `def_id`s for each unused function (if any), define a synthetic function with a\n-    // single LLVM coverage counter, and add the function's coverage `CodeRegion`s. to the\n-    // function_coverage_map.\n-    for covered_file_name in cgu_covered_files {\n-        for def_id in unused_def_ids_by_file.remove(&covered_file_name).into_iter().flatten() {\n-            cx.define_unused_fn(def_id);\n-        }\n+        debug!(\"generating unused fn: {:?}\", non_codegenned_def_id);\n+        cx.define_unused_fn(non_codegenned_def_id);\n     }\n }"}, {"sha": "6c6ee363ea310c1480c3208d2c3596793a4167cd", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -41,6 +41,6 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n \n [dependencies.object]\n-version = \"0.26.2\"\n+version = \"0.28.0\"\n default-features = false\n features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]"}, {"sha": "6849533abc049e7098e8ee154b08bb23d1ed3f9d", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -95,7 +95,7 @@ fn search_for_metadata<'a>(\n         .map_err(|e| format!(\"failed to read {} section in '{}': {}\", section, path.display(), e))\n }\n \n-fn create_object_file(sess: &Session) -> Option<write::Object> {\n+fn create_object_file(sess: &Session) -> Option<write::Object<'static>> {\n     let endianness = match sess.target.options.endian {\n         Endian::Little => Endianness::Little,\n         Endian::Big => Endianness::Big,\n@@ -135,12 +135,24 @@ fn create_object_file(sess: &Session) -> Option<write::Object> {\n         Architecture::Mips => {\n             // copied from `mipsel-linux-gnu-gcc foo.c -c` and\n             // inspecting the resulting `e_flags` field.\n-            let e_flags = elf::EF_MIPS_ARCH_32R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n+            let e_flags = elf::EF_MIPS_CPIC\n+                | elf::EF_MIPS_PIC\n+                | if sess.target.options.cpu.contains(\"r6\") {\n+                    elf::EF_MIPS_ARCH_32R6 | elf::EF_MIPS_NAN2008\n+                } else {\n+                    elf::EF_MIPS_ARCH_32R2\n+                };\n             file.flags = FileFlags::Elf { e_flags };\n         }\n         Architecture::Mips64 => {\n             // copied from `mips64el-linux-gnuabi64-gcc foo.c -c`\n-            let e_flags = elf::EF_MIPS_ARCH_64R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n+            let e_flags = elf::EF_MIPS_CPIC\n+                | elf::EF_MIPS_PIC\n+                | if sess.target.options.cpu.contains(\"r6\") {\n+                    elf::EF_MIPS_ARCH_64R6 | elf::EF_MIPS_NAN2008\n+                } else {\n+                    elf::EF_MIPS_ARCH_64R2\n+                };\n             file.flags = FileFlags::Elf { e_flags };\n         }\n         Architecture::Riscv64 if sess.target.options.features.contains(\"+d\") => {"}, {"sha": "d5e65705b2885a9f2226ec032ae21bab8fd98dbf", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -551,6 +551,22 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             let predicate = predicate.subst(tcx, substs);\n             debug!(?predicate);\n \n+            let predicate = predicate.fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| match *ty.kind() {\n+                    // Replace all other mentions of the same opaque type with the hidden type,\n+                    // as the bounds must hold on the hidden type after all.\n+                    ty::Opaque(def_id2, substs2) if def_id == def_id2 && substs == substs2 => {\n+                        ty_var\n+                    }\n+                    // Instantiate nested instances of `impl Trait`.\n+                    ty::Opaque(..) => self.instantiate_opaque_types_in_map(ty),\n+                    _ => ty,\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            });\n+\n             // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n             let predicate = predicate.fold_with(&mut BottomUpFolder {\n                 tcx,\n@@ -575,10 +591,6 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     return tcx.ty_error();\n                 }\n             }\n-            // Change the predicate to refer to the type variable,\n-            // which will be the concrete type instead of the opaque type.\n-            // This also instantiates nested instances of `impl Trait`.\n-            let predicate = self.instantiate_opaque_types_in_map(predicate);\n \n             let cause =\n                 traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);"}, {"sha": "85c0d28d5ea1180e4e5e00b27e64e1a09e589972", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -218,40 +218,40 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'tcx Session) {\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadataRef<'a> {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for CrateMetadataRef<'a> {\n     #[inline]\n     fn blob(self) -> &'a MetadataBlob {\n-        &self.blob\n+        &self.cdata.blob\n     }\n     #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n-        Some(*self)\n+        Some(self)\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, &'tcx Session) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (CrateMetadataRef<'a>, &'tcx Session) {\n     #[inline]\n     fn blob(self) -> &'a MetadataBlob {\n-        &self.0.blob\n+        &self.0.cdata.blob\n     }\n     #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n-        Some(*self.0)\n+        Some(self.0)\n     }\n     #[inline]\n     fn sess(self) -> Option<&'tcx Session> {\n-        Some(&self.1)\n+        Some(self.1)\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     #[inline]\n     fn blob(self) -> &'a MetadataBlob {\n-        &self.0.blob\n+        &self.0.cdata.blob\n     }\n     #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n-        Some(*self.0)\n+        Some(self.0)\n     }\n     #[inline]\n     fn tcx(self) -> Option<TyCtxt<'tcx>> {\n@@ -414,9 +414,9 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n             Ok(cdata\n                 .root\n                 .syntax_contexts\n-                .get(&cdata, id)\n+                .get(cdata, id)\n                 .unwrap_or_else(|| panic!(\"Missing SyntaxContext {:?} for crate {:?}\", id, cname))\n-                .decode((&cdata, sess)))\n+                .decode((cdata, sess)))\n         })\n     }\n }\n@@ -442,15 +442,15 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n             let expn_data = crate_data\n                 .root\n                 .expn_data\n-                .get(&crate_data, index)\n+                .get(crate_data, index)\n                 .unwrap()\n-                .decode((&crate_data, sess));\n+                .decode((crate_data, sess));\n             let expn_hash = crate_data\n                 .root\n                 .expn_hashes\n-                .get(&crate_data, index)\n+                .get(crate_data, index)\n                 .unwrap()\n-                .decode((&crate_data, sess));\n+                .decode((crate_data, sess));\n             (expn_data, expn_hash)\n         });\n         Ok(expn_id)\n@@ -706,7 +706,7 @@ impl CrateRoot<'_> {\n }\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n-    fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n+    fn raw_proc_macro(self, id: DefIndex) -> &'a ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n         let pos = self\n@@ -721,7 +721,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    fn opt_item_ident(&self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n+    fn opt_item_ident(self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n         let name = self.def_key(item_index).disambiguated_data.data.get_opt_name()?;\n         let span = match self.root.tables.ident_span.get(self, item_index) {\n             Some(lazy_span) => lazy_span.decode((self, sess)),\n@@ -737,15 +737,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         Some(Ident::new(name, span))\n     }\n \n-    fn item_ident(&self, item_index: DefIndex, sess: &Session) -> Ident {\n+    fn item_ident(self, item_index: DefIndex, sess: &Session) -> Ident {\n         self.opt_item_ident(item_index, sess).expect(\"no encoded ident for item\")\n     }\n \n-    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n+    fn maybe_kind(self, item_id: DefIndex) -> Option<EntryKind> {\n         self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n     }\n \n-    fn kind(&self, item_id: DefIndex) -> EntryKind {\n+    fn kind(self, item_id: DefIndex) -> EntryKind {\n         self.maybe_kind(item_id).unwrap_or_else(|| {\n             bug!(\n                 \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn def_kind(&self, item_id: DefIndex) -> DefKind {\n+    fn def_kind(self, item_id: DefIndex) -> DefKind {\n         self.root.tables.def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(|| {\n             bug!(\n                 \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n@@ -767,7 +767,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+    fn get_span(self, index: DefIndex, sess: &Session) -> Span {\n         self.root\n             .tables\n             .span\n@@ -776,7 +776,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+    fn load_proc_macro(self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n         let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n@@ -807,7 +807,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n+    fn get_trait_def(self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         match self.kind(item_id) {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n@@ -837,7 +837,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_variant(\n-        &self,\n+        self,\n         kind: &EntryKind,\n         index: DefIndex,\n         parent_did: DefId,\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+    fn get_adt_def(self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n         let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -914,15 +914,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_explicit_predicates(\n-        &self,\n+        self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.tables.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     fn get_inferred_outlives(\n-        &self,\n+        self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n@@ -935,15 +935,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_super_predicates(\n-        &self,\n+        self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.tables.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     fn get_explicit_item_bounds(\n-        &self,\n+        self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n@@ -955,11 +955,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .unwrap_or_default()\n     }\n \n-    fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n+    fn get_generics(self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.root.tables.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn get_type(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         self.root\n             .tables\n             .ty\n@@ -968,78 +968,78 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+    fn get_stability(self, id: DefIndex) -> Option<attr::Stability> {\n         self.root.tables.stability.get(self, id).map(|stab| stab.decode(self))\n     }\n \n-    fn get_const_stability(&self, id: DefIndex) -> Option<attr::ConstStability> {\n+    fn get_const_stability(self, id: DefIndex) -> Option<attr::ConstStability> {\n         self.root.tables.const_stability.get(self, id).map(|stab| stab.decode(self))\n     }\n \n-    fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+    fn get_deprecation(self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.root.tables.deprecation.get(self, id).map(|depr| depr.decode(self))\n     }\n \n-    fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+    fn get_visibility(self, id: DefIndex) -> ty::Visibility {\n         self.root.tables.visibility.get(self, id).unwrap().decode(self)\n     }\n \n-    fn get_impl_data(&self, id: DefIndex) -> ImplData {\n+    fn get_impl_data(self, id: DefIndex) -> ImplData {\n         match self.kind(id) {\n             EntryKind::Impl(data) => data.decode(self),\n             _ => bug!(),\n         }\n     }\n \n-    fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_parent_impl(self, id: DefIndex) -> Option<DefId> {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n+    fn get_impl_polarity(self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n \n-    fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n+    fn get_impl_defaultness(self, id: DefIndex) -> hir::Defaultness {\n         self.get_impl_data(id).defaultness\n     }\n \n-    fn get_impl_constness(&self, id: DefIndex) -> hir::Constness {\n+    fn get_impl_constness(self, id: DefIndex) -> hir::Constness {\n         self.get_impl_data(id).constness\n     }\n \n-    fn get_trait_item_def_id(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_trait_item_def_id(self, id: DefIndex) -> Option<DefId> {\n         self.root.tables.trait_item_def_id.get(self, id).map(|d| d.decode(self))\n     }\n \n-    fn get_coerce_unsized_info(&self, id: DefIndex) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n+    fn get_coerce_unsized_info(self, id: DefIndex) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n+    fn get_impl_trait(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.root.tables.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n-    fn get_expn_that_defined(&self, id: DefIndex, sess: &Session) -> ExpnId {\n+    fn get_expn_that_defined(self, id: DefIndex, sess: &Session) -> ExpnId {\n         self.root.tables.expn_that_defined.get(self, id).unwrap().decode((self, sess))\n     }\n \n     fn get_const_param_default(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> rustc_middle::ty::Const<'tcx> {\n         self.root.tables.const_defaults.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Option<Symbol>)] {\n+    fn get_lib_features(self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Option<Symbol>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root.lib_features.decode(self))\n     }\n \n     /// Iterates over the language items in the given crate.\n-    fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    fn get_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -1054,7 +1054,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    fn get_diagnostic_items(&self) -> DiagnosticItems {\n+    fn get_diagnostic_items(self) -> DiagnosticItems {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any diagnostic-items to the target.\n             Default::default()\n@@ -1079,7 +1079,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     /// Module here is understood in name resolution sense - it can be a `mod` item,\n     /// or a crate root, or an enum, or a trait.\n     fn for_each_module_child(\n-        &self,\n+        self,\n         id: DefIndex,\n         mut callback: impl FnMut(ModChild),\n         sess: &Session,\n@@ -1177,15 +1177,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn is_ctfe_mir_available(&self, id: DefIndex) -> bool {\n+    fn is_ctfe_mir_available(self, id: DefIndex) -> bool {\n         self.root.tables.mir_for_ctfe.get(self, id).is_some()\n     }\n \n-    fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+    fn is_item_mir_available(self, id: DefIndex) -> bool {\n         self.root.tables.mir.get(self, id).is_some()\n     }\n \n-    fn module_expansion(&self, id: DefIndex, sess: &Session) -> ExpnId {\n+    fn module_expansion(self, id: DefIndex, sess: &Session) -> ExpnId {\n         match self.kind(id) {\n             EntryKind::Mod(_) | EntryKind::Enum(_) | EntryKind::Trait(_) => {\n                 self.get_expn_that_defined(id, sess)\n@@ -1194,7 +1194,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    fn get_optimized_mir(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.root\n             .tables\n             .mir\n@@ -1205,7 +1205,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_mir_for_ctfe(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    fn get_mir_for_ctfe(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.root\n             .tables\n             .mir_for_ctfe\n@@ -1217,7 +1217,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_thir_abstract_const(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n@@ -1228,7 +1228,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }\n \n-    fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u32> {\n+    fn get_unused_generic_params(self, id: DefIndex) -> FiniteBitSet<u32> {\n         self.root\n             .tables\n             .unused_generic_params\n@@ -1237,7 +1237,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .unwrap_or_default()\n     }\n \n-    fn get_promoted_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> IndexVec<Promoted, Body<'tcx>> {\n+    fn get_promoted_mir(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> IndexVec<Promoted, Body<'tcx>> {\n         self.root\n             .tables\n             .promoted_mir\n@@ -1248,7 +1248,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn mir_const_qualif(&self, id: DefIndex) -> mir::ConstQualifs {\n+    fn mir_const_qualif(self, id: DefIndex) -> mir::ConstQualifs {\n         match self.kind(id) {\n             EntryKind::AnonConst(qualif, _)\n             | EntryKind::Const(qualif, _)\n@@ -1263,14 +1263,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_fn_has_self_parameter(&self, id: DefIndex) -> bool {\n+    fn get_fn_has_self_parameter(self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::AssocFn(data) => data.decode(self).has_self,\n             _ => false,\n         }\n     }\n \n-    fn get_associated_item_def_ids(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [DefId] {\n+    fn get_associated_item_def_ids(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [DefId] {\n         if let Some(children) = self.root.tables.children.get(self, id) {\n             tcx.arena.alloc_from_iter(\n                 children.decode((self, tcx.sess)).map(|child_index| self.local_def_id(child_index)),\n@@ -1280,7 +1280,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_associated_item(&self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n+    fn get_associated_item(self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let ident = self.item_ident(id, sess);\n@@ -1307,11 +1307,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_item_variances(&'a self, id: DefIndex) -> impl Iterator<Item = ty::Variance> + 'a {\n+    fn get_item_variances(self, id: DefIndex) -> impl Iterator<Item = ty::Variance> + 'a {\n         self.root.tables.variances.get(self, id).unwrap_or_else(Lazy::empty).decode(self)\n     }\n \n-    fn get_ctor_def_id_and_kind(&self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n+    fn get_ctor_def_id_and_kind(self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) | EntryKind::Variant(data) => {\n                 let vdata = data.decode(self);\n@@ -1322,7 +1322,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_item_attrs(\n-        &'a self,\n+        self,\n         id: DefIndex,\n         sess: &'a Session,\n     ) -> impl Iterator<Item = ast::Attribute> + 'a {\n@@ -1346,7 +1346,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<Symbol>> {\n+    fn get_struct_field_names(self, id: DefIndex, sess: &Session) -> Vec<Spanned<Symbol>> {\n         self.root\n             .tables\n             .children\n@@ -1357,7 +1357,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .collect()\n     }\n \n-    fn get_struct_field_visibilities(&self, id: DefIndex) -> Vec<Visibility> {\n+    fn get_struct_field_visibilities(self, id: DefIndex) -> Vec<Visibility> {\n         self.root\n             .tables\n             .children\n@@ -1369,7 +1369,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_inherent_implementations_for_type(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> &'tcx [DefId] {\n@@ -1384,20 +1384,20 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_traits(&'a self) -> impl Iterator<Item = DefId> + 'a {\n-        self.root.traits.decode(self).map(|index| self.local_def_id(index))\n+    fn get_traits(self) -> impl Iterator<Item = DefId> + 'a {\n+        self.root.traits.decode(self).map(move |index| self.local_def_id(index))\n     }\n \n-    fn get_trait_impls(&'a self) -> impl Iterator<Item = (DefId, Option<SimplifiedType>)> + 'a {\n-        self.trait_impls.values().flat_map(move |impls| {\n+    fn get_trait_impls(self) -> impl Iterator<Item = (DefId, Option<SimplifiedType>)> + 'a {\n+        self.cdata.trait_impls.values().flat_map(move |impls| {\n             impls\n                 .decode(self)\n-                .map(|(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty))\n+                .map(move |(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty))\n         })\n     }\n \n     fn get_implementations_of_trait(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n     ) -> &'tcx [(DefId, Option<SimplifiedType>)] {\n@@ -1424,7 +1424,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_trait_of_item(self, id: DefIndex) -> Option<DefId> {\n         let def_key = self.def_key(id);\n         match def_key.disambiguated_data.data {\n             DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n@@ -1437,7 +1437,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLib> {\n+    fn get_native_libraries(self, sess: &Session) -> Vec<NativeLib> {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1446,7 +1446,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_proc_macro_quoted_span(&self, index: usize, sess: &Session) -> Span {\n+    fn get_proc_macro_quoted_span(self, index: usize, sess: &Session) -> Span {\n         self.root\n             .tables\n             .proc_macro_quoted_spans\n@@ -1455,7 +1455,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> Lrc<FxHashMap<DefId, ForeignModule>> {\n+    fn get_foreign_modules(self, tcx: TyCtxt<'tcx>) -> Lrc<FxHashMap<DefId, ForeignModule>> {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             Lrc::new(FxHashMap::default())\n@@ -1467,7 +1467,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_dylib_dependency_formats(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n         tcx.arena.alloc_from_iter(\n@@ -1478,7 +1478,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    fn get_missing_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1487,7 +1487,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n+    fn get_fn_param_names(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) | EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,\n@@ -1497,7 +1497,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn exported_symbols(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportLevel)] {\n         if self.root.is_proc_macro_crate() {\n@@ -1509,7 +1509,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_rendered_const(&self, id: DefIndex) -> String {\n+    fn get_rendered_const(self, id: DefIndex) -> String {\n         match self.kind(id) {\n             EntryKind::AnonConst(_, data)\n             | EntryKind::Const(_, data)\n@@ -1518,7 +1518,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_macro(&self, id: DefIndex, sess: &Session) -> MacroDef {\n+    fn get_macro(self, id: DefIndex, sess: &Session) -> MacroDef {\n         match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode((self, sess)),\n             _ => bug!(),\n@@ -1527,7 +1527,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     // This replicates some of the logic of the crate-local `is_const_fn_raw` query, because we\n     // don't serialize constness for tuple variant and tuple struct constructors.\n-    fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n+    fn is_const_fn_raw(self, id: DefIndex) -> bool {\n         let constness = match self.kind(id) {\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n@@ -1538,7 +1538,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         constness == hir::Constness::Const\n     }\n \n-    fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+    fn asyncness(self, id: DefIndex) -> hir::IsAsync {\n         match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.asyncness,\n@@ -1547,7 +1547,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn is_foreign_item(&self, id: DefIndex) -> bool {\n+    fn is_foreign_item(self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::ForeignImmStatic | EntryKind::ForeignMutStatic | EntryKind::ForeignFn(_) => {\n                 true\n@@ -1556,27 +1556,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n+    fn static_mutability(self, id: DefIndex) -> Option<hir::Mutability> {\n         match self.kind(id) {\n             EntryKind::ImmStatic | EntryKind::ForeignImmStatic => Some(hir::Mutability::Not),\n             EntryKind::MutStatic | EntryKind::ForeignMutStatic => Some(hir::Mutability::Mut),\n             _ => None,\n         }\n     }\n \n-    fn generator_kind(&self, id: DefIndex) -> Option<hir::GeneratorKind> {\n+    fn generator_kind(self, id: DefIndex) -> Option<hir::GeneratorKind> {\n         match self.kind(id) {\n             EntryKind::Generator(data) => Some(data),\n             _ => None,\n         }\n     }\n \n-    fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+    fn fn_sig(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         self.root.tables.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]\n-    fn def_key(&self, index: DefIndex) -> DefKey {\n+    fn def_key(self, index: DefIndex) -> DefKey {\n         *self\n             .def_key_cache\n             .lock()\n@@ -1585,13 +1585,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     // Returns the path leading to the thing with this `id`.\n-    fn def_path(&self, id: DefIndex) -> DefPath {\n+    fn def_path(self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     fn def_path_hash_unlocked(\n-        &self,\n+        self,\n         index: DefIndex,\n         def_path_hashes: &mut FxHashMap<DefIndex, DefPathHash>,\n     ) -> DefPathHash {\n@@ -1601,17 +1601,17 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     #[inline]\n-    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+    fn def_path_hash(self, index: DefIndex) -> DefPathHash {\n         let mut def_path_hashes = self.def_path_hash_cache.lock();\n         self.def_path_hash_unlocked(index, &mut def_path_hashes)\n     }\n \n     #[inline]\n-    fn def_path_hash_to_def_index(&self, hash: DefPathHash) -> DefIndex {\n+    fn def_path_hash_to_def_index(self, hash: DefPathHash) -> DefIndex {\n         self.def_path_hash_map.def_path_hash_to_def_index(&hash)\n     }\n \n-    fn expn_hash_to_expn_id(&self, sess: &Session, index_guess: u32, hash: ExpnHash) -> ExpnId {\n+    fn expn_hash_to_expn_id(self, sess: &Session, index_guess: u32, hash: ExpnHash) -> ExpnId {\n         debug_assert_eq!(ExpnId::from_hash(hash), None);\n         let index_guess = ExpnIndex::from_u32(index_guess);\n         let old_hash = self.root.expn_hashes.get(self, index_guess).map(|lazy| lazy.decode(self));\n@@ -1669,7 +1669,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    fn imported_source_files(&self, sess: &Session) -> &'a [ImportedSourceFile] {\n+    fn imported_source_files(self, sess: &Session) -> &'a [ImportedSourceFile] {\n         // Translate the virtual `/rustc/$hash` prefix back to a real directory\n         // that should hold actual sources, where possible.\n         //"}, {"sha": "3a6c091b3313d33a7a8d79fde56cc4da97e6c63b", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -247,6 +247,9 @@ pub struct CodegenUnit<'tcx> {\n     items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n     size_estimate: Option<usize>,\n     primary: bool,\n+    /// True if this is CGU is used to hold code coverage information for dead code,\n+    /// false otherwise.\n+    is_code_coverage_dead_code_cgu: bool,\n }\n \n /// Specifies the linkage type for a `MonoItem`.\n@@ -277,7 +280,13 @@ pub enum Visibility {\n impl<'tcx> CodegenUnit<'tcx> {\n     #[inline]\n     pub fn new(name: Symbol) -> CodegenUnit<'tcx> {\n-        CodegenUnit { name, items: Default::default(), size_estimate: None, primary: false }\n+        CodegenUnit {\n+            name,\n+            items: Default::default(),\n+            size_estimate: None,\n+            primary: false,\n+            is_code_coverage_dead_code_cgu: false,\n+        }\n     }\n \n     pub fn name(&self) -> Symbol {\n@@ -304,6 +313,15 @@ impl<'tcx> CodegenUnit<'tcx> {\n         &mut self.items\n     }\n \n+    pub fn is_code_coverage_dead_code_cgu(&self) -> bool {\n+        self.is_code_coverage_dead_code_cgu\n+    }\n+\n+    /// Marks this CGU as the one used to contain code coverage information for dead code.\n+    pub fn make_code_coverage_dead_code_cgu(&mut self) {\n+        self.is_code_coverage_dead_code_cgu = true;\n+    }\n+\n     pub fn mangle_name(human_readable_name: &str) -> String {\n         // We generate a 80 bit hash from the name. This should be enough to\n         // avoid collisions and is still reasonably short for filenames.\n@@ -404,9 +422,11 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n             // The size estimate is not relevant to the hash\n             size_estimate: _,\n             primary: _,\n+            is_code_coverage_dead_code_cgu,\n         } = *self;\n \n         name.hash_stable(hcx, hasher);\n+        is_code_coverage_dead_code_cgu.hash_stable(hcx, hasher);\n \n         let mut items: Vec<(Fingerprint, _)> = items\n             .iter()"}, {"sha": "3772f1c9feab0812d3c4d48affdd2ee9fbc01370", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -386,16 +386,6 @@ rustc_queries! {\n         storage(ArenaCacheSelector<'tcx>)\n     }\n \n-    /// Returns the name of the file that contains the function body, if instrumented for coverage.\n-    query covered_file_name(key: DefId) -> Option<Symbol> {\n-        desc {\n-            |tcx| \"retrieving the covered file name, if instrumented, for `{}`\",\n-            tcx.def_path_str(key)\n-        }\n-        storage(ArenaCacheSelector<'tcx>)\n-        cache_on_disk_if { key.is_local() }\n-    }\n-\n     /// Returns the `CodeRegions` for a function that has instrumented coverage, in case the\n     /// function was optimized out before codegen, and before being added to the Coverage Map.\n     query covered_code_regions(key: DefId) -> Vec<&'tcx mir::coverage::CodeRegion> {"}, {"sha": "46de6d939a1df69fbc48754e4c02d94fb3b6225d", "filename": "compiler/rustc_mir_transform/src/coverage/query.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -9,7 +9,6 @@ use rustc_span::def_id::DefId;\n /// A `query` provider for retrieving coverage information injected into MIR.\n pub(crate) fn provide(providers: &mut Providers) {\n     providers.coverageinfo = |tcx, def_id| coverageinfo(tcx, def_id);\n-    providers.covered_file_name = |tcx, def_id| covered_file_name(tcx, def_id);\n     providers.covered_code_regions = |tcx, def_id| covered_code_regions(tcx, def_id);\n }\n \n@@ -137,25 +136,6 @@ fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, instance_def: ty::InstanceDef<'tcx>) ->\n     coverage_visitor.info\n }\n \n-fn covered_file_name(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n-    if tcx.is_mir_available(def_id) {\n-        let body = mir_body(tcx, def_id);\n-        for bb_data in body.basic_blocks().iter() {\n-            for statement in bb_data.statements.iter() {\n-                if let StatementKind::Coverage(box ref coverage) = statement.kind {\n-                    if let Some(code_region) = coverage.code_region.as_ref() {\n-                        if is_inlined(body, statement) {\n-                            continue;\n-                        }\n-                        return Some(code_region.file_name);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    return None;\n-}\n-\n fn covered_code_regions<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Vec<&'tcx CodeRegion> {\n     let body = mir_body(tcx, def_id);\n     body.basic_blocks()"}, {"sha": "67597a0d7b46b5dea8d40f9bce3480e6ebb68146", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -201,6 +201,40 @@ pub fn partition<'tcx>(\n         partitioner.internalize_symbols(cx, &mut post_inlining);\n     }\n \n+    let instrument_dead_code =\n+        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n+\n+    if instrument_dead_code {\n+        assert!(\n+            post_inlining.codegen_units.len() > 0,\n+            \"There must be at least one CGU that code coverage data can be generated in.\"\n+        );\n+\n+        // Find the smallest CGU that has exported symbols and put the dead\n+        // function stubs in that CGU. We look for exported symbols to increase\n+        // the likelihood the linker won't throw away the dead functions.\n+        // FIXME(#92165): In order to truly resolve this, we need to make sure\n+        // the object file (CGU) containing the dead function stubs is included\n+        // in the final binary. This will probably require forcing these\n+        // function symbols to be included via `-u` or `/include` linker args.\n+        let mut cgus: Vec<_> = post_inlining.codegen_units.iter_mut().collect();\n+        cgus.sort_by_key(|cgu| cgu.size_estimate());\n+\n+        let dead_code_cgu = if let Some(cgu) = cgus\n+            .into_iter()\n+            .rev()\n+            .filter(|cgu| cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External))\n+            .next()\n+        {\n+            cgu\n+        } else {\n+            // If there are no CGUs that have externally linked items,\n+            // then we just pick the first CGU as a fallback.\n+            &mut post_inlining.codegen_units[0]\n+        };\n+        dead_code_cgu.make_code_coverage_dead_code_cgu();\n+    }\n+\n     // Finally, sort by codegen unit name, so that we get deterministic results.\n     let PostInliningPartitioning {\n         codegen_units: mut result,"}, {"sha": "d662f61e2cf4dbbc1532fef09b656d71d7b546d1", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -4,7 +4,9 @@ use crate::infer::canonical::{\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n-use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::infer::canonical::{Canonical, Certainty};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::PredicateObligations;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use std::fmt;\n@@ -17,7 +19,6 @@ pub mod implied_outlives_bounds;\n pub mod normalize;\n pub mod outlives;\n pub mod prove_predicate;\n-use self::prove_predicate::ProvePredicate;\n pub mod subtype;\n \n pub use rustc_middle::traits::query::type_op::*;\n@@ -80,9 +81,14 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'tcx>,\n         output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n-    ) -> Fallible<(Self::QueryResponse, Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>)> {\n+    ) -> Fallible<(\n+        Self::QueryResponse,\n+        Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>,\n+        PredicateObligations<'tcx>,\n+        Certainty,\n+    )> {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n-            return Ok((result, None));\n+            return Ok((result, None, vec![], Certainty::Proven));\n         }\n \n         // FIXME(#33684) -- We need to use\n@@ -104,20 +110,7 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n                 output_query_region_constraints,\n             )?;\n \n-        // Typically, instantiating NLL query results does not\n-        // create obligations. However, in some cases there\n-        // are unresolved type variables, and unify them *can*\n-        // create obligations. In that case, we have to go\n-        // fulfill them. We do this via a (recursive) query.\n-        for obligation in obligations {\n-            let ((), _) = ProvePredicate::fully_perform_into(\n-                obligation.param_env.and(ProvePredicate::new(obligation.predicate)),\n-                infcx,\n-                output_query_region_constraints,\n-            )?;\n-        }\n-\n-        Ok((value, Some(canonical_self)))\n+        Ok((value, Some(canonical_self), obligations, canonical_result.value.certainty))\n     }\n }\n \n@@ -129,9 +122,39 @@ where\n \n     fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let mut region_constraints = QueryRegionConstraints::default();\n-        let (output, canonicalized_query) =\n+        let (output, canonicalized_query, mut obligations, _) =\n             Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n \n+        // Typically, instantiating NLL query results does not\n+        // create obligations. However, in some cases there\n+        // are unresolved type variables, and unify them *can*\n+        // create obligations. In that case, we have to go\n+        // fulfill them. We do this via a (recursive) query.\n+        while !obligations.is_empty() {\n+            trace!(\"{:#?}\", obligations);\n+            let mut progress = false;\n+            for obligation in std::mem::take(&mut obligations) {\n+                let obligation = infcx.resolve_vars_if_possible(obligation);\n+                match ProvePredicate::fully_perform_into(\n+                    obligation.param_env.and(ProvePredicate::new(obligation.predicate)),\n+                    infcx,\n+                    &mut region_constraints,\n+                ) {\n+                    Ok(((), _, new, certainty)) => {\n+                        obligations.extend(new);\n+                        progress = true;\n+                        if let Certainty::Ambiguous = certainty {\n+                            obligations.push(obligation);\n+                        }\n+                    }\n+                    Err(_) => obligations.push(obligation),\n+                }\n+            }\n+            if !progress {\n+                return Err(NoSolution);\n+            }\n+        }\n+\n         // Promote the final query-region-constraints into a\n         // (optional) ref-counted vector:\n         let region_constraints ="}, {"sha": "643108b88bf79da58131bacff61a3a67e616285b", "filename": "library/std/src/error.rs", "status": "modified", "additions": 643, "deletions": 4, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -25,7 +25,7 @@ use crate::backtrace::Backtrace;\n use crate::borrow::Cow;\n use crate::cell;\n use crate::char;\n-use crate::fmt::{self, Debug, Display};\n+use crate::fmt::{self, Debug, Display, Write};\n use crate::mem::transmute;\n use crate::num;\n use crate::str;\n@@ -63,7 +63,7 @@ pub trait Error: Debug + Display {\n     ///\n     /// #[derive(Debug)]\n     /// struct SuperError {\n-    ///     side: SuperErrorSideKick,\n+    ///     source: SuperErrorSideKick,\n     /// }\n     ///\n     /// impl fmt::Display for SuperError {\n@@ -74,7 +74,7 @@ pub trait Error: Debug + Display {\n     ///\n     /// impl Error for SuperError {\n     ///     fn source(&self) -> Option<&(dyn Error + 'static)> {\n-    ///         Some(&self.side)\n+    ///         Some(&self.source)\n     ///     }\n     /// }\n     ///\n@@ -90,7 +90,7 @@ pub trait Error: Debug + Display {\n     /// impl Error for SuperErrorSideKick {}\n     ///\n     /// fn get_super_error() -> Result<(), SuperError> {\n-    ///     Err(SuperError { side: SuperErrorSideKick })\n+    ///     Err(SuperError { source: SuperErrorSideKick })\n     /// }\n     ///\n     /// fn main() {\n@@ -810,3 +810,642 @@ impl dyn Error + Send + Sync {\n         })\n     }\n }\n+\n+/// An error reporter that print's an error and its sources.\n+///\n+/// Report also exposes configuration options for formatting the error chain, either entirely on a\n+/// single line, or in multi-line format with each cause in the error chain on a new line.\n+///\n+/// `Report` only requires that the wrapped error implements `Error`. It doesn't require that the\n+/// wrapped error be `Send`, `Sync`, or `'static`.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// #![feature(error_reporter)]\n+/// use std::error::{Error, Report};\n+/// use std::fmt;\n+///\n+/// #[derive(Debug)]\n+/// struct SuperError {\n+///     source: SuperErrorSideKick,\n+/// }\n+///\n+/// impl fmt::Display for SuperError {\n+///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         write!(f, \"SuperError is here!\")\n+///     }\n+/// }\n+///\n+/// impl Error for SuperError {\n+///     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+///         Some(&self.source)\n+///     }\n+/// }\n+///\n+/// #[derive(Debug)]\n+/// struct SuperErrorSideKick;\n+///\n+/// impl fmt::Display for SuperErrorSideKick {\n+///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         write!(f, \"SuperErrorSideKick is here!\")\n+///     }\n+/// }\n+///\n+/// impl Error for SuperErrorSideKick {}\n+///\n+/// fn get_super_error() -> Result<(), SuperError> {\n+///     Err(SuperError { source: SuperErrorSideKick })\n+/// }\n+///\n+/// fn main() {\n+///     match get_super_error() {\n+///         Err(e) => println!(\"Error: {}\", Report::new(e)),\n+///         _ => println!(\"No error\"),\n+///     }\n+/// }\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// Error: SuperError is here!: SuperErrorSideKick is here!\n+/// ```\n+///\n+/// ## Output consistency\n+///\n+/// Report prints the same output via `Display` and `Debug`, so it works well with\n+/// [`Result::unwrap`]/[`Result::expect`] which print their `Err` variant via `Debug`:\n+///\n+/// ```should_panic\n+/// #![feature(error_reporter)]\n+/// use std::error::Report;\n+/// # use std::error::Error;\n+/// # use std::fmt;\n+/// # #[derive(Debug)]\n+/// # struct SuperError {\n+/// #     source: SuperErrorSideKick,\n+/// # }\n+/// # impl fmt::Display for SuperError {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperError is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperError {\n+/// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+/// #         Some(&self.source)\n+/// #     }\n+/// # }\n+/// # #[derive(Debug)]\n+/// # struct SuperErrorSideKick;\n+/// # impl fmt::Display for SuperErrorSideKick {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperErrorSideKick is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperErrorSideKick {}\n+/// # fn get_super_error() -> Result<(), SuperError> {\n+/// #     Err(SuperError { source: SuperErrorSideKick })\n+/// # }\n+///\n+/// get_super_error().map_err(Report::new).unwrap();\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: SuperError is here!: SuperErrorSideKick is here!', src/error.rs:34:40\n+/// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n+/// ```\n+///\n+/// ## Return from `main`\n+///\n+/// `Report` also implements `From` for all types that implement [`Error`], this when combined with\n+/// the `Debug` output means `Report` is an ideal starting place for formatting errors returned\n+/// from `main`.\n+///\n+/// ```should_panic\n+/// #![feature(error_reporter)]\n+/// use std::error::Report;\n+/// # use std::error::Error;\n+/// # use std::fmt;\n+/// # #[derive(Debug)]\n+/// # struct SuperError {\n+/// #     source: SuperErrorSideKick,\n+/// # }\n+/// # impl fmt::Display for SuperError {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperError is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperError {\n+/// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+/// #         Some(&self.source)\n+/// #     }\n+/// # }\n+/// # #[derive(Debug)]\n+/// # struct SuperErrorSideKick;\n+/// # impl fmt::Display for SuperErrorSideKick {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperErrorSideKick is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperErrorSideKick {}\n+/// # fn get_super_error() -> Result<(), SuperError> {\n+/// #     Err(SuperError { source: SuperErrorSideKick })\n+/// # }\n+///\n+/// fn main() -> Result<(), Report> {\n+///     get_super_error()?;\n+///     Ok(())\n+/// }\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// Error: SuperError is here!: SuperErrorSideKick is here!\n+/// ```\n+///\n+/// **Note**: `Report`s constructed via `?` and `From` will be configured to use the single line\n+/// output format, if you want to make sure your `Report`s are pretty printed and include backtrace\n+/// you will need to manually convert and enable those flags.\n+///\n+/// ```should_panic\n+/// #![feature(error_reporter)]\n+/// use std::error::Report;\n+/// # use std::error::Error;\n+/// # use std::fmt;\n+/// # #[derive(Debug)]\n+/// # struct SuperError {\n+/// #     source: SuperErrorSideKick,\n+/// # }\n+/// # impl fmt::Display for SuperError {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperError is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperError {\n+/// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+/// #         Some(&self.source)\n+/// #     }\n+/// # }\n+/// # #[derive(Debug)]\n+/// # struct SuperErrorSideKick;\n+/// # impl fmt::Display for SuperErrorSideKick {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperErrorSideKick is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperErrorSideKick {}\n+/// # fn get_super_error() -> Result<(), SuperError> {\n+/// #     Err(SuperError { source: SuperErrorSideKick })\n+/// # }\n+///\n+/// fn main() -> Result<(), Report> {\n+///     get_super_error()\n+///         .map_err(Report::from)\n+///         .map_err(|r| r.pretty(true).show_backtrace(true))?;\n+///     Ok(())\n+/// }\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// Error: SuperError is here!\n+///\n+/// Caused by:\n+///       SuperErrorSideKick is here!\n+/// ```\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+pub struct Report<E = Box<dyn Error>> {\n+    /// The error being reported.\n+    error: E,\n+    /// Whether a backtrace should be included as part of the report.\n+    show_backtrace: bool,\n+    /// Whether the report should be pretty-printed.\n+    pretty: bool,\n+}\n+\n+impl<E> Report<E>\n+where\n+    Report<E>: From<E>,\n+{\n+    /// Create a new `Report` from an input error.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn new(error: E) -> Report<E> {\n+        Self::from(error)\n+    }\n+}\n+\n+impl<E> Report<E> {\n+    /// Enable pretty-printing the report across multiple lines.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(error_reporter)]\n+    /// use std::error::Report;\n+    /// # use std::error::Error;\n+    /// # use std::fmt;\n+    /// # #[derive(Debug)]\n+    /// # struct SuperError {\n+    /// #     source: SuperErrorSideKick,\n+    /// # }\n+    /// # impl fmt::Display for SuperError {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperError is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperError {\n+    /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+    /// #         Some(&self.source)\n+    /// #     }\n+    /// # }\n+    /// # #[derive(Debug)]\n+    /// # struct SuperErrorSideKick;\n+    /// # impl fmt::Display for SuperErrorSideKick {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperErrorSideKick is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperErrorSideKick {}\n+    ///\n+    /// let error = SuperError { source: SuperErrorSideKick };\n+    /// let report = Report::new(error).pretty(true);\n+    /// eprintln!(\"Error: {:?}\", report);\n+    /// ```\n+    ///\n+    /// This example produces the following output:\n+    ///\n+    /// ```console\n+    /// Error: SuperError is here!\n+    ///\n+    /// Caused by:\n+    ///       SuperErrorSideKick is here!\n+    /// ```\n+    ///\n+    /// When there are multiple source errors the causes will be numbered in order of iteration\n+    /// starting from the outermost error.\n+    ///\n+    /// ```rust\n+    /// #![feature(error_reporter)]\n+    /// use std::error::Report;\n+    /// # use std::error::Error;\n+    /// # use std::fmt;\n+    /// # #[derive(Debug)]\n+    /// # struct SuperError {\n+    /// #     source: SuperErrorSideKick,\n+    /// # }\n+    /// # impl fmt::Display for SuperError {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperError is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperError {\n+    /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+    /// #         Some(&self.source)\n+    /// #     }\n+    /// # }\n+    /// # #[derive(Debug)]\n+    /// # struct SuperErrorSideKick {\n+    /// #     source: SuperErrorSideKickSideKick,\n+    /// # }\n+    /// # impl fmt::Display for SuperErrorSideKick {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperErrorSideKick is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperErrorSideKick {\n+    /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+    /// #         Some(&self.source)\n+    /// #     }\n+    /// # }\n+    /// # #[derive(Debug)]\n+    /// # struct SuperErrorSideKickSideKick;\n+    /// # impl fmt::Display for SuperErrorSideKickSideKick {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperErrorSideKickSideKick is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperErrorSideKickSideKick { }\n+    ///\n+    /// let source = SuperErrorSideKickSideKick;\n+    /// let source = SuperErrorSideKick { source };\n+    /// let error = SuperError { source };\n+    /// let report = Report::new(error).pretty(true);\n+    /// eprintln!(\"Error: {:?}\", report);\n+    /// ```\n+    ///\n+    /// This example produces the following output:\n+    ///\n+    /// ```console\n+    /// Error: SuperError is here!\n+    ///\n+    /// Caused by:\n+    ///    0: SuperErrorSideKick is here!\n+    ///    1: SuperErrorSideKickSideKick is here!\n+    /// ```\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn pretty(mut self, pretty: bool) -> Self {\n+        self.pretty = pretty;\n+        self\n+    }\n+\n+    /// Display backtrace if available when using pretty output format.\n+    ///\n+    /// # Examples\n+    ///\n+    /// **Note**: Report will search for the first `Backtrace` it can find starting from the\n+    /// outermost error. In this example it will display the backtrace from the second error in the\n+    /// chain, `SuperErrorSideKick`.\n+    ///\n+    /// ```rust\n+    /// #![feature(error_reporter)]\n+    /// #![feature(backtrace)]\n+    /// # use std::error::Error;\n+    /// # use std::fmt;\n+    /// use std::error::Report;\n+    /// use std::backtrace::Backtrace;\n+    ///\n+    /// # #[derive(Debug)]\n+    /// # struct SuperError {\n+    /// #     source: SuperErrorSideKick,\n+    /// # }\n+    /// # impl fmt::Display for SuperError {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperError is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperError {\n+    /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+    /// #         Some(&self.source)\n+    /// #     }\n+    /// # }\n+    /// #[derive(Debug)]\n+    /// struct SuperErrorSideKick {\n+    ///     backtrace: Backtrace,\n+    /// }\n+    ///\n+    /// impl SuperErrorSideKick {\n+    ///     fn new() -> SuperErrorSideKick {\n+    ///         SuperErrorSideKick { backtrace: Backtrace::force_capture() }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Error for SuperErrorSideKick {\n+    ///     fn backtrace(&self) -> Option<&Backtrace> {\n+    ///         Some(&self.backtrace)\n+    ///     }\n+    /// }\n+    ///\n+    /// // The rest of the example is unchanged ...\n+    /// # impl fmt::Display for SuperErrorSideKick {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperErrorSideKick is here!\")\n+    /// #     }\n+    /// # }\n+    ///\n+    /// let source = SuperErrorSideKick::new();\n+    /// let error = SuperError { source };\n+    /// let report = Report::new(error).pretty(true).show_backtrace(true);\n+    /// eprintln!(\"Error: {:?}\", report);\n+    /// ```\n+    ///\n+    /// This example produces something similar to the following output:\n+    ///\n+    /// ```console\n+    /// Error: SuperError is here!\n+    ///\n+    /// Caused by:\n+    ///       SuperErrorSideKick is here!\n+    ///\n+    /// Stack backtrace:\n+    ///    0: rust_out::main::_doctest_main_src_error_rs_1158_0::SuperErrorSideKick::new\n+    ///    1: rust_out::main::_doctest_main_src_error_rs_1158_0\n+    ///    2: rust_out::main\n+    ///    3: core::ops::function::FnOnce::call_once\n+    ///    4: std::sys_common::backtrace::__rust_begin_short_backtrace\n+    ///    5: std::rt::lang_start::{{closure}}\n+    ///    6: std::panicking::try\n+    ///    7: std::rt::lang_start_internal\n+    ///    8: std::rt::lang_start\n+    ///    9: main\n+    ///   10: __libc_start_main\n+    ///   11: _start\n+    /// ```\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn show_backtrace(mut self, show_backtrace: bool) -> Self {\n+        self.show_backtrace = show_backtrace;\n+        self\n+    }\n+}\n+\n+impl<E> Report<E>\n+where\n+    E: Error,\n+{\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        // have to grab the backtrace on the first error directly since that error may not be\n+        // 'static\n+        let backtrace = self.error.backtrace();\n+        let backtrace = backtrace.or_else(|| {\n+            self.error\n+                .source()\n+                .map(|source| source.chain().find_map(|source| source.backtrace()))\n+                .flatten()\n+        });\n+        backtrace\n+    }\n+\n+    /// Format the report as a single line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.error)?;\n+\n+        let sources = self.error.source().into_iter().flat_map(<dyn Error>::chain);\n+\n+        for cause in sources {\n+            write!(f, \": {}\", cause)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Format the report as multiple lines, with each error cause on its own line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_multiline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let error = &self.error;\n+\n+        write!(f, \"{}\", error)?;\n+\n+        if let Some(cause) = error.source() {\n+            write!(f, \"\\n\\nCaused by:\")?;\n+\n+            let multiple = cause.source().is_some();\n+\n+            for (ind, error) in cause.chain().enumerate() {\n+                writeln!(f)?;\n+                let mut indented = Indented { inner: f };\n+                if multiple {\n+                    write!(indented, \"{: >4}: {}\", ind, error)?;\n+                } else {\n+                    write!(indented, \"      {}\", error)?;\n+                }\n+            }\n+        }\n+\n+        if self.show_backtrace {\n+            let backtrace = self.backtrace();\n+\n+            if let Some(backtrace) = backtrace {\n+                let backtrace = backtrace.to_string();\n+\n+                f.write_str(\"\\n\\nStack backtrace:\\n\")?;\n+                f.write_str(backtrace.trim_end())?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl Report<Box<dyn Error>> {\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        // have to grab the backtrace on the first error directly since that error may not be\n+        // 'static\n+        let backtrace = self.error.backtrace();\n+        let backtrace = backtrace.or_else(|| {\n+            self.error\n+                .source()\n+                .map(|source| source.chain().find_map(|source| source.backtrace()))\n+                .flatten()\n+        });\n+        backtrace\n+    }\n+\n+    /// Format the report as a single line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.error)?;\n+\n+        let sources = self.error.source().into_iter().flat_map(<dyn Error>::chain);\n+\n+        for cause in sources {\n+            write!(f, \": {}\", cause)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Format the report as multiple lines, with each error cause on its own line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_multiline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let error = &self.error;\n+\n+        write!(f, \"{}\", error)?;\n+\n+        if let Some(cause) = error.source() {\n+            write!(f, \"\\n\\nCaused by:\")?;\n+\n+            let multiple = cause.source().is_some();\n+\n+            for (ind, error) in cause.chain().enumerate() {\n+                writeln!(f)?;\n+                let mut indented = Indented { inner: f };\n+                if multiple {\n+                    write!(indented, \"{: >4}: {}\", ind, error)?;\n+                } else {\n+                    write!(indented, \"      {}\", error)?;\n+                }\n+            }\n+        }\n+\n+        if self.show_backtrace {\n+            let backtrace = self.backtrace();\n+\n+            if let Some(backtrace) = backtrace {\n+                let backtrace = backtrace.to_string();\n+\n+                f.write_str(\"\\n\\nStack backtrace:\\n\")?;\n+                f.write_str(backtrace.trim_end())?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> From<E> for Report<E>\n+where\n+    E: Error,\n+{\n+    fn from(error: E) -> Self {\n+        Report { error, show_backtrace: false, pretty: false }\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<'a, E> From<E> for Report<Box<dyn Error + 'a>>\n+where\n+    E: Error + 'a,\n+{\n+    fn from(error: E) -> Self {\n+        let error = box error;\n+        Report { error, show_backtrace: false, pretty: false }\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> fmt::Display for Report<E>\n+where\n+    E: Error,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.pretty { self.fmt_multiline(f) } else { self.fmt_singleline(f) }\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl fmt::Display for Report<Box<dyn Error>> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.pretty { self.fmt_multiline(f) } else { self.fmt_singleline(f) }\n+    }\n+}\n+\n+// This type intentionally outputs the same format for `Display` and `Debug`for\n+// situations where you unwrap a `Report` or return it from main.\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> fmt::Debug for Report<E>\n+where\n+    Report<E>: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+/// Wrapper type for indenting the inner source.\n+struct Indented<'a, D> {\n+    inner: &'a mut D,\n+}\n+\n+impl<T> Write for Indented<'_, T>\n+where\n+    T: Write,\n+{\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for (i, line) in s.split('\\n').enumerate() {\n+            if i > 0 {\n+                self.inner.write_char('\\n')?;\n+                self.inner.write_str(\"      \")?;\n+            }\n+\n+            self.inner.write_str(line)?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "eae5f43ff3cfb060b424b6a59aa0d8e40e35b2ad", "filename": "library/std/src/error/tests.rs", "status": "modified", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -35,3 +35,408 @@ fn downcasting() {\n         Err(e) => assert_eq!(*e.downcast::<A>().unwrap(), A),\n     }\n }\n+\n+use crate::backtrace::Backtrace;\n+use crate::error::Report;\n+\n+#[derive(Debug)]\n+struct SuperError {\n+    source: SuperErrorSideKick,\n+}\n+\n+impl fmt::Display for SuperError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"SuperError is here!\")\n+    }\n+}\n+\n+impl Error for SuperError {\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        Some(&self.source)\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct SuperErrorSideKick;\n+\n+impl fmt::Display for SuperErrorSideKick {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"SuperErrorSideKick is here!\")\n+    }\n+}\n+\n+impl Error for SuperErrorSideKick {}\n+\n+#[test]\n+fn single_line_formatting() {\n+    let error = SuperError { source: SuperErrorSideKick };\n+    let report = Report::new(&error);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperError is here!: SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn multi_line_formatting() {\n+    let error = SuperError { source: SuperErrorSideKick };\n+    let report = Report::new(&error).pretty(true);\n+    let actual = report.to_string();\n+    let expected = String::from(\n+        \"\\\n+SuperError is here!\n+\n+Caused by:\n+      SuperErrorSideKick is here!\",\n+    );\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_no_sources_formats_single_line_correctly() {\n+    let report = Report::new(SuperErrorSideKick);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_no_sources_formats_multi_line_correctly() {\n+    let report = Report::new(SuperErrorSideKick).pretty(true);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_backtrace_outputs_correctly_with_one_source() {\n+    let trace = Backtrace::force_capture();\n+    let expected = format!(\n+        \"\\\n+The source of the error\n+\n+Caused by:\n+      Error with backtrace\n+\n+Stack backtrace:\n+{}\",\n+        trace\n+    );\n+    let error = GenericError::new(\"Error with backtrace\");\n+    let mut error = GenericError::new_with_source(\"The source of the error\", error);\n+    error.backtrace = Some(trace);\n+    let report = Report::new(error).pretty(true).show_backtrace(true);\n+\n+    println!(\"Error: {}\", report);\n+    assert_eq!(expected.trim_end(), report.to_string());\n+}\n+\n+#[test]\n+fn error_with_backtrace_outputs_correctly_with_two_sources() {\n+    let trace = Backtrace::force_capture();\n+    let expected = format!(\n+        \"\\\n+Error with two sources\n+\n+Caused by:\n+   0: The source of the error\n+   1: Error with backtrace\n+\n+Stack backtrace:\n+{}\",\n+        trace\n+    );\n+    let mut error = GenericError::new(\"Error with backtrace\");\n+    error.backtrace = Some(trace);\n+    let error = GenericError::new_with_source(\"The source of the error\", error);\n+    let error = GenericError::new_with_source(\"Error with two sources\", error);\n+    let report = Report::new(error).pretty(true).show_backtrace(true);\n+\n+    println!(\"Error: {}\", report);\n+    assert_eq!(expected.trim_end(), report.to_string());\n+}\n+\n+#[derive(Debug)]\n+struct GenericError<D> {\n+    message: D,\n+    backtrace: Option<Backtrace>,\n+    source: Option<Box<dyn Error + 'static>>,\n+}\n+\n+impl<D> GenericError<D> {\n+    fn new(message: D) -> GenericError<D> {\n+        Self { message, backtrace: None, source: None }\n+    }\n+\n+    fn new_with_source<E>(message: D, source: E) -> GenericError<D>\n+    where\n+        E: Error + 'static,\n+    {\n+        let source: Box<dyn Error + 'static> = Box::new(source);\n+        let source = Some(source);\n+        GenericError { message, backtrace: None, source }\n+    }\n+}\n+\n+impl<D> fmt::Display for GenericError<D>\n+where\n+    D: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.message, f)\n+    }\n+}\n+\n+impl<D> Error for GenericError<D>\n+where\n+    D: fmt::Debug + fmt::Display,\n+{\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        self.source.as_deref()\n+    }\n+\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        self.backtrace.as_ref()\n+    }\n+}\n+\n+#[test]\n+fn error_formats_single_line_with_rude_display_impl() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\nline 2\")?;\n+            f.write_str(\"\\nline 3\\nline 4\\n\")?;\n+            f.write_str(\"line 5\\nline 6\")?;\n+            Ok(())\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error);\n+    let expected = \"\\\n+line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6\";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_formats_multi_line_with_rude_display_impl() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\nline 2\")?;\n+            f.write_str(\"\\nline 3\\nline 4\\n\")?;\n+            f.write_str(\"line 5\\nline 6\")?;\n+            Ok(())\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6\n+\n+Caused by:\n+   0: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\n+   1: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\n+   2: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn errors_that_start_with_newline_formats_correctly() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"\\nThe message\\n\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\n+The message\n+\n+\n+Caused by:\n+   0: \\\n+\\n      The message\n+      \\\n+\\n   1: \\\n+\\n      The message\n+      \";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn errors_with_multiple_writes_on_same_line_dont_insert_erroneous_newlines() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"The message\")?;\n+            f.write_str(\" goes on\")?;\n+            f.write_str(\" and on.\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\\\n+The message goes on and on.\n+\n+Caused by:\n+   0: The message goes on and on.\n+   1: The message goes on and on.\";\n+\n+    let actual = report.to_string();\n+    println!(\"{}\", actual);\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn errors_with_string_interpolation_formats_correctly() {\n+    #[derive(Debug)]\n+    struct MyMessage(usize);\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"Got an error code: ({}). \", self.0)?;\n+            write!(f, \"What would you like to do in response?\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage(10));\n+    let error = GenericError::new_with_source(MyMessage(20), error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\\\n+Got an error code: (20). What would you like to do in response?\n+\n+Caused by:\n+      Got an error code: (10). What would you like to do in response?\";\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn empty_lines_mid_message() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\n\\nline 2\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\\\n+line 1\n+\n+line 2\n+\n+Caused by:\n+   0: line 1\n+      \\\n+\\n      line 2\n+   1: line 1\n+      \\\n+\\n      line 2\";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn only_one_source() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\nline 2\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\\\n+line 1\n+line 2\n+\n+Caused by:\n+      line 1\n+      line 2\";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}"}, {"sha": "b14430d10e9fc9d4434d6347916f6e02480a559e", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -17,6 +17,8 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::source_map::FilePathMapping;\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::fmt::Write as _;\n use std::mem;\n@@ -486,20 +488,67 @@ crate const DOC_RUST_LANG_ORG_CHANNEL: &str = env!(\"DOC_RUST_LANG_ORG_CHANNEL\");\n /// Render a sequence of macro arms in a format suitable for displaying to the user\n /// as part of an item declaration.\n pub(super) fn render_macro_arms<'a>(\n+    tcx: TyCtxt<'_>,\n     matchers: impl Iterator<Item = &'a TokenTree>,\n     arm_delim: &str,\n ) -> String {\n     let mut out = String::new();\n     for matcher in matchers {\n-        writeln!(out, \"    {} => {{ ... }}{}\", render_macro_matcher(matcher), arm_delim).unwrap();\n+        writeln!(out, \"    {} => {{ ... }}{}\", render_macro_matcher(tcx, matcher), arm_delim)\n+            .unwrap();\n     }\n     out\n }\n \n /// Render a macro matcher in a format suitable for displaying to the user\n /// as part of an item declaration.\n-pub(super) fn render_macro_matcher(matcher: &TokenTree) -> String {\n-    rustc_ast_pretty::pprust::tt_to_string(matcher)\n+pub(super) fn render_macro_matcher(tcx: TyCtxt<'_>, matcher: &TokenTree) -> String {\n+    if let Some(snippet) = snippet_equal_to_token(tcx, matcher) {\n+        snippet\n+    } else {\n+        rustc_ast_pretty::pprust::tt_to_string(matcher)\n+    }\n+}\n+\n+/// Find the source snippet for this token's Span, reparse it, and return the\n+/// snippet if the reparsed TokenTree matches the argument TokenTree.\n+fn snippet_equal_to_token(tcx: TyCtxt<'_>, matcher: &TokenTree) -> Option<String> {\n+    // Find what rustc thinks is the source snippet.\n+    // This may not actually be anything meaningful if this matcher was itself\n+    // generated by a macro.\n+    let source_map = tcx.sess.source_map();\n+    let span = matcher.span();\n+    let snippet = source_map.span_to_snippet(span).ok()?;\n+\n+    // Create a Parser.\n+    let sess = ParseSess::new(FilePathMapping::empty());\n+    let file_name = source_map.span_to_filename(span);\n+    let mut parser =\n+        match rustc_parse::maybe_new_parser_from_source_str(&sess, file_name, snippet.clone()) {\n+            Ok(parser) => parser,\n+            Err(diagnostics) => {\n+                for mut diagnostic in diagnostics {\n+                    diagnostic.cancel();\n+                }\n+                return None;\n+            }\n+        };\n+\n+    // Reparse a single token tree.\n+    let mut reparsed_trees = match parser.parse_all_token_trees() {\n+        Ok(reparsed_trees) => reparsed_trees,\n+        Err(mut diagnostic) => {\n+            diagnostic.cancel();\n+            return None;\n+        }\n+    };\n+    if reparsed_trees.len() != 1 {\n+        return None;\n+    }\n+    let reparsed_tree = reparsed_trees.pop().unwrap();\n+\n+    // Compare against the original tree.\n+    if reparsed_tree.eq_unspanned(matcher) { Some(snippet) } else { None }\n }\n \n pub(super) fn display_macro_source(\n@@ -514,21 +563,21 @@ pub(super) fn display_macro_source(\n     let matchers = tts.chunks(4).map(|arm| &arm[0]);\n \n     if def.macro_rules {\n-        format!(\"macro_rules! {} {{\\n{}}}\", name, render_macro_arms(matchers, \";\"))\n+        format!(\"macro_rules! {} {{\\n{}}}\", name, render_macro_arms(cx.tcx, matchers, \";\"))\n     } else {\n         if matchers.len() <= 1 {\n             format!(\n                 \"{}macro {}{} {{\\n    ...\\n}}\",\n                 vis.to_src_with_space(cx.tcx, def_id),\n                 name,\n-                matchers.map(render_macro_matcher).collect::<String>(),\n+                matchers.map(|matcher| render_macro_matcher(cx.tcx, matcher)).collect::<String>(),\n             )\n         } else {\n             format!(\n                 \"{}macro {} {{\\n{}}}\",\n                 vis.to_src_with_space(cx.tcx, def_id),\n                 name,\n-                render_macro_arms(matchers, \",\"),\n+                render_macro_arms(cx.tcx, matchers, \",\"),\n             )\n         }\n     }"}, {"sha": "5431bd8565b5787fc277eb9ff37527652bf0a642", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -1126,18 +1126,27 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             w.write_str(\"</h3>\");\n \n             use crate::clean::Variant;\n-            if let Some((extra, fields)) = match *variant.kind {\n-                clean::VariantItem(Variant::Struct(ref s)) => Some((\"\", &s.fields)),\n-                clean::VariantItem(Variant::Tuple(ref fields)) => Some((\"Tuple \", fields)),\n+\n+            let heading_and_fields = match &*variant.kind {\n+                clean::VariantItem(Variant::Struct(s)) => Some((\"Fields\", &s.fields)),\n+                // Documentation on tuple variant fields is rare, so to reduce noise we only emit\n+                // the section if at least one field is documented.\n+                clean::VariantItem(Variant::Tuple(fields))\n+                    if fields.iter().any(|f| f.doc_value().is_some()) =>\n+                {\n+                    Some((\"Tuple Fields\", fields))\n+                }\n                 _ => None,\n-            } {\n+            };\n+\n+            if let Some((heading, fields)) = heading_and_fields {\n                 let variant_id = cx.derive_id(format!(\n                     \"{}.{}.fields\",\n                     ItemType::Variant,\n                     variant.name.as_ref().unwrap()\n                 ));\n                 write!(w, \"<div class=\\\"sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n-                write!(w, \"<h4>{extra}Fields</h4>\", extra = extra,);\n+                write!(w, \"<h4>{heading}</h4>\", heading = heading);\n                 document_non_exhaustive(w, variant);\n                 for field in fields {\n                     match *field.kind {"}, {"sha": "094d6b3ebf5f8f6a41c32b343ebba175c85afcf2", "filename": "src/test/run-make-fulldeps/coverage-reports/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -64,7 +64,7 @@ endif\n # if and when we allow `llvm-cov` to produce results for multiple files. Note, the path separators\n # appear to be normalized to `/` in those files, thankfully.)\n LLVM_COV_IGNORE_FILES=\\\n-\t--ignore-filename-regex='(uses_crate.rs|uses_inline_crate.rs)'\n+\t--ignore-filename-regex='(uses_crate.rs|uses_inline_crate.rs|unused_mod.rs)'\n \n all: $(patsubst $(SOURCEDIR)/lib/%.rs,%,$(wildcard $(SOURCEDIR)/lib/*.rs)) $(patsubst $(SOURCEDIR)/%.rs,%,$(wildcard $(SOURCEDIR)/*.rs))\n "}, {"sha": "82d6fccc2714a53c3e8775c7ba7f45d7f2e76eb5", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.unused_mod.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -0,0 +1,4 @@\n+    1|      0|pub fn never_called_function() {\n+    2|      0|    println!(\"I am never called\");\n+    3|      0|}\n+"}, {"sha": "ae1cc1531ed759ec3c41d264a9f81b54f13b30a2", "filename": "src/test/run-make-fulldeps/coverage/lib/unused_mod_helper.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Flib%2Funused_mod_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Flib%2Funused_mod_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Flib%2Funused_mod_helper.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -0,0 +1,3 @@\n+pub fn never_called_function() {\n+    println!(\"I am never called\");\n+}"}, {"sha": "679b4e5318803a30d3fd5ad2af28bb8bb5dd2b49", "filename": "src/test/run-make-fulldeps/coverage/unused_mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Funused_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Funused_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Funused_mod.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -0,0 +1,6 @@\n+#[path = \"lib/unused_mod_helper.rs\"]\n+mod unused_module;\n+\n+fn main() {\n+    println!(\"hello world!\");\n+}"}, {"sha": "94ade31b5e5f4ce4f12bc5c5a830dc0d7cd400da", "filename": "src/test/rustdoc/decl_macro.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Fdecl_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Fdecl_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdecl_macro.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -9,7 +9,7 @@ pub macro my_macro() {\n \n }\n \n-// @has decl_macro/macro.my_macro_2.html //pre 'pub macro my_macro_2($($tok : tt) *) {'\n+// @has decl_macro/macro.my_macro_2.html //pre 'pub macro my_macro_2($($tok:tt)*) {'\n // @has - //pre '...'\n // @has - //pre '}'\n pub macro my_macro_2($($tok:tt)*) {\n@@ -18,8 +18,8 @@ pub macro my_macro_2($($tok:tt)*) {\n \n // @has decl_macro/macro.my_macro_multi.html //pre 'pub macro my_macro_multi {'\n // @has - //pre '(_) => { ... },'\n-// @has - //pre '($foo : ident.$bar : expr) => { ... },'\n-// @has - //pre '($($foo : literal), +) => { ... },'\n+// @has - //pre '($foo:ident . $bar:expr) => { ... },'\n+// @has - //pre '($($foo:literal),+) => { ... },'\n // @has - //pre '}'\n pub macro my_macro_multi {\n     (_) => {\n@@ -33,7 +33,7 @@ pub macro my_macro_multi {\n     }\n }\n \n-// @has decl_macro/macro.by_example_single.html //pre 'pub macro by_example_single($foo : expr) {'\n+// @has decl_macro/macro.by_example_single.html //pre 'pub macro by_example_single($foo:expr) {'\n // @has - //pre '...'\n // @has - //pre '}'\n pub macro by_example_single {\n@@ -42,12 +42,12 @@ pub macro by_example_single {\n \n mod a {\n     mod b {\n-        // @has decl_macro/a/b/macro.by_example_vis.html //pre 'pub(super) macro by_example_vis($foo : expr) {'\n+        // @has decl_macro/a/b/macro.by_example_vis.html //pre 'pub(super) macro by_example_vis($foo:expr) {'\n         pub(in super) macro by_example_vis {\n             ($foo:expr) => {}\n         }\n         mod c {\n-            // @has decl_macro/a/b/c/macro.by_example_vis_named.html //pre 'pub(in a) macro by_example_vis_named($foo : expr) {'\n+            // @has decl_macro/a/b/c/macro.by_example_vis_named.html //pre 'pub(in a) macro by_example_vis_named($foo:expr) {'\n             pub(in a) macro by_example_vis_named {\n                 ($foo:expr) => {}\n             }"}, {"sha": "fc63ed343bda27cefb52a6258acb6b23c557af8e", "filename": "src/test/rustdoc/issue-88600.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Fissue-88600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Fissue-88600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-88600.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -18,17 +18,18 @@ pub enum FooEnum {\n     // @has - '//*[@id=\"variant.MixedHiddenFirst\"]//code' 'MixedHiddenFirst(_, S)'\n     // @count - '//*[@id=\"variant.MixedHiddenFirst.field.0\"]' 0\n     // @has - '//*[@id=\"variant.MixedHiddenFirst.field.1\"]' '1: S'\n-    MixedHiddenFirst(#[doc(hidden)] H, S),\n+    MixedHiddenFirst(#[doc(hidden)] H, /** dox */ S),\n     // @has - '//*[@id=\"variant.MixedHiddenLast\"]//code' 'MixedHiddenLast(S, _)'\n     // @has - '//*[@id=\"variant.MixedHiddenLast.field.0\"]' '0: S'\n     // @count - '//*[@id=\"variant.MixedHiddenLast.field.1\"]' 0\n-    MixedHiddenLast(S, #[doc(hidden)] H),\n+    MixedHiddenLast(/** dox */ S, #[doc(hidden)] H),\n     // @has - '//*[@id=\"variant.HiddenStruct\"]//code' 'HiddenStruct'\n     // @count - '//*[@id=\"variant.HiddenStruct.field.h\"]' 0\n     // @has - '//*[@id=\"variant.HiddenStruct.field.s\"]' 's: S'\n     HiddenStruct {\n         #[doc(hidden)]\n         h: H,\n+        /// dox\n         s: S,\n     },\n }"}, {"sha": "25d8bc3ec62817243fcb29657566ea1b89b2a0d1", "filename": "src/test/rustdoc/macro-generated-macro.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -0,0 +1,14 @@\n+macro_rules! outer {\n+    ($($matcher:tt)*) => {\n+        #[macro_export]\n+        macro_rules! inner {\n+            (<= $($matcher)* =>) => {};\n+        }\n+    }\n+}\n+\n+// @has macro_generated_macro/macro.inner.html //pre 'macro_rules! inner {'\n+// @has - //pre '(<= type $($i : ident) :: * + $e : expr =>) => { ... };'\n+outer!(type $($i:ident)::* + $e:expr);\n+\n+inner!(<= type foo::bar + x.sort() =>);"}, {"sha": "ae0cf7a14789d78103c6cb4585ea36ab650153f7", "filename": "src/test/rustdoc/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacros.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -1,7 +1,7 @@\n // @has macros/macro.my_macro.html //pre 'macro_rules! my_macro {'\n // @has - //pre '() => { ... };'\n-// @has - //pre '($a : tt) => { ... };'\n-// @has - //pre '($e : expr) => { ... };'\n+// @has - //pre '($a:tt) => { ... };'\n+// @has - //pre '($e:expr) => { ... };'\n #[macro_export]\n macro_rules! my_macro {\n     () => [];\n@@ -12,8 +12,8 @@ macro_rules! my_macro {\n // Check that exported macro defined in a module are shown at crate root.\n // @has macros/macro.my_sub_macro.html //pre 'macro_rules! my_sub_macro {'\n // @has - //pre '() => { ... };'\n-// @has - //pre '($a : tt) => { ... };'\n-// @has - //pre '($e : expr) => { ... };'\n+// @has - //pre '($a:tt) => { ... };'\n+// @has - //pre '($e:expr) => { ... };'\n mod sub {\n     #[macro_export]\n     macro_rules! my_sub_macro {"}, {"sha": "aea9b9f2b395dc1b85b63f0c891026607df629db", "filename": "src/test/rustdoc/reexports-priv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Freexports-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Freexports-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Freexports-priv.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -5,7 +5,7 @@\n \n extern crate reexports;\n \n-// @has 'foo/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place : expr) {'\n+// @has 'foo/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place:expr) {'\n pub use reexports::addr_of;\n // @!has 'foo/macro.addr_of_crate.html'\n pub(crate) use reexports::addr_of_crate;\n@@ -61,11 +61,11 @@ use reexports::UnionLocal;\n \n pub mod outer {\n     pub mod inner {\n-        // @has 'foo/outer/inner/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place : expr) {'\n+        // @has 'foo/outer/inner/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place:expr) {'\n         pub use reexports::addr_of;\n-        // @has 'foo/outer/inner/macro.addr_of_crate.html' '//*[@class=\"docblock item-decl\"]' 'pub(crate) macro addr_of_crate($place : expr) {'\n+        // @has 'foo/outer/inner/macro.addr_of_crate.html' '//*[@class=\"docblock item-decl\"]' 'pub(crate) macro addr_of_crate($place:expr) {'\n         pub(crate) use reexports::addr_of_crate;\n-        // @has 'foo/outer/inner/macro.addr_of_super.html' '//*[@class=\"docblock item-decl\"]' 'pub(in outer) macro addr_of_super($place : expr) {'\n+        // @has 'foo/outer/inner/macro.addr_of_super.html' '//*[@class=\"docblock item-decl\"]' 'pub(in outer) macro addr_of_super($place:expr) {'\n         pub(super) use reexports::addr_of_super;\n         // @!has 'foo/outer/inner/macro.addr_of_self.html'\n         pub(self) use reexports::addr_of_self;"}, {"sha": "7abcbfb618122194125511eab7812079367b65e8", "filename": "src/test/rustdoc/reexports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Freexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Freexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Freexports.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -4,7 +4,7 @@\n \n extern crate reexports;\n \n-// @has 'foo/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place : expr) {'\n+// @has 'foo/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place:expr) {'\n pub use reexports::addr_of;\n // @!has 'foo/macro.addr_of_crate.html'\n pub(crate) use reexports::addr_of_crate;\n@@ -60,7 +60,7 @@ use reexports::UnionLocal;\n \n pub mod outer {\n     pub mod inner {\n-        // @has 'foo/outer/inner/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place : expr) {'\n+        // @has 'foo/outer/inner/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place:expr) {'\n         pub use reexports::addr_of;\n         // @!has 'foo/outer/inner/macro.addr_of_crate.html'\n         pub(crate) use reexports::addr_of_crate;"}, {"sha": "31426131bc2c1897312145ebd8d418413138468a", "filename": "src/test/rustdoc/tuple-struct-fields-doc.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Ftuple-struct-fields-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Frustdoc%2Ftuple-struct-fields-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftuple-struct-fields-doc.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -24,6 +24,9 @@ pub struct Foo(\n // @has - '//*[@id=\"variant.BarVariant.field.0\"]' '0: String'\n // @has - '//*[@id=\"variant.BarVariant.fields\"]//*[@class=\"docblock\"]' 'Hello docs'\n // @matches - '//*[@id=\"variant.FooVariant.fields\"]/h4' '^Fields$'\n+// @has - '//*[@id=\"variant.BazVariant.fields\"]//*[@class=\"docblock\"]' 'dox'\n+// @has - '//*[@id=\"variant.OtherVariant.fields\"]//*[@class=\"docblock\"]' 'dox'\n+// @!matches - '//*[@id=\"variant.QuuxVariant.fields\"]/h4' '^Tuple Fields$'\n pub enum Bar {\n     BarVariant(\n         /// Hello docs\n@@ -33,4 +36,15 @@ pub enum Bar {\n        /// hello\n        x: u32,\n     },\n+    BazVariant(\n+        String,\n+        /// dox\n+        u32,\n+    ),\n+    OtherVariant(\n+        /// dox\n+        String,\n+        u32,\n+    ),\n+    QuuxVariant(String),\n }"}, {"sha": "cee8186dd8f8c432c3a2ccf10f49ae3822e120f5", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -15,9 +15,5 @@ impl<W> Trait<W> for () {}\n \n fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n     //~^ ERROR non-defining opaque type use in defining scope\n-    //~| ERROR non-defining opaque type use in defining scope\n-    //~| ERROR non-defining opaque type use in defining scope\n-    //~| ERROR `T` is part of concrete type but not used in parameter list\n-    //~| ERROR `T` is part of concrete type but not used in parameter list\n     ()\n }"}, {"sha": "03e696fe8980376392a3df6e8219d9ae3dbd03fc", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 3, "deletions": 53, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -1,70 +1,20 @@\n-error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/bound_reduction2.rs:16:60\n-   |\n-LL |   fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   |  ____________________________________________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     ()\n-LL | | }\n-   | |_^\n-\n-error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/bound_reduction2.rs:16:60\n-   |\n-LL |   fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   |  ____________________________________________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     ()\n-LL | | }\n-   | |_^\n-\n error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:1\n+  --> $DIR/bound_reduction2.rs:16:46\n    |\n LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                              ^^^^^^^^^^^^^\n    |\n note: used non-generic type `<T as TraitWithAssoc>::Assoc` for generic parameter\n   --> $DIR/bound_reduction2.rs:9:10\n    |\n LL | type Foo<V> = impl Trait<V>;\n    |          ^\n \n-error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:1\n-   |\n-LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: used non-generic type `_` for generic parameter\n-  --> $DIR/bound_reduction2.rs:9:10\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   |          ^\n-\n-error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:1\n-   |\n-LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: used non-generic type `_` for generic parameter\n-  --> $DIR/bound_reduction2.rs:9:10\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   |          ^\n-\n error: could not find defining uses\n   --> $DIR/bound_reduction2.rs:9:15\n    |\n LL | type Foo<V> = impl Trait<V>;\n    |               ^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "06b9d31743210b788b130c8a484c2838afa6fc27", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -1 +1 @@\n-Subproject commit 358e79fe56fe374649275ca7aebaafd57ade0e8d\n+Subproject commit 06b9d31743210b788b130c8a484c2838afa6fc27"}, {"sha": "9d2aa0f21c8e1a992f6f926fe90ba0bac7597157", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f312a5e610d47601e9a3da828002f5e1ffeb272a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=f312a5e610d47601e9a3da828002f5e1ffeb272a", "patch": "@@ -73,6 +73,7 @@ const RESTRICTED_DEPENDENCY_CRATES: &[&str] = &[\"rustc_driver\", \"rustc_codegen_l\n const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"addr2line\",\n     \"adler\",\n+    \"ahash\",\n     \"aho-corasick\",\n     \"annotate-snippets\",\n     \"ansi_term\","}]}