{"sha": "793eb1d38d6549e26fbf3014604c5c81e4b18c4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5M2ViMWQzOGQ2NTQ5ZTI2ZmJmMzAxNDYwNGM1YzgxZTRiMThjNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-17T11:51:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-17T11:51:40Z"}, "message": "auto merge of #10996 : huonw/rust/more-vec-raw, r=cmr\n\nThe removal of the aliasing &mut[] and &[] from `shift_opt` also comes with its simplification.\r\n\r\nThe above also allows the use of `copy_nonoverlapping_memory` in `[].copy_memory` (I did an audit of each use of `.copy_memory` and `std::vec::bytes::copy_memory`, and I believe none of them are called with arguments can ever alias). This changes requires that `unsafe` code using `copy_memory` **needs** to respect the aliasing rules of `&mut[]`.", "tree": {"sha": "62b9cd5ba709a7a26fe14df65e34fc3a53b5081f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62b9cd5ba709a7a26fe14df65e34fc3a53b5081f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/793eb1d38d6549e26fbf3014604c5c81e4b18c4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/793eb1d38d6549e26fbf3014604c5c81e4b18c4f", "html_url": "https://github.com/rust-lang/rust/commit/793eb1d38d6549e26fbf3014604c5c81e4b18c4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/793eb1d38d6549e26fbf3014604c5c81e4b18c4f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5", "html_url": "https://github.com/rust-lang/rust/commit/dc65762d7923a9e66e8e5d743cb8b2d2fdd3cde5"}, {"sha": "dd355700cf4f1fa1744cdeb165b68898fa30a9d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd355700cf4f1fa1744cdeb165b68898fa30a9d1", "html_url": "https://github.com/rust-lang/rust/commit/dd355700cf4f1fa1744cdeb165b68898fa30a9d1"}], "stats": {"total": 154, "additions": 65, "deletions": 89}, "files": [{"sha": "38a1394d339c4b7d64a7324a289a70cc2d958da8", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793eb1d38d6549e26fbf3014604c5c81e4b18c4f/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793eb1d38d6549e26fbf3014604c5c81e4b18c4f/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=793eb1d38d6549e26fbf3014604c5c81e4b18c4f", "patch": "@@ -219,9 +219,7 @@ impl Uuid {\n         }\n \n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        unsafe {\n-            vec::raw::copy_memory(uuid.bytes, b);\n-        }\n+        vec::bytes::copy_memory(uuid.bytes, b);\n         Some(uuid)\n     }\n "}, {"sha": "25a6429d8518a0303db8d3ca342f3601fe397ebb", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 64, "deletions": 86, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/793eb1d38d6549e26fbf3014604c5c81e4b18c4f/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793eb1d38d6549e26fbf3014604c5c81e4b18c4f/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=793eb1d38d6549e26fbf3014604c5c81e4b18c4f", "patch": "@@ -1625,54 +1625,38 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     fn shift_opt(&mut self) -> Option<T> {\n-        unsafe {\n-            let ln = match self.len() {\n-                0 => return None,\n-                1 => return self.pop_opt(),\n-                2 =>  {\n-                    let last = self.pop();\n-                    let first = self.pop_opt();\n-                    self.push(last);\n-                    return first;\n-                }\n-                x => x\n-            };\n-\n-            let next_ln = self.len() - 1;\n-\n-            // Save the last element. We're going to overwrite its position\n-            let work_elt = self.pop();\n-            // We still should have room to work where what last element was\n-            assert!(self.capacity() >= ln);\n-            // Pretend like we have the original length so we can use\n-            // the vector copy_memory to overwrite the hole we just made\n-            self.set_len(ln);\n-\n-            // Memcopy the head element (the one we want) to the location we just\n-            // popped. For the moment it unsafely exists at both the head and last\n-            // positions\n-            {\n-                let first_slice = self.slice(0, 1);\n-                let last_slice = self.slice(next_ln, ln);\n-                raw::copy_memory(cast::transmute(last_slice), first_slice);\n+        match self.len() {\n+            0 => None,\n+            1 => self.pop_opt(),\n+            2 => {\n+                let last = self.pop();\n+                let first = self.pop_opt();\n+                self.push(last);\n+                first\n             }\n+            len => {\n+                unsafe {\n+                    let next_len = len - 1;\n \n-            // Memcopy everything to the left one element\n-            {\n-                let init_slice = self.slice(0, next_ln);\n-                let tail_slice = self.slice(1, ln);\n-                raw::copy_memory(cast::transmute(init_slice),\n-                                 tail_slice);\n-            }\n+                    let ptr = self.as_ptr();\n+\n+                    // copy out the head element, for the moment it exists\n+                    // unsafely on the stack and as the first element of the\n+                    // vector.\n+                    let head = ptr::read_ptr(ptr);\n \n-            // Set the new length. Now the vector is back to normal\n-            self.set_len(next_ln);\n+                    // Memcpy everything to the left one element (leaving the\n+                    // last element unsafely in two consecutive memory\n+                    // locations)\n+                    ptr::copy_memory(self.as_mut_ptr(), ptr.offset(1), next_len);\n \n-            // Swap out the element we want from the end\n-            let vp = self.as_mut_ptr();\n-            let vp = ptr::mut_offset(vp, (next_ln - 1) as int);\n+                    // set the new length, which means the second instance of\n+                    // the last element is forgotten.\n+                    self.set_len(next_len);\n \n-            Some(ptr::replace_ptr(vp, work_elt))\n+                    Some(head)\n+                }\n+            }\n         }\n     }\n \n@@ -2073,6 +2057,19 @@ pub trait MutableVector<'a, T> {\n     /// Unsafely sets the element in index to the value\n     unsafe fn unsafe_set(self, index: uint, val: T);\n \n+    /**\n+     * Unchecked vector index assignment.  Does not drop the\n+     * old value and hence is only suitable when the vector\n+     * is newly allocated.\n+     */\n+    unsafe fn init_elem(self, i: uint, val: T);\n+\n+    /// Copies data from `src` to `self`.\n+    ///\n+    /// `self` and `src` must not overlap. Fails if `self` is\n+    /// shorter than `src`.\n+    unsafe fn copy_memory(self, src: &[T]);\n+\n     /// Similar to `as_imm_buf` but passing a `*mut T`\n     fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U;\n }\n@@ -2201,6 +2198,21 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         *self.unsafe_mut_ref(index) = val;\n     }\n \n+    #[inline]\n+    unsafe fn init_elem(self, i: uint, val: T) {\n+        intrinsics::move_val_init(&mut (*self.as_mut_ptr().offset(i as int)), val);\n+    }\n+\n+    #[inline]\n+    unsafe fn copy_memory(self, src: &[T]) {\n+        self.as_mut_buf(|p_dst, len_dst| {\n+            src.as_imm_buf(|p_src, len_src| {\n+                assert!(len_dst >= len_src)\n+                ptr::copy_nonoverlapping_memory(p_dst, p_src, len_src)\n+            })\n+        })\n+    }\n+\n     #[inline]\n     fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U {\n         let Slice{ data, len } = self.repr();\n@@ -2241,10 +2253,8 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n /// Unsafe operations\n pub mod raw {\n     use cast;\n-    use option::Some;\n     use ptr;\n-    use unstable::intrinsics;\n-    use vec::{with_capacity, ImmutableVector, MutableVector};\n+    use vec::{with_capacity, MutableVector};\n     use unstable::raw::Slice;\n \n     /**\n@@ -2277,20 +2287,6 @@ pub mod raw {\n         }))\n     }\n \n-    /**\n-     * Unchecked vector index assignment.  Does not drop the\n-     * old value and hence is only suitable when the vector\n-     * is newly allocated.\n-     */\n-    #[inline]\n-    pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n-        let mut alloc = Some(val);\n-        v.as_mut_buf(|p, _len| {\n-            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)),\n-                                      alloc.take_unwrap());\n-        })\n-    }\n-\n     /**\n     * Constructs a vector from an unsafe pointer to a buffer\n     *\n@@ -2308,21 +2304,6 @@ pub mod raw {\n         dst\n     }\n \n-    /**\n-      * Copies data from one vector to another.\n-      *\n-      * Copies `src` to `dst`. The source and destination may overlap.\n-      */\n-    #[inline]\n-    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[T]) {\n-        dst.as_mut_buf(|p_dst, len_dst| {\n-            src.as_imm_buf(|p_src, len_src| {\n-                assert!(len_dst >= len_src)\n-                ptr::copy_memory(p_dst, p_src, len_src)\n-            })\n-        })\n-    }\n-\n     /**\n      * Returns a pointer to first element in slice and adjusts\n      * slice so it no longer contains that element. Fails if\n@@ -2351,7 +2332,7 @@ pub mod raw {\n \n /// Operations on `[u8]`.\n pub mod bytes {\n-    use vec::raw;\n+    use vec::MutableVector;\n     use ptr;\n \n     /// A trait for operations on mutable `[u8]`s.\n@@ -2369,17 +2350,14 @@ pub mod bytes {\n         }\n     }\n \n-    /**\n-      * Copies data from one vector to another.\n-      *\n-      * Copies `src` to `dst`. The source and destination may\n-      * overlap. Fails if the length of `dst` is less than the length\n-      * of `src`.\n-      */\n+    /// Copies data from `src` to `dst`\n+    ///\n+    /// `src` and `dst` must not overlap. Fails if the length of `dst`\n+    /// is less than the length of `src`.\n     #[inline]\n     pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n-        // Bound checks are done at vec::raw::copy_memory.\n-        unsafe { raw::copy_memory(dst, src) }\n+        // Bound checks are done at .copy_memory.\n+        unsafe { dst.copy_memory(src) }\n     }\n \n     /**\n@@ -3601,7 +3579,7 @@ mod tests {\n         unsafe {\n             let mut a = [1, 2, 3, 4];\n             let b = [1, 2, 3, 4, 5];\n-            raw::copy_memory(a, b);\n+            a.copy_memory(b);\n         }\n     }\n "}]}