{"sha": "2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNDFhODVkOGUxZjU3N2YxN2U1YjE3YTFkNjQ4NTA4ZTFhYzUwMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-14T15:36:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-14T15:36:56Z"}, "message": "auto merge of #13431 : lifthrasiir/rust/rustdoc-smaller-index, r=alexcrichton\n\nThis is a series of inter-related commits which depend on #13402 (Prune the paths that do not appear in the index). Please consider this as an early review request; I'll rebase this when the parent PR get merged and rebase is required.\r\n\r\n----\r\n\r\nThis PR aims at reducing the search index without removing the actual information. In my measurement with both library and compiler docs, the search index is 52% smaller before gzipped, and 16% smaller after gzipped:\r\n\r\n```\r\n 1719473 search-index-old.js\r\n 1503299 search-index.js (after #13402, 13% gain)\r\n  724955 search-index-new.js (after this PR, 52% gain w.r.t. #13402)\r\n\r\n  262711 search-index-old.js.gz\r\n  214205 search-index.js.gz (after #13402, 18.5% gain)\r\n  179396 search-index-new.js.gz (after this PR, 16% gain w.r.t. #13402)\r\n```\r\n\r\nBoth the uncompressed and compressed size of the search index have been accounted. While the former would be less relevant when #12597 (Web site should be transferring data compressed) is resolved, the uncompressed index will be around for a while anyway and directly affects the UX of docs. Moreover, LZ77 (and gzip) can only remove *some* repeated strings (since its search window is limited in size), so optimizing for the uncompressed size often has a positive effect on the compressed size as well.\r\n\r\nEach commit represents the following incremental improvements, in the order:\r\n\r\n1. Parent paths were referred by its AST `NodeId`, which tends to be large. We don't need the actual node ID, so we remap them to the smaller sequential numbers. This also means that the list of paths can be a flat array instead of an object.\r\n2. We remap each item type to small predefined numbers. This is strictly intended to reduce the uncompressed size of the search index.\r\n3. We use arrays instead of objects and reconstruct the original objects in the JavaScript code. Since this removes a lot of boilerplates, this affects both the uncompressed and compressed size.\r\n4. (I've found that a centralized `searchIndex` is easier to handle in JS, so I shot one global variable down.)\r\n5. Finally, the repeated paths in the consecutive items are omitted (replaced by an empty string). This also greatly affects both the uncompressed and compressed size.\r\n\r\nThere had been several unsuccessful attempts to reduce the search index. Especially, I explicitly avoided complex optimizations like encoding paths in a compressed form, and only applied the optimizations when it had a substantial gain compared to the changes. Also, while I've tried to be careful, the lack of proper (non-smoke) tests makes me a bit worry; any advice on testing the search indices would be appreciated.", "tree": {"sha": "7c1973345899b24b79e842aefef53b23e0ff28c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c1973345899b24b79e842aefef53b23e0ff28c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "html_url": "https://github.com/rust-lang/rust/commit/2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2e754810c78a25c902b76c74ba8f04d0dcdc6f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e754810c78a25c902b76c74ba8f04d0dcdc6f1", "html_url": "https://github.com/rust-lang/rust/commit/e2e754810c78a25c902b76c74ba8f04d0dcdc6f1"}, {"sha": "8f5d71cf71849bea25f87836cec1b06b476baf37", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5d71cf71849bea25f87836cec1b06b476baf37", "html_url": "https://github.com/rust-lang/rust/commit/8f5d71cf71849bea25f87836cec1b06b476baf37"}], "stats": {"total": 305, "additions": 229, "deletions": 76}, "files": [{"sha": "ca55d1f04ad2f16715d49ff9e8c04efcbf262d55", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -24,6 +24,8 @@ use syntax::ast;\n use syntax::ast_util;\n \n use clean;\n+use html::item_type;\n+use html::item_type::ItemType;\n use html::render;\n use html::render::{cache_key, current_location_key};\n \n@@ -172,17 +174,17 @@ fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n         },\n         |_cache| {\n             Some((Vec::from_slice(fqn), match kind {\n-                clean::TypeStruct => \"struct\",\n-                clean::TypeEnum => \"enum\",\n-                clean::TypeFunction => \"fn\",\n-                clean::TypeTrait => \"trait\",\n+                clean::TypeStruct => item_type::Struct,\n+                clean::TypeEnum => item_type::Enum,\n+                clean::TypeFunction => item_type::Function,\n+                clean::TypeTrait => item_type::Trait,\n             }))\n         })\n }\n \n fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         root: |&render::Cache, &[~str]| -> Option<~str>,\n-        info: |&render::Cache| -> Option<(Vec<~str> , &'static str)>)\n+        info: |&render::Cache| -> Option<(Vec<~str> , ItemType)>)\n     -> fmt::Result\n {\n     // The generics will get written to both the title and link\n@@ -252,12 +254,12 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                         url.push_str(\"/\");\n                     }\n                     match shortty {\n-                        \"mod\" => {\n+                        item_type::Module => {\n                             url.push_str(*fqp.last().unwrap());\n                             url.push_str(\"/index.html\");\n                         }\n                         _ => {\n-                            url.push_str(shortty);\n+                            url.push_str(shortty.to_static_str());\n                             url.push_str(\".\");\n                             url.push_str(*fqp.last().unwrap());\n                             url.push_str(\".html\");"}, {"sha": "f59e8cb248738edb49e82e82bef397dadc89e50d", "filename": "src/librustdoc/html/item_type.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Item types.\n+\n+use std::fmt;\n+use clean;\n+\n+/// Item type. Corresponds to `clean::ItemEnum` variants.\n+///\n+/// The search index uses item types encoded as smaller numbers which equal to\n+/// discriminants. JavaScript then is used to decode them into the original value.\n+/// Consequently, every change to this type should be synchronized to\n+/// the `itemTypes` mapping table in `static/main.js`.\n+#[deriving(Eq, Clone)]\n+pub enum ItemType {\n+    Module          = 0,\n+    Struct          = 1,\n+    Enum            = 2,\n+    Function        = 3,\n+    Typedef         = 4,\n+    Static          = 5,\n+    Trait           = 6,\n+    Impl            = 7,\n+    ViewItem        = 8,\n+    TyMethod        = 9,\n+    Method          = 10,\n+    StructField     = 11,\n+    Variant         = 12,\n+    ForeignFunction = 13,\n+    ForeignStatic   = 14,\n+    Macro           = 15,\n+}\n+\n+impl ItemType {\n+    pub fn to_static_str(&self) -> &'static str {\n+        match *self {\n+            Module          => \"mod\",\n+            Struct          => \"struct\",\n+            Enum            => \"enum\",\n+            Function        => \"fn\",\n+            Typedef         => \"typedef\",\n+            Static          => \"static\",\n+            Trait           => \"trait\",\n+            Impl            => \"impl\",\n+            ViewItem        => \"viewitem\",\n+            TyMethod        => \"tymethod\",\n+            Method          => \"method\",\n+            StructField     => \"structfield\",\n+            Variant         => \"variant\",\n+            ForeignFunction => \"ffi\",\n+            ForeignStatic   => \"ffs\",\n+            Macro           => \"macro\",\n+        }\n+    }\n+}\n+\n+impl fmt::Show for ItemType {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.to_static_str().fmt(f)\n+    }\n+}\n+\n+impl fmt::Unsigned for ItemType {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (*self as uint).fmt(f)\n+    }\n+}\n+\n+pub fn shortty(item: &clean::Item) -> ItemType {\n+    match item.inner {\n+        clean::ModuleItem(..)          => Module,\n+        clean::StructItem(..)          => Struct,\n+        clean::EnumItem(..)            => Enum,\n+        clean::FunctionItem(..)        => Function,\n+        clean::TypedefItem(..)         => Typedef,\n+        clean::StaticItem(..)          => Static,\n+        clean::TraitItem(..)           => Trait,\n+        clean::ImplItem(..)            => Impl,\n+        clean::ViewItemItem(..)        => ViewItem,\n+        clean::TyMethodItem(..)        => TyMethod,\n+        clean::MethodItem(..)          => Method,\n+        clean::StructFieldItem(..)     => StructField,\n+        clean::VariantItem(..)         => Variant,\n+        clean::ForeignFunctionItem(..) => ForeignFunction,\n+        clean::ForeignStaticItem(..)   => ForeignStatic,\n+        clean::MacroItem(..)           => Macro,\n+    }\n+}\n+"}, {"sha": "669a489a4fb6e6ce2d0a34802af121fd1297f966", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 58, "deletions": 53, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "patch": "@@ -52,6 +52,8 @@ use rustc::util::nodemap::NodeSet;\n use clean;\n use doctree;\n use fold::DocFolder;\n+use html::item_type;\n+use html::item_type::{ItemType, shortty};\n use html::format::{VisSpace, Method, FnStyleSpace};\n use html::layout;\n use html::markdown;\n@@ -138,7 +140,7 @@ pub struct Cache {\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: HashMap<ast::NodeId, (Vec<~str> , &'static str)>,\n+    pub paths: HashMap<ast::NodeId, (Vec<~str> , ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -193,7 +195,7 @@ struct Sidebar<'a> { cx: &'a Context, item: &'a clean::Item, }\n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n struct IndexItem {\n-    ty: &'static str,\n+    ty: ItemType,\n     name: ~str,\n     path: ~str,\n     desc: ~str,\n@@ -262,6 +264,9 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     });\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n+\n+    let mut nodeid_to_pathid = HashMap::new();\n+    let mut pathid_to_nodeid = Vec::new();\n     {\n         let Cache { search_index: ref mut index,\n                     orphan_methods: ref meths, paths: ref mut paths, ..} = cache;\n@@ -283,48 +288,67 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             }\n         };\n \n-        // Prune the paths that do not appear in the index.\n-        let mut unseen: HashSet<ast::NodeId> = paths.keys().map(|&id| id).collect();\n+        // Reduce `NodeId` in paths into smaller sequential numbers,\n+        // and prune the paths that do not appear in the index.\n         for item in index.iter() {\n             match item.parent {\n-                Some(ref pid) => { unseen.remove(pid); }\n+                Some(nodeid) => {\n+                    if !nodeid_to_pathid.contains_key(&nodeid) {\n+                        let pathid = pathid_to_nodeid.len();\n+                        nodeid_to_pathid.insert(nodeid, pathid);\n+                        pathid_to_nodeid.push(nodeid);\n+                    }\n+                }\n                 None => {}\n             }\n         }\n-        for pid in unseen.iter() {\n-            paths.remove(pid);\n-        }\n+        assert_eq!(nodeid_to_pathid.len(), pathid_to_nodeid.len());\n     }\n \n     // Publish the search index\n     let index = {\n         let mut w = MemWriter::new();\n-        try!(write!(&mut w, \"searchIndex['{}'] = [\", krate.name));\n+        try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n+\n+        let mut lastpath = ~\"\";\n         for (i, item) in cache.search_index.iter().enumerate() {\n+            // Omit the path if it is same to that of the prior item.\n+            let path;\n+            if lastpath == item.path {\n+                path = \"\";\n+            } else {\n+                lastpath = item.path.clone();\n+                path = item.path.as_slice();\n+            };\n+\n             if i > 0 {\n                 try!(write!(&mut w, \",\"));\n             }\n-            try!(write!(&mut w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n-                        item.ty, item.name, item.path,\n+            try!(write!(&mut w, r#\"[{:u},\"{}\",\"{}\",{}\"#,\n+                        item.ty, item.name, path,\n                         item.desc.to_json().to_str()));\n             match item.parent {\n-                Some(id) => {\n-                    try!(write!(&mut w, \",parent:'{}'\", id));\n+                Some(nodeid) => {\n+                    let pathid = *nodeid_to_pathid.find(&nodeid).unwrap();\n+                    try!(write!(&mut w, \",{}\", pathid));\n                 }\n                 None => {}\n             }\n-            try!(write!(&mut w, \"\\\\}\"));\n+            try!(write!(&mut w, \"]\"));\n         }\n-        try!(write!(&mut w, \"];\"));\n-        try!(write!(&mut w, \"allPaths['{}'] = \\\\{\", krate.name));\n-        for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n+\n+        try!(write!(&mut w, r#\"],\"paths\":[\"#));\n+\n+        for (i, &nodeid) in pathid_to_nodeid.iter().enumerate() {\n+            let &(ref fqp, short) = cache.paths.find(&nodeid).unwrap();\n             if i > 0 {\n                 try!(write!(&mut w, \",\"));\n             }\n-            try!(write!(&mut w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n-                        id, short, *fqp.last().unwrap()));\n+            try!(write!(&mut w, r#\"[{:u},\"{}\"]\"#,\n+                        short, *fqp.last().unwrap()));\n         }\n-        try!(write!(&mut w, \"\\\\};\"));\n+\n+        try!(write!(&mut w, r\"]\\};\"));\n \n         str::from_utf8(w.unwrap().as_slice()).unwrap().to_owned()\n     };\n@@ -360,7 +384,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             }\n         }\n         let mut w = try!(File::create(&dst));\n-        try!(writeln!(&mut w, r\"var searchIndex = \\{\\}; var allPaths = \\{\\};\"));\n+        try!(writeln!(&mut w, r\"var searchIndex = \\{\\};\"));\n         for index in all_indexes.iter() {\n             try!(writeln!(&mut w, \"{}\", *index));\n         }\n@@ -613,12 +637,13 @@ impl DocFolder for Cache {\n                         } else {\n                             let last = self.parent_stack.last().unwrap();\n                             let path = match self.paths.find(last) {\n-                                Some(&(_, \"trait\")) =>\n+                                Some(&(_, item_type::Trait)) =>\n                                     Some(self.stack.slice_to(self.stack.len() - 1)),\n                                 // The current stack not necessarily has correlation for\n                                 // where the type was defined. On the other hand,\n                                 // `paths` always has the right information if present.\n-                                Some(&(ref fqp, \"struct\")) | Some(&(ref fqp, \"enum\")) =>\n+                                Some(&(ref fqp, item_type::Struct)) |\n+                                Some(&(ref fqp, item_type::Enum)) =>\n                                     Some(fqp.slice_to(fqp.len() - 1)),\n                                 Some(..) => Some(self.stack.as_slice()),\n                                 None => None\n@@ -678,7 +703,7 @@ impl DocFolder for Cache {\n             clean::VariantItem(..) => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n-                self.paths.insert(item.id, (stack, \"enum\"));\n+                self.paths.insert(item.id, (stack, item_type::Enum));\n             }\n             _ => {}\n         }\n@@ -836,7 +861,7 @@ impl Context {\n             }\n             title.push_str(\" - Rust\");\n             let page = layout::Page {\n-                ty: shortty(it),\n+                ty: shortty(it).to_static_str(),\n                 root_path: cx.root_path.as_slice(),\n                 title: title.as_slice(),\n             };\n@@ -890,27 +915,6 @@ impl Context {\n     }\n }\n \n-fn shortty(item: &clean::Item) -> &'static str {\n-    match item.inner {\n-        clean::ModuleItem(..)          => \"mod\",\n-        clean::StructItem(..)          => \"struct\",\n-        clean::EnumItem(..)            => \"enum\",\n-        clean::FunctionItem(..)        => \"fn\",\n-        clean::TypedefItem(..)         => \"typedef\",\n-        clean::StaticItem(..)          => \"static\",\n-        clean::TraitItem(..)           => \"trait\",\n-        clean::ImplItem(..)            => \"impl\",\n-        clean::ViewItemItem(..)        => \"viewitem\",\n-        clean::TyMethodItem(..)        => \"tymethod\",\n-        clean::MethodItem(..)          => \"method\",\n-        clean::StructFieldItem(..)     => \"structfield\",\n-        clean::VariantItem(..)         => \"variant\",\n-        clean::ForeignFunctionItem(..) => \"ffi\",\n-        clean::ForeignStaticItem(..)   => \"ffs\",\n-        clean::MacroItem(..)           => \"macro\",\n-    }\n-}\n-\n impl<'a> Item<'a> {\n     fn ismodule(&self) -> bool {\n         match self.item.inner {\n@@ -1000,7 +1004,7 @@ impl<'a> fmt::Show for Item<'a> {\n fn item_path(item: &clean::Item) -> ~str {\n     match item.inner {\n         clean::ModuleItem(..) => *item.name.get_ref() + \"/index.html\",\n-        _ => shortty(item) + \".\" + *item.name.get_ref() + \".html\"\n+        _ => shortty(item).to_static_str() + \".\" + *item.name.get_ref() + \".html\"\n     }\n }\n \n@@ -1086,13 +1090,13 @@ fn item_module(w: &mut Writer, cx: &Context,\n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n-    let mut curty = \"\";\n+    let mut curty = None;\n     for &idx in indices.iter() {\n         let myitem = &items[idx];\n \n-        let myty = shortty(myitem);\n+        let myty = Some(shortty(myitem));\n         if myty != curty {\n-            if curty != \"\" {\n+            if curty.is_some() {\n                 try!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n@@ -1695,8 +1699,9 @@ impl<'a> fmt::Show for Sidebar<'a> {\n             };\n             try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n             for item in items.iter() {\n+                let curty = shortty(cur).to_static_str();\n                 let class = if cur.name.get_ref() == item &&\n-                               short == shortty(cur) { \"current\" } else { \"\" };\n+                               short == curty { \"current\" } else { \"\" };\n                 try!(write!(w, \"<a class='{ty} {class}' href='{curty, select,\n                                 mod{../}\n                                 other{}\n@@ -1707,7 +1712,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n                        ty = short,\n                        tysel = short,\n                        class = class,\n-                       curty = shortty(cur),\n+                       curty = curty,\n                        name = item.as_slice()));\n             }\n             try!(write!(w, \"</div>\"));\n@@ -1726,7 +1731,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n fn build_sidebar(m: &clean::Module) -> HashMap<~str, Vec<~str> > {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n-        let short = shortty(item);\n+        let short = shortty(item).to_static_str();\n         let myname = match item.name {\n             None => continue,\n             Some(ref s) => s.to_owned(),"}, {"sha": "4b79ae89eef6bc41a0ba566c7752e3cb5f560afd", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 63, "deletions": 15, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n /*jslint browser: true, es5: true */\n-/*globals $: true, rootPath: true, allPaths: true */\n+/*globals $: true, rootPath: true */\n \n (function() {\n     \"use strict\";\n@@ -135,7 +135,7 @@\n         function execQuery(query, max, searchWords) {\n             var valLower = query.query.toLowerCase(),\n                 val = valLower,\n-                typeFilter = query.type,\n+                typeFilter = itemTypeFromName(query.type),\n                 results = [],\n                 split = valLower.split(\"::\");\n \n@@ -156,7 +156,7 @@\n                 for (var i = 0; i < nSearchWords; i += 1) {\n                     if (searchWords[i] === val) {\n                         // filter type: ... queries\n-                        if (!typeFilter || typeFilter === searchIndex[i].ty) {\n+                        if (typeFilter < 0 || typeFilter === searchIndex[i].ty) {\n                             results.push({id: i, index: -1});\n                         }\n                     }\n@@ -174,7 +174,7 @@\n                             searchWords[j].replace(/_/g, \"\").indexOf(val) > -1)\n                         {\n                             // filter type: ... queries\n-                            if (!typeFilter || typeFilter === searchIndex[j].ty) {\n+                            if (typeFilter < 0 || typeFilter === searchIndex[j].ty) {\n                                 results.push({id: j, index: searchWords[j].replace(/_/g, \"\").indexOf(val)});\n                             }\n                         }\n@@ -258,7 +258,7 @@\n                 var result = results[i],\n                     name = result.item.name.toLowerCase(),\n                     path = result.item.path.toLowerCase(),\n-                    parent = allPaths[result.item.crate][result.item.parent];\n+                    parent = result.item.parent;\n \n                 var valid = validateResult(name, path, split, parent);\n                 if (!valid) {\n@@ -405,7 +405,7 @@\n \n                     shown.push(item);\n                     name = item.name;\n-                    type = item.ty;\n+                    type = itemTypes[item.ty];\n \n                     output += '<tr class=\"' + type + ' result\"><td>';\n \n@@ -422,12 +422,12 @@\n                             '/index.html\" class=\"' + type +\n                             '\">' + name + '</a>';\n                     } else if (item.parent !== undefined) {\n-                        var myparent = allPaths[item.crate][item.parent];\n+                        var myparent = item.parent;\n                         var anchor = '#' + type + '.' + name;\n                         output += item.path + '::' + myparent.name +\n                             '::<a href=\"' + rootPath +\n                             item.path.replace(/::/g, '/') +\n-                            '/' + myparent.type +\n+                            '/' + itemTypes[myparent.ty] +\n                             '.' + myparent.name +\n                             '.html' + anchor +\n                             '\" class=\"' + type +\n@@ -505,28 +505,76 @@\n             showResults(results);\n         }\n \n+        // This mapping table should match the discriminants of\n+        // `rustdoc::html::item_type::ItemType` type in Rust.\n+        var itemTypes = [\"mod\",\n+                         \"struct\",\n+                         \"enum\",\n+                         \"fn\",\n+                         \"typedef\",\n+                         \"static\",\n+                         \"trait\",\n+                         \"impl\",\n+                         \"viewitem\",\n+                         \"tymethod\",\n+                         \"method\",\n+                         \"structfield\",\n+                         \"variant\",\n+                         \"ffi\",\n+                         \"ffs\",\n+                         \"macro\"];\n+\n+        function itemTypeFromName(typename) {\n+            for (var i = 0; i < itemTypes.length; ++i) {\n+                if (itemTypes[i] === typename) return i;\n+            }\n+            return -1;\n+        }\n+\n         function buildIndex(rawSearchIndex) {\n             searchIndex = [];\n             var searchWords = [];\n             for (var crate in rawSearchIndex) {\n                 if (!rawSearchIndex.hasOwnProperty(crate)) { continue }\n-                var len = rawSearchIndex[crate].length;\n-                var i = 0;\n \n+                // an array of [(Number) item type,\n+                //              (String) name,\n+                //              (String) full path or empty string for previous path,\n+                //              (String) description,\n+                //              (optional Number) the parent path index to `paths`]\n+                var items = rawSearchIndex[crate].items;\n+                // an array of [(Number) item type,\n+                //              (String) name]\n+                var paths = rawSearchIndex[crate].paths;\n+\n+                // convert `paths` into an object form\n+                var len = paths.length;\n+                for (var i = 0; i < len; ++i) {\n+                    paths[i] = {ty: paths[i][0], name: paths[i][1]};\n+                }\n+\n+                // convert `items` into an object form, and construct word indices.\n+                //\n                 // before any analysis is performed lets gather the search terms to\n                 // search against apart from the rest of the data.  This is a quick\n                 // operation that is cached for the life of the page state so that\n                 // all other search operations have access to this cached data for\n                 // faster analysis operations\n-                for (i = 0; i < len; i += 1) {\n-                    rawSearchIndex[crate][i].crate = crate;\n-                    searchIndex.push(rawSearchIndex[crate][i]);\n-                    if (typeof rawSearchIndex[crate][i].name === \"string\") {\n-                        var word = rawSearchIndex[crate][i].name.toLowerCase();\n+                var len = items.length;\n+                var lastPath = \"\";\n+                for (var i = 0; i < len; i += 1) {\n+                    var rawRow = items[i];\n+                    var row = {crate: crate, ty: rawRow[0], name: rawRow[1],\n+                               path: rawRow[2] || lastPath, desc: rawRow[3],\n+                               parent: paths[rawRow[4]]};\n+                    searchIndex.push(row);\n+                    if (typeof row.name === \"string\") {\n+                        var word = row.name.toLowerCase();\n                         searchWords.push(word);\n                     } else {\n                         searchWords.push(\"\");\n                     }\n+                    lastPath = row.path;\n                 }\n             }\n             return searchWords;"}, {"sha": "db6f6778efcad0ee4e9dc86e696c08be5c70db74", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f41a85d8e1f577f17e5b17a1d648508e1ac5001/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=2f41a85d8e1f577f17e5b17a1d648508e1ac5001", "patch": "@@ -41,6 +41,7 @@ pub mod fold;\n pub mod html {\n     pub mod highlight;\n     pub mod escape;\n+    pub mod item_type;\n     pub mod format;\n     pub mod layout;\n     pub mod markdown;"}]}