{"sha": "13b5f69848bf4ba9213fa60e7873f6ff51fc3afc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzYjVmNjk4NDhiZjRiYTkyMTNmYTYwZTc4NzNmNmZmNTFmYzNhZmM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-07-15T14:51:35Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-07-20T19:01:11Z"}, "message": "Improve NLL mutability errors\n\n* Better explain why the place is immutable\n* Distinguish &T and *const T\n* Use better spans when a mutable borrow is for a closure capture", "tree": {"sha": "94b783d92a38ba686848b5debcf774552e072f7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94b783d92a38ba686848b5debcf774552e072f7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc", "html_url": "https://github.com/rust-lang/rust/commit/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db568e426a254a83b8891b6ea6836913d28181d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/db568e426a254a83b8891b6ea6836913d28181d3", "html_url": "https://github.com/rust-lang/rust/commit/db568e426a254a83b8891b6ea6836913d28181d3"}], "stats": {"total": 294, "additions": 257, "deletions": 37}, "files": [{"sha": "3dca7768d704e6ba0f20203e15e3c512df0660c2", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=13b5f69848bf4ba9213fa60e7873f6ff51fc3afc", "patch": "@@ -202,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// the local assigned at `location`.\n     /// This is done by searching in statements succeeding `location`\n     /// and originating from `maybe_closure_span`.\n-    fn find_closure_span(\n+    pub(super) fn find_closure_span(\n         &self,\n         maybe_closure_span: Span,\n         location: Location,"}, {"sha": "2a074a84e63e5e953b73079976eea56d55682334", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 242, "deletions": 33, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=13b5f69848bf4ba9213fa60e7873f6ff51fc3afc", "patch": "@@ -36,42 +36,166 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         location: Location,\n     ) {\n         let mut err;\n-        let item_msg = match self.describe_place(place) {\n-            Some(name) => format!(\"immutable item `{}`\", name),\n-            None => \"immutable item\".to_owned(),\n-        };\n+        let item_msg;\n+        let reason;\n+        let access_place_desc = self.describe_place(access_place);\n+\n+        match the_place_err {\n+            Place::Local(local) => {\n+                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                if let Place::Local(_) = access_place {\n+                    reason = \", as it is not declared as mutable\".to_string();\n+                } else {\n+                    let name = self.mir.local_decls[*local]\n+                        .name\n+                        .expect(\"immutable unnamed local\");\n+                    reason = format!(\", as `{}` is not declared as mutable\", name);\n+                }\n+            }\n+\n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Field(upvar_index, _),\n+            }) => {\n+                debug_assert!(is_closure_or_generator(\n+                    base.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                ));\n+\n+                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                if self.is_upvar(access_place) {\n+                    reason = \", as it is not declared as mutable\".to_string();\n+                } else {\n+                    let name = self.mir.upvar_decls[upvar_index.index()].debug_name;\n+                    reason = format!(\", as `{}` is not declared as mutable\", name);\n+                }\n+            }\n+\n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Deref,\n+            }) => {\n+                if *base == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty() {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n+                    debug_assert!(is_closure_or_generator(\n+                        the_place_err.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                    ));\n+\n+                    reason = if self.is_upvar(access_place) {\n+                        \", as it is a captured variable in a `Fn` closure\".to_string()\n+                    } else {\n+                        format!(\", as `Fn` closures cannot mutate their captured variables\")\n+                    }\n+                } else if {\n+                    if let Place::Local(local) = *base {\n+                        if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n+                            = self.mir.local_decls[local].is_user_variable {\n+                                true\n+                        } else {\n+                            false\n+                        }\n+                    } else {\n+                        false\n+                    }\n+                } {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    reason = format!(\", as it is immutable for the pattern guard\");\n+                } else {\n+                    let pointer_type =\n+                        if base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n+                            \"`&` reference\"\n+                        } else {\n+                            \"`*const` pointer\"\n+                        };\n+                    if let Some(desc) = access_place_desc {\n+                        item_msg = format!(\"`{}`\", desc);\n+                        reason = match error_access {\n+                            AccessKind::Mutate => format!(\" which is behind a {}\", pointer_type),\n+                            AccessKind::MutableBorrow => {\n+                                format!(\", as it is behind a {}\", pointer_type)\n+                            }\n+                        }\n+                    } else {\n+                        item_msg = format!(\"data in a {}\", pointer_type);\n+                        reason = \"\".to_string();\n+                    }\n+                }\n+            }\n+\n+            Place::Static(box Static { def_id, ty: _ }) => {\n+                if let Place::Static(_) = access_place {\n+                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n+                    reason = \"\".to_string();\n+                } else {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    let static_name = &self.tcx.item_name(*def_id);\n+                    reason = format!(\", as `{}` is an immutable static item\", static_name);\n+                }\n+            }\n+\n+            Place::Projection(box Projection {\n+                base: _,\n+                elem: ProjectionElem::Index(_),\n+            })\n+            | Place::Projection(box Projection {\n+                base: _,\n+                elem: ProjectionElem::ConstantIndex { .. },\n+            })\n+            | Place::Projection(box Projection {\n+                base: _,\n+                elem: ProjectionElem::Subslice { .. },\n+            })\n+            | Place::Projection(box Projection {\n+                base: _,\n+                elem: ProjectionElem::Downcast(..),\n+            }) => bug!(\"Unexpected immutable place.\"),\n+        }\n \n         // `act` and `acted_on` are strings that let us abstract over\n         // the verbs used in some diagnostic messages.\n         let act;\n         let acted_on;\n \n-        match error_access {\n+\n+        let span = match error_access {\n             AccessKind::Mutate => {\n-                let item_msg = match the_place_err {\n-                    Place::Projection(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::Deref,\n-                    }) => match self.describe_place(place) {\n-                        Some(description) => {\n-                            format!(\"`{}` which is behind a `&` reference\", description)\n-                        }\n-                        None => format!(\"data in a `&` reference\"),\n-                    },\n-                    _ => item_msg,\n-                };\n-                err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                err = self.tcx\n+                    .cannot_assign(span, &(item_msg + &reason), Origin::Mir);\n                 act = \"assign\";\n                 acted_on = \"written\";\n+                span\n             }\n             AccessKind::MutableBorrow => {\n-                err = self\n-                    .tcx\n-                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n                 act = \"borrow as mutable\";\n                 acted_on = \"borrowed as mutable\";\n+\n+                let closure_span = self.find_closure_span(span, location);\n+                if let Some((args, var)) = closure_span {\n+                    err = self.tcx.cannot_borrow_path_as_mutable_because(\n+                        args,\n+                        &item_msg,\n+                        &reason,\n+                        Origin::Mir,\n+                    );\n+                    err.span_label(\n+                        var,\n+                        format!(\n+                            \"mutable borrow occurs due to use of `{}` in closure\",\n+                            self.describe_place(access_place).unwrap(),\n+                        ),\n+                    );\n+                    args\n+                } else {\n+                    err = self.tcx.cannot_borrow_path_as_mutable_because(\n+                        span,\n+                        &item_msg,\n+                        &reason,\n+                        Origin::Mir,\n+                    );\n+                    span\n+                }\n             }\n-        }\n+        };\n \n         match the_place_err {\n             // We want to suggest users use `let mut` for local (user\n@@ -80,7 +204,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n-                // mutable)..\n+                // mutable).\n                 let local_decl = &self.mir.local_decls[*local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n@@ -92,6 +216,38 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 );\n             }\n \n+            // Also suggest adding mut for upvars\n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Field(upvar_index, _),\n+            }) => {\n+                debug_assert!(is_closure_or_generator(\n+                    base.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                ));\n+\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+\n+                let upvar_hir_id = self.mir.upvar_decls[upvar_index.index()]\n+                    .var_hir_id\n+                    .assert_crate_local();\n+                let upvar_node_id = self.tcx.hir.hir_to_node_id(upvar_hir_id);\n+                if let Some(hir::map::NodeBinding(pat)) = self.tcx.hir.find(upvar_node_id) {\n+                    if let hir::PatKind::Binding(\n+                        hir::BindingAnnotation::Unannotated,\n+                        _,\n+                        upvar_ident,\n+                        _,\n+                    ) = pat.node\n+                    {\n+                        err.span_suggestion(\n+                            upvar_ident.span,\n+                            \"consider changing this to be mutable\",\n+                            format!(\"mut {}\", upvar_ident.name),\n+                        );\n+                    }\n+                }\n+            }\n+\n             // complete hack to approximate old AST-borrowck\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n@@ -108,6 +264,25 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 err.span_label(span, \"try removing `&mut` here\");\n             }\n \n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) if {\n+                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n+                    self.mir.local_decls[*local].is_user_variable\n+                {\n+                    true\n+                } else {\n+                    false\n+                }\n+            } =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.note(\n+                    \"variables bound in patterns are immutable until the end of the pattern guard\",\n+                );\n+            }\n+\n             // We want to point out when a `&` can be readily replaced\n             // with an `&mut`.\n             //\n@@ -116,12 +291,13 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             Place::Projection(box Projection {\n                 base: Place::Local(local),\n                 elem: ProjectionElem::Deref,\n-            }) if self.mir.local_decls[*local].is_user_variable.is_some() => {\n+            }) if self.mir.local_decls[*local].is_user_variable.is_some() =>\n+            {\n                 let local_decl = &self.mir.local_decls[*local];\n                 let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n                     ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n                         Some(suggest_ampmut_self(local_decl))\n-                    },\n+                    }\n \n                     ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n                         binding_mode: ty::BindingMode::BindByValue(_),\n@@ -140,13 +316,22 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         ..\n                     })) => suggest_ref_mut(self.tcx, local_decl.source_info.span),\n \n+                    //\n+                    ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),\n+\n                     ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n                 };\n \n+                let (pointer_sigil, pointer_desc) = if local_decl.ty.is_region_ptr() {\n+                    (\"&\", \"reference\")\n+                } else {\n+                    (\"*const\", \"pointer\")\n+                };\n+\n                 if let Some((err_help_span, suggested_code)) = suggestion {\n                     err.span_suggestion(\n                         err_help_span,\n-                        \"consider changing this to be a mutable reference\",\n+                        &format!(\"consider changing this to be a mutable {}\", pointer_desc),\n                         suggested_code,\n                     );\n                 }\n@@ -155,20 +340,39 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     err.span_label(\n                         span,\n                         format!(\n-                            \"`{NAME}` is a `&` reference, \\\n+                            \"`{NAME}` is a `{SIGIL}` {DESC}, \\\n                              so the data it refers to cannot be {ACTED_ON}\",\n                             NAME = name,\n+                            SIGIL = pointer_sigil,\n+                            DESC = pointer_desc,\n                             ACTED_ON = acted_on\n                         ),\n                     );\n                 } else {\n                     err.span_label(\n                         span,\n-                        format!(\"cannot {ACT} through `&`-reference\", ACT = act),\n+                        format!(\n+                            \"cannot {ACT} through `{SIGIL}` {DESC}\",\n+                            ACT = act,\n+                            SIGIL = pointer_sigil,\n+                            DESC = pointer_desc\n+                        ),\n                     );\n                 }\n             }\n \n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Deref,\n+            }) if *base == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty() =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_help(\n+                    self.mir.span,\n+                    \"consider changing this to accept closures that implement `FnMut`\"\n+                );\n+            }\n+\n             _ => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n             }\n@@ -236,10 +440,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n         if let Ok(src) = snippet {\n             if src.starts_with('&') {\n                 let borrowed_expr = src[1..].to_string();\n-                return (\n-                    assignment_rhs_span,\n-                    format!(\"&mut {}\", borrowed_expr),\n-                );\n+                return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n             }\n         }\n     }\n@@ -256,5 +457,13 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n     assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n-    (highlight_span, format!(\"&mut {}\", ty_mut.ty))\n+    if local_decl.ty.is_region_ptr() {\n+        (highlight_span, format!(\"&mut {}\", ty_mut.ty))\n+    } else {\n+        (highlight_span, format!(\"*mut {}\", ty_mut.ty))\n+    }\n+}\n+\n+fn is_closure_or_generator(ty: ty::Ty) -> bool {\n+    ty.is_closure() || ty.is_generator()\n }"}, {"sha": "2d6b6cea030197b9673b715124d55f1e02f3a5ac", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13b5f69848bf4ba9213fa60e7873f6ff51fc3afc/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=13b5f69848bf4ba9213fa60e7873f6ff51fc3afc", "patch": "@@ -519,24 +519,35 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_path_as_mutable(\n+    fn cannot_borrow_path_as_mutable_because(\n         self,\n         span: Span,\n         path: &str,\n+        reason: &str,\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let err = struct_span_err!(\n             self,\n             span,\n             E0596,\n-            \"cannot borrow {} as mutable{OGN}\",\n+            \"cannot borrow {} as mutable{}{OGN}\",\n             path,\n-            OGN = o\n+            reason,\n+            OGN = o,\n         );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n+    fn cannot_borrow_path_as_mutable(\n+        self,\n+        span: Span,\n+        path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        self.cannot_borrow_path_as_mutable_because(span, path, \"\", o)\n+    }\n+\n     fn cannot_borrow_across_generator_yield(\n         self,\n         span: Span,"}]}