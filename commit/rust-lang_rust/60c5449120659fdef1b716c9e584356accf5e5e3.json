{"sha": "60c5449120659fdef1b716c9e584356accf5e5e3", "node_id": "C_kwDOAAsO6NoAKDYwYzU0NDkxMjA2NTlmZGVmMWI3MTZjOWU1ODQzNTZhY2NmNWU1ZTM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-02T17:39:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-02T17:39:06Z"}, "message": "Merge #10431\n\n10431: internal: cleanup mbe a bit r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "171f2d19d5556e54dcefe47400ca0f5263c427cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/171f2d19d5556e54dcefe47400ca0f5263c427cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60c5449120659fdef1b716c9e584356accf5e5e3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhWJk6CRBK7hj4Ov3rIwAA258IADVhHCkLyUiRRnropARAHA4N\nP8nEOIqX5G2e6VMqureOE+cBotuBQxbxjSp0JA3zsrC4Fj1ixm+ML/tGc2jPUy6r\nfM6MZHtjndN4jW+u0bZMGU+fZfzjfYpdAgSPKuES8YC2+yTHutVe0sQoXssj3uzd\n9CsLS+ESp93WtwQjUSyDiuy5+1CF/FiFbV3idRPK+aov3KnLqSpc+hYD4LXMF8PT\nyhzLp5zj91P5c4UOYO6rMlVtsu7r67sNicBQbx8fMwesbi6Nxd33sBTyTsrU7of1\n9Sl4M/ZiGgz9/cRCZ4NGfxSXbyQNQvbH3ulVCnFtDBqqdj97Xr5R87uXqmeM/B8=\n=gTXH\n-----END PGP SIGNATURE-----\n", "payload": "tree 171f2d19d5556e54dcefe47400ca0f5263c427cf\nparent e504f8ae8d7e63abd4926a4ea6b1344bba3157d1\nparent 4e352275d17dcba44052f232940223cbbb70c7ce\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633196346 +0000\ncommitter GitHub <noreply@github.com> 1633196346 +0000\n\nMerge #10431\n\n10431: internal: cleanup mbe a bit r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60c5449120659fdef1b716c9e584356accf5e5e3", "html_url": "https://github.com/rust-lang/rust/commit/60c5449120659fdef1b716c9e584356accf5e5e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60c5449120659fdef1b716c9e584356accf5e5e3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e504f8ae8d7e63abd4926a4ea6b1344bba3157d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e504f8ae8d7e63abd4926a4ea6b1344bba3157d1", "html_url": "https://github.com/rust-lang/rust/commit/e504f8ae8d7e63abd4926a4ea6b1344bba3157d1"}, {"sha": "4e352275d17dcba44052f232940223cbbb70c7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e352275d17dcba44052f232940223cbbb70c7ce", "html_url": "https://github.com/rust-lang/rust/commit/4e352275d17dcba44052f232940223cbbb70c7ce"}], "stats": {"total": 179, "additions": 95, "deletions": 84}, "files": [{"sha": "06c21dfd70fe5ec4a22d2c668d0873a1e71a839e", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/60c5449120659fdef1b716c9e584356accf5e5e3/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c5449120659fdef1b716c9e584356accf5e5e3/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=60c5449120659fdef1b716c9e584356accf5e5e3", "patch": "@@ -63,7 +63,7 @@ use std::rc::Rc;\n \n use crate::{\n     expander::{Binding, Bindings, Fragment},\n-    parser::{Op, OpDelimited, OpDelimitedIter, RepeatKind, Separator},\n+    parser::{Op, RepeatKind, Separator},\n     tt_iter::TtIter,\n     ExpandError, MetaTemplate,\n };\n@@ -750,6 +750,64 @@ fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) {\n     }\n }\n \n+impl MetaTemplate {\n+    fn iter_delimited<'a>(&'a self, delimited: Option<&'a tt::Delimiter>) -> OpDelimitedIter<'a> {\n+        OpDelimitedIter { inner: &self.0, idx: 0, delimited }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum OpDelimited<'a> {\n+    Op(&'a Op),\n+    Open,\n+    Close,\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+struct OpDelimitedIter<'a> {\n+    inner: &'a [Op],\n+    delimited: Option<&'a tt::Delimiter>,\n+    idx: usize,\n+}\n+\n+impl<'a> OpDelimitedIter<'a> {\n+    fn is_eof(&self) -> bool {\n+        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        self.idx >= len\n+    }\n+\n+    fn peek(&self) -> Option<OpDelimited<'a>> {\n+        match self.delimited {\n+            None => self.inner.get(self.idx).map(OpDelimited::Op),\n+            Some(_) => match self.idx {\n+                0 => Some(OpDelimited::Open),\n+                i if i == self.inner.len() + 1 => Some(OpDelimited::Close),\n+                i => self.inner.get(i - 1).map(OpDelimited::Op),\n+            },\n+        }\n+    }\n+\n+    fn reset(&self) -> Self {\n+        Self { inner: self.inner, idx: 0, delimited: self.delimited }\n+    }\n+}\n+\n+impl<'a> Iterator for OpDelimitedIter<'a> {\n+    type Item = OpDelimited<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let res = self.peek();\n+        self.idx += 1;\n+        res\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        let remain = len.saturating_sub(self.idx);\n+        (remain, Some(remain))\n+    }\n+}\n+\n impl<'a> TtIter<'a> {\n     fn expect_separator(&mut self, separator: &Separator, idx: usize) -> bool {\n         let mut fork = self.clone();"}, {"sha": "8470ea0aaf58dd90b20fcaacb7c457cedca433d2", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60c5449120659fdef1b716c9e584356accf5e5e3/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c5449120659fdef1b716c9e584356accf5e5e3/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=60c5449120659fdef1b716c9e584356accf5e5e3", "patch": "@@ -19,7 +19,7 @@ mod token_map;\n use std::fmt;\n \n use crate::{\n-    parser::{parse_pattern, parse_template, MetaTemplate, Op},\n+    parser::{MetaTemplate, Op},\n     tt_iter::TtIter,\n };\n \n@@ -275,8 +275,8 @@ impl Rule {\n             .expect_subtree()\n             .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?;\n \n-        let lhs = MetaTemplate(parse_pattern(lhs)?);\n-        let rhs = MetaTemplate(parse_template(rhs)?);\n+        let lhs = MetaTemplate::parse_pattern(lhs)?;\n+        let rhs = MetaTemplate::parse_template(rhs)?;\n \n         Ok(crate::Rule { lhs, rhs })\n     }"}, {"sha": "4ce818f9b00752f243c8cd78d58aed8a610bc182", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 33, "deletions": 80, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/60c5449120659fdef1b716c9e584356accf5e5e3/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c5449120659fdef1b716c9e584356accf5e5e3/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=60c5449120659fdef1b716c9e584356accf5e5e3", "patch": "@@ -3,75 +3,48 @@\n \n use smallvec::SmallVec;\n use syntax::SmolStr;\n-use tt::Delimiter;\n \n use crate::{tt_iter::TtIter, ParseError};\n \n+/// Consider\n+///\n+/// ```\n+/// macro_rules! an_macro {\n+///     ($x:expr + $y:expr) => ($y * $x)\n+/// }\n+/// ```\n+///\n+/// Stuff to the left of `=>` is a [`MetaTemplate`] pattern (which is matched\n+/// with input).\n+///\n+/// Stuff to the right is a [`MetaTemplate`] template which is used to produce\n+/// output.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct MetaTemplate(pub(crate) Vec<Op>);\n \n-#[derive(Debug, Clone, Copy)]\n-pub(crate) enum OpDelimited<'a> {\n-    Op(&'a Op),\n-    Open,\n-    Close,\n-}\n-\n-#[derive(Debug, Clone, Copy)]\n-pub(crate) struct OpDelimitedIter<'a> {\n-    inner: &'a Vec<Op>,\n-    delimited: Option<&'a Delimiter>,\n-    idx: usize,\n-}\n-\n-impl<'a> OpDelimitedIter<'a> {\n-    pub(crate) fn is_eof(&self) -> bool {\n-        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n-        self.idx >= len\n-    }\n-\n-    pub(crate) fn peek(&self) -> Option<OpDelimited<'a>> {\n-        match self.delimited {\n-            None => self.inner.get(self.idx).map(OpDelimited::Op),\n-            Some(_) => match self.idx {\n-                0 => Some(OpDelimited::Open),\n-                i if i == self.inner.len() + 1 => Some(OpDelimited::Close),\n-                i => self.inner.get(i - 1).map(OpDelimited::Op),\n-            },\n-        }\n-    }\n-\n-    pub(crate) fn reset(&self) -> Self {\n-        Self { inner: self.inner, idx: 0, delimited: self.delimited }\n+impl MetaTemplate {\n+    pub(crate) fn parse_pattern(pattern: &tt::Subtree) -> Result<MetaTemplate, ParseError> {\n+        MetaTemplate::parse(pattern, Mode::Pattern)\n     }\n-}\n-\n-impl<'a> Iterator for OpDelimitedIter<'a> {\n-    type Item = OpDelimited<'a>;\n \n-    fn next(&mut self) -> Option<Self::Item> {\n-        let res = self.peek();\n-        self.idx += 1;\n-        res\n+    pub(crate) fn parse_template(template: &tt::Subtree) -> Result<MetaTemplate, ParseError> {\n+        MetaTemplate::parse(template, Mode::Template)\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n-        let remain = len.saturating_sub(self.idx);\n-        (remain, Some(remain))\n-    }\n-}\n-\n-impl<'a> MetaTemplate {\n     pub(crate) fn iter(&self) -> impl Iterator<Item = &Op> {\n         self.0.iter()\n     }\n \n-    pub(crate) fn iter_delimited(\n-        &'a self,\n-        delimited: Option<&'a Delimiter>,\n-    ) -> OpDelimitedIter<'a> {\n-        OpDelimitedIter { inner: &self.0, idx: 0, delimited }\n+    fn parse(tt: &tt::Subtree, mode: Mode) -> Result<MetaTemplate, ParseError> {\n+        let mut src = TtIter::new(tt);\n+\n+        let mut res = Vec::new();\n+        while let Some(first) = src.next() {\n+            let op = next_op(first, &mut src, mode)?;\n+            res.push(op)\n+        }\n+\n+        Ok(MetaTemplate(res))\n     }\n }\n \n@@ -80,7 +53,7 @@ pub(crate) enum Op {\n     Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n     Leaf(tt::Leaf),\n-    Subtree { tokens: MetaTemplate, delimiter: Option<Delimiter> },\n+    Subtree { tokens: MetaTemplate, delimiter: Option<tt::Delimiter> },\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -125,29 +98,12 @@ impl Separator {\n     }\n }\n \n-pub(crate) fn parse_template(template: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n-    parse_inner(template, Mode::Template).into_iter().collect()\n-}\n-\n-pub(crate) fn parse_pattern(pattern: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n-    parse_inner(pattern, Mode::Pattern).into_iter().collect()\n-}\n-\n #[derive(Clone, Copy)]\n enum Mode {\n     Pattern,\n     Template,\n }\n \n-fn parse_inner(tt: &tt::Subtree, mode: Mode) -> Vec<Result<Op, ParseError>> {\n-    let mut src = TtIter::new(tt);\n-    std::iter::from_fn(move || {\n-        let first = src.next()?;\n-        Some(next_op(first, &mut src, mode))\n-    })\n-    .collect()\n-}\n-\n macro_rules! err {\n     ($($tt:tt)*) => {\n         ParseError::UnexpectedToken(($($tt)*).to_string())\n@@ -171,10 +127,8 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n             match second {\n                 tt::TokenTree::Subtree(subtree) => {\n                     let (separator, kind) = parse_repeat(src)?;\n-                    let tokens = parse_inner(subtree, mode)\n-                        .into_iter()\n-                        .collect::<Result<Vec<Op>, ParseError>>()?;\n-                    Op::Repeat { tokens: MetaTemplate(tokens), separator, kind }\n+                    let tokens = MetaTemplate::parse(subtree, mode)?;\n+                    Op::Repeat { tokens, separator, kind }\n                 }\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n                     tt::Leaf::Punct(_) => {\n@@ -205,9 +159,8 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n         }\n         tt::TokenTree::Leaf(tt) => Op::Leaf(tt.clone()),\n         tt::TokenTree::Subtree(subtree) => {\n-            let tokens =\n-                parse_inner(subtree, mode).into_iter().collect::<Result<Vec<Op>, ParseError>>()?;\n-            Op::Subtree { tokens: MetaTemplate(tokens), delimiter: subtree.delimiter }\n+            let tokens = MetaTemplate::parse(subtree, mode)?;\n+            Op::Subtree { tokens, delimiter: subtree.delimiter }\n         }\n     };\n     Ok(res)"}]}