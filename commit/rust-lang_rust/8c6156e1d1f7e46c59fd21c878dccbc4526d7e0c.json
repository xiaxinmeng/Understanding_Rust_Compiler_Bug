{"sha": "8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNjE1NmUxZDFmN2U0NmM1OWZkMjFjODc4ZGNjYmM0NTI2ZDdlMGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-23T01:07:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T12:18:01Z"}, "message": "have coercion supply back the target type\n\nThe `try_coerce` method coerces from a source to a target\ntype, possibly inserting adjustments. It should guarantee\nthat the post-adjustment type is a subtype of the target type\n(or else that some side-constraint has been registered which will lead\nto an error). However, it used to return the (possibly adjusted) source\nas the type of the expression rather than the target. This led to\nless good downstream errors.\n\nTo work around this, the code around blocks -- and particular tail\nexpressions in blocks -- had some special case manipulation. However,\nsince that code is now using the more general `CoerceMany` construct (to\naccount for breaks), it can no longer take advantage of that. This lead\nto some regressions in compile-fail tests were errors were reported at\n\"less good\" locations than before.\n\nThis change modifies coercions to return the target type when successful\nrather the source type. This extends the behavior from blocks to all\ncoercions. Typically this has limited effect but on a few tests yielded\nbetter errors results (and avoided regressions, of course).\n\nThis change also restores the hint about removing semicolons which went\nmissing (by giving 'force-unit' coercions a chance to add notes etc).", "tree": {"sha": "c4fd161eeacf7bf660a49d83e9d02f6ce95752f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4fd161eeacf7bf660a49d83e9d02f6ce95752f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "html_url": "https://github.com/rust-lang/rust/commit/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d08a6da1f05dc6f8de4201efe949f1c26704ced0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08a6da1f05dc6f8de4201efe949f1c26704ced0", "html_url": "https://github.com/rust-lang/rust/commit/d08a6da1f05dc6f8de4201efe949f1c26704ced0"}], "stats": {"total": 152, "additions": 91, "deletions": 61}, "files": [{"sha": "4a04464244442a2763b3c9124dc7074b35d31adc", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if is_if_let_fallback {\n                 let cause = self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse);\n                 assert!(arm_ty.is_nil());\n-                coercion.coerce_forced_unit(self, &cause);\n+                coercion.coerce_forced_unit(self, &cause, &mut |_| ());\n             } else {\n                 let cause = self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n                     arm_span: arm.body.span,"}, {"sha": "a5acd0c7e530047368f0d2abdd4ce89e59532ee7", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "patch": "@@ -74,6 +74,7 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n use rustc::ty::subst::Subst;\n+use errors::DiagnosticBuilder;\n use syntax::abi;\n use syntax::feature_gate;\n use syntax::ptr::P;\n@@ -718,7 +719,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 self.write_adjustment(expr.id, adjustment);\n             }\n-            Ok(adjustment.target)\n+\n+            // We should now have added sufficient adjustments etc to\n+            // ensure that the type of expression, post-adjustment, is\n+            // a subtype of target.\n+            Ok(target)\n         })\n     }\n \n@@ -1000,7 +1005,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                       expression_ty: Ty<'tcx>,\n                       expression_diverges: Diverges)\n     {\n-        self.coerce_inner(fcx, cause, Some(expression), expression_ty, expression_diverges)\n+        self.coerce_inner(fcx, cause, Some(expression), expression_ty, expression_diverges, None)\n     }\n \n     /// Indicates that one of the inputs is a \"forced unit\". This\n@@ -1011,15 +1016,21 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     /// purposes. Note that these tend to correspond to cases where\n     /// the `()` expression is implicit in the source, and hence we do\n     /// not take an expression argument.\n+    ///\n+    /// The `augment_error` gives you a chance to extend the error\n+    /// message, in case any results (e.g., we use this to suggest\n+    /// removing a `;`).\n     pub fn coerce_forced_unit<'a>(&mut self,\n                                   fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                                  cause: &ObligationCause<'tcx>)\n+                                  cause: &ObligationCause<'tcx>,\n+                                  augment_error: &mut FnMut(&mut DiagnosticBuilder))\n     {\n         self.coerce_inner(fcx,\n                           cause,\n                           None,\n                           fcx.tcx.mk_nil(),\n-                          Diverges::Maybe)\n+                          Diverges::Maybe,\n+                          Some(augment_error))\n     }\n \n     /// The inner coercion \"engine\". If `expression` is `None`, this\n@@ -1030,7 +1041,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         cause: &ObligationCause<'tcx>,\n                         expression: Option<&'gcx hir::Expr>,\n                         mut expression_ty: Ty<'tcx>,\n-                        expression_diverges: Diverges)\n+                        expression_diverges: Diverges,\n+                        augment_error: Option<&mut FnMut(&mut DiagnosticBuilder)>)\n     {\n         // Incorporate whatever type inference information we have\n         // until now; in principle we might also want to process\n@@ -1126,19 +1138,25 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     (self.final_ty.unwrap_or(self.expected_ty), expression_ty)\n                 };\n \n+                let mut db;\n                 match cause.code {\n                     ObligationCauseCode::ReturnNoExpression => {\n-                        struct_span_err!(fcx.tcx.sess, cause.span, E0069,\n-                                         \"`return;` in a function whose return type is not `()`\")\n-                            .span_label(cause.span, &format!(\"return type is not ()\"))\n-                            .emit();\n+                        db = struct_span_err!(\n+                            fcx.tcx.sess, cause.span, E0069,\n+                            \"`return;` in a function whose return type is not `()`\");\n+                        db.span_label(cause.span, &format!(\"return type is not ()\"));\n                     }\n                     _ => {\n-                        fcx.report_mismatched_types(cause, expected, found, err)\n-                           .emit();\n+                        db = fcx.report_mismatched_types(cause, expected, found, err);\n                     }\n                 }\n \n+                if let Some(mut augment_error) = augment_error {\n+                    augment_error(&mut db);\n+                }\n+\n+                db.emit();\n+\n                 self.final_ty = Some(fcx.tcx.types.err);\n             }\n         }"}, {"sha": "29b83523aed6b1bd8c50f42258b8b46be6d13bb1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 57, "deletions": 42, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "patch": "@@ -87,7 +87,7 @@ use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_back::slice::ref_slice;\n-use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin, TypeTrace};\n+use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::type_variable::{self, TypeVariableOrigin};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n@@ -99,6 +99,7 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n+use errors::DiagnosticBuilder;\n use require_c_abi_if_variadic;\n use session::{Session, CompileResult};\n use TypeAndSubsts;\n@@ -2875,7 +2876,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n         } else {\n             let else_cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n-            coerce.coerce_forced_unit(self, &else_cause);\n+            coerce.coerce_forced_unit(self, &else_cause, &mut |_| ());\n \n             // If the condition is false we can't diverge.\n             self.diverges.set(cond_diverges);\n@@ -3591,7 +3592,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           coerce.coerce(self, &cause, e, e_ty, e_diverges);\n                       } else {\n                           assert!(e_ty.is_nil());\n-                          coerce.coerce_forced_unit(self, &cause);\n+                          coerce.coerce_forced_unit(self, &cause, &mut |_| ());\n                       }\n                   } else {\n                       // If `ctxt.coerce` is `None`, we can just ignore\n@@ -3626,7 +3627,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else {\n                 let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n                 let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-                coercion.coerce_forced_unit(self, &cause);\n+                coercion.coerce_forced_unit(self, &cause, &mut |_| ());\n             }\n             tcx.types.never\n           }\n@@ -4158,8 +4159,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               tail_expr,\n                               tail_expr_ty,\n                               self.diverges.get()); // TODO\n-            } else if !self.diverges.get().always() {\n-                coerce.coerce_forced_unit(self, &self.misc(blk.span));\n+            } else {\n+                // Subtle: if there is no explicit tail expression,\n+                // that is typically equivalent to a tail expression\n+                // of `()` -- except if the block diverges. In that\n+                // case, there is no value supplied from the tail\n+                // expression (assuming there are no other breaks,\n+                // this implies that the type of the block will be\n+                // `!`).\n+                if !self.diverges.get().always() {\n+                    coerce.coerce_forced_unit(self, &self.misc(blk.span), &mut |err| {\n+                        if let Some(expected_ty) = expected.only_has_type(self) {\n+                            self.consider_hint_about_removing_semicolon(blk,\n+                                                                        expected_ty,\n+                                                                        err);\n+                        }\n+                    });\n+                }\n             }\n         });\n \n@@ -4175,43 +4191,42 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n-    pub fn check_block_no_expr(&self, blk: &'gcx hir::Block, ty: Ty<'tcx>, ety: Ty<'tcx>) {\n-        // We're not diverging and there's an expected type, which,\n-        // in case it's not `()`, could result in an error higher-up.\n-        // We have a chance to error here early and be more helpful.\n-        let cause = self.misc(blk.span);\n-        let trace = TypeTrace::types(&cause, false, ty, ety);\n-        match self.sub_types(false, &cause, ty, ety) {\n-            Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n-            },\n-            Err(err) => {\n-                let mut err = self.report_and_explain_type_error(trace, &err);\n-\n-                // Be helpful when the user wrote `{... expr;}` and\n-                // taking the `;` off is enough to fix the error.\n-                let mut extra_semi = None;\n-                if let Some(stmt) = blk.stmts.last() {\n-                    if let hir::StmtSemi(ref e, _) = stmt.node {\n-                        if self.can_sub_types(self.node_ty(e.id), ety).is_ok() {\n-                            extra_semi = Some(stmt);\n-                        }\n-                    }\n-                }\n-                if let Some(last_stmt) = extra_semi {\n-                    let original_span = original_sp(last_stmt.span, blk.span);\n-                    let span_semi = Span {\n-                        lo: original_span.hi - BytePos(1),\n-                        hi: original_span.hi,\n-                        ctxt: original_span.ctxt,\n-                    };\n-                    err.span_help(span_semi, \"consider removing this semicolon:\");\n-                }\n-\n-                err.emit();\n-            }\n+    /// A common error is to add an extra semicolon:\n+    ///\n+    /// ```\n+    /// fn foo() -> usize {\n+    ///     22;\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the final statement in a block is an\n+    /// expression with an explicit semicolon whose type is compatible\n+    /// with `expected_ty`. If so, it suggests removing the semicolon.\n+    fn consider_hint_about_removing_semicolon(&self,\n+                                              blk: &'gcx hir::Block,\n+                                              expected_ty: Ty<'tcx>,\n+                                              err: &mut DiagnosticBuilder) {\n+        // Be helpful when the user wrote `{... expr;}` and\n+        // taking the `;` off is enough to fix the error.\n+        let last_stmt = match blk.stmts.last() {\n+            Some(s) => s,\n+            None => return,\n+        };\n+        let last_expr = match last_stmt.node {\n+            hir::StmtSemi(ref e, _) => e,\n+            _ => return,\n+        };\n+        let last_expr_ty = self.expr_ty(last_expr);\n+        if self.can_sub_types(last_expr_ty, expected_ty).is_err() {\n+            return;\n         }\n+        let original_span = original_sp(last_stmt.span, blk.span);\n+        let span_semi = Span {\n+            lo: original_span.hi - BytePos(1),\n+            hi: original_span.hi,\n+            ctxt: original_span.ctxt,\n+        };\n+        err.span_help(span_semi, \"consider removing this semicolon:\");\n     }\n \n     // Instantiates the given path, which must refer to an item with the given"}, {"sha": "08b896f387bbed5d13e5f2bd2ef0f01c7261b34c", "filename": "src/test/compile-fail/issue-15965.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs?ref=8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     return\n         { return () }\n-//~^ ERROR expected function, found `!`\n+//~^ ERROR the type of this value must be known in this context\n     ()\n     ;\n }"}, {"sha": "256c5d8e6f72cc08d375e1e45caba593528c0e77", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "patch": "@@ -21,5 +21,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR no method named `bind` found for type `[&'static str; 1]` in the current scope\n+    //~^ ERROR no method named `bind` found for type `[&str; 1]` in the current scope\n }"}, {"sha": "d25674a74b1d37e563adcbe82728b269e3a70626", "filename": "src/test/compile-fail/region-invariant-static-error-reporting.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs?ref=8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "patch": "@@ -13,9 +13,6 @@\n // over time, but this test used to exhibit some pretty bogus messages\n // that were not remotely helpful.\n \n-// error-pattern:cannot infer\n-// error-pattern:cannot outlive the lifetime 'a\n-// error-pattern:must be valid for the static lifetime\n // error-pattern:cannot infer\n // error-pattern:cannot outlive the lifetime 'a\n // error-pattern:must be valid for the static lifetime"}, {"sha": "5ce80be98d9741320d1c430a733f55710113bafd", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=8c6156e1d1f7e46c59fd21c878dccbc4526d7e0c", "patch": "@@ -16,11 +16,11 @@ struct an_enum<'a>(&'a isize);\n struct a_class<'a> { x:&'a isize }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n-    return e; //~^ ERROR mismatched types\n+    return e; //~ ERROR mismatched types\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n-    return e; //~^ ERROR mismatched types\n+    return e; //~ ERROR mismatched types\n }\n \n fn main() { }"}]}