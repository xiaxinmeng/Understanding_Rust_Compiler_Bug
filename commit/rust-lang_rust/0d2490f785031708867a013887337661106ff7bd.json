{"sha": "0d2490f785031708867a013887337661106ff7bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMjQ5MGY3ODUwMzE3MDg4NjdhMDEzODg3MzM3NjYxMTA2ZmY3YmQ=", "commit": {"author": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-09T17:56:11Z"}, "committer": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-17T17:23:05Z"}, "message": "Handle tuple in macro call\n\nOnly tuple name is handled (uncommented), not tuple index", "tree": {"sha": "9d73129182fe13a2f953c86311870b8250819de1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d73129182fe13a2f953c86311870b8250819de1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d2490f785031708867a013887337661106ff7bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEJTdsK5zmAD3L8AFljIMXU7iI9loFAmEb8HkACgkQjIMXU7iI\n9lp1TxAAnDc2DVTPwDSPj7Kd4U3IB38X9h+gBFVviWurinEVlGtHlpu60mot8Etm\nxrrGH2V1Lnp8WBws+28w7bedsFTOu/mJqEyIUQK36wOxnvt4Bwl2J37I64EfFGyF\n5u48aEXWUrauP13wFjOx3o8FRND8n4KGu3z3DTV25OLBrqgw1O+3qsccglbTiOiN\n6Ppun+t0nCYyl9LWihlfcDApf7rb80KrPGuZo+cO+12K4lv86nsz9fgF4+nZOFOQ\nnlWJCdCjOLfT9dic5Ii2zAnV0YLSz2Lx8CCELuvQ5KY9bJztcuQ0BnNDHvABBKDz\npS7Z1FkLlHJpIG6Giv+3ErSlCcGPTIYuG8hV0SKACLTel0412p/Rzfpy2FVlHd7B\nmI1jbqQB+2GZXjYxo7340uc+ZEHh/fAhb1/smPz/eZv7kYzUX7ogKAIpCHjRqzd1\nubmJPqBgFD3HJNN29xKMhf8tC7oULL7qbpKyGvmNbT/F3PeKta+5VbHsQci9Z485\nbJ7gnTD7s74uLqzmrYihtdgTv5/aYJN0noSACSMk+e5ojGUbcLVme8dbh+efsE22\nP6eHBZ6R/yCBL2pJB2XDuxY3xITvh0IP4AA3ycWaQiC1GYe95R0gfZgTJxwbEkEP\nWxmO3jq6GSXj4R1mx3+VYbfnyrMTECViXgtPJZrztSdJ1QtXqeY=\n=Vir1\n-----END PGP SIGNATURE-----", "payload": "tree 9d73129182fe13a2f953c86311870b8250819de1\nparent 450a9c5b122f3807c9dbabcf29e2bd7d40410dc7\nauthor BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1628531771 +0200\ncommitter BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1629220985 +0200\n\nHandle tuple in macro call\n\nOnly tuple name is handled (uncommented), not tuple index\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d2490f785031708867a013887337661106ff7bd", "html_url": "https://github.com/rust-lang/rust/commit/0d2490f785031708867a013887337661106ff7bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d2490f785031708867a013887337661106ff7bd/comments", "author": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "450a9c5b122f3807c9dbabcf29e2bd7d40410dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/450a9c5b122f3807c9dbabcf29e2bd7d40410dc7", "html_url": "https://github.com/rust-lang/rust/commit/450a9c5b122f3807c9dbabcf29e2bd7d40410dc7"}], "stats": {"total": 369, "additions": 326, "deletions": 43}, "files": [{"sha": "5694aa4c9a7edece374877cf115ae89517281e52", "filename": "crates/ide_assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 326, "deletions": 43, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/0d2490f785031708867a013887337661106ff7bd/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2490f785031708867a013887337661106ff7bd/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=0d2490f785031708867a013887337661106ff7bd", "patch": "@@ -4,10 +4,7 @@ use ide_db::{\n     search::{FileReference, SearchScope, UsageSearchResult},\n };\n use itertools::Itertools;\n-use syntax::{\n-    ast::{self, AstNode, FieldExpr, IdentPat, NameOwner},\n-    SyntaxNode, TextRange,\n-};\n+use syntax::{TextRange, ast::{self, AstNode, IdentPat, NameOwner}};\n \n use crate::assist_context::{AssistBuilder, AssistContext, Assists};\n \n@@ -186,7 +183,7 @@ fn edit_tuple_usages(\n     if let Some(usages) = data.usages.as_ref() {\n         for (file_id, refs) in usages.iter() {\n             builder.edit_file(*file_id);\n-    \n+\n             for r in refs {\n                 edit_tuple_usage(r, data, builder, ctx, in_sub_pattern);\n             }\n@@ -200,12 +197,10 @@ fn edit_tuple_usage(\n     _ctx: &AssistContext,\n     in_sub_pattern: bool,\n ) {\n-    match detect_tuple_index(usage.name.syntax(), data) {\n-        Some((expr, idx)) => {\n-            // index field access\n-            let text = &data.field_names[idx];\n-            let range = expr.syntax().text_range();\n-            builder.replace(range, text);\n+    match detect_tuple_index(usage, data) {\n+        Some(index) => {\n+            let text = &data.field_names[index.index];\n+            builder.replace(index.range, text);\n         }\n         None => {\n             if in_sub_pattern {\n@@ -221,7 +216,12 @@ fn edit_tuple_usage(\n     }\n }\n \n-fn detect_tuple_index(usage: &SyntaxNode, data: &TupleData) -> Option<(FieldExpr, usize)> {\n+struct TupleIndex {\n+    index: usize,\n+    range: TextRange,\n+}\n+\n+fn detect_tuple_index(usage: &FileReference, data: &TupleData) -> Option<TupleIndex> {\n     // usage is IDENT\n     // IDENT\n     //  NAME_REF\n@@ -230,7 +230,9 @@ fn detect_tuple_index(usage: &SyntaxNode, data: &TupleData) -> Option<(FieldExpr\n     //     PATH_EXPR\n     //      PAREN_EXRP*\n     //       FIELD_EXPR\n-    let node = usage\n+\n+    let node = \n+        usage.name.syntax()\n         .ancestors()\n         .skip_while(|s| !ast::PathExpr::can_cast(s.kind()))\n         .skip(1) // PATH_EXPR\n@@ -239,7 +241,29 @@ fn detect_tuple_index(usage: &SyntaxNode, data: &TupleData) -> Option<(FieldExpr\n     if let Some(field_expr) = ast::FieldExpr::cast(node) {\n         let idx = field_expr.name_ref()?.as_tuple_field()?;\n         if idx < data.field_names.len() {\n-            Some((field_expr, idx))\n+\n+            // special case: in macro call -> range of `field_expr` in applied macro, NOT range in actual file!\n+            if field_expr.syntax().ancestors().any(|a| ast::MacroStmts::can_cast(a.kind())) {\n+                cov_mark::hit!(destructure_tuple_macro_call);\n+\n+                // issue: cannot differentiate between tuple index passed into macro or tuple index as result of macro:\n+                // ```rust\n+                // macro_rules! m {\n+                //     ($t1:expr, $t2:expr) => { $t1; $t2.0 }\n+                // }\n+                // let t = (1,2);\n+                // m!(t.0, t)\n+                // ```\n+                // -> 2 tuple index usages detected!\n+                //\n+                // -> only handle `t`\n+                return None;\n+            }\n+\n+            Some(TupleIndex {\n+                            index: idx,\n+                            range: field_expr.syntax().text_range(),\n+                        })\n         } else {\n             // tuple index out of range\n             None\n@@ -1030,51 +1054,56 @@ fn main {\n         )\n     }\n \n-    // -----------------------\n-    #[test]\n-    #[ignore]\n-    fn replace_in_macro_call() {\n-        // doesn't work: cannot find usage in `println!`\n-        // Note: Just `t` works, but not `t.0`\n-        check_assist(\n-            assist,\n-            r#\"\n-fn main() {\n-    let $0t = (1,2);\n-    println!(\"{}\", t.0);\n-}\n-            \"#,\n-            r#\"\n-fn main() {\n-    let ($0_0, _1) = (1,2);\n-    println!(\"{}\", _0);\n-}\n-            \"#,\n-        )\n-    }\n-\n-    /// Tests for destructure of tuple in sub-pattern: \n-    /// `let $0t = (1,2);` -> `let t @ (_0, _1) = (1,2);`\n-    mod sub_pattern {\n+    mod assist {\n         use super::*;\n         use crate::tests::check_assist_by_label;\n \n         fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n             destructure_tuple_binding_impl(acc, ctx, true)\n         }\n \n-        fn check_sub_pattern_assist(\n+        pub(crate) fn check_in_place_assist(\n+\n+            ra_fixture_before: &str,\n+            ra_fixture_after: &str,\n+        ) {\n+            check_assist_by_label(\n+                assist, \n+                ra_fixture_before, \n+                ra_fixture_after, \n+                \"Destructure tuple in place\"\n+            );\n+        }\n+\n+        pub(crate) fn check_sub_pattern_assist(\n             ra_fixture_before: &str,\n             ra_fixture_after: &str,\n         ) {\n-            // with sub-pattern there are two assists: One with and one without sub-pattern\n             check_assist_by_label(\n                 assist, \n                 ra_fixture_before, \n                 ra_fixture_after, \n-                \"Destructure tuple in sub-pattern\")\n+                \"Destructure tuple in sub-pattern\"\n+            );\n         }\n \n+        pub(crate) fn check_both_assists(\n+            ra_fixture_before: &str,\n+            ra_fixture_after_in_place: &str,\n+            ra_fixture_after_in_sub_pattern: &str,\n+        ) {\n+            check_in_place_assist(ra_fixture_before, ra_fixture_after_in_place);\n+            check_sub_pattern_assist(ra_fixture_before, ra_fixture_after_in_sub_pattern);\n+        }\n+    }\n+\n+    /// Tests for destructure of tuple in sub-pattern: \n+    /// `let $0t = (1,2);` -> `let t @ (_0, _1) = (1,2);`\n+    mod sub_pattern {\n+        use super::*;\n+        use super::assist::*;\n+        use crate::tests::check_assist_by_label;\n+\n         #[test]\n         fn destructure_in_sub_pattern() {\n             check_sub_pattern_assist(\n@@ -1097,6 +1126,9 @@ fn main() {\n     \n         #[test]\n         fn trigger_both_destructure_tuple_assists() {\n+            fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+                destructure_tuple_binding_impl(acc, ctx, true)\n+            }\n             let text = r#\"\n fn main() {\n     let $0t = (1,2);\n@@ -1259,4 +1291,255 @@ fn main() {\n             )\n         }\n     }\n+\n+    /// Tests for tuple usage in macro call:\n+    /// `dbg!(t.0)`\n+    mod in_macro_call {       \n+        use super::assist::*;\n+\n+\n+        #[test]\n+        fn detect_macro_call() {\n+            cov_mark::check!(destructure_tuple_macro_call);\n+            check_in_place_assist(\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t.0);\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/.0);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_usage() {\n+            check_both_assists(\n+                // leading `\"foo\"` to ensure `$e` doesn't start at position `0`\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t);\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/);\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!(t);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_function_usage() {\n+            check_both_assists(\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t.into());\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/.into());\n+}\n+                \"#,\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!(t.into());\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_index_usage() {\n+            check_both_assists(\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t.0);\n+}\n+                \"#,\n+                // FIXME: replace `t.0` with `_0` (cannot detect range of tuple index in macro call)\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/.0);\n+}\n+                \"#,\n+                // FIXME: replace `t.0` with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!(t.0);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_in_parentheses_index_usage() {\n+            check_both_assists(\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!((t).0);\n+}\n+                \"#,\n+                // FIXME: replace `(t).0` with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!((/*t*/).0);\n+}\n+                \"#,\n+                // FIXME: replace `(t).0` with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($e:expr) => { \"foo\"; $e };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!((t).0);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn empty_macro() {\n+            check_in_place_assist(\n+                r#\"\n+macro_rules! m {\n+    () => { \"foo\" };\n+    ($e:expr) => { $e; \"foo\" };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t);\n+}\n+                \"#,\n+                // FIXME: macro allows no arg -> is valid. But assist should result in invalid code\n+                r#\"\n+macro_rules! m {\n+    () => { \"foo\" };\n+    ($e:expr) => { $e; \"foo\" };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn tuple_index_in_macro() {\n+            check_both_assists(\n+                r#\"\n+macro_rules! m {\n+    ($t:expr, $i:expr) => { $t.0 + $i };\n+}\n+\n+fn main() {\n+    let $0t = (1,2);\n+    m!(t, t.0);\n+}\n+                \"#,\n+                // FIXME: replace `t.0` in macro call (not IN macro) with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($t:expr, $i:expr) => { $t.0 + $i };\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    m!(/*t*/, /*t*/.0);\n+}\n+                \"#,\n+                // FIXME: replace `t.0` in macro call with `_0`\n+                r#\"\n+macro_rules! m {\n+    ($t:expr, $i:expr) => { $t.0 + $i };\n+}\n+\n+fn main() {\n+    let t @ ($0_0, _1) = (1,2);\n+    m!(t, t.0);\n+}\n+                \"#,\n+            )\n+\n+        }\n+    }\n }"}]}