{"sha": "80adfd8de380d3055683e4a042ce845e663b7309", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYWRmZDhkZTM4MGQzMDU1NjgzZTRhMDQyY2U4NDVlNjYzYjczMDk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-18T02:15:06Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-25T06:23:02Z"}, "message": "Account for multiple trait bounds with missing associated types", "tree": {"sha": "5fefcb11b8abd707d88fb80ef3598b8ea9b76895", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fefcb11b8abd707d88fb80ef3598b8ea9b76895"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80adfd8de380d3055683e4a042ce845e663b7309", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80adfd8de380d3055683e4a042ce845e663b7309", "html_url": "https://github.com/rust-lang/rust/commit/80adfd8de380d3055683e4a042ce845e663b7309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80adfd8de380d3055683e4a042ce845e663b7309/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83c5b4ec40ceadfbcf3c558f06e04c48f01c1e52", "url": "https://api.github.com/repos/rust-lang/rust/commits/83c5b4ec40ceadfbcf3c558f06e04c48f01c1e52", "html_url": "https://github.com/rust-lang/rust/commit/83c5b4ec40ceadfbcf3c558f06e04c48f01c1e52"}], "stats": {"total": 513, "additions": 367, "deletions": 146}, "files": [{"sha": "96295e7a326ff8d84598a2a8c6b518930cd7c995", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 191, "deletions": 133, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/80adfd8de380d3055683e4a042ce845e663b7309/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80adfd8de380d3055683e4a042ce845e663b7309/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=80adfd8de380d3055683e4a042ce845e663b7309", "patch": "@@ -1444,59 +1444,68 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         // Use a `BTreeSet` to keep output in a more consistent order.\n-        let mut associated_types = BTreeSet::default();\n+        let mut associated_types: FxHashMap<Span, BTreeSet<DefId>> = FxHashMap::default();\n \n-        let regular_traits_refs = bounds\n+        let regular_traits_refs_spans = bounds\n             .trait_bounds\n             .into_iter()\n-            .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()))\n-            .map(|(trait_ref, _)| trait_ref);\n-        for trait_ref in traits::elaborate_trait_refs(tcx, regular_traits_refs) {\n-            debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", trait_ref);\n-            match trait_ref {\n-                ty::Predicate::Trait(pred) => {\n-                    associated_types.extend(\n-                        tcx.associated_items(pred.def_id())\n-                            .filter(|item| item.kind == ty::AssocKind::Type)\n-                            .map(|item| item.def_id),\n-                    );\n-                }\n-                ty::Predicate::Projection(pred) => {\n-                    // A `Self` within the original bound will be substituted with a\n-                    // `trait_object_dummy_self`, so check for that.\n-                    let references_self = pred.skip_binder().ty.walk().any(|t| t == dummy_self);\n-\n-                    // If the projection output contains `Self`, force the user to\n-                    // elaborate it explicitly to avoid a lot of complexity.\n-                    //\n-                    // The \"classicaly useful\" case is the following:\n-                    // ```\n-                    //     trait MyTrait: FnMut() -> <Self as MyTrait>::MyOutput {\n-                    //         type MyOutput;\n-                    //     }\n-                    // ```\n-                    //\n-                    // Here, the user could theoretically write `dyn MyTrait<Output = X>`,\n-                    // but actually supporting that would \"expand\" to an infinitely-long type\n-                    // `fix $ \u03c4 \u2192 dyn MyTrait<MyOutput = X, Output = <\u03c4 as MyTrait>::MyOutput`.\n-                    //\n-                    // Instead, we force the user to write `dyn MyTrait<MyOutput = X, Output = X>`,\n-                    // which is uglier but works. See the discussion in #56288 for alternatives.\n-                    if !references_self {\n-                        // Include projections defined on supertraits.\n-                        bounds.projection_bounds.push((pred, DUMMY_SP))\n+            .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()));\n+\n+        for (base_trait_ref, span) in regular_traits_refs_spans {\n+            debug!(\"conv_object_ty_poly_trait_ref regular_trait_ref `{:?}`\", base_trait_ref);\n+            let mut new_bounds = vec![];\n+            for trait_ref in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n+                debug!(\n+                    \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n+                    trait_ref\n+                );\n+                match trait_ref {\n+                    ty::Predicate::Trait(pred) => {\n+                        associated_types.entry(span).or_default().extend(\n+                            tcx.associated_items(pred.def_id())\n+                                .filter(|item| item.kind == ty::AssocKind::Type)\n+                                .map(|item| item.def_id),\n+                        );\n                     }\n+                    ty::Predicate::Projection(pred) => {\n+                        // A `Self` within the original bound will be substituted with a\n+                        // `trait_object_dummy_self`, so check for that.\n+                        let references_self = pred.skip_binder().ty.walk().any(|t| t == dummy_self);\n+\n+                        // If the projection output contains `Self`, force the user to\n+                        // elaborate it explicitly to avoid a lot of complexity.\n+                        //\n+                        // The \"classicaly useful\" case is the following:\n+                        // ```\n+                        //     trait MyTrait: FnMut() -> <Self as MyTrait>::MyOutput {\n+                        //         type MyOutput;\n+                        //     }\n+                        // ```\n+                        //\n+                        // Here, the user could theoretically write `dyn MyTrait<Output = X>`,\n+                        // but actually supporting that would \"expand\" to an infinitely-long type\n+                        // `fix $ \u03c4 \u2192 dyn MyTrait<MyOutput = X, Output = <\u03c4 as MyTrait>::MyOutput`.\n+                        //\n+                        // Instead, we force the user to write `dyn MyTrait<MyOutput = X, Output = X>`,\n+                        // which is uglier but works. See the discussion in #56288 for alternatives.\n+                        if !references_self {\n+                            // Include projections defined on supertraits.\n+                            new_bounds.push((pred, span));\n+                        }\n+                    }\n+                    _ => (),\n                 }\n-                _ => (),\n             }\n+            bounds.projection_bounds.extend(new_bounds);\n         }\n \n         for (projection_bound, _) in &bounds.projection_bounds {\n-            associated_types.remove(&projection_bound.projection_def_id());\n+            for (_, def_ids) in &mut associated_types {\n+                def_ids.remove(&projection_bound.projection_def_id());\n+            }\n         }\n \n         self.complain_about_missing_associated_types(\n-            span,\n             associated_types,\n             potential_assoc_types,\n             trait_bounds,\n@@ -1591,134 +1600,183 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     fn complain_about_missing_associated_types(\n         &self,\n-        span: Span,\n-        associated_types: BTreeSet<DefId>,\n+        mut associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n         potential_assoc_types: Vec<Span>,\n         trait_bounds: &[hir::PolyTraitRef],\n     ) {\n-        if associated_types.is_empty() {\n+        if !associated_types.values().any(|v| v.len() > 0) {\n             return;\n         }\n-        // Account for things like `dyn Foo + 'a` by pointing at the `TraitRef.path`\n-        // `Span` instead of the `PolyTraitRef` `Span`. That way the suggestion will\n-        // be valid, otherwise we would suggest `dyn Foo + 'a<A = Type>`. See tests\n-        // `issue-22434.rs` and `issue-22560.rs` for examples.\n-        let sugg_span = match (&potential_assoc_types[..], &trait_bounds) {\n+        let tcx = self.tcx();\n+        let mut names = vec![];\n+\n+        // Account for things like `dyn Foo + 'a`, like in tests `issue-22434.rs` and\n+        // `issue-22560.rs`.\n+        let mut trait_bound_spans: Vec<Span> = vec![];\n+        for (span, item_def_ids) in &associated_types {\n+            if !item_def_ids.is_empty() {\n+                trait_bound_spans.push(*span);\n+            }\n+            for item_def_id in item_def_ids {\n+                let assoc_item = tcx.associated_item(*item_def_id);\n+                let trait_def_id = assoc_item.container.id();\n+                names.push(format!(\n+                    \"`{}` (from trait `{}`)\",\n+                    assoc_item.ident,\n+                    tcx.def_path_str(trait_def_id),\n+                ));\n+            }\n+        }\n+\n+        match (&potential_assoc_types[..], &trait_bounds) {\n             ([], [bound]) => match &bound.trait_ref.path.segments[..] {\n                 // FIXME: `trait_ref.path.span` can point to a full path with multiple\n                 // segments, even though `trait_ref.path.segments` is of length `1`. Work\n                 // around that bug here, even though it should be fixed elsewhere.\n                 // This would otherwise cause an invalid suggestion. For an example, look at\n-                // `src/test/ui/issues/issue-28344.rs`.\n-                [segment] if segment.args.is_none() => segment.ident.span,\n-                _ => bound.trait_ref.path.span,\n+                // `src/test/ui/issues/issue-28344.rs` where instead of the following:\n+                //\n+                //   error[E0191]: the value of the associated type `Output`\n+                //                 (from trait `std::ops::BitXor`) must be specified\n+                //   --> $DIR/issue-28344.rs:4:17\n+                //    |\n+                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n+                //    |                 ^^^^^^ help: specify the associated type:\n+                //    |                              `BitXor<Output = Type>`\n+                //\n+                // we would output:\n+                //\n+                //   error[E0191]: the value of the associated type `Output`\n+                //                 (from trait `std::ops::BitXor`) must be specified\n+                //   --> $DIR/issue-28344.rs:4:17\n+                //    |\n+                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n+                //    |                 ^^^^^^^^^^^^^ help: specify the associated type:\n+                //    |                                     `BitXor::bitor<Output = Type>`\n+                [segment] if segment.args.is_none() => {\n+                    trait_bound_spans = vec![segment.ident.span];\n+                    associated_types = associated_types\n+                        .into_iter()\n+                        .map(|(_, defs)| (segment.ident.span, defs))\n+                        .collect();\n+                }\n+                _ => {}\n             },\n-            _ => span,\n-        };\n-        let tcx = self.tcx();\n-        let names = associated_types\n-            .iter()\n-            .map(|item_def_id| {\n-                let assoc_item = tcx.associated_item(*item_def_id);\n-                let trait_def_id = assoc_item.container.id();\n-                format!(\"`{}` (from trait `{}`)\", assoc_item.ident, tcx.def_path_str(trait_def_id))\n-            })\n-            .collect::<Vec<_>>()\n-            .join(\", \");\n+            _ => {}\n+        }\n         let mut err = struct_span_err!(\n             tcx.sess,\n-            sugg_span,\n+            trait_bound_spans,\n             E0191,\n             \"the value of the associated type{} {} must be specified\",\n-            pluralize!(associated_types.len()),\n-            names,\n+            pluralize!(names.len()),\n+            names.join(\", \"),\n         );\n-        let mut suggestions = Vec::new();\n-        let mut applicability = Applicability::MaybeIncorrect;\n-        for (i, item_def_id) in associated_types.iter().enumerate() {\n-            let assoc_item = tcx.associated_item(*item_def_id);\n-            if let Some(sp) = tcx.hir().span_if_local(*item_def_id) {\n-                err.span_label(sp, format!(\"`{}` defined here\", assoc_item.ident));\n-            }\n-            if potential_assoc_types.len() == associated_types.len() {\n+        let mut suggestions = vec![];\n+        let mut types_count = 0;\n+        let mut where_constraints = vec![];\n+        for (span, def_ids) in &associated_types {\n+            let assoc_items: Vec<_> =\n+                def_ids.iter().map(|def_id| tcx.associated_item(*def_id)).collect();\n+            let mut names: FxHashMap<_, usize> = FxHashMap::default();\n+            for item in &assoc_items {\n+                types_count += 1;\n+                *names.entry(item.ident.name).or_insert(0) += 1;\n+            }\n+            let mut dupes = false;\n+            for item in &assoc_items {\n+                let prefix = if names[&item.ident.name] > 1 {\n+                    let trait_def_id = item.container.id();\n+                    dupes = true;\n+                    format!(\"{}::\", tcx.def_path_str(trait_def_id))\n+                } else {\n+                    String::new()\n+                };\n+                if let Some(sp) = tcx.hir().span_if_local(item.def_id) {\n+                    err.span_label(sp, format!(\"`{}{}` defined here\", prefix, item.ident));\n+                }\n+            }\n+            if potential_assoc_types.len() == assoc_items.len() {\n                 // Only suggest when the amount of missing associated types equals the number of\n                 // extra type arguments present, as that gives us a relatively high confidence\n                 // that the user forgot to give the associtated type's name. The canonical\n                 // example would be trying to use `Iterator<isize>` instead of\n                 // `Iterator<Item = isize>`.\n-                if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(potential_assoc_types[i])\n-                {\n-                    suggestions.push((\n-                        potential_assoc_types[i],\n-                        format!(\"{} = {}\", assoc_item.ident, snippet),\n-                    ));\n+                for (potential, item) in potential_assoc_types.iter().zip(assoc_items.iter()) {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*potential) {\n+                        suggestions.push((*potential, format!(\"{} = {}\", item.ident, snippet)));\n+                    }\n                 }\n-            }\n-        }\n-        let mut suggestions_len = suggestions.len();\n-        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(sugg_span) {\n-            let assoc_types: Vec<String> = associated_types\n-                .iter()\n-                .map(|item_def_id| {\n-                    let assoc_item = tcx.associated_item(*item_def_id);\n-                    format!(\"{} = Type\", assoc_item.ident)\n-                })\n-                .collect();\n-            let dedup = assoc_types.clone().drain(..).collect::<FxHashSet<_>>();\n-\n-            if dedup.len() != assoc_types.len() && trait_bounds.len() == 1 {\n-                // If there are duplicates associated type names and a single trait bound do not\n-                // use structured suggestion, it means that there are multiple super-traits with\n-                // the same associated type name.\n-                err.help(\n-                    \"consider introducing a new type parameter, adding `where` constraints \\\n-                          using the fully-qualified path to the associated type\",\n-                );\n-            } else if dedup.len() == assoc_types.len() &&\n-                potential_assoc_types.is_empty() &&\n-                trait_bounds.len() == 1 &&\n-                // Do not attempt to suggest when we don't know which path segment needs the\n-                // type parameter set.\n-                trait_bounds[0].trait_ref.path.segments.len() == 1\n+            } else if let (Ok(snippet), false) =\n+                (tcx.sess.source_map().span_to_snippet(*span), dupes)\n             {\n-                applicability = Applicability::HasPlaceholders;\n-                let sugg = assoc_types.join(\", \");\n-                if snippet.ends_with('>') {\n+                let types: Vec<_> =\n+                    assoc_items.iter().map(|item| format!(\"{} = Type\", item.ident)).collect();\n+                let code = if snippet.ends_with(\">\") {\n                     // The user wrote `Trait<'a>` or similar and we don't have a type we can\n                     // suggest, but at least we can clue them to the correct syntax\n                     // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the\n                     // suggestion.\n-                    suggestions.push((\n-                        sugg_span,\n-                        format!(\"{}, {}>\", &snippet[..snippet.len() - 1], sugg,),\n-                    ));\n+                    format!(\"{}, {}>\", &snippet[..snippet.len() - 1], types.join(\", \"))\n                 } else {\n                     // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n                     // least we can clue them to the correct syntax `Iterator<Item = Type>`.\n-                    suggestions.push((sugg_span, format!(\"{}<{}>\", snippet, sugg)));\n-                }\n-                suggestions_len = assoc_types.len();\n+                    format!(\"{}<{}>\", snippet, types.join(\", \"))\n+                };\n+                suggestions.push((*span, code));\n+            } else if dupes {\n+                where_constraints.push(*span);\n             }\n         }\n+        let where_msg = \"consider introducing a new type parameter, adding `where` constraints \\\n+                         using the fully-qualified path to the associated types\";\n+        if !where_constraints.is_empty() && suggestions.is_empty() {\n+            // If there are duplicates associated type names and a single trait bound do not\n+            // use structured suggestion, it means that there are multiple super-traits with\n+            // the same associated type name.\n+            err.help(where_msg);\n+        }\n         if suggestions.len() != 1 {\n             // We don't need this label if there's an inline suggestion, show otherwise.\n-            let names = associated_types\n-                .iter()\n-                .map(|t| format!(\"`{}`\", tcx.associated_item(*t).ident))\n-                .collect::<Vec<_>>()\n-                .join(\", \");\n-            err.span_label(\n-                sugg_span,\n-                format!(\n-                    \"associated type{} {} must be specified\",\n-                    pluralize!(associated_types.len()),\n-                    names,\n-                ),\n-            );\n+            for (span, def_ids) in &associated_types {\n+                let assoc_items: Vec<_> =\n+                    def_ids.iter().map(|def_id| tcx.associated_item(*def_id)).collect();\n+                let mut names: FxHashMap<_, usize> = FxHashMap::default();\n+                for item in &assoc_items {\n+                    types_count += 1;\n+                    *names.entry(item.ident.name).or_insert(0) += 1;\n+                }\n+                let mut label = vec![];\n+                for item in &assoc_items {\n+                    let postfix = if names[&item.ident.name] > 1 {\n+                        let trait_def_id = item.container.id();\n+                        format!(\" (from trait `{}`)\", tcx.def_path_str(trait_def_id))\n+                    } else {\n+                        String::new()\n+                    };\n+                    label.push(format!(\"`{}`{}\", item.ident, postfix));\n+                }\n+                if !label.is_empty() {\n+                    err.span_label(\n+                        *span,\n+                        format!(\n+                            \"associated type{} {} must be specified\",\n+                            pluralize!(label.len()),\n+                            label.join(\", \"),\n+                        ),\n+                    );\n+                }\n+            }\n         }\n         if !suggestions.is_empty() {\n-            let msg = format!(\"specify the associated type{}\", pluralize!(suggestions_len));\n-            err.multipart_suggestion(&msg, suggestions, applicability);\n+            err.multipart_suggestion(\n+                &format!(\"specify the associated type{}\", pluralize!(types_count)),\n+                suggestions,\n+                Applicability::HasPlaceholders,\n+            );\n+            if !where_constraints.is_empty() {\n+                err.span_help(where_constraints, where_msg);\n+            }\n         }\n         err.emit();\n     }"}, {"sha": "8eb296d4998afc974a496f3ba6420ca5d196749f", "filename": "src/test/ui/associated-type/associated-type-projection-from-multiple-supertraits.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr?ref=80adfd8de380d3055683e4a042ce845e663b7309", "patch": "@@ -49,15 +49,15 @@ error[E0191]: the value of the associated types `Color` (from trait `Vehicle`),\n   --> $DIR/associated-type-projection-from-multiple-supertraits.rs:23:30\n    |\n LL |     type Color;\n-   |     ----------- `Color` defined here\n+   |     ----------- `Vehicle::Color` defined here\n ...\n LL |     type Color;\n-   |     ----------- `Color` defined here\n+   |     ----------- `Box::Color` defined here\n ...\n LL | fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {\n-   |                              ^^^^^^^^^^^^^^^^^^^ associated types `Color`, `Color` must be specified\n+   |                              ^^^^^^^^^^^^^^^^^^^ associated types `Color` (from trait `Vehicle`), `Color` (from trait `Box`) must be specified\n    |\n-   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated type\n+   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated types\n \n error[E0221]: ambiguous associated type `Color` in bounds of `C`\n   --> $DIR/associated-type-projection-from-multiple-supertraits.rs:28:29\n@@ -84,15 +84,15 @@ error[E0191]: the value of the associated types `Color` (from trait `Vehicle`),\n   --> $DIR/associated-type-projection-from-multiple-supertraits.rs:32:32\n    |\n LL |     type Color;\n-   |     ----------- `Color` defined here\n+   |     ----------- `Vehicle::Color` defined here\n ...\n LL |     type Color;\n-   |     ----------- `Color` defined here\n+   |     ----------- `Box::Color` defined here\n ...\n LL | fn dent_object_2<COLOR>(c: dyn BoxCar) where <dyn BoxCar as Vehicle>::Color = COLOR {\n-   |                                ^^^^^^ associated types `Color`, `Color` must be specified\n+   |                                ^^^^^^ associated types `Color` (from trait `Vehicle`), `Color` (from trait `Box`) must be specified\n    |\n-   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated type\n+   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated types\n \n error: aborting due to 6 previous errors\n "}, {"sha": "3c8410e39bd09d3969f3bef7abdf0778ff1b2439", "filename": "src/test/ui/associated-types/missing-associated-types.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.rs?ref=80adfd8de380d3055683e4a042ce845e663b7309", "patch": "@@ -0,0 +1,27 @@\n+use std::ops::{Add, Sub, Mul, Div};\n+trait X<Rhs>: Mul<Rhs> + Div<Rhs> {}\n+trait Y<Rhs>: Div<Rhs, Output = Rhs> {\n+    type A;\n+}\n+trait Z<Rhs>: Div<Rhs> {\n+    type A;\n+    type B;\n+}\n+trait Fine<Rhs>: Div<Rhs, Output = Rhs> {}\n+\n+type Foo<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Y<Rhs>;\n+//~^ ERROR only auto traits can be used as additional traits in a trait object\n+//~| ERROR the value of the associated types\n+type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n+//~^ ERROR only auto traits can be used as additional traits in a trait object\n+//~| ERROR the value of the associated types\n+type Baz<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Y<Rhs>;\n+//~^ ERROR only auto traits can be used as additional traits in a trait object\n+//~| ERROR the value of the associated types\n+type Bat<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Fine<Rhs>;\n+//~^ ERROR only auto traits can be used as additional traits in a trait object\n+//~| ERROR the value of the associated types\n+type Bal<Rhs> = dyn X<Rhs>;\n+//~^ ERROR the value of the associated types\n+\n+fn main() {}"}, {"sha": "7be266388177ae2abfd7131c5bff59911483d4a2", "filename": "src/test/ui/associated-types/missing-associated-types.stderr", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr?ref=80adfd8de380d3055683e4a042ce845e663b7309", "patch": "@@ -0,0 +1,129 @@\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/missing-associated-types.rs:12:32\n+   |\n+LL | type Foo<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Y<Rhs>;\n+   |                     --------   ^^^^^^^^\n+   |                     |          |\n+   |                     |          additional non-auto trait\n+   |                     |          trait alias used in trait object type (additional use)\n+   |                     first non-auto trait\n+   |                     trait alias used in trait object type (first use)\n+\n+error[E0191]: the value of the associated types `A` (from trait `Y`), `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Add`), `Output` (from trait `std::ops::Sub`) must be specified\n+  --> $DIR/missing-associated-types.rs:12:52\n+   |\n+LL |     type A;\n+   |     ------- `A` defined here\n+...\n+LL | type Foo<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Y<Rhs>;\n+   |                     ^^^^^^^^   ^^^^^^^^   ^^^^^^   ^^^^^^ associated type `A` must be specified\n+   |                     |          |          |\n+   |                     |          |          associated type `Output` must be specified\n+   |                     |          associated type `Output` must be specified\n+   |                     associated type `Output` must be specified\n+   |\n+help: specify the associated types\n+   |\n+LL | type Foo<Rhs> = dyn Add<Rhs, Output = Type> + Sub<Rhs, Output = Type> + X<Rhs, Output = Type> + Y<Rhs, A = Type>;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/missing-associated-types.rs:15:32\n+   |\n+LL | type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n+   |                     --------   ^^^^^^^^\n+   |                     |          |\n+   |                     |          additional non-auto trait\n+   |                     |          trait alias used in trait object type (additional use)\n+   |                     first non-auto trait\n+   |                     trait alias used in trait object type (first use)\n+\n+error[E0191]: the value of the associated types `Output` (from trait `std::ops::Add`), `Output` (from trait `std::ops::Sub`), `A` (from trait `Z`), `B` (from trait `Z`), `Output` (from trait `std::ops::Div`), `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Div`) must be specified\n+  --> $DIR/missing-associated-types.rs:15:21\n+   |\n+LL |     type A;\n+   |     ------- `A` defined here\n+LL |     type B;\n+   |     ------- `B` defined here\n+...\n+LL | type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n+   |                     ^^^^^^^^   ^^^^^^^^   ^^^^^^   ^^^^^^ associated types `A`, `B`, `Output` must be specified\n+   |                     |          |          |\n+   |                     |          |          associated types `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Div`) must be specified\n+   |                     |          associated type `Output` must be specified\n+   |                     associated type `Output` must be specified\n+   |\n+help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated types\n+  --> $DIR/missing-associated-types.rs:15:43\n+   |\n+LL | type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n+   |                                           ^^^^^^\n+help: specify the associated types\n+   |\n+LL | type Bar<Rhs> = dyn Add<Rhs, Output = Type> + Sub<Rhs, Output = Type> + X<Rhs> + Z<Rhs, A = Type, B = Type, Output = Type>;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/missing-associated-types.rs:18:32\n+   |\n+LL | type Baz<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Y<Rhs>;\n+   |                     --------   ^^^^^^^^\n+   |                     |          |\n+   |                     |          additional non-auto trait\n+   |                     |          trait alias used in trait object type (additional use)\n+   |                     first non-auto trait\n+   |                     trait alias used in trait object type (first use)\n+\n+error[E0191]: the value of the associated types `Output` (from trait `std::ops::Sub`), `A` (from trait `Y`), `Output` (from trait `std::ops::Add`) must be specified\n+  --> $DIR/missing-associated-types.rs:18:32\n+   |\n+LL |     type A;\n+   |     ------- `A` defined here\n+...\n+LL | type Baz<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Y<Rhs>;\n+   |                     ^^^^^^^^   ^^^^^^^^   ^^^^^^ associated type `A` must be specified\n+   |                     |          |\n+   |                     |          associated type `Output` must be specified\n+   |                     associated type `Output` must be specified\n+   |\n+help: specify the associated types\n+   |\n+LL | type Baz<Rhs> = dyn Add<Rhs, Output = Type> + Sub<Rhs, Output = Type> + Y<Rhs, A = Type>;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/missing-associated-types.rs:21:32\n+   |\n+LL | type Bat<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Fine<Rhs>;\n+   |                     --------   ^^^^^^^^\n+   |                     |          |\n+   |                     |          additional non-auto trait\n+   |                     |          trait alias used in trait object type (additional use)\n+   |                     first non-auto trait\n+   |                     trait alias used in trait object type (first use)\n+\n+error[E0191]: the value of the associated types `Output` (from trait `std::ops::Sub`), `Output` (from trait `std::ops::Add`) must be specified\n+  --> $DIR/missing-associated-types.rs:21:32\n+   |\n+LL | type Bat<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Fine<Rhs>;\n+   |                     ^^^^^^^^   ^^^^^^^^ associated type `Output` must be specified\n+   |                     |\n+   |                     associated type `Output` must be specified\n+   |\n+help: specify the associated types\n+   |\n+LL | type Bat<Rhs> = dyn Add<Rhs, Output = Type> + Sub<Rhs, Output = Type> + Fine<Rhs>;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0191]: the value of the associated types `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Div`) must be specified\n+  --> $DIR/missing-associated-types.rs:24:21\n+   |\n+LL | type Bal<Rhs> = dyn X<Rhs>;\n+   |                     ^^^^^^ associated types `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Div`) must be specified\n+   |\n+   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated types\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors have detailed explanations: E0191, E0225.\n+For more information about an error, try `rustc --explain E0191`."}, {"sha": "bf80b24fa563e319325e7f9a26765f08357fd881", "filename": "src/test/ui/issues/issue-22560.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr?ref=80adfd8de380d3055683e4a042ce845e663b7309", "patch": "@@ -35,8 +35,8 @@ LL | type Test = dyn Add + Sub;\n    |                 first non-auto trait\n    |                 trait alias used in trait object type (first use)\n \n-error[E0191]: the value of the associated types `Output` (from trait `Add`), `Output` (from trait `Sub`) must be specified\n-  --> $DIR/issue-22560.rs:9:13\n+error[E0191]: the value of the associated types `Output` (from trait `Sub`), `Output` (from trait `Add`) must be specified\n+  --> $DIR/issue-22560.rs:9:23\n    |\n LL |     type Output;\n    |     ------------ `Output` defined here\n@@ -45,7 +45,14 @@ LL |     type Output;\n    |     ------------ `Output` defined here\n ...\n LL | type Test = dyn Add + Sub;\n-   |             ^^^^^^^^^^^^^ associated types `Output`, `Output` must be specified\n+   |                 ^^^   ^^^ associated type `Output` must be specified\n+   |                 |\n+   |                 associated type `Output` must be specified\n+   |\n+help: specify the associated types\n+   |\n+LL | type Test = dyn Add<Output = Type> + Sub<Output = Type>;\n+   |                 ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "58a73187fb158200c11fcef49972e343dcb610a9", "filename": "src/test/ui/suggestions/use-type-argument-instead-of-assoc-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80adfd8de380d3055683e4a042ce845e663b7309/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr?ref=80adfd8de380d3055683e4a042ce845e663b7309", "patch": "@@ -7,7 +7,7 @@ LL |     i: Box<dyn T<usize, usize, usize, usize, B=usize>>,\n    |                                unexpected type argument\n \n error[E0191]: the value of the associated types `A` (from trait `T`), `C` (from trait `T`) must be specified\n-  --> $DIR/use-type-argument-instead-of-assoc-type.rs:7:12\n+  --> $DIR/use-type-argument-instead-of-assoc-type.rs:7:16\n    |\n LL |     type A;\n    |     ------- `A` defined here\n@@ -16,7 +16,7 @@ LL |     type C;\n    |     ------- `C` defined here\n ...\n LL |     i: Box<dyn T<usize, usize, usize, usize, B=usize>>,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ associated types `A`, `C` must be specified\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ associated types `A`, `C` must be specified\n    |\n help: specify the associated types\n    |"}]}