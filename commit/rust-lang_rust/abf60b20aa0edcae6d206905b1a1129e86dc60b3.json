{"sha": "abf60b20aa0edcae6d206905b1a1129e86dc60b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZjYwYjIwYWEwZWRjYWU2ZDIwNjkwNWIxYTExMjllODZkYzYwYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-19T23:21:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-19T23:21:12Z"}, "message": "Auto merge of #30430 - mmcco:master, r=alexcrichton\n\nRust already supports Linux's getrandom(2), which is very similar and\nwas based on getentropy(2). This is a pretty clean, simple addition that\nuses the same approach as the iOS randomness API support.", "tree": {"sha": "21d853d07db83ace8f209292e0e67ae082976236", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21d853d07db83ace8f209292e0e67ae082976236"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abf60b20aa0edcae6d206905b1a1129e86dc60b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abf60b20aa0edcae6d206905b1a1129e86dc60b3", "html_url": "https://github.com/rust-lang/rust/commit/abf60b20aa0edcae6d206905b1a1129e86dc60b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abf60b20aa0edcae6d206905b1a1129e86dc60b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cef0d0f9a88e241423c30ae89a0f66aade257391", "url": "https://api.github.com/repos/rust-lang/rust/commits/cef0d0f9a88e241423c30ae89a0f66aade257391", "html_url": "https://github.com/rust-lang/rust/commit/cef0d0f9a88e241423c30ae89a0f66aade257391"}, {"sha": "9fde3e9b94e19426a319af33b330a5cb87340c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fde3e9b94e19426a319af33b330a5cb87340c46", "html_url": "https://github.com/rust-lang/rust/commit/9fde3e9b94e19426a319af33b330a5cb87340c46"}], "stats": {"total": 65, "additions": 63, "deletions": 2}, "files": [{"sha": "4b9b07c71997da23d5d1e3035cd16a5855b94ecc", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=abf60b20aa0edcae6d206905b1a1129e86dc60b3", "patch": "@@ -1 +1 @@\n-Subproject commit 9863d5645fc4d1be789d03bcf58c1b3cfafbba39\n+Subproject commit 4b9b07c71997da23d5d1e3035cd16a5855b94ecc"}, {"sha": "21e60420c186adb48a19058884006bcd763f2455", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf60b20aa0edcae6d206905b1a1129e86dc60b3/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf60b20aa0edcae6d206905b1a1129e86dc60b3/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=abf60b20aa0edcae6d206905b1a1129e86dc60b3", "patch": "@@ -47,6 +47,7 @@\n //!     if the entropy pool is very small, such as immediately after first booting.\n //!     Linux 3.17 added the `getrandom(2)` system call which solves the issue: it blocks if entropy\n //!     pool is not initialized yet, but it does not block once initialized.\n+//!     `getrandom(2)` was based on `getentropy(2)`, an existing system call in OpenBSD.\n //!     `OsRng` tries to use `getrandom(2)` if available, and use `/dev/urandom` fallback if not.\n //!     If an application does not have `getrandom` and likely to be run soon after first booting,\n //!     or on a system with very few entropy sources, one should consider using `/dev/random` via"}, {"sha": "13965ce810ddc1bbd37a1db10975aa75e61dd526", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/abf60b20aa0edcae6d206905b1a1129e86dc60b3/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf60b20aa0edcae6d206905b1a1129e86dc60b3/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=abf60b20aa0edcae6d206905b1a1129e86dc60b3", "patch": "@@ -13,7 +13,7 @@\n \n pub use self::imp::OsRng;\n \n-#[cfg(all(unix, not(target_os = \"ios\")))]\n+#[cfg(all(unix, not(target_os = \"ios\"), not(target_os = \"openbsd\")))]\n mod imp {\n     use self::OsRngInner::*;\n \n@@ -131,6 +131,7 @@ mod imp {\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n     /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n+    /// - OpenBSD: uses the `getentropy(2)` system call.\n     ///\n     /// This does not block.\n     pub struct OsRng {\n@@ -178,6 +179,63 @@ mod imp {\n     }\n }\n \n+#[cfg(target_os = \"openbsd\")]\n+mod imp {\n+    use io;\n+    use mem;\n+    use libc::c_long;\n+    use sys::os::errno;\n+    use rand::Rng;\n+\n+    /// A random number generator that retrieves randomness straight from\n+    /// the operating system. Platform sources:\n+    ///\n+    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n+    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+    ///   service provider with the `PROV_RSA_FULL` type.\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n+    /// - OpenBSD: uses the `getentropy(2)` system call.\n+    ///\n+    /// This does not block.\n+    pub struct OsRng {\n+        // dummy field to ensure that this struct cannot be constructed outside\n+        // of this module\n+        _dummy: (),\n+    }\n+\n+    impl OsRng {\n+        /// Create a new `OsRng`.\n+        pub fn new() -> io::Result<OsRng> {\n+            Ok(OsRng { _dummy: () })\n+        }\n+    }\n+\n+    impl Rng for OsRng {\n+        fn next_u32(&mut self) -> u32 {\n+            let mut v = [0; 4];\n+            self.fill_bytes(&mut v);\n+            unsafe { mem::transmute(v) }\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            let mut v = [0; 8];\n+            self.fill_bytes(&mut v);\n+            unsafe { mem::transmute(v) }\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            // getentropy(2) permits a maximum buffer size of 256 bytes\n+            for s in v.chunks_mut(256) {\n+                let ret = unsafe {\n+                    libc::syscall(libc::NR_GETENTROPY, s.as_mut_ptr(), s.len())\n+                };\n+                if ret == -1 {\n+                    panic!(\"unexpected getentropy error: {}\", errno());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(target_os = \"ios\")]\n mod imp {\n     #[cfg(stage0)] use prelude::v1::*;\n@@ -196,6 +254,7 @@ mod imp {\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n     /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n+    /// - OpenBSD: uses the `getentropy(2)` system call.\n     ///\n     /// This does not block.\n     pub struct OsRng {\n@@ -261,6 +320,7 @@ mod imp {\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n     /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n+    /// - OpenBSD: uses the `getentropy(2)` system call.\n     ///\n     /// This does not block.\n     pub struct OsRng {"}]}