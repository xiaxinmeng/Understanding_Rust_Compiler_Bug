{"sha": "fd95db25b367d5d61ee9bc86b928c529747b3622", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkOTVkYjI1YjM2N2Q1ZDYxZWU5YmM4NmI5MjhjNTI5NzQ3YjM2MjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-05T15:42:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-05T15:42:13Z"}, "message": "Merge remote-tracking branch 'origin/master' into proc_macro_api", "tree": {"sha": "f93755558c3f91addb568e1f5aa4f2a4799589f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f93755558c3f91addb568e1f5aa4f2a4799589f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd95db25b367d5d61ee9bc86b928c529747b3622", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd95db25b367d5d61ee9bc86b928c529747b3622", "html_url": "https://github.com/rust-lang/rust/commit/fd95db25b367d5d61ee9bc86b928c529747b3622", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd95db25b367d5d61ee9bc86b928c529747b3622/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d316874c87e25669895c306658e15aa3746d66ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/d316874c87e25669895c306658e15aa3746d66ab", "html_url": "https://github.com/rust-lang/rust/commit/d316874c87e25669895c306658e15aa3746d66ab"}, {"sha": "692b5722363be2de18a27b46db59950124a5101d", "url": "https://api.github.com/repos/rust-lang/rust/commits/692b5722363be2de18a27b46db59950124a5101d", "html_url": "https://github.com/rust-lang/rust/commit/692b5722363be2de18a27b46db59950124a5101d"}], "stats": {"total": 10170, "additions": 6479, "deletions": 3691}, "files": [{"sha": "b54bab177d0aeb8b78f816b02b4bcb9c4afc0efe", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -51,6 +51,7 @@\n .hg/\n .hgignore\n .idea\n+*.iml\n __pycache__/\n *.py[cod]\n *$py.class"}, {"sha": "21877ecb43e105b6e99dfd1dd7fc8a55ce81133d", "filename": ".travis.yml", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -171,16 +171,22 @@ before_script:\n       if [[ \"$SKIP_BUILD\" == true ]]; then\n           export RUN_SCRIPT=\"echo 'skipping, not a full build'\";\n       else\n-          RUN_SCRIPT=\"stamp src/ci/init_repo.sh . $HOME/rustsrc\";\n+          RUN_SCRIPT=\"src/ci/init_repo.sh . $HOME/rustsrc\";\n           if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-              export RUN_SCRIPT=\"$RUN_SCRIPT && stamp src/ci/run.sh\";\n+              export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/run.sh\";\n           else\n-              export RUN_SCRIPT=\"$RUN_SCRIPT && stamp src/ci/docker/run.sh $IMAGE\";\n+              export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/docker/run.sh $IMAGE\";\n           fi\n       fi\n \n+# Log time information from this machine and an external machine for insight into possible\n+# clock drift. Timezones don't matter since relative deltas give all the necessary info.\n script:\n-  - sh -x -c \"$RUN_SCRIPT\"\n+  - >\n+      date && curl -s --head https://google.com | grep ^Date: | sed 's/Date: //g'\n+  - stamp sh -x -c \"$RUN_SCRIPT\"\n+  - >\n+      date && curl -s --head https://google.com | grep ^Date: | sed 's/Date: //g'\n \n after_success:\n   - >"}, {"sha": "a1f018610753c801c34e0ab0f96a6f7d261b9590", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -40,8 +40,9 @@ Read [\"Installation\"] from [The Book].\n \n     > ***Note:*** Install locations can be adjusted by copying the config file\n     > from `./src/bootstrap/config.toml.example` to `./config.toml`, and\n-    > adjusting the `prefix` option under `[install]`. Various other options are\n-    > also supported, and are documented in the config file.\n+    > adjusting the `prefix` option under `[install]`. Various other options, such\n+    > as enabling debug information, are also supported, and are documented in\n+    > the config file.\n \n     When complete, `sudo ./x.py install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the"}, {"sha": "dc94ee27e930d93265e9c9e6842d347841bb203c", "filename": "src/Cargo.lock", "status": "modified", "additions": 78, "deletions": 82, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -129,7 +129,7 @@ dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -157,7 +157,7 @@ dependencies = [\n [[package]]\n name = \"cargo\"\n version = \"0.21.0\"\n-source = \"git+https://github.com/rust-lang/cargo#50b1c24d146fa072db71f12005deed319ac5ba9a\"\n+source = \"git+https://github.com/rust-lang/cargo#eb6cf012a6cc23c9c89c4009564de9fccc38b9cb\"\n replace = \"cargo 0.21.0\"\n \n [[package]]\n@@ -170,8 +170,8 @@ dependencies = [\n  \"cargotest 0.1.0\",\n  \"crates-io 0.10.0\",\n  \"crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"docopt 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"docopt 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -188,7 +188,7 @@ dependencies = [\n  \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -201,8 +201,8 @@ dependencies = [\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -224,7 +224,7 @@ dependencies = [\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -301,12 +301,12 @@ dependencies = [\n name = \"crates-io\"\n version = \"0.10.0\"\n dependencies = [\n- \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -316,19 +316,20 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.6\"\n+version = \"0.4.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"curl-sys 0.3.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"socket2 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.3.12\"\n+version = \"0.3.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -365,7 +366,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"docopt\"\n-version = \"0.8.0\"\n+version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -474,18 +475,18 @@ dependencies = [\n  \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"git2-curl\"\n version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -575,14 +576,14 @@ dependencies = [\n \n [[package]]\n name = \"languageserver-types\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -609,7 +610,7 @@ version = \"0.6.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"curl-sys 0.3.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -798,7 +799,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"num_cpus\"\n-version = \"1.5.1\"\n+version = \"1.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -936,11 +937,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"racer\"\n-version = \"2.0.8\"\n+version = \"2.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"clap 2.24.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -984,7 +986,7 @@ dependencies = [\n  \"aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_local 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1013,39 +1015,30 @@ dependencies = [\n  \"cargo 0.21.0 (git+https://github.com/rust-lang/cargo)\",\n  \"derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"languageserver-types 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"languageserver-types 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"racer 2.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-analysis 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-analysis 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-vfs 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-nightly 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-vfs 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-nightly 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-analysis\"\n-version = \"0.3.2\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"rls-data\"\n-version = \"0.4.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n+ \"rls-data 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1071,10 +1064,10 @@ dependencies = [\n \n [[package]]\n name = \"rls-vfs\"\n-version = \"0.4.2\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"racer 2.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1396,6 +1389,7 @@ dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -1463,7 +1457,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"0.1.3\"\n+version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1477,8 +1471,8 @@ dependencies = [\n  \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1579,6 +1573,18 @@ name = \"shell-escape\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"socket2\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"stable_deref_trait\"\n version = \"1.0.0\"\n@@ -1697,7 +1703,7 @@ dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1720,7 +1726,7 @@ dependencies = [\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1748,7 +1754,7 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"term\"\n-version = \"0.4.5\"\n+version = \"0.4.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1790,15 +1796,6 @@ dependencies = [\n  \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"thread-id\"\n-version = \"3.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"thread_local\"\n version = \"0.2.7\"\n@@ -1809,11 +1806,11 @@ dependencies = [\n \n [[package]]\n name = \"thread_local\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"thread-id 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1846,7 +1843,7 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.4.1\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1892,7 +1889,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"unreachable\"\n-version = \"0.1.1\"\n+version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1907,7 +1904,7 @@ dependencies = [\n \n [[package]]\n name = \"url\"\n-version = \"1.5.0\"\n+version = \"1.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"idna 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1921,7 +1918,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2026,12 +2023,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum clap 2.24.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6b8f69e518f967224e628896b54e41ff6acfb4dcfefc5076325c36525dac900f\"\n \"checksum cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8ebbb35d3dc9cd09497168f33de1acb79b265d350ab0ac34133b98f8509af1f\"\n \"checksum crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c5ea215664ca264da8a9d9c3be80d2eaf30923c259d03e870388eb927508f97\"\n-\"checksum curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c90e1240ef340dd4027ade439e5c7c2064dd9dc652682117bd50d1486a3add7b\"\n-\"checksum curl-sys 0.3.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f00c8ba847fb0730c293069b4d1203dc01bf3c2e1f90b4e55f426ed8f4a1eeac\"\n+\"checksum curl 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6689276ab61f97c660669a5ecc117c36875dfc1ba301c986b16c653415bdf9d7\"\n+\"checksum curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d5481162dc4f424d088581db2f979fa7d4c238fe9794595de61d8d7522e277de\"\n \"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n \"checksum derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"41be6ca3b99e0c0483fb2389685448f650459c3ecbe4e18d7705d8010ec4ab8e\"\n \"checksum diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a515461b6c8c08419850ced27bc29e86166dcdcde8fbe76f8b1f0589bb49472\"\n-\"checksum docopt 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"63e408eee8a772c5c61f62353992e3ebf51ef5c832dd04d986b3dc7d48c5b440\"\n+\"checksum docopt 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b5b93718f8b3e5544fcc914c43de828ca6c6ace23e0332c6080a2977b49787a\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n \"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n@@ -2053,7 +2050,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n \"checksum jobserver 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e28adc987f6d0521ef66ad60b055968107b164b3bb3cf3dc8474e0a380474a6\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum languageserver-types 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97c2985bfcbbcb0189cfa25e1c10c1ac7111df2b6214b652c690127aefdf4e5b\"\n+\"checksum languageserver-types 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c178b944c3187527293fb9f8a0b0db3c5fb62eb127cacd65296f651a2440f5b1\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n \"checksum libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f5c2b18a287cf78b4097db62e20f43cace381dc76ae5c0a3073067f78b7ddc\"\n \"checksum libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df18a822100352d9863b302faf6f8f25c0e77f0e60feb40e5dbe1238b7f13b1d\"\n@@ -2075,7 +2072,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum num-iter 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7d1891bd7b936f12349b7d1403761c8a0b85a18b148e9da4429d5d102c1a41e\"\n \"checksum num-rational 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"33c881e104a26e1accc09449374c095ff2312c8e0c27fab7bbefe16eac7c776d\"\n \"checksum num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1708c0628602a98b52fad936cf3edb9a107af06e52e49fdf0707e884456a6af6\"\n-\"checksum num_cpus 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6e416ba127a4bb3ff398cb19546a8d0414f73352efe2857f4060d36f5fe5983a\"\n+\"checksum num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aec53c34f2d0247c5ca5d32cca1478762f301740468ee9ee6dcb7a0dd7a0c584\"\n \"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n \"checksum openssl 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11ba043cb65fc9af71a431b8a36ffe8686cd4751cdf70a473ec1d01066ac7e41\"\n \"checksum openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d98df0270d404ccd3c050a41d579c52d1db15375168bb3471e04ec0f5f378daf\"\n@@ -2090,20 +2087,19 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c36987d4978eb1be2e422b1e0423a557923a5c3e7e6f31d5699e9aafaefa469\"\n \"checksum quote 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c5cf478fe1006dbcc72567121d23dbdae5f1632386068c5c86ff4f645628504\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n-\"checksum racer 2.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"edf2dfc188373ef96168bec3646a0415c5c21111c6144c0c36104fc720587ecd\"\n+\"checksum racer 2.0.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9079a128fdb6f0c8850010e1478b215d4c00134654bf995bfda41824951ce9bd\"\n \"checksum rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"022e0636ec2519ddae48154b028864bdce4eaf7d35226ab8e65c611be97b189d\"\n \"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n-\"checksum rls-analysis 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d77d58e8933752142b5b92e3f8ba6d6f1630be6da5627c492268a43f79ffbda\"\n-\"checksum rls-data 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"374a8fad31cc0681a7bfd8a04079dd4afd0e981d34e18a171b1a467445bdf51e\"\n+\"checksum rls-analysis 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"78a05b130793ebc781c2d933299d7214a10d014fdebe5184eb652c81ba8d3184\"\n \"checksum rls-data 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e502ac679bc35e023e982506c32d0278ef89e29af1e4ad21cb70c44b525b87a9\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n-\"checksum rls-vfs 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ace07060dd154731b39254864245cbdd33c8f5f64fe1f630a089c72e2468f854\"\n+\"checksum rls-vfs 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f19246a0fda45f2fb6eb34addef2a692c044cbf1c90ec7695583450fb5f23e7\"\n \"checksum rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3058a43ada2c2d0b92b3ae38007a2d0fa5e9db971be260e0171408a4ff471c95\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum rustfmt-nightly 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"277deb9c0ee9c4788ee94faef5988fa334179cd7363bf281a2cae027edbbc8bf\"\n+\"checksum rustfmt-nightly 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31ac6fe40a9844ee2de3d51d0be2bbcdb361bad6f3667a02db8c4e2330afbbb5\"\n \"checksum same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d931a44fdaa43b8637009e7632a02adc4f2b2e0733c08caa4cf00e8da4a117a7\"\n \"checksum scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f417c22df063e9450888a7561788e9bd46d3bb3c1466435b4eccb903807f147d\"\n \"checksum semver 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fdd61b85a0fa777f7fb7c454b9189b2941b110d1385ce84d7f76efdf1606a85\"\n@@ -2116,6 +2112,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum serde_json 0.9.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad8bcf487be7d2e15d3d543f04312de991d631cfe1b43ea0ade69e6a8a5b16a1\"\n \"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n \"checksum shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd5cc96481d54583947bfe88bf30c23d53f883c6cd0145368b69989d97b84ef8\"\n+\"checksum socket2 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"12cdbddbaa27bf94cc194b8e37f5811db6fe83cea96cf99cf1f8e92b65a41371\"\n \"checksum stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15132e0e364248108c5e2c02e3ab539be8d6f5d52a01ca9bbf27ed657316f02b\"\n \"checksum strings 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"da75d8bf2c4d210d63dd09581a041b036001f9f6e03d9b151dbff810fb7ba26a\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n@@ -2127,26 +2124,25 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum syntex_syntax 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76a302e717e348aa372ff577791c3832395650073b8d8432f8b3cb170b34afde\"\n \"checksum tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"281285b717926caa919ad905ef89c63d75805c7d89437fb873100925a53f2b1b\"\n \"checksum tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"87974a6f5c1dfb344d733055601650059a3363de2a6104819293baff662132d6\"\n-\"checksum term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d168af3930b369cfe245132550579d47dfd873d69470755a19c2c6568dbbd989\"\n+\"checksum term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1\"\n \"checksum term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2b6b55df3198cc93372e85dd2ed817f0e38ce8cc0f22eb32391bfad9c4bf209\"\n \"checksum termcolor 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a5193a56b8d82014662c4b933dea6bec851daf018a2b01722e007daaf5f9dca\"\n \"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n-\"checksum thread-id 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8df7875b676fddfadffd96deea3b1124e5ede707d4884248931077518cf1f773\"\n \"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n-\"checksum thread_local 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c85048c6260d17cf486ceae3282d9fb6b90be220bf5b28c400f5485ffc29f0c7\"\n+\"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n \"checksum toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"736b60249cb25337bc196faa43ee12c705e426f3d55c214d73a4e7be06f92cb4\"\n \"checksum toml 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bd86ad9ebee246fdedd610e0f6d0587b754a3d81438db930a244d0480ed7878f\"\n-\"checksum toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4cc5dbfb20a481e64b99eb7ae280859ec76730c7191570ba5edaa962394edb0a\"\n+\"checksum toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0601da6c97135c8d330c7a13a013ca6cd4143221b01de2f8d4edc50a9e551c7\"\n \"checksum typed-arena 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5934776c3ac1bea4a9d56620d6bf2d483b20d394e49581db40f187e1118ff667\"\n \"checksum unicode-bidi 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a6a2c4e3710edd365cd7e78383153ed739fa31af19f9172f72d3575060f5a43a\"\n \"checksum unicode-normalization 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51ccda9ef9efa3f7ef5d91e8f9b83bbe6955f9bf86aec89d5cce2c874625920f\"\n \"checksum unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a8083c594e02b8ae1654ae26f0ade5158b119bd88ad0e8227a5d8fcd72407946\"\n \"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f\"\n \"checksum unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36dff09cafb4ec7c8cf0023eb0b686cb6ce65499116a12201c9e11840ca01beb\"\n \"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n-\"checksum unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f2ae5ddb18e1c92664717616dd9549dde73f539f01bd7b77c2edb2446bdff91\"\n-\"checksum url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a69a2e36a5e5ed3f3063c8c64a3b028c4d50d689fa6c862abd7cfe65f882595c\"\n+\"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n+\"checksum url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eeb819346883532a271eb626deb43c4a1bb4c4dd47c519bd78137c3e72a4fe27\"\n \"checksum url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n \"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\""}, {"sha": "7232208b52234d278caf2a5d001ca04ee8261d8a", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -75,16 +75,11 @@ fn main() {\n         Err(_) => 0,\n     };\n \n-    // Build scripts always use the snapshot compiler which is guaranteed to be\n-    // able to produce an executable, whereas intermediate compilers may not\n-    // have the standard library built yet and may not be able to produce an\n-    // executable. Otherwise we just use the standard compiler we're\n-    // bootstrapping with.\n-    //\n-    // Also note that cargo will detect the version of the compiler to trigger\n-    // a rebuild when the compiler changes. If this happens, we want to make\n-    // sure to use the actual compiler instead of the snapshot compiler becase\n-    // that's the one that's actually changing.\n+    // Use a different compiler for build scripts, since there may not yet be a\n+    // libstd for the real compiler to use. However, if Cargo is attempting to\n+    // determine the version of the compiler, the real compiler needs to be\n+    // used. Currently, these two states are differentiated based on whether\n+    // --target and -vV is/isn't passed.\n     let (rustc, libdir) = if target.is_none() && version.is_none() {\n         (\"RUSTC_SNAPSHOT\", \"RUSTC_SNAPSHOT_LIBDIR\")\n     } else {"}, {"sha": "eaf2a40f2fad4fb3f6eed800a17d10b17708937b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -25,10 +25,11 @@\n \n \n def get(url, path, verbose=False):\n-    sha_url = url + \".sha256\"\n+    suffix = '.sha256'\n+    sha_url = url + suffix\n     with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n         temp_path = temp_file.name\n-    with tempfile.NamedTemporaryFile(suffix=\".sha256\", delete=False) as sha_file:\n+    with tempfile.NamedTemporaryFile(suffix=suffix, delete=False) as sha_file:\n         sha_path = sha_file.name\n \n     try:\n@@ -55,6 +56,7 @@ def get(url, path, verbose=False):\n \n \n def delete_if_present(path, verbose):\n+    \"\"\"Remove the given file if present\"\"\"\n     if os.path.isfile(path):\n         if verbose:\n             print(\"removing \" + path)\n@@ -92,12 +94,13 @@ def _download(path, url, probably_big, verbose, exception):\n \n \n def verify(path, sha_path, verbose):\n+    \"\"\"Check if the sha256 sum of the given path is valid\"\"\"\n     if verbose:\n         print(\"verifying \" + path)\n-    with open(path, \"rb\") as f:\n-        found = hashlib.sha256(f.read()).hexdigest()\n-    with open(sha_path, \"r\") as f:\n-        expected = f.readline().split()[0]\n+    with open(path, \"rb\") as source:\n+        found = hashlib.sha256(source.read()).hexdigest()\n+    with open(sha_path, \"r\") as sha256sum:\n+        expected = sha256sum.readline().split()[0]\n     verified = found == expected\n     if not verified:\n         print(\"invalid checksum:\\n\"\n@@ -107,6 +110,7 @@ def verify(path, sha_path, verbose):\n \n \n def unpack(tarball, dst, verbose=False, match=None):\n+    \"\"\"Unpack the given tarball file\"\"\"\n     print(\"extracting \" + tarball)\n     fname = os.path.basename(tarball).replace(\".tar.gz\", \"\")\n     with contextlib.closing(tarfile.open(tarball)) as tar:\n@@ -128,6 +132,7 @@ def unpack(tarball, dst, verbose=False, match=None):\n             shutil.move(tp, fp)\n     shutil.rmtree(os.path.join(dst, fname))\n \n+\n def run(args, verbose=False, exception=False, **kwargs):\n     if verbose:\n         print(\"running: \" + ' '.join(args))\n@@ -245,7 +250,8 @@ def fix_executable(self, fname):\n             return\n \n         # At this point we're pretty sure the user is running NixOS\n-        print(\"info: you seem to be running NixOS. Attempting to patch \" + fname)\n+        nix_os_msg = \"info: you seem to be running NixOS. Attempting to patch\"\n+        print(nix_os_msg, fname)\n \n         try:\n             interpreter = subprocess.check_output(\n@@ -293,18 +299,22 @@ def stage0_cargo_channel(self):\n         return self._cargo_channel\n \n     def rustc_stamp(self):\n+        \"\"\"Return the path for .rustc-stamp\"\"\"\n         return os.path.join(self.bin_root(), '.rustc-stamp')\n \n     def cargo_stamp(self):\n+        \"\"\"Return the path for .cargo-stamp\"\"\"\n         return os.path.join(self.bin_root(), '.cargo-stamp')\n \n     def rustc_out_of_date(self):\n+        \"\"\"Check if rustc is out of date\"\"\"\n         if not os.path.exists(self.rustc_stamp()) or self.clean:\n             return True\n         with open(self.rustc_stamp(), 'r') as f:\n             return self.stage0_date() != f.read()\n \n     def cargo_out_of_date(self):\n+        \"\"\"Check if cargo is out of date\"\"\"\n         if not os.path.exists(self.cargo_stamp()) or self.clean:\n             return True\n         with open(self.cargo_stamp(), 'r') as f:\n@@ -357,16 +367,15 @@ def get_string(self, line):\n     def exe_suffix(self):\n         if sys.platform == 'win32':\n             return '.exe'\n-        else:\n-            return ''\n+        return ''\n \n     def print_what_it_means_to_bootstrap(self):\n         if hasattr(self, 'printed'):\n             return\n         self.printed = True\n         if os.path.exists(self.bootstrap_binary()):\n             return\n-        if not '--help' in sys.argv or len(sys.argv) == 1:\n+        if '--help' not in sys.argv or len(sys.argv) == 1:\n             return\n \n         print('info: the build system for Rust is written in Rust, so this')\n@@ -461,8 +470,8 @@ def build_triple(self):\n             # always emit 'i386' on x86/amd64 systems).  As such, isainfo -k\n             # must be used instead.\n             try:\n-                cputype = subprocess.check_output(['isainfo',\n-                                                   '-k']).strip().decode(default_encoding)\n+                cputype = subprocess.check_output(\n+                    ['isainfo', '-k']).strip().decode(default_encoding)\n             except (subprocess.CalledProcessError, OSError):\n                 err = \"isainfo not found\"\n                 if self.verbose:\n@@ -562,21 +571,26 @@ def update_submodules(self):\n         default_encoding = sys.getdefaultencoding()\n         run([\"git\", \"submodule\", \"-q\", \"sync\"], cwd=self.rust_root)\n         submodules = [s.split(' ', 1)[1] for s in subprocess.check_output(\n-            [\"git\", \"config\", \"--file\", os.path.join(self.rust_root, \".gitmodules\"),\n+            [\"git\", \"config\", \"--file\",\n+             os.path.join(self.rust_root, \".gitmodules\"),\n              \"--get-regexp\", \"path\"]\n         ).decode(default_encoding).splitlines()]\n         submodules = [module for module in submodules\n                       if not ((module.endswith(\"llvm\") and\n-                               (self.get_toml('llvm-config') or self.get_mk('CFG_LLVM_ROOT'))) or\n+                               (self.get_toml('llvm-config') or\n+                                self.get_mk('CFG_LLVM_ROOT'))) or\n                               (module.endswith(\"jemalloc\") and\n-                               (self.get_toml('jemalloc') or self.get_mk('CFG_JEMALLOC_ROOT'))))\n-                     ]\n+                               (self.get_toml('jemalloc') or\n+                                self.get_mk('CFG_JEMALLOC_ROOT'))))]\n         run([\"git\", \"submodule\", \"update\",\n-                  \"--init\"] + submodules, cwd=self.rust_root, verbose=self.verbose)\n+             \"--init\"] + submodules,\n+            cwd=self.rust_root, verbose=self.verbose)\n         run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-                  \"reset\", \"-q\", \"--hard\"], cwd=self.rust_root, verbose=self.verbose)\n+             \"reset\", \"-q\", \"--hard\"],\n+            cwd=self.rust_root, verbose=self.verbose)\n         run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-                  \"clean\", \"-qdfx\"], cwd=self.rust_root, verbose=self.verbose)\n+             \"clean\", \"-qdfx\"],\n+            cwd=self.rust_root, verbose=self.verbose)\n \n \n def bootstrap():\n@@ -692,5 +706,6 @@ def main():\n                   format_build_time(time() - start_time))\n         sys.exit(exit_code)\n \n+\n if __name__ == '__main__':\n     main()"}, {"sha": "7c7161916ee2ce9c8ea8d96c3a49003a0670f309", "filename": "src/bootstrap/cc.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -42,10 +42,13 @@ use config::Target;\n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n-    for target in build.config.target.iter() {\n+    //\n+    // This includes targets that aren't necessarily passed on the commandline\n+    // (FIXME: Perhaps it shouldn't?)\n+    for target in &build.config.target {\n         let mut cfg = gcc::Config::new();\n         cfg.cargo_metadata(false).opt_level(0).debug(false)\n-           .target(target).host(&build.config.build);\n+           .target(target).host(&build.build);\n \n         let config = build.config.target_config.get(target);\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n@@ -64,10 +67,13 @@ pub fn find(build: &mut Build) {\n     }\n \n     // For all host triples we need to find a C++ compiler as well\n-    for host in build.config.host.iter() {\n+    //\n+    // This includes hosts that aren't necessarily passed on the commandline\n+    // (FIXME: Perhaps it shouldn't?)\n+    for host in &build.config.host {\n         let mut cfg = gcc::Config::new();\n         cfg.cargo_metadata(false).opt_level(0).debug(false).cpp(true)\n-           .target(host).host(&build.config.build);\n+           .target(host).host(&build.build);\n         let config = build.config.target_config.get(host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);"}, {"sha": "1153acfa57d39113b893ba8f78d2f9ba76e52f8e", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -23,12 +23,12 @@ use build_helper::output;\n use Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &'static str = \"1.20.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.20.0\";\n \n // An optional number to put after the label, e.g. '.2' -> '-beta.2'\n // Be sure to make this starts with a dot to conform to semver pre-release\n // versions (section 9)\n-pub const CFG_PRERELEASE_VERSION: &'static str = \".1\";\n+pub const CFG_PRERELEASE_VERSION: &str = \".1\";\n \n pub struct GitInfo {\n     inner: Option<Info>,\n@@ -99,6 +99,10 @@ impl GitInfo {\n             version.push_str(&inner.commit_date);\n             version.push_str(\")\");\n         }\n-        return version\n+        version\n+    }\n+\n+    pub fn is_git(&self) -> bool {\n+        self.inner.is_some()\n     }\n }"}, {"sha": "b3b5ae8d67d6551f97b6c54dd857831d02b18b3e", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -13,23 +13,22 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n-extern crate build_helper;\n-\n use std::collections::HashSet;\n use std::env;\n+use std::iter;\n use std::fmt;\n use std::fs::{self, File};\n use std::path::{PathBuf, Path};\n use std::process::Command;\n use std::io::Read;\n \n-use build_helper::output;\n+use build_helper::{self, output};\n \n use {Build, Compiler, Mode};\n use dist;\n use util::{self, dylib_path, dylib_path_var, exe};\n \n-const ADB_TEST_DIR: &'static str = \"/data/tmp/work\";\n+const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n /// The two modes of the test runner; tests or benchmarks.\n #[derive(Copy, Clone)]\n@@ -60,7 +59,7 @@ impl fmt::Display for TestKind {\n }\n \n fn try_run(build: &Build, cmd: &mut Command) {\n-    if build.flags.cmd.no_fail_fast() {\n+    if !build.fail_fast {\n         if !build.try_run(cmd) {\n             let failures = build.delayed_failures.get();\n             build.delayed_failures.set(failures + 1);\n@@ -71,7 +70,7 @@ fn try_run(build: &Build, cmd: &mut Command) {\n }\n \n fn try_run_quiet(build: &Build, cmd: &mut Command) {\n-    if build.flags.cmd.no_fail_fast() {\n+    if !build.fail_fast {\n         if !build.try_run_quiet(cmd) {\n             let failures = build.delayed_failures.get();\n             build.delayed_failures.set(failures + 1);\n@@ -99,7 +98,7 @@ pub fn linkcheck(build: &Build, host: &str) {\n /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n /// test` to ensure that we don't regress the test suites there.\n pub fn cargotest(build: &Build, stage: u32, host: &str) {\n-    let ref compiler = Compiler::new(stage, host);\n+    let compiler = Compiler::new(stage, host);\n \n     // Note that this is a short, cryptic, and not scoped directory name. This\n     // is currently to minimize the length of path on Windows where we otherwise\n@@ -109,11 +108,11 @@ pub fn cargotest(build: &Build, stage: u32, host: &str) {\n \n     let _time = util::timeit();\n     let mut cmd = Command::new(build.tool(&Compiler::new(0, host), \"cargotest\"));\n-    build.prepare_tool_cmd(compiler, &mut cmd);\n-    try_run(build, cmd.arg(&build.cargo)\n+    build.prepare_tool_cmd(&compiler, &mut cmd);\n+    try_run(build, cmd.arg(&build.initial_cargo)\n                       .arg(&out_dir)\n-                      .env(\"RUSTC\", build.compiler_path(compiler))\n-                      .env(\"RUSTDOC\", build.rustdoc(compiler)));\n+                      .env(\"RUSTC\", build.compiler_path(&compiler))\n+                      .env(\"RUSTDOC\", build.rustdoc(&compiler)));\n }\n \n /// Runs `cargo test` for `cargo` packaged with Rust.\n@@ -124,13 +123,12 @@ pub fn cargo(build: &Build, stage: u32, host: &str) {\n     // and not RUSTC because the Cargo test suite has tests that will\n     // fail if rustc is not spelled `rustc`.\n     let path = build.sysroot(compiler).join(\"bin\");\n-    let old_path = ::std::env::var(\"PATH\").expect(\"\");\n-    let sep = if cfg!(windows) { \";\" } else {\":\" };\n-    let ref newpath = format!(\"{}{}{}\", path.display(), sep, old_path);\n+    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+    let newpath = env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\");\n \n     let mut cargo = build.cargo(compiler, Mode::Tool, host, \"test\");\n     cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n-    if build.flags.cmd.no_fail_fast() {\n+    if !build.fail_fast {\n         cargo.arg(\"--no-fail-fast\");\n     }\n \n@@ -198,9 +196,9 @@ pub fn compiletest(build: &Build,\n     cmd.arg(\"--mode\").arg(mode);\n     cmd.arg(\"--target\").arg(target);\n     cmd.arg(\"--host\").arg(compiler.host);\n-    cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.config.build));\n+    cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.build));\n \n-    if let Some(nodejs) = build.config.nodejs.as_ref() {\n+    if let Some(ref nodejs) = build.config.nodejs {\n         cmd.arg(\"--nodejs\").arg(nodejs);\n     }\n \n@@ -224,7 +222,7 @@ pub fn compiletest(build: &Build,\n \n     cmd.arg(\"--docck-python\").arg(build.python());\n \n-    if build.config.build.ends_with(\"apple-darwin\") {\n+    if build.build.ends_with(\"apple-darwin\") {\n         // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n         // LLDB plugin's compiled module which only works with the system python\n         // (namely not Homebrew-installed python)\n@@ -251,7 +249,7 @@ pub fn compiletest(build: &Build,\n \n     cmd.args(&build.flags.cmd.test_args());\n \n-    if build.config.verbose() || build.flags.verbose() {\n+    if build.is_verbose() {\n         cmd.arg(\"--verbose\");\n     }\n \n@@ -279,7 +277,7 @@ pub fn compiletest(build: &Build,\n \n     if build.remote_tested(target) {\n         cmd.arg(\"--remote-test-client\")\n-           .arg(build.tool(&Compiler::new(0, &build.config.build),\n+           .arg(build.tool(&Compiler::new(0, &build.build),\n                            \"remote-test-client\"));\n     }\n \n@@ -368,7 +366,7 @@ pub fn error_index(build: &Build, compiler: &Compiler) {\n                              \"error_index_generator\")\n                    .arg(\"markdown\")\n                    .arg(&output)\n-                   .env(\"CFG_BUILD\", &build.config.build));\n+                   .env(\"CFG_BUILD\", &build.build));\n \n     markdown_test(build, compiler, &output);\n }\n@@ -450,7 +448,7 @@ pub fn krate(build: &Build,\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n-    if test_kind.subcommand() == \"test\" && build.flags.cmd.no_fail_fast() {\n+    if test_kind.subcommand() == \"test\" && !build.fail_fast {\n         cargo.arg(\"--no-fail-fast\");\n     }\n \n@@ -520,16 +518,14 @@ fn krate_emscripten(build: &Build,\n                     compiler: &Compiler,\n                     target: &str,\n                     mode: Mode) {\n-    let mut tests = Vec::new();\n     let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n+    let tests = find_tests(&out_dir.join(\"deps\"), target);\n \n+    let nodejs = build.config.nodejs.as_ref().expect(\"nodejs not configured\");\n     for test in tests {\n-        let test_file_name = test.to_string_lossy().into_owned();\n-        println!(\"running {}\", test_file_name);\n-        let nodejs = build.config.nodejs.as_ref().expect(\"nodejs not configured\");\n+        println!(\"running {}\", test.display());\n         let mut cmd = Command::new(nodejs);\n-        cmd.arg(&test_file_name);\n+        cmd.arg(&test);\n         if build.config.quiet_tests {\n             cmd.arg(\"--quiet\");\n         }\n@@ -541,11 +537,10 @@ fn krate_remote(build: &Build,\n                 compiler: &Compiler,\n                 target: &str,\n                 mode: Mode) {\n-    let mut tests = Vec::new();\n     let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n+    let tests = find_tests(&out_dir.join(\"deps\"), target);\n \n-    let tool = build.tool(&Compiler::new(0, &build.config.build),\n+    let tool = build.tool(&Compiler::new(0, &build.build),\n                           \"remote-test-client\");\n     for test in tests {\n         let mut cmd = Command::new(&tool);\n@@ -559,9 +554,8 @@ fn krate_remote(build: &Build,\n     }\n }\n \n-fn find_tests(dir: &Path,\n-              target: &str,\n-              dst: &mut Vec<PathBuf>) {\n+fn find_tests(dir: &Path, target: &str) -> Vec<PathBuf> {\n+    let mut dst = Vec::new();\n     for e in t!(dir.read_dir()).map(|e| t!(e)) {\n         let file_type = t!(e.file_type());\n         if !file_type.is_file() {\n@@ -576,6 +570,7 @@ fn find_tests(dir: &Path,\n             dst.push(e.path());\n         }\n     }\n+    dst\n }\n \n pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n@@ -590,7 +585,7 @@ pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n                       .join(exe(\"remote-test-server\", target));\n \n     // Spawn the emulator and wait for it to come online\n-    let tool = build.tool(&Compiler::new(0, &build.config.build),\n+    let tool = build.tool(&Compiler::new(0, &build.build),\n                           \"remote-test-client\");\n     let mut cmd = Command::new(&tool);\n     cmd.arg(\"spawn-emulator\")\n@@ -616,7 +611,7 @@ pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n \n /// Run \"distcheck\", a 'make check' from a tarball\n pub fn distcheck(build: &Build) {\n-    if build.config.build != \"x86_64-unknown-linux-gnu\" {\n+    if build.build != \"x86_64-unknown-linux-gnu\" {\n         return\n     }\n     if !build.config.host.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n@@ -641,7 +636,7 @@ pub fn distcheck(build: &Build) {\n                      .args(&build.config.configure_args)\n                      .arg(\"--enable-vendor\")\n                      .current_dir(&dir));\n-    build.run(Command::new(build_helper::make(&build.config.build))\n+    build.run(Command::new(build_helper::make(&build.build))\n                      .arg(\"check\")\n                      .current_dir(&dir));\n \n@@ -659,7 +654,7 @@ pub fn distcheck(build: &Build) {\n     build.run(&mut cmd);\n \n     let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-    build.run(Command::new(&build.cargo)\n+    build.run(Command::new(&build.initial_cargo)\n                      .arg(\"generate-lockfile\")\n                      .arg(\"--manifest-path\")\n                      .arg(&toml)\n@@ -668,13 +663,13 @@ pub fn distcheck(build: &Build) {\n \n /// Test the build system itself\n pub fn bootstrap(build: &Build) {\n-    let mut cmd = Command::new(&build.cargo);\n+    let mut cmd = Command::new(&build.initial_cargo);\n     cmd.arg(\"test\")\n        .current_dir(build.src.join(\"src/bootstrap\"))\n        .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n        .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-       .env(\"RUSTC\", &build.rustc);\n-    if build.flags.cmd.no_fail_fast() {\n+       .env(\"RUSTC\", &build.initial_rustc);\n+    if !build.fail_fast {\n         cmd.arg(\"--no-fail-fast\");\n     }\n     cmd.arg(\"--\").args(&build.flags.cmd.test_args());"}, {"sha": "5a3106c7d5e64e59aa8c0cca9a64b61ad78769e4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -50,7 +50,7 @@ pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n     let mut cargo = build.cargo(compiler, Mode::Libstd, target, \"build\");\n     let mut features = build.std_features();\n \n-    if let Ok(target) = env::var(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n+    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n@@ -158,7 +158,7 @@ pub fn build_startup_objects(build: &Build, for_compiler: &Compiler, target: &st\n         return\n     }\n \n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let compiler_path = build.compiler_path(&compiler);\n     let src_dir = &build.src.join(\"src/rtstartup\");\n     let dst_dir = &build.native_dir(target).join(\"rtstartup\");\n@@ -199,7 +199,7 @@ pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n     let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n     build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n     let mut cargo = build.cargo(compiler, Mode::Libtest, target, \"build\");\n-    if let Ok(target) = env::var(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n+    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n     cargo.arg(\"--manifest-path\")\n@@ -247,7 +247,7 @@ pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n     cargo.env(\"CFG_RELEASE\", build.rust_release())\n          .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n          .env(\"CFG_VERSION\", build.rust_version())\n-         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or(PathBuf::new()));\n+         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default());\n \n     if compiler.stage == 0 {\n         cargo.env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n@@ -276,10 +276,6 @@ pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n     if build.is_rust_llvm(target) {\n         cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n     }\n-    if let Some(ref cfg_file) = build.flags.config {\n-        let cfg_path = t!(PathBuf::from(cfg_file).canonicalize());\n-        cargo.env(\"CFG_LLVM_TOML\", cfg_path.into_os_string());\n-    }\n     cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n     let target_config = build.config.target_config.get(target);\n     if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n@@ -355,7 +351,7 @@ pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n /// Prepare a new compiler from the artifacts in `stage`\n ///\n /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n-/// must have been previously produced by the `stage - 1` build.config.build\n+/// must have been previously produced by the `stage - 1` build.build\n /// compiler.\n pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     // nothing to do in stage0\n@@ -369,7 +365,7 @@ pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     let target_compiler = Compiler::new(stage, host);\n \n     // The compiler that compiled the compiler we're assembling\n-    let build_compiler = Compiler::new(stage - 1, &build.config.build);\n+    let build_compiler = Compiler::new(stage - 1, &build.build);\n \n     // Link in all dylibs to the libdir\n     let sysroot = build.sysroot(&target_compiler);\n@@ -389,7 +385,7 @@ pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     let rustc = out_dir.join(exe(\"rustc\", host));\n     let bindir = sysroot.join(\"bin\");\n     t!(fs::create_dir_all(&bindir));\n-    let compiler = build.compiler_path(&Compiler::new(stage, host));\n+    let compiler = build.compiler_path(&target_compiler);\n     let _ = fs::remove_file(&compiler);\n     copy(&rustc, &compiler);\n \n@@ -411,6 +407,8 @@ fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n     let mut contents = Vec::new();\n     t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+    // This is the method we use for extracting paths from the stamp file passed to us. See\n+    // run_cargo for more information (in this file).\n     for part in contents.split(|b| *b == 0) {\n         if part.is_empty() {\n             continue\n@@ -425,7 +423,7 @@ fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n /// This will build the specified tool with the specified `host` compiler in\n /// `stage` into the normal cargo output directory.\n pub fn maybe_clean_tools(build: &Build, stage: u32, target: &str, mode: Mode) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n \n     let stamp = match mode {\n         Mode::Libstd => libstd_stamp(build, &compiler, target),\n@@ -445,7 +443,7 @@ pub fn tool(build: &Build, stage: u32, target: &str, tool: &str) {\n     let _folder = build.fold_output(|| format!(\"stage{}-{}\", stage, tool));\n     println!(\"Building stage{} tool {} ({})\", stage, tool, target);\n \n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n \n     let mut cargo = build.cargo(&compiler, Mode::Tool, target, \"build\");\n     let dir = build.src.join(\"src/tools\").join(tool);\n@@ -561,23 +559,24 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n             // If this was an output file in the \"host dir\" we don't actually\n             // worry about it, it's not relevant for us.\n             if filename.starts_with(&host_root_dir) {\n-                continue\n+                continue;\n+            }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n-            } else if filename.starts_with(&target_deps_dir) {\n+            if filename.starts_with(&target_deps_dir) {\n                 deps.push(filename.to_path_buf());\n+                continue;\n+            }\n \n             // Otherwise this was a \"top level artifact\" which right now doesn't\n             // have a hash in the name, but there's a version of this file in\n             // the `deps` folder which *does* have a hash in the name. That's\n             // the one we'll want to we'll probe for it later.\n-            } else {\n-                toplevel.push((filename.file_stem().unwrap()\n-                                       .to_str().unwrap().to_string(),\n-                               filename.extension().unwrap().to_owned()\n-                                       .to_str().unwrap().to_string()));\n-            }\n+            toplevel.push((filename.file_stem().unwrap()\n+                                    .to_str().unwrap().to_string(),\n+                            filename.extension().unwrap().to_owned()\n+                                    .to_str().unwrap().to_string()));\n         }\n     }\n "}, {"sha": "34628852ab3773a2ff50bc051d77231bfd96b438", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -81,8 +81,6 @@ pub struct Config {\n     pub build: String,\n     pub host: Vec<String>,\n     pub target: Vec<String>,\n-    pub rustc: Option<PathBuf>,\n-    pub cargo: Option<PathBuf>,\n     pub local_rebuild: bool,\n \n     // dist misc\n@@ -114,11 +112,18 @@ pub struct Config {\n     pub python: Option<PathBuf>,\n     pub configure_args: Vec<String>,\n     pub openssl_static: bool,\n+\n+\n+    // These are either the stage0 downloaded binaries or the locally installed ones.\n+    pub initial_cargo: PathBuf,\n+    pub initial_rustc: PathBuf,\n+\n }\n \n /// Per-target configuration stored in the global configuration structure.\n #[derive(Default)]\n pub struct Target {\n+    /// Some(path to llvm-config) if using an external LLVM.\n     pub llvm_config: Option<PathBuf>,\n     pub jemalloc: Option<PathBuf>,\n     pub cc: Option<PathBuf>,\n@@ -307,8 +312,6 @@ impl Config {\n                 config.target.push(target.clone());\n             }\n         }\n-        config.rustc = build.rustc.map(PathBuf::from);\n-        config.cargo = build.cargo.map(PathBuf::from);\n         config.nodejs = build.nodejs.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n         config.python = build.python.map(PathBuf::from);\n@@ -410,13 +413,25 @@ impl Config {\n             set(&mut config.rust_dist_src, t.src_tarball);\n         }\n \n+        let cwd = t!(env::current_dir());\n+        let out = cwd.join(\"build\");\n+\n+        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n+        config.initial_rustc = match build.rustc {\n+            Some(s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"rustc\", &config.build)),\n+        };\n+        config.initial_cargo = match build.cargo {\n+            Some(s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"cargo\", &config.build)),\n+        };\n \n         // compat with `./configure` while we're still using that\n         if fs::metadata(\"config.mk\").is_ok() {\n             config.update_with_config_mk();\n         }\n \n-        return config\n+        config\n     }\n \n     /// \"Temporary\" routine to parse `config.mk` into this configuration.\n@@ -609,8 +624,8 @@ impl Config {\n                 }\n                 \"CFG_LOCAL_RUST_ROOT\" if value.len() > 0 => {\n                     let path = parse_configure_path(value);\n-                    self.rustc = Some(push_exe_path(path.clone(), &[\"bin\", \"rustc\"]));\n-                    self.cargo = Some(push_exe_path(path, &[\"bin\", \"cargo\"]));\n+                    self.initial_rustc = push_exe_path(path.clone(), &[\"bin\", \"rustc\"]);\n+                    self.initial_cargo = push_exe_path(path, &[\"bin\", \"cargo\"]);\n                 }\n                 \"CFG_PYTHON\" if value.len() > 0 => {\n                     let path = parse_configure_path(value);"}, {"sha": "efc33bcee9b3becf2bca18c0964577df002949b2", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -50,7 +50,7 @@ pub fn tmpdir(build: &Build) -> PathBuf {\n }\n \n fn rust_installer(build: &Build) -> Command {\n-    build.tool_cmd(&Compiler::new(0, &build.config.build), \"rust-installer\")\n+    build.tool_cmd(&Compiler::new(0, &build.build), \"rust-installer\")\n }\n \n /// Builds the `rust-docs` installer component.\n@@ -89,15 +89,15 @@ pub fn docs(build: &Build, stage: u32, host: &str) {\n \n     // As part of this step, *also* copy the docs directory to a directory which\n     // buildbot typically uploads.\n-    if host == build.config.build {\n+    if host == build.build {\n         let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n         t!(fs::create_dir_all(&dst));\n         cp_r(&src, &dst);\n     }\n }\n \n fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n-    let mut found = Vec::new();\n+    let mut found = Vec::with_capacity(files.len());\n \n     for file in files {\n         let file_path =\n@@ -119,17 +119,9 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n     //Ask gcc where it keeps its stuff\n     let mut cmd = Command::new(build.cc(target_triple));\n     cmd.arg(\"-print-search-dirs\");\n-    build.run_quiet(&mut cmd);\n-    let gcc_out =\n-        String::from_utf8(\n-                cmd\n-                .output()\n-                .expect(\"failed to execute gcc\")\n-                .stdout).expect(\"gcc.exe output was not utf8\");\n-\n-    let mut bin_path: Vec<_> =\n-        env::split_paths(&env::var_os(\"PATH\").unwrap_or_default())\n-        .collect();\n+    let gcc_out = output(&mut cmd);\n+\n+    let mut bin_path: Vec<_> = env::split_paths(&env::var_os(\"PATH\").unwrap_or_default()).collect();\n     let mut lib_path = Vec::new();\n \n     for line in gcc_out.lines() {\n@@ -140,7 +132,7 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n             line[(idx + 1)..]\n                 .trim_left_matches(trim_chars)\n                 .split(';')\n-                .map(|s| PathBuf::from(s));\n+                .map(PathBuf::from);\n \n         if key == \"programs\" {\n             bin_path.extend(value);\n@@ -149,15 +141,15 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n         }\n     }\n \n-    let target_tools = vec![\"gcc.exe\", \"ld.exe\", \"ar.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n+    let target_tools = [\"gcc.exe\", \"ld.exe\", \"ar.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n     let mut rustc_dlls = vec![\"libstdc++-6.dll\", \"libwinpthread-1.dll\"];\n     if target_triple.starts_with(\"i686-\") {\n         rustc_dlls.push(\"libgcc_s_dw2-1.dll\");\n     } else {\n         rustc_dlls.push(\"libgcc_s_seh-1.dll\");\n     }\n \n-    let target_libs = vec![ //MinGW libs\n+    let target_libs = [ //MinGW libs\n         \"libgcc.a\",\n         \"libgcc_eh.a\",\n         \"libgcc_s.a\",\n@@ -203,7 +195,7 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n     let target_libs = find_files(&target_libs, &lib_path);\n \n     fn copy_to_folder(src: &Path, dest_folder: &Path) {\n-        let file_name = src.file_name().unwrap().to_os_string();\n+        let file_name = src.file_name().unwrap();\n         let dest = dest_folder.join(file_name);\n         copy(src, &dest);\n     }\n@@ -234,8 +226,6 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n ///\n /// This contains all the bits and pieces to run the MinGW Windows targets\n /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n-/// Currently just shells out to a python script, but that should be rewritten\n-/// in Rust.\n pub fn mingw(build: &Build, host: &str) {\n     println!(\"Dist mingw ({})\", host);\n     let name = pkgname(build, \"rust-mingw\");\n@@ -366,9 +356,9 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n pub fn debugger_scripts(build: &Build,\n                         sysroot: &Path,\n                         host: &str) {\n+    let dst = sysroot.join(\"lib/rustlib/etc\");\n+    t!(fs::create_dir_all(&dst));\n     let cp_debugger_script = |file: &str| {\n-        let dst = sysroot.join(\"lib/rustlib/etc\");\n-        t!(fs::create_dir_all(&dst));\n         install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n     };\n     if host.contains(\"windows-msvc\") {\n@@ -404,7 +394,7 @@ pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n \n     // The only true set of target libraries came from the build triple, so\n     // let's reduce redundant work by only producing archives from that host.\n-    if compiler.host != build.config.build {\n+    if compiler.host != build.build {\n         println!(\"\\tskipping, not a build host\");\n         return\n     }\n@@ -450,7 +440,7 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n     assert!(build.config.extended);\n     println!(\"Dist analysis\");\n \n-    if compiler.host != build.config.build {\n+    if compiler.host != build.build {\n         println!(\"\\tskipping, not a build host\");\n         return;\n     }\n@@ -498,12 +488,11 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n         if spath.ends_with(\"~\") || spath.ends_with(\".pyc\") {\n             return false\n         }\n-        if spath.contains(\"llvm/test\") || spath.contains(\"llvm\\\\test\") {\n-            if spath.ends_with(\".ll\") ||\n-               spath.ends_with(\".td\") ||\n-               spath.ends_with(\".s\") {\n-                return false\n-            }\n+        if (spath.contains(\"llvm/test\") || spath.contains(\"llvm\\\\test\")) &&\n+            (spath.ends_with(\".ll\") ||\n+             spath.ends_with(\".td\") ||\n+             spath.ends_with(\".s\")) {\n+            return false\n         }\n \n         let full_path = Path::new(dir).join(path);\n@@ -595,7 +584,7 @@ pub fn rust_src(build: &Build) {\n     t!(fs::remove_dir_all(&image));\n }\n \n-const CARGO_VENDOR_VERSION: &'static str = \"0.1.4\";\n+const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n \n /// Creates the plain source tarball\n pub fn plain_source_tarball(build: &Build) {\n@@ -634,26 +623,26 @@ pub fn plain_source_tarball(build: &Build) {\n     write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n \n     // If we're building from git sources, we need to vendor a complete distribution.\n-    if build.src_is_git {\n+    if build.rust_info.is_git() {\n         // Get cargo-vendor installed, if it isn't already.\n         let mut has_cargo_vendor = false;\n-        let mut cmd = Command::new(&build.cargo);\n+        let mut cmd = Command::new(&build.initial_cargo);\n         for line in output(cmd.arg(\"install\").arg(\"--list\")).lines() {\n             has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n         }\n         if !has_cargo_vendor {\n-            let mut cmd = Command::new(&build.cargo);\n+            let mut cmd = Command::new(&build.initial_cargo);\n             cmd.arg(\"install\")\n                .arg(\"--force\")\n                .arg(\"--debug\")\n                .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n                .arg(\"cargo-vendor\")\n-               .env(\"RUSTC\", &build.rustc);\n+               .env(\"RUSTC\", &build.initial_rustc);\n             build.run(&mut cmd);\n         }\n \n         // Vendor all Cargo dependencies\n-        let mut cmd = Command::new(&build.cargo);\n+        let mut cmd = Command::new(&build.initial_cargo);\n         cmd.arg(\"vendor\")\n            .current_dir(&plain_dst_src.join(\"src\"));\n         build.run(&mut cmd);\n@@ -716,7 +705,7 @@ fn write_file(path: &Path, data: &[u8]) {\n \n pub fn cargo(build: &Build, stage: u32, target: &str) {\n     println!(\"Dist cargo stage{} ({})\", stage, target);\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n \n     let src = build.src.join(\"src/tools/cargo\");\n     let etc = src.join(\"src/etc\");\n@@ -777,7 +766,7 @@ pub fn cargo(build: &Build, stage: u32, target: &str) {\n pub fn rls(build: &Build, stage: u32, target: &str) {\n     assert!(build.config.extended);\n     println!(\"Dist RLS stage{} ({})\", stage, target);\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n \n     let src = build.src.join(\"src/tools/rls\");\n     let release_num = build.release_num(\"rls\");\n@@ -1209,7 +1198,7 @@ fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n }\n \n pub fn hash_and_sign(build: &Build) {\n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");\n     let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n         panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")"}, {"sha": "7dbc3e5553957c4feb360b92a33a170cb15fda7f", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -45,7 +45,7 @@ pub fn rustbook_src(build: &Build, target: &str, name: &str, src: &Path) {\n     t!(fs::create_dir_all(&out));\n \n     let out = out.join(name);\n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let src = src.join(name);\n     let index = out.join(\"index.html\");\n     let rustbook = build.tool(&compiler, \"rustbook\");\n@@ -95,7 +95,7 @@ pub fn book(build: &Build, target: &str, name: &str) {\n fn invoke_rustdoc(build: &Build, target: &str, markdown: &str) {\n     let out = build.doc_out(target);\n \n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n \n     let path = build.src.join(\"src/doc\").join(markdown);\n \n@@ -150,7 +150,7 @@ pub fn standalone(build: &Build, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n \n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n \n     let favicon = build.src.join(\"src/doc/favicon.inc\");\n     let footer = build.src.join(\"src/doc/footer.inc\");\n@@ -217,7 +217,7 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} std ({})\", stage, target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n     let compiler = if build.force_use_stage1(&compiler, target) {\n         Compiler::new(1, compiler.host)\n     } else {\n@@ -276,7 +276,7 @@ pub fn test(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} test ({})\", stage, target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n     let compiler = if build.force_use_stage1(&compiler, target) {\n         Compiler::new(1, compiler.host)\n     } else {\n@@ -306,7 +306,7 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} compiler ({})\", stage, target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n     let compiler = if build.force_use_stage1(&compiler, target) {\n         Compiler::new(1, compiler.host)\n     } else {\n@@ -351,13 +351,13 @@ pub fn error_index(build: &Build, target: &str) {\n     println!(\"Documenting error index ({})\", target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n     index.arg(\"html\");\n     index.arg(out.join(\"error-index.html\"));\n \n     // FIXME: shouldn't have to pass this env var\n-    index.env(\"CFG_BUILD\", &build.config.build);\n+    index.env(\"CFG_BUILD\", &build.build);\n \n     build.run(&mut index);\n }\n@@ -367,7 +367,7 @@ pub fn unstable_book_gen(build: &Build, target: &str) {\n     let out = build.md_doc_out(target).join(\"unstable-book\");\n     t!(fs::create_dir_all(&out));\n     t!(fs::remove_dir_all(&out));\n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let mut cmd = build.tool_cmd(&compiler, \"unstable-book-gen\");\n     cmd.arg(build.src.join(\"src\"));\n     cmd.arg(out);"}, {"sha": "5804df34e8b383f21798c20fcf0791244d9628ac", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -35,22 +35,12 @@ pub struct Flags {\n     pub host: Vec<String>,\n     pub target: Vec<String>,\n     pub config: Option<PathBuf>,\n-    pub src: Option<PathBuf>,\n+    pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n }\n \n-impl Flags {\n-    pub fn verbose(&self) -> bool {\n-        self.verbose > 0\n-    }\n-\n-    pub fn very_verbose(&self) -> bool {\n-        self.verbose > 1\n-    }\n-}\n-\n pub enum Subcommand {\n     Build {\n         paths: Vec<PathBuf>,\n@@ -61,7 +51,7 @@ pub enum Subcommand {\n     Test {\n         paths: Vec<PathBuf>,\n         test_args: Vec<String>,\n-        no_fail_fast: bool,\n+        fail_fast: bool,\n     },\n     Bench {\n         paths: Vec<PathBuf>,\n@@ -122,16 +112,15 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n         // complete the definition of the options.  Then we can use the getopt::Matches object from\n         // there on out.\n-        let mut possible_subcommands = args.iter().collect::<Vec<_>>();\n-        possible_subcommands.retain(|&s|\n-                                           (s == \"build\")\n-                                        || (s == \"test\")\n-                                        || (s == \"bench\")\n-                                        || (s == \"doc\")\n-                                        || (s == \"clean\")\n-                                        || (s == \"dist\")\n-                                        || (s == \"install\"));\n-        let subcommand = match possible_subcommands.first() {\n+        let subcommand = args.iter().find(|&s|\n+            (s == \"build\")\n+            || (s == \"test\")\n+            || (s == \"bench\")\n+            || (s == \"doc\")\n+            || (s == \"clean\")\n+            || (s == \"dist\")\n+            || (s == \"install\"));\n+        let subcommand = match subcommand {\n             Some(s) => s,\n             None => {\n                 // No subcommand -- show the general usage and subcommand help\n@@ -164,7 +153,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         let mut pass_sanity_check = true;\n         match matches.free.get(0) {\n             Some(check_subcommand) => {\n-                if &check_subcommand != subcommand {\n+                if check_subcommand != subcommand {\n                     pass_sanity_check = false;\n                 }\n             },\n@@ -279,7 +268,7 @@ Arguments:\n                 Subcommand::Test {\n                     paths: paths,\n                     test_args: matches.opt_strs(\"test-args\"),\n-                    no_fail_fast: matches.opt_present(\"no-fail-fast\"),\n+                    fail_fast: !matches.opt_present(\"no-fail-fast\"),\n                 }\n             }\n             \"bench\" => {\n@@ -316,12 +305,15 @@ Arguments:\n \n         let mut stage = matches.opt_str(\"stage\").map(|j| j.parse().unwrap());\n \n-        if matches.opt_present(\"incremental\") {\n-            if stage.is_none() {\n-                stage = Some(1);\n-            }\n+        if matches.opt_present(\"incremental\") && stage.is_none() {\n+            stage = Some(1);\n         }\n \n+        let cwd = t!(env::current_dir());\n+        let src = matches.opt_str(\"src\").map(PathBuf::from)\n+            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n+            .unwrap_or(cwd);\n+\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: stage,\n@@ -333,7 +325,7 @@ Arguments:\n             host: split(matches.opt_strs(\"host\")),\n             target: split(matches.opt_strs(\"target\")),\n             config: cfg_file,\n-            src: matches.opt_str(\"src\").map(PathBuf::from),\n+            src: src,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd: cmd,\n             incremental: matches.opt_present(\"incremental\"),\n@@ -352,9 +344,9 @@ impl Subcommand {\n         }\n     }\n \n-    pub fn no_fail_fast(&self) -> bool {\n+    pub fn fail_fast(&self) -> bool {\n         match *self {\n-            Subcommand::Test { no_fail_fast, .. } => no_fail_fast,\n+            Subcommand::Test { fail_fast, .. } => fail_fast,\n             _ => false,\n         }\n     }"}, {"sha": "8e2ef527b1658dc0ea4a6a0aca491b439dfbf1f3", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -146,5 +146,5 @@ fn add_destdir(path: &Path, destdir: &Option<PathBuf>) -> PathBuf {\n             _ => {}\n         }\n     }\n-    return ret\n+    ret\n }"}, {"sha": "69b0c4a2756a681a1a22691d87af43010dae7c3b", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 81, "deletions": 49, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -161,25 +161,35 @@ pub struct Build {\n     flags: Flags,\n \n     // Derived properties from the above two configurations\n-    cargo: PathBuf,\n-    rustc: PathBuf,\n     src: PathBuf,\n     out: PathBuf,\n     rust_info: channel::GitInfo,\n     cargo_info: channel::GitInfo,\n     rls_info: channel::GitInfo,\n     local_rebuild: bool,\n+    fail_fast: bool,\n+    verbosity: usize,\n+\n+    // Targets for which to build.\n+    build: String,\n+    hosts: Vec<String>,\n+    targets: Vec<String>,\n+\n+    // Stage 0 (downloaded) compiler and cargo or their local rust equivalents.\n+    initial_rustc: PathBuf,\n+    initial_cargo: PathBuf,\n \n     // Probed tools at runtime\n     lldb_version: Option<String>,\n     lldb_python_dir: Option<String>,\n \n     // Runtime state filled in later on\n+    // target -> (cc, ar)\n     cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n+    // host -> (cc, ar)\n     cxx: HashMap<String, gcc::Tool>,\n     crates: HashMap<String, Crate>,\n     is_sudo: bool,\n-    src_is_git: bool,\n     ci_env: CiEnv,\n     delayed_failures: Cell<usize>,\n }\n@@ -202,20 +212,16 @@ struct Crate {\n /// build system, with each mod generating output in a different directory.\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub enum Mode {\n-    /// This cargo is going to build the standard library, placing output in the\n-    /// \"stageN-std\" directory.\n+    /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Libstd,\n \n-    /// This cargo is going to build libtest, placing output in the\n-    /// \"stageN-test\" directory.\n+    /// Build libtest, placing output in the \"stageN-test\" directory.\n     Libtest,\n \n-    /// This cargo is going to build librustc and compiler libraries, placing\n-    /// output in the \"stageN-rustc\" directory.\n+    /// Build librustc and compiler libraries, placing output in the \"stageN-rustc\" directory.\n     Librustc,\n \n-    /// This cargo is going to build some tool, placing output in the\n-    /// \"stageN-tools\" directory.\n+    /// Build some tool, placing output in the \"stageN-tools\" directory.\n     Tool,\n }\n \n@@ -226,22 +232,9 @@ impl Build {\n     /// By default all build output will be placed in the current directory.\n     pub fn new(flags: Flags, config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n-        let src = flags.src.clone().or_else(|| {\n-            env::var_os(\"SRC\").map(|x| x.into())\n-        }).unwrap_or(cwd.clone());\n+        let src = flags.src.clone();\n         let out = cwd.join(\"build\");\n \n-        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n-        let rustc = match config.rustc {\n-            Some(ref s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"rustc\", &config.build)),\n-        };\n-        let cargo = match config.cargo {\n-            Some(ref s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"cargo\", &config.build)),\n-        };\n-        let local_rebuild = config.local_rebuild;\n-\n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n             Some(sudo_user) => {\n                 match env::var_os(\"USER\") {\n@@ -254,32 +247,64 @@ impl Build {\n         let rust_info = channel::GitInfo::new(&src);\n         let cargo_info = channel::GitInfo::new(&src.join(\"src/tools/cargo\"));\n         let rls_info = channel::GitInfo::new(&src.join(\"src/tools/rls\"));\n-        let src_is_git = src.join(\".git\").exists();\n+\n+        let hosts = if !flags.host.is_empty() {\n+            for host in flags.host.iter() {\n+                if !config.host.contains(host) {\n+                    panic!(\"specified host `{}` is not in configuration\", host);\n+                }\n+            }\n+            flags.host.clone()\n+        } else {\n+            config.host.clone()\n+        };\n+        let targets = if !flags.target.is_empty() {\n+            for target in flags.target.iter() {\n+                if !config.target.contains(target) {\n+                    panic!(\"specified target `{}` is not in configuration\", target);\n+                }\n+            }\n+            flags.target.clone()\n+        } else {\n+            config.target.clone()\n+        };\n \n         Build {\n+            initial_rustc: config.initial_rustc.clone(),\n+            initial_cargo: config.initial_cargo.clone(),\n+            local_rebuild: config.local_rebuild,\n+            fail_fast: flags.cmd.fail_fast(),\n+            verbosity: cmp::max(flags.verbose, config.verbose),\n+\n+            build: config.host[0].clone(),\n+            hosts: hosts,\n+            targets: targets,\n+\n             flags: flags,\n             config: config,\n-            cargo: cargo,\n-            rustc: rustc,\n             src: src,\n             out: out,\n \n             rust_info: rust_info,\n             cargo_info: cargo_info,\n             rls_info: rls_info,\n-            local_rebuild: local_rebuild,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n             is_sudo: is_sudo,\n-            src_is_git: src_is_git,\n             ci_env: CiEnv::current(),\n             delayed_failures: Cell::new(0),\n         }\n     }\n \n+    fn build_slice(&self) -> &[String] {\n+        unsafe {\n+            std::slice::from_raw_parts(&self.build, 1)\n+        }\n+    }\n+\n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n         unsafe {\n@@ -296,7 +321,7 @@ impl Build {\n         sanity::check(self);\n         // If local-rust is the same major.minor as the current version, then force a local-rebuild\n         let local_version_verbose = output(\n-            Command::new(&self.rustc).arg(\"--version\").arg(\"--verbose\"));\n+            Command::new(&self.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n         let local_release = local_version_verbose\n             .lines().filter(|x| x.starts_with(\"release:\"))\n             .next().unwrap().trim_left_matches(\"release:\").trim();\n@@ -338,7 +363,7 @@ impl Build {\n              mode: Mode,\n              target: &str,\n              cmd: &str) -> Command {\n-        let mut cargo = Command::new(&self.cargo);\n+        let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n         cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n              .arg(cmd)\n@@ -347,7 +372,7 @@ impl Build {\n \n         // FIXME: Temporary fix for https://github.com/rust-lang/cargo/issues/3005\n         // Force cargo to output binaries with disambiguating hashes in the name\n-        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"1\");\n+        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &self.config.channel);\n \n         let stage;\n         if compiler.stage == 0 && self.local_rebuild {\n@@ -422,7 +447,7 @@ impl Build {\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n         if mode == Mode::Libstd {\n-            cargo.env(\"RUSTC_SNAPSHOT\", &self.rustc)\n+            cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n             cargo.env(\"RUSTC_SNAPSHOT\", self.compiler_path(compiler))\n@@ -441,8 +466,7 @@ impl Build {\n             cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n         }\n \n-        let verbose = cmp::max(self.config.verbose, self.flags.verbose);\n-        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", verbose));\n+        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n         // Specify some various options for build scripts used throughout\n         // the build.\n@@ -480,7 +504,7 @@ impl Build {\n         // FIXME: should update code to not require this env var\n         cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n \n-        if self.config.verbose() || self.flags.verbose() {\n+        if self.is_verbose() {\n             cargo.arg(\"-v\");\n         }\n         // FIXME: cargo bench does not accept `--release`\n@@ -496,13 +520,13 @@ impl Build {\n \n         self.ci_env.force_coloring_in_ci(&mut cargo);\n \n-        return cargo\n+        cargo\n     }\n \n     /// Get a path to the compiler specified.\n     fn compiler_path(&self, compiler: &Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n-            self.rustc.clone()\n+            self.initial_rustc.clone()\n         } else {\n             self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n         }\n@@ -519,15 +543,15 @@ impl Build {\n         let mut rustdoc = self.compiler_path(compiler);\n         rustdoc.pop();\n         rustdoc.push(exe(\"rustdoc\", compiler.host));\n-        return rustdoc\n+        rustdoc\n     }\n \n     /// Get a `Command` which is ready to run `tool` in `stage` built for\n     /// `host`.\n     fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n         self.prepare_tool_cmd(compiler, &mut cmd);\n-        return cmd\n+        cmd\n     }\n \n     /// Prepares the `cmd` provided to be able to run the `compiler` provided.\n@@ -578,7 +602,7 @@ impl Build {\n         if self.config.profiler {\n             features.push_str(\" profiler\");\n         }\n-        return features\n+        features\n     }\n \n     /// Get the space-separated set of activated features for the compiler.\n@@ -587,7 +611,7 @@ impl Build {\n         if self.config.use_jemalloc {\n             features.push_str(\" jemalloc\");\n         }\n-        return features\n+        features\n     }\n \n     /// Component directory that Cargo will produce output into (e.g.\n@@ -760,7 +784,7 @@ impl Build {\n \n     /// Returns the libdir of the snapshot compiler.\n     fn rustc_snapshot_libdir(&self) -> PathBuf {\n-        self.rustc.parent().unwrap().parent().unwrap()\n+        self.initial_rustc.parent().unwrap().parent().unwrap()\n             .join(libdir(&self.config.build))\n     }\n \n@@ -792,17 +816,25 @@ impl Build {\n         try_run_suppressed(cmd)\n     }\n \n+    pub fn is_verbose(&self) -> bool {\n+        self.verbosity > 0\n+    }\n+\n+    pub fn is_very_verbose(&self) -> bool {\n+        self.verbosity > 1\n+    }\n+\n     /// Prints a message if this build is configured in verbose mode.\n     fn verbose(&self, msg: &str) {\n-        if self.flags.verbose() || self.config.verbose() {\n+        if self.is_verbose() {\n             println!(\"{}\", msg);\n         }\n     }\n \n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n-        self.flags.jobs.unwrap_or(num_cpus::get() as u32)\n+        self.flags.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n@@ -834,7 +866,7 @@ impl Build {\n         if target == \"i686-pc-windows-gnu\" {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n-        return base\n+        base\n     }\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n@@ -866,7 +898,7 @@ impl Build {\n             !target.contains(\"emscripten\") {\n             base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n         }\n-        return base\n+        base\n     }\n \n     /// Returns the \"musl root\" for this `target`, if defined\n@@ -1047,7 +1079,7 @@ impl<'a> Compiler<'a> {\n \n     /// Returns whether this is a snapshot compiler for `build`'s configuration\n     fn is_snapshot(&self, build: &Build) -> bool {\n-        self.stage == 0 && self.host == build.config.build\n+        self.stage == 0 && self.host == build.build\n     }\n \n     /// Returns if this compiler should be treated as a final stage one in the"}, {"sha": "9326bb7129afa7f59d50d8d72360fc3eaea2271f", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -56,7 +56,7 @@ fn build_krate(build: &mut Build, krate: &str) {\n     // of packages we're going to have to know what `-p` arguments to pass it\n     // to know what crates to test. Here we run `cargo metadata` to learn about\n     // the dependency graph and what `-p` arguments there are.\n-    let mut cargo = Command::new(&build.cargo);\n+    let mut cargo = Command::new(&build.initial_cargo);\n     cargo.arg(\"metadata\")\n          .arg(\"--format-version\").arg(\"1\")\n          .arg(\"--manifest-path\").arg(build.src.join(krate).join(\"Cargo.toml\"));"}, {"sha": "20eec97d8e5aaa8e39fb675132e4644d79575331", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -94,7 +94,7 @@ pub fn llvm(build: &Build, target: &str) {\n     let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n \n     cfg.target(target)\n-       .host(&build.config.build)\n+       .host(&build.build)\n        .out_dir(&out_dir)\n        .profile(profile)\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n@@ -129,11 +129,11 @@ pub fn llvm(build: &Build, target: &str) {\n     }\n \n     // http://llvm.org/docs/HowToCrossCompileLLVM.html\n-    if target != build.config.build {\n+    if target != build.build {\n         // FIXME: if the llvm root for the build triple is overridden then we\n         //        should use llvm-tblgen from there, also should verify that it\n         //        actually exists most of the time in normal installs of LLVM.\n-        let host = build.llvm_out(&build.config.build).join(\"bin/llvm-tblgen\");\n+        let host = build.llvm_out(&build.build).join(\"bin/llvm-tblgen\");\n         cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n            .define(\"LLVM_TABLEGEN\", &host);\n     }\n@@ -243,7 +243,7 @@ pub fn test_helpers(build: &Build, target: &str) {\n     cfg.cargo_metadata(false)\n        .out_dir(&dst)\n        .target(target)\n-       .host(&build.config.build)\n+       .host(&build.build)\n        .opt_level(0)\n        .debug(false)\n        .file(build.src.join(\"src/rt/rust_test_helpers.c\"))"}, {"sha": "a9c1b023dd4f543413de521cfd3aa8f711bd6ad0", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 72, "deletions": 96, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -18,9 +18,9 @@\n //! In theory if we get past this phase it's a bug if a build fails, but in\n //! practice that's likely not true!\n \n-use std::collections::HashSet;\n+use std::collections::HashMap;\n use std::env;\n-use std::ffi::{OsStr, OsString};\n+use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::process::Command;\n use std::path::PathBuf;\n@@ -29,137 +29,125 @@ use build_helper::output;\n \n use Build;\n \n+struct Finder {\n+    cache: HashMap<OsString, Option<PathBuf>>,\n+    path: OsString,\n+}\n+\n+impl Finder {\n+    fn new() -> Self {\n+        Self {\n+            cache: HashMap::new(),\n+            path: env::var_os(\"PATH\").unwrap_or_default()\n+        }\n+    }\n+\n+    fn maybe_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> Option<PathBuf> {\n+        let cmd: OsString = cmd.as_ref().into();\n+        let path = self.path.clone();\n+        self.cache.entry(cmd.clone()).or_insert_with(|| {\n+            for path in env::split_paths(&path) {\n+                let target = path.join(&cmd);\n+                let mut cmd_alt = cmd.clone();\n+                cmd_alt.push(\".exe\");\n+                if target.is_file() || // some/path/git\n+                target.with_extension(\"exe\").exists() || // some/path/git.exe\n+                target.join(&cmd_alt).exists() { // some/path/git/git.exe\n+                    return Some(target);\n+                }\n+            }\n+            None\n+        }).clone()\n+    }\n+\n+    fn must_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> PathBuf {\n+        self.maybe_have(&cmd).unwrap_or_else(|| {\n+            panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd.as_ref());\n+        })\n+    }\n+}\n+\n pub fn check(build: &mut Build) {\n-    let mut checked = HashSet::new();\n-    let path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n+    let path = env::var_os(\"PATH\").unwrap_or_default();\n     // On Windows, quotes are invalid characters for filename paths, and if\n     // one is present as part of the PATH then that can lead to the system\n     // being unable to identify the files properly. See\n     // https://github.com/rust-lang/rust/issues/34959 for more details.\n-    if cfg!(windows) {\n-        if path.to_string_lossy().contains(\"\\\"\") {\n-            panic!(\"PATH contains invalid character '\\\"'\");\n-        }\n+    if cfg!(windows) && path.to_string_lossy().contains(\"\\\"\") {\n+        panic!(\"PATH contains invalid character '\\\"'\");\n     }\n-    let have_cmd = |cmd: &OsStr| {\n-        for path in env::split_paths(&path) {\n-            let target = path.join(cmd);\n-            let mut cmd_alt = cmd.to_os_string();\n-            cmd_alt.push(\".exe\");\n-            if target.is_file() ||\n-               target.with_extension(\"exe\").exists() ||\n-               target.join(cmd_alt).exists() {\n-                return Some(target);\n-            }\n-        }\n-        return None;\n-    };\n-\n-    let mut need_cmd = |cmd: &OsStr| {\n-        if !checked.insert(cmd.to_owned()) {\n-            return\n-        }\n-        if have_cmd(cmd).is_none() {\n-            panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n-        }\n-    };\n \n+    let mut cmd_finder = Finder::new();\n     // If we've got a git directory we're gona need git to update\n     // submodules and learn about various other aspects.\n-    if build.src_is_git {\n-        need_cmd(\"git\".as_ref());\n+    if build.rust_info.is_git() {\n+        cmd_finder.must_have(\"git\");\n     }\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n     let building_llvm = build.config.host.iter()\n         .filter_map(|host| build.config.target_config.get(host))\n         .any(|config| config.llvm_config.is_none());\n     if building_llvm || build.config.sanitizers {\n-        need_cmd(\"cmake\".as_ref());\n+        cmd_finder.must_have(\"cmake\");\n     }\n \n     // Ninja is currently only used for LLVM itself.\n-    if building_llvm && build.config.ninja {\n-        // Some Linux distros rename `ninja` to `ninja-build`.\n-        // CMake can work with either binary name.\n-        if have_cmd(\"ninja-build\".as_ref()).is_none() {\n-            need_cmd(\"ninja\".as_ref());\n-        }\n+    // Some Linux distros rename `ninja` to `ninja-build`.\n+    // CMake can work with either binary name.\n+    if building_llvm && build.config.ninja && cmd_finder.maybe_have(\"ninja-build\").is_none() {\n+        cmd_finder.must_have(\"ninja\");\n     }\n \n-    if build.config.python.is_none() {\n-        // set by bootstrap.py\n-        if let Some(v) = env::var_os(\"BOOTSTRAP_PYTHON\") {\n-            build.config.python = Some(PathBuf::from(v));\n-        }\n-    }\n-    if build.config.python.is_none() {\n-        build.config.python = have_cmd(\"python2.7\".as_ref());\n-    }\n-    if build.config.python.is_none() {\n-        build.config.python = have_cmd(\"python2\".as_ref());\n-    }\n-    if build.config.python.is_none() {\n-        need_cmd(\"python\".as_ref());\n-        build.config.python = Some(\"python\".into());\n-    }\n-    need_cmd(build.config.python.as_ref().unwrap().as_ref());\n+    build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n+        .or_else(|| cmd_finder.maybe_have(\"python2.7\"))\n+        .or_else(|| cmd_finder.maybe_have(\"python2\"))\n+        .or_else(|| Some(cmd_finder.must_have(\"python\")));\n \n+    build.config.nodejs = build.config.nodejs.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"node\"))\n+        .or_else(|| cmd_finder.maybe_have(\"nodejs\"));\n \n-    if let Some(ref s) = build.config.nodejs {\n-        need_cmd(s.as_ref());\n-    } else {\n-        // Look for the nodejs command, needed for emscripten testing\n-        if let Some(node) = have_cmd(\"node\".as_ref()) {\n-            build.config.nodejs = Some(node);\n-        } else if let Some(node) = have_cmd(\"nodejs\".as_ref()) {\n-            build.config.nodejs = Some(node);\n-        }\n-    }\n-\n-    if let Some(ref gdb) = build.config.gdb {\n-        need_cmd(gdb.as_ref());\n-    } else {\n-        build.config.gdb = have_cmd(\"gdb\".as_ref());\n-    }\n+    build.config.gdb = build.config.gdb.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"gdb\"));\n \n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n-    for target in build.config.target.iter() {\n+    for target in &build.config.target {\n         // On emscripten we don't actually need the C compiler to just\n         // build the target artifacts, only for testing. For the sake\n         // of easier bot configuration, just skip detection.\n         if target.contains(\"emscripten\") {\n             continue;\n         }\n \n-        need_cmd(build.cc(target).as_ref());\n+        cmd_finder.must_have(build.cc(target));\n         if let Some(ar) = build.ar(target) {\n-            need_cmd(ar.as_ref());\n+            cmd_finder.must_have(ar);\n         }\n     }\n-    for host in build.config.host.iter() {\n-        need_cmd(build.cxx(host).unwrap().as_ref());\n-    }\n \n-    // The msvc hosts don't use jemalloc, turn it off globally to\n-    // avoid packaging the dummy liballoc_jemalloc on that platform.\n     for host in build.config.host.iter() {\n+        cmd_finder.must_have(build.cxx(host).unwrap());\n+\n+        // The msvc hosts don't use jemalloc, turn it off globally to\n+        // avoid packaging the dummy liballoc_jemalloc on that platform.\n         if host.contains(\"msvc\") {\n             build.config.use_jemalloc = false;\n         }\n     }\n \n     // Externally configured LLVM requires FileCheck to exist\n-    let filecheck = build.llvm_filecheck(&build.config.build);\n+    let filecheck = build.llvm_filecheck(&build.build);\n     if !filecheck.starts_with(&build.out) && !filecheck.exists() && build.config.codegen_tests {\n         panic!(\"FileCheck executable {:?} does not exist\", filecheck);\n     }\n \n-    for target in build.config.target.iter() {\n+    for target in &build.config.target {\n         // Can't compile for iOS unless we're on macOS\n         if target.contains(\"apple-ios\") &&\n-           !build.config.build.contains(\"apple-darwin\") {\n+           !build.build.contains(\"apple-darwin\") {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n@@ -206,18 +194,6 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n         }\n     }\n \n-    for host in build.flags.host.iter() {\n-        if !build.config.host.contains(host) {\n-            panic!(\"specified host `{}` is not in the ./configure list\", host);\n-        }\n-    }\n-    for target in build.flags.target.iter() {\n-        if !build.config.target.contains(target) {\n-            panic!(\"specified target `{}` is not in the ./configure list\",\n-                   target);\n-        }\n-    }\n-\n     let run = |cmd: &mut Command| {\n         cmd.output().map(|output| {\n             String::from_utf8_lossy(&output.stdout)\n@@ -231,6 +207,6 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     }\n \n     if let Some(ref s) = build.config.ccache {\n-        need_cmd(s.as_ref());\n+        cmd_finder.must_have(s);\n     }\n }"}, {"sha": "c221d7076832fa6aee6b5d7b363d6d29d30a4fbd", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 63, "deletions": 71, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -104,10 +104,10 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"llvm\", \"src/llvm\")\n          .host(true)\n          .dep(move |s| {\n-             if s.target == build.config.build {\n+             if s.target == build.build {\n                  Step::noop()\n              } else {\n-                 s.target(&build.config.build)\n+                 s.target(&build.build)\n              }\n          })\n          .run(move |s| native::llvm(build, s.target));\n@@ -124,7 +124,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                  Step::noop()\n              } else {\n                  s.name(\"librustc\")\n-                  .host(&build.config.build)\n+                  .host(&build.build)\n                   .stage(s.stage - 1)\n              }\n          })\n@@ -148,7 +148,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                 }\n             }\n         }\n-        return ret\n+        ret\n     };\n \n     // ========================================================================\n@@ -215,29 +215,29 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n         let mut rule = rules.build(&krate, \"path/to/nowhere\");\n         rule.dep(move |s| {\n                 if build.force_use_stage1(&s.compiler(), s.target) {\n-                    s.host(&build.config.build).stage(1)\n-                } else if s.host == build.config.build {\n+                    s.host(&build.build).stage(1)\n+                } else if s.host == build.build {\n                     s.name(dep)\n                 } else {\n-                    s.host(&build.config.build)\n+                    s.host(&build.build)\n                 }\n             })\n             .run(move |s| {\n                 if build.force_use_stage1(&s.compiler(), s.target) {\n                     link(build,\n-                         &s.stage(1).host(&build.config.build).compiler(),\n+                         &s.stage(1).host(&build.build).compiler(),\n                          &s.compiler(),\n                          s.target)\n-                } else if s.host == build.config.build {\n+                } else if s.host == build.build {\n                     link(build, &s.compiler(), &s.compiler(), s.target)\n                 } else {\n                     link(build,\n-                         &s.host(&build.config.build).compiler(),\n+                         &s.host(&build.build).compiler(),\n                          &s.compiler(),\n                          s.target)\n                 }\n             });\n-            return rule\n+            rule\n     }\n \n     // Similar to the `libstd`, `libtest`, and `librustc` rules above, except\n@@ -269,7 +269,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     for (krate, path, _default) in krates(\"std\") {\n         rules.build(&krate.build_step, path)\n              .dep(|s| s.name(\"startup-objects\"))\n-             .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(s.host))\n+             .dep(move |s| s.name(\"rustc\").host(&build.build).target(s.host))\n              .run(move |s| compile::std(build, s.target, &s.compiler()));\n     }\n     for (krate, path, _default) in krates(\"test\") {\n@@ -280,7 +280,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.build(&krate.build_step, path)\n              .dep(|s| s.name(\"libtest-link\"))\n-             .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n+             .dep(move |s| s.name(\"llvm\").host(&build.build).stage(0))\n              .dep(|s| s.name(\"may-run-build-script\"))\n              .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n     }\n@@ -291,8 +291,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"may-run-build-script\", \"path/to/nowhere\")\n          .dep(move |s| {\n              s.name(\"libstd-link\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n          });\n     rules.build(\"startup-objects\", \"src/rtstartup\")\n          .dep(|s| s.name(\"create-sysroot\").target(s.host))\n@@ -332,7 +332,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n               \"incremental\");\n     }\n \n-    if build.config.build.contains(\"msvc\") {\n+    if build.build.contains(\"msvc\") {\n         // nothing to do for debuginfo tests\n     } else {\n         rules.test(\"check-debuginfo-lldb\", \"src/test/debuginfo-lldb\")\n@@ -352,7 +352,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                                          \"debuginfo-gdb\", \"debuginfo\"));\n         let mut rule = rules.test(\"check-debuginfo\", \"src/test/debuginfo\");\n         rule.default(true);\n-        if build.config.build.contains(\"apple\") {\n+        if build.build.contains(\"apple\") {\n             rule.dep(|s| s.name(\"check-debuginfo-lldb\"));\n         } else {\n             rule.dep(|s| s.name(\"check-debuginfo-gdb\"));\n@@ -594,8 +594,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n              // Cargo depends on procedural macros, which requires a full host\n              // compiler to be available, so we need to depend on that.\n              s.name(\"librustc-link\")\n-              .target(&build.config.build)\n-              .host(&build.config.build)\n+              .target(&build.build)\n+              .host(&build.build)\n          })\n          .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n     rules.build(\"tool-rls\", \"src/tools/rls\")\n@@ -606,8 +606,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(move |s| {\n              // rls, like cargo, uses procedural macros\n              s.name(\"librustc-link\")\n-              .target(&build.config.build)\n-              .host(&build.config.build)\n+              .target(&build.build)\n+              .host(&build.build)\n          })\n          .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n \n@@ -635,35 +635,35 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.doc(\"doc-book\", \"src/doc/book\")\n          .dep(move |s| {\n              s.name(\"tool-rustbook\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::book(build, s.target, \"book\"));\n     rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n          .dep(move |s| {\n              s.name(\"tool-rustbook\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n     rules.doc(\"doc-reference\", \"src/doc/reference\")\n          .dep(move |s| {\n              s.name(\"tool-rustbook\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n     rules.doc(\"doc-unstable-book\", \"src/doc/unstable-book\")\n          .dep(move |s| {\n              s.name(\"tool-rustbook\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .dep(move |s| s.name(\"doc-unstable-book-gen\"))\n@@ -675,23 +675,23 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.doc(\"doc-standalone\", \"src/doc\")\n          .dep(move |s| {\n              s.name(\"rustc\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::standalone(build, s.target));\n     rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n-         .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build).stage(0))\n+         .dep(move |s| s.name(\"tool-error-index\").target(&build.build).stage(0))\n          .dep(move |s| s.name(\"librustc-link\"))\n          .default(build.config.docs)\n          .host(true)\n          .run(move |s| doc::error_index(build, s.target));\n     rules.doc(\"doc-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n          .dep(move |s| {\n              s.name(\"tool-unstable-book-gen\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .dep(move |s| s.name(\"libstd-link\"))\n@@ -725,7 +725,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     // ========================================================================\n     // Distribution targets\n     rules.dist(\"dist-rustc\", \"src/librustc\")\n-         .dep(move |s| s.name(\"rustc\").host(&build.config.build))\n+         .dep(move |s| s.name(\"rustc\").host(&build.build))\n          .host(true)\n          .only_host_build(true)\n          .default(true)\n@@ -811,7 +811,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .host(true)\n          .only_build(true)\n          .only_host_build(true)\n-         .dep(move |s| s.name(\"tool-build-manifest\").target(&build.config.build).stage(0))\n+         .dep(move |s| s.name(\"tool-build-manifest\").target(&build.build).stage(0))\n          .run(move |_| dist::hash_and_sign(build));\n \n     rules.install(\"install-docs\", \"src/doc\")\n@@ -861,8 +861,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     /// Helper to depend on a stage0 build-only rust-installer tool.\n     fn tool_rust_installer<'a>(build: &'a Build, step: &Step<'a>) -> Step<'a> {\n         step.name(\"tool-rust-installer\")\n-            .host(&build.config.build)\n-            .target(&build.config.build)\n+            .host(&build.build)\n+            .target(&build.build)\n             .stage(0)\n     }\n }\n@@ -1058,8 +1058,8 @@ impl<'a> Rules<'a> {\n             build: build,\n             sbuild: Step {\n                 stage: build.flags.stage.unwrap_or(2),\n-                target: &build.config.build,\n-                host: &build.config.build,\n+                target: &build.build,\n+                host: &build.build,\n                 name: \"\",\n             },\n             rules: BTreeMap::new(),\n@@ -1218,16 +1218,9 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n \n         rules.into_iter().flat_map(|(rule, _)| {\n             let hosts = if rule.only_host_build || rule.only_build {\n-                &self.build.config.host[..1]\n-            } else if self.build.flags.host.len() > 0 {\n-                &self.build.flags.host\n+                self.build.build_slice()\n             } else {\n-                &self.build.config.host\n-            };\n-            let targets = if self.build.flags.target.len() > 0 {\n-                &self.build.flags.target\n-            } else {\n-                &self.build.config.target\n+                &self.build.hosts\n             };\n             // Determine the actual targets participating in this rule.\n             // NOTE: We should keep the full projection from build triple to\n@@ -1236,19 +1229,18 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             // the original non-shadowed hosts array is used below.\n             let arr = if rule.host {\n                 // If --target was specified but --host wasn't specified,\n-                // don't run any host-only tests. Also, respect any `--host`\n-                // overrides as done for `hosts`.\n+                // don't run any host-only tests.\n                 if self.build.flags.host.len() > 0 {\n-                    &self.build.flags.host[..]\n+                    &self.build.hosts\n                 } else if self.build.flags.target.len() > 0 {\n                     &[]\n                 } else if rule.only_build {\n-                    &self.build.config.host[..1]\n+                    self.build.build_slice()\n                 } else {\n-                    &self.build.config.host[..]\n+                    &self.build.hosts\n                 }\n             } else {\n-                targets\n+                &self.build.targets\n             };\n \n             hosts.iter().flat_map(move |host| {\n@@ -1326,7 +1318,7 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         for idx in 0..nodes.len() {\n             self.topo_sort(idx, &idx_to_node, &edges, &mut visited, &mut order);\n         }\n-        return order\n+        order\n     }\n \n     /// Builds the dependency graph rooted at `step`.\n@@ -1365,7 +1357,7 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         }\n \n         edges.entry(idx).or_insert(HashSet::new()).extend(deps);\n-        return idx\n+        idx\n     }\n \n     /// Given a dependency graph with a finished list of `nodes`, fill out more\n@@ -1494,8 +1486,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(plan.contains(&step.name(\"dist-docs\")));\n@@ -1517,8 +1509,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(plan.contains(&step.name(\"dist-docs\")));\n@@ -1545,8 +1537,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(!plan.iter().any(|s| s.host == \"B\"));\n@@ -1575,8 +1567,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(!plan.iter().any(|s| s.host == \"B\"));\n@@ -1612,8 +1604,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(!plan.iter().any(|s| s.target == \"A\"));\n@@ -1639,8 +1631,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(!plan.iter().any(|s| s.target == \"A\"));\n@@ -1683,8 +1675,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         // rustc built for all for of (A, B) x (A, B)"}, {"sha": "092fb04637ba72da2e0ec80fb421e4dcaee1dd24", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,7 +14,6 @@\n //! not a lot of interesting happenings here unfortunately.\n \n use std::env;\n-use std::ffi::OsString;\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n@@ -32,16 +31,9 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Copies a file from `src` to `dst`, attempting to use hard links and then\n-/// falling back to an actually filesystem copy if necessary.\n+/// Copies a file from `src` to `dst`\n pub fn copy(src: &Path, dst: &Path) {\n-    // A call to `hard_link` will fail if `dst` exists, so remove it if it\n-    // already exists so we can try to help `hard_link` succeed.\n     let _ = fs::remove_file(&dst);\n-\n-    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n-    // windows), but if that fails just fall back to a slow `copy` operation.\n-    // let res = fs::hard_link(src, dst);\n     let res = fs::copy(src, dst);\n     if let Err(e) = res {\n         panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n@@ -149,8 +141,7 @@ pub fn dylib_path_var() -> &'static str {\n /// Parses the `dylib_path_var()` environment variable, returning a list of\n /// paths that are members of this lookup path.\n pub fn dylib_path() -> Vec<PathBuf> {\n-    env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n-        .collect()\n+    env::split_paths(&env::var_os(dylib_path_var()).unwrap_or_default()).collect()\n }\n \n /// `push` all components to `buf`. On windows, append `.exe` to the last component.\n@@ -422,4 +413,4 @@ impl CiEnv {\n             cmd.env(\"TERM\", \"xterm\").args(&[\"--color\", \"always\"]);\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "4b24c0a6a0d39fb9e38c5d5ea2d96f01a5ecfecf", "filename": "src/doc/unstable-book/src/language-features/compile-error.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcompile-error.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcompile-error.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcompile-error.md?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is: [#40872]\n \n-[#29599]: https://github.com/rust-lang/rust/issues/40872\n+[#40872]: https://github.com/rust-lang/rust/issues/40872\n \n ------------------------\n "}, {"sha": "a2368ee5f4ac53f7a45e9c4fcbaba3752038ac4e", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -143,7 +143,8 @@ pub extern fn rust_eh_unwind_resume() {\n #[no_mangle]\n pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n                                _file: &'static str,\n-                               _line: u32) -> ! {\n+                               _line: u32,\n+                               _column: u32) -> ! {\n     unsafe { intrinsics::abort() }\n }\n ```\n@@ -187,7 +188,8 @@ pub extern fn rust_eh_unwind_resume() {\n #[no_mangle]\n pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n                                _file: &'static str,\n-                               _line: u32) -> ! {\n+                               _line: u32,\n+                               _column: u32) -> ! {\n     unsafe { intrinsics::abort() }\n }\n ```"}, {"sha": "200a9c19462caa8a97c2d37449f785b80eab6ade", "filename": "src/doc/unstable-book/src/language-features/unsized-tuple-coercion.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-tuple-coercion.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-tuple-coercion.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-tuple-coercion.md?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,27 @@\n+# `unsized_tuple_coercion`\n+\n+The tracking issue for this feature is: [#42877]\n+\n+[#42877]: https://github.com/rust-lang/rust/issues/42877\n+\n+------------------------\n+\n+This is a part of [RFC0401]. According to the RFC, there should be an implementation like this:\n+\n+```rust\n+impl<..., T, U: ?Sized> Unsized<(..., U)> for (..., T) where T: Unsized<U> {}\n+```\n+\n+This implementation is currently gated behind `#[feature(unsized_tuple_coercion)]` to avoid insta-stability. Therefore you can use it like this:\n+\n+```rust\n+#![feature(unsized_tuple_coercion)]\n+\n+fn main() {\n+    let x : ([i32; 3], [i32; 3]) = ([1, 2, 3], [4, 5, 6]);\n+    let y : &([i32; 3], [i32]) = &x;\n+    assert_eq!(y.1[0], 4);\n+}\n+```\n+\n+[RFC0401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md"}, {"sha": "ebeb5f6a1de51d2f72f5404d65de360f5c7cdae7", "filename": "src/doc/unstable-book/src/library-features/iterator-for-each.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-for-each.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-for-each.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-for-each.md?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,17 @@\n+# `iterator_for_each`\n+\n+The tracking issue for this feature is: [#42986]\n+\n+[#42986]: https://github.com/rust-lang/rust/issues/42986\n+\n+------------------------\n+\n+To call a closure on each element of an iterator, you can use `for_each`:\n+\n+```rust\n+#![feature(iterator_for_each)]\n+\n+fn main() {\n+    (0..10).for_each(|i| println!(\"{}\", i));\n+}\n+```"}, {"sha": "c84f40e7ee551ffa53a4e3abb710f7cfef45432d", "filename": "src/doc/unstable-book/src/library-features/more-io-inner-methods.md", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d316874c87e25669895c306658e15aa3746d66ab/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmore-io-inner-methods.md", "raw_url": "https://github.com/rust-lang/rust/raw/d316874c87e25669895c306658e15aa3746d66ab/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmore-io-inner-methods.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmore-io-inner-methods.md?ref=d316874c87e25669895c306658e15aa3746d66ab", "patch": "@@ -1,11 +0,0 @@\n-# `more_io_inner_methods`\n-\n-The tracking issue for this feature is: [#41519]\n-\n-[#41519]: https://github.com/rust-lang/rust/issues/41519\n-\n-------------------------\n-\n-This feature enables several internal accessor methods on structures in\n-`std::io` including `Take::{get_ref, get_mut}` and `Chain::{into_inner, get_ref,\n-get_mut}`."}, {"sha": "9effcfc774c7743bc55a7756741ed2ad263680ff", "filename": "src/doc/unstable-book/src/library-features/sort-unstable.md", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d316874c87e25669895c306658e15aa3746d66ab/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsort-unstable.md", "raw_url": "https://github.com/rust-lang/rust/raw/d316874c87e25669895c306658e15aa3746d66ab/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsort-unstable.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsort-unstable.md?ref=d316874c87e25669895c306658e15aa3746d66ab", "patch": "@@ -1,40 +0,0 @@\n-# `sort_unstable`\n-\n-The tracking issue for this feature is: [#40585]\n-\n-[#40585]: https://github.com/rust-lang/rust/issues/40585\n-\n-------------------------\n-\n-The default `sort` method on slices is stable. In other words, it guarantees\n-that the original order of equal elements is preserved after sorting. The\n-method has several undesirable characteristics:\n-\n-1. It allocates a sizable chunk of memory.\n-2. If you don't need stability, it is not as performant as it could be.\n-\n-An alternative is the new `sort_unstable` feature, which includes these\n-methods for sorting slices:\n-\n-1. `sort_unstable`\n-2. `sort_unstable_by`\n-3. `sort_unstable_by_key`\n-\n-Unstable sorting is generally faster and makes no allocations. The majority\n-of real-world sorting needs doesn't require stability, so these methods can\n-very often come in handy.\n-\n-Another important difference is that `sort` lives in `libstd` and\n-`sort_unstable` lives in `libcore`. The reason is that the former makes\n-allocations and the latter doesn't.\n-\n-A simple example:\n-\n-```rust\n-#![feature(sort_unstable)]\n-\n-let mut v = [-5, 4, 1, -3, 2];\n-\n-v.sort_unstable();\n-assert!(v == [-5, -3, 1, 2, 4]);\n-```"}, {"sha": "bf38629ed38a7a344eb5214842a49c340428fab1", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -873,7 +873,7 @@ pub unsafe trait Alloc {\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            unsafe { self.alloc(k).map(|p|Unique::new(*p as *mut T)) }\n+            unsafe { self.alloc(k).map(|p| Unique::new(p as *mut T)) }\n         } else {\n             Err(AllocErr::invalid_input(\"zero-sized type invalid for alloc_one\"))\n         }"}, {"sha": "174628ccd0788e5eeeea962274542138cd643ad4", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,9 +14,9 @@\n #![feature(rand)]\n #![feature(repr_simd)]\n #![feature(slice_rotate)]\n-#![feature(sort_unstable)]\n #![feature(test)]\n \n+extern crate rand;\n extern crate test;\n \n mod btree;"}, {"sha": "d99270e7f311e20c0e54c32622a48f42301a3b5d", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{mem, ptr};\n-use std::__rand::{Rng, thread_rng};\n+use std::__rand::{thread_rng};\n+use std::mem;\n+use std::ptr;\n \n+use rand::{Rng, SeedableRng, XorShiftRng};\n use test::{Bencher, black_box};\n \n #[bench]\n@@ -191,17 +193,17 @@ fn gen_descending(len: usize) -> Vec<u64> {\n }\n \n fn gen_random(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter::<u64>().take(len).collect()\n }\n \n fn gen_random_bytes(len: usize) -> Vec<u8> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter::<u8>().take(len).collect()\n }\n \n fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = gen_ascending(len);\n     for _ in (0usize..).take_while(|x| x * x <= len) {\n         let x = rng.gen::<usize>() % len;\n@@ -212,7 +214,7 @@ fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n }\n \n fn gen_mostly_descending(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = gen_descending(len);\n     for _ in (0usize..).take_while(|x| x * x <= len) {\n         let x = rng.gen::<usize>() % len;\n@@ -223,7 +225,7 @@ fn gen_mostly_descending(len: usize) -> Vec<u64> {\n }\n \n fn gen_strings(len: usize) -> Vec<String> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = vec![];\n     for _ in 0..len {\n         let n = rng.gen::<usize>() % 20 + 1;\n@@ -233,26 +235,40 @@ fn gen_strings(len: usize) -> Vec<String> {\n }\n \n fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n }\n \n macro_rules! sort {\n     ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n-            b.iter(|| $gen($len).$f());\n+            let v = $gen($len);\n+            b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n     }\n }\n \n+macro_rules! sort_strings {\n+    ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n+            let v = v.iter().map(|s| &**s).collect::<Vec<&str>>();\n+            b.iter(|| v.clone().$f());\n+            b.bytes = $len * mem::size_of::<&str>() as u64;\n+        }\n+    }\n+}\n+\n macro_rules! sort_expensive {\n     ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n             b.iter(|| {\n-                let mut v = $gen($len);\n+                let mut v = v.clone();\n                 let mut count = 0;\n                 v.$f(|a: &u64, b: &u64| {\n                     count += 1;\n@@ -263,38 +279,38 @@ macro_rules! sort_expensive {\n                 });\n                 black_box(count);\n             });\n-            b.bytes = $len as u64 * mem::size_of::<u64>() as u64;\n+            b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n     }\n }\n \n sort!(sort, sort_small_ascending, gen_ascending, 10);\n sort!(sort, sort_small_descending, gen_descending, 10);\n sort!(sort, sort_small_random, gen_random, 10);\n-sort!(sort, sort_small_big_random, gen_big_random, 10);\n+sort!(sort, sort_small_big, gen_big_random, 10);\n sort!(sort, sort_medium_random, gen_random, 100);\n sort!(sort, sort_large_ascending, gen_ascending, 10000);\n sort!(sort, sort_large_descending, gen_descending, 10000);\n sort!(sort, sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n sort!(sort, sort_large_mostly_descending, gen_mostly_descending, 10000);\n sort!(sort, sort_large_random, gen_random, 10000);\n-sort!(sort, sort_large_big_random, gen_big_random, 10000);\n-sort!(sort, sort_large_strings, gen_strings, 10000);\n-sort_expensive!(sort_by, sort_large_random_expensive, gen_random, 10000);\n+sort!(sort, sort_large_big, gen_big_random, 10000);\n+sort_strings!(sort, sort_large_strings, gen_strings, 10000);\n+sort_expensive!(sort_by, sort_large_expensive, gen_random, 10000);\n \n sort!(sort_unstable, sort_unstable_small_ascending, gen_ascending, 10);\n sort!(sort_unstable, sort_unstable_small_descending, gen_descending, 10);\n sort!(sort_unstable, sort_unstable_small_random, gen_random, 10);\n-sort!(sort_unstable, sort_unstable_small_big_random, gen_big_random, 10);\n+sort!(sort_unstable, sort_unstable_small_big, gen_big_random, 10);\n sort!(sort_unstable, sort_unstable_medium_random, gen_random, 100);\n sort!(sort_unstable, sort_unstable_large_ascending, gen_ascending, 10000);\n sort!(sort_unstable, sort_unstable_large_descending, gen_descending, 10000);\n sort!(sort_unstable, sort_unstable_large_mostly_ascending, gen_mostly_ascending, 10000);\n sort!(sort_unstable, sort_unstable_large_mostly_descending, gen_mostly_descending, 10000);\n sort!(sort_unstable, sort_unstable_large_random, gen_random, 10000);\n-sort!(sort_unstable, sort_unstable_large_big_random, gen_big_random, 10000);\n-sort!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n-sort_expensive!(sort_unstable_by, sort_unstable_large_random_expensive, gen_random, 10000);\n+sort!(sort_unstable, sort_unstable_large_big, gen_big_random, 10000);\n+sort_strings!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n+sort_expensive!(sort_unstable_by, sort_unstable_large_expensive, gen_random, 10000);\n \n macro_rules! reverse {\n     ($name:ident, $ty:ty, $f:expr) => {"}, {"sha": "4847b21c0b3b5d4c9f9d87653befd5d5b5cca94e", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -498,12 +498,10 @@ pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n \n use string;\n \n-/// The format function takes a precompiled format string and a list of\n-/// arguments, to return the resulting formatted string.\n+/// The `format` function takes an `Arguments` struct and returns the resulting\n+/// formatted string.\n ///\n-/// # Arguments\n-///\n-///   * args - a structure of arguments generated via the `format_args!` macro.\n+/// The `Arguments` instance can be created with the `format_args!` macro.\n ///\n /// # Examples\n ///"}, {"sha": "23da29131362e6c3e0773668df58d5f30929200a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -83,7 +83,6 @@\n #![cfg_attr(not(test), feature(core_float))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![cfg_attr(not(test), feature(slice_rotate))]\n-#![cfg_attr(not(test), feature(sort_unstable))]\n #![cfg_attr(not(test), feature(str_checked_slicing))]\n #![cfg_attr(test, feature(rand, test))]\n #![feature(allocator)]"}, {"sha": "f4c2b9d054b4faf7019f7225795cb4456e4f7b08", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1144,6 +1144,10 @@ impl<T> [T] {\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n+    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n+    /// sorting and it doesn't allocate auxiliary memory.\n+    /// See [`sort_unstable`](#method.sort_unstable).\n+    ///\n     /// # Current implementation\n     ///\n     /// The current algorithm is an adaptive, iterative merge sort inspired by\n@@ -1174,6 +1178,10 @@ impl<T> [T] {\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n+    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n+    /// sorting and it doesn't allocate auxiliary memory.\n+    /// See [`sort_unstable_by`](#method.sort_unstable_by).\n+    ///\n     /// # Current implementation\n     ///\n     /// The current algorithm is an adaptive, iterative merge sort inspired by\n@@ -1207,6 +1215,10 @@ impl<T> [T] {\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n+    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n+    /// sorting and it doesn't allocate auxiliary memory.\n+    /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n+    ///\n     /// # Current implementation\n     ///\n     /// The current algorithm is an adaptive, iterative merge sort inspired by\n@@ -1251,17 +1263,14 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sort_unstable)]\n-    ///\n     /// let mut v = [-5, 4, 1, -3, 2];\n     ///\n     /// v.sort_unstable();\n     /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n-    // FIXME #40585: Mention `sort_unstable` in the documentation for `sort`.\n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n     pub fn sort_unstable(&mut self)\n         where T: Ord\n@@ -1288,8 +1297,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sort_unstable)]\n-    ///\n     /// let mut v = [5, 4, 1, 3, 2];\n     /// v.sort_unstable_by(|a, b| a.cmp(b));\n     /// assert!(v == [1, 2, 3, 4, 5]);\n@@ -1300,8 +1307,7 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n-    // FIXME #40585: Mention `sort_unstable_by` in the documentation for `sort_by`.\n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n     pub fn sort_unstable_by<F>(&mut self, compare: F)\n         where F: FnMut(&T, &T) -> Ordering\n@@ -1328,17 +1334,14 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sort_unstable)]\n-    ///\n     /// let mut v = [-5i32, 4, 1, -3, 2];\n     ///\n     /// v.sort_unstable_by_key(|k| k.abs());\n     /// assert!(v == [1, 2, -3, 4, -5]);\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n-    // FIXME #40585: Mention `sort_unstable_by_key` in the documentation for `sort_by_key`.\n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n     pub fn sort_unstable_by_key<B, F>(&mut self, f: F)\n         where F: FnMut(&T) -> B,\n@@ -1794,7 +1797,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n \n     impl<T> Drop for MergeHole<T> {\n         fn drop(&mut self) {\n-            // `T` is not a zero-sized type, so it's okay to divide by it's size.\n+            // `T` is not a zero-sized type, so it's okay to divide by its size.\n             let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n             unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n         }\n@@ -1908,7 +1911,7 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n     // algorithm should continue building a new run instead, `None` is returned.\n     //\n-    // TimSort is infamous for it's buggy implementations, as described here:\n+    // TimSort is infamous for its buggy implementations, as described here:\n     // http://envisage-project.eu/timsort-specification-and-verification/\n     //\n     // The gist of the story is: we must enforce the invariants on the top four runs on the stack."}, {"sha": "622cc68964bf7061cc49d3832a69bbc63186c81c", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -2008,10 +2008,10 @@ impl From<Box<str>> for String {\n     }\n }\n \n-#[stable(feature = \"box_from_str\", since = \"1.18.0\")]\n-impl Into<Box<str>> for String {\n-    fn into(self) -> Box<str> {\n-        self.into_boxed_str()\n+#[stable(feature = \"box_from_str\", since = \"1.20.0\")]\n+impl From<String> for Box<str> {\n+    fn from(s: String) -> Box<str> {\n+        s.into_boxed_str()\n     }\n }\n "}, {"sha": "c53bf15f1bfb6263fe861c643defab423ffa3dd7", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -396,18 +396,44 @@ fn test_sort() {\n     let mut rng = thread_rng();\n \n     for len in (2..25).chain(500..510) {\n-        for _ in 0..100 {\n-            let mut v: Vec<_> = rng.gen_iter::<i32>().take(len).collect();\n-            let mut v1 = v.clone();\n-\n-            v.sort();\n-            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-            v1.sort_by(|a, b| a.cmp(b));\n-            assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n-\n-            v1.sort_by(|a, b| b.cmp(a));\n-            assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..10 {\n+                let orig: Vec<_> = rng.gen_iter::<i32>()\n+                    .map(|x| x % modulus)\n+                    .take(len)\n+                    .collect();\n+\n+                // Sort in default order.\n+                let mut v = orig.clone();\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| a.cmp(b));\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| b.cmp(a));\n+                assert!(v.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Sort with many pre-sorted runs.\n+                let mut v = orig.clone();\n+                v.sort();\n+                v.reverse();\n+                for _ in 0..5 {\n+                    let a = rng.gen::<usize>() % len;\n+                    let b = rng.gen::<usize>() % len;\n+                    if a < b {\n+                        v[a..b].reverse();\n+                    } else {\n+                        v.swap(a, b);\n+                    }\n+                }\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+            }\n         }\n     }\n "}, {"sha": "17f1229c2060ef2145c377c122ee8e3996ca5e87", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -274,6 +274,11 @@ fn test_dedup_by() {\n     vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n \n     assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n+\n+    let mut vec = vec![(\"foo\", 1), (\"foo\", 2), (\"bar\", 3), (\"bar\", 4), (\"bar\", 5)];\n+    vec.dedup_by(|a, b| a.0 == b.0 && { b.1 += a.1; true });\n+\n+    assert_eq!(vec, [(\"foo\", 3), (\"bar\", 12)]);\n }\n \n #[test]"}, {"sha": "f2935c05d4f7a90ac3112b0481fdac7057562652", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -510,8 +510,7 @@ fn test_from_iter() {\n     let u: Vec<_> = deq.iter().cloned().collect();\n     assert_eq!(u, v);\n \n-    // FIXME #27741: Remove `.skip(0)` when Range::step_by is fully removed\n-    let seq = (0..).skip(0).step_by(2).take(256);\n+    let seq = (0..).step_by(2).take(256);\n     let deq: VecDeque<_> = seq.collect();\n     for (i, &x) in deq.iter().enumerate() {\n         assert_eq!(2 * i, x);"}, {"sha": "780a51aec3bab4b9a0450b3d8394c7119bb26ed8", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -222,7 +222,7 @@ use Bound::{Excluded, Included, Unbounded};\n /// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n /// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n /// the `Vec` may not report a [`capacity`] of 0*. `Vec` will allocate if and only\n-/// if [`mem::size_of::<T>`]` * capacity() > 0`. In general, `Vec`'s allocation\n+/// if [`mem::size_of::<T>`]`() * capacity() > 0`. In general, `Vec`'s allocation\n /// details are subtle enough that it is strongly recommended that you only\n /// free memory allocated by a `Vec` by creating a new `Vec` and dropping it.\n ///\n@@ -823,7 +823,8 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes consecutive elements in the vector that resolve to the same key.\n+    /// Removes all but the first of consecutive elements in the vector that resolve to the same\n+    /// key.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///\n@@ -842,11 +843,13 @@ impl<T> Vec<T> {\n         self.dedup_by(|a, b| key(a) == key(b))\n     }\n \n-    /// Removes consecutive elements in the vector according to a predicate.\n+    /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n+    /// relation.\n     ///\n     /// The `same_bucket` function is passed references to two elements from the vector, and\n-    /// returns `true` if the elements compare equal, or `false` if they do not. Only the first\n-    /// of adjacent equal items is kept.\n+    /// returns `true` if the elements compare equal, or `false` if they do not. The elements are\n+    /// passed in opposite order from their order in the vector, so if `same_bucket(a, b)` returns\n+    /// `true`, `a` is removed.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///"}, {"sha": "085f62f4b0f26675383619d92d6a86e878055f79", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -137,8 +137,6 @@ fn main() {\n         cmd.arg(\"--enable-debug\");\n     }\n \n-    // Turn off broken quarantine (see jemalloc/jemalloc#161)\n-    cmd.arg(\"--disable-fill\");\n     cmd.arg(format!(\"--host={}\", build_helper::gnu_target(&target)));\n     cmd.arg(format!(\"--build={}\", build_helper::gnu_target(&host)));\n "}, {"sha": "5b06229c21f23367f0682273c1926884659afe12", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -99,3 +99,50 @@ fn bench_zip_add(b: &mut Bencher) {\n         add_zip(&source, &mut dst)\n     });\n }\n+\n+/// `Iterator::for_each` implemented as a plain loop.\n+fn for_each_loop<I, F>(iter: I, mut f: F) where\n+    I: Iterator, F: FnMut(I::Item)\n+{\n+    for item in iter {\n+        f(item);\n+    }\n+}\n+\n+/// `Iterator::for_each` implemented with `fold` for internal iteration.\n+/// (except when `by_ref()` effectively disables that optimization.)\n+fn for_each_fold<I, F>(iter: I, mut f: F) where\n+    I: Iterator, F: FnMut(I::Item)\n+{\n+    iter.fold((), move |(), item| f(item));\n+}\n+\n+#[bench]\n+fn bench_for_each_chain_loop(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut acc = 0;\n+        let iter = (0i64..1000000).chain(0..1000000).map(black_box);\n+        for_each_loop(iter, |x| acc += x);\n+        acc\n+    });\n+}\n+\n+#[bench]\n+fn bench_for_each_chain_fold(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut acc = 0;\n+        let iter = (0i64..1000000).chain(0..1000000).map(black_box);\n+        for_each_fold(iter, |x| acc += x);\n+        acc\n+    });\n+}\n+\n+#[bench]\n+fn bench_for_each_chain_ref_fold(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut acc = 0;\n+        let mut iter = (0i64..1000000).chain(0..1000000).map(black_box);\n+        for_each_fold(iter.by_ref(), |x| acc += x);\n+        acc\n+    });\n+}"}, {"sha": "f133bd93c9178560b852f0c675f52425dab6fde9", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -335,18 +335,17 @@ impl Ordering {\n /// Example usage:\n ///\n /// ```\n-/// #![feature(reverse_cmp_key)]\n /// use std::cmp::Reverse;\n ///\n /// let mut v = vec![1, 2, 3, 4, 5, 6];\n /// v.sort_by_key(|&num| (num > 3, Reverse(num)));\n /// assert_eq!(v, vec![3, 2, 1, 6, 5, 4]);\n /// ```\n #[derive(PartialEq, Eq, Debug)]\n-#[unstable(feature = \"reverse_cmp_key\", issue = \"40893\")]\n-pub struct Reverse<T>(pub T);\n+#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n+pub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n \n-#[unstable(feature = \"reverse_cmp_key\", issue = \"40893\")]\n+#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n impl<T: PartialOrd> PartialOrd for Reverse<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n@@ -363,7 +362,7 @@ impl<T: PartialOrd> PartialOrd for Reverse<T> {\n     fn gt(&self, other: &Self) -> bool { other.0 > self.0 }\n }\n \n-#[unstable(feature = \"reverse_cmp_key\", issue = \"40893\")]\n+#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n impl<T: Ord> Ord for Reverse<T> {\n     #[inline]\n     fn cmp(&self, other: &Reverse<T>) -> Ordering {\n@@ -380,8 +379,9 @@ impl<T: Ord> Ord for Reverse<T> {\n ///\n /// ## Derivable\n ///\n-/// This trait can be used with `#[derive]`. When `derive`d, it will produce a lexicographic\n-/// ordering based on the top-to-bottom declaration order of the struct's members.\n+/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n+/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n+/// When `derive`d on enums, variants are ordered by their top-to-bottom declaration order.\n ///\n /// ## How can I implement `Ord`?\n ///\n@@ -513,8 +513,9 @@ impl PartialOrd for Ordering {\n ///\n /// ## Derivable\n ///\n-/// This trait can be used with `#[derive]`. When `derive`d, it will produce a lexicographic\n-/// ordering based on the top-to-bottom declaration order of the struct's members.\n+/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n+/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n+/// When `derive`d on enums, variants are ordered by their top-to-bottom declaration order.\n ///\n /// ## How can I implement `PartialOrd`?\n ///"}, {"sha": "322df6e5b47c690e5d05d0204de35701b40d9065", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 129, "deletions": 10, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -49,9 +49,37 @@ impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n ///\n-/// Constructed by the `Formatter::debug_struct` method.\n+/// This is useful when you wish to output a formatted struct as a part of your\n+/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_struct`](struct.Formatter.html#method.debug_struct)\n+/// method.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo {\n+///     bar: i32,\n+///     baz: String,\n+/// }\n+///\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_struct(\"Foo\")\n+///            .field(\"bar\", &self.bar)\n+///            .field(\"baz\", &self.baz)\n+///            .finish()\n+///     }\n+/// }\n+///\n+/// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n+/// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n@@ -116,9 +144,34 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n+///\n+/// This is useful when you wish to output a formatted tuple as a part of your\n+/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_tuple`](struct.Formatter.html#method.debug_tuple)\n+/// method.\n ///\n-/// Constructed by the `Formatter::debug_tuple` method.\n+/// # Example\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo(i32, String);\n+///\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_tuple(\"Foo\")\n+///            .field(&self.0)\n+///            .field(&self.1)\n+///            .finish()\n+///     }\n+/// }\n+///\n+/// // prints \"Foo(10, \"Hello World\")\"\n+/// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n@@ -228,9 +281,31 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n+///\n+/// This is useful when you wish to output a formatted set of items as a part\n+/// of your [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_set`](struct.Formatter.html#method.debug_set)\n+/// method.\n+///\n+/// # Example\n ///\n-/// Constructed by the `Formatter::debug_set` method.\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo(Vec<i32>);\n+///\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_set().entries(self.0.iter()).finish()\n+///     }\n+/// }\n+///\n+/// // prints \"{10, 11}\"\n+/// println!(\"{:?}\", Foo(vec![10, 11]));\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n@@ -277,9 +352,31 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n+///\n+/// This is useful when you wish to output a formatted list of items as a part\n+/// of your [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_list`](struct.Formatter.html#method.debug_list)\n+/// method.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo(Vec<i32>);\n ///\n-/// Constructed by the `Formatter::debug_list` method.\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_list().entries(self.0.iter()).finish()\n+///     }\n+/// }\n+///\n+/// // prints \"[10, 11]\"\n+/// println!(\"{:?}\", Foo(vec![10, 11]));\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n@@ -326,9 +423,31 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n+///\n+/// This is useful when you wish to output a formatted map as a part of your\n+/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_map`](struct.Formatter.html#method.debug_map)\n+/// method.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo(Vec<(String, i32)>);\n+///\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n+///     }\n+/// }\n ///\n-/// Constructed by the `Formatter::debug_map` method.\n+/// // prints \"{\"A\": 10, \"B\": 11}\"\n+/// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]"}, {"sha": "bcc6d53c81d3bb9764bd94e4cdac15b339d44b31", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -897,14 +897,11 @@ pub trait UpperExp {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// The `write` function takes an output stream, a precompiled format string,\n-/// and a list of arguments. The arguments will be formatted according to the\n-/// specified format string into the output stream provided.\n+/// The `write` function takes an output stream, and an `Arguments` struct\n+/// that can be precompiled with the `format_args!` macro.\n ///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * args - the precompiled arguments generated by `format_args!`\n+/// The arguments will be formatted according to the specified format string\n+/// into the output stream provided.\n ///\n /// # Examples\n ///"}, {"sha": "d9887094fefb2f767e2b8e202093d233c733ddc0", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -482,6 +482,53 @@ pub trait Iterator {\n         Map{iter: self, f: f}\n     }\n \n+    /// Calls a closure on each element of an iterator.\n+    ///\n+    /// This is equivalent to using a [`for`] loop on the iterator, although\n+    /// `break` and `continue` are not possible from a closure.  It's generally\n+    /// more idiomatic to use a `for` loop, but `for_each` may be more legible\n+    /// when processing items at the end of longer iterator chains.  In some\n+    /// cases `for_each` may also be faster than a loop, because it will use\n+    /// internal iteration on adaptors like `Chain`.\n+    ///\n+    /// [`for`]: ../../book/first-edition/loops.html#for\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_for_each)]\n+    ///\n+    /// use std::sync::mpsc::channel;\n+    ///\n+    /// let (tx, rx) = channel();\n+    /// (0..5).map(|x| x * 2 + 1)\n+    ///       .for_each(move |x| tx.send(x).unwrap());\n+    ///\n+    /// let v: Vec<_> =  rx.iter().collect();\n+    /// assert_eq!(v, vec![1, 3, 5, 7, 9]);\n+    /// ```\n+    ///\n+    /// For such a small example, a `for` loop may be cleaner, but `for_each`\n+    /// might be preferable to keep a functional style with longer iterators:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_for_each)]\n+    ///\n+    /// (0..5).flat_map(|x| x * 100 .. x * 110)\n+    ///       .enumerate()\n+    ///       .filter(|&(i, x)| (i + x) % 3 == 0)\n+    ///       .for_each(|(i, x)| println!(\"{}:{}\", i, x));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_for_each\", issue = \"42986\")]\n+    fn for_each<F>(self, mut f: F) where\n+        Self: Sized, F: FnMut(Self::Item),\n+    {\n+        self.fold((), move |(), item| f(item));\n+    }\n+\n     /// Creates an iterator which uses a closure to determine if an element\n     /// should be yielded.\n     ///"}, {"sha": "decd718d65e15c6e8af03368024be64c69d9bae3", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -314,12 +314,6 @@ pub use self::iterator::Iterator;\n            reason = \"likely to be replaced by finer-grained traits\",\n            issue = \"42168\")]\n pub use self::range::Step;\n-#[unstable(feature = \"step_by\", reason = \"recent addition\",\n-           issue = \"27741\")]\n-#[rustc_deprecated(since = \"1.19.0\",\n-                   reason = \"replaced by `iter::StepBy`\")]\n-#[allow(deprecated)]\n-pub use self::range::StepBy as DeprecatedStepBy;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::sources::{Repeat, repeat};"}, {"sha": "1dad8157948958f6a94e544fe24e9cbbb305b7e7", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -244,219 +244,6 @@ step_impl_signed!(i64);\n step_impl_no_between!(u64 i64);\n step_impl_no_between!(u128 i128);\n \n-/// An adapter for stepping range iterators by a custom amount.\n-///\n-/// The resulting iterator handles overflow by stopping. The `A`\n-/// parameter is the type being iterated over, while `R` is the range\n-/// type (usually one of `std::ops::{Range, RangeFrom, RangeInclusive}`.\n-#[derive(Clone, Debug)]\n-#[unstable(feature = \"step_by\", reason = \"recent addition\",\n-           issue = \"27741\")]\n-#[rustc_deprecated(since = \"1.19.0\",\n-                   reason = \"replaced by `iter::StepBy`\")]\n-#[allow(deprecated)]\n-pub struct StepBy<A, R> {\n-    step_by: A,\n-    range: R,\n-}\n-\n-impl<A: Step> ops::RangeFrom<A> {\n-    /// Creates an iterator starting at the same point, but stepping by\n-    /// the given amount at each iteration.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(step_by)]\n-    /// fn main() {\n-    ///     let result: Vec<_> = (0..).step_by(2).take(5).collect();\n-    ///     assert_eq!(result, vec![0, 2, 4, 6, 8]);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n-               issue = \"27741\")]\n-    #[rustc_deprecated(since = \"1.19.0\",\n-                       reason = \"replaced by `Iterator::step_by`\")]\n-    #[allow(deprecated)]\n-    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n-        StepBy {\n-            step_by: by,\n-            range: self\n-        }\n-    }\n-}\n-\n-impl<A: Step> ops::Range<A> {\n-    /// Creates an iterator with the same range, but stepping by the\n-    /// given amount at each iteration.\n-    ///\n-    /// The resulting iterator handles overflow by stopping.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(step_by)]\n-    /// fn main() {\n-    ///     let result: Vec<_> = (0..10).step_by(2).collect();\n-    ///     assert_eq!(result, vec![0, 2, 4, 6, 8]);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n-               issue = \"27741\")]\n-    #[rustc_deprecated(since = \"1.19.0\",\n-                       reason = \"replaced by `Iterator::step_by`\")]\n-    #[allow(deprecated)]\n-    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n-        StepBy {\n-            step_by: by,\n-            range: self\n-        }\n-    }\n-}\n-\n-impl<A: Step> ops::RangeInclusive<A> {\n-    /// Creates an iterator with the same range, but stepping by the\n-    /// given amount at each iteration.\n-    ///\n-    /// The resulting iterator handles overflow by stopping.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(step_by, inclusive_range_syntax)]\n-    ///\n-    /// let result: Vec<_> = (0...10).step_by(2).collect();\n-    /// assert_eq!(result, vec![0, 2, 4, 6, 8, 10]);\n-    /// ```\n-    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n-               issue = \"27741\")]\n-    #[rustc_deprecated(since = \"1.19.0\",\n-                       reason = \"replaced by `Iterator::step_by`\")]\n-    #[allow(deprecated)]\n-    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n-        StepBy {\n-            step_by: by,\n-            range: self\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"step_by\", reason = \"recent addition\",\n-           issue = \"27741\")]\n-#[allow(deprecated)]\n-impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n-    A: Clone,\n-    for<'a> &'a A: Add<&'a A, Output = A>\n-{\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        let mut n = &self.range.start + &self.step_by;\n-        mem::swap(&mut n, &mut self.range.start);\n-        Some(n)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None) // Too bad we can't specify an infinite lower bound\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-#[allow(deprecated)]\n-impl<A> FusedIterator for StepBy<A, ops::RangeFrom<A>>\n-    where A: Clone, for<'a> &'a A: Add<&'a A, Output = A> {}\n-\n-#[unstable(feature = \"step_by\", reason = \"recent addition\",\n-           issue = \"27741\")]\n-#[allow(deprecated)]\n-impl<A: Step + Clone> Iterator for StepBy<A, ops::Range<A>> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        let rev = self.step_by.is_negative();\n-        if (rev && self.range.start > self.range.end) ||\n-           (!rev && self.range.start < self.range.end)\n-        {\n-            match self.range.start.step(&self.step_by) {\n-                Some(mut n) => {\n-                    mem::swap(&mut self.range.start, &mut n);\n-                    Some(n)\n-                },\n-                None => {\n-                    let mut n = self.range.end.clone();\n-                    mem::swap(&mut self.range.start, &mut n);\n-                    Some(n)\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match Step::steps_between(&self.range.start,\n-                                  &self.range.end,\n-                                  &self.step_by) {\n-            Some(hint) => (hint, Some(hint)),\n-            None       => (0, None)\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-#[allow(deprecated)]\n-impl<A: Step + Clone> FusedIterator for StepBy<A, ops::Range<A>> {}\n-\n-#[unstable(feature = \"inclusive_range\",\n-           reason = \"recently added, follows RFC\",\n-           issue = \"28237\")]\n-#[allow(deprecated)]\n-impl<A: Step + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        let rev = self.step_by.is_negative();\n-\n-        if (rev && self.range.start >= self.range.end) ||\n-           (!rev && self.range.start <= self.range.end)\n-        {\n-            match self.range.start.step(&self.step_by) {\n-                Some(n) => {\n-                    Some(mem::replace(&mut self.range.start, n))\n-                },\n-                None => {\n-                    let last = self.range.start.replace_one();\n-                    self.range.end.replace_zero();\n-                    self.step_by.replace_one();\n-                    Some(last)\n-                },\n-            }\n-        }\n-        else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match Step::steps_between(&self.range.start,\n-                                  &self.range.end,\n-                                  &self.step_by) {\n-            Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n-            None       => (0, None)\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-#[allow(deprecated)]\n-impl<A: Step + Clone> FusedIterator for StepBy<A, ops::RangeInclusive<A>> {}\n-\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "97aaaffe8bc88909ff21401664f1077a3e199d20", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -36,12 +36,12 @@\n //!   These functions are often provided by the system libc, but can also be\n //!   provided by the [rlibc crate](https://crates.io/crates/rlibc).\n //!\n-//! * `rust_begin_panic` - This function takes three arguments, a\n-//!   `fmt::Arguments`, a `&'static str`, and a `u32`. These three arguments\n+//! * `rust_begin_panic` - This function takes four arguments, a\n+//!   `fmt::Arguments`, a `&'static str`, and two `u32`'s. These four arguments\n //!   dictate the panic message, the file at which panic was invoked, and the\n-//!   line. It is up to consumers of this core library to define this panic\n-//!   function; it is only required to never return. This requires a `lang`\n-//!   attribute named `panic_fmt`.\n+//!   line and column inside the file. It is up to consumers of this core\n+//!   library to define this panic function; it is only required to never\n+//!   return. This requires a `lang` attribute named `panic_fmt`.\n //!\n //! * `rust_eh_personality` - is used by the failure mechanisms of the\n //!    compiler. This is often mapped to GCC's personality function, but crates"}, {"sha": "70820dce5f9409013daf6092959e3a1bc862fb95", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -17,16 +17,18 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     );\n     ($msg:expr) => ({\n-        static _MSG_FILE_LINE: (&'static str, &'static str, u32) = ($msg, file!(), line!());\n-        $crate::panicking::panic(&_MSG_FILE_LINE)\n+        static _MSG_FILE_LINE_COL: (&'static str, &'static str, u32, u32) =\n+            ($msg, file!(), line!(), column!());\n+        $crate::panicking::panic(&_MSG_FILE_LINE_COL)\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n         // The leading _'s are to avoid dead code warnings if this is\n         // used inside a dead function. Just `#[allow(dead_code)]` is\n         // insufficient, since the user may have\n         // `#[forbid(dead_code)]` and which cannot be overridden.\n-        static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+        static _MSG_FILE_LINE_COL: (&'static str, u32, u32) =\n+            (file!(), line!(), column!());\n+        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_MSG_FILE_LINE_COL)\n     });\n }\n "}, {"sha": "6c1e8e8960f7549f4b2f50f23e59714ae18375e3", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -506,59 +506,7 @@ pub unsafe fn uninitialized<T>() -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n-        // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n-        // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n-        // Haswell E processors. LLVM is more able to optimize if we give a struct a\n-        // #[repr(simd)], even if we don't actually use this struct directly.\n-        //\n-        // FIXME repr(simd) broken on emscripten and redox\n-        #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\")), repr(simd))]\n-        struct Block(u64, u64, u64, u64);\n-        struct UnalignedBlock(u64, u64, u64, u64);\n-\n-        let block_size = size_of::<Block>();\n-\n-        // Get raw pointers to the bytes of x & y for easier manipulation\n-        let x = x as *mut T as *mut u8;\n-        let y = y as *mut T as *mut u8;\n-\n-        // Loop through x & y, copying them `Block` at a time\n-        // The optimizer should unroll the loop fully for most types\n-        // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n-        let len = size_of::<T>();\n-        let mut i = 0;\n-        while i + block_size <= len {\n-            // Create some uninitialized memory as scratch space\n-            // Declaring `t` here avoids aligning the stack when this loop is unused\n-            let mut t: Block = uninitialized();\n-            let t = &mut t as *mut _ as *mut u8;\n-            let x = x.offset(i as isize);\n-            let y = y.offset(i as isize);\n-\n-            // Swap a block of bytes of x & y, using t as a temporary buffer\n-            // This should be optimized into efficient SIMD operations where available\n-            ptr::copy_nonoverlapping(x, t, block_size);\n-            ptr::copy_nonoverlapping(y, x, block_size);\n-            ptr::copy_nonoverlapping(t, y, block_size);\n-            i += block_size;\n-        }\n-\n-\n-        if i < len {\n-            // Swap any remaining bytes, using aligned types to copy\n-            // where appropriate (this information is lost by conversion\n-            // to *mut u8, so restore it manually here)\n-            let mut t: UnalignedBlock = uninitialized();\n-            let rem = len - i;\n-\n-            let t = &mut t as *mut _ as *mut u8;\n-            let x = x.offset(i as isize);\n-            let y = y.offset(i as isize);\n-\n-            ptr::copy_nonoverlapping(x, t, rem);\n-            ptr::copy_nonoverlapping(y, x, rem);\n-            ptr::copy_nonoverlapping(t, y, rem);\n-        }\n+        ptr::swap_nonoverlapping(x, y, 1);\n     }\n }\n "}, {"sha": "ebc30dc8b61fb0fd390e16a745728c89d60cdc3f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -205,18 +205,25 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n     #[inline]\n     fn is_sign_positive(self) -> bool {\n-        self > 0.0 || (1.0 / self) == INFINITY\n+        !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        self < 0.0 || (1.0 / self) == NEG_INFINITY\n+        // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n+        // applies to zeros and NaNs as well.\n+        #[repr(C)]\n+        union F32Bytes {\n+            f: f32,\n+            b: u32\n+        }\n+        unsafe { F32Bytes { f: self }.b & 0x8000_0000 != 0 }\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number."}, {"sha": "1a1fe4d86e0d093ccb3dab01139374948a88023b", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -205,18 +205,23 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n     #[inline]\n     fn is_sign_positive(self) -> bool {\n-        self > 0.0 || (1.0 / self) == INFINITY\n+        !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        self < 0.0 || (1.0 / self) == NEG_INFINITY\n+        #[repr(C)]\n+        union F64Bytes {\n+            f: f64,\n+            b: u64\n+        }\n+        unsafe { F64Bytes { f: self }.b & 0x8000_0000_0000_0000 != 0 }\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number."}, {"sha": "f5a7e78d0faa04eae9715425f017237f0a699a13", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -17,7 +17,7 @@\n //!\n //! ```\n //! # use std::fmt;\n-//! fn panic_impl(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> !\n+//! fn panic_impl(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> !\n //! # { loop {} }\n //! ```\n //!\n@@ -39,34 +39,55 @@\n use fmt;\n \n #[cold] #[inline(never)] // this is the slow path, always\n-#[lang = \"panic\"]\n-pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n+#[cfg_attr(not(stage0), lang = \"panic\")]\n+pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n     // reduce size overhead. The format_args! macro uses str's Display trait to\n     // write expr, which calls Formatter::pad, which must accommodate string\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n+    let (expr, file, line, col) = *expr_file_line_col;\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line, col))\n+}\n+\n+// FIXME: remove when SNAP\n+#[cold] #[inline(never)]\n+#[cfg(stage0)]\n+#[lang = \"panic\"]\n+pub fn panic_old(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n     let (expr, file, line) = *expr_file_line;\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line))\n+    let expr_file_line_col = (expr, file, line, 0);\n+    panic(&expr_file_line_col)\n+}\n+\n+#[cold] #[inline(never)]\n+#[cfg_attr(not(stage0), lang = \"panic_bounds_check\")]\n+fn panic_bounds_check(file_line_col: &(&'static str, u32, u32),\n+                     index: usize, len: usize) -> ! {\n+    panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n+                           len, index), file_line_col)\n }\n \n+// FIXME: remove when SNAP\n #[cold] #[inline(never)]\n+#[cfg(stage0)]\n #[lang = \"panic_bounds_check\"]\n-fn panic_bounds_check(file_line: &(&'static str, u32),\n+fn panic_bounds_check_old(file_line: &(&'static str, u32),\n                      index: usize, len: usize) -> ! {\n+    let (file, line) = *file_line;\n     panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n-                           len, index), file_line)\n+                           len, index), &(file, line, 0))\n }\n \n #[cold] #[inline(never)]\n-pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n+pub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> ! {\n     #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"panic_fmt\"]\n         #[unwind]\n-        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32) -> !;\n+        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32, col: u32) -> !;\n     }\n-    let (file, line) = *file_line;\n-    unsafe { panic_impl(fmt, file, line) }\n+    let (file, line, col) = *file_line_col;\n+    unsafe { panic_impl(fmt, file, line, col) }\n }"}, {"sha": "92470299366ce9fbc9df72695221151007495019", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -117,6 +117,90 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     mem::forget(tmp);\n }\n \n+/// Swaps a sequence of values at two mutable locations of the same type.\n+///\n+/// # Safety\n+///\n+/// The two arguments must each point to the beginning of `count` locations\n+/// of valid memory, and the two memory ranges must not overlap.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(swap_nonoverlapping)]\n+///\n+/// use std::ptr;\n+///\n+/// let mut x = [1, 2, 3, 4];\n+/// let mut y = [7, 8, 9];\n+///\n+/// unsafe {\n+///     ptr::swap_nonoverlapping(x.as_mut_ptr(), y.as_mut_ptr(), 2);\n+/// }\n+///\n+/// assert_eq!(x, [7, 8, 3, 4]);\n+/// assert_eq!(y, [1, 2, 9]);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"swap_nonoverlapping\", issue = \"42818\")]\n+pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n+    let x = x as *mut u8;\n+    let y = y as *mut u8;\n+    let len = mem::size_of::<T>() * count;\n+    swap_nonoverlapping_bytes(x, y, len)\n+}\n+\n+#[inline]\n+unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n+    // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n+    // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n+    // Haswell E processors. LLVM is more able to optimize if we give a struct a\n+    // #[repr(simd)], even if we don't actually use this struct directly.\n+    //\n+    // FIXME repr(simd) broken on emscripten and redox\n+    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\")), repr(simd))]\n+    struct Block(u64, u64, u64, u64);\n+    struct UnalignedBlock(u64, u64, u64, u64);\n+\n+    let block_size = mem::size_of::<Block>();\n+\n+    // Loop through x & y, copying them `Block` at a time\n+    // The optimizer should unroll the loop fully for most types\n+    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n+    let mut i = 0;\n+    while i + block_size <= len {\n+        // Create some uninitialized memory as scratch space\n+        // Declaring `t` here avoids aligning the stack when this loop is unused\n+        let mut t: Block = mem::uninitialized();\n+        let t = &mut t as *mut _ as *mut u8;\n+        let x = x.offset(i as isize);\n+        let y = y.offset(i as isize);\n+\n+        // Swap a block of bytes of x & y, using t as a temporary buffer\n+        // This should be optimized into efficient SIMD operations where available\n+        copy_nonoverlapping(x, t, block_size);\n+        copy_nonoverlapping(y, x, block_size);\n+        copy_nonoverlapping(t, y, block_size);\n+        i += block_size;\n+    }\n+\n+    if i < len {\n+        // Swap any remaining bytes\n+        let mut t: UnalignedBlock = mem::uninitialized();\n+        let rem = len - i;\n+\n+        let t = &mut t as *mut _ as *mut u8;\n+        let x = x.offset(i as isize);\n+        let y = y.offset(i as isize);\n+\n+        copy_nonoverlapping(x, t, rem);\n+        copy_nonoverlapping(y, x, rem);\n+        copy_nonoverlapping(t, y, rem);\n+    }\n+}\n+\n /// Replaces the value at `dest` with `src`, returning the old\n /// value, without dropping either.\n ///"}, {"sha": "62c7e7aa1cce223ada86607a9e9775b60f0e47d8", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -212,15 +212,15 @@ pub trait SliceExt {\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;\n \n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     fn sort_unstable(&mut self)\n         where Self::Item: Ord;\n \n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     fn sort_unstable_by<F>(&mut self, compare: F)\n         where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n \n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     fn sort_unstable_by_key<B, F>(&mut self, f: F)\n         where F: FnMut(&Self::Item) -> B,\n               B: Ord;"}, {"sha": "e4a4e33c1729efb94bd924b552915d048480d6c5", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -76,7 +76,7 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n             break;\n         }\n \n-        ptr_swap_n(\n+        ptr::swap_nonoverlapping(\n             mid.offset(-(left as isize)),\n             mid.offset((right-delta) as isize),\n             delta);\n@@ -103,10 +103,3 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n         ptr::copy_nonoverlapping(buf, mid.offset(-(left as isize)), right);\n     }\n }\n-\n-unsafe fn ptr_swap_n<T>(a: *mut T, b: *mut T, n: usize) {\n-    for i in 0..n {\n-        // These are nonoverlapping, so use mem::swap instead of ptr::swap\n-        mem::swap(&mut *a.offset(i as isize), &mut *b.offset(i as isize));\n-    }\n-}"}, {"sha": "518d56095d60105ecf05392ad73c45f2efa1769c", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -351,7 +351,7 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n \n     if start_l < end_l {\n         // The left block remains.\n-        // Move it's remaining out-of-order elements to the far right.\n+        // Move its remaining out-of-order elements to the far right.\n         debug_assert_eq!(width(l, r), block_l);\n         while start_l < end_l {\n             unsafe {\n@@ -363,7 +363,7 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n         width(v.as_mut_ptr(), r)\n     } else if start_r < end_r {\n         // The right block remains.\n-        // Move it's remaining out-of-order elements to the far left.\n+        // Move its remaining out-of-order elements to the far left.\n         debug_assert_eq!(width(l, r), block_r);\n         while start_r < end_r {\n             unsafe {"}, {"sha": "14f0260f57129391b0da27fb5c9fd96bca77627f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -12,15 +12,6 @@ use core::iter::*;\n use core::{i8, i16, isize};\n use core::usize;\n \n-// FIXME #27741: This is here to simplify calling Iterator::step_by. Remove\n-// once Range::step_by is completely gone (not just deprecated).\n-trait IterEx: Sized {\n-    fn iter_step_by(self, n: usize) -> StepBy<Self>;\n-}\n-impl<I:Iterator> IterEx for I {\n-    fn iter_step_by(self, n: usize) -> StepBy<Self> { self.step_by(n) }\n-}\n-\n #[test]\n fn test_lt() {\n     let empty: [isize; 0] = [];\n@@ -76,7 +67,7 @@ fn test_multi_iter() {\n \n #[test]\n fn test_counter_from_iter() {\n-    let it = (0..).iter_step_by(5).take(10);\n+    let it = (0..).step_by(5).take(10);\n     let xs: Vec<isize> = FromIterator::from_iter(it);\n     assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n }\n@@ -94,7 +85,7 @@ fn test_iterator_chain() {\n     }\n     assert_eq!(i, expected.len());\n \n-    let ys = (30..).iter_step_by(10).take(4);\n+    let ys = (30..).step_by(10).take(4);\n     let it = xs.iter().cloned().chain(ys);\n     let mut i = 0;\n     for x in it {\n@@ -156,13 +147,13 @@ fn test_iterator_chain_find() {\n #[test]\n fn test_iterator_step_by() {\n     // Identity\n-    let mut it = (0..).iter_step_by(1).take(3);\n+    let mut it = (0..).step_by(1).take(3);\n     assert_eq!(it.next(), Some(0));\n     assert_eq!(it.next(), Some(1));\n     assert_eq!(it.next(), Some(2));\n     assert_eq!(it.next(), None);\n \n-    let mut it = (0..).iter_step_by(3).take(4);\n+    let mut it = (0..).step_by(3).take(4);\n     assert_eq!(it.next(), Some(0));\n     assert_eq!(it.next(), Some(3));\n     assert_eq!(it.next(), Some(6));\n@@ -173,7 +164,7 @@ fn test_iterator_step_by() {\n #[test]\n #[should_panic]\n fn test_iterator_step_by_zero() {\n-    let mut it = (0..).iter_step_by(0);\n+    let mut it = (0..).step_by(0);\n     it.next();\n }\n \n@@ -252,7 +243,7 @@ fn test_iterator_step_by_size_hint() {\n \n #[test]\n fn test_filter_map() {\n-    let it = (0..).iter_step_by(1).take(10)\n+    let it = (0..).step_by(1).take(10)\n         .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n     assert_eq!(it.collect::<Vec<usize>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n@@ -654,7 +645,7 @@ fn test_iterator_scan() {\n fn test_iterator_flat_map() {\n     let xs = [0, 3, 6];\n     let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    let it = xs.iter().flat_map(|&x| (x..).iter_step_by(1).take(3));\n+    let it = xs.iter().flat_map(|&x| (x..).step_by(1).take(3));\n     let mut i = 0;\n     for x in it {\n         assert_eq!(x, ys[i]);\n@@ -680,13 +671,13 @@ fn test_inspect() {\n #[test]\n fn test_cycle() {\n     let cycle_len = 3;\n-    let it = (0..).iter_step_by(1).take(cycle_len).cycle();\n+    let it = (0..).step_by(1).take(cycle_len).cycle();\n     assert_eq!(it.size_hint(), (usize::MAX, None));\n     for (i, x) in it.take(100).enumerate() {\n         assert_eq!(i % cycle_len, x);\n     }\n \n-    let mut it = (0..).iter_step_by(1).take(0).cycle();\n+    let mut it = (0..).step_by(1).take(0).cycle();\n     assert_eq!(it.size_hint(), (0, Some(0)));\n     assert_eq!(it.next(), None);\n }\n@@ -765,7 +756,7 @@ fn test_iterator_min() {\n \n #[test]\n fn test_iterator_size_hint() {\n-    let c = (0..).iter_step_by(1);\n+    let c = (0..).step_by(1);\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let v2 = &[10, 11, 12];\n     let vi = v.iter();\n@@ -1090,22 +1081,21 @@ fn test_range_step() {\n     #![allow(deprecated)]\n \n     assert_eq!((0..20).step_by(5).collect::<Vec<isize>>(), [0, 5, 10, 15]);\n-    assert_eq!((20..0).step_by(-5).collect::<Vec<isize>>(), [20, 15, 10, 5]);\n-    assert_eq!((20..0).step_by(-6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n+    assert_eq!((1..21).rev().step_by(5).collect::<Vec<isize>>(), [20, 15, 10, 5]);\n+    assert_eq!((1..21).rev().step_by(6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n     assert_eq!((200..255).step_by(50).collect::<Vec<u8>>(), [200, 250]);\n     assert_eq!((200..-5).step_by(1).collect::<Vec<isize>>(), []);\n     assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n \n     assert_eq!((0..20).step_by(1).size_hint(), (20, Some(20)));\n     assert_eq!((0..20).step_by(21).size_hint(), (1, Some(1)));\n     assert_eq!((0..20).step_by(5).size_hint(), (4, Some(4)));\n-    assert_eq!((20..0).step_by(-5).size_hint(), (4, Some(4)));\n-    assert_eq!((20..0).step_by(-6).size_hint(), (4, Some(4)));\n+    assert_eq!((1..21).rev().step_by(5).size_hint(), (4, Some(4)));\n+    assert_eq!((1..21).rev().step_by(6).size_hint(), (4, Some(4)));\n     assert_eq!((20..-5).step_by(1).size_hint(), (0, Some(0)));\n     assert_eq!((20..20).step_by(1).size_hint(), (0, Some(0)));\n-    assert_eq!((0..1).step_by(0).size_hint(), (0, None));\n-    assert_eq!((i8::MAX..i8::MIN).step_by(i8::MIN).size_hint(), (2, Some(2)));\n-    assert_eq!((i16::MIN..i16::MAX).step_by(i16::MAX).size_hint(), (3, Some(3)));\n+    assert_eq!((i8::MIN..i8::MAX).step_by(-(i8::MIN as i32) as usize).size_hint(), (2, Some(2)));\n+    assert_eq!((i16::MIN..i16::MAX).step_by(i16::MAX as usize).size_hint(), (3, Some(3)));\n     assert_eq!((isize::MIN..isize::MAX).step_by(1).size_hint(), (usize::MAX, Some(usize::MAX)));\n }\n "}, {"sha": "8d3e367d2379adf5d387df9047fea55a1588ecd4", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -34,9 +34,7 @@\n #![feature(slice_patterns)]\n #![feature(slice_rotate)]\n #![feature(sort_internals)]\n-#![feature(sort_unstable)]\n #![feature(specialization)]\n-#![feature(step_by)]\n #![feature(step_trait)]\n #![feature(test)]\n #![feature(trusted_len)]"}, {"sha": "5e56b0d8ab16cf0f9d02b79234a2cc74dff47923", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -31,7 +31,7 @@\n             issue = \"27703\")]\n #![feature(core_intrinsics)]\n #![feature(staged_api)]\n-#![feature(step_by)]\n+#![feature(iterator_step_by)]\n #![feature(custom_attribute)]\n #![feature(specialization)]\n #![allow(unused_attributes)]"}, {"sha": "035640b9710e27302007af8ef3d286f6e267c7a4", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1946,6 +1946,44 @@ Maybe you just misspelled the lint name or the lint doesn't exist anymore.\n Either way, try to update/remove it in order to fix the error.\n \"##,\n \n+E0621: r##\"\n+This error code indicates a mismatch between the function signature (i.e.,\n+the parameter types and the return type) and the function body. Most of\n+the time, this indicates that the function signature needs to be changed to\n+match the body, but it may be that the body needs to be changed to match\n+the signature.\n+\n+Specifically, one or more of the parameters contain borrowed data that\n+needs to have a named lifetime in order for the body to type-check. Most of\n+the time, this is because the borrowed data is being returned from the\n+function, as in this example:\n+\n+```compile_fail,E0621\n+fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 { // explicit lifetime required\n+                                             // in the type of `y`\n+    if x > y { x } else { y }\n+}\n+```\n+\n+Here, the function is returning data borrowed from either x or y, but the\n+'a annotation indicates that it is returning data only from x. We can make\n+the signature match the body by changing the type of y to &'a i32, like so:\n+\n+```\n+fn foo<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {\n+    if x > y { x } else { y }\n+}\n+```\n+\n+Alternatively, you could change the body not to return data from y:\n+\n+```\n+fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+    x\n+}\n+```\n+\"##,\n+\n }\n \n "}, {"sha": "873d39ec9e9fb0fb6cd7d16a198d27390b146958", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -2170,12 +2170,12 @@ impl<'a> LoweringContext<'a> {\n                 //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n                 //       mut iter => {\n                 //         [opt_ident]: loop {\n-                //           let mut _next;\n+                //           let mut __next;\n                 //           match ::std::iter::Iterator::next(&mut iter) {\n-                //             ::std::option::Option::Some(val) => _next = val,\n+                //             ::std::option::Option::Some(val) => __next = val,\n                 //             ::std::option::Option::None => break\n                 //           };\n-                //           let <pat> = _next;\n+                //           let <pat> = __next;\n                 //           StmtExpr(<body>);\n                 //         }\n                 //       }\n@@ -2188,7 +2188,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let iter = self.str_to_ident(\"iter\");\n \n-                let next_ident = self.str_to_ident(\"_next\");\n+                let next_ident = self.str_to_ident(\"__next\");\n                 let next_pat = self.pat_ident_binding_mode(e.span,\n                                                            next_ident,\n                                                            hir::BindByValue(hir::MutMutable));\n@@ -2237,13 +2237,13 @@ impl<'a> LoweringContext<'a> {\n \n                 let next_expr = P(self.expr_ident(e.span, next_ident, next_pat.id));\n \n-                // `let mut _next`\n+                // `let mut __next`\n                 let next_let = self.stmt_let_pat(e.span,\n                     None,\n                     next_pat,\n                     hir::LocalSource::ForLoopDesugar);\n \n-                // `let <pat> = _next`\n+                // `let <pat> = __next`\n                 let pat = self.lower_pat(pat);\n                 let pat_let = self.stmt_let_pat(e.span,\n                     Some(next_expr),"}, {"sha": "02a36a372d9ef3354aab83d9e93dcb9afa1039fc", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -594,8 +594,12 @@ impl<'hir> Map<'hir> {\n     /// last good node id we found. Note that reaching the crate root (id == 0),\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n-    fn walk_parent_nodes<F>(&self, start_id: NodeId, found: F) -> Result<NodeId, NodeId>\n-        where F: Fn(&Node<'hir>) -> bool\n+    fn walk_parent_nodes<F, F2>(&self,\n+                                start_id: NodeId,\n+                                found: F,\n+                                bail_early: F2)\n+        -> Result<NodeId, NodeId>\n+        where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n     {\n         let mut id = start_id;\n         loop {\n@@ -616,6 +620,8 @@ impl<'hir> Map<'hir> {\n                 Some(ref node) => {\n                     if found(node) {\n                         return Ok(parent_node);\n+                    } else if bail_early(node) {\n+                        return Err(parent_node);\n                     }\n                 }\n                 None => {\n@@ -626,6 +632,56 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Retrieve the NodeId for `id`'s enclosing method, unless there's a\n+    /// `while` or `loop` before reacing it, as block tail returns are not\n+    /// available in them.\n+    ///\n+    /// ```\n+    /// fn foo(x: usize) -> bool {\n+    ///     if x == 1 {\n+    ///         true  // `get_return_block` gets passed the `id` corresponding\n+    ///     } else {  // to this, it will return `foo`'s `NodeId`.\n+    ///         false\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// ```\n+    /// fn foo(x: usize) -> bool {\n+    ///     loop {\n+    ///         true  // `get_return_block` gets passed the `id` corresponding\n+    ///     }         // to this, it will return `None`.\n+    ///     false\n+    /// }\n+    /// ```\n+    pub fn get_return_block(&self, id: NodeId) -> Option<NodeId> {\n+        let match_fn = |node: &Node| {\n+            match *node {\n+                NodeItem(_) |\n+                NodeForeignItem(_) |\n+                NodeTraitItem(_) |\n+                NodeImplItem(_) => true,\n+                _ => false,\n+            }\n+        };\n+        let match_non_returning_block = |node: &Node| {\n+            match *node {\n+                NodeExpr(ref expr) => {\n+                    match expr.node {\n+                        ExprWhile(..) | ExprLoop(..) => true,\n+                        _ => false,\n+                    }\n+                }\n+                _ => false,\n+            }\n+        };\n+\n+        match self.walk_parent_nodes(id, match_fn, match_non_returning_block) {\n+            Ok(id) => Some(id),\n+            Err(_) => None,\n+        }\n+    }\n+\n     /// Retrieve the NodeId for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the AST which is recorded by the map and is an item, either an item\n@@ -637,7 +693,7 @@ impl<'hir> Map<'hir> {\n             NodeTraitItem(_) |\n             NodeImplItem(_) => true,\n             _ => false,\n-        }) {\n+        }, |_| false) {\n             Ok(id) => id,\n             Err(id) => id,\n         }\n@@ -649,7 +705,7 @@ impl<'hir> Map<'hir> {\n         let id = match self.walk_parent_nodes(id, |node| match *node {\n             NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n             _ => false,\n-        }) {\n+        }, |_| false) {\n             Ok(id) => id,\n             Err(id) => id,\n         };\n@@ -668,7 +724,7 @@ impl<'hir> Map<'hir> {\n             NodeImplItem(_) |\n             NodeBlock(_) => true,\n             _ => false,\n-        }) {\n+        }, |_| false) {\n             Ok(id) => Some(id),\n             Err(_) => None,\n         }"}, {"sha": "c6f4cd585d7b5d41accf1b189aaa2901ef935fb2", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1527,7 +1527,8 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 word(&mut self.s, \"::\")?\n             }\n-            if segment.name != keywords::CrateRoot.name() && segment.name != \"$crate\" {\n+            if segment.name != keywords::CrateRoot.name() &&\n+               segment.name != keywords::DollarCrate.name() {\n                 self.print_name(segment.name)?;\n                 self.print_path_parameters(&segment.parameters, colons_before_params)?;\n             }\n@@ -1554,7 +1555,8 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         word(&mut self.s, \"::\")?\n                     }\n-                    if segment.name != keywords::CrateRoot.name() && segment.name != \"$crate\" {\n+                    if segment.name != keywords::CrateRoot.name() &&\n+                       segment.name != keywords::DollarCrate.name() {\n                         self.print_name(segment.name)?;\n                         self.print_path_parameters(&segment.parameters, colons_before_params)?;\n                     }"}, {"sha": "4f365a97f4ceba1719af50f475bf9b06e1068263", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -524,10 +524,9 @@ for ty::TypeVariants<'tcx>\n                 region.hash_stable(hcx, hasher);\n                 pointee_ty.hash_stable(hcx, hasher);\n             }\n-            TyFnDef(def_id, substs, ref sig) => {\n+            TyFnDef(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n-                sig.hash_stable(hcx, hasher);\n             }\n             TyFnPtr(ref sig) => {\n                 sig.hash_stable(hcx, hasher);"}, {"sha": "82bbb4a1bf5159db048cf4d43fc2af7309ed3fc6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -72,9 +72,11 @@ use ty::error::TypeError;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n use errors::{DiagnosticBuilder, DiagnosticStyledString};\n-\n mod note;\n+\n mod need_type_info;\n+mod named_anon_conflict;\n+\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -255,34 +257,48 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn report_region_errors(&self,\n-                                errors: &Vec<RegionResolutionError<'tcx>>) {\n+\n+    pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:\n         let errors = self.process_errors(errors);\n \n-        debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n+        debug!(\"report_region_errors: {} errors after preprocessing\",\n+               errors.len());\n \n         for error in errors {\n+\n             debug!(\"report_region_errors: error = {:?}\", error);\n-            match error.clone() {\n-                ConcreteFailure(origin, sub, sup) => {\n-                    self.report_concrete_failure(origin, sub, sup).emit();\n-                }\n \n-                GenericBoundFailure(kind, param_ty, sub) => {\n-                    self.report_generic_bound_failure(kind, param_ty, sub);\n-                }\n+            if !self.try_report_named_anon_conflict(&error){\n+\n+               match error.clone() {\n+                  // These errors could indicate all manner of different\n+                  // problems with many different solutions. Rather\n+                  // than generate a \"one size fits all\" error, what we\n+                  // attempt to do is go through a number of specific\n+                  // scenarios and try to find the best way to present\n+                  // the error. If all of these fails, we fall back to a rather\n+                  // general bit of code that displays the error information\n+                  ConcreteFailure(origin, sub, sup) => {\n+\n+                      self.report_concrete_failure(origin, sub, sup).emit();\n+                  }\n \n-                SubSupConflict(var_origin,\n+                  GenericBoundFailure(kind, param_ty, sub) => {\n+                      self.report_generic_bound_failure(kind, param_ty, sub);\n+                  }\n+\n+                  SubSupConflict(var_origin,\n                                sub_origin, sub_r,\n                                sup_origin, sup_r) => {\n-                    self.report_sub_sup_conflict(var_origin,\n+                      self.report_sub_sup_conflict(var_origin,\n                                                  sub_origin, sub_r,\n                                                  sup_origin, sup_r);\n-                }\n+                  }\n+               }\n             }\n         }\n     }"}, {"sha": "ccbc5cdb862f98eb96f26880a857b7091d3cbef9", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Error Reporting for Anonymous Region Lifetime Errors.\n+use hir;\n+use infer::InferCtxt;\n+use ty::{self, Region};\n+use infer::region_inference::RegionResolutionError::*;\n+use infer::region_inference::RegionResolutionError;\n+use hir::map as hir_map;\n+use hir::def_id::DefId;\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    // This method walks the Type of the function body arguments using\n+    // `fold_regions()` function and returns the\n+    // &hir::Arg of the function argument corresponding to the anonymous\n+    // region and the Ty corresponding to the named region.\n+    // Currently only the case where the function declaration consists of\n+    // one named region and one anonymous region is handled.\n+    // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n+    // Here, we would return the hir::Arg for y, we return the type &'a\n+    // i32, which is the type of y but with the anonymous region replaced\n+    // with 'a, the corresponding bound region and is_first which is true if\n+    // the hir::Arg is the first argument in the function declaration.\n+    fn find_arg_with_anonymous_region\n+        (&self,\n+         anon_region: Region<'tcx>,\n+         named_region: Region<'tcx>)\n+         -> Option<(&hir::Arg, ty::Ty<'tcx>, ty::BoundRegion, bool)> {\n+\n+        match *anon_region {\n+            ty::ReFree(ref free_region) => {\n+\n+                let id = free_region.scope;\n+                let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n+                let body_id = self.tcx.hir.maybe_body_owned_by(node_id).unwrap();\n+                let body = self.tcx.hir.body(body_id);\n+                if let Some(tables) = self.in_progress_tables {\n+                    body.arguments\n+                        .iter()\n+                        .enumerate()\n+                        .filter_map(|(index, arg)| {\n+                            let ty = tables.borrow().node_id_to_type(arg.id);\n+                            let mut found_anon_region = false;\n+                            let new_arg_ty = self.tcx\n+                                .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {\n+                                    found_anon_region = true;\n+                                    named_region\n+                                } else {\n+                                    r\n+                                });\n+                            if found_anon_region {\n+                                let is_first = index == 0;\n+                                Some((arg, new_arg_ty, free_region.bound_region, is_first))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .next()\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+\n+        }\n+    }\n+\n+    // This method generates the error message for the case when\n+    // the function arguments consist of a named region and an anonymous\n+    // region and corresponds to `ConcreteFailure(..)`\n+    pub fn try_report_named_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n+\n+        let (span, sub, sup) = match *error {\n+            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n+            _ => return false, // inapplicable\n+        };\n+\n+        // Determine whether the sub and sup consist of one named region ('a)\n+        // and one anonymous (elided) region. If so, find the parameter arg\n+        // where the anonymous region appears (there must always be one; we\n+        // only introduced anonymous regions in parameters) as well as a\n+        // version new_ty of its type where the anonymous region is replaced\n+        // with the named one.\n+        let (named, (arg, new_ty, br, is_first), scope_def_id) =\n+            if sub.is_named_region() && self.is_suitable_anonymous_region(sup).is_some() {\n+                (sub,\n+                 self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n+                 self.is_suitable_anonymous_region(sup).unwrap())\n+            } else if sup.is_named_region() && self.is_suitable_anonymous_region(sub).is_some() {\n+                (sup,\n+                 self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n+                 self.is_suitable_anonymous_region(sub).unwrap())\n+            } else {\n+                return false; // inapplicable\n+            };\n+\n+        // Here, we check for the case where the anonymous region\n+        // is in the return type.\n+        // FIXME(#42703) - Need to handle certain cases here.\n+        let ret_ty = self.tcx.type_of(scope_def_id);\n+        match ret_ty.sty {\n+            ty::TyFnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(self.tcx);\n+                let late_bound_regions = self.tcx\n+                    .collect_referenced_late_bound_regions(&sig.output());\n+                if late_bound_regions.iter().any(|r| *r == br) {\n+                    return false;\n+                } else {\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // Here we check for the case where anonymous region\n+        // corresponds to self and if yes, we display E0312.\n+        // FIXME(#42700) - Need to format self properly to\n+        // enable E0621 for it.\n+        if is_first &&\n+           self.tcx\n+               .opt_associated_item(scope_def_id)\n+               .map(|i| i.method_has_self_argument)\n+               .unwrap_or(false) {\n+            return false;\n+        }\n+\n+        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n+        } else {\n+            (format!(\"parameter type\"), format!(\"type\"))\n+        };\n+\n+\n+        struct_span_err!(self.tcx.sess,\n+                         span,\n+                         E0621,\n+                         \"explicit lifetime required in {}\",\n+                         error_var)\n+                .span_label(arg.pat.span,\n+                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n+                .span_label(span, format!(\"lifetime `{}` required\", named))\n+                .emit();\n+\n+        return true;\n+\n+    }\n+\n+    // This method returns whether the given Region is Anonymous\n+    // and returns the DefId corresponding to the region.\n+    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<DefId> {\n+\n+        match *region {\n+            ty::ReFree(ref free_region) => {\n+                match free_region.bound_region {\n+                    ty::BrAnon(..) => {\n+                        let anonymous_region_binding_scope = free_region.scope;\n+                        let node_id = self.tcx\n+                            .hir\n+                            .as_local_node_id(anonymous_region_binding_scope)\n+                            .unwrap();\n+                        match self.tcx.hir.find(node_id) {\n+                            Some(hir_map::NodeItem(..)) |\n+                            Some(hir_map::NodeTraitItem(..)) => {\n+                                // proceed ahead //\n+                            }\n+                            Some(hir_map::NodeImplItem(..)) => {\n+                                let container_id = self.tcx\n+                                    .associated_item(anonymous_region_binding_scope)\n+                                    .container\n+                                    .id();\n+                                if self.tcx.impl_trait_ref(container_id).is_some() {\n+                                    // For now, we do not try to target impls of traits. This is\n+                                    // because this message is going to suggest that the user\n+                                    // change the fn signature, but they may not be free to do so,\n+                                    // since the signature must match the trait.\n+                                    //\n+                                    // FIXME(#42706) -- in some cases, we could do better here.\n+                                    return None;\n+                                }\n+                            }\n+                            _ => return None, // inapplicable\n+                            // we target only top-level functions\n+                        }\n+                        return Some(anonymous_region_binding_scope);\n+                    }\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "a684881c0912abbb7ee967433d60d15c5ab6ecbd", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::{self, map, Local, Pat, Body};\n+use hir::{self, Local, Pat, Body};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use infer::InferCtxt;\n use infer::type_variable::TypeVariableOrigin;\n@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn need_type_info(&self, body_id: hir::BodyId, span: Span, ty: Ty<'tcx>) {\n+    pub fn need_type_info(&self, body_id: Option<hir::BodyId>, span: Span, ty: Ty<'tcx>) {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty);\n \n@@ -103,11 +103,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             found_arg_pattern: None,\n         };\n \n-        // #40294: cause.body_id can also be a fn declaration.\n-        // Currently, if it's anything other than NodeExpr, we just ignore it\n-        match self.tcx.hir.find(body_id.node_id) {\n-            Some(map::NodeExpr(expr)) => local_visitor.visit_expr(expr),\n-            _ => ()\n+        if let Some(body_id) = body_id {\n+            let expr = self.tcx.hir.expect_expr(body_id.node_id);\n+            local_visitor.visit_expr(expr);\n         }\n \n         if let Some(pattern) = local_visitor.found_arg_pattern {"}, {"sha": "5cb1606da6708bac132f6ea39d5ec936f2df412c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -38,7 +38,6 @@ use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n use util::nodemap::FxHashMap;\n use arena::DroplessArena;\n-\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n@@ -1077,6 +1076,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                region_map,\n                                                free_regions);\n         let errors = self.region_vars.resolve_regions(&region_rels);\n+\n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n@@ -1191,28 +1191,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // types using one of these methods, and should not call span_err directly for such\n     // errors.\n \n-    pub fn type_error_message<M>(&self,\n-                                 sp: Span,\n-                                 mk_msg: M,\n-                                 actual_ty: Ty<'tcx>)\n-        where M: FnOnce(String) -> String,\n-    {\n-        self.type_error_struct(sp, mk_msg, actual_ty).emit();\n-    }\n-\n-    // FIXME: this results in errors without an error code. Deprecate?\n-    pub fn type_error_struct<M>(&self,\n-                                sp: Span,\n-                                mk_msg: M,\n-                                actual_ty: Ty<'tcx>)\n-                                -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(String) -> String,\n-    {\n-        self.type_error_struct_with_diag(sp, |actual_ty| {\n-            self.tcx.sess.struct_span_err(sp, &mk_msg(actual_ty))\n-        }, actual_ty)\n-    }\n-\n     pub fn type_error_struct_with_diag<M>(&self,\n                                           sp: Span,\n                                           mk_diag: M,\n@@ -1369,7 +1347,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Some(self.tcx.closure_kind(def_id))\n     }\n \n-    pub fn closure_type(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n+    /// Obtain the signature of a function or closure.\n+    /// For closures, unlike `tcx.fn_sig(def_id)`, this method will\n+    /// work during the type-checking of the enclosing function and\n+    /// return the closure signature in its partially inferred state.\n+    pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n         if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 if let Some(&ty) = tables.borrow().closure_tys.get(&id) {\n@@ -1378,7 +1360,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.tcx.closure_type(def_id)\n+        self.tcx.fn_sig(def_id)\n     }\n }\n "}, {"sha": "e4cf893375c757e68d4695da606c7ca498c56314", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -39,7 +39,6 @@\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n #![feature(discriminant_value)]\n-#![feature(sort_unstable)]\n #![feature(trace_macros)]\n #![feature(test)]\n "}, {"sha": "8202c6106d14753e67db667eaeba4e2582f91a57", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -291,16 +291,13 @@ impl LintStore {\n         self.by_name.insert(name.into(), Removed(reason.into()));\n     }\n \n-    #[allow(unused_variables)]\n-    fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n-                 -> Result<LintId, FindLintError>\n-    {\n+    fn find_lint(&self, lint_name: &str) -> Result<LintId, FindLintError> {\n         match self.by_name.get(lint_name) {\n             Some(&Id(lint_id)) => Ok(lint_id),\n             Some(&Renamed(_, lint_id)) => {\n                 Ok(lint_id)\n             },\n-            Some(&Removed(ref reason)) => {\n+            Some(&Removed(_)) => {\n                 Err(FindLintError::Removed)\n             },\n             None => Err(FindLintError::NotFound)\n@@ -313,7 +310,7 @@ impl LintStore {\n                                     &lint_name[..], level);\n \n             let lint_flag_val = Symbol::intern(&lint_name);\n-            match self.find_lint(&lint_name[..], sess, None) {\n+            match self.find_lint(&lint_name[..]) {\n                 Ok(lint_id) => self.levels.set(lint_id, (level, CommandLine(lint_flag_val))),\n                 Err(FindLintError::Removed) => { }\n                 Err(_) => {\n@@ -513,7 +510,6 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n     }\n \n     let name = lint.name_lower();\n-    let mut def = None;\n \n     // Except for possible note details, forbid behaves like deny.\n     let effective_level = if level == Forbid { Deny } else { level };\n@@ -528,7 +524,8 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n \n     match source {\n         Default => {\n-            err.note(&format!(\"#[{}({})] on by default\", level.as_str(), name));\n+            sess.diag_note_once(&mut err, lint,\n+                                &format!(\"#[{}({})] on by default\", level.as_str(), name));\n         },\n         CommandLine(lint_flag_val) => {\n             let flag = match level {\n@@ -537,20 +534,24 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n             };\n             let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n             if lint_flag_val.as_str() == name {\n-                err.note(&format!(\"requested on the command line with `{} {}`\",\n-                                  flag, hyphen_case_lint_name));\n+                sess.diag_note_once(&mut err, lint,\n+                                    &format!(\"requested on the command line with `{} {}`\",\n+                                             flag, hyphen_case_lint_name));\n             } else {\n                 let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n-                err.note(&format!(\"`{} {}` implied by `{} {}`\",\n-                                  flag, hyphen_case_lint_name, flag, hyphen_case_flag_val));\n+                sess.diag_note_once(&mut err, lint,\n+                                    &format!(\"`{} {}` implied by `{} {}`\",\n+                                             flag, hyphen_case_lint_name, flag,\n+                                             hyphen_case_flag_val));\n             }\n         },\n         Node(lint_attr_name, src) => {\n-            def = Some(src);\n+            sess.diag_span_note_once(&mut err, lint, src, \"lint level defined here\");\n             if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n-                err.note(&format!(\"#[{}({})] implied by #[{}({})]\",\n-                                  level_str, name, level_str, lint_attr_name));\n+                sess.diag_note_once(&mut err, lint,\n+                                    &format!(\"#[{}({})] implied by #[{}({})]\",\n+                                             level_str, name, level_str, lint_attr_name));\n             }\n         }\n     }\n@@ -566,10 +567,6 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n         err.note(&citation);\n     }\n \n-    if let Some(span) = def {\n-        sess.diag_span_note_once(&mut err, lint, span, \"lint level defined here\");\n-    }\n-\n     err\n }\n \n@@ -724,21 +721,22 @@ pub trait LintContext<'tcx>: Sized {\n         let mut pushed = 0;\n \n         for result in gather_attrs(attrs) {\n-            let v = match result {\n+            let (is_group, lint_level_spans) = match result {\n                 Err(span) => {\n                     span_err!(self.sess(), span, E0452,\n                               \"malformed lint attribute\");\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints().find_lint(&lint_name.as_str(), &self.sess(), Some(span)) {\n-                        Ok(lint_id) => vec![(lint_id, level, span)],\n+                    match self.lints().find_lint(&lint_name.as_str()) {\n+                        Ok(lint_id) => (false, vec![(lint_id, level, span)]),\n                         Err(FindLintError::NotFound) => {\n                             match self.lints().lint_groups.get(&*lint_name.as_str()) {\n-                                Some(&(ref v, _)) => v.iter()\n+                                Some(&(ref v, _)) => (true,\n+                                                      v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n-                                                      .collect(),\n+                                                      .collect()),\n                                 None => {\n                                     // The lint or lint group doesn't exist.\n                                     // This is an error, but it was handled\n@@ -754,14 +752,18 @@ pub trait LintContext<'tcx>: Sized {\n \n             let lint_attr_name = result.expect(\"lint attribute should be well-formed\").0;\n \n-            for (lint_id, level, span) in v {\n+            for (lint_id, level, span) in lint_level_spans {\n                 let (now, now_source) = self.lint_sess().get_source(lint_id);\n                 if now == Forbid && level != Forbid {\n-                    let lint_name = lint_id.to_string();\n+                    let forbidden_lint_name = match now_source {\n+                        LintSource::Default => lint_id.to_string(),\n+                        LintSource::Node(name, _) => name.to_string(),\n+                        LintSource::CommandLine(name) => name.to_string(),\n+                    };\n                     let mut diag_builder = struct_span_err!(self.sess(), span, E0453,\n                                                             \"{}({}) overruled by outer forbid({})\",\n-                                                            level.as_str(), lint_name,\n-                                                            lint_name);\n+                                                            level.as_str(), lint_attr_name,\n+                                                            forbidden_lint_name);\n                     diag_builder.span_label(span, \"overruled by previous forbid\");\n                     match now_source {\n                         LintSource::Default => &mut diag_builder,\n@@ -772,7 +774,10 @@ pub trait LintContext<'tcx>: Sized {\n                         LintSource::CommandLine(_) => {\n                             diag_builder.note(\"`forbid` lint level was set on command line\")\n                         }\n-                    }.emit()\n+                    }.emit();\n+                    if is_group { // don't set a separate error for every lint in the group\n+                        break;\n+                    }\n                 } else if now != level {\n                     let cx = self.lint_sess_mut();\n                     cx.stack.push((lint_id, (now, now_source)));\n@@ -1420,7 +1425,7 @@ impl Decodable for LintId {\n     fn decode<D: Decoder>(d: &mut D) -> Result<LintId, D::Error> {\n         let s = d.read_str()?;\n         ty::tls::with(|tcx| {\n-            match tcx.sess.lint_store.borrow().find_lint(&s, tcx.sess, None) {\n+            match tcx.sess.lint_store.borrow().find_lint(&s) {\n                 Ok(id) => Ok(id),\n                 Err(_) => panic!(\"invalid lint-id `{}`\", s),\n             }"}, {"sha": "eab5a8f910331184187caac0a7dd822df61afd86", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -12,7 +12,7 @@\n //! `unsafe`.\n use self::RootUnsafeContext::*;\n \n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, TyCtxt};\n use lint;\n \n use syntax::ast;\n@@ -40,14 +40,6 @@ enum RootUnsafeContext {\n     UnsafeBlock(ast::NodeId),\n }\n \n-fn type_is_unsafe_function(ty: Ty) -> bool {\n-    match ty.sty {\n-        ty::TyFnDef(.., f) |\n-        ty::TyFnPtr(f) => f.unsafety() == hir::Unsafety::Unsafe,\n-        _ => false,\n-    }\n-}\n-\n struct EffectCheckVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -174,10 +166,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n-                let base_type = self.tcx.type_of(def_id);\n-                debug!(\"effect: method call case, base type is {:?}\",\n-                        base_type);\n-                if type_is_unsafe_function(base_type) {\n+                let sig = self.tcx.fn_sig(def_id);\n+                debug!(\"effect: method call case, signature is {:?}\",\n+                        sig);\n+\n+                if sig.0.unsafety == hir::Unsafety::Unsafe {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n                 }\n@@ -186,8 +179,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n                 let base_type = self.tables.expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n-                if type_is_unsafe_function(base_type) {\n-                    self.require_unsafe(expr.span, \"call to unsafe function\")\n+                match base_type.sty {\n+                    ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                        if base_type.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n+                            self.require_unsafe(expr.span, \"call to unsafe function\")\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {"}, {"sha": "259bd4f09991590df6ef072868299737e75677b6", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -816,7 +816,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n         debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n-        let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n@@ -864,13 +863,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             match def {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {\n-                    let enum_did = tcx.parent_def_id(variant_did).unwrap();\n-                    let downcast_cmt = if tcx.adt_def(enum_did).is_univariant() {\n-                        cmt_pat\n-                    } else {\n-                        let cmt_pat_ty = cmt_pat.ty;\n-                        mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n-                    };\n+                    let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);"}, {"sha": "fde207e4b2f79f75922a2fb36ef74ce9739ad07b", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -66,11 +66,8 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.tcx.type_of(def_id).sty {\n-            ty::TyFnDef(.., bfty) => bfty.abi() == RustIntrinsic,\n-            _ => return false\n-        };\n-        intrinsic && self.tcx.item_name(def_id) == \"transmute\"\n+        self.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n+        self.tcx.item_name(def_id) == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>) {\n@@ -153,22 +150,14 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n         } else {\n             Def::Err\n         };\n-        match def {\n-            Def::Fn(did) if self.def_id_is_transmute(did) => {\n+        if let Def::Fn(did) = def {\n+            if self.def_id_is_transmute(did) {\n                 let typ = self.tables.node_id_to_type(expr.id);\n-                let typ = self.tcx.lift_to_global(&typ).unwrap();\n-                match typ.sty {\n-                    ty::TyFnDef(.., sig) if sig.abi() == RustIntrinsic => {\n-                        let from = sig.inputs().skip_binder()[0];\n-                        let to = *sig.output().skip_binder();\n-                        self.check_transmute(expr.span, from, to);\n-                    }\n-                    _ => {\n-                        span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n-                    }\n-                }\n+                let sig = typ.fn_sig(self.tcx);\n+                let from = sig.inputs().skip_binder()[0];\n+                let to = *sig.output().skip_binder();\n+                self.check_transmute(expr.span, from, to);\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);"}, {"sha": "5c741eccf83c7e23686efe991b5ee14116f22252", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1032,22 +1032,29 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n-    pub fn cat_downcast<N:ast_node>(&self,\n-                                    node: &N,\n-                                    base_cmt: cmt<'tcx>,\n-                                    downcast_ty: Ty<'tcx>,\n-                                    variant_did: DefId)\n-                                    -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n-            id: node.id(),\n-            span: node.span(),\n-            mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Downcast(base_cmt, variant_did),\n-            ty: downcast_ty,\n-            note: NoteNone\n-        });\n-        debug!(\"cat_downcast ret={:?}\", ret);\n-        ret\n+    pub fn cat_downcast_if_needed<N:ast_node>(&self,\n+                                              node: &N,\n+                                              base_cmt: cmt<'tcx>,\n+                                              variant_did: DefId)\n+                                              -> cmt<'tcx> {\n+        // univariant enums do not need downcasts\n+        let base_did = self.tcx.parent_def_id(variant_did).unwrap();\n+        if !self.tcx.adt_def(base_did).is_univariant() {\n+            let base_ty = base_cmt.ty;\n+            let ret = Rc::new(cmt_ {\n+                id: node.id(),\n+                span: node.span(),\n+                mutbl: base_cmt.mutbl.inherit(),\n+                cat: Categorization::Downcast(base_cmt, variant_did),\n+                ty: base_ty,\n+                note: NoteNone\n+            });\n+            debug!(\"cat_downcast ret={:?}\", ret);\n+            ret\n+        } else {\n+            debug!(\"cat_downcast univariant={:?}\", base_cmt);\n+            base_cmt\n+        }\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n@@ -1109,45 +1116,23 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         op(cmt.clone(), pat);\n \n-        // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n-        // alone) because PatKind::Struct can also refer to variants.\n-        let cmt = match pat.node {\n-            PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n-            PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n-            PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n-                match path.def {\n-                    Def::Err => {\n-                        debug!(\"access to unresolvable pattern {:?}\", pat);\n-                        return Err(())\n-                    }\n-                    Def::Variant(variant_did) |\n-                    Def::VariantCtor(variant_did, ..) => {\n-                        // univariant enums do not need downcasts\n-                        let enum_did = self.tcx.parent_def_id(variant_did).unwrap();\n-                        if !self.tcx.adt_def(enum_did).is_univariant() {\n-                            self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n-                        } else {\n-                            cmt\n-                        }\n-                    }\n-                    _ => cmt\n-                }\n-            }\n-            _ => cmt\n-        };\n-\n         match pat.node {\n           PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n             let def = self.tables.qpath_def(qpath, pat.id);\n-            let expected_len = match def {\n+            let (cmt, expected_len) = match def {\n+                Def::Err => {\n+                    debug!(\"access to unresolvable pattern {:?}\", pat);\n+                    return Err(())\n+                }\n                 Def::VariantCtor(def_id, CtorKind::Fn) => {\n                     let enum_def = self.tcx.parent_def_id(def_id).unwrap();\n-                    self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len()\n+                    (self.cat_downcast_if_needed(pat, cmt, def_id),\n+                     self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len())\n                 }\n                 Def::StructCtor(_, CtorKind::Fn) => {\n                     match self.pat_ty(&pat)?.sty {\n                         ty::TyAdt(adt_def, _) => {\n-                            adt_def.struct_variant().fields.len()\n+                            (cmt, adt_def.struct_variant().fields.len())\n                         }\n                         ref ty => {\n                             span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n@@ -1168,8 +1153,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Struct(_, ref field_pats, _) => {\n+          PatKind::Struct(ref qpath, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n+            let def = self.tables.qpath_def(qpath, pat.id);\n+            let cmt = match def {\n+                Def::Err => {\n+                    debug!(\"access to unresolvable pattern {:?}\", pat);\n+                    return Err(())\n+                },\n+                Def::Variant(variant_did) |\n+                Def::VariantCtor(variant_did, ..) => {\n+                    self.cat_downcast_if_needed(pat, cmt, variant_did)\n+                },\n+                _ => cmt\n+            };\n+\n             for fp in field_pats {\n                 let field_ty = self.pat_ty(&fp.node.pat)?; // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.name, field_ty);"}, {"sha": "b347a93185124b21852a2c51c377885b52b1d82b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -28,6 +28,7 @@ use syntax::attr;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n+use util::common::ErrorReported;\n use util::nodemap::{NodeMap, NodeSet, FxHashSet, FxHashMap, DefIdMap};\n use rustc_back::slice;\n \n@@ -255,7 +256,7 @@ const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n pub fn krate(sess: &Session,\n              hir_map: &Map)\n-             -> Result<NamedRegionMap, usize> {\n+             -> Result<NamedRegionMap, ErrorReported> {\n     let krate = hir_map.krate();\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),"}, {"sha": "8bafdda234a09b1589a30b7314f8d156a9e8b961", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -21,7 +21,7 @@ use session::search_paths::PathKind;\n use session::config::DebugInfoLevel;\n use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n-use util::common::duration_to_secs_str;\n+use util::common::{duration_to_secs_str, ErrorReported};\n \n use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder};\n@@ -79,10 +79,10 @@ pub struct Session {\n     pub working_dir: (String, bool),\n     pub lint_store: RefCell<lint::LintStore>,\n     pub lints: RefCell<lint::LintTable>,\n-    /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n-    /// that have been set once, but should not be set again, in order to avoid\n-    /// redundantly verbose output (Issue #24690).\n-    pub one_time_diagnostics: RefCell<FxHashSet<(lint::LintId, Span, String)>>,\n+    /// Set of (LintId, Option<Span>, message) tuples tracking lint\n+    /// (sub)diagnostics that have been set once, but should not be set again,\n+    /// in order to avoid redundantly verbose output (Issue #24690).\n+    pub one_time_diagnostics: RefCell<FxHashSet<(lint::LintId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n@@ -157,6 +157,13 @@ pub struct PerfStats {\n     pub decode_def_path_tables_time: Cell<Duration>,\n }\n \n+/// Enum to support dispatch of one-time diagnostics (in Session.diag_once)\n+enum DiagnosticBuilderMethod {\n+    Note,\n+    SpanNote,\n+    // add more variants as needed to support one-time diagnostics\n+}\n+\n impl Session {\n     pub fn local_crate_disambiguator(&self) -> Symbol {\n         *self.crate_disambiguator.borrow()\n@@ -248,7 +255,10 @@ impl Session {\n     pub fn abort_if_errors(&self) {\n         self.diagnostic().abort_if_errors();\n     }\n-    pub fn track_errors<F, T>(&self, f: F) -> Result<T, usize>\n+    pub fn compile_status(&self) -> Result<(), CompileIncomplete> {\n+        compile_result_from_err_count(self.err_count())\n+    }\n+    pub fn track_errors<F, T>(&self, f: F) -> Result<T, ErrorReported>\n         where F: FnOnce() -> T\n     {\n         let old_count = self.err_count();\n@@ -257,7 +267,7 @@ impl Session {\n         if errors == 0 {\n             Ok(result)\n         } else {\n-            Err(errors)\n+            Err(ErrorReported)\n         }\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n@@ -329,34 +339,53 @@ impl Session {\n         &self.parse_sess.span_diagnostic\n     }\n \n-    /// Analogous to calling `.span_note` on the given DiagnosticBuilder, but\n-    /// deduplicates on lint ID, span, and message for this `Session` if we're\n-    /// not outputting in JSON mode.\n-    //\n-    // FIXME: if the need arises for one-time diagnostics other than\n-    // `span_note`, we almost certainly want to generalize this\n-    // \"check/insert-into the one-time diagnostics map, then set message if\n-    // it's not already there\" code to accomodate all of them\n-    pub fn diag_span_note_once<'a, 'b>(&'a self,\n-                                       diag_builder: &'b mut DiagnosticBuilder<'a>,\n-                                       lint: &'static lint::Lint, span: Span, message: &str) {\n+    /// Analogous to calling methods on the given `DiagnosticBuilder`, but\n+    /// deduplicates on lint ID, span (if any), and message for this `Session`\n+    /// if we're not outputting in JSON mode.\n+    fn diag_once<'a, 'b>(&'a self,\n+                         diag_builder: &'b mut DiagnosticBuilder<'a>,\n+                         method: DiagnosticBuilderMethod,\n+                         lint: &'static lint::Lint, message: &str, span: Option<Span>) {\n+        let mut do_method = || {\n+            match method {\n+                DiagnosticBuilderMethod::Note => {\n+                    diag_builder.note(message);\n+                },\n+                DiagnosticBuilderMethod::SpanNote => {\n+                    diag_builder.span_note(span.expect(\"span_note expects a span\"), message);\n+                }\n+            }\n+        };\n+\n         match self.opts.error_format {\n             // when outputting JSON for tool consumption, the tool might want\n             // the duplicates\n             config::ErrorOutputType::Json => {\n-                diag_builder.span_note(span, &message);\n+                do_method()\n             },\n             _ => {\n                 let lint_id = lint::LintId::of(lint);\n                 let id_span_message = (lint_id, span, message.to_owned());\n                 let fresh = self.one_time_diagnostics.borrow_mut().insert(id_span_message);\n                 if fresh {\n-                    diag_builder.span_note(span, &message);\n+                    do_method()\n                 }\n             }\n         }\n     }\n \n+    pub fn diag_span_note_once<'a, 'b>(&'a self,\n+                                       diag_builder: &'b mut DiagnosticBuilder<'a>,\n+                                       lint: &'static lint::Lint, span: Span, message: &str) {\n+        self.diag_once(diag_builder, DiagnosticBuilderMethod::SpanNote, lint, message, Some(span));\n+    }\n+\n+    pub fn diag_note_once<'a, 'b>(&'a self,\n+                                  diag_builder: &'b mut DiagnosticBuilder<'a>,\n+                                  lint: &'static lint::Lint, message: &str) {\n+        self.diag_once(diag_builder, DiagnosticBuilderMethod::Note, lint, message, None);\n+    }\n+\n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n         self.parse_sess.codemap()\n     }\n@@ -776,15 +805,23 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);\n }\n \n-// Err(0) means compilation was stopped, but no errors were found.\n-// This would be better as a dedicated enum, but using try! is so convenient.\n-pub type CompileResult = Result<(), usize>;\n+#[derive(Copy, Clone, Debug)]\n+pub enum CompileIncomplete {\n+    Stopped,\n+    Errored(ErrorReported)\n+}\n+impl From<ErrorReported> for CompileIncomplete {\n+    fn from(err: ErrorReported) -> CompileIncomplete {\n+        CompileIncomplete::Errored(err)\n+    }\n+}\n+pub type CompileResult = Result<(), CompileIncomplete>;\n \n pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n     if err_count == 0 {\n         Ok(())\n     } else {\n-        Err(err_count)\n+        Err(CompileIncomplete::Errored(ErrorReported))\n     }\n }\n "}, {"sha": "0bf0e21baaf93e2973ff6886bb1e6a6cd55dbf62", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -45,7 +45,8 @@ use syntax_pos::{DUMMY_SP, Span};\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n-                                     errors: &Vec<FulfillmentError<'tcx>>) {\n+                                     errors: &Vec<FulfillmentError<'tcx>>,\n+                                     body_id: Option<hir::BodyId>) {\n         #[derive(Debug)]\n         struct ErrorDescriptor<'tcx> {\n             predicate: ty::Predicate<'tcx>,\n@@ -105,7 +106,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         for (error, suppressed) in errors.iter().zip(is_suppressed) {\n             if !suppressed {\n-                self.report_fulfillment_error(error);\n+                self.report_fulfillment_error(error, body_id);\n             }\n         }\n     }\n@@ -148,7 +149,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         false\n     }\n \n-    fn report_fulfillment_error(&self, error: &FulfillmentError<'tcx>) {\n+    fn report_fulfillment_error(&self, error: &FulfillmentError<'tcx>,\n+                                body_id: Option<hir::BodyId>) {\n         debug!(\"report_fulfillment_errors({:?})\", error);\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref e) => {\n@@ -158,7 +160,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.report_projection_error(&error.obligation, e);\n             }\n             FulfillmentErrorCode::CodeAmbiguity => {\n-                self.maybe_report_ambiguity(&error.obligation);\n+                self.maybe_report_ambiguity(&error.obligation, body_id);\n             }\n             FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n                 self.report_mismatched_types(&error.obligation.cause,\n@@ -869,14 +871,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n+    fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>,\n+                              body_id: Option<hir::BodyId>) {\n         // Unable to successfully determine, probably means\n         // insufficient type information, but could mean\n         // ambiguous impls. The latter *ought* to be a\n         // coherence violation, so we don't report it here.\n \n         let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n-        let body_id = hir::BodyId { node_id: obligation.cause.body_id };\n         let span = obligation.cause.span;\n \n         debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n@@ -953,7 +955,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n                     // both must be type variables, or the other would've been instantiated\n                     assert!(a.is_ty_var() && b.is_ty_var());\n-                    self.need_type_info(hir::BodyId { node_id: obligation.cause.body_id },\n+                    self.need_type_info(body_id,\n                                         obligation.cause.span,\n                                         a);\n                 }\n@@ -1058,7 +1060,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }\n             ObligationCauseCode::TupleElem => {\n-                err.note(\"tuple elements must have `Sized` type\");\n+                err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n                 err.note(&format!(\"required so that the projection `{}` is well-formed\",\n@@ -1088,13 +1090,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::VariableType(_) => {\n                 err.note(\"all local variables must have a statically known size\");\n             }\n-            ObligationCauseCode::ReturnType => {\n+            ObligationCauseCode::SizedReturnType => {\n                 err.note(\"the return type of a function must have a \\\n                           statically known size\");\n             }\n             ObligationCauseCode::AssignmentLhsSized => {\n                 err.note(\"the left-hand-side of an assignment must have a statically known size\");\n             }\n+            ObligationCauseCode::TupleInitializerSized => {\n+                err.note(\"tuples must have a statically known size to be initialized\");\n+            }\n             ObligationCauseCode::StructInitializerSized => {\n                 err.note(\"structs must have a statically known size to be initialized\");\n             }\n@@ -1133,6 +1138,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               but not on the corresponding trait method\",\n                              predicate));\n             }\n+            ObligationCauseCode::ReturnType(_) |\n+            ObligationCauseCode::BlockTailExpression(_) => (),\n         }\n     }\n "}, {"sha": "16c41c816b4ebc8852d864fe119e135d54dca035", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -118,65 +118,78 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n-    /// Various cases where expressions must be sized/copy/etc:\n-    AssignmentLhsSized,        // L = X implies that L is Sized\n-    StructInitializerSized,    // S { ... } must be Sized\n-    VariableType(ast::NodeId), // Type of each variable must be Sized\n-    ReturnType,                // Return type must be Sized\n-    RepeatVec,                 // [T,..n] --> T must be Copy\n-\n-    // Types of fields (other than the last) in a struct must be sized.\n+    // Various cases where expressions must be sized/copy/etc:\n+    /// L = X implies that L is Sized\n+    AssignmentLhsSized,\n+    /// (x1, .., xn) must be Sized\n+    TupleInitializerSized,\n+    /// S { ... } must be Sized\n+    StructInitializerSized,\n+    /// Type of each variable must be Sized\n+    VariableType(ast::NodeId),\n+    /// Return type must be Sized\n+    SizedReturnType,\n+    /// [T,..n] --> T must be Copy\n+    RepeatVec,\n+\n+    /// Types of fields (other than the last) in a struct must be sized.\n     FieldSized,\n \n-    // Constant expressions must be sized.\n+    /// Constant expressions must be sized.\n     ConstSized,\n \n-    // static items must have `Sync` type\n+    /// static items must have `Sync` type\n     SharedStatic,\n \n     BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n \n     ImplDerivedObligation(DerivedObligationCause<'tcx>),\n \n-    // error derived when matching traits/impls; see ObligationCause for more details\n+    /// error derived when matching traits/impls; see ObligationCause for more details\n     CompareImplMethodObligation {\n         item_name: ast::Name,\n         impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n         lint_id: Option<ast::NodeId>,\n     },\n \n-    // Checking that this expression can be assigned where it needs to be\n+    /// Checking that this expression can be assigned where it needs to be\n     // FIXME(eddyb) #11161 is the original Expr required?\n     ExprAssignable,\n \n-    // Computing common supertype in the arms of a match expression\n+    /// Computing common supertype in the arms of a match expression\n     MatchExpressionArm { arm_span: Span,\n                          source: hir::MatchSource },\n \n-    // Computing common supertype in an if expression\n+    /// Computing common supertype in an if expression\n     IfExpression,\n \n-    // Computing common supertype of an if expression with no else counter-part\n+    /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,\n \n-    // `where a == b`\n+    /// `where a == b`\n     EquatePredicate,\n \n-    // `main` has wrong type\n+    /// `main` has wrong type\n     MainFunctionType,\n \n-    // `start` has wrong type\n+    /// `start` has wrong type\n     StartFunctionType,\n \n-    // intrinsic has wrong type\n+    /// intrinsic has wrong type\n     IntrinsicType,\n \n-    // method receiver\n+    /// method receiver\n     MethodReceiver,\n \n-    // `return` with no expression\n+    /// `return` with no expression\n     ReturnNoExpression,\n+\n+    /// `return` with an expression\n+    ReturnType(ast::NodeId),\n+\n+    /// Block implicit return\n+    BlockTailExpression(ast::NodeId),\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -498,7 +511,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ) {\n             Ok(predicates) => predicates,\n             Err(errors) => {\n-                infcx.report_fulfillment_errors(&errors);\n+                infcx.report_fulfillment_errors(&errors, None);\n                 // An unnormalized env is better than nothing.\n                 return elaborated_env;\n             }\n@@ -597,7 +610,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n+    let result = tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::All);\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = FulfillmentContext::new();\n@@ -613,7 +626,10 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         fulfill_cx.select_all_or_error(&infcx).is_ok()\n-    })\n+    });\n+    debug!(\"normalize_and_test_predicates(predicates={:?}) = {:?}\",\n+           predicates, result);\n+    result\n }\n \n /// Given a trait `trait_ref`, iterates the vtable entries"}, {"sha": "c6c052fa4b1bc100b8bd034126464cd2d71d4bc8", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = self.type_of(method.def_id).fn_sig();\n+        let ref sig = self.fn_sig(method.def_id);\n         for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);"}, {"sha": "c356e53234d9c3e3248eb17138fce58c9f012e19", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1137,9 +1137,19 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n-    let sig = fn_type.fn_sig();\n+    let sig = fn_type.fn_sig(selcx.tcx());\n+    let Normalized {\n+        value: sig,\n+        obligations\n+    } = normalize_with_depth(selcx,\n+                             obligation.param_env,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &sig);\n+\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n         .with_addl_obligations(fn_pointer_vtable.nested)\n+        .with_addl_obligations(obligations)\n }\n \n fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n@@ -1149,7 +1159,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.closure_type(vtable.closure_def_id)\n+    let closure_type = closure_typer.fn_sig(vtable.closure_def_id)\n         .subst(selcx.tcx(), vtable.substs.substs);\n     let Normalized {\n         value: closure_type,"}, {"sha": "856fea7c2c437188fe97402e74924c96c2f65e11", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1404,19 +1404,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::TyFnDef(.., ty::Binder(ty::FnSig {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: Abi::Rust,\n-                variadic: false,\n-                ..\n-            })) |\n-            ty::TyFnPtr(ty::Binder(ty::FnSig {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: Abi::Rust,\n-                variadic: false,\n-                ..\n-            })) => {\n-                candidates.vec.push(FnPointerCandidate);\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                if let ty::Binder(ty::FnSig {\n+                    unsafety: hir::Unsafety::Normal,\n+                    abi: Abi::Rust,\n+                    variadic: false,\n+                    ..\n+                }) = self_ty.fn_sig(self.tcx()) {\n+                    candidates.vec.push(FnPointerCandidate);\n+                }\n             }\n \n             _ => { }\n@@ -1655,6 +1651,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 def_id_a == def_id_b\n             }\n \n+            // (.., T) -> (.., U).\n+            (&ty::TyTuple(tys_a, _), &ty::TyTuple(tys_b, _)) => {\n+                tys_a.len() == tys_b.len()\n+            }\n+\n             _ => false\n         };\n \n@@ -2348,19 +2349,26 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // ok to skip binder; it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let sig = self_ty.fn_sig();\n+        let sig = self_ty.fn_sig(self.tcx());\n         let trait_ref =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n                                                          self_ty,\n                                                          sig,\n                                                          util::TupleArgumentsFlag::Yes)\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n+        let Normalized { value: trait_ref, obligations } =\n+            project::normalize_with_depth(self,\n+                                          obligation.param_env,\n+                                          obligation.cause.clone(),\n+                                          obligation.recursion_depth + 1,\n+                                          &trait_ref);\n+\n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                      obligation.param_env,\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n-        Ok(VtableFnPointerData { fn_ty: self_ty, nested: vec![] })\n+        Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n     }\n \n     fn confirm_closure_candidate(&mut self,\n@@ -2588,8 +2596,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let inner_source = field.subst(tcx, substs_a);\n                 let inner_target = field.subst(tcx, substs_b);\n \n-                // Check that the source structure with the target's\n-                // type parameters is a subtype of the target.\n+                // Check that the source struct with the target's\n+                // unsized parameters is equal to the target.\n                 let params = substs_a.iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n                         Kind::from(substs_b.type_at(i))\n@@ -2614,6 +2622,37 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     &[inner_target]));\n             }\n \n+            // (.., T) -> (.., U).\n+            (&ty::TyTuple(tys_a, _), &ty::TyTuple(tys_b, _)) => {\n+                assert_eq!(tys_a.len(), tys_b.len());\n+\n+                // The last field of the tuple has to exist.\n+                let (a_last, a_mid) = if let Some(x) = tys_a.split_last() {\n+                    x\n+                } else {\n+                    return Err(Unimplemented);\n+                };\n+                let b_last = tys_b.last().unwrap();\n+\n+                // Check that the source tuple with the target's\n+                // last element is equal to the target.\n+                let new_tuple = tcx.mk_tup(a_mid.iter().chain(Some(b_last)), false);\n+                let InferOk { obligations, .. } =\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(target, new_tuple)\n+                              .map_err(|_| Unimplemented)?;\n+                self.inferred_obligations.extend(obligations);\n+\n+                // Construct the nested T: Unsize<U> predicate.\n+                nested.push(tcx.predicate_for_trait_def(\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.predicate.def_id(),\n+                    obligation.recursion_depth + 1,\n+                    a_last,\n+                    &[b_last]));\n+            }\n+\n             _ => bug!()\n         };\n \n@@ -2799,7 +2838,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let closure_type = self.infcx.closure_type(closure_def_id)\n+        let closure_type = self.infcx.fn_sig(closure_def_id)\n             .subst(self.tcx(), substs.substs);\n         let ty::Binder((trait_ref, _)) =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),"}, {"sha": "c4479e6903267a5f5d3036bdc9d62a25aa46f85c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -189,9 +189,11 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 tcx.lift(&ty).map(super::ObjectCastObligation)\n             }\n             super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n+            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n             super::StructInitializerSized => Some(super::StructInitializerSized),\n             super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnType => Some(super::ReturnType),\n+            super::ReturnType(id) => Some(super::ReturnType(id)),\n+            super::SizedReturnType => Some(super::SizedReturnType),\n             super::RepeatVec => Some(super::RepeatVec),\n             super::FieldSized => Some(super::FieldSized),\n             super::ConstSized => Some(super::ConstSized),\n@@ -213,34 +215,19 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                     lint_id: lint_id,\n                 })\n             }\n-            super::ExprAssignable => {\n-                Some(super::ExprAssignable)\n-            }\n+            super::ExprAssignable => Some(super::ExprAssignable),\n             super::MatchExpressionArm { arm_span, source } => {\n                 Some(super::MatchExpressionArm { arm_span: arm_span,\n                                                  source: source })\n             }\n-            super::IfExpression => {\n-                Some(super::IfExpression)\n-            }\n-            super::IfExpressionWithNoElse => {\n-                Some(super::IfExpressionWithNoElse)\n-            }\n-            super::EquatePredicate => {\n-                Some(super::EquatePredicate)\n-            }\n-            super::MainFunctionType => {\n-                Some(super::MainFunctionType)\n-            }\n-            super::StartFunctionType => {\n-                Some(super::StartFunctionType)\n-            }\n-            super::IntrinsicType => {\n-                Some(super::IntrinsicType)\n-            }\n-            super::MethodReceiver => {\n-                Some(super::MethodReceiver)\n-            }\n+            super::IfExpression => Some(super::IfExpression),\n+            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n+            super::EquatePredicate => Some(super::EquatePredicate),\n+            super::MainFunctionType => Some(super::MainFunctionType),\n+            super::StartFunctionType => Some(super::StartFunctionType),\n+            super::IntrinsicType => Some(super::IntrinsicType),\n+            super::MethodReceiver => Some(super::MethodReceiver),\n+            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n         }\n     }\n }\n@@ -490,14 +477,17 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::TupleElem |\n             super::ItemObligation(_) |\n             super::AssignmentLhsSized |\n+            super::TupleInitializerSized |\n             super::StructInitializerSized |\n             super::VariableType(_) |\n-            super::ReturnType |\n+            super::ReturnType(_) |\n+            super::SizedReturnType |\n             super::ReturnNoExpression |\n             super::RepeatVec |\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n+            super::BlockTailExpression(_) |\n             super::CompareImplMethodObligation { .. } => self.clone(),\n \n             super::ProjectionWf(proj) => super::ProjectionWf(proj.fold_with(folder)),\n@@ -535,14 +525,17 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::TupleElem |\n             super::ItemObligation(_) |\n             super::AssignmentLhsSized |\n+            super::TupleInitializerSized |\n             super::StructInitializerSized |\n             super::VariableType(_) |\n-            super::ReturnType |\n+            super::ReturnType(_) |\n+            super::SizedReturnType |\n             super::ReturnNoExpression |\n             super::RepeatVec |\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n+            super::BlockTailExpression(_) |\n             super::CompareImplMethodObligation { .. } => false,\n \n             super::ProjectionWf(proj) => proj.visit_with(visitor),"}, {"sha": "5f869fc5567ee186d58a7641505634de882a94b9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1378,9 +1378,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_fn_def(self, def_id: DefId,\n-                     substs: &'tcx Substs<'tcx>,\n-                     fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnDef(def_id, substs, fty))\n+                     substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnDef(def_id, substs))\n     }\n \n     pub fn mk_fn_ptr(self, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {"}, {"sha": "68f85ba7d33e23dc87beb3ab93134b71352c6edd", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -68,14 +68,15 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             // view of possibly unifying\n             simplify_type(tcx, mt.ty, can_simplify_params)\n         }\n+        ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n         ty::TyNever => Some(NeverSimplifiedType),\n         ty::TyTuple(ref tys, _) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n-        ty::TyFnDef(.., ref f) | ty::TyFnPtr(ref f) => {\n+        ty::TyFnPtr(ref f) => {\n             Some(FunctionSimplifiedType(f.skip_binder().inputs().len()))\n         }\n         ty::TyProjection(_) | ty::TyParam(_) => {"}, {"sha": "d5aa9f55ff0c4e34beb5942070f79ba6bee1f78b", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -155,9 +155,8 @@ impl FlagComputation {\n                 self.add_tys(&ts[..]);\n             }\n \n-            &ty::TyFnDef(_, substs, f) => {\n+            &ty::TyFnDef(_, substs) => {\n                 self.add_substs(substs);\n-                self.add_fn_sig(f);\n             }\n \n             &ty::TyFnPtr(f) => {"}, {"sha": "b9896e0cecf5dac93d19cebe75950af51194daf8", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -348,7 +348,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n                                       .filter_map(|ty| characteristic_def_id_of_type(ty))\n                                       .next(),\n \n-        ty::TyFnDef(def_id, ..) |\n+        ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => Some(def_id),\n \n         ty::TyBool |"}, {"sha": "e1aa89078a33b5456973752d268e4422b2f01f0e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1220,12 +1220,16 @@ impl<'a, 'tcx> Layout {\n             }\n \n             ty::TyTuple(tys, _) => {\n-                // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked.\n-                // See the univariant case below to learn how.\n+                let kind = if tys.len() == 0 {\n+                    StructKind::AlwaysSizedUnivariant\n+                } else {\n+                    StructKind::MaybeUnsizedUnivariant\n+                };\n+\n                 let st = Struct::new(dl,\n                     &tys.iter().map(|ty| ty.layout(tcx, param_env))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?;\n+                    &ReprOptions::default(), kind, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n "}, {"sha": "a6c59d4c2235436fc1e6f739b02c34ea76fa2bfc", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -875,13 +875,12 @@ define_maps! { <'tcx>\n     /// for trans. This is also the only query that can fetch non-local MIR, at present.\n     [] optimized_mir: Mir(DefId) -> &'tcx mir::Mir<'tcx>,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n+    /// Type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n     [] closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    [] closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    /// The signature of functions and closures.\n+    [] fn_sig: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n     [] coerce_unsized_info: ItemSignature(DefId)"}, {"sha": "548ee7bcbe503eb743630f388d4ec970fd177046", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -206,7 +206,7 @@ impl AssociatedItem {\n                 // late-bound regions, and we don't want method signatures to show up\n                 // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n                 // regions just fine, showing `fn(&MyType)`.\n-                format!(\"{}\", tcx.type_of(self.def_id).fn_sig().skip_binder())\n+                format!(\"{}\", tcx.fn_sig(self.def_id).skip_binder())\n             }\n             ty::AssociatedKind::Type => format!(\"type {};\", self.name.to_string()),\n             ty::AssociatedKind::Const => {\n@@ -481,6 +481,18 @@ impl<'tcx> TyS<'tcx> {\n             _ => false,\n         }\n     }\n+\n+    pub fn is_suggestable(&self) -> bool {\n+        match self.sty {\n+            TypeVariants::TyAnon(..) |\n+            TypeVariants::TyFnDef(..) |\n+            TypeVariants::TyFnPtr(..) |\n+            TypeVariants::TyDynamic(..) |\n+            TypeVariants::TyClosure(..) |\n+            TypeVariants::TyProjection(..) => false,\n+            _ => true,\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::TyS<'tcx> {"}, {"sha": "2e9780572c9b40bfa8d4ac2a1b1aafee64fb9835", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -291,7 +291,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = relation.relate_item_substs(a.def_id, a.substs, b.substs)?;\n+            let substs = relate_substs(relation, None, a.substs, b.substs)?;\n             Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n@@ -308,7 +308,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = relation.relate_item_substs(a.def_id, a.substs, b.substs)?;\n+            let substs = relate_substs(relation, None, a.substs, b.substs)?;\n             Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n@@ -440,13 +440,11 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             }\n         }\n \n-        (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n-         &ty::TyFnDef(b_def_id, b_substs, b_fty))\n+        (&ty::TyFnDef(a_def_id, a_substs), &ty::TyFnDef(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n-            let substs = relate_substs(relation, None, a_substs, b_substs)?;\n-            let fty = relation.relate(&a_fty, &b_fty)?;\n-            Ok(tcx.mk_fn_def(a_def_id, substs, fty))\n+            let substs = relation.relate_item_substs(a_def_id, a_substs, b_substs)?;\n+            Ok(tcx.mk_fn_def(a_def_id, substs))\n         }\n \n         (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>"}, {"sha": "d05262965d7fd6daf8505f23bcdd7bb51c842c8b", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -531,10 +531,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyDynamic(ref trait_ty, ref region) =>\n                 ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n             ty::TyTuple(ts, defaulted) => ty::TyTuple(ts.fold_with(folder), defaulted),\n-            ty::TyFnDef(def_id, substs, f) => {\n-                ty::TyFnDef(def_id,\n-                            substs.fold_with(folder),\n-                            f.fold_with(folder))\n+            ty::TyFnDef(def_id, substs) => {\n+                ty::TyFnDef(def_id, substs.fold_with(folder))\n             }\n             ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n             ty::TyRef(ref r, tm) => {\n@@ -568,9 +566,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyDynamic(ref trait_ty, ref reg) =>\n                 trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n             ty::TyTuple(ts, _) => ts.visit_with(visitor),\n-            ty::TyFnDef(_, substs, ref f) => {\n-                substs.visit_with(visitor) || f.visit_with(visitor)\n-            }\n+            ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),"}, {"sha": "452775e9e13379f45c0c74ffbfde85ad42b2ba51", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use hir::map::DefPathHash;\n \n use middle::region;\n-use ty::subst::Substs;\n+use ty::subst::{Substs, Subst};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n use ty::subst::Kind;\n@@ -138,7 +138,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n-    TyFnDef(DefId, &'tcx Substs<'tcx>, PolyFnSig<'tcx>),\n+    TyFnDef(DefId, &'tcx Substs<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n     TyFnPtr(PolyFnSig<'tcx>),\n@@ -990,6 +990,20 @@ impl RegionKind {\n \n         flags\n     }\n+\n+    // This method returns whether the given Region is Named\n+    pub fn is_named_region(&self) -> bool {\n+\n+        match *self {\n+            ty::ReFree(ref free_region) => {\n+                match free_region.bound_region {\n+                    ty::BrNamed(..) => true,\n+                    _ => false,\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n }\n \n /// Type utilities\n@@ -1329,9 +1343,12 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self) -> PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n         match self.sty {\n-            TyFnDef(.., f) | TyFnPtr(f) => f,\n+            TyFnDef(def_id, substs) => {\n+                tcx.fn_sig(def_id).subst(tcx, substs)\n+            }\n+            TyFnPtr(f) => f,\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }"}, {"sha": "df4bbad3859f4ecc46623ed3b7bf30911dc814c4", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -317,15 +317,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n-        while let (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs)) = (&a.sty, &b.sty) {\n-            if a_def != b_def || !a_def.is_struct() {\n-                break;\n-            }\n-            match a_def.struct_variant().fields.last() {\n-                Some(f) => {\n-                    a = f.ty(self, a_substs);\n-                    b = f.ty(self, b_substs);\n-                }\n+        loop {\n+            match (&a.sty, &b.sty) {\n+                (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs))\n+                        if a_def == b_def && a_def.is_struct() => {\n+                    if let Some(f) = a_def.struct_variant().fields.last() {\n+                        a = f.ty(self, a_substs);\n+                        b = f.ty(self, b_substs);\n+                    } else {\n+                        break;\n+                    }\n+                },\n+                (&TyTuple(a_tys, _), &TyTuple(b_tys, _))\n+                        if a_tys.len() == b_tys.len() => {\n+                    if let Some(a_last) = a_tys.last() {\n+                        a = a_last;\n+                        b = b_tys.last().unwrap();\n+                    } else {\n+                        break;\n+                    }\n+                },\n                 _ => break,\n             }\n         }\n@@ -679,7 +690,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n             TyAnon(def_id, _) |\n-            TyFnDef(def_id, ..) => self.def_id(def_id),\n+            TyFnDef(def_id, _) => self.def_id(def_id),\n             TyAdt(d, _) => self.def_id(d.did),\n             TyFnPtr(f) => {\n                 self.hash(f.unsafety());"}, {"sha": "71844abfe534c14b8e6cf5dcd0f6e97de1325467", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -115,9 +115,8 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());\n         }\n-        ty::TyFnDef(_, substs, ft) => {\n+        ty::TyFnDef(_, substs) => {\n             stack.extend(substs.types().rev());\n-            push_sig_subtypes(stack, ft);\n         }\n         ty::TyFnPtr(ft) => {\n             push_sig_subtypes(stack, ft);"}, {"sha": "eb6bffc29c56171ecc37cd1d07a7cc0571defb39", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -753,8 +753,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n                 write!(f, \")\")\n             }\n-            TyFnDef(def_id, substs, ref bare_fn) => {\n-                write!(f, \"{} {{\", bare_fn.0)?;\n+            TyFnDef(def_id, substs) => {\n+                ty::tls::with(|tcx| {\n+                    let mut sig = tcx.fn_sig(def_id);\n+                    if let Some(substs) = tcx.lift(&substs) {\n+                        sig = sig.subst(tcx, substs);\n+                    }\n+                    write!(f, \"{} {{\", sig.0)\n+                })?;\n                 parameterized(f, substs, def_id, &[])?;\n                 write!(f, \"}}\")\n             }"}, {"sha": "cb7721affe761778b2856826cfe31be29f698804", "filename": "src/librustc_asan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_asan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_asan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Fbuild.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -32,4 +32,5 @@ fn main() {\n             .build_target(\"asan\")\n             .build();\n     }\n+    println!(\"cargo:rerun-if-env-changed=LLVM_CONFIG\");\n }"}, {"sha": "3be7c43cab9388c654b1355134a105b1002793e9", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -18,8 +18,6 @@ pub use self::bckerr_code::*;\n pub use self::AliasableViolationKind::*;\n pub use self::MovedValueUseKind::*;\n \n-pub use self::mir::elaborate_drops::ElaborateDrops;\n-\n use self::InteriorKind::*;\n \n use rustc::hir::map as hir_map;\n@@ -55,8 +53,6 @@ pub mod gather_loans;\n \n pub mod move_data;\n \n-mod mir;\n-\n #[derive(Clone, Copy)]\n pub struct LoanDataFlowOperator;\n \n@@ -100,26 +96,21 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     }\n \n     let body_id = tcx.hir.body_owned_by(owner_id);\n-    let attributes = tcx.get_attrs(owner_def_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_maps = tcx.region_maps(owner_def_id);\n     let mut bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n \n     let body = bccx.tcx.hir.body(body_id);\n \n-    if bccx.tcx.has_attr(owner_def_id, \"rustc_mir_borrowck\") {\n-        mir::borrowck_mir(bccx, owner_id, &attributes);\n-    } else {\n-        // Eventually, borrowck will always read the MIR, but at the\n-        // moment we do not. So, for now, we always force MIR to be\n-        // constructed for a given fn, since this may result in errors\n-        // being reported and we want that to happen.\n-        //\n-        // Note that `mir_validated` is a \"stealable\" result; the\n-        // thief, `optimized_mir()`, forces borrowck, so we know that\n-        // is not yet stolen.\n-        tcx.mir_validated(owner_def_id).borrow();\n-    }\n+    // Eventually, borrowck will always read the MIR, but at the\n+    // moment we do not. So, for now, we always force MIR to be\n+    // constructed for a given fn, since this may result in errors\n+    // being reported and we want that to happen.\n+    //\n+    // Note that `mir_validated` is a \"stealable\" result; the\n+    // thief, `optimized_mir()`, forces borrowck, so we know that\n+    // is not yet stolen.\n+    tcx.mir_validated(owner_def_id).borrow();\n \n     let cfg = cfg::CFG::new(bccx.tcx, &body);\n     let AnalysisData { all_loans,"}, {"sha": "a2b1e3c26637dbd3876a7eccbb6bd3ce96ae9671", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -21,7 +21,6 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(associated_consts)]\n-#![feature(nonzero)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -39,7 +38,7 @@ extern crate core; // for NonZero\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n-pub use borrowck::{AnalysisData, BorrowckCtxt, ElaborateDrops};\n+pub use borrowck::{AnalysisData, BorrowckCtxt};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used."}, {"sha": "0a966b0c170712dceabb786c3b72e1e8f81bcc7f", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -12,7 +12,7 @@ use eval;\n \n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n use rustc::mir::{Field, BorrowKind, Mutability};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, TypeVariants, Region};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -549,8 +549,8 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     let substs = match ty.sty {\n-                        TypeVariants::TyAdt(_, substs) => substs,\n-                        TypeVariants::TyFnDef(_, substs, _) => substs,\n+                        ty::TyAdt(_, substs) |\n+                        ty::TyFnDef(_, substs) => substs,\n                         _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n                     };\n                     PatternKind::Variant {"}, {"sha": "a3e1cf7c1a8f81427179929d7bc6fb618d9008f0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -13,7 +13,8 @@ use rustc::hir::lowering::lower_crate;\n use rustc::ich::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_mir as mir;\n-use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n+use rustc::session::{Session, CompileResult};\n+use rustc::session::CompileIncomplete;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n                              OutputTypes};\n use rustc::session::search_paths::PathKind;\n@@ -23,7 +24,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::traits;\n-use rustc::util::common::time;\n+use rustc::util::common::{ErrorReported, time};\n use rustc::util::nodemap::NodeSet;\n use rustc::util::fs::rename_or_copy_remove;\n use rustc_borrowck as borrowck;\n@@ -78,7 +79,9 @@ pub fn compile_input(sess: &Session,\n             }\n \n             if control.$point.stop == Compilation::Stop {\n-                return compile_result_from_err_count($tsess.err_count());\n+                // FIXME: shouldn't this return Err(CompileIncomplete::Stopped)\n+                // if there are no errors?\n+                return $tsess.compile_status();\n             }\n         }}\n     }\n@@ -91,7 +94,7 @@ pub fn compile_input(sess: &Session,\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n                 parse_error.emit();\n-                return Err(1);\n+                return Err(CompileIncomplete::Errored(ErrorReported));\n             }\n         };\n \n@@ -194,7 +197,7 @@ pub fn compile_input(sess: &Session,\n                 (control.after_analysis.callback)(&mut state);\n \n                 if control.after_analysis.stop == Compilation::Stop {\n-                    return result.and_then(|_| Err(0usize));\n+                    return result.and_then(|_| Err(CompileIncomplete::Stopped));\n                 }\n             }\n \n@@ -564,7 +567,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n                                        addl_plugins: Option<Vec<String>>,\n                                        make_glob_map: MakeGlobMap,\n                                        after_expand: F)\n-                                       -> Result<ExpansionResult, usize>\n+                                       -> Result<ExpansionResult, CompileIncomplete>\n     where F: FnOnce(&ast::Crate) -> CompileResult,\n {\n     let time_passes = sess.time_passes();\n@@ -636,7 +639,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     // Lint plugins are registered; now we can process command line flags.\n     if sess.opts.describe_lints {\n         super::describe_lints(&sess.lint_store.borrow(), true);\n-        return Err(0);\n+        return Err(CompileIncomplete::Stopped);\n     }\n     sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess))?;\n \n@@ -839,7 +842,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                arenas: &'tcx GlobalArenas<'tcx>,\n                                                name: &str,\n                                                f: F)\n-                                               -> Result<R, usize>\n+                                               -> Result<R, CompileIncomplete>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n                             ty::CrateAnalysis,\n                             IncrementalHashesMap,\n@@ -920,6 +923,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // What we need to do constant evaluation.\n     passes.push_pass(MIR_CONST, mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n     passes.push_pass(MIR_CONST, mir::transform::type_check::TypeckMir);\n+    passes.push_pass(MIR_CONST, mir::transform::rustc_peek::SanityCheck);\n \n     // What we need to run borrowck etc.\n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n@@ -934,7 +938,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // From here on out, regions are gone.\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::erase_regions::EraseRegions);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n-    passes.push_pass(MIR_OPTIMIZED, borrowck::ElaborateDrops);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::elaborate_drops::ElaborateDrops);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n \n@@ -1018,7 +1022,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, analysis, incremental_hashes_map, Err(sess.err_count())));\n+            return Ok(f(tcx, analysis, incremental_hashes_map, sess.compile_status()));\n         }\n \n         analysis.reachable =\n@@ -1034,12 +1038,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes, \"lint checking\", || lint::check_crate(tcx));\n \n-        // The above three passes generate errors w/o aborting\n-        if sess.err_count() > 0 {\n-            return Ok(f(tcx, analysis, incremental_hashes_map, Err(sess.err_count())));\n-        }\n-\n-        Ok(f(tcx, analysis, incremental_hashes_map, Ok(())))\n+        return Ok(f(tcx, analysis, incremental_hashes_map, tcx.sess.compile_status()));\n     })\n }\n \n@@ -1115,11 +1114,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n          \"serialize work products\",\n          move || rustc_incremental::save_work_products(sess));\n \n-    if sess.err_count() > 0 {\n-        Err(sess.err_count())\n-    } else {\n-        Ok(())\n-    }\n+    sess.compile_status()\n }\n \n /// Run the linker on any artifacts that resulted from the LLVM run."}, {"sha": "802ed2a489b100cc87534c323090c8b2d37dd5b6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 94, "deletions": 28, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -67,14 +67,15 @@ use rustc_trans::back::link;\n use rustc_trans::back::write::{RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n+use rustc::session::CompileIncomplete;\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n-use rustc::util::common::time;\n+use rustc::util::common::{time, ErrorReported};\n \n use serialize::json::ToJson;\n \n@@ -83,10 +84,11 @@ use std::cmp::max;\n use std::cmp::Ordering::Equal;\n use std::default::Default;\n use std::env;\n+use std::ffi::OsString;\n use std::io::{self, Read, Write};\n use std::iter::repeat;\n use std::path::PathBuf;\n-use std::process;\n+use std::process::{self, Command, Stdio};\n use std::rc::Rc;\n use std::str;\n use std::sync::{Arc, Mutex};\n@@ -109,18 +111,14 @@ mod derive_registrar;\n const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n                                       md#bug-reports\";\n \n-#[inline]\n-fn abort_msg(err_count: usize) -> String {\n-    match err_count {\n-        0 => \"aborting with no errors (maybe a bug?)\".to_owned(),\n-        _ => \"aborting due to previous error(s)\".to_owned(),\n-    }\n-}\n-\n-pub fn abort_on_err<T>(result: Result<T, usize>, sess: &Session) -> T {\n+pub fn abort_on_err<T>(result: Result<T, CompileIncomplete>, sess: &Session) -> T {\n     match result {\n-        Err(err_count) => {\n-            sess.fatal(&abort_msg(err_count));\n+        Err(CompileIncomplete::Errored(ErrorReported)) => {\n+            sess.abort_if_errors();\n+            panic!(\"error reported but abort_if_errors didn't abort???\");\n+        }\n+        Err(CompileIncomplete::Stopped) => {\n+            sess.fatal(\"compilation terminated\");\n         }\n         Ok(x) => x,\n     }\n@@ -131,19 +129,20 @@ pub fn run<F>(run_compiler: F) -> isize\n {\n     monitor(move || {\n         let (result, session) = run_compiler();\n-        if let Err(err_count) = result {\n-            if err_count > 0 {\n-                match session {\n-                    Some(sess) => sess.fatal(&abort_msg(err_count)),\n-                    None => {\n-                        let emitter =\n-                            errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto, None);\n-                        let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n-                        handler.emit(&MultiSpan::new(),\n-                                     &abort_msg(err_count),\n-                                     errors::Level::Fatal);\n-                        exit_on_err();\n-                    }\n+        if let Err(CompileIncomplete::Errored(_)) = result {\n+            match session {\n+                Some(sess) => {\n+                    sess.abort_if_errors();\n+                    panic!(\"error reported but abort_if_errors didn't abort???\");\n+                }\n+                None => {\n+                    let emitter =\n+                        errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto, None);\n+                    let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n+                    handler.emit(&MultiSpan::new(),\n+                                 \"aborting due to previous error(s)\",\n+                                 errors::Level::Fatal);\n+                    exit_on_err();\n                 }\n             }\n         }\n@@ -345,6 +344,31 @@ pub trait CompilerCalls<'a> {\n #[derive(Copy, Clone)]\n pub struct RustcDefaultCalls;\n \n+// FIXME remove these and use winapi 0.3 instead\n+// Duplicates: bootstrap/compile.rs, librustc_errors/emitter.rs\n+#[cfg(unix)]\n+fn stdout_isatty() -> bool {\n+    unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n+}\n+\n+#[cfg(windows)]\n+fn stdout_isatty() -> bool {\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    type HANDLE = *mut u8;\n+    type LPDWORD = *mut u32;\n+    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n+    extern \"system\" {\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n+        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n+    }\n+    unsafe {\n+        let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n+        let mut out = 0;\n+        GetConsoleMode(handle, &mut out) != 0\n+    }\n+}\n+\n fn handle_explain(code: &str,\n                   descriptions: &errors::registry::Registry,\n                   output: ErrorOutputType) {\n@@ -356,19 +380,28 @@ fn handle_explain(code: &str,\n     match descriptions.find_description(&normalised) {\n         Some(ref description) => {\n             let mut is_in_code_block = false;\n+            let mut text = String::new();\n+\n             // Slice off the leading newline and print.\n             for line in description[1..].lines() {\n                 let indent_level = line.find(|c: char| !c.is_whitespace())\n                     .unwrap_or_else(|| line.len());\n                 let dedented_line = &line[indent_level..];\n                 if dedented_line.starts_with(\"```\") {\n                     is_in_code_block = !is_in_code_block;\n-                    println!(\"{}\", &line[..(indent_level+3)]);\n+                    text.push_str(&line[..(indent_level+3)]);\n                 } else if is_in_code_block && dedented_line.starts_with(\"# \") {\n                     continue;\n                 } else {\n-                    println!(\"{}\", line);\n+                    text.push_str(line);\n                 }\n+                text.push('\\n');\n+            }\n+\n+            if stdout_isatty() {\n+                show_content_with_pager(&text);\n+            } else {\n+                print!(\"{}\", text);\n             }\n         }\n         None => {\n@@ -377,6 +410,39 @@ fn handle_explain(code: &str,\n     }\n }\n \n+fn show_content_with_pager(content: &String) {\n+    let pager_name = env::var_os(\"PAGER\").unwrap_or_else(|| if cfg!(windows) {\n+        OsString::from(\"more.com\")\n+    } else {\n+        OsString::from(\"less\")\n+    });\n+\n+    let mut fallback_to_println = false;\n+\n+    match Command::new(pager_name).stdin(Stdio::piped()).spawn() {\n+        Ok(mut pager) => {\n+            if let Some(mut pipe) = pager.stdin.as_mut() {\n+                if pipe.write_all(content.as_bytes()).is_err() {\n+                    fallback_to_println = true;\n+                }\n+            }\n+\n+            if pager.wait().is_err() {\n+                fallback_to_println = true;\n+            }\n+        }\n+        Err(_) => {\n+            fallback_to_println = true;\n+        }\n+    }\n+\n+    // If pager fails for whatever reason, we should still print the content\n+    // to standard output\n+    if fallback_to_println {\n+        print!(\"{}\", content);\n+    }\n+}\n+\n impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,"}, {"sha": "4b71aa6b85f1c91c24f8dd0ea3a19fed0da9bf70", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -47,7 +47,12 @@ impl Emitter for EmitterWriter {\n                // don't display multiline suggestions as labels\n                sugg.substitution_parts[0].substitutions[0].find('\\n').is_none() {\n                 let substitution = &sugg.substitution_parts[0].substitutions[0];\n-                let msg = format!(\"help: {} `{}`\", sugg.msg, substitution);\n+                let msg = if substitution.len() == 0 {\n+                    // This substitution is only removal, don't show it\n+                    format!(\"help: {}\", sugg.msg)\n+                } else {\n+                    format!(\"help: {} `{}`\", sugg.msg, substitution)\n+                };\n                 primary_span.push_span_label(sugg.substitution_spans().next().unwrap(), msg);\n             } else {\n                 // if there are multiple suggestions, print them all in full"}, {"sha": "dd25f96941401f868d69e8502db9d9df14a34aa5", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -506,7 +506,10 @@ impl Handler {\n \n                 return;\n             }\n-            _ => s = \"aborting due to previous error(s)\".to_string(),\n+            1 => s = \"aborting due to previous error\".to_string(),\n+            _ => {\n+                s = format!(\"aborting due to {} previous errors\", self.err_count.get());\n+            }\n         }\n \n         panic!(self.fatal(&s));"}, {"sha": "ac3149b90b8af9a7a6ceb970a8678993834edb1a", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -20,7 +20,6 @@\n \n #![feature(rand)]\n #![feature(conservative_impl_trait)]\n-#![feature(sort_unstable)]\n \n extern crate graphviz;\n #[macro_use] extern crate rustc;"}, {"sha": "2b33150902532536d219720d89c2034c2efd8e4e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -684,13 +684,9 @@ fn fl_lit_check_expr(cx: &EarlyContext, expr: &ast::Expr) {\n         // These may occur in patterns\n         // and can maybe contain float literals\n         ExprKind::Unary(_, ref f) => fl_lit_check_expr(cx, f),\n-        // These may occur in patterns\n-        // and can't contain float literals\n-        ExprKind::Path(..) => (),\n-        // If something unhandled is encountered, we need to expand the\n-        // search or ignore more ExprKinds.\n-        _ => span_bug!(expr.span, \"Unhandled expression {:?} in float lit pattern lint\",\n-                       expr.node),\n+        // Other kinds of exprs can't occur in patterns so we don't have to check them\n+        // (ast_validation will emit an error if they occur)\n+        _ => (),\n     }\n }\n \n@@ -1154,24 +1150,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tables.node_id_to_type(expr.id);\n-                match typ.sty {\n-                    ty::TyFnDef(.., bare_fn) if bare_fn.abi() == RustIntrinsic => {\n-                        let from = bare_fn.inputs().skip_binder()[0];\n-                        let to = *bare_fn.output().skip_binder();\n-                        return Some((&from.sty, &to.sty));\n-                    }\n-                    _ => (),\n-                }\n+                let sig = cx.tables.node_id_to_type(expr.id).fn_sig(cx.tcx);\n+                let from = sig.inputs().skip_binder()[0];\n+                let to = *sig.output().skip_binder();\n+                return Some((&from.sty, &to.sty));\n             }\n             None\n         }\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n-            match cx.tcx.type_of(def_id).sty {\n-                ty::TyFnDef(.., bfty) if bfty.abi() == RustIntrinsic => (),\n-                _ => return false,\n-            }\n+            cx.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n             cx.tcx.item_name(def_id) == \"transmute\"\n         }\n     }"}, {"sha": "ac3977bd216e7a4587f293ffb4c961635c391766", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -659,7 +659,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n         let def_id = self.cx.tcx.hir.local_def_id(id);\n-        let sig = self.cx.tcx.type_of(def_id).fn_sig();\n+        let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {"}, {"sha": "3f0f5369607e527eb6ddb16050cfa79c52bae6d9", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -60,11 +60,7 @@ fn main() {\n         });\n \n     println!(\"cargo:rerun-if-changed={}\", llvm_config.display());\n-\n-    if let Some(cfg_toml) = env::var_os(\"CFG_LLVM_TOML\") {\n-        let cfg_path = PathBuf::from(cfg_toml);\n-        println!(\"cargo:rerun-if-changed={}\", cfg_path.display());\n-    }\n+    println!(\"cargo:rerun-if-env-changed=LLVM_CONFIG\");\n \n     // Test whether we're cross-compiling LLVM. This is a pretty rare case\n     // currently where we're producing an LLVM for a different platform than"}, {"sha": "770d16e5c029a6e6c21f1b1919bfaee93e83877d", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1597,7 +1597,13 @@ extern \"C\" {\n                                    Output: *const c_char,\n                                    FileType: FileType)\n                                    -> LLVMRustResult;\n-    pub fn LLVMRustPrintModule(PM: PassManagerRef, M: ModuleRef, Output: *const c_char);\n+    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n+                               M: ModuleRef,\n+                               Output: *const c_char,\n+                               Demangle: extern fn(*const c_char,\n+                                                   size_t,\n+                                                   *mut c_char,\n+                                                   size_t) -> size_t);\n     pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);"}, {"sha": "3d2ae480de6df3716abbd915b396120ba137f771", "filename": "src/librustc_lsan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_lsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_lsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Fbuild.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -32,4 +32,5 @@ fn main() {\n             .build_target(\"lsan\")\n             .build();\n     }\n+    println!(\"cargo:rerun-if-env-changed=LLVM_CONFIG\");\n }"}, {"sha": "54138e2e3b028461ae4ecd4cead4485e7d9abce7", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -107,7 +107,7 @@ provide! { <'tcx> tcx, def_id, cdata,\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n-    closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+    fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n     is_const_fn => { cdata.is_const_fn(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }"}, {"sha": "ad3a9dd9fefaf4c354000aef492aa2110e290d7a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1084,14 +1084,20 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn closure_ty(&self,\n-                      closure_id: DefIndex,\n-                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                      -> ty::PolyFnSig<'tcx> {\n-        match self.entry(closure_id).kind {\n-            EntryKind::Closure(data) => data.decode(self).ty.decode((self, tcx)),\n+    pub fn fn_sig(&self,\n+                  id: DefIndex,\n+                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                  -> ty::PolyFnSig<'tcx> {\n+        let sig = match self.entry(id).kind {\n+            EntryKind::Fn(data) |\n+            EntryKind::ForeignFn(data) => data.decode(self).sig,\n+            EntryKind::Method(data) => data.decode(self).fn_data.sig,\n+            EntryKind::Variant(data) |\n+            EntryKind::Struct(data, _) => data.decode(self).ctor_sig.unwrap(),\n+            EntryKind::Closure(data) => data.decode(self).sig,\n             _ => bug!(),\n-        }\n+        };\n+        sig.decode((self, tcx))\n     }\n \n     #[inline]"}, {"sha": "f74aac255a03909a33a10192b879dad55d8195fe", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -16,6 +16,7 @@ use schema::*;\n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n                             EncodedMetadata, EncodedMetadataHashes,\n                             EncodedMetadataHash};\n+use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::ich::Fingerprint;\n@@ -499,6 +500,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             struct_ctor: None,\n+            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n+                Some(self.lazy(&tcx.fn_sig(def_id)))\n+            } else {\n+                None\n+            }\n         };\n \n         let enum_id = tcx.hir.as_local_node_id(enum_did).unwrap();\n@@ -518,7 +524,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if variant.ctor_kind == CtorKind::Fn {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -617,6 +627,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             struct_ctor: Some(def_id.index),\n+            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n+                Some(self.lazy(&tcx.fn_sig(def_id)))\n+            } else {\n+                None\n+            }\n         };\n \n         let struct_id = tcx.hir.as_local_node_id(adt_def_id).unwrap();\n@@ -641,7 +656,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if variant.ctor_kind == CtorKind::Fn {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -695,7 +714,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names: arg_names\n+                        arg_names: arg_names,\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -732,7 +752,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 }\n             },\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if trait_item.kind == ty::AssociatedKind::Method {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -747,6 +771,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n+        let tcx = self.tcx;\n+\n         let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.hir.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n@@ -768,6 +794,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     FnData {\n                         constness: sig.constness,\n                         arg_names: self.encode_fn_arg_names_for_body(body),\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -806,7 +833,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if impl_item.kind == ty::AssociatedKind::Method {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -881,6 +912,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 let data = FnData {\n                     constness: constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n+                    sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n \n                 EntryKind::Fn(self.lazy(&data))\n@@ -910,6 +942,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     struct_ctor: struct_ctor,\n+                    ctor_sig: None,\n                 }), repr_options)\n             }\n             hir::ItemUnion(..) => {\n@@ -920,6 +953,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     struct_ctor: None,\n+                    ctor_sig: None,\n                 }), repr_options)\n             }\n             hir::ItemDefaultImpl(..) => {\n@@ -1037,7 +1071,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemTrait(..) => self.encode_variances_of(def_id),\n+                hir::ItemFn(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: match item.node {\n@@ -1176,7 +1210,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.closure_type(def_id)),\n+            sig: self.lazy(&tcx.fn_sig(def_id)),\n         };\n \n         Entry {\n@@ -1364,6 +1398,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n                     arg_names: self.encode_fn_arg_names(names),\n+                    sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(&data))\n             }\n@@ -1382,7 +1417,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: match nitem.node {\n+                hir::ForeignItemFn(..) => self.encode_variances_of(def_id),\n+                _ => LazySeq::empty(),\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n "}, {"sha": "99b718ea07b1e9cc6bc0a592702f2674b50d1b32", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -26,7 +26,6 @@\n #![feature(specialization)]\n #![feature(discriminant_value)]\n #![feature(rustc_private)]\n-#![feature(sort_unstable)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "9ef5b9408303d7f886ad74a3a145e2a872d6665b", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -343,18 +343,18 @@ pub enum EntryKind<'tcx> {\n     Type,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>, ReprOptions),\n-    Union(Lazy<VariantData>, ReprOptions),\n-    Fn(Lazy<FnData>),\n-    ForeignFn(Lazy<FnData>),\n+    Variant(Lazy<VariantData<'tcx>>),\n+    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Fn(Lazy<FnData<'tcx>>),\n+    ForeignFn(Lazy<FnData<'tcx>>),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n     Closure(Lazy<ClosureData<'tcx>>),\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n-    Method(Lazy<MethodData>),\n+    Method(Lazy<MethodData<'tcx>>),\n     AssociatedType(AssociatedContainer),\n     AssociatedConst(AssociatedContainer, u8),\n }\n@@ -439,27 +439,33 @@ pub struct MacroDef {\n impl_stable_hash_for!(struct MacroDef { body, legacy });\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct FnData {\n+pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n     pub arg_names: LazySeq<ast::Name>,\n+    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct FnData { constness, arg_names });\n+impl_stable_hash_for!(struct FnData<'tcx> { constness, arg_names, sig });\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData {\n+pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item.\n     pub struct_ctor: Option<DefIndex>,\n+\n+    /// If this is a tuple struct or variant\n+    /// ctor, this is its \"function\" signature.\n+    pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct VariantData {\n+impl_stable_hash_for!(struct VariantData<'tcx> {\n     ctor_kind,\n     discr,\n-    struct_ctor\n+    struct_ctor,\n+    ctor_sig\n });\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -543,16 +549,16 @@ impl AssociatedContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData {\n-    pub fn_data: FnData,\n+pub struct MethodData<'tcx> {\n+    pub fn_data: FnData<'tcx>,\n     pub container: AssociatedContainer,\n     pub has_self: bool,\n }\n-impl_stable_hash_for!(struct MethodData { fn_data, container, has_self });\n+impl_stable_hash_for!(struct MethodData<'tcx> { fn_data, container, has_self });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub kind: ty::ClosureKind,\n-    pub ty: Lazy<ty::PolyFnSig<'tcx>>,\n+    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n-impl_stable_hash_for!(struct ClosureData<'tcx> { kind, ty });\n+impl_stable_hash_for!(struct ClosureData<'tcx> { kind, sig });"}, {"sha": "326c1df69ebebd364c4990d2cadccd097c64985c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -205,11 +205,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n                 let diverges = expr.ty.is_never();\n                 let intrinsic = match ty.sty {\n-                    ty::TyFnDef(def_id, _, ref f) if\n-                        f.abi() == Abi::RustIntrinsic ||\n-                        f.abi() == Abi::PlatformIntrinsic =>\n-                    {\n-                        Some(this.hir.tcx().item_name(def_id).as_str())\n+                    ty::TyFnDef(def_id, _)  => {\n+                        let f = ty.fn_sig(this.hir.tcx());\n+                        if f.abi() == Abi::RustIntrinsic ||\n+                           f.abi() == Abi::PlatformIntrinsic {\n+                            Some(this.hir.tcx().item_name(def_id).as_str())\n+                        } else {\n+                            None\n+                        }\n                     }\n                     _ => None\n                 };"}, {"sha": "daafbecc5dfa3ba0d96642d125ac6ba5bd081b1f", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "renamed", "additions": 21, "deletions": 127, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,33 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrowck::BorrowckCtxt;\n-\n use syntax::ast::{self, MetaItem};\n use syntax_pos::DUMMY_SP;\n \n-use rustc::mir::{self, BasicBlock, BasicBlockData, Mir, Statement, Terminator, Location};\n+\n+use rustc::mir::{self, Mir, BasicBlock, Location};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n-use rustc_mir::util::elaborate_drops::DropFlagState;\n-use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n-\n-mod abs_domain;\n-pub mod elaborate_drops;\n-mod dataflow;\n-mod gather_moves;\n-// mod graphviz;\n-\n-use self::dataflow::{BitDenotation};\n-use self::dataflow::{DataflowOperator};\n-use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n-use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use self::dataflow::{DefinitelyInitializedLvals};\n-use self::gather_moves::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+use util::elaborate_drops::DropFlagState;\n+use rustc_data_structures::indexed_set::{IdxSet};\n \n use std::fmt;\n \n-fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n+use super::{Dataflow, DataflowBuilder, DataflowAnalysis};\n+use super::{BitDenotation, DataflowOperator, DataflowResults};\n+use super::indexes::MovePathIndex;\n+use super::move_paths::{MoveData, LookupResult};\n+\n+pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n     for attr in attrs {\n         if attr.check_name(\"rustc_mir\") {\n             let items = attr.meta_item_list();\n@@ -50,69 +41,11 @@ fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem>\n }\n \n pub struct MoveDataParamEnv<'tcx> {\n-    move_data: MoveData<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) move_data: MoveData<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n-                    id: ast::NodeId,\n-                    attributes: &[ast::Attribute]) {\n-    let tcx = bcx.tcx;\n-    let def_id = tcx.hir.local_def_id(id);\n-    debug!(\"borrowck_mir({:?}) UNIMPLEMENTED\", def_id);\n-\n-    // It is safe for us to borrow `mir_validated()`: `optimized_mir`\n-    // steals it, but it forces the `borrowck` query.\n-    let mir = &tcx.mir_validated(def_id).borrow();\n-\n-    let param_env = tcx.param_env(def_id);\n-    let move_data = MoveData::gather_moves(mir, tcx, param_env);\n-    let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-    let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n-    let flow_inits =\n-        do_dataflow(tcx, mir, id, attributes, &dead_unwinds,\n-                    MaybeInitializedLvals::new(tcx, mir, &mdpe),\n-                    |bd, i| &bd.move_data().move_paths[i]);\n-    let flow_uninits =\n-        do_dataflow(tcx, mir, id, attributes, &dead_unwinds,\n-                    MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n-                    |bd, i| &bd.move_data().move_paths[i]);\n-    let flow_def_inits =\n-        do_dataflow(tcx, mir, id, attributes, &dead_unwinds,\n-                    DefinitelyInitializedLvals::new(tcx, mir, &mdpe),\n-                    |bd, i| &bd.move_data().move_paths[i]);\n-\n-    if has_rustc_mir_with(attributes, \"rustc_peek_maybe_init\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &flow_inits);\n-    }\n-    if has_rustc_mir_with(attributes, \"rustc_peek_maybe_uninit\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &flow_uninits);\n-    }\n-    if has_rustc_mir_with(attributes, \"rustc_peek_definite_init\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &flow_def_inits);\n-    }\n-\n-    if has_rustc_mir_with(attributes, \"stop_after_dataflow\").is_some() {\n-        bcx.tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n-    }\n-\n-    let mut mbcx = MirBorrowckCtxt {\n-        bcx: bcx,\n-        mir: mir,\n-        node_id: id,\n-        move_data: &mdpe.move_data,\n-        flow_inits: flow_inits,\n-        flow_uninits: flow_uninits,\n-    };\n-\n-    for bb in mir.basic_blocks().indices() {\n-        mbcx.process_basic_block(bb);\n-    }\n-\n-    debug!(\"borrowck_mir done\");\n-}\n-\n-fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 mir: &Mir<'tcx>,\n                                 node_id: ast::NodeId,\n                                 attributes: &[ast::Attribute],\n@@ -142,7 +75,7 @@ fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let print_postflow_to =\n         name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n \n-    let mut mbcx = MirBorrowckCtxtPreDataflow {\n+    let mut mbcx = DataflowBuilder {\n         node_id: node_id,\n         print_preflow_to: print_preflow_to,\n         print_postflow_to: print_postflow_to,\n@@ -153,46 +86,7 @@ fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mbcx.flow_state.results()\n }\n \n-\n-pub struct MirBorrowckCtxtPreDataflow<'a, 'tcx: 'a, BD> where BD: BitDenotation\n-{\n-    node_id: ast::NodeId,\n-    flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n-    print_preflow_to: Option<String>,\n-    print_postflow_to: Option<String>,\n-}\n-\n-#[allow(dead_code)]\n-pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n-    bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n-    mir: &'b Mir<'tcx>,\n-    node_id: ast::NodeId,\n-    move_data: &'b MoveData<'tcx>,\n-    flow_inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n-    flow_uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>\n-}\n-\n-impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n-    fn process_basic_block(&mut self, bb: BasicBlock) {\n-        let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n-            self.mir[bb];\n-        for stmt in statements {\n-            self.process_statement(bb, stmt);\n-        }\n-\n-        self.process_terminator(bb, terminator);\n-    }\n-\n-    fn process_statement(&mut self, bb: BasicBlock, stmt: &Statement<'tcx>) {\n-        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}\", bb, stmt);\n-    }\n-\n-    fn process_terminator(&mut self, bb: BasicBlock, term: &Option<Terminator<'tcx>>) {\n-        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?})\", bb, term);\n-    }\n-}\n-\n-fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n+pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)\n                                         -> Option<MovePathIndex>\n@@ -253,7 +147,7 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n     }\n }\n \n-fn on_lookup_result_bits<'a, 'tcx, F>(\n+pub(crate) fn on_lookup_result_bits<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     move_data: &MoveData<'tcx>,\n@@ -271,7 +165,7 @@ fn on_lookup_result_bits<'a, 'tcx, F>(\n     }\n }\n \n-fn on_all_children_bits<'a, 'tcx, F>(\n+pub(crate) fn on_all_children_bits<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     move_data: &MoveData<'tcx>,\n@@ -312,7 +206,7 @@ fn on_all_children_bits<'a, 'tcx, F>(\n     on_all_children_bits(tcx, mir, move_data, move_path_index, &mut each_child);\n }\n \n-fn on_all_drop_children_bits<'a, 'tcx, F>(\n+pub(crate) fn on_all_drop_children_bits<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     ctxt: &MoveDataParamEnv<'tcx>,\n@@ -333,7 +227,7 @@ fn on_all_drop_children_bits<'a, 'tcx, F>(\n     })\n }\n \n-fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n+pub(crate) fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     ctxt: &MoveDataParamEnv<'tcx>,\n@@ -350,7 +244,7 @@ fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     }\n }\n \n-fn drop_flag_effects_for_location<'a, 'tcx, F>(\n+pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     ctxt: &MoveDataParamEnv<'tcx>,", "previous_filename": "src/librustc_borrowck/borrowck/mir/mod.rs"}, {"sha": "e6d77aa2686af345839169226078bdc7e9f3d0f5", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -15,7 +15,6 @@ use rustc::mir::{BasicBlock, Mir};\n use rustc_data_structures::bitslice::bits_to_string;\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_mir::util as mir_util;\n \n use dot;\n use dot::IntoCow;\n@@ -28,8 +27,10 @@ use std::marker::PhantomData;\n use std::mem;\n use std::path::Path;\n \n-use super::super::MirBorrowckCtxtPreDataflow;\n+use util;\n+\n use super::{BitDenotation, DataflowState};\n+use super::DataflowBuilder;\n \n impl<O: BitDenotation> DataflowState<O> {\n     fn each_bit<F>(&self, words: &IdxSet<O::Idx>, mut f: F)\n@@ -86,7 +87,7 @@ pub trait MirWithFlowState<'tcx> {\n     fn flow_state(&self) -> &DataflowState<Self::BD>;\n }\n \n-impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n     where 'tcx: 'a, BD: BitDenotation\n {\n     type BD = BD;\n@@ -103,8 +104,8 @@ struct Graph<'a, 'tcx, MWF:'a, P> where\n     render_idx: P,\n }\n \n-pub fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n-    mbcx: &MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>,\n+pub(crate) fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n+    mbcx: &DataflowBuilder<'a, 'tcx, BD>,\n     path: &Path,\n     render_idx: P)\n     -> io::Result<()>\n@@ -220,7 +221,7 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n             }\n             Ok(())\n         }\n-        mir_util::write_graphviz_node_label(\n+        util::write_graphviz_node_label(\n             *n, self.mbcx.mir(), &mut v, 4,\n             |w| {\n                 let flow = self.mbcx.flow_state();", "previous_filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs"}, {"sha": "97c996dea68f6c07cc6078cd1711111fe0557b71", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "renamed", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,25 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Dataflow analyses are built upon some interpretation of the\n+//! bitvectors attached to each basic block, represented via a\n+//! zero-sized structure.\n+\n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_mir::util::elaborate_drops::DropFlagState;\n \n-use super::super::gather_moves::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n-use super::super::MoveDataParamEnv;\n-use super::super::drop_flag_effects_for_function_entry;\n-use super::super::drop_flag_effects_for_location;\n-use super::super::on_lookup_result_bits;\n+use super::MoveDataParamEnv;\n+use util::elaborate_drops::DropFlagState;\n \n+use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n-// Dataflow analyses are built upon some interpretation of the\n-// bitvectors attached to each basic block, represented via a\n-// zero-sized structure.\n+use super::drop_flag_effects_for_function_entry;\n+use super::drop_flag_effects_for_location;\n+use super::on_lookup_result_bits;\n \n /// `MaybeInitializedLvals` tracks all l-values that might be\n /// initialized upon reaching a particular point in the control flow\n@@ -219,6 +220,16 @@ pub struct MovingOutStatements<'a, 'tcx: 'a> {\n     mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n+impl<'a, 'tcx: 'a> MovingOutStatements<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               -> Self\n+    {\n+        MovingOutStatements { tcx: tcx, mir: mir, mdpe: mdpe }\n+    }\n+}\n+\n impl<'a, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }", "previous_filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs"}, {"sha": "d7ad9f9c09aef820ea7b5a0dcb48c1353bda1ac4", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "renamed", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use syntax::ast;\n+\n use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{TyCtxt};\n use rustc::mir::{self, Mir};\n \n use std::fmt::Debug;\n@@ -21,21 +23,31 @@ use std::mem;\n use std::path::PathBuf;\n use std::usize;\n \n-use super::MirBorrowckCtxtPreDataflow;\n-\n-pub use self::sanity_check::sanity_check_via_rustc_peek;\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n \n+pub(crate) use self::drop_flag_effects::*;\n+\n+mod drop_flag_effects;\n mod graphviz;\n-mod sanity_check;\n mod impls;\n+pub mod move_paths;\n+\n+pub(crate) use self::move_paths::indexes;\n+\n+pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD> where BD: BitDenotation\n+{\n+    node_id: ast::NodeId,\n+    flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n+    print_preflow_to: Option<String>,\n+    print_postflow_to: Option<String>,\n+}\n \n pub trait Dataflow<BD: BitDenotation> {\n     fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug;\n }\n \n-impl<'a, 'tcx: 'a, BD> Dataflow<BD> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+impl<'a, 'tcx: 'a, BD> Dataflow<BD> for DataflowBuilder<'a, 'tcx, BD>\n     where BD: BitDenotation + DataflowOperator\n {\n     fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug {\n@@ -135,7 +147,7 @@ fn dataflow_path(context: &str, prepost: &str, path: &str) -> PathBuf {\n     path\n }\n \n-impl<'a, 'tcx: 'a, BD> MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD>\n     where BD: BitDenotation\n {\n     fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n@@ -195,7 +207,7 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n     pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n }\n \n-pub struct DataflowResults<O>(DataflowState<O>) where O: BitDenotation;\n+pub struct DataflowResults<O>(pub(crate) DataflowState<O>) where O: BitDenotation;\n \n impl<O: BitDenotation> DataflowResults<O> {\n     pub fn sets(&self) -> &AllSets<O::Idx> {\n@@ -213,7 +225,7 @@ pub struct DataflowState<O: BitDenotation>\n     pub sets: AllSets<O::Idx>,\n \n     /// operator used to initialize, combine, and interpret bits.\n-    operator: O,\n+    pub(crate) operator: O,\n }\n \n #[derive(Debug)]\n@@ -240,9 +252,9 @@ pub struct AllSets<E: Idx> {\n }\n \n pub struct BlockSets<'a, E: Idx> {\n-    on_entry: &'a mut IdxSet<E>,\n-    gen_set: &'a mut IdxSet<E>,\n-    kill_set: &'a mut IdxSet<E>,\n+    pub(crate) on_entry: &'a mut IdxSet<E>,\n+    pub(crate) gen_set: &'a mut IdxSet<E>,\n+    pub(crate) kill_set: &'a mut IdxSet<E>,\n }\n \n impl<'a, E:Idx> BlockSets<'a, E> {", "previous_filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs"}, {"sha": "5e61c2ec7a292b588a727f33d05c560b74339dcd", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "previous_filename": "src/librustc_borrowck/borrowck/mir/abs_domain.rs"}, {"sha": "d7ed0938e886a00e0ed71dd3c4f46cb1c89e87d5", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "renamed", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -21,14 +21,16 @@ use std::fmt;\n use std::mem;\n use std::ops::{Index, IndexMut};\n \n-use super::abs_domain::{AbstractElem, Lift};\n+use self::abs_domain::{AbstractElem, Lift};\n+\n+mod abs_domain;\n \n // This submodule holds some newtype'd Index wrappers that are using\n // NonZero to ensure that Option<Index> occupies only a single word.\n // They are in a submodule to impose privacy restrictions; namely, to\n // ensure that other code does not accidentally access `index.0`\n // (which is likely to yield a subtle off-by-one error).\n-mod indexes {\n+pub(crate) mod indexes {\n     use std::fmt;\n     use core::nonzero::NonZero;\n     use rustc_data_structures::indexed_vec::Idx;\n@@ -65,7 +67,7 @@ mod indexes {\n pub use self::indexes::MovePathIndex;\n pub use self::indexes::MoveOutIndex;\n \n-impl self::indexes::MoveOutIndex {\n+impl MoveOutIndex {\n     pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n         move_data.moves[*self].path\n     }\n@@ -128,7 +130,7 @@ pub trait HasMoveData<'tcx> {\n pub struct LocationMap<T> {\n     /// Location-indexed (BasicBlock for outer index, index within BB\n     /// for inner index) map.\n-    map: IndexVec<BasicBlock, Vec<T>>,\n+    pub(crate) map: IndexVec<BasicBlock, Vec<T>>,\n }\n \n impl<T> Index<Location> for LocationMap<T> {\n@@ -188,7 +190,7 @@ pub struct MovePathLookup<'tcx> {\n     projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n \n-struct MoveDataBuilder<'a, 'tcx: 'a> {\n+pub(super) struct MoveDataBuilder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,", "previous_filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs"}, {"sha": "0010f312ef9852e13bfe166f4c0a0c6768fa76cb", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -19,7 +19,6 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::cast::CastKind as TyCastKind;\n-use rustc::ty::subst::Subst;\n use rustc::hir;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n@@ -586,7 +585,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     });\n     Expr {\n         temp_lifetime: temp_lifetime,\n-        ty: cx.tcx.type_of(def_id).subst(cx.tcx, substs),\n+        ty: cx.tcx().mk_fn_def(def_id, substs),\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {"}, {"sha": "71855d3805e139c2c8e3008e85273c83fe378a46", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -26,6 +26,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(rustc_diagnostic_macros)]\n #![feature(placement_in_syntax)]\n #![feature(collection_placement)]\n+#![feature(nonzero)]\n \n #[macro_use] extern crate log;\n extern crate graphviz as dot;\n@@ -40,10 +41,12 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n+extern crate core; // for NonZero\n \n pub mod diagnostics;\n \n mod build;\n+pub mod dataflow;\n mod hair;\n mod shim;\n pub mod transform;"}, {"sha": "11ad5d1509d29bcd17b2cd0bb1c541986de4cf31", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -58,7 +58,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             // types in the MIR. They will be substituted again with\n             // the param-substs, but because they are concrete, this\n             // will not do any harm.\n-            let sig = tcx.erase_late_bound_regions(&ty.fn_sig());\n+            let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n             let arg_tys = sig.inputs();\n \n             build_call_shim(\n@@ -153,8 +153,8 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     } else {\n         Substs::identity_for_item(tcx, def_id)\n     };\n-    let fn_ty = tcx.type_of(def_id).subst(tcx, substs);\n-    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let sig = tcx.fn_sig(def_id).subst(tcx, substs);\n+    let sig = tcx.erase_late_bound_regions(&sig);\n     let span = tcx.def_span(def_id);\n \n     let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n@@ -276,8 +276,8 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n \n-    let fn_ty = tcx.type_of(def_id);\n-    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let sig = tcx.fn_sig(def_id);\n+    let sig = tcx.erase_late_bound_regions(&sig);\n     let span = tcx.def_span(def_id);\n \n     debug!(\"build_call_shim: sig={:?}\", sig);\n@@ -409,11 +409,8 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n {\n     let tcx = infcx.tcx;\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    let sig = match tcx.type_of(def_id).sty {\n-        ty::TyFnDef(_, _, fty) => tcx.no_late_bound_regions(&fty)\n-            .expect(\"LBR in ADT constructor signature\"),\n-        _ => bug!(\"unexpected type for ctor {:?}\", def_id)\n-    };\n+    let sig = tcx.no_late_bound_regions(&tcx.fn_sig(def_id))\n+        .expect(\"LBR in ADT constructor signature\");\n     let sig = tcx.erase_regions(&sig);\n \n     let (adt_def, substs) = match sig.output().sty {"}, {"sha": "b158cb43ce7a922c4192bcad6ea79ae43367c733", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "renamed", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,22 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::gather_moves::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n-use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use super::dataflow::{DataflowResults};\n-use super::{on_all_children_bits, on_all_drop_children_bits};\n-use super::{drop_flag_effects_for_location, on_lookup_result_bits};\n-use super::MoveDataParamEnv;\n+use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{DataflowResults};\n+use dataflow::{on_all_children_bits, on_all_drop_children_bits};\n+use dataflow::{drop_flag_effects_for_location, on_lookup_result_bits};\n+use dataflow::MoveDataParamEnv;\n+use dataflow;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_mir::util::patch::MirPatch;\n-use rustc_mir::util::elaborate_drops::{DropFlagState, Unwind, elaborate_drop};\n-use rustc_mir::util::elaborate_drops::{DropElaborator, DropStyle, DropFlagMode};\n+use util::patch::MirPatch;\n+use util::elaborate_drops::{DropFlagState, Unwind, elaborate_drop};\n+use util::elaborate_drops::{DropElaborator, DropStyle, DropFlagMode};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -54,13 +55,13 @@ impl MirPass for ElaborateDrops {\n             };\n             let dead_unwinds = find_dead_unwinds(tcx, mir, id, &env);\n             let flow_inits =\n-                super::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                                   MaybeInitializedLvals::new(tcx, mir, &env),\n-                                   |bd, p| &bd.move_data().move_paths[p]);\n+                dataflow::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n+                                      MaybeInitializedLvals::new(tcx, mir, &env),\n+                                      |bd, p| &bd.move_data().move_paths[p]);\n             let flow_uninits =\n-                super::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                                   MaybeUninitializedLvals::new(tcx, mir, &env),\n-                                   |bd, p| &bd.move_data().move_paths[p]);\n+                dataflow::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n+                                      MaybeUninitializedLvals::new(tcx, mir, &env),\n+                                      |bd, p| &bd.move_data().move_paths[p]);\n \n             ElaborateDropsCtxt {\n                 tcx: tcx,\n@@ -91,7 +92,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n     // reach cleanup blocks, which can't have unwind edges themselves.\n     let mut dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let flow_inits =\n-        super::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n+        dataflow::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n                            MaybeInitializedLvals::new(tcx, mir, &env),\n                            |bd, p| &bd.move_data().move_paths[p]);\n     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n@@ -242,7 +243,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n     }\n \n     fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path> {\n-        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n             match p {\n                 &Projection {\n                     elem: ProjectionElem::Field(idx, _), ..\n@@ -253,7 +254,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n     }\n \n     fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path> {\n-        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n             match p {\n                 &Projection { elem: ProjectionElem::Deref, .. } => true,\n                 _ => false\n@@ -262,7 +263,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n     }\n \n     fn downcast_subpath(&self, path: Self::Path, variant: usize) -> Option<Self::Path> {\n-        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n             match p {\n                 &Projection {\n                     elem: ProjectionElem::Downcast(_, idx), ..\n@@ -560,7 +561,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn drop_flags_for_args(&mut self) {\n         let loc = Location { block: START_BLOCK, statement_index: 0 };\n-        super::drop_flag_effects_for_function_entry(\n+        dataflow::drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.env, |path, ds| {\n                 self.set_drop_flag(loc, path, ds);\n             }\n@@ -605,7 +606,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     }\n                 }\n                 let loc = Location { block: bb, statement_index: i };\n-                super::drop_flag_effects_for_location(\n+                dataflow::drop_flag_effects_for_location(\n                     self.tcx, self.mir, self.env, loc, |path, ds| {\n                         if ds == DropFlagState::Absent || allow_initializations {\n                             self.set_drop_flag(loc, path, ds)", "previous_filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs"}, {"sha": "eb283df869f127197e6a3948cca892ba9cde32b2", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -67,12 +67,13 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     }\n \n     fn visit_statement(&mut self,\n-                       _block: BasicBlock,\n+                       block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n-                       _location: Location) {\n+                       location: Location) {\n         if let StatementKind::EndRegion(_) = statement.kind {\n             statement.kind = StatementKind::Nop;\n         }\n+        self.super_statement(block, statement, location);\n     }\n }\n "}, {"sha": "5f80c7bee147832ca51ef19283df30b27a76e3f5", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let terminator = bb_data.terminator();\n                 if let TerminatorKind::Call {\n                     func: Operand::Constant(ref f), .. } = terminator.kind {\n-                    if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                    if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n                         callsites.push_back(CallSite {\n                             callee: callee_def_id,\n                             substs: substs,\n@@ -131,7 +131,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     let terminator = bb_data.terminator();\n                     if let TerminatorKind::Call {\n                         func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                        if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n                             // Don't inline the same function multiple times.\n                             if callsite.callee != callee_def_id {\n                                 callsites.push_back(CallSite {\n@@ -270,8 +270,9 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 }\n \n                 TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n-                    if let ty::TyFnDef(.., f) = f.ty.sty {\n+                    if let ty::TyFnDef(def_id, _) = f.ty.sty {\n                         // Don't give intrinsics the extra penalty for calls\n+                        let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n                             cost += INSTR_COST;\n                         } else {"}, {"sha": "1530ea8e0df0fad09cd0f61fd39f8e9a5ba26bb2", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -30,6 +30,8 @@ pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n+pub mod rustc_peek;\n+pub mod elaborate_drops;\n pub mod add_call_guards;\n pub mod promote_consts;\n pub mod qualify_consts;"}, {"sha": "68b687a2e6182c8ba34fddadcfc442e1ded1b03f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -750,8 +750,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             let fn_ty = func.ty(self.mir, self.tcx);\n             let (is_shuffle, is_const_fn) = match fn_ty.sty {\n-                ty::TyFnDef(def_id, _, f) => {\n-                    (f.abi() == Abi::PlatformIntrinsic &&\n+                ty::TyFnDef(def_id, _) => {\n+                    (self.tcx.fn_sig(def_id).abi() == Abi::PlatformIntrinsic &&\n                      self.tcx.item_name(def_id).as_str().starts_with(\"simd_shuffle\"),\n                      self.tcx.is_const_fn(def_id))\n                 }\n@@ -996,7 +996,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                                               tcx.require_lang_item(lang_items::SyncTraitLangItem),\n                                               cause);\n                 if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&err);\n+                    infcx.report_fulfillment_errors(&err, None);\n                 }\n             });\n         }"}, {"sha": "5918de0c6881104a906c857f250c2f0853d40670", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "renamed", "additions": 66, "deletions": 16, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,12 +14,67 @@ use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir};\n+use rustc::mir::transform::{MirPass, MirSource};\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::super::gather_moves::{MovePathIndex, LookupResult};\n-use super::BitDenotation;\n-use super::DataflowResults;\n-use super::super::gather_moves::HasMoveData;\n+use dataflow::do_dataflow;\n+use dataflow::MoveDataParamEnv;\n+use dataflow::BitDenotation;\n+use dataflow::DataflowResults;\n+use dataflow::{DefinitelyInitializedLvals, MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::move_paths::{MovePathIndex, LookupResult};\n+use dataflow::move_paths::{HasMoveData, MoveData};\n+use dataflow;\n+\n+use dataflow::has_rustc_mir_with;\n+\n+pub struct SanityCheck;\n+\n+impl MirPass for SanityCheck {\n+    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource, mir: &mut Mir<'tcx>) {\n+        let id = src.item_id();\n+        let def_id = tcx.hir.local_def_id(id);\n+        if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") {\n+            debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n+            return;\n+        } else {\n+            debug!(\"running rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n+        }\n+\n+        let attributes = tcx.get_attrs(def_id);\n+        let param_env = tcx.param_env(def_id);\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+        let flow_inits =\n+            do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                        MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                        |bd, i| &bd.move_data().move_paths[i]);\n+        let flow_uninits =\n+            do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                        MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                        |bd, i| &bd.move_data().move_paths[i]);\n+        let flow_def_inits =\n+            do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                        DefinitelyInitializedLvals::new(tcx, mir, &mdpe),\n+                        |bd, i| &bd.move_data().move_paths[i]);\n+\n+        if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_init\").is_some() {\n+            sanity_check_via_rustc_peek(tcx, mir, id, &attributes, &flow_inits);\n+        }\n+        if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_uninit\").is_some() {\n+            sanity_check_via_rustc_peek(tcx, mir, id, &attributes, &flow_uninits);\n+        }\n+        if has_rustc_mir_with(&attributes, \"rustc_peek_definite_init\").is_some() {\n+            sanity_check_via_rustc_peek(tcx, mir, id, &attributes, &flow_def_inits);\n+        }\n+        if has_rustc_mir_with(&attributes, \"stop_after_dataflow\").is_some() {\n+            tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n+        }\n+    }\n+}\n \n /// This function scans `mir` for all calls to the intrinsic\n /// `rustc_peek` that have the expression form `rustc_peek(&expr)`.\n@@ -92,7 +147,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // of the argument at time immediate preceding Call to\n     // `rustc_peek`).\n \n-    let mut sets = super::BlockSets { on_entry: &mut entry,\n+    let mut sets = dataflow::BlockSets { on_entry: &mut entry,\n                                       gen_set: &mut gen,\n                                       kill_set: &mut kill };\n \n@@ -161,18 +216,13 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            terminator: &'a Option<mir::Terminator<'tcx>>)\n                            -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n-        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n-        {\n-            if let mir::Operand::Constant(ref func) = *oper\n-            {\n-                if let ty::TyFnDef(def_id, _, sig) = func.ty.sty\n-                {\n-                    let abi = sig.abi();\n+        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n+            if let mir::Operand::Constant(ref func) = *oper {\n+                if let ty::TyFnDef(def_id, _) = func.ty.sty {\n+                    let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n-                    if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                        if name == \"rustc_peek\" {\n-                            return Some((args, source_info.span));\n-                        }\n+                    if abi == Abi::RustIntrinsic &&  name == \"rustc_peek\" {\n+                        return Some((args, source_info.span));\n                     }\n                 }\n             }", "previous_filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs"}, {"sha": "7e6fccf30192ce626dbc072efd9b4948bf41b747", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n-                    ty::TyFnDef(.., sig) | ty::TyFnPtr(sig) => sig,\n+                    ty::TyFnDef(..) | ty::TyFnPtr(_) => func_ty.fn_sig(tcx),\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n                         return;"}, {"sha": "7e2a82dd0ab94aa47f3b02e747c01aa0fe77050c", "filename": "src/librustc_msan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_msan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_msan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Fbuild.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -32,4 +32,5 @@ fn main() {\n             .build_target(\"msan\")\n             .build();\n     }\n+    println!(\"cargo:rerun-if-env-changed=LLVM_CONFIG\");\n }"}, {"sha": "6ad03186dc778136cc8ca6402207cd463cb325da", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -93,6 +93,17 @@ impl<'a> AstValidator<'a> {\n             }\n         }\n     }\n+\n+    /// matches '-' lit | lit (cf. parser::Parser::parse_pat_literal_maybe_minus)\n+    fn check_expr_within_pat(&self, expr: &Expr) {\n+        match expr.node {\n+            ExprKind::Lit(..) | ExprKind::Path(..) => {}\n+            ExprKind::Unary(UnOp::Neg, ref inner)\n+                if match inner.node { ExprKind::Lit(_) => true, _ => false } => {}\n+            _ => self.err_handler().span_err(expr.span, \"arbitrary expressions aren't allowed \\\n+                                                         in patterns\")\n+        }\n+    }\n }\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n@@ -308,6 +319,21 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         }\n         visit::walk_generics(self, g)\n     }\n+\n+    fn visit_pat(&mut self, pat: &'a Pat) {\n+        match pat.node {\n+            PatKind::Lit(ref expr) => {\n+                self.check_expr_within_pat(expr);\n+            }\n+            PatKind::Range(ref start, ref end, _) => {\n+                self.check_expr_within_pat(start);\n+                self.check_expr_within_pat(end);\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_pat(self, pat)\n+    }\n }\n \n pub fn check_crate(session: &Session, krate: &Crate) {"}, {"sha": "0dbb2d1d4d0bf8e6183c295fb1b5cc79f226475e", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -12,8 +12,9 @@\n // recursively.\n \n use rustc::hir::map as hir_map;\n-use rustc::session::{CompileResult, Session};\n+use rustc::session::Session;\n use rustc::hir::def::{Def, CtorKind};\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n@@ -86,7 +87,9 @@ impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n     }\n }\n \n-pub fn check_crate<'hir>(sess: &Session, hir_map: &hir_map::Map<'hir>) -> CompileResult {\n+pub fn check_crate<'hir>(sess: &Session, hir_map: &hir_map::Map<'hir>)\n+                         -> Result<(), ErrorReported>\n+{\n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n         hir_map: hir_map,"}, {"sha": "9eb96fea52778e6677d09a28deacfd1ee99d15fe", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -400,7 +400,13 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        self.ev.tcx.type_of(self.item_def_id).visit_with(self);\n+        let ty = self.ev.tcx.type_of(self.item_def_id);\n+        ty.visit_with(self);\n+        if let ty::TyFnDef(def_id, _) = ty.sty {\n+            if def_id == self.item_def_id {\n+                self.ev.tcx.fn_sig(def_id).visit_with(self);\n+            }\n+        }\n         self\n     }\n \n@@ -910,7 +916,13 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        self.tcx.type_of(self.item_def_id).visit_with(self);\n+        let ty = self.tcx.type_of(self.item_def_id);\n+        ty.visit_with(self);\n+        if let ty::TyFnDef(def_id, _) = ty.sty {\n+            if def_id == self.item_def_id {\n+                self.tcx.fn_sig(def_id).visit_with(self);\n+            }\n+        }\n         self\n     }\n "}, {"sha": "4b6b754dca655cd7c77df77e2b1a37b26e59f1f7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -149,14 +149,15 @@ impl<'a> Resolver<'a> {\n                             resolve_error(self,\n                                           view_path.span,\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n-                        } else if source_name == \"$crate\" && full_path.segments.len() == 1 {\n+                        } else if source_name == keywords::DollarCrate.name() &&\n+                                  full_path.segments.len() == 1 {\n                             let crate_root = self.resolve_crate_root(source.ctxt);\n                             let crate_name = match crate_root.kind {\n                                 ModuleKind::Def(_, name) => name,\n                                 ModuleKind::Block(..) => unreachable!(),\n                             };\n                             source.name = crate_name;\n-                            if binding.name == \"$crate\" {\n+                            if binding.name == keywords::DollarCrate.name() {\n                                 binding.name = crate_name;\n                             }\n "}, {"sha": "4bfe4d25ded9373ecdfe3a96e907469320426894", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -2665,7 +2665,8 @@ impl<'a> Resolver<'a> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n+           path[0].name != keywords::CrateRoot.name() &&\n+           path[0].name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n@@ -2718,7 +2719,7 @@ impl<'a> Resolver<'a> {\n             if i == 0 && ns == TypeNS && ident.name == keywords::CrateRoot.name() {\n                 module = Some(self.resolve_crate_root(ident.ctxt.modern()));\n                 continue\n-            } else if i == 0 && ns == TypeNS && ident.name == \"$crate\" {\n+            } else if i == 0 && ns == TypeNS && ident.name == keywords::DollarCrate.name() {\n                 module = Some(self.resolve_crate_root(ident.ctxt));\n                 continue\n             }"}, {"sha": "0fbc596f2e1c24f132ebbbcd292b094503279866", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -128,7 +128,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n-                if ident.name == \"$crate\" {\n+                if ident.name == keywords::DollarCrate.name() {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_root(ident.ctxt);\n                     if !module.is_local() {"}, {"sha": "a512cf2f02a5c0807f33995332a29918df55e8ae", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -15,6 +15,7 @@ flate2 = \"0.2\"\n jobserver = \"0.1.5\"\n log = \"0.3\"\n owning_ref = \"0.3.3\"\n+rustc-demangle = \"0.1.4\"\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }"}, {"sha": "10b66fb1991087a351150bcc8ec921a8cd7ce349", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -154,6 +154,13 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         assert!(!item_type.has_erasable_regions());\n         hasher.visit_ty(item_type);\n \n+        // If this is a function, we hash the signature as well.\n+        // This is not *strictly* needed, but it may help in some\n+        // situations, see the `run-make/a-b-a-linker-guard` test.\n+        if let ty::TyFnDef(..) = item_type.sty {\n+            item_type.fn_sig(tcx).visit_with(&mut hasher);\n+        }\n+\n         // also include any type parameters (for generic items)\n         if let Some(substs) = substs {\n             assert!(!substs.has_erasable_regions());"}, {"sha": "562d7171156fe0dbe66b1b250a0d624ae2b5705c", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -29,15 +29,18 @@ use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n use jobserver::{Client, Acquired};\n use crossbeam::{scope, Scope};\n+use rustc_demangle;\n \n use std::cmp;\n use std::ffi::CString;\n use std::fs;\n use std::io;\n+use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::str;\n use std::sync::mpsc::{channel, Sender};\n-use libc::{c_uint, c_void};\n+use std::slice;\n+use libc::{c_uint, c_void, c_char, size_t};\n \n pub const RELOC_MODEL_ARGS : [(&'static str, llvm::RelocMode); 7] = [\n     (\"pic\", llvm::RelocMode::PIC),\n@@ -510,8 +513,40 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         if config.emit_ir {\n             let out = output_names.temp_path(OutputType::LlvmAssembly, module_name);\n             let out = path2cstr(&out);\n+\n+            extern \"C\" fn demangle_callback(input_ptr: *const c_char,\n+                                            input_len: size_t,\n+                                            output_ptr: *mut c_char,\n+                                            output_len: size_t) -> size_t {\n+                let input = unsafe {\n+                    slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n+                };\n+\n+                let input = match str::from_utf8(input) {\n+                    Ok(s) => s,\n+                    Err(_) => return 0,\n+                };\n+\n+                let output = unsafe {\n+                    slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n+                };\n+                let mut cursor = io::Cursor::new(output);\n+\n+                let demangled = match rustc_demangle::try_demangle(input) {\n+                    Ok(d) => d,\n+                    Err(_) => return 0,\n+                };\n+\n+                if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n+                    // Possible only if provided buffer is not big enough\n+                    return 0;\n+                }\n+\n+                cursor.position() as size_t\n+            }\n+\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n+                llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr(), demangle_callback);\n                 llvm::LLVMDisposePassManager(cpm);\n             })\n         }"}, {"sha": "a76abcf7b49a69ab5e187c19bd9385f6ee344c05", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -195,7 +195,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n use rustc::traits;\n-use rustc::ty::subst::{Substs, Subst};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::{self, Location};\n@@ -304,6 +304,11 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         scx.tcx().hir.krate().visit_all_item_likes(&mut visitor);\n     }\n \n+    // We can only translate items that are instantiable - items all of\n+    // whose predicates hold. Luckily, items that aren't instantiable\n+    // can't actually be used, so we can just skip translating them.\n+    roots.retain(|root| root.is_instantiable(scx.tcx()));\n+\n     roots\n }\n \n@@ -587,7 +592,7 @@ fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<TransItem<'tcx>>)\n {\n-    if let ty::TyFnDef(def_id, substs, _) = ty.sty {\n+    if let ty::TyFnDef(def_id, substs) = ty.sty {\n         let instance = monomorphize::resolve(scx, def_id, substs);\n         visit_instance_use(scx, instance, is_direct_call, output);\n     }\n@@ -937,14 +942,9 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                     let instance =\n                         monomorphize::resolve(scx, method.def_id, callee_substs);\n \n-                    let predicates = tcx.predicates_of(instance.def_id()).predicates\n-                        .subst(tcx, instance.substs);\n-                    if !traits::normalize_and_test_predicates(tcx, predicates) {\n-                        continue;\n-                    }\n-\n-                    if should_trans_locally(tcx, &instance) {\n-                        output.push(create_fn_trans_item(instance));\n+                    let trans_item = create_fn_trans_item(instance);\n+                    if trans_item.is_instantiable(tcx) && should_trans_locally(tcx, &instance) {\n+                        output.push(trans_item);\n                     }\n                 }\n             }"}, {"sha": "9b0803908b162582e1dc86bbdc152f4b4f3a4dc5", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -495,12 +495,12 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            -> ty::PolyFnSig<'tcx>\n {\n     match ty.sty {\n-        ty::TyFnDef(_, _, sig) => sig,\n+        ty::TyFnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(sig) => sig,\n+        ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx()),\n         ty::TyClosure(def_id, substs) => {\n             let tcx = ccx.tcx();\n-            let sig = tcx.closure_type(def_id).subst(tcx, substs.substs);\n+            let sig = tcx.fn_sig(def_id).subst(tcx, substs.substs);\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n             let env_ty = match tcx.closure_kind(def_id) {"}, {"sha": "0cc1993601119597c7d2e553f9abd8126a1d70d8", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -488,7 +488,6 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"type_metadata: {:?}\", t);\n \n-    let sty = &t.sty;\n     let ptr_metadata = |ty: Ty<'tcx>| {\n         match ty.sty {\n             ty::TySlice(typ) => {\n@@ -518,7 +517,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n+    let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.sty {\n         ty::TyNever    |\n         ty::TyBool     |\n         ty::TyChar     |\n@@ -557,10 +556,10 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 Err(metadata) => return metadata,\n             }\n         }\n-        ty::TyFnDef(.., sig) | ty::TyFnPtr(sig) => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n-                                                       sig,\n+                                                       t.fn_sig(cx.tcx()),\n                                                        usage_site_span).metadata;\n             match debug_context(cx).type_map\n                                    .borrow()\n@@ -610,7 +609,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty)\n+            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", t)\n         }\n     };\n "}, {"sha": "bfca4fec706eda94267e9779c79320c94d18866a", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -96,8 +96,8 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 push_type_params(cx, principal.substs, output);\n             }\n         },\n-        ty::TyFnDef(.., sig) |\n-        ty::TyFnPtr(sig) => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            let sig = t.fn_sig(cx.tcx());\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }"}, {"sha": "c2f44c089a2d6a7f8cd7b0fcbffd817490e2b038", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -76,7 +76,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n     }\n     assert!(!info.is_null());\n     match t.sty {\n-        ty::TyAdt(def, substs) => {\n+        ty::TyAdt(..) | ty::TyTuple(..) => {\n             let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n@@ -101,8 +101,14 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let last_field = def.struct_variant().fields.last().unwrap();\n-            let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n+            let field_ty = match t.sty {\n+                ty::TyAdt(def, substs) => {\n+                    let last_field = def.struct_variant().fields.last().unwrap();\n+                    monomorphize::field_ty(bcx.tcx(), substs, last_field)\n+                },\n+                ty::TyTuple(tys, _) => tys.last().unwrap(),\n+                _ => unreachable!(),\n+            };\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding"}, {"sha": "9956c28e6412139d2f2fc2fddc106b74b020a104", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -95,11 +95,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ccx = bcx.ccx;\n     let tcx = ccx.tcx();\n \n-    let (def_id, substs, sig) = match callee_ty.sty {\n-        ty::TyFnDef(def_id, substs, sig) => (def_id, substs, sig),\n+    let (def_id, substs) = match callee_ty.sty {\n+        ty::TyFnDef(def_id, substs) => (def_id, substs),\n         _ => bug!(\"expected fn item type, found {}\", callee_ty)\n     };\n \n+    let sig = callee_ty.fn_sig(tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     let arg_tys = sig.inputs();\n     let ret_ty = sig.output();\n@@ -986,7 +987,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n \n     let tcx = bcx.tcx();\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig());\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n \n     // every intrinsic takes a SIMD vector as its first argument"}, {"sha": "6acd10cb887f8e615a63b76d3a383bc737b1daf4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -34,7 +34,6 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(conservative_impl_trait)]\n-#![feature(command_envs)]\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n@@ -53,6 +52,7 @@ extern crate rustc_const_math;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n+extern crate rustc_demangle;\n extern crate jobserver;\n \n #[macro_use] extern crate log;"}, {"sha": "48b166c61deb17323bd228e88f65cf10d00027af", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -28,6 +28,7 @@ use type_of;\n use type_::Type;\n \n use syntax::symbol::Symbol;\n+use syntax_pos::Pos;\n \n use std::cmp;\n \n@@ -333,6 +334,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);\n+                let col = C_u32(bcx.ccx, loc.col.to_usize() as u32 + 1);\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args, const_err) = match *msg {\n@@ -347,29 +349,29 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     index: index as u64\n                                 }));\n \n-                        let file_line = C_struct(bcx.ccx, &[filename, line], false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line));\n-                        let file_line = consts::addr_of(bcx.ccx,\n-                                                        file_line,\n-                                                        align,\n-                                                        \"panic_bounds_check_loc\");\n+                        let file_line_col = C_struct(bcx.ccx, &[filename, line, col], false);\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line_col));\n+                        let file_line_col = consts::addr_of(bcx.ccx,\n+                                                            file_line_col,\n+                                                            align,\n+                                                            \"panic_bounds_check_loc\");\n                         (lang_items::PanicBoundsCheckFnLangItem,\n-                         vec![file_line, index, len],\n+                         vec![file_line_col, index, len],\n                          const_err)\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n                         let msg_str = Symbol::intern(err.description()).as_str();\n                         let msg_str = C_str_slice(bcx.ccx, msg_str);\n-                        let msg_file_line = C_struct(bcx.ccx,\n-                                                     &[msg_str, filename, line],\n+                        let msg_file_line_col = C_struct(bcx.ccx,\n+                                                     &[msg_str, filename, line, col],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line));\n-                        let msg_file_line = consts::addr_of(bcx.ccx,\n-                                                            msg_file_line,\n-                                                            align,\n-                                                            \"panic_loc\");\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line_col));\n+                        let msg_file_line_col = consts::addr_of(bcx.ccx,\n+                                                                msg_file_line_col,\n+                                                                align,\n+                                                                \"panic_loc\");\n                         (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line],\n+                         vec![msg_file_line_col],\n                          Some(ErrKind::Math(err.clone())))\n                     }\n                 };\n@@ -404,20 +406,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n-                let (instance, mut llfn, sig) = match callee.ty.sty {\n-                    ty::TyFnDef(def_id, substs, sig) => {\n+                let (instance, mut llfn) = match callee.ty.sty {\n+                    ty::TyFnDef(def_id, substs) => {\n                         (Some(monomorphize::resolve(bcx.ccx.shared(), def_id, substs)),\n-                         None,\n-                         sig)\n+                         None)\n                     }\n-                    ty::TyFnPtr(sig) => {\n-                        (None,\n-                         Some(callee.immediate()),\n-                         sig)\n+                    ty::TyFnPtr(_) => {\n+                        (None, Some(callee.immediate()))\n                     }\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n                 let def = instance.map(|i| i.def);\n+                let sig = callee.ty.fn_sig(bcx.tcx());\n                 let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                 let abi = sig.abi;\n "}, {"sha": "fcb4b25e6fe88d6a8bf6d6f7584ade9bad7ef86c", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     let fn_ty = func.ty(self.mir, tcx);\n                     let fn_ty = self.monomorphize(&fn_ty);\n                     let (def_id, substs) = match fn_ty.sty {\n-                        ty::TyFnDef(def_id, substs, _) => (def_id, substs),\n+                        ty::TyFnDef(def_id, substs) => (def_id, substs),\n                         _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n                                        func, fn_ty)\n                     };\n@@ -560,7 +560,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n-                            ty::TyFnDef(def_id, substs, _) => {\n+                            ty::TyFnDef(def_id, substs) => {\n                                 callee::resolve_and_get_fn(self.ccx, def_id, substs)\n                             }\n                             _ => {\n@@ -579,7 +579,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     .find(|it| it.kind == ty::AssociatedKind::Method)\n                                     .unwrap().def_id;\n                                 // Now create its substs [Closure, Tuple]\n-                                let input = tcx.closure_type(def_id)\n+                                let input = tcx.fn_sig(def_id)\n                                     .subst(tcx, substs.substs).input(0);\n                                 let input = tcx.erase_late_bound_regions_and_normalize(&input);\n                                 let substs = tcx.mk_substs([operand.ty, input]"}, {"sha": "4bd5091a4f35f8069ea4225e58a17a3a07916468", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n-                            ty::TyFnDef(def_id, substs, _) => {\n+                            ty::TyFnDef(def_id, substs) => {\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n                             }"}, {"sha": "1f6a262162d3950021550cba8a44dce92be8777d", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -40,7 +40,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let self_ty = tcx.mk_closure_from_closure_substs(\n         closure_did, substs);\n \n-    let sig = tcx.closure_type(closure_did).subst(tcx, substs.substs);\n+    let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs([\n@@ -165,9 +165,11 @@ pub fn resolve<'a, 'tcx>(\n     } else {\n         let item_type = def_ty(scx, def_id, substs);\n         let def = match item_type.sty {\n-            ty::TyFnDef(_, _, f) if\n-                f.abi() == Abi::RustIntrinsic ||\n-                f.abi() == Abi::PlatformIntrinsic =>\n+            ty::TyFnDef(..) if {\n+                    let f = item_type.fn_sig(scx.tcx());\n+                    f.abi() == Abi::RustIntrinsic ||\n+                    f.abi() == Abi::PlatformIntrinsic\n+                } =>\n             {\n                 debug!(\" => intrinsic\");\n                 ty::InstanceDef::Intrinsic(def_id)"}, {"sha": "2a6e7c5ace6cf0a8962960d08015c4f65208a37c", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -25,8 +25,9 @@ use llvm;\n use monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Subst, Substs};\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n use syntax_pos::Span;\n@@ -250,6 +251,44 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n+    /// Returns whether this instance is instantiable - whether it has no unsatisfied\n+    /// predicates.\n+    ///\n+    /// In order to translate an item, all of its predicates must hold, because\n+    /// otherwise the item does not make sense. Type-checking ensures that\n+    /// the predicates of every item that is *used by* a valid item *do*\n+    /// hold, so we can rely on that.\n+    ///\n+    /// However, we translate collector roots (reachable items) and functions\n+    /// in vtables when they are seen, even if they are not used, and so they\n+    /// might not be instantiable. For example, a programmer can define this\n+    /// public function:\n+    ///\n+    ///     pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n+    ///         <&mut () as Clone>::clone(&s);\n+    ///     }\n+    ///\n+    /// That function can't be translated, because the method `<&mut () as Clone>::clone`\n+    /// does not exist. Luckily for us, that function can't ever be used,\n+    /// because that would require for `&'a mut (): Clone` to hold, so we\n+    /// can just not emit any code, or even a linker reference for it.\n+    ///\n+    /// Similarly, if a vtable method has such a signature, and therefore can't\n+    /// be used, we can just not emit it and have a placeholder (a null pointer,\n+    /// which will never be accessed) in its place.\n+    pub fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        debug!(\"is_instantiable({:?})\", self);\n+        let (def_id, substs) = match *self {\n+            TransItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n+            TransItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n+            // global asm never has predicates\n+            TransItem::GlobalAsm(..) => return true\n+        };\n+\n+        let predicates = tcx.predicates_of(def_id).predicates.subst(tcx, substs);\n+        traits::normalize_and_test_predicates(tcx, predicates)\n+    }\n+\n     pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         let hir_map = &tcx.hir;\n \n@@ -401,8 +440,9 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                         output);\n                 }\n             },\n-            ty::TyFnDef(.., sig) |\n-            ty::TyFnPtr(sig) => {\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) => {\n+                let sig = t.fn_sig(self.tcx);\n                 if sig.unsafety() == hir::Unsafety::Unsafe {\n                     output.push_str(\"unsafe \");\n                 }"}, {"sha": "641d9c3647d390e570585f27cf0433ccb04f88f0", "filename": "src/librustc_tsan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_tsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_tsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Fbuild.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -32,4 +32,5 @@ fn main() {\n             .build_target(\"tsan\")\n             .build();\n     }\n+    println!(\"cargo:rerun-if-env-changed=LLVM_CONFIG\");\n }"}, {"sha": "68726a7b1c4ebe111a7c53f35cf7ca2d63bd0774", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -619,7 +619,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = pat_ty.fn_sig().output();\n+        let pat_ty = pat_ty.fn_sig(tcx).output();\n         let pat_ty = tcx.no_late_bound_regions(&pat_ty).expect(\"expected fn type\");\n         self.demand_eqtype(pat.span, expected, pat_ty);\n "}, {"sha": "a0801a7486654580f86ef2e6a8e5717fba2c6342", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id).is_none() {\n-                    let closure_ty = self.closure_type(def_id).subst(self.tcx, substs.substs);\n+                    let closure_ty = self.fn_sig(def_id).subst(self.tcx, substs.substs);\n                     let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                    infer::FnCall,\n                                                                    &closure_ty)\n@@ -196,8 +196,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expected: Expectation<'tcx>)\n                             -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n-            ty::TyFnDef(def_id, .., sig) => {\n-                (sig, self.tcx.hir.span_if_local(def_id))\n+            ty::TyFnDef(def_id, _) => {\n+                (callee_ty.fn_sig(self.tcx), self.tcx.hir.span_if_local(def_id))\n             }\n             ty::TyFnPtr(sig) => (sig, None),\n             ref t => {"}, {"sha": "7bd24c939caf0beef8e405216da7da4decfc25cb", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 48, "deletions": 70, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -40,9 +40,11 @@\n \n use super::{Diverges, FnCtxt};\n \n-use lint;\n+use errors::DiagnosticBuilder;\n use hir::def_id::DefId;\n+use lint;\n use rustc::hir;\n+use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::cast::{CastKind, CastTy};\n@@ -112,6 +114,18 @@ enum CastError {\n     NonScalar,\n }\n \n+fn make_invalid_casting_error<'a, 'gcx, 'tcx>(sess: &'a Session,\n+                                              span: Span,\n+                                              expr_ty: Ty<'tcx>,\n+                                              cast_ty: Ty<'tcx>,\n+                                              fcx: &FnCtxt<'a, 'gcx, 'tcx>)\n+                                              -> DiagnosticBuilder<'a> {\n+    type_error_struct!(sess, span, expr_ty, E0606,\n+                       \"casting `{}` as `{}` is invalid\",\n+                       fcx.ty_to_string(expr_ty),\n+                       fcx.ty_to_string(cast_ty))\n+}\n+\n impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     pub fn new(fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                expr: &'tcx hir::Expr,\n@@ -146,14 +160,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         match e {\n             CastError::NeedDeref => {\n                 let error_span = self.span;\n+                let mut err = make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty,\n+                                                         self.cast_ty, fcx);\n                 let cast_ty = fcx.ty_to_string(self.cast_ty);\n-                let mut err = fcx.type_error_struct(error_span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   cast_ty)\n-                                       },\n-                                       self.expr_ty);\n                 err.span_label(error_span,\n                                format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n@@ -166,13 +175,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             }\n             CastError::NeedViaThinPtr |\n             CastError::NeedViaPtr => {\n-                let mut err = fcx.type_error_struct(self.span,\n-                                                    |actual| {\n-                                                        format!(\"casting `{}` as `{}` is invalid\",\n-                                                                actual,\n-                                                                fcx.ty_to_string(self.cast_ty))\n-                                                    },\n-                                                    self.expr_ty);\n+                let mut err = make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty,\n+                                                         self.cast_ty, fcx);\n                 if self.cast_ty.is_uint() {\n                     err.help(&format!(\"cast through {} first\",\n                                       match e {\n@@ -184,72 +188,47 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 err.emit();\n             }\n             CastError::NeedViaInt => {\n-                fcx.type_error_struct(self.span,\n-                                      |actual| {\n-                                          format!(\"casting `{}` as `{}` is invalid\",\n-                                                  actual,\n-                                                  fcx.ty_to_string(self.cast_ty))\n-                                      },\n-                                      self.expr_ty)\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n                    .help(&format!(\"cast through {} first\",\n                                   match e {\n                                       CastError::NeedViaInt => \"an integer\",\n                                       _ => bug!(),\n                                   }))\n                    .emit();\n             }\n+            CastError::IllegalCast => {\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n+                    .emit();\n+            }\n+            CastError::DifferingKinds => {\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n+                    .note(\"vtable kinds may not match\")\n+                    .emit();\n+            }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx.sess, self.span, E0054, \"cannot cast as `bool`\")\n                     .span_label(self.span, \"unsupported cast\")\n                     .help(\"compare with zero instead\")\n                     .emit();\n             }\n             CastError::CastToChar => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"only `u8` can be cast as `char`, not `{}`\",\n-                                                   actual)\n-                                       },\n-                                       self.expr_ty);\n+                type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0604,\n+                                 \"only `u8` can be cast as `char`, not `{}`\", self.expr_ty).emit();\n             }\n             CastError::NonScalar => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"non-scalar cast: `{}` as `{}`\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty);\n-            }\n-            CastError::IllegalCast => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty);\n+                type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0605,\n+                                 \"non-primitive cast: `{}` as `{}`\",\n+                                 self.expr_ty,\n+                                 fcx.ty_to_string(self.cast_ty))\n+                                .note(\"an `as` expression can only be used to convert between \\\n+                                       primitive types. Consider using the `From` trait\")\n+                                .emit();\n             }\n             CastError::SizedUnsizedCast => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"cannot cast thin pointer `{}` to fat pointer \\\n-                                                    `{}`\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty)\n-            }\n-            CastError::DifferingKinds => {\n-                fcx.type_error_struct(self.span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty)\n-                    .note(\"vtable kinds may not match\")\n-                    .emit();\n+                type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0607,\n+                                 \"cannot cast thin pointer `{}` to fat pointer `{}`\",\n+                                 self.expr_ty,\n+                                 fcx.ty_to_string(self.cast_ty)).emit();\n             }\n         }\n     }\n@@ -260,12 +239,10 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         }\n \n         let tstr = fcx.ty_to_string(self.cast_ty);\n-        let mut err =\n-            fcx.type_error_struct(self.span,\n-                                  |actual| {\n-                                      format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-                                  },\n-                                  self.expr_ty);\n+        let mut err = type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0620,\n+                                         \"cast to unsized type: `{}` as `{}`\",\n+                                         fcx.resolve_type_vars_if_possible(&self.expr_ty),\n+                                         tstr);\n         match self.expr_ty.sty {\n             ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n                 let mtstr = match mt {\n@@ -377,8 +354,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                if let ty::TyFnDef(.., f) = self.expr_ty.sty {\n+                if let ty::TyFnDef(..) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n+                    let f = self.expr_ty.fn_sig(fcx.tcx);\n                     let res = fcx.try_coerce(self.expr,\n                                              self.expr_ty,\n                                              self.expr_diverges,"}, {"sha": "968e893b9a00b422862e26713fcd6aabbbfb0767", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 79, "deletions": 42, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -76,6 +76,7 @@ use rustc::ty::relate::RelateResult;\n use rustc::ty::subst::Subst;\n use errors::DiagnosticBuilder;\n use syntax::abi;\n+use syntax::feature_gate;\n use syntax::ptr::P;\n use syntax_pos;\n \n@@ -210,13 +211,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         match a.sty {\n-            ty::TyFnDef(.., a_f) => {\n+            ty::TyFnDef(..) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n                 // require double indirection).\n                 // Additionally, we permit coercion of function\n                 // items to drop the unsafe qualifier.\n-                self.coerce_from_fn_item(a, a_f, b)\n+                self.coerce_from_fn_item(a, b)\n             }\n             ty::TyFnPtr(a_f) => {\n                 // We permit coercion of fn pointers to drop the\n@@ -520,14 +521,24 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                          coerce_source,\n                                                          &[coerce_target]));\n \n+        let mut has_unsized_tuple_coercion = false;\n+\n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n         // inference might unify those two inner type variables later.\n         let traits = [coerce_unsized_did, unsize_did];\n         while let Some(obligation) = queue.pop_front() {\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let trait_ref = match obligation.predicate {\n-                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => tr.clone(),\n+                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n+                    if unsize_did == tr.def_id() {\n+                        if let ty::TyTuple(..) = tr.0.input_types().nth(1).unwrap().sty {\n+                            debug!(\"coerce_unsized: found unsized tuple coercion\");\n+                            has_unsized_tuple_coercion = true;\n+                        }\n+                    }\n+                    tr.clone()\n+                }\n                 _ => {\n                     coercion.obligations.push(obligation);\n                     continue;\n@@ -557,6 +568,14 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         }\n \n+        if has_unsized_tuple_coercion && !self.tcx.sess.features.borrow().unsized_tuple_coercion {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           \"unsized_tuple_coercion\",\n+                                           self.cause.span,\n+                                           feature_gate::GateIssue::Language,\n+                                           feature_gate::EXPLAIN_UNSIZED_TUPLE_COERCION);\n+        }\n+\n         Ok(coercion)\n     }\n \n@@ -600,7 +619,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     fn coerce_from_fn_item(&self,\n                            a: Ty<'tcx>,\n-                           fn_ty_a: ty::PolyFnSig<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n@@ -612,9 +630,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         match b.sty {\n             ty::TyFnPtr(_) => {\n-                let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n-                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b,\n-                    simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))\n+                let a_sig = a.fn_sig(self.tcx);\n+                let InferOk { value: a_sig, mut obligations } =\n+                    self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n+\n+                let a_fn_pointer = self.tcx.mk_fn_ptr(a_sig);\n+                let InferOk { value, obligations: o2 } =\n+                    self.coerce_from_safe_fn(a_fn_pointer, a_sig, b,\n+                        simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))?;\n+\n+                obligations.extend(o2);\n+                Ok(InferOk { value, obligations })\n             }\n             _ => self.unify_and(a, b, identity),\n         }\n@@ -639,7 +665,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n                 //     `fn(arg0,arg1,...) -> _`\n-                let sig = self.closure_type(def_id_a).subst(self.tcx, substs_a.substs);\n+                let sig = self.fn_sig(def_id_a).subst(self.tcx, substs_a.substs);\n                 let converted_sig = sig.map_bound(|s| {\n                     let params_iter = match s.inputs()[0].sty {\n                         ty::TyTuple(params, _) => {\n@@ -775,42 +801,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n-        match (&prev_ty.sty, &new_ty.sty) {\n-            (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n-                // The signature must always match.\n-                let fty = self.at(cause, self.param_env)\n-                              .trace(prev_ty, new_ty)\n-                              .lub(&a_fty, &b_fty)\n-                              .map(|ok| self.register_infer_ok_obligations(ok))?;\n-\n-                if a_def_id == b_def_id {\n-                    // Same function, maybe the parameters match.\n-                    let substs = self.commit_if_ok(|_| {\n-                        self.at(cause, self.param_env)\n-                            .trace(prev_ty, new_ty)\n-                            .lub(&a_substs, &b_substs)\n-                            .map(|ok| self.register_infer_ok_obligations(ok))\n-                    });\n-\n-                    if let Ok(substs) = substs {\n-                        // We have a LUB of prev_ty and new_ty, just return it.\n-                        return Ok(self.tcx.mk_fn_def(a_def_id, substs, fty));\n-                    }\n-                }\n+        if let (&ty::TyFnDef(..), &ty::TyFnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n+            // Don't reify if the function types have a LUB, i.e. they\n+            // are the same function and their parameters have a LUB.\n+            let lub_ty = self.commit_if_ok(|_| {\n+                self.at(cause, self.param_env)\n+                    .lub(prev_ty, new_ty)\n+                    .map(|ok| self.register_infer_ok_obligations(ok))\n+            });\n+\n+            if lub_ty.is_ok() {\n+                // We have a LUB of prev_ty and new_ty, just return it.\n+                return lub_ty;\n+            }\n \n-                // Reify both sides and return the reified fn pointer type.\n-                let fn_ptr = self.tcx.mk_fn_ptr(fty);\n-                for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n-                    // The only adjustment that can produce an fn item is\n-                    // `NeverToAny`, so this should always be valid.\n-                    self.apply_adjustments(expr, vec![Adjustment {\n-                        kind: Adjust::ReifyFnPointer,\n-                        target: fn_ptr\n-                    }]);\n-                }\n-                return Ok(fn_ptr);\n+            // The signature must match.\n+            let a_sig = prev_ty.fn_sig(self.tcx);\n+            let a_sig = self.normalize_associated_types_in(new.span, &a_sig);\n+            let b_sig = new_ty.fn_sig(self.tcx);\n+            let b_sig = self.normalize_associated_types_in(new.span, &b_sig);\n+            let sig = self.at(cause, self.param_env)\n+                          .trace(prev_ty, new_ty)\n+                          .lub(&a_sig, &b_sig)\n+                          .map(|ok| self.register_infer_ok_obligations(ok))?;\n+\n+            // Reify both sides and return the reified fn pointer type.\n+            let fn_ptr = self.tcx.mk_fn_ptr(sig);\n+            for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n+                // The only adjustment that can produce an fn item is\n+                // `NeverToAny`, so this should always be valid.\n+                self.apply_adjustments(expr, vec![Adjustment {\n+                    kind: Adjust::ReifyFnPointer,\n+                    target: fn_ptr\n+                }]);\n             }\n-            _ => {}\n+            return Ok(fn_ptr);\n         }\n \n         let mut coerce = Coerce::new(self, cause.clone());\n@@ -1162,6 +1187,18 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                             \"`return;` in a function whose return type is not `()`\");\n                         db.span_label(cause.span, \"return type is not ()\");\n                     }\n+                    ObligationCauseCode::BlockTailExpression(blk_id) => {\n+                        db = fcx.report_mismatched_types(cause, expected, found, err);\n+\n+                        let expr = expression.unwrap_or_else(|| {\n+                            span_bug!(cause.span,\n+                                      \"supposed to be part of a block tail expression, but the \\\n+                                       expression is empty\");\n+                        });\n+                        fcx.suggest_mismatched_types_on_tail(&mut db, expr,\n+                                                             expected, found,\n+                                                             cause.span, blk_id);\n+                    }\n                     _ => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);\n                     }"}, {"sha": "bf134f9547d3817893097baf4148f04abcabd9bc", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -256,17 +256,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Compute skolemized form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n-        let m_sig = |method: &ty::AssociatedItem| {\n-            match tcx.type_of(method.def_id).sty {\n-                ty::TyFnDef(_, _, f) => f,\n-                _ => bug!()\n-            }\n-        };\n-\n         let (impl_sig, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                             infer::HigherRankedType,\n-                                                            &m_sig(impl_m));\n+                                                            &tcx.fn_sig(impl_m.def_id));\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n@@ -277,7 +270,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let trait_sig = inh.liberate_late_bound_regions(\n             impl_m.def_id,\n-            &m_sig(trait_m));\n+            &tcx.fn_sig(trait_m.def_id));\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n@@ -335,7 +328,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n-            infcx.report_fulfillment_errors(errors);\n+            infcx.report_fulfillment_errors(errors, None);\n             return Err(ErrorReported);\n         }\n \n@@ -507,8 +500,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n-        let method_ty = tcx.type_of(method.def_id);\n-        let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n+        let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n         match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n             ExplicitSelf::ByValue => \"self\".to_string(),\n             ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n@@ -637,14 +629,8 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_m: &ty::AssociatedItem,\n                                                 trait_item_span: Option<Span>)\n                                                 -> Result<(), ErrorReported> {\n-    let m_fty = |method: &ty::AssociatedItem| {\n-        match tcx.type_of(method.def_id).sty {\n-            ty::TyFnDef(_, _, f) => f,\n-            _ => bug!()\n-        }\n-    };\n-    let impl_m_fty = m_fty(impl_m);\n-    let trait_m_fty = m_fty(trait_m);\n+    let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n+    let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n@@ -807,7 +793,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n-            infcx.report_fulfillment_errors(errors);\n+            infcx.report_fulfillment_errors(errors, None);\n             return;\n         }\n "}, {"sha": "f54ad54187267fd6d96ee6f48a22c9de61ad573a", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -73,15 +73,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n+        if let Some(mut err) = self.demand_coerce_diag(expr, checked_ty, expected) {\n+            err.emit();\n+        }\n+    }\n+\n     // Checks that the type of `expr` can be coerced to `expected`.\n     //\n     // NB: This code relies on `self.diverges` to be accurate.  In\n     // particular, assignments to `!` will be permitted if the\n     // diverges flag is currently \"always\".\n-    pub fn demand_coerce(&self,\n-                         expr: &hir::Expr,\n-                         checked_ty: Ty<'tcx>,\n-                         expected: Ty<'tcx>) {\n+    pub fn demand_coerce_diag(&self,\n+                              expr: &hir::Expr,\n+                              checked_ty: Ty<'tcx>,\n+                              expected: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n \n         if let Err(e) = self.try_coerce(expr, checked_ty, self.diverges.get(), expected) {\n@@ -105,8 +111,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       self.get_best_match(&suggestions).join(\"\\n\")));\n                 }\n             }\n-            err.emit();\n+            return Some(err);\n         }\n+        None\n     }\n \n     fn format_method_suggestion(&self, method: &AssociatedItem) -> String {\n@@ -143,12 +150,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n-                match self.tcx.type_of(def_id).sty {\n-                    ty::TypeVariants::TyFnDef(_, _, sig) => {\n-                        sig.inputs().skip_binder().len() == 1\n-                    }\n-                    _ => false,\n-                }\n+                self.tcx.fn_sig(def_id).inputs().skip_binder().len() == 1\n             }\n             _ => false,\n         }"}, {"sha": "ed22cd1333e9c58cf5b25ad8a565c341be834eee", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -110,7 +110,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n         if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n             // this could be reached when we get lazy normalization\n-            infcx.report_fulfillment_errors(errors);\n+            infcx.report_fulfillment_errors(errors, None);\n             return Err(ErrorReported);\n         }\n "}, {"sha": "96643ae72abadc5c7beaade2ff465137743c0a17", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -13,7 +13,6 @@\n \n use intrinsics;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::util::nodemap::FxHashMap;\n use require_same_types;\n@@ -35,22 +34,22 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    output: Ty<'tcx>) {\n     let def_id = tcx.hir.local_def_id(it.id);\n \n-    let substs = Substs::for_item(tcx, def_id,\n-                                  |_, _| tcx.types.re_erased,\n-                                  |def, _| tcx.mk_param_from_def(def));\n+    match it.node {\n+        hir::ForeignItemFn(..) => {}\n+        _ => {\n+            struct_span_err!(tcx.sess, it.span, E0622,\n+                             \"intrinsic must be a function\")\n+                .span_label(it.span, \"expected a function\")\n+                .emit();\n+            return;\n+        }\n+    }\n \n-    let fty = tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n-        inputs.into_iter(),\n-        output,\n-        false,\n-        hir::Unsafety::Unsafe,\n-        abi\n-    )));\n     let i_n_tps = tcx.generics_of(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, _, ref generics) => generics.span,\n-            hir::ForeignItemStatic(..) => it.span\n+            _ => bug!()\n         };\n \n         struct_span_err!(tcx.sess, span, E0094,\n@@ -59,14 +58,18 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         i_n_tps, n_tps)\n             .span_label(span, format!(\"expected {} type parameter\", n_tps))\n             .emit();\n-    } else {\n-        require_same_types(tcx,\n-                           &ObligationCause::new(it.span,\n-                                                 it.id,\n-                                                 ObligationCauseCode::IntrinsicType),\n-                           tcx.type_of(def_id),\n-                           fty);\n+        return;\n     }\n+\n+    let fty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+        inputs.into_iter(),\n+        output,\n+        false,\n+        hir::Unsafety::Unsafe,\n+        abi\n+    )));\n+    let cause = ObligationCause::new(it.span, it.id, ObligationCauseCode::IntrinsicType);\n+    require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(def_id)), fty);\n }\n \n /// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n@@ -376,7 +379,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                     let mut structural_to_nomimal = FxHashMap();\n \n-                    let sig = tcx.type_of(def_id).fn_sig();\n+                    let sig = tcx.fn_sig(def_id);\n                     let sig = tcx.no_late_bound_regions(&sig).unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,"}, {"sha": "209245187b13fd8bdc4903f266af7ccde2e051c1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let sig = self.tcx.type_of(def_id).fn_sig();\n+        let sig = self.tcx.fn_sig(def_id);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type."}, {"sha": "4f4169ac93d1b3d98027be9149eb20a868ef72b0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let fn_sig = tcx.type_of(def_id).fn_sig();\n+        let fn_sig = tcx.fn_sig(def_id);\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n                                                                     &fn_sig).0;"}, {"sha": "ee9a347ae95111b299c963ebb98a3ce554fae271", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -673,7 +673,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                expected: ty::Ty<'tcx>) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n-                let fty = self.tcx.type_of(def_id).fn_sig();\n+                let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let output = fty.output().subst(self.tcx, substs);\n@@ -1288,7 +1288,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n-        let self_ty = self.tcx.type_of(method).fn_sig().input(0);\n+        let self_ty = self.tcx.fn_sig(method).input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n                self_ty,"}, {"sha": "3241267bbc2e48d55c78bbe00a4997819912cf3b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 177, "deletions": 80, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -102,7 +102,7 @@ use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n use errors::DiagnosticBuilder;\n use require_c_abi_if_variadic;\n-use session::{Session, CompileResult};\n+use session::{CompileIncomplete, Session};\n use TypeAndSubsts;\n use lint;\n use util::common::{ErrorReported, indenter};\n@@ -124,6 +124,7 @@ use syntax_pos::{self, BytePos, Span};\n \n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::map::Node;\n use rustc::hir::{self, PatKind};\n use rustc::middle::lang_items;\n use rustc_back::slice;\n@@ -216,6 +217,8 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// environment is for an item or something where the \"callee\" is\n     /// not clear.\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n+\n+    body_id: Option<hir::BodyId>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -604,6 +607,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             anon_types: RefCell::new(NodeMap()),\n             implicit_region_bound,\n+            body_id,\n         }\n     }\n \n@@ -687,51 +691,45 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n }\n \n-pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n         tcx.hir.krate().visit_all_item_likes(&mut visit.as_deep_visitor());\n     })\n }\n \n-pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         tcx.hir.krate().visit_all_item_likes(&mut CheckItemTypesVisitor { tcx });\n     })\n }\n \n-pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), CompileIncomplete> {\n     tcx.typeck_item_bodies(LOCAL_CRATE)\n }\n \n-fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> CompileResult {\n+fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n+                                -> Result<(), CompileIncomplete>\n+{\n     debug_assert!(crate_num == LOCAL_CRATE);\n-    tcx.sess.track_errors(|| {\n+    Ok(tcx.sess.track_errors(|| {\n         for body_owner_def_id in tcx.body_owners() {\n             tcx.typeck_tables_of(body_owner_def_id);\n         }\n-    })\n+    })?)\n }\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         typeck_item_bodies,\n         typeck_tables_of,\n         has_typeck_tables,\n-        closure_type,\n         closure_kind,\n         adt_destructor,\n         ..*providers\n     };\n }\n \n-fn closure_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          def_id: DefId)\n-                          -> ty::PolyFnSig<'tcx> {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n-}\n-\n fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n@@ -844,7 +842,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let Some(decl) = fn_decl {\n-            let fn_sig = tcx.type_of(def_id).fn_sig();\n+            let fn_sig = tcx.fn_sig(def_id);\n \n             check_abi(tcx, span, fn_sig.abi());\n \n@@ -985,7 +983,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n     let ret_ty = fn_sig.output();\n-    fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n+    fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::SizedReturnType);\n     let ret_ty = fcx.instantiate_anon_types(&ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n@@ -1000,16 +998,17 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n-        // The type of the argument must be well-formed.\n-        //\n-        // NB -- this is now checked in wfcheck, but that\n-        // currently only results in warnings, so we issue an\n-        // old-style WF obligation here so that we still get the\n-        // errors that we used to get.\n-        fcx.register_old_wf_obligation(arg_ty, arg.pat.span, traits::MiscObligation);\n-\n         // Check the pattern.\n         fcx.check_pat_arg(&arg.pat, arg_ty, true);\n+\n+        // Check that argument is Sized.\n+        // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n+        // for simple cases like `fn foo(x: Trait)`,\n+        // where we would error once on the parameter as a whole, and once on the binding `x`.\n+        if arg.pat.simple_name().is_none() {\n+            fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::MiscObligation);\n+        }\n+\n         fcx.write_ty(arg.id, arg_ty);\n     }\n \n@@ -1908,7 +1907,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     // Require that the predicate holds for the concrete type.\n                     let cause = traits::ObligationCause::new(span, self.body_id,\n-                                                             traits::ReturnType);\n+                                                             traits::SizedReturnType);\n                     self.register_predicate(traits::Obligation::new(cause,\n                                                                     self.param_env,\n                                                                     predicate));\n@@ -1985,17 +1984,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Registers an obligation for checking later, during regionck, that the type `ty` must\n-    /// outlive the region `r`.\n-    pub fn register_region_obligation(&self,\n-                                      ty: Ty<'tcx>,\n-                                      region: ty::Region<'tcx>,\n-                                      cause: traits::ObligationCause<'tcx>)\n-    {\n-        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n-        fulfillment_cx.register_region_obligation(ty, region, cause);\n-    }\n-\n     /// Registers an obligation for checking later, during regionck, that the type `ty` must\n     /// outlive the region `r`.\n     pub fn register_wf_obligation(&self,\n@@ -2010,21 +1998,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                         ty::Predicate::WellFormed(ty)));\n     }\n \n-    pub fn register_old_wf_obligation(&self,\n-                                      ty: Ty<'tcx>,\n-                                      span: Span,\n-                                      code: traits::ObligationCauseCode<'tcx>)\n-    {\n-        // Registers an \"old-style\" WF obligation that uses the\n-        // implicator code.  This is basically a buggy version of\n-        // `register_wf_obligation` that is being kept around\n-        // temporarily just to help with phasing in the newer rules.\n-        //\n-        // FIXME(#27579) all uses of this should be migrated to register_wf_obligation eventually\n-        let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_region_obligation(ty, self.tcx.types.re_empty, cause);\n-    }\n-\n     /// Registers obligations that all types appearing in `substs` are well-formed.\n     pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr)\n     {\n@@ -2152,15 +2125,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match fulfillment_cx.select_all_or_error(self) {\n             Ok(()) => { }\n-            Err(errors) => { self.report_fulfillment_errors(&errors); }\n+            Err(errors) => { self.report_fulfillment_errors(&errors, self.inh.body_id); }\n         }\n     }\n \n     /// Select as many obligations as we can at present.\n     fn select_obligations_where_possible(&self) {\n         match self.fulfillment_cx.borrow_mut().select_where_possible(self) {\n             Ok(()) => { }\n-            Err(errors) => { self.report_fulfillment_errors(&errors); }\n+            Err(errors) => { self.report_fulfillment_errors(&errors, self.inh.body_id); }\n         }\n     }\n \n@@ -2173,7 +2146,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                           -> ty::TypeAndMut<'tcx>\n     {\n         // extract method return type, which will be &T;\n-        // all LB regions should have been instantiated during method lookup\n         let ret_ty = method.sig.output();\n \n         // method returns &T, but the type as visible to user is T, so deref\n@@ -2580,8 +2552,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n                     }\n-                    ty::TyFnDef(.., f) => {\n-                        let ptr_ty = self.tcx.mk_fn_ptr(f);\n+                    ty::TyFnDef(..) => {\n+                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n                         let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &format!(\"{}\", ptr_ty));\n                     }\n@@ -2848,10 +2820,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              \"check_return_expr called outside fn body\"));\n \n         let ret_ty = ret_coercion.borrow().expected_ty();\n-        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty);\n+        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty.clone());\n         ret_coercion.borrow_mut()\n                     .coerce(self,\n-                            &self.misc(return_expr.span),\n+                            &self.cause(return_expr.span,\n+                                        ObligationCauseCode::ReturnType(return_expr.id)),\n                             return_expr,\n                             return_expr_ty,\n                             self.diverges.get());\n@@ -3154,11 +3127,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let adt_ty_hint =\n             self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n-                .get(0).cloned().unwrap_or(adt_ty);\n+            .get(0).cloned().unwrap_or(adt_ty);\n+        // re-link the regions that EIfEO can erase.\n+        self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n-        let (substs, hint_substs, adt_kind, kind_name) = match (&adt_ty.sty, &adt_ty_hint.sty) {\n-            (&ty::TyAdt(adt, substs), &ty::TyAdt(_, hint_substs)) => {\n-                (substs, hint_substs, adt.adt_kind(), adt.variant_descr())\n+        let (substs, adt_kind, kind_name) = match &adt_ty.sty{\n+            &ty::TyAdt(adt, substs) => {\n+                (substs, adt.adt_kind(), adt.variant_descr())\n             }\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n@@ -3174,14 +3149,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Typecheck each field.\n         for field in ast_fields {\n-            let final_field_type;\n-            let field_type_hint;\n-\n             let ident = tcx.adjust(field.name.node, variant.did, self.body_id).0;\n-            if let Some(v_field) = remaining_fields.remove(&ident) {\n-                final_field_type = self.field_ty(field.span, v_field, substs);\n-                field_type_hint = self.field_ty(field.span, v_field, hint_substs);\n-\n+            let field_type = if let Some(v_field) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(field.name.node, field.span);\n \n                 // we don't look at stability attributes on\n@@ -3190,10 +3159,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if adt_kind != ty::AdtKind::Enum {\n                     tcx.check_stability(v_field.did, expr_id, field.span);\n                 }\n+\n+                self.field_ty(field.span, v_field, substs)\n             } else {\n                 error_happened = true;\n-                final_field_type = tcx.types.err;\n-                field_type_hint = tcx.types.err;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n                                                    field.name.span,\n@@ -3211,12 +3180,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name);\n                 }\n-            }\n+\n+                tcx.types.err\n+            };\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue typechecking\n-            let ty = self.check_expr_with_hint(&field.expr, field_type_hint);\n-            self.demand_coerce(&field.expr, ty, final_field_type);\n+            self.check_expr_coercable_to_type(&field.expr, field_type);\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -3883,6 +3853,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if tuple.references_error() {\n                 tcx.types.err\n             } else {\n+                self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n                 tuple\n             }\n           }\n@@ -4170,8 +4141,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut coerce = ctxt.coerce.as_mut().unwrap();\n             if let Some(tail_expr_ty) = tail_expr_ty {\n                 let tail_expr = tail_expr.unwrap();\n+                let cause = self.cause(tail_expr.span,\n+                                       ObligationCauseCode::BlockTailExpression(blk.id));\n                 coerce.coerce(self,\n-                              &self.misc(tail_expr.span),\n+                              &cause,\n                               tail_expr,\n                               tail_expr_ty,\n                               self.diverges.get());\n@@ -4210,6 +4183,130 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n+    /// Given a `NodeId`, return the `FnDecl` of the method it is enclosed by and whether it is\n+    /// `fn main` if it is a method, `None` otherwise.\n+    pub fn get_fn_decl(&self, blk_id: ast::NodeId) -> Option<(hir::FnDecl, bool)> {\n+        // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n+        // `while` before reaching it, as block tail returns are not available in them.\n+        if let Some(fn_id) = self.tcx.hir.get_return_block(blk_id) {\n+            let parent = self.tcx.hir.get(fn_id);\n+\n+            if let Node::NodeItem(&hir::Item {\n+                name, node: hir::ItemFn(ref decl, ..), ..\n+            }) = parent {\n+                decl.clone().and_then(|decl| {\n+                    // This is less than ideal, it will not present the return type span on any\n+                    // method called `main`, regardless of whether it is actually the entry point.\n+                    Some((decl, name == Symbol::intern(\"main\")))\n+                })\n+            } else if let Node::NodeTraitItem(&hir::TraitItem {\n+                node: hir::TraitItemKind::Method(hir::MethodSig {\n+                    ref decl, ..\n+                }, ..), ..\n+            }) = parent {\n+                decl.clone().and_then(|decl| {\n+                    Some((decl, false))\n+                })\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// On implicit return expressions with mismatched types, provide the following suggestions:\n+    ///\n+    ///  - Point out the method's return type as the reason for the expected type\n+    ///  - Possible missing semicolon\n+    ///  - Possible missing return type if the return type is the default, and not `fn main()`\n+    pub fn suggest_mismatched_types_on_tail(&self,\n+                                            err: &mut DiagnosticBuilder<'tcx>,\n+                                            expression: &'gcx hir::Expr,\n+                                            expected: Ty<'tcx>,\n+                                            found: Ty<'tcx>,\n+                                            cause_span: Span,\n+                                            blk_id: ast::NodeId) {\n+        self.suggest_missing_semicolon(err, expression, expected, cause_span);\n+\n+        if let Some((fn_decl, is_main)) = self.get_fn_decl(blk_id) {\n+            // `fn main()` must return `()`, do not suggest changing return type\n+            if !is_main {\n+                self.suggest_missing_return_type(err, &fn_decl, found);\n+            }\n+        }\n+    }\n+\n+    /// A common error is to forget to add a semicolon at the end of a block:\n+    ///\n+    /// ```\n+    /// fn foo() {\n+    ///     bar_that_returns_u32()\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the return expression in a block would make sense on its own as a\n+    /// statement and the return type has been left as defaultor has been specified as `()`. If so,\n+    /// it suggests adding a semicolon.\n+    fn suggest_missing_semicolon(&self,\n+                                     err: &mut DiagnosticBuilder<'tcx>,\n+                                     expression: &'gcx hir::Expr,\n+                                     expected: Ty<'tcx>,\n+                                     cause_span: Span) {\n+        if expected.is_nil() {\n+            // `BlockTailExpression` only relevant if the tail expr would be\n+            // useful on its own.\n+            match expression.node {\n+                hir::ExprCall(..) |\n+                hir::ExprMethodCall(..) |\n+                hir::ExprIf(..) |\n+                hir::ExprWhile(..) |\n+                hir::ExprLoop(..) |\n+                hir::ExprMatch(..) |\n+                hir::ExprBlock(..) => {\n+                    let sp = cause_span.next_point();\n+                    err.span_suggestion(sp,\n+                                        \"did you mean to add a semicolon here?\",\n+                                        \";\".to_string());\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+\n+    /// A possible error is to forget to add a return type that is needed:\n+    ///\n+    /// ```\n+    /// fn foo() {\n+    ///     bar_that_returns_u32()\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the return type is left as default, the method is not part of an\n+    /// `impl` block and that it isn't the `main` method. If so, it suggests setting the return\n+    /// type.\n+    fn suggest_missing_return_type(&self,\n+                                   err: &mut DiagnosticBuilder<'tcx>,\n+                                   fn_decl: &hir::FnDecl,\n+                                   ty: Ty<'tcx>) {\n+\n+        // Only recommend changing the return type for methods that\n+        // haven't set a return type at all (and aren't `fn main()` or an impl).\n+        if let &hir::FnDecl {\n+            output: hir::FunctionRetTy::DefaultReturn(span), ..\n+        } = fn_decl {\n+            if ty.is_suggestable() {\n+                err.span_suggestion(span,\n+                                    \"possibly return type missing here?\",\n+                                    format!(\"-> {} \", ty));\n+            } else {\n+                err.span_label(span, \"possibly return type missing here?\");\n+            }\n+        }\n+    }\n+\n+\n     /// A common error is to add an extra semicolon:\n     ///\n     /// ```\n@@ -4245,7 +4342,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hi: original_span.hi,\n             ctxt: original_span.ctxt,\n         };\n-        err.span_help(span_semi, \"consider removing this semicolon:\");\n+        err.span_suggestion(span_semi, \"consider removing this semicolon\", \"\".to_string());\n     }\n \n     // Instantiates the given path, which must refer to an item with the given\n@@ -4619,9 +4716,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // If not, error.\n             if alternative.is_ty_var() || alternative.references_error() {\n                 if !self.is_tainted_by_errors() {\n-                    self.type_error_message(sp, |_actual| {\n-                        \"the type of this value must be known in this context\".to_string()\n-                    }, ty);\n+                    type_error_struct!(self.tcx.sess, sp, ty, E0619,\n+                                       \"the type of this value must be known in this context\")\n+                        .emit();\n                 }\n                 self.demand_suptype(sp, self.tcx.types.err, ty);\n                 ty = self.tcx.types.err;"}, {"sha": "cbda1227742ca32d5756e27344e204cd02736915", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -177,12 +177,11 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n-                    let method_ty = fcx.tcx.type_of(item.def_id);\n-                    let method_ty = fcx.normalize_associated_types_in(span, &method_ty);\n+                    let sig = fcx.tcx.fn_sig(item.def_id);\n+                    let sig = fcx.normalize_associated_types_in(span, &sig);\n                     let predicates = fcx.tcx.predicates_of(item.def_id)\n                         .instantiate_identity(fcx.tcx);\n                     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n-                    let sig = method_ty.fn_sig();\n                     this.check_fn_or_method(fcx, span, sig, &predicates,\n                                             item.def_id, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n@@ -331,9 +330,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n     fn check_item_fn(&mut self, item: &hir::Item) {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let ty = fcx.tcx.type_of(def_id);\n-            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n-            let sig = item_ty.fn_sig();\n+            let sig = fcx.tcx.fn_sig(def_id);\n+            let sig = fcx.normalize_associated_types_in(item.span, &sig);\n \n             let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n             let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n@@ -461,9 +459,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         let span = method_sig.decl.inputs[0].span;\n \n-        let method_ty = fcx.tcx.type_of(method.def_id);\n-        let fty = fcx.normalize_associated_types_in(span, &method_ty);\n-        let sig = fcx.liberate_late_bound_regions(method.def_id, &fty.fn_sig());\n+        let sig = fcx.tcx.fn_sig(method.def_id);\n+        let sig = fcx.normalize_associated_types_in(span, &sig);\n+        let sig = fcx.liberate_late_bound_regions(method.def_id, &sig);\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n "}, {"sha": "81e5dae5477ebcf8df619c8790364c43127f86c4", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -377,7 +377,7 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n \n     fn report_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n-            self.infcx.need_type_info(self.body.id(), self.span.to_span(&self.tcx), t);\n+            self.infcx.need_type_info(Some(self.body.id()), self.span.to_span(&self.tcx), t);\n         }\n     }\n }"}, {"sha": "9305eff1436520e7b3ee0bebf1c2e21c4e105198", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -386,7 +386,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Check that all transitive obligations are satisfied.\n         if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-            infcx.report_fulfillment_errors(&errors);\n+            infcx.report_fulfillment_errors(&errors, None);\n         }\n \n         // Finally, resolve all regions."}, {"sha": "fd6dda5ccf4a72e9c81be10c6bef8beec7c4f7ca", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 82, "deletions": 30, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -97,6 +97,7 @@ pub fn provide(providers: &mut Providers) {\n         type_param_predicates,\n         trait_def,\n         adt_def,\n+        fn_sig,\n         impl_trait_ref,\n         impl_polarity,\n         is_foreign_item,\n@@ -447,6 +448,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n+                if let hir::ForeignItemFn(..) = item.node {\n+                    tcx.fn_sig(def_id);\n+                }\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n@@ -497,6 +501,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n+            if let hir::ItemFn(..) = it.node {\n+                tcx.fn_sig(def_id);\n+            }\n         }\n     }\n }\n@@ -511,6 +518,9 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast:\n         hir::TraitItemKind::Type(_, Some(_)) |\n         hir::TraitItemKind::Method(..) => {\n             tcx.type_of(def_id);\n+            if let hir::TraitItemKind::Method(..) = trait_item.node {\n+                tcx.fn_sig(def_id);\n+            }\n         }\n \n         hir::TraitItemKind::Type(_, None) => {}\n@@ -524,6 +534,9 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: ast::N\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n+    if let hir::ImplItemKind::Method(..) = tcx.hir.expect_impl_item(impl_item_id).node {\n+        tcx.fn_sig(def_id);\n+    }\n }\n \n fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -963,10 +976,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match tcx.hir.get(node_id) {\n         NodeTraitItem(item) => {\n             match item.node {\n-                TraitItemKind::Method(ref sig, _) => {\n-                    let fty = AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl);\n+                TraitItemKind::Method(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, fty)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 TraitItemKind::Const(ref ty, _) |\n                 TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n@@ -978,10 +990,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeImplItem(item) => {\n             match item.node {\n-                ImplItemKind::Method(ref sig, _) => {\n-                    let fty = AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl);\n+                ImplItemKind::Method(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, fty)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n                 ImplItemKind::Type(ref ty) => {\n@@ -1001,10 +1012,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ItemTy(ref t, _) | ItemImpl(.., ref t, _) => {\n                     icx.to_ty(t)\n                 }\n-                ItemFn(ref decl, unsafety, _, abi, _, _) => {\n-                    let tofd = AstConv::ty_of_fn(&icx, unsafety, abi, &decl);\n+                ItemFn(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, tofd)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ItemEnum(..) |\n                 ItemStruct(..) |\n@@ -1029,33 +1039,24 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         NodeForeignItem(foreign_item) => {\n-            let abi = tcx.hir.get_foreign_abi(node_id);\n-\n             match foreign_item.node {\n-                ForeignItemFn(ref fn_decl, _, _) => {\n-                    compute_type_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n+                ForeignItemFn(..) => {\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ForeignItemStatic(ref t, _) => icx.to_ty(t)\n             }\n         }\n \n         NodeStructCtor(&ref def) |\n         NodeVariant(&Spanned { node: hir::Variant_ { data: ref def, .. }, .. }) => {\n-            let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n             match *def {\n-                VariantData::Unit(..) | VariantData::Struct(..) => ty,\n-                VariantData::Tuple(ref fields, _) => {\n-                    let inputs = fields.iter().map(|f| {\n-                        tcx.type_of(tcx.hir.local_def_id(f.id))\n-                    });\n+                VariantData::Unit(..) | VariantData::Struct(..) => {\n+                    tcx.type_of(tcx.hir.get_parent_did(node_id))\n+                }\n+                VariantData::Tuple(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n-                        inputs,\n-                        ty,\n-                        false,\n-                        hir::Unsafety::Normal,\n-                        abi::Abi::Rust\n-                    )))\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n             }\n         }\n@@ -1105,6 +1106,58 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    def_id: DefId)\n+                    -> ty::PolyFnSig<'tcx> {\n+    use rustc::hir::map::*;\n+    use rustc::hir::*;\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+\n+    let icx = ItemCtxt::new(tcx, def_id);\n+\n+    match tcx.hir.get(node_id) {\n+        NodeTraitItem(&hir::TraitItem { node: TraitItemKind::Method(ref sig, _), .. }) |\n+        NodeImplItem(&hir::ImplItem { node: ImplItemKind::Method(ref sig, _), .. }) => {\n+            AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl)\n+        }\n+\n+        NodeItem(&hir::Item { node: ItemFn(ref decl, unsafety, _, abi, _, _), .. }) => {\n+            AstConv::ty_of_fn(&icx, unsafety, abi, decl)\n+        }\n+\n+        NodeForeignItem(&hir::ForeignItem { node: ForeignItemFn(ref fn_decl, _, _), .. }) => {\n+            let abi = tcx.hir.get_foreign_abi(node_id);\n+            compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n+        }\n+\n+        NodeStructCtor(&VariantData::Tuple(ref fields, _)) |\n+        NodeVariant(&Spanned { node: hir::Variant_ {\n+            data: VariantData::Tuple(ref fields, _), ..\n+        }, .. }) => {\n+            let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n+            let inputs = fields.iter().map(|f| {\n+                tcx.type_of(tcx.hir.local_def_id(f.id))\n+            });\n+            ty::Binder(tcx.mk_fn_sig(\n+                inputs,\n+                ty,\n+                false,\n+                hir::Unsafety::Normal,\n+                abi::Abi::Rust\n+            ))\n+        }\n+\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+            tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n+        }\n+\n+        x => {\n+            bug!(\"unexpected sort of node in fn_sig(): {:?}\", x);\n+        }\n+    }\n+}\n+\n fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             def_id: DefId)\n                             -> Option<ty::TraitRef<'tcx>> {\n@@ -1502,12 +1555,12 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n+fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     decl: &hir::FnDecl,\n     abi: abi::Abi)\n-    -> Ty<'tcx>\n+    -> ty::PolyFnSig<'tcx>\n {\n     let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), hir::Unsafety::Unsafe, abi, decl);\n \n@@ -1533,8 +1586,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = Substs::identity_for_item(tcx, def_id);\n-    tcx.mk_fn_def(def_id, substs, fty)\n+    fty\n }\n \n fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "37f6f3753d7b4fea373fba03fb68c68b3323b797", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -4208,6 +4208,104 @@ println!(\"{}\", v[2]);\n ```\n \"##,\n \n+E0604: r##\"\n+A cast to `char` was attempted on a type other than `u8`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0604\n+0u32 as char; // error: only `u8` can be cast as `char`, not `u32`\n+```\n+\n+As the error message indicates, only `u8` can be cast into `char`. Example:\n+\n+```\n+let c = 86u8 as char; // ok!\n+assert_eq!(c, 'V');\n+```\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+\"##,\n+\n+E0605: r##\"\n+An invalid cast was attempted.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0605\n+let x = 0u8;\n+x as Vec<u8>; // error: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n+\n+// Another example\n+\n+let v = 0 as *const u8; // So here, `v` is a `*const u8`.\n+v as &u8; // error: non-primitive cast: `*const u8` as `&u8`\n+```\n+\n+Only primitive types can be cast into each other. Examples:\n+\n+```\n+let x = 0u8;\n+x as u32; // ok!\n+\n+let v = 0 as *const u8;\n+v as *const i8; // ok!\n+```\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+\"##,\n+\n+E0606: r##\"\n+An incompatible cast was attempted.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0606\n+let x = &0u8; // Here, `x` is a `&u8`.\n+let y: u32 = x as u32; // error: casting `&u8` as `u32` is invalid\n+```\n+\n+When casting, keep in mind that only primitive types can be cast into each\n+other. Example:\n+\n+```\n+let x = &0u8;\n+let y: u32 = *x as u32; // We dereference it first and then cast it.\n+```\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+\"##,\n+\n+E0607: r##\"\n+A cast between a thin and a fat pointer was attempted.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0607\n+let v = 0 as *const u8;\n+v as *const [u8];\n+```\n+\n+First: what are thin and fat pointers?\n+\n+Thin pointers are \"simple\" pointers: they are purely a reference to a memory\n+address.\n+\n+Fat pointers are pointers referencing Dynamically Sized Types (also called DST).\n+DST don't have a statically known size, therefore they can only exist behind\n+some kind of pointers that contain additional information. Slices and trait\n+objects are DSTs. In the case of slices, the additional information the fat\n+pointer holds is their size.\n+\n+To fix this error, don't try to cast directly between thin and fat pointers.\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+\"##,\n+\n E0609: r##\"\n Attempted to access a non-existent field in a struct.\n \n@@ -4567,6 +4665,87 @@ i_am_a_function();\n ```\n \"##,\n \n+E0619: r##\"\n+The type-checker needed to know the type of an expression, but that type had not\n+yet been inferred.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0619\n+let mut x = vec![];\n+match x.pop() {\n+    Some(v) => {\n+        // Here, the type of `v` is not (yet) known, so we\n+        // cannot resolve this method call:\n+        v.to_uppercase(); // error: the type of this value must be known in\n+                          //        this context\n+    }\n+    None => {}\n+}\n+```\n+\n+Type inference typically proceeds from the top of the function to the bottom,\n+figuring out types as it goes. In some cases -- notably method calls and\n+overloadable operators like `*` -- the type checker may not have enough\n+information *yet* to make progress. This can be true even if the rest of the\n+function provides enough context (because the type-checker hasn't looked that\n+far ahead yet). In this case, type annotations can be used to help it along.\n+\n+To fix this error, just specify the type of the variable. Example:\n+\n+```\n+let mut x: Vec<String> = vec![]; // We precise the type of the vec elements.\n+match x.pop() {\n+    Some(v) => {\n+        v.to_uppercase(); // Since rustc now knows the type of the vec elements,\n+                          // we can use `v`'s methods.\n+    }\n+    None => {}\n+}\n+```\n+\"##,\n+\n+E0620: r##\"\n+A cast to an unsized type was attempted.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0620\n+let x = &[1_usize, 2] as [usize]; // error: cast to unsized type: `&[usize; 2]`\n+                                  //        as `[usize]`\n+```\n+\n+In Rust, some types don't have a known size at compile-time. For example, in a\n+slice type like `[u32]`, the number of elements is not known at compile-time and\n+hence the overall size cannot be computed. As a result, such types can only be\n+manipulated through a reference (e.g., `&T` or `&mut T`) or other pointer-type\n+(e.g., `Box` or `Rc`). Try casting to a reference instead:\n+\n+```\n+let x = &[1_usize, 2] as &[usize]; // ok!\n+```\n+\"##,\n+\n+E0622: r##\"\n+An intrinsic was declared without being a function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0622\n+#![feature(intrinsics)]\n+extern \"rust-intrinsic\" {\n+    pub static breakpoint : unsafe extern \"rust-intrinsic\" fn();\n+    // error: intrinsic must be a function\n+}\n+\n+fn main() { unsafe { breakpoint(); } }\n+```\n+\n+An intrinsic is a function available for use in a given programming language\n+whose implementation is handled specially by the compiler. In order to fix this\n+error, just declare a function.\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "9b829e6e3ff2ed8cbf1ec6502dac208ffc72e6b0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -108,7 +108,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::traits::{FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n-use session::config;\n+use session::{CompileIncomplete, config};\n use util::common::time;\n \n use syntax::ast;\n@@ -166,7 +166,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match fulfill_cx.select_all_or_error(infcx) {\n             Ok(()) => true,\n             Err(errors) => {\n-                infcx.report_fulfillment_errors(&errors);\n+                infcx.report_fulfillment_errors(&errors, None);\n                 false\n             }\n         }\n@@ -198,22 +198,21 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n                 _ => ()\n             }\n-            let substs = tcx.intern_substs(&[]);\n-            let se_ty = tcx.mk_fn_def(main_def_id, substs,\n-                ty::Binder(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n+                tcx.mk_fn_sig(\n                     iter::empty(),\n                     tcx.mk_nil(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust\n-                ))\n-            );\n+                )\n+            ));\n \n             require_same_types(\n                 tcx,\n                 &ObligationCause::new(main_span, main_id, ObligationCauseCode::MainFunctionType),\n                 se_ty,\n-                main_t);\n+                tcx.mk_fn_ptr(tcx.fn_sig(main_def_id)));\n         }\n         _ => {\n             span_bug!(main_span,\n@@ -248,9 +247,8 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => ()\n             }\n \n-            let substs = tcx.intern_substs(&[]);\n-            let se_ty = tcx.mk_fn_def(start_def_id, substs,\n-                ty::Binder(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n+                tcx.mk_fn_sig(\n                     [\n                         tcx.types.isize,\n                         tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n@@ -259,14 +257,14 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust\n-                ))\n-            );\n+                )\n+            ));\n \n             require_same_types(\n                 tcx,\n                 &ObligationCause::new(start_span, start_id, ObligationCauseCode::StartFunctionType),\n                 se_ty,\n-                start_t);\n+                tcx.mk_fn_ptr(tcx.fn_sig(start_def_id)));\n         }\n         _ => {\n             span_bug!(start_span,\n@@ -295,7 +293,8 @@ pub fn provide(providers: &mut Providers) {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                             -> Result<(), usize> {\n+                             -> Result<(), CompileIncomplete>\n+{\n     let time_passes = tcx.sess.time_passes();\n \n     // this ensures that later parts of type checking can assume that items\n@@ -330,12 +329,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n \n-    let err_count = tcx.sess.err_count();\n-    if err_count == 0 {\n-        Ok(())\n-    } else {\n-        Err(err_count)\n-    }\n+    tcx.sess.compile_status()\n }\n \n /// A quasi-deprecated helper used in rustdoc and save-analysis to get"}, {"sha": "f4963619370e41ef2b1cc8f6e746b00596f62ace", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 146, "deletions": 248, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,11 +14,9 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use middle::resolve_lifetime as rl;\n use rustc::dep_graph::{AssertDepGraphSafe, DepKind};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -61,10 +59,10 @@ pub struct Constraint<'a> {\n ///     }\n ///\n /// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n-/// the def-id and generics of `Foo`.\n-pub struct CurrentItem<'a> {\n+/// the def-id and the start of `Foo`'s inferreds.\n+pub struct CurrentItem {\n     def_id: DefId,\n-    generics: &'a ty::Generics,\n+    inferred_start: InferredIndex,\n }\n \n pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n@@ -91,29 +89,71 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        match item.node {\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.visit_node_helper(item.id);\n+\n+                if let hir::VariantData::Tuple(..) = *struct_def {\n+                    self.visit_node_helper(struct_def.id());\n+                }\n+            }\n+\n+            hir::ItemEnum(ref enum_def, _) => {\n+                self.visit_node_helper(item.id);\n+\n+                for variant in &enum_def.variants {\n+                    if let hir::VariantData::Tuple(..) = variant.node.data {\n+                        self.visit_node_helper(variant.node.data.id());\n+                    }\n+                }\n+            }\n+\n+            hir::ItemFn(..) => {\n+                self.visit_node_helper(item.id);\n+            }\n+\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if let hir::ForeignItemFn(..) = foreign_item.node {\n+                        self.visit_node_helper(foreign_item.id);\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(..) = trait_item.node {\n+            self.visit_node_helper(trait_item.id);\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(..) = impl_item.node {\n+            self.visit_node_helper(impl_item.id);\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn visit_node_helper(&mut self, id: ast::NodeId) {\n         let tcx = self.terms_cx.tcx;\n-        let def_id = tcx.hir.local_def_id(item.id);\n+        let def_id = tcx.hir.local_def_id(id);\n \n         // Encapsulate constructing the constraints into a task we can\n         // reference later. This can go away once the red-green\n         // algorithm is in place.\n         //\n         // See README.md for a detailed discussion\n         // on dep-graph management.\n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => {\n-                let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-                tcx.dep_graph.with_task(dep_node,\n-                                        AssertDepGraphSafe(self),\n-                                        def_id,\n-                                        visit_item_task);\n-            }\n-            _ => {\n-                // Nothing to do here, skip the task.\n-            }\n-        }\n+        let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+        tcx.dep_graph.with_task(dep_node,\n+                                AssertDepGraphSafe(self),\n+                                def_id,\n+                                visit_item_task);\n \n         fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n                                      def_id: DefId)\n@@ -122,197 +162,57 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-/// Is `param_id` a lifetime according to `map`?\n-fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n-    match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true,\n-        _ => false,\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.terms_cx.tcx\n     }\n \n     fn build_constraints_for_item(&mut self, def_id: DefId) {\n         let tcx = self.tcx();\n-        let id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-        let item = tcx.hir.expect_item(id);\n-        debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n+        debug!(\"build_constraints_for_item({})\", tcx.item_path_str(def_id));\n \n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => {\n-                let generics = tcx.generics_of(def_id);\n-                let current_item = &CurrentItem { def_id, generics };\n+        // Skip items with no generics - there's nothing to infer in them.\n+        if tcx.generics_of(def_id).count() == 0 {\n+            return;\n+        }\n \n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let inferred_start = self.terms_cx.inferred_starts[&id];\n+        let current_item = &CurrentItem { def_id, inferred_start };\n+        match tcx.type_of(def_id).sty {\n+            ty::TyAdt(def, _) => {\n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(generics);\n \n-                for field in tcx.adt_def(def_id).all_fields() {\n+                for field in def.all_fields() {\n                     self.add_constraints_from_ty(current_item,\n                                                  tcx.type_of(field.did),\n                                                  self.covariant);\n                 }\n             }\n \n-            hir::ItemTrait(..) |\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {\n-                span_bug!(item.span, \"`build_constraints_for_item` invoked for non-type-def\");\n+            ty::TyFnDef(..) => {\n+                self.add_constraints_from_sig(current_item,\n+                                              tcx.fn_sig(def_id),\n+                                              self.covariant);\n             }\n-        }\n-    }\n-\n-    /// Load the generics for another item, adding a corresponding\n-    /// relation into the dependencies to indicate that the variance\n-    /// for `current` relies on `def_id`.\n-    fn read_generics(&mut self, current: &CurrentItem, def_id: DefId) -> &'tcx ty::Generics {\n-        let generics = self.tcx().generics_of(def_id);\n-        if self.tcx().dep_graph.is_fully_enabled() {\n-            self.dependencies.add(current.def_id, def_id);\n-        }\n-        generics\n-    }\n \n-    fn opt_inferred_index(&self, param_id: ast::NodeId) -> Option<&InferredIndex> {\n-        self.terms_cx.inferred_map.get(&param_id)\n-    }\n-\n-    fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n-        let tcx = self.terms_cx.tcx;\n-        assert!(is_lifetime(&tcx.hir, param_id));\n-        match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::Region::EarlyBound(_, lifetime_decl_id)) => lifetime_decl_id,\n-            Some(_) => bug!(\"should not encounter non early-bound cases\"),\n-\n-            // The lookup should only fail when `param_id` is\n-            // itself a lifetime binding: use it as the decl_id.\n-            None => param_id,\n-        }\n-\n-    }\n-\n-    /// Is `param_id` a type parameter for which we infer variance?\n-    fn is_to_be_inferred(&self, param_id: ast::NodeId) -> bool {\n-        let result = self.terms_cx.inferred_map.contains_key(&param_id);\n-\n-        // To safe-guard against invalid inferred_map constructions,\n-        // double-check if variance is inferred at some use of a type\n-        // parameter (by inspecting parent of its binding declaration\n-        // to see if it is introduced by a type or by a fn/impl).\n-\n-        let check_result = |this: &ConstraintContext| -> bool {\n-            let tcx = this.terms_cx.tcx;\n-            let decl_id = this.find_binding_for_lifetime(param_id);\n-            // Currently only called on lifetimes; double-checking that.\n-            assert!(is_lifetime(&tcx.hir, param_id));\n-            let parent_id = tcx.hir.get_parent(decl_id);\n-            let parent = tcx.hir\n-                .find(parent_id)\n-                .unwrap_or_else(|| bug!(\"tcx.hir missing entry for id: {}\", parent_id));\n-\n-            let is_inferred;\n-            macro_rules! cannot_happen { () => { {\n-                bug!(\"invalid parent: {} for {}\",\n-                     tcx.hir.node_to_string(parent_id),\n-                     tcx.hir.node_to_string(param_id));\n-            } } }\n-\n-            match parent {\n-                hir_map::NodeItem(p) => {\n-                    match p.node {\n-                        hir::ItemTy(..) |\n-                        hir::ItemEnum(..) |\n-                        hir::ItemStruct(..) |\n-                        hir::ItemUnion(..) |\n-                        hir::ItemTrait(..) => is_inferred = true,\n-                        hir::ItemFn(..) => is_inferred = false,\n-                        _ => cannot_happen!(),\n-                    }\n-                }\n-                hir_map::NodeTraitItem(..) => is_inferred = false,\n-                hir_map::NodeImplItem(..) => is_inferred = false,\n-                _ => cannot_happen!(),\n-            }\n-\n-            return is_inferred;\n-        };\n-\n-        assert_eq!(result, check_result(self));\n-\n-        return result;\n-    }\n-\n-    /// Returns a variance term representing the declared variance of the type/region parameter\n-    /// with the given id.\n-    fn declared_variance(&self,\n-                         param_def_id: DefId,\n-                         item_def_id: DefId,\n-                         index: usize)\n-                         -> VarianceTermPtr<'a> {\n-        assert_eq!(param_def_id.krate, item_def_id.krate);\n-\n-        if let Some(param_node_id) = self.tcx().hir.as_local_node_id(param_def_id) {\n-            // Parameter on an item defined within current crate:\n-            // variance not yet inferred, so return a symbolic\n-            // variance.\n-            if let Some(&InferredIndex(index)) = self.opt_inferred_index(param_node_id) {\n-                self.terms_cx.inferred_infos[index].term\n-            } else {\n-                // If there is no inferred entry for a type parameter,\n-                // it must be declared on a (locally defiend) trait -- they don't\n-                // get inferreds because they are always invariant.\n-                if cfg!(debug_assertions) {\n-                    let item_node_id = self.tcx().hir.as_local_node_id(item_def_id).unwrap();\n-                    let item = self.tcx().hir.expect_item(item_node_id);\n-                    let success = match item.node {\n-                        hir::ItemTrait(..) => true,\n-                        _ => false,\n-                    };\n-                    if !success {\n-                        bug!(\"parameter {:?} has no inferred, but declared on non-trait: {:?}\",\n-                             item_def_id,\n-                             item);\n-                    }\n-                }\n-                self.invariant\n+            _ => {\n+                span_bug!(tcx.def_span(def_id),\n+                          \"`build_constraints_for_item` unsupported for this item\");\n             }\n-        } else {\n-            // Parameter on an item defined within another crate:\n-            // variance already inferred, just look it up.\n-            let variances = self.tcx().variances_of(item_def_id);\n-            self.constant_term(variances[index])\n         }\n     }\n \n     fn add_constraint(&mut self,\n-                      InferredIndex(index): InferredIndex,\n+                      current: &CurrentItem,\n+                      index: u32,\n                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraint(index={}, variance={:?})\", index, variance);\n         self.constraints.push(Constraint {\n-            inferred: InferredIndex(index),\n+            inferred: InferredIndex(current.inferred_start.0 + index as usize),\n             variance: variance,\n         });\n     }\n@@ -354,15 +254,26 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n                trait_ref,\n                variance);\n+        self.add_constraints_from_invariant_substs(current, trait_ref.substs, variance);\n+    }\n \n-        let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n+    fn add_constraints_from_invariant_substs(&mut self,\n+                                             current: &CurrentItem,\n+                                             substs: &Substs<'tcx>,\n+                                             variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_invariant_substs: substs={:?} variance={:?}\",\n+               substs,\n+               variance);\n \n-        self.add_constraints_from_substs(current,\n-                                         trait_ref.def_id,\n-                                         &trait_generics.types,\n-                                         &trait_generics.regions,\n-                                         trait_ref.substs,\n-                                         variance);\n+        // Trait are always invariant so we can take advantage of that.\n+        let variance_i = self.invariant(variance);\n+        for ty in substs.types() {\n+            self.add_constraints_from_ty(current, ty, variance_i);\n+        }\n+\n+        for region in substs.regions() {\n+            self.add_constraints_from_region(current, region, variance_i);\n+        }\n     }\n \n     /// Adds constraints appropriate for an instance of `ty` appearing\n@@ -382,8 +293,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // leaf type -- noop\n             }\n \n-            ty::TyClosure(..) |\n-            ty::TyAnon(..) => {\n+            ty::TyFnDef(..) |\n+            ty::TyClosure(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n \n@@ -409,26 +320,15 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let adt_generics = self.read_generics(current, def.did);\n-\n-                self.add_constraints_from_substs(current,\n-                                                 def.did,\n-                                                 &adt_generics.types,\n-                                                 &adt_generics.regions,\n-                                                 substs,\n-                                                 variance);\n+                self.add_constraints_from_substs(current, def.did, substs, variance);\n             }\n \n             ty::TyProjection(ref data) => {\n-                let trait_ref = &data.trait_ref;\n-                let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n-\n-                self.add_constraints_from_substs(current,\n-                                                 trait_ref.def_id,\n-                                                 &trait_generics.types,\n-                                                 &trait_generics.regions,\n-                                                 trait_ref.substs,\n-                                                 variance);\n+                self.add_constraints_from_trait_ref(current, data.trait_ref, variance);\n+            }\n+\n+            ty::TyAnon(_, substs) => {\n+                self.add_constraints_from_invariant_substs(current, substs, variance);\n             }\n \n             ty::TyDynamic(ref data, r) => {\n@@ -447,26 +347,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyParam(ref data) => {\n-                assert_eq!(current.generics.parent, None);\n-                let mut i = data.idx as usize;\n-                if !current.generics.has_self || i > 0 {\n-                    i -= current.generics.regions.len();\n-                }\n-                let def_id = current.generics.types[i].def_id;\n-                let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                match self.terms_cx.inferred_map.get(&node_id) {\n-                    Some(&index) => {\n-                        self.add_constraint(index, variance);\n-                    }\n-                    None => {\n-                        // We do not infer variance for type parameters\n-                        // declared on methods. They will not be present\n-                        // in the inferred_map.\n-                    }\n-                }\n+                self.add_constraint(current, data.idx, variance);\n             }\n \n-            ty::TyFnDef(.., sig) |\n             ty::TyFnPtr(sig) => {\n                 self.add_constraints_from_sig(current, sig, variance);\n             }\n@@ -489,30 +372,52 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn add_constraints_from_substs(&mut self,\n                                    current: &CurrentItem,\n                                    def_id: DefId,\n-                                   type_param_defs: &[ty::TypeParameterDef],\n-                                   region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n                def_id,\n                substs,\n                variance);\n \n-        for p in type_param_defs {\n-            let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n+        // We don't record `inferred_starts` entries for empty generics.\n+        if substs.is_empty() {\n+            return;\n+        }\n+\n+        // Add a corresponding relation into the dependencies to\n+        // indicate that the variance for `current` relies on `def_id`.\n+        if self.tcx().dep_graph.is_fully_enabled() {\n+            self.dependencies.add(current.def_id, def_id);\n+        }\n+\n+        let (local, remote) = if let Some(id) = self.tcx().hir.as_local_node_id(def_id) {\n+            (Some(self.terms_cx.inferred_starts[&id]), None)\n+        } else {\n+            (None, Some(self.tcx().variances_of(def_id)))\n+        };\n+\n+        for (i, k) in substs.iter().enumerate() {\n+            let variance_decl = if let Some(InferredIndex(start)) = local {\n+                // Parameter on an item defined within current crate:\n+                // variance not yet inferred, so return a symbolic\n+                // variance.\n+                self.terms_cx.inferred_terms[start + i]\n+            } else {\n+                // Parameter on an item defined within another crate:\n+                // variance already inferred, just look it up.\n+                self.constant_term(remote.as_ref().unwrap()[i])\n+            };\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            self.add_constraints_from_ty(current, substs_ty, variance_i);\n-        }\n-\n-        for p in region_param_defs {\n-            let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n-            let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = substs.region_for_def(p);\n-            self.add_constraints_from_region(current, substs_r, variance_i);\n+            if let Some(ty) = k.as_type() {\n+                self.add_constraints_from_ty(current, ty, variance_i);\n+            } else if let Some(r) = k.as_region() {\n+                self.add_constraints_from_region(current, r, variance_i);\n+            } else {\n+                bug!();\n+            }\n         }\n     }\n \n@@ -537,21 +442,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                assert_eq!(current.generics.parent, None);\n-                let i = data.index as usize - current.generics.has_self as usize;\n-                let def_id = current.generics.regions[i].def_id;\n-                let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                if self.is_to_be_inferred(node_id) {\n-                    let &index = self.opt_inferred_index(node_id).unwrap();\n-                    self.add_constraint(index, variance);\n-                }\n+                self.add_constraint(current, data.index, variance);\n             }\n \n             ty::ReStatic => {}\n \n             ty::ReLateBound(..) => {\n-                // We do not infer variance for region parameters on\n-                // methods or in fn types.\n+                // Late-bound regions do not get substituted the same\n+                // way early-bound regions do, so we skip them here.\n             }\n \n             ty::ReFree(..) |"}, {"sha": "7a9f35545e2f383defa9c09444aac638c0793c63", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -54,45 +54,63 @@ fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n                             -> Rc<Vec<ty::Variance>> {\n-    let item_id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n-    let item = tcx.hir.expect_item(item_id);\n-    match item.node {\n-        hir::ItemTrait(..) => {\n-            // Traits are always invariant.\n-            let generics = tcx.generics_of(item_def_id);\n-            assert!(generics.parent.is_none());\n-            Rc::new(vec![ty::Variance::Invariant; generics.count()])\n-        }\n+    let id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n+    let unsupported = || {\n+        // Variance not relevant.\n+        span_bug!(tcx.hir.span(id), \"asked to compute variance for wrong kind of item\")\n+    };\n+    match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) |\n+            hir::ItemFn(..) => {}\n \n-        hir::ItemEnum(..) |\n-        hir::ItemStruct(..) |\n-        hir::ItemUnion(..) => {\n-            // Everything else must be inferred.\n+            _ => unsupported()\n+        },\n \n-            // Lacking red/green, we read the variances for all items here\n-            // but ignore the dependencies, then re-synthesize the ones we need.\n-            let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n-            let dep_node = item_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-            tcx.dep_graph.read(dep_node);\n-            for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n-                if dep_def_id.is_local() {\n-                    let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-                    tcx.dep_graph.read(dep_node);\n-                } else {\n-                    let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVariances);\n-                    tcx.dep_graph.read(dep_node);\n-                }\n-            }\n-\n-            crate_map.variances.get(&item_def_id)\n-                               .unwrap_or(&crate_map.empty_variance)\n-                               .clone()\n-        }\n+        hir::map::NodeTraitItem(item) => match item.node {\n+            hir::TraitItemKind::Method(..) => {}\n+\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeImplItem(item) => match item.node {\n+            hir::ImplItemKind::Method(..) => {}\n+\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeForeignItem(item) => match item.node {\n+            hir::ForeignItemFn(..) => {}\n \n-        _ => {\n-            // Variance not relevant.\n-            span_bug!(item.span, \"asked to compute variance for wrong kind of item\")\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeVariant(_) | hir::map::NodeStructCtor(_) => {}\n+\n+        _ => unsupported()\n+    }\n+\n+    // Everything else must be inferred.\n+\n+    // Lacking red/green, we read the variances for all items here\n+    // but ignore the dependencies, then re-synthesize the ones we need.\n+    let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n+    let dep_node = item_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+    tcx.dep_graph.read(dep_node);\n+    for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n+        if dep_def_id.is_local() {\n+            let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+            tcx.dep_graph.read(dep_node);\n+        } else {\n+            let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVariances);\n+            tcx.dep_graph.read(dep_node);\n         }\n     }\n+\n+    crate_map.variances.get(&item_def_id)\n+                       .unwrap_or(&crate_map.empty_variance)\n+                       .clone()\n }\n "}, {"sha": "495eb95419a90876581ef3165507f97373e7c417", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -36,15 +36,18 @@ struct SolveContext<'a, 'tcx: 'a> {\n pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n     let ConstraintContext { terms_cx, dependencies, constraints, .. } = constraints_cx;\n \n-    let solutions = terms_cx.inferred_infos\n-        .iter()\n-        .map(|ii| ii.initial_variance)\n-        .collect();\n+    let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];\n+    for &(id, ref variances) in &terms_cx.lang_items {\n+        let InferredIndex(start) = terms_cx.inferred_starts[&id];\n+        for (i, &variance) in variances.iter().enumerate() {\n+            solutions[start + i] = variance;\n+        }\n+    }\n \n     let mut solutions_cx = SolveContext {\n-        terms_cx: terms_cx,\n-        constraints: constraints,\n-        solutions: solutions,\n+        terms_cx,\n+        constraints,\n+        solutions,\n     };\n     solutions_cx.solve();\n     let variances = solutions_cx.create_map();\n@@ -71,12 +74,9 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 let old_value = self.solutions[inferred];\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n-                    debug!(\"Updating inferred {} (node {}) \\\n+                    debug!(\"Updating inferred {} \\\n                             from {:?} to {:?} due to {:?}\",\n                            inferred,\n-                           self.terms_cx\n-                                   .inferred_infos[inferred]\n-                               .param_id,\n                            old_value,\n                            new_value,\n                            term);\n@@ -89,49 +89,28 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n     }\n \n     fn create_map(&self) -> FxHashMap<DefId, Rc<Vec<ty::Variance>>> {\n-        // Collect all the variances for a particular item and stick\n-        // them into the variance map. We rely on the fact that we\n-        // generate all the inferreds for a particular item\n-        // consecutively (that is, we collect solutions for an item\n-        // until we see a new item id, and we assume (1) the solutions\n-        // are in the same order as the type parameters were declared\n-        // and (2) all solutions or a given item appear before a new\n-        // item id).\n-\n         let tcx = self.terms_cx.tcx;\n \n-        let mut map = FxHashMap();\n-\n         let solutions = &self.solutions;\n-        let inferred_infos = &self.terms_cx.inferred_infos;\n-        let mut index = 0;\n-        let num_inferred = self.terms_cx.num_inferred();\n-        while index < num_inferred {\n-            let item_id = inferred_infos[index].item_id;\n-\n-            let mut item_variances = vec![];\n-\n-            while index < num_inferred && inferred_infos[index].item_id == item_id {\n-                let info = &inferred_infos[index];\n-                let variance = solutions[index];\n-                debug!(\"Index {} Info {} Variance {:?}\",\n-                       index,\n-                       info.index,\n-                       variance);\n-\n-                assert_eq!(item_variances.len(), info.index);\n-                item_variances.push(variance);\n-                index += 1;\n-            }\n+        self.terms_cx.inferred_starts.iter().map(|(&id, &InferredIndex(start))| {\n+            let def_id = tcx.hir.local_def_id(id);\n+            let generics = tcx.generics_of(def_id);\n \n-            debug!(\"item_id={} item_variances={:?}\", item_id, item_variances);\n+            let mut variances = solutions[start..start+generics.count()].to_vec();\n \n-            let item_def_id = tcx.hir.local_def_id(item_id);\n+            debug!(\"id={} variances={:?}\", id, variances);\n \n-            map.insert(item_def_id, Rc::new(item_variances));\n-        }\n+            // Functions can have unused type parameters: make those invariant.\n+            if let ty::TyFnDef(..) = tcx.type_of(def_id).sty {\n+                for variance in &mut variances {\n+                    if *variance == ty::Bivariant {\n+                        *variance = ty::Invariant;\n+                    }\n+                }\n+            }\n \n-        map\n+            (def_id, Rc::new(variances))\n+        }).collect()\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "38457146a9714deebfa958aafa42959bed515e39", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 61, "deletions": 99, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -22,7 +22,6 @@\n use arena::TypedArena;\n use rustc::ty::{self, TyCtxt};\n use std::fmt;\n-use std::rc::Rc;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -63,31 +62,17 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n-    pub empty_variances: Rc<Vec<ty::Variance>>,\n-\n     // For marker types, UnsafeCell, and other lang items where\n     // variance is hardcoded, records the item-id and the hardcoded\n     // variance.\n     pub lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n \n-    // Maps from the node id of a type/generic parameter to the\n-    // corresponding inferred index.\n-    pub inferred_map: NodeMap<InferredIndex>,\n-\n-    // Maps from an InferredIndex to the info for that variable.\n-    pub inferred_infos: Vec<InferredInfo<'a>>,\n-}\n-\n-pub struct InferredInfo<'a> {\n-    pub item_id: ast::NodeId,\n-    pub index: usize,\n-    pub param_id: ast::NodeId,\n-    pub term: VarianceTermPtr<'a>,\n+    // Maps from the node id of an item to the first inferred index\n+    // used for its type & region parameters.\n+    pub inferred_starts: NodeMap<InferredIndex>,\n \n-    // Initial value to use for this parameter when inferring\n-    // variance. For most parameters, this is Bivariant. But for lang\n-    // items and input type parameters on traits, it is different.\n-    pub initial_variance: ty::Variance,\n+    // Maps from an InferredIndex to the term for that variable.\n+    pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n }\n \n pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -96,14 +81,10 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n         arena: arena,\n-        inferred_map: NodeMap(),\n-        inferred_infos: Vec::new(),\n+        inferred_starts: NodeMap(),\n+        inferred_terms: vec![],\n \n         lang_items: lang_items(tcx),\n-\n-        // cache and share the variance struct used for items with\n-        // no type/region parameters\n-        empty_variances: Rc::new(vec![]),\n     };\n \n     // See README.md for a discussion on dep-graph management.\n@@ -135,67 +116,28 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n }\n \n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n-    fn add_inferreds_for_item(&mut self,\n-                              item_id: ast::NodeId,\n-                              generics: &hir::Generics) {\n-        //! Add \"inferreds\" for the generic parameters declared on this\n-        //! item. This has a lot of annoying parameters because we are\n-        //! trying to drive this from the AST, rather than the\n-        //! ty::Generics, so that we can get span info -- but this\n-        //! means we must accommodate syntactic distinctions.\n-        //!\n+    fn add_inferreds_for_item(&mut self, id: ast::NodeId) {\n+        let tcx = self.tcx;\n+        let def_id = tcx.hir.local_def_id(id);\n+        let count = tcx.generics_of(def_id).count();\n \n-        // NB: In the code below for writing the results back into the\n-        // `CrateVariancesMap`, we rely on the fact that all inferreds\n-        // for a particular item are assigned continuous indices.\n-\n-        for (p, i) in generics.lifetimes.iter().zip(0..) {\n-            let id = p.lifetime.id;\n-            self.add_inferred(item_id, i, id);\n-        }\n-\n-        for (p, i) in generics.ty_params.iter().zip(generics.lifetimes.len()..) {\n-            self.add_inferred(item_id, i, p.id);\n+        if count == 0 {\n+            return;\n         }\n-    }\n \n-    fn add_inferred(&mut self, item_id: ast::NodeId, index: usize, param_id: ast::NodeId) {\n-        let inf_index = InferredIndex(self.inferred_infos.len());\n-        let term = self.arena.alloc(InferredTerm(inf_index));\n-        let initial_variance = self.pick_initial_variance(item_id, index);\n-        self.inferred_infos.push(InferredInfo {\n-            item_id: item_id,\n-            index: index,\n-            param_id: param_id,\n-            term: term,\n-            initial_variance: initial_variance,\n-        });\n-        let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n+        // Record the start of this item's inferreds.\n+        let start = self.inferred_terms.len();\n+        let newly_added = self.inferred_starts.insert(id, InferredIndex(start)).is_none();\n         assert!(newly_added);\n \n-        debug!(\"add_inferred(item_path={}, \\\n-                item_id={}, \\\n-                index={}, \\\n-                param_id={}, \\\n-                inf_index={:?}, \\\n-                initial_variance={:?})\",\n-               self.tcx.item_path_str(self.tcx.hir.local_def_id(item_id)),\n-               item_id,\n-               index,\n-               param_id,\n-               inf_index,\n-               initial_variance);\n-    }\n-\n-    fn pick_initial_variance(&self, item_id: ast::NodeId, index: usize) -> ty::Variance {\n-        match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n-            Some(&(_, ref variances)) => variances[index],\n-            None => ty::Bivariant,\n-        }\n-    }\n+        // NB: In the code below for writing the results back into the\n+        // `CrateVariancesMap`, we rely on the fact that all inferreds\n+        // for a particular item are assigned continuous indices.\n \n-    pub fn num_inferred(&self) -> usize {\n-        self.inferred_infos.len()\n+        let arena = self.arena;\n+        self.inferred_terms.extend((start..start+count).map(|i| {\n+            &*arena.alloc(InferredTerm(InferredIndex(i)))\n+        }));\n     }\n }\n \n@@ -205,30 +147,50 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                self.tcx.hir.node_to_string(item.id));\n \n         match item.node {\n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) => {\n-                self.add_inferreds_for_item(item.id, generics);\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.add_inferreds_for_item(item.id);\n+\n+                if let hir::VariantData::Tuple(..) = *struct_def {\n+                    self.add_inferreds_for_item(struct_def.id());\n+                }\n+            }\n+\n+            hir::ItemEnum(ref enum_def, _) => {\n+                self.add_inferreds_for_item(item.id);\n+\n+                for variant in &enum_def.variants {\n+                    if let hir::VariantData::Tuple(..) = variant.node.data {\n+                        self.add_inferreds_for_item(variant.node.data.id());\n+                    }\n+                }\n+            }\n+\n+            hir::ItemFn(..) => {\n+                self.add_inferreds_for_item(item.id);\n             }\n \n-            hir::ItemTrait(..) |\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) |\n-            hir::ItemDefaultImpl(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemTy(..) => {}\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if let hir::ForeignItemFn(..) = foreign_item.node {\n+                        self.add_inferreds_for_item(foreign_item.id);\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(..) = trait_item.node {\n+            self.add_inferreds_for_item(trait_item.id);\n+        }\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(..) = impl_item.node {\n+            self.add_inferreds_for_item(impl_item.id);\n+        }\n     }\n }"}, {"sha": "fa5a999adf1960c00dfb57d52365d19397d25a79", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -149,7 +149,7 @@ pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n }\n \n fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n-    let sig = cx.tcx.type_of(did).fn_sig();\n+    let sig = cx.tcx.fn_sig(did);\n \n     let constness = if cx.tcx.is_const_fn(did) {\n         hir::Constness::Const"}, {"sha": "478e2fc5085d19fe8dba0e3fcc7ea6ac6d30e777", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1367,7 +1367,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             ty::AssociatedKind::Method => {\n                 let generics = (cx.tcx.generics_of(self.def_id),\n                                 &cx.tcx.predicates_of(self.def_id)).clean(cx);\n-                let sig = cx.tcx.type_of(self.def_id).fn_sig();\n+                let sig = cx.tcx.fn_sig(self.def_id);\n                 let mut decl = (self.def_id, sig).clean(cx);\n \n                 if self.method_has_self_argument {\n@@ -1842,17 +1842,21 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 mutability: mt.mutbl.clean(cx),\n                 type_: box mt.ty.clean(cx),\n             },\n-            ty::TyFnDef(.., sig) |\n-            ty::TyFnPtr(sig) => BareFunction(box BareFunctionDecl {\n-                unsafety: sig.unsafety(),\n-                generics: Generics {\n-                    lifetimes: Vec::new(),\n-                    type_params: Vec::new(),\n-                    where_predicates: Vec::new()\n-                },\n-                decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n-                abi: sig.abi(),\n-            }),\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) => {\n+                let ty = cx.tcx.lift(self).unwrap();\n+                let sig = ty.fn_sig(cx.tcx);\n+                BareFunction(box BareFunctionDecl {\n+                    unsafety: sig.unsafety(),\n+                    generics: Generics {\n+                        lifetimes: Vec::new(),\n+                        type_params: Vec::new(),\n+                        where_predicates: Vec::new()\n+                    },\n+                    decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n+                    abi: sig.abi(),\n+                })\n+            }\n             ty::TyAdt(def, substs) => {\n                 let did = def.did;\n                 let kind = match def.adt_kind() {"}, {"sha": "766e76137ca424dc5c74683eb6ab9b8970b76350", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1019,7 +1019,11 @@ impl fmt::Display for clean::Import {\n                 }\n             }\n             clean::Import::Glob(ref src) => {\n-                write!(f, \"use {}::*;\", *src)\n+                if src.path.segments.is_empty() {\n+                    write!(f, \"use *;\")\n+                } else {\n+                    write!(f, \"use {}::*;\", *src)\n+                }\n             }\n         }\n     }"}, {"sha": "89a40b0db9662f76bf34b23368fd4f6b72bba0af", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -300,7 +300,7 @@ impl<'a> Classifier<'a> {\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n \n                     \"$crate\" => Class::KeyWord,\n-                    _ if tas.tok.is_any_keyword() => Class::KeyWord,\n+                    _ if tas.tok.is_reserved_ident() => Class::KeyWord,\n \n                     _ => {\n                         if self.in_macro_nonterminal {"}, {"sha": "03da451fd9a0a2477fe9226b04f53a23ff08ed2b", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -769,7 +769,7 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n                                block_info.should_panic, block_info.no_run,\n                                block_info.ignore, block_info.test_harness,\n                                block_info.compile_fail, block_info.error_codes,\n-                               line, filename);\n+                               line, filename, block_info.allow_fail);\n             } else {\n                 tests.add_old_test(text, filename);\n             }\n@@ -859,7 +859,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n                                block_info.should_panic, block_info.no_run,\n                                block_info.ignore, block_info.test_harness,\n                                block_info.compile_fail, block_info.error_codes,\n-                               line, filename);\n+                               line, filename, block_info.allow_fail);\n                 prev_offset = offset;\n             }\n             Event::Start(Tag::Header(level)) => {\n@@ -889,6 +889,7 @@ struct LangString {\n     test_harness: bool,\n     compile_fail: bool,\n     error_codes: Vec<String>,\n+    allow_fail: bool,\n }\n \n impl LangString {\n@@ -902,6 +903,7 @@ impl LangString {\n             test_harness: false,\n             compile_fail: false,\n             error_codes: Vec::new(),\n+            allow_fail: false,\n         }\n     }\n \n@@ -930,6 +932,7 @@ impl LangString {\n                 }\n                 \"no_run\" => { data.no_run = true; seen_rust_tags = !seen_other_tags; }\n                 \"ignore\" => { data.ignore = true; seen_rust_tags = !seen_other_tags; }\n+                \"allow_fail\" => { data.allow_fail = true; seen_rust_tags = !seen_other_tags; }\n                 \"rust\" => { data.rust = true; seen_rust_tags = true; }\n                 \"test_harness\" => {\n                     data.test_harness = true;\n@@ -1118,7 +1121,7 @@ mod tests {\n     fn test_lang_string_parse() {\n         fn t(s: &str,\n             should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n-            compile_fail: bool, error_codes: Vec<String>) {\n+            compile_fail: bool, allow_fail: bool, error_codes: Vec<String>) {\n             assert_eq!(LangString::parse(s), LangString {\n                 should_panic: should_panic,\n                 no_run: no_run,\n@@ -1128,25 +1131,31 @@ mod tests {\n                 compile_fail: compile_fail,\n                 error_codes: error_codes,\n                 original: s.to_owned(),\n+                allow_fail: allow_fail,\n             })\n         }\n \n+        fn v() -> Vec<String> {\n+            Vec::new()\n+        }\n+\n         // marker                | should_panic| no_run| ignore| rust | test_harness| compile_fail\n-        //                       | error_codes\n-        t(\"\",                      false,        false,  false,  true,  false, false, Vec::new());\n-        t(\"rust\",                  false,        false,  false,  true,  false, false, Vec::new());\n-        t(\"sh\",                    false,        false,  false,  false, false, false, Vec::new());\n-        t(\"ignore\",                false,        false,  true,   true,  false, false, Vec::new());\n-        t(\"should_panic\",          true,         false,  false,  true,  false, false, Vec::new());\n-        t(\"no_run\",                false,        true,   false,  true,  false, false, Vec::new());\n-        t(\"test_harness\",          false,        false,  false,  true,  true,  false, Vec::new());\n-        t(\"compile_fail\",          false,        true,   false,  true,  false, true,  Vec::new());\n-        t(\"{.no_run .example}\",    false,        true,   false,  true,  false, false, Vec::new());\n-        t(\"{.sh .should_panic}\",   true,         false,  false,  false, false, false, Vec::new());\n-        t(\"{.example .rust}\",      false,        false,  false,  true,  false, false, Vec::new());\n-        t(\"{.test_harness .rust}\", false,        false,  false,  true,  true,  false, Vec::new());\n-        t(\"text, no_run\",          false,        true,   false,  false, false, false, Vec::new());\n-        t(\"text,no_run\",           false,        true,   false,  false, false, false, Vec::new());\n+        //                       | allow_fail | error_codes\n+        t(\"\",                      false,        false,  false,  true,  false, false, false, v());\n+        t(\"rust\",                  false,        false,  false,  true,  false, false, false, v());\n+        t(\"sh\",                    false,        false,  false,  false, false, false, false, v());\n+        t(\"ignore\",                false,        false,  true,   true,  false, false, false, v());\n+        t(\"should_panic\",          true,         false,  false,  true,  false, false, false, v());\n+        t(\"no_run\",                false,        true,   false,  true,  false, false, false, v());\n+        t(\"test_harness\",          false,        false,  false,  true,  true,  false, false, v());\n+        t(\"compile_fail\",          false,        true,   false,  true,  false, true,  false, v());\n+        t(\"allow_fail\",            false,        false,  false,  true,  false, false, true,  v());\n+        t(\"{.no_run .example}\",    false,        true,   false,  true,  false, false, false, v());\n+        t(\"{.sh .should_panic}\",   true,         false,  false,  false, false, false, false, v());\n+        t(\"{.example .rust}\",      false,        false,  false,  true,  false, false, false, v());\n+        t(\"{.test_harness .rust}\", false,        false,  false,  true,  true,  false, false, v());\n+        t(\"text, no_run\",          false,        true,   false,  false, false, false, false, v());\n+        t(\"text,no_run\",           false,        true,   false,  false, false, false, false, v());\n     }\n \n     #[test]"}, {"sha": "f012fd974b574267d28841be6f870741872dca58", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -25,7 +25,7 @@ use rustc_lint;\n use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::intravisit;\n-use rustc::session::{self, config};\n+use rustc::session::{self, CompileIncomplete, config};\n use rustc::session::config::{OutputType, OutputTypes, Externs};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n use rustc_back::dynamic_lib::DynamicLibrary;\n@@ -253,35 +253,25 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         driver::compile_input(&sess, &cstore, &input, &out, &None, None, &control)\n     }));\n \n-    match res {\n-        Ok(r) => {\n-            match r {\n-                Err(count) => {\n-                    if count > 0 && !compile_fail {\n-                        sess.fatal(\"aborting due to previous error(s)\")\n-                    } else if count == 0 && compile_fail {\n-                        panic!(\"test compiled while it wasn't supposed to\")\n-                    }\n-                    if count > 0 && error_codes.len() > 0 {\n-                        let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n-                        error_codes.retain(|err| !out.contains(err));\n-                    }\n-                }\n-                Ok(()) if compile_fail => {\n-                    panic!(\"test compiled while it wasn't supposed to\")\n-                }\n-                _ => {}\n-            }\n+    let compile_result = match res {\n+        Ok(Ok(())) | Ok(Err(CompileIncomplete::Stopped)) => Ok(()),\n+        Err(_) | Ok(Err(CompileIncomplete::Errored(_))) => Err(())\n+    };\n+\n+    match (compile_result, compile_fail) {\n+        (Ok(()), true) => {\n+            panic!(\"test compiled while it wasn't supposed to\")\n         }\n-        Err(_) => {\n-            if !compile_fail {\n-                panic!(\"couldn't compile the test\");\n-            }\n+        (Ok(()), false) => {}\n+        (Err(()), true) => {\n             if error_codes.len() > 0 {\n                 let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n                 error_codes.retain(|err| !out.contains(err));\n             }\n         }\n+        (Err(()), false) => {\n+            panic!(\"couldn't compile the test\")\n+        }\n     }\n \n     if error_codes.len() > 0 {\n@@ -467,7 +457,7 @@ impl Collector {\n     pub fn add_test(&mut self, test: String,\n                     should_panic: bool, no_run: bool, should_ignore: bool,\n                     as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n-                    line: usize, filename: String) {\n+                    line: usize, filename: String, allow_fail: bool) {\n         let name = self.generate_name(line, &filename);\n         // to be removed when hoedown is removed\n         if self.render_type == RenderType::Pulldown {\n@@ -499,6 +489,7 @@ impl Collector {\n                 ignore: should_ignore,\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n+                allow_fail: allow_fail,\n             },\n             testfn: testing::DynTestFn(box move |()| {\n                 let panic = io::set_panic(None);"}, {"sha": "f81adad3ebebf1747578e982ab3fedb8bc021429", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 81, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -949,63 +949,9 @@ mod arch {\n mod tests {\n     use super::*;\n \n-    use iter::repeat;\n-    use rand::{self, Rng};\n-    use ffi::{OsString, OsStr};\n+    use ffi::OsStr;\n     use path::{Path, PathBuf};\n \n-    fn make_rand_name() -> OsString {\n-        let mut rng = rand::thread_rng();\n-        let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n-                                     .collect::<String>());\n-        let n = OsString::from(n);\n-        assert!(var_os(&n).is_none());\n-        n\n-    }\n-\n-    fn eq(a: Option<OsString>, b: Option<&str>) {\n-        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::new).map(|s| &*s));\n-    }\n-\n-    #[test]\n-    fn test_set_var() {\n-        let n = make_rand_name();\n-        set_var(&n, \"VALUE\");\n-        eq(var_os(&n), Some(\"VALUE\"));\n-    }\n-\n-    #[test]\n-    fn test_remove_var() {\n-        let n = make_rand_name();\n-        set_var(&n, \"VALUE\");\n-        remove_var(&n);\n-        eq(var_os(&n), None);\n-    }\n-\n-    #[test]\n-    fn test_set_var_overwrite() {\n-        let n = make_rand_name();\n-        set_var(&n, \"1\");\n-        set_var(&n, \"2\");\n-        eq(var_os(&n), Some(\"2\"));\n-        set_var(&n, \"\");\n-        eq(var_os(&n), Some(\"\"));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn test_var_big() {\n-        let mut s = \"\".to_string();\n-        let mut i = 0;\n-        while i < 100 {\n-            s.push_str(\"aaaaaaaaaa\");\n-            i += 1;\n-        }\n-        let n = make_rand_name();\n-        set_var(&n, &s);\n-        eq(var_os(&n), Some(&s));\n-    }\n-\n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_self_exe_path() {\n@@ -1017,32 +963,6 @@ mod tests {\n         assert!(path.is_absolute());\n     }\n \n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn test_env_set_get_huge() {\n-        let n = make_rand_name();\n-        let s = repeat(\"x\").take(10000).collect::<String>();\n-        set_var(&n, &s);\n-        eq(var_os(&n), Some(&s));\n-        remove_var(&n);\n-        eq(var_os(&n), None);\n-    }\n-\n-    #[test]\n-    fn test_env_set_var() {\n-        let n = make_rand_name();\n-\n-        let mut e = vars_os();\n-        set_var(&n, \"VALUE\");\n-        assert!(!e.any(|(k, v)| {\n-            &*k == &*n && &*v == \"VALUE\"\n-        }));\n-\n-        assert!(vars_os().any(|(k, v)| {\n-            &*k == &*n && &*v == \"VALUE\"\n-        }));\n-    }\n-\n     #[test]\n     fn test() {\n         assert!((!Path::new(\"test-path\").is_absolute()));"}, {"sha": "a6eb17c8fa41bf6819bfe89af7c2bfca27659be1", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -363,39 +363,29 @@ impl f32 {\n     #[inline]\n     pub fn signum(self) -> f32 { num::Float::signum(self) }\n \n-    /// Returns `true` if `self`'s sign bit is positive, including\n-    /// `+0.0` and `INFINITY`.\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n     ///\n     /// ```\n-    /// use std::f32;\n-    ///\n-    /// let nan = f32::NAN;\n     /// let f = 7.0_f32;\n     /// let g = -7.0_f32;\n     ///\n     /// assert!(f.is_sign_positive());\n     /// assert!(!g.is_sign_positive());\n-    /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }\n \n-    /// Returns `true` if `self`'s sign is negative, including `-0.0`\n-    /// and `NEG_INFINITY`.\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n     ///\n     /// ```\n-    /// use std::f32;\n-    ///\n-    /// let nan = f32::NAN;\n     /// let f = 7.0f32;\n     /// let g = -7.0f32;\n     ///\n     /// assert!(!f.is_sign_negative());\n     /// assert!(g.is_sign_negative());\n-    /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1141,13 +1131,16 @@ impl f32 {\n     #[inline]\n     pub fn from_bits(mut v: u32) -> Self {\n         const EXP_MASK: u32   = 0x7F800000;\n-        const QNAN_MASK: u32  = 0x00400000;\n         const FRACT_MASK: u32 = 0x007FFFFF;\n         if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n-            // If we have a NaN value, we\n-            // convert signaling NaN values to quiet NaN\n-            // by setting the the highest bit of the fraction\n-            v |= QNAN_MASK;\n+            // While IEEE 754-2008 specifies encodings for quiet NaNs\n+            // and signaling ones, certain MIPS and PA-RISC\n+            // CPUs treat signaling NaNs differently.\n+            // Therefore to be safe, we pass a known quiet NaN\n+            // if v is any kind of NaN.\n+            // The check above only assumes IEEE 754-1985 to be\n+            // valid.\n+            v = unsafe { ::mem::transmute(NAN) };\n         }\n         unsafe { ::mem::transmute(v) }\n     }\n@@ -1184,7 +1177,7 @@ mod tests {\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n         assert!(!nan.is_normal());\n-        assert!(!nan.is_sign_positive());\n+        assert!(nan.is_sign_positive());\n         assert!(!nan.is_sign_negative());\n         assert_eq!(Fp::Nan, nan.classify());\n     }\n@@ -1428,7 +1421,8 @@ mod tests {\n         assert!(!(-1f32).is_sign_positive());\n         assert!(!NEG_INFINITY.is_sign_positive());\n         assert!(!(1f32/NEG_INFINITY).is_sign_positive());\n-        assert!(!NAN.is_sign_positive());\n+        assert!(NAN.is_sign_positive());\n+        assert!(!(-NAN).is_sign_positive());\n     }\n \n     #[test]\n@@ -1441,6 +1435,7 @@ mod tests {\n         assert!(NEG_INFINITY.is_sign_negative());\n         assert!((1f32/NEG_INFINITY).is_sign_negative());\n         assert!(!NAN.is_sign_negative());\n+        assert!((-NAN).is_sign_negative());\n     }\n \n     #[test]\n@@ -1740,8 +1735,15 @@ mod tests {\n     }\n     #[test]\n     fn test_snan_masking() {\n+        // NOTE: this test assumes that our current platform\n+        // implements IEEE 754-2008 that specifies the difference\n+        // in encoding of quiet and signaling NaNs.\n+        // If you are porting Rust to a platform that does not\n+        // implement IEEE 754-2008 (but e.g. IEEE 754-1985, which\n+        // only says that \"Signaling NaNs shall be reserved operands\"\n+        // but doesn't specify the actual setup), feel free to\n+        // cfg out this test.\n         let snan: u32 = 0x7F801337;\n-        const PAYLOAD_MASK: u32 = 0x003FFFFF;\n         const QNAN_MASK: u32  = 0x00400000;\n         let nan_masked_fl = f32::from_bits(snan);\n         let nan_masked = nan_masked_fl.to_bits();\n@@ -1750,7 +1752,5 @@ mod tests {\n         // Ensure that we have a quiet NaN\n         assert_ne!(nan_masked & QNAN_MASK, 0);\n         assert!(nan_masked_fl.is_nan());\n-        // Ensure the payload wasn't touched during conversion\n-        assert_eq!(nan_masked & PAYLOAD_MASK, snan & PAYLOAD_MASK);\n     }\n }"}, {"sha": "4d8d8b4ebe6aa001d725972c3148a3c9cc62e193", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -301,21 +301,15 @@ impl f64 {\n     #[inline]\n     pub fn signum(self) -> f64 { num::Float::signum(self) }\n \n-    /// Returns `true` if `self`'s sign bit is positive, including\n-    /// `+0.0` and `INFINITY`.\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n     ///\n     /// ```\n-    /// use std::f64;\n-    ///\n-    /// let nan: f64 = f64::NAN;\n-    ///\n     /// let f = 7.0_f64;\n     /// let g = -7.0_f64;\n     ///\n     /// assert!(f.is_sign_positive());\n     /// assert!(!g.is_sign_positive());\n-    /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -326,21 +320,15 @@ impl f64 {\n     #[inline]\n     pub fn is_positive(self) -> bool { num::Float::is_sign_positive(self) }\n \n-    /// Returns `true` if `self`'s sign is negative, including `-0.0`\n-    /// and `NEG_INFINITY`.\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n     ///\n     /// ```\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    ///\n     /// let f = 7.0_f64;\n     /// let g = -7.0_f64;\n     ///\n     /// assert!(!f.is_sign_negative());\n     /// assert!(g.is_sign_negative());\n-    /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1058,13 +1046,16 @@ impl f64 {\n     #[inline]\n     pub fn from_bits(mut v: u64) -> Self {\n         const EXP_MASK: u64   = 0x7FF0000000000000;\n-        const QNAN_MASK: u64  = 0x0001000000000000;\n         const FRACT_MASK: u64 = 0x000FFFFFFFFFFFFF;\n         if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n-            // If we have a NaN value, we\n-            // convert signaling NaN values to quiet NaN\n-            // by setting the the highest bit of the fraction\n-            v |= QNAN_MASK;\n+            // While IEEE 754-2008 specifies encodings for quiet NaNs\n+            // and signaling ones, certain MIPS and PA-RISC\n+            // CPUs treat signaling NaNs differently.\n+            // Therefore to be safe, we pass a known quiet NaN\n+            // if v is any kind of NaN.\n+            // The check above only assumes IEEE 754-1985 to be\n+            // valid.\n+            v = unsafe { ::mem::transmute(NAN) };\n         }\n         unsafe { ::mem::transmute(v) }\n     }\n@@ -1101,7 +1092,7 @@ mod tests {\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n         assert!(!nan.is_normal());\n-        assert!(!nan.is_sign_positive());\n+        assert!(nan.is_sign_positive());\n         assert!(!nan.is_sign_negative());\n         assert_eq!(Fp::Nan, nan.classify());\n     }\n@@ -1347,7 +1338,8 @@ mod tests {\n         assert!(!(-1f64).is_sign_positive());\n         assert!(!NEG_INFINITY.is_sign_positive());\n         assert!(!(1f64/NEG_INFINITY).is_sign_positive());\n-        assert!(!NAN.is_sign_positive());\n+        assert!(NAN.is_sign_positive());\n+        assert!(!(-NAN).is_sign_positive());\n     }\n \n     #[test]\n@@ -1360,6 +1352,7 @@ mod tests {\n         assert!(NEG_INFINITY.is_sign_negative());\n         assert!((1f64/NEG_INFINITY).is_sign_negative());\n         assert!(!NAN.is_sign_negative());\n+        assert!((-NAN).is_sign_negative());\n     }\n \n     #[test]"}, {"sha": "5f0b11a616eb0f02d236109a00bec23538ee13dc", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -585,11 +585,11 @@ impl From<Box<CStr>> for CString {\n     }\n }\n \n-#[stable(feature = \"box_from_c_string\", since = \"1.18.0\")]\n-impl Into<Box<CStr>> for CString {\n+#[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\n+impl From<CString> for Box<CStr> {\n     #[inline]\n-    fn into(self) -> Box<CStr> {\n-        self.into_boxed_c_str()\n+    fn from(s: CString) -> Box<CStr> {\n+        s.into_boxed_c_str()\n     }\n }\n "}, {"sha": "02a13ed7a5a03d822675da1219dbc27ded40e0ef", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -29,7 +29,7 @@ use sys_common::{AsInner, IntoInner, FromInner};\n /// * On Windows, strings are often arbitrary sequences of non-zero 16-bit\n ///   values, interpreted as UTF-16 when it is valid to do so.\n ///\n-/// * In Rust, strings are always valid UTF-8, but may contain zeros.\n+/// * In Rust, strings are always valid UTF-8, which may contain zeros.\n ///\n /// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n /// and platform-native string values, and in particular allowing a Rust string\n@@ -230,8 +230,6 @@ impl OsString {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(osstring_shrink_to_fit)]\n-    ///\n     /// use std::ffi::OsString;\n     ///\n     /// let mut s = OsString::from(\"foo\");\n@@ -242,7 +240,7 @@ impl OsString {\n     /// s.shrink_to_fit();\n     /// assert_eq!(3, s.capacity());\n     /// ```\n-    #[unstable(feature = \"osstring_shrink_to_fit\", issue = \"40421\")]\n+    #[stable(feature = \"osstring_shrink_to_fit\", since = \"1.19.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.inner.shrink_to_fit()\n     }\n@@ -542,10 +540,10 @@ impl From<Box<OsStr>> for OsString {\n     }\n }\n \n-#[stable(feature = \"box_from_os_string\", since = \"1.18.0\")]\n-impl Into<Box<OsStr>> for OsString {\n-    fn into(self) -> Box<OsStr> {\n-        self.into_boxed_os_str()\n+#[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n+impl From<OsString> for Box<OsStr> {\n+    fn from(s: OsString) -> Box<OsStr> {\n+        s.into_boxed_os_str()\n     }\n }\n "}, {"sha": "88994b284c90dced81a4592873f405756d2c82d6", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -653,15 +653,29 @@ impl OpenOptions {\n     /// # Errors\n     ///\n     /// This function will return an error under a number of different\n-    /// circumstances, to include but not limited to:\n-    ///\n-    /// * Opening a file that does not exist without setting `create` or\n-    ///   `create_new`.\n-    /// * Attempting to open a file with access that the user lacks\n-    ///   permissions for\n-    /// * Filesystem-level errors (full disk, etc)\n-    /// * Invalid combinations of open options (truncate without write access,\n-    ///   no access mode set, etc)\n+    /// circumstances. Some of these error conditions are listed here, together\n+    /// with their [`ErrorKind`]. The mapping to [`ErrorKind`]s is not part of\n+    /// the compatiblity contract of the function, especially the `Other` kind\n+    /// might change to more specific kinds in the future.\n+    ///\n+    /// * [`NotFound`]: The specified file does not exist and neither `create`\n+    ///   or `create_new` is set.\n+    /// * [`NotFound`]: One of the directory components of the file path does\n+    ///   not exist.\n+    /// * [`PermissionDenied`]: The user lacks permission to get the specified\n+    ///   access rights for the file.\n+    /// * [`PermissionDenied`]: The user lacks permission to open one of the\n+    ///   directory components of the specified path.\n+    /// * [`AlreadyExists`]: `create_new` was specified and the file already\n+    ///   exists.\n+    /// * [`InvalidInput`]: Invalid combinations of open options (truncate\n+    ///   without write access, no access mode set, etc.).\n+    /// * [`Other`]: One of the directory components of the specified file path\n+    ///   was not, in fact, a directory.\n+    /// * [`Other`]: Filesystem-level errors: full disk, write permission\n+    ///   requested on a read-only file system, exceeded disk quota, too many\n+    ///   open files, too long filename, too many symbolic links in the\n+    ///   specified path (Unix-like systems only), etc.\n     ///\n     /// # Examples\n     ///\n@@ -670,6 +684,13 @@ impl OpenOptions {\n     ///\n     /// let file = OpenOptions::new().open(\"foo.txt\");\n     /// ```\n+    ///\n+    /// [`ErrorKind`]: ../io/enum.ErrorKind.html\n+    /// [`AlreadyExists`]: ../io/enum.ErrorKind.html#variant.AlreadyExists\n+    /// [`InvalidInput`]: ../io/enum.ErrorKind.html#variant.InvalidInput\n+    /// [`NotFound`]: ../io/enum.ErrorKind.html#variant.NotFound\n+    /// [`Other`]: ../io/enum.ErrorKind.html#variant.Other\n+    /// [`PermissionDenied`]: ../io/enum.ErrorKind.html#variant.PermissionDenied\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> {\n         self._open(path.as_ref())"}, {"sha": "71c76008244e6b784fa49fa8ac9b186b76f3f9c0", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1589,8 +1589,6 @@ impl<T, U> Chain<T, U> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(more_io_inner_methods)]\n-    ///\n     /// # use std::io;\n     /// use std::io::prelude::*;\n     /// use std::fs::File;\n@@ -1604,7 +1602,7 @@ impl<T, U> Chain<T, U> {\n     /// # Ok(())\n     /// # }\n     /// ```\n-    #[unstable(feature = \"more_io_inner_methods\", issue=\"41519\")]\n+    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n     pub fn into_inner(self) -> (T, U) {\n         (self.first, self.second)\n     }\n@@ -1614,8 +1612,6 @@ impl<T, U> Chain<T, U> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(more_io_inner_methods)]\n-    ///\n     /// # use std::io;\n     /// use std::io::prelude::*;\n     /// use std::fs::File;\n@@ -1629,7 +1625,7 @@ impl<T, U> Chain<T, U> {\n     /// # Ok(())\n     /// # }\n     /// ```\n-    #[unstable(feature = \"more_io_inner_methods\", issue=\"41519\")]\n+    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n     pub fn get_ref(&self) -> (&T, &U) {\n         (&self.first, &self.second)\n     }\n@@ -1643,8 +1639,6 @@ impl<T, U> Chain<T, U> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(more_io_inner_methods)]\n-    ///\n     /// # use std::io;\n     /// use std::io::prelude::*;\n     /// use std::fs::File;\n@@ -1658,7 +1652,7 @@ impl<T, U> Chain<T, U> {\n     /// # Ok(())\n     /// # }\n     /// ```\n-    #[unstable(feature = \"more_io_inner_methods\", issue=\"41519\")]\n+    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n     pub fn get_mut(&mut self) -> (&mut T, &mut U) {\n         (&mut self.first, &mut self.second)\n     }\n@@ -1791,8 +1785,6 @@ impl<T> Take<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(more_io_inner_methods)]\n-    ///\n     /// use std::io;\n     /// use std::io::prelude::*;\n     /// use std::fs::File;\n@@ -1808,7 +1800,7 @@ impl<T> Take<T> {\n     /// # Ok(())\n     /// # }\n     /// ```\n-    #[unstable(feature = \"more_io_inner_methods\", issue=\"41519\")]\n+    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n     pub fn get_ref(&self) -> &T {\n         &self.inner\n     }\n@@ -1822,8 +1814,6 @@ impl<T> Take<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(more_io_inner_methods)]\n-    ///\n     /// use std::io;\n     /// use std::io::prelude::*;\n     /// use std::fs::File;\n@@ -1839,7 +1829,7 @@ impl<T> Take<T> {\n     /// # Ok(())\n     /// # }\n     /// ```\n-    #[unstable(feature = \"more_io_inner_methods\", issue=\"41519\")]\n+    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n         &mut self.inner\n     }"}, {"sha": "6eb9faacf7fbe4f392ca2609291e520ec8865c7b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -41,10 +41,10 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n-        $crate::rt::begin_panic($msg, {\n+        $crate::rt::begin_panic_new($msg, {\n             // static requires less code at runtime, more constant data\n-            static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-            &_FILE_LINE\n+            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(), column!());\n+            &_FILE_LINE_COL\n         })\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n@@ -53,8 +53,8 @@ macro_rules! panic {\n             // used inside a dead function. Just `#[allow(dead_code)]` is\n             // insufficient, since the user may have\n             // `#[forbid(dead_code)]` and which cannot be overridden.\n-            static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-            &_FILE_LINE\n+            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(), column!());\n+            &_FILE_LINE_COL\n         })\n     });\n }"}, {"sha": "494376b831ed6c87076aa525a23030bc1130641b", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 73, "deletions": 11, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -262,6 +262,7 @@ impl<'a> PanicInfo<'a> {\n pub struct Location<'a> {\n     file: &'a str,\n     line: u32,\n+    col: u32,\n }\n \n impl<'a> Location<'a> {\n@@ -308,6 +309,29 @@ impl<'a> Location<'a> {\n     pub fn line(&self) -> u32 {\n         self.line\n     }\n+\n+    /// Returns the column from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// #![feature(panic_col)]\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occured at column {}\", location.column());\n+    ///     } else {\n+    ///         println!(\"panic occured but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[unstable(feature = \"panic_col\", reason = \"recently added\", issue = \"42939\")]\n+    pub fn column(&self) -> u32 {\n+        self.col\n+    }\n }\n \n fn default_hook(info: &PanicInfo) {\n@@ -329,6 +353,7 @@ fn default_hook(info: &PanicInfo) {\n \n     let file = info.location.file;\n     let line = info.location.line;\n+    let col = info.location.col;\n \n     let msg = match info.payload.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n@@ -342,8 +367,8 @@ fn default_hook(info: &PanicInfo) {\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n \n     let write = |err: &mut ::io::Write| {\n-        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}\",\n-                         name, msg, file, line);\n+        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}:{}\",\n+                         name, msg, file, line, col);\n \n         #[cfg(feature = \"backtrace\")]\n         {\n@@ -467,8 +492,9 @@ pub fn panicking() -> bool {\n #[unwind]\n pub extern fn rust_begin_panic(msg: fmt::Arguments,\n                                file: &'static str,\n-                               line: u32) -> ! {\n-    begin_panic_fmt(&msg, &(file, line))\n+                               line: u32,\n+                               col: u32) -> ! {\n+    begin_panic_fmt(&msg, &(file, line, col))\n }\n \n /// The entry point for panicking with a formatted message.\n@@ -482,7 +508,7 @@ pub extern fn rust_begin_panic(msg: fmt::Arguments,\n            issue = \"0\")]\n #[inline(never)] #[cold]\n pub fn begin_panic_fmt(msg: &fmt::Arguments,\n-                       file_line: &(&'static str, u32)) -> ! {\n+                       file_line_col: &(&'static str, u32, u32)) -> ! {\n     use fmt::Write;\n \n     // We do two allocations here, unfortunately. But (a) they're\n@@ -492,7 +518,39 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments,\n \n     let mut s = String::new();\n     let _ = s.write_fmt(*msg);\n-    begin_panic(s, file_line)\n+    begin_panic_new(s, file_line_col)\n+}\n+\n+// FIXME: In PR #42938, we have added the column as info passed to the panic\n+// handling code. For this, we want to break the ABI of begin_panic.\n+// This is not possible to do directly, as the stage0 compiler is hardcoded\n+// to emit a call to begin_panic in src/libsyntax/ext/build.rs, only\n+// with the file and line number being passed, but not the colum number.\n+// By changing the compiler source, we can only affect behaviour of higher\n+// stages. We need to perform the switch over two stage0 replacements, using\n+// a temporary function begin_panic_new while performing the switch:\n+// 0. Right now, we tell stage1 onward to emit a call to begin_panic_new.\n+// 1. In the first SNAP, stage0 calls begin_panic_new with the new ABI,\n+//    begin_panic stops being used. Now we can change begin_panic to\n+//    the new ABI, and start emitting calls to begin_panic in higher\n+//    stages again, this time with the new ABI.\n+// 2. After the second SNAP, stage0 calls begin_panic with the new ABI,\n+//    and we can remove the temporary begin_panic_new function.\n+\n+/// This is the entry point of panicking for panic!() and assert!().\n+#[unstable(feature = \"libstd_sys_internals\",\n+           reason = \"used by the panic! macro\",\n+           issue = \"0\")]\n+#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+pub fn begin_panic_new<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n+    // Note that this should be the only allocation performed in this code path.\n+    // Currently this means that panic!() on OOM will invoke this code path,\n+    // but then again we're not really ready for panic on OOM anyway. If\n+    // we do start doing this, then we should propagate this allocation to\n+    // be performed in the parent of this thread instead of the thread that's\n+    // panicking.\n+\n+    rust_panic_with_hook(Box::new(msg), file_line_col)\n }\n \n /// This is the entry point of panicking for panic!() and assert!().\n@@ -508,7 +566,10 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> !\n     // be performed in the parent of this thread instead of the thread that's\n     // panicking.\n \n-    rust_panic_with_hook(Box::new(msg), file_line)\n+    let (file, line) = *file_line;\n+    let file_line_col = (file, line, 0);\n+\n+    rust_panic_with_hook(Box::new(msg), &file_line_col)\n }\n \n /// Executes the primary logic for a panic, including checking for recursive\n@@ -520,8 +581,8 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> !\n #[inline(never)]\n #[cold]\n fn rust_panic_with_hook(msg: Box<Any + Send>,\n-                        file_line: &(&'static str, u32)) -> ! {\n-    let (file, line) = *file_line;\n+                        file_line_col: &(&'static str, u32, u32)) -> ! {\n+    let (file, line, col) = *file_line_col;\n \n     let panics = update_panic_count(1);\n \n@@ -540,8 +601,9 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n         let info = PanicInfo {\n             payload: &*msg,\n             location: Location {\n-                file: file,\n-                line: line,\n+                file,\n+                line,\n+                col,\n             },\n         };\n         HOOK_LOCK.read();"}, {"sha": "e7c7be981d25f64763e427c80a5adafb40761af0", "filename": "src/libstd/path.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -276,7 +276,7 @@ impl<'a> Prefix<'a> {\n /// ```\n /// use std::path;\n ///\n-/// assert!(path::is_separator('/'));\n+/// assert!(path::is_separator('/')); // '/' works for both Unix and Windows\n /// assert!(!path::is_separator('\u2764'));\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1348,10 +1348,10 @@ impl From<Box<Path>> for PathBuf {\n     }\n }\n \n-#[stable(feature = \"box_from_path_buf\", since = \"1.18.0\")]\n-impl Into<Box<Path>> for PathBuf {\n-    fn into(self) -> Box<Path> {\n-        self.into_boxed_path()\n+#[stable(feature = \"box_from_path_buf\", since = \"1.20.0\")]\n+impl From<PathBuf> for Box<Path> {\n+    fn from(p: PathBuf) -> Box<Path> {\n+        p.into_boxed_path()\n     }\n }\n \n@@ -1499,9 +1499,9 @@ impl AsRef<OsStr> for PathBuf {\n /// A slice of a path (akin to [`str`]).\n ///\n /// This type supports a number of operations for inspecting a path, including\n-/// breaking the path into its components (separated by `/` or `\\`, depending on\n-/// the platform), extracting the file name, determining whether the path is\n-/// absolute, and so on.\n+/// breaking the path into its components (separated by `/` on Unix and by either\n+/// `/` or `\\` on Windows), extracting the file name, determining whether the path\n+/// is absolute, and so on.\n ///\n /// This is an *unsized* type, meaning that it must always be used behind a\n /// pointer like `&` or [`Box`]. For an owned version of this type,\n@@ -1520,10 +1520,11 @@ impl AsRef<OsStr> for PathBuf {\n /// use std::path::Path;\n /// use std::ffi::OsStr;\n ///\n-/// let path = Path::new(\"/tmp/foo/bar.txt\");\n+/// // Note: this example does work on Windows\n+/// let path = Path::new(\"./foo/bar.txt\");\n ///\n /// let parent = path.parent();\n-/// assert_eq!(parent, Some(Path::new(\"/tmp/foo\")));\n+/// assert_eq!(parent, Some(Path::new(\"./foo\")));\n ///\n /// let file_stem = path.file_stem();\n /// assert_eq!(file_stem, Some(OsStr::new(\"bar\")));"}, {"sha": "7adfcc44ad008847e9fd99c8f628de9f768bb688", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -447,8 +447,6 @@ impl Command {\n     /// Basic usage:\n     ///\n     /// ```no_run\n-    /// #![feature(command_envs)]\n-    ///\n     /// use std::process::{Command, Stdio};\n     /// use std::env;\n     /// use std::collections::HashMap;\n@@ -466,7 +464,7 @@ impl Command {\n     ///         .spawn()\n     ///         .expect(\"printenv failed to start\");\n     /// ```\n-    #[unstable(feature = \"command_envs\", issue = \"38526\")]\n+    #[stable(feature = \"command_envs\", since = \"1.19.0\")]\n     pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Command\n         where I: IntoIterator<Item=(K, V)>, K: AsRef<OsStr>, V: AsRef<OsStr>\n     {"}, {"sha": "2ee63527c147cfd739f93b04939abb2557103ce2", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -25,7 +25,7 @@\n \n \n // Reexport some of our utilities which are expected by other crates.\n-pub use panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n+pub use panicking::{begin_panic_new, begin_panic, begin_panic_fmt, update_panic_count};\n \n #[cfg(not(test))]\n #[lang = \"start\"]"}, {"sha": "9f0eee024d56f59b25695db63ef004a82a78b29d", "filename": "src/libstd/sys/redox/fast_thread_local.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -57,7 +57,7 @@ impl<T> Key<T> {\n     }\n }\n \n-unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n     // The fallback implementation uses a vanilla OS-based TLS key to track\n     // the list of destructors that need to be run for this thread. The key\n     // then has its own destructor which runs all the other destructors.\n@@ -115,3 +115,7 @@ pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n         ptr::drop_in_place((*ptr).inner.get());\n     }\n }\n+\n+pub fn requires_move_before_drop() -> bool {\n+    false\n+}"}, {"sha": "c5a19e8debe93ec349c6ec763791cce3b377faab", "filename": "src/libstd/sys/redox/fs.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -420,12 +420,19 @@ fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    canonicalize(p)\n-}\n-\n-pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    ::sys_common::util::dumb_print(format_args!(\"Symlink\\n\"));\n-    unimplemented!();\n+    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_SYMLINK | syscall::O_RDONLY))?;\n+    let mut buf: [u8; 4096] = [0; 4096];\n+    let count = cvt(syscall::read(fd, &mut buf))?;\n+    cvt(syscall::close(fd))?;\n+    Ok(PathBuf::from(unsafe { String::from_utf8_unchecked(Vec::from(&buf[..count])) }))\n+}\n+\n+pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n+    let fd = cvt(syscall::open(dst.to_str().unwrap(),\n+                               syscall::O_SYMLINK | syscall::O_CREAT | syscall::O_WRONLY | 0o777))?;\n+    cvt(syscall::write(fd, src.to_str().unwrap().as_bytes()))?;\n+    cvt(syscall::close(fd))?;\n+    Ok(())\n }\n \n pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {"}, {"sha": "17673f0bd60b3b5a7525f709ce002e6825cfe55a", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -17,7 +17,6 @@ use sys::fs::{File, OpenOptions};\n use sys::syscall::TimeSpec;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n-use vec::Vec;\n \n use super::{path_to_peer_addr, path_to_local_addr};\n "}, {"sha": "28645facd93f814d48db2d4da788d96d439a2a81", "filename": "src/libstd/sys/redox/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -49,8 +49,8 @@ pub fn read2(p1: AnonPipe,\n     //FIXME: Use event based I/O multiplexing\n     //unimplemented!()\n \n-    p1.read_to_end(v1)?;\n-    p2.read_to_end(v2)?;\n+    p1.0.read_to_end(v1)?;\n+    p2.0.read_to_end(v2)?;\n \n     Ok(())\n "}, {"sha": "bd603cfe6ef9df25bcfe8380b374a9b0bd1c34b4", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -33,6 +33,7 @@ pub const MAP_WRITE_COMBINE: usize = 2;\n pub const MODE_TYPE: u16 = 0xF000;\n pub const MODE_DIR: u16 = 0x4000;\n pub const MODE_FILE: u16 = 0x8000;\n+pub const MODE_SYMLINK: u16 = 0xA000;\n \n pub const MODE_PERM: u16 = 0x0FFF;\n pub const MODE_SETUID: u16 = 0o4000;\n@@ -53,6 +54,7 @@ pub const O_TRUNC: usize =      0x0400_0000;\n pub const O_EXCL: usize =       0x0800_0000;\n pub const O_DIRECTORY: usize =  0x1000_0000;\n pub const O_STAT: usize =       0x2000_0000;\n+pub const O_SYMLINK: usize =    0x4000_0000;\n pub const O_ACCMODE: usize =    O_RDONLY | O_WRONLY | O_RDWR;\n \n pub const SEEK_SET: usize = 0;"}, {"sha": "f4fe52ca3b36c1962c841fbf07da7f303bbc6e64", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -825,8 +825,6 @@ pub fn park_timeout(dur: Duration) {\n /// # Examples\n ///\n /// ```\n-/// #![feature(thread_id)]\n-///\n /// use std::thread;\n ///\n /// let other_thread = thread::spawn(|| {\n@@ -836,7 +834,7 @@ pub fn park_timeout(dur: Duration) {\n /// let other_thread_id = other_thread.join().unwrap();\n /// assert!(thread::current().id() != other_thread_id);\n /// ```\n-#[unstable(feature = \"thread_id\", issue = \"21507\")]\n+#[stable(feature = \"thread_id\", since = \"1.19.0\")]\n #[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct ThreadId(u64);\n \n@@ -966,8 +964,6 @@ impl Thread {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(thread_id)]\n-    ///\n     /// use std::thread;\n     ///\n     /// let other_thread = thread::spawn(|| {\n@@ -977,7 +973,7 @@ impl Thread {\n     /// let other_thread_id = other_thread.join().unwrap();\n     /// assert!(thread::current().id() != other_thread_id);\n     /// ```\n-    #[unstable(feature = \"thread_id\", issue = \"21507\")]\n+    #[stable(feature = \"thread_id\", since = \"1.19.0\")]\n     pub fn id(&self) -> ThreadId {\n         self.inner.id\n     }\n@@ -1168,8 +1164,6 @@ impl<T> JoinHandle<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(thread_id)]\n-    ///\n     /// use std::thread;\n     ///\n     /// let builder = thread::Builder::new();"}, {"sha": "0938738b52cbd4246a18831e1810564d9be4cb05", "filename": "src/libstd_unicode/tables.rs", "status": "modified", "additions": 168, "deletions": 155, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibstd_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftables.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,7 +14,7 @@\n \n /// The version of [Unicode](http://www.unicode.org/)\n /// that the unicode parts of `CharExt` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (u64, u64, u64) = (9, 0, 0);\n+pub const UNICODE_VERSION: (u64, u64, u64) = (10, 0, 0);\n \n \n // BoolTrie is a trie for representing a set of Unicode codepoints. It is\n@@ -167,7 +167,7 @@ pub mod general_category {\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 0, 8, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0,\n             0, 0, 8, 0, 9, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,\n+            0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,\n             11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -236,31 +236,31 @@ pub mod derived_property {\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 95, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 96, 97, 36, 36, 36, 36, 98, 99, 36, 100, 101, 36, 102,\n-            103, 104, 105, 36, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 36, 117, 36,\n+            103, 104, 105, 36, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 36, 95, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n             36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 118, 119,\n+            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 117, 118,\n             31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n             31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n             31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n             31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n             31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n             31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n-            36, 36, 36, 36, 36, 120, 36, 121, 122, 123, 124, 125, 36, 36, 36, 36, 126, 127, 128,\n-            129, 31, 130, 36, 131, 132, 133, 113, 134\n+            36, 36, 36, 36, 36, 119, 36, 120, 121, 122, 123, 124, 36, 36, 36, 36, 125, 126, 127,\n+            128, 31, 129, 36, 130, 131, 132, 113, 133\n         ],\n         r3: &[\n-            0x00001ffffcffffff, 0x0000000001ffffff, 0x3fdfffff00000000, 0xffff03f8fff00000,\n-            0xefffffffffffffff, 0xfffe000fffe1dfff, 0xe3c5fdfffff99fef, 0x0003000fb080599f,\n-            0xc36dfdfffff987ee, 0x003f00005e021987, 0xe3edfdfffffbbfee, 0x0200000f00011bbf,\n+            0x00001ffffcffffff, 0x000007ff01ffffff, 0x3fdfffff00000000, 0xffff03f8fff00000,\n+            0xefffffffffffffff, 0xfffe000fffe1dfff, 0xe3c5fdfffff99fef, 0x1003000fb080599f,\n+            0xc36dfdfffff987ee, 0x003f00005e021987, 0xe3edfdfffffbbfee, 0x1e00000f00011bbf,\n             0xe3edfdfffff99fee, 0x0002000fb0c0199f, 0xc3ffc718d63dc7ec, 0x0000000000811dc7,\n             0xe3fffdfffffddfef, 0x0000000f07601ddf, 0xe3effdfffffddfef, 0x0006000f40601ddf,\n-            0xe7fffffffffddfee, 0xfc00000f80f05ddf, 0x2ffbfffffc7fffec, 0x000c0000ff5f807f,\n+            0xe7fffffffffddfef, 0xfc00000f80f05ddf, 0x2ffbfffffc7fffec, 0x000c0000ff5f807f,\n             0x07fffffffffffffe, 0x000000000000207f, 0x3bffecaefef02596, 0x00000000f000205f,\n             0x0000000000000001, 0xfffe1ffffffffeff, 0x1ffffffffeffff03, 0x0000000000000000,\n             0xf97fffffffffffff, 0xffffc1e7ffff0000, 0xffffffff3000407f, 0xf7ffffffffff20bf,\n@@ -278,74 +278,76 @@ pub mod derived_property {\n             0x000003ffffffffff, 0xffff7fffffffffff, 0xffffffff7fffffff, 0x000c781fffffffff,\n             0xffff20bfffffffff, 0x000080ffffffffff, 0x7f7f7f7f007fffff, 0xffffffff7f7f7f7f,\n             0x0000800000000000, 0x1f3e03fe000000e0, 0xfffffffee07fffff, 0xf7ffffffffffffff,\n-            0xfffe3fffffffffe0, 0x07ffffff00007fff, 0xffff000000000000, 0x00000000003fffff,\n+            0xfffe7fffffffffe0, 0x07ffffff00007fff, 0xffff000000000000, 0x000007ffffffffff,\n             0x0000000000001fff, 0x3fffffffffff0000, 0x00000c00ffff1fff, 0x8ff07fffffffffff,\n             0x0000ffffffffffff, 0xfffffffcff800000, 0x00ff7ffffffff9ff, 0xff80000000000000,\n             0x000000fffffff7bb, 0x000fffffffffffff, 0x28fc00000000002f, 0xffff07fffffffc00,\n             0x1fffffff0007ffff, 0xfff7ffffffffffff, 0x7c00ffdf00008000, 0x007fffffffffffff,\n             0xc47fffff00003fff, 0x7fffffffffffffff, 0x003cffff38000005, 0xffff7f7f007e7e7e,\n-            0xffff003ff7ffffff, 0x000007ffffffffff, 0xffff000fffffffff, 0x0ffffffffffff87f,\n-            0xffff3fffffffffff, 0x0000000003ffffff, 0x5f7ffdffe0f8007f, 0xffffffffffffffdb,\n-            0x0003ffffffffffff, 0xfffffffffff80000, 0x3fffffffffffffff, 0xffffffffffff0000,\n-            0xfffffffffffcffff, 0x0fff0000000000ff, 0xffdf000000000000, 0x1fffffffffffffff,\n-            0x07fffffe00000000, 0xffffffc007fffffe, 0x000000001cfcfcfc\n+            0xffff003ff7ffffff, 0xffff000fffffffff, 0x0ffffffffffff87f, 0xffff3fffffffffff,\n+            0x0000000003ffffff, 0x5f7ffdffe0f8007f, 0xffffffffffffffdb, 0x0003ffffffffffff,\n+            0xfffffffffff80000, 0x3fffffffffffffff, 0xffffffffffff0000, 0xfffffffffffcffff,\n+            0x0fff0000000000ff, 0xffdf000000000000, 0x1fffffffffffffff, 0x07fffffe00000000,\n+            0xffffffc007fffffe, 0x000000001cfcfcfc\n         ],\n         r4: [\n             0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 12, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 13, 14,\n-            15, 5, 5, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+            15, 7, 16, 17, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n+            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n         ],\n         r5: &[\n             0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15, 4, 4, 2, 2, 2,\n             2, 16, 17, 4, 4, 18, 19, 20, 21, 22, 4, 23, 4, 24, 25, 26, 27, 28, 29, 30, 4, 2, 31, 32,\n             32, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 33, 34, 35, 32, 36, 2, 37, 38, 4, 39, 40, 41,\n             42, 4, 4, 2, 43, 2, 44, 4, 4, 45, 46, 47, 48, 28, 4, 49, 4, 4, 4, 4, 4, 50, 51, 4, 4, 4,\n-            4, 4, 4, 4, 52, 4, 4, 4, 4, 53, 54, 55, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 56, 4, 2, 57, 2, 2, 2, 58, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 52, 53, 54, 55, 4, 4, 4, 4, 56, 57, 58, 4, 59, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 4, 2, 62, 2, 2, 2, 63, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 57, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 62, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 59, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2,\n-            2, 2, 2, 2, 52, 20, 4, 60, 16, 61, 62, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 63, 64,\n-            65, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2,\n+            2, 2, 2, 2, 2, 2, 55, 20, 4, 65, 16, 66, 67, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n+            68, 69, 70, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 66, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 67, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 71, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 20, 72, 2, 2, 2, 2, 2, 73,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 2, 68, 69, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 2, 70, 71, 72, 73, 74, 2, 2, 2, 2, 75, 76, 77, 78, 79, 80, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 81,\n+            4, 4, 4, 4, 4, 4, 4, 2, 74, 75, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 76, 77, 78, 79, 80, 2, 2, 2, 2, 81, 82, 83, 84, 85, 86,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 2, 2, 2, 82, 2, 83, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 84, 85,\n-            86, 4, 4, 4, 4, 4, 4, 4, 4, 4, 87, 88, 89, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 87, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 2, 2, 2, 88, 2, 89, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 90, 91, 92, 4, 4, 4, 4, 4, 4, 4, 4, 4, 72, 93, 94, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 95, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 10, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 91, 4, 4, 4,\n+            96, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 97, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 92, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 98, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n         ],\n         r6: &[\n             0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n             0x0000000000000000, 0x001fffffffffffff, 0xffffffff1fffffff, 0x000000000001ffff,\n-            0xffff0000ffffffff, 0x07ffffffffff07ff, 0xffffffff3fffffff, 0x00000000003eff0f,\n+            0xffffe000ffffffff, 0x07ffffffffff07ff, 0xffffffff3fffffff, 0x00000000003eff0f,\n             0xffff00003fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff, 0x0000000fffffffff,\n             0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f, 0x007fffff003fffff,\n             0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff, 0xc0ffffffffffffff,\n@@ -356,17 +358,18 @@ pub mod derived_property {\n             0x000001ffffffffff, 0xe3edfdfffff99fef, 0x0000000fe081199f, 0x00000000000007bb,\n             0x00000000000000b3, 0x7f3fffffffffffff, 0x000000003f000000, 0x7fffffffffffffff,\n             0x0000000000000011, 0x000007ffe3ffffff, 0xffffffff00000000, 0x80000000ffffffff,\n-            0x01ffffffffffffff, 0x7f7ffffffffffdff, 0xfffc000000000001, 0x007ffefffffcffff,\n-            0x0000000003ffffff, 0x00007fffffffffff, 0x000000000000000f, 0x000000000000007f,\n-            0x00003fffffff0000, 0xe0fffff80000000f, 0x000000000000ffff, 0x7fffffffffff001f,\n-            0x00000000fff80000, 0x0000000100000000, 0x00001fffffffffff, 0x0000000000000003,\n-            0x1fff07ffffffffff, 0x0000000043ff01ff, 0xffffffffffdfffff, 0xebffde64dfffffff,\n-            0xffffffffffffffef, 0x7bffffffdfdfe7bf, 0xfffffffffffdfc5f, 0xffffff3fffffffff,\n-            0xf7fffffff7fffffd, 0xffdfffffffdfffff, 0xffff7fffffff7fff, 0xfffffdfffffffdff,\n-            0x0000000000000ff7, 0x000007dbf9ffff7f, 0x000000000000001f, 0x000000000000008f,\n-            0x0af7fe96ffffffef, 0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff, 0xffff000000000000,\n-            0xffff03ffffff03ff, 0x00000000000003ff, 0x00000000007fffff, 0x00000003ffffffff,\n-            0x000000003fffffff\n+            0x7fe7ffffffffffff, 0xffffffffffff0000, 0x0000000000ffffcf, 0x01ffffffffffffff,\n+            0x7f7ffffffffffdff, 0xfffc000000000001, 0x007ffefffffcffff, 0xb47ffffffffffb7f,\n+            0x00000000000000cb, 0x0000000003ffffff, 0x00007fffffffffff, 0x000000000000000f,\n+            0x000000000000007f, 0x00003fffffff0000, 0xe0fffff80000000f, 0x000000000000ffff,\n+            0x7fffffffffff001f, 0x00000000fff80000, 0x0000000300000000, 0x00001fffffffffff,\n+            0xffff000000000000, 0x0fffffffffffffff, 0x1fff07ffffffffff, 0x0000000043ff01ff,\n+            0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf,\n+            0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff,\n+            0xffff7fffffff7fff, 0xfffffdfffffffdff, 0x0000000000000ff7, 0x000007dbf9ffff7f,\n+            0x000000000000001f, 0x000000000000008f, 0x0af7fe96ffffffef, 0x5ef7f796aa96ea84,\n+            0x0ffffbee0ffffbff, 0xffff03ffffff03ff, 0x00000000000003ff, 0x00000000007fffff,\n+            0xffff0003ffffffff, 0x00000001ffffffff, 0x000000003fffffff\n         ],\n     };\n \n@@ -426,9 +429,9 @@ pub mod derived_property {\n         r3: &[\n             0x00003fffffc00000, 0x000000000e000000, 0x0000000000000000, 0xfffffffffff00000,\n             0x1400000000000007, 0x0002000c00fe21fe, 0x1000000000000002, 0x0000000c0000201e,\n-            0x1000000000000006, 0x0023000000023986, 0x0000000c000021be, 0x9000000000000002,\n+            0x1000000000000006, 0x0023000000023986, 0xfc00000c000021be, 0x9000000000000002,\n             0x0000000c0040201e, 0x0000000000000004, 0x0000000000002001, 0xc000000000000001,\n-            0x0000000c00603dc1, 0x0000000c00003040, 0x0000000000000002, 0x00000000005c0400,\n+            0x0000000c00603dc1, 0x0000000c00003040, 0x1800000000000003, 0x00000000005c0400,\n             0x07f2000000000000, 0x0000000000007fc0, 0x1bf2000000000000, 0x0000000000003f40,\n             0x02a0000003000000, 0x7ffe000000000000, 0x1ffffffffeffe0df, 0x0000000000000040,\n             0x66fde00000000000, 0x001e0001c3000000, 0x0000000020002064, 0x1000000000000000,\n@@ -437,7 +440,7 @@ pub mod derived_property {\n             0x0e04018700000000, 0x0000000009800000, 0x9ff81fe57f400000, 0x7fff008000000000,\n             0x17d000000000000f, 0x000ff80000000004, 0x00003b3c00000003, 0x0003a34000000000,\n             0x00cff00000000000, 0x3f00000000000000, 0x031021fdfff70000, 0xfffff00000000000,\n-            0x010007ffffffffff, 0xfffffffff8000000, 0xf83fffffffffffff, 0xa000000000000000,\n+            0x010007ffffffffff, 0xfffffffff8000000, 0xfbffffffffffffff, 0xa000000000000000,\n             0x6000e000e000e003, 0x00007c900300f800, 0x8002ffdf00000000, 0x000000001fff0000,\n             0x0001ffffffff0000, 0x3000000000000000, 0x0003800000000000, 0x8000800000000000,\n             0xffffffff00000000, 0x0000800000000000, 0x083e3c0000000020, 0x000000007e000000,\n@@ -465,24 +468,24 @@ pub mod derived_property {\n             0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 6, 7, 8, 0, 9, 10, 11, 12, 13, 0, 0, 14, 15, 16, 0, 0, 17, 18, 19, 20,\n-            0, 0, 21, 22, 23, 24, 25, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-            0, 27, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 21, 22, 23, 24, 25, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 29, 0, 0, 0,\n+            0, 0, 30, 0, 31, 0, 32, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 0, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32,\n-            2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 35, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 38, 39, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 42, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 35, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 37, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 39, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 41, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 48, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 45,\n-            0, 0, 45, 45, 45, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-            0, 0, 0, 0, 0\n+            50, 51, 0, 0, 51, 51, 51, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0\n         ],\n         r6: &[\n             0x0000000000000000, 0x2000000000000000, 0x0000000100000000, 0x07c0000000000000,\n@@ -491,12 +494,14 @@ pub mod derived_property {\n             0x0000000000001c00, 0x40d3800000000000, 0x000007f880000000, 0x1000000000000003,\n             0x001f1fc000000001, 0xff00000000000000, 0x000000000000005c, 0x85f8000000000000,\n             0x000000000000000d, 0xb03c000000000000, 0x0000000030000001, 0xa7f8000000000000,\n-            0x0000000000000001, 0x00bf280000000000, 0x00000fbce0000000, 0xbf7f000000000000,\n-            0x006dfcfffffc0000, 0x001f000000000000, 0x007f000000000000, 0x000000000000000f,\n-            0x00000000ffff8000, 0x0000000f60000000, 0xfff8038000000000, 0x00003c0000000fe7,\n-            0x000000000000001c, 0xf87fffffffffffff, 0x00201fffffffffff, 0x0000fffef8000010,\n-            0x000007dbf9ffff7f, 0x00000000007f0000, 0x00000000000007f0, 0xf800000000000000,\n-            0xffffffff00000002, 0xffffffffffffffff, 0x0000ffffffffffff\n+            0x0000000000000001, 0x00bf280000000000, 0x00000fbce0000000, 0x79f800000000067e,\n+            0x000000000e7e0080, 0x00000000037ffc00, 0xbf7f000000000000, 0x006dfcfffffc0000,\n+            0xb47e000000000000, 0x00000000000000bf, 0x001f000000000000, 0x007f000000000000,\n+            0x000000000000000f, 0x00000000ffff8000, 0x0000000300000000, 0x0000000f60000000,\n+            0xfff8038000000000, 0x00003c0000000fe7, 0x000000000000001c, 0xf87fffffffffffff,\n+            0x00201fffffffffff, 0x0000fffef8000010, 0x000007dbf9ffff7f, 0x00000000007f0000,\n+            0x00000000000007f0, 0xf800000000000000, 0xffffffff00000002, 0xffffffffffffffff,\n+            0x0000ffffffffffff\n         ],\n     };\n \n@@ -851,12 +856,12 @@ pub mod derived_property {\n             127\n         ],\n         r3: &[\n-            0x00003fffffffffff, 0x000000000fffffff, 0x3fdfffff00000000, 0xfffffffbfff00000,\n-            0xffffffffffffffff, 0xfffeffcfffffffff, 0xf3c5fdfffff99fef, 0x0003ffcfb080799f,\n-            0xd36dfdfffff987ee, 0x003fffc05e023987, 0xf3edfdfffffbbfee, 0x0200ffcf00013bbf,\n+            0x00003fffffffffff, 0x000007ff0fffffff, 0x3fdfffff00000000, 0xfffffffbfff00000,\n+            0xffffffffffffffff, 0xfffeffcfffffffff, 0xf3c5fdfffff99fef, 0x1003ffcfb080799f,\n+            0xd36dfdfffff987ee, 0x003fffc05e023987, 0xf3edfdfffffbbfee, 0xfe00ffcf00013bbf,\n             0xf3edfdfffff99fee, 0x0002ffcfb0c0399f, 0xc3ffc718d63dc7ec, 0x0000ffc000813dc7,\n             0xe3fffdfffffddfef, 0x0000ffcf07603ddf, 0xf3effdfffffddfef, 0x0006ffcf40603ddf,\n-            0xe7fffffffffddfee, 0xfc00ffcf80f07ddf, 0x2ffbfffffc7fffec, 0x000cffc0ff5f847f,\n+            0xfffffffffffddfef, 0xfc00ffcf80f07ddf, 0x2ffbfffffc7fffec, 0x000cffc0ff5f847f,\n             0x07fffffffffffffe, 0x0000000003ff7fff, 0x3bffecaefef02596, 0x00000000f3ff3f5f,\n             0xc2a003ff03000001, 0xfffe1ffffffffeff, 0x1ffffffffeffffdf, 0x0000000000000040,\n             0xffffffffffff03ff, 0xffffffff3fffffff, 0xf7ffffffffff20bf, 0xffffffff3d7f3dff,\n@@ -867,13 +872,13 @@ pub mod derived_property {\n             0x003fffffffffffff, 0x0fff0fff7fffffff, 0x001f3fffffffffc0, 0xffff0fffffffffff,\n             0x0000000007ff03ff, 0xffffffff0fffffff, 0x9fffffff7fffffff, 0x3fff008003ff03ff,\n             0x0000000000000000, 0x000ff80003ff0fff, 0x000fffffffffffff, 0x3fffffffffffe3ff,\n-            0x00000000000001ff, 0x037ffffffff70000, 0xf83fffffffffffff, 0xffffffff3f3fffff,\n+            0x00000000000001ff, 0x03fffffffff70000, 0xfbffffffffffffff, 0xffffffff3f3fffff,\n             0x3fffffffaaff3f3f, 0x5fdfffffffffffff, 0x1fdc1fff0fcf1fdc, 0x8000000000000000,\n             0x8002000000100001, 0x000000001fff0000, 0x0001ffe21fff0000, 0xf3fffd503f2ffc84,\n             0xffffffff000043e0, 0xffff7fffffffffff, 0xffffffff7fffffff, 0x000ff81fffffffff,\n             0xffff20bfffffffff, 0x800080ffffffffff, 0x7f7f7f7f007fffff, 0xffffffff7f7f7f7f,\n-            0x1f3efffe000000e0, 0xfffffffee67fffff, 0xf7ffffffffffffff, 0xfffe3fffffffffe0,\n-            0x07ffffff00007fff, 0xffff000000000000, 0x00000000003fffff, 0x0000000000001fff,\n+            0x1f3efffe000000e0, 0xfffffffee67fffff, 0xf7ffffffffffffff, 0xfffe7fffffffffe0,\n+            0x07ffffff00007fff, 0xffff000000000000, 0x000007ffffffffff, 0x0000000000001fff,\n             0x3fffffffffff0000, 0x00000fffffff1fff, 0xbff0ffffffffffff, 0x0003ffffffffffff,\n             0xfffffffcff800000, 0x00ff7ffffffff9ff, 0xff80000000000000, 0x000000ffffffffff,\n             0x28ffffff03ff003f, 0xffff3fffffffffff, 0x1fffffff000fffff, 0x7fffffff03ff8001,\n@@ -886,60 +891,62 @@ pub mod derived_property {\n         ],\n         r4: [\n             0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 13,\n-            14, 5, 5, 15, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+            14, 7, 15, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n+            5, 5, 5, 5, 5, 5, 5, 17, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n         ],\n         r5: &[\n             0, 1, 2, 3, 4, 5, 4, 6, 4, 4, 7, 8, 9, 10, 11, 12, 2, 2, 13, 14, 15, 16, 4, 4, 2, 2, 2,\n             2, 17, 18, 4, 4, 19, 20, 21, 22, 23, 4, 24, 4, 25, 26, 27, 28, 29, 30, 31, 4, 2, 32, 33,\n             33, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 34, 3, 35, 36, 37, 2, 38, 39, 4, 40, 41, 42,\n             43, 4, 4, 2, 44, 2, 45, 4, 4, 46, 47, 2, 48, 49, 50, 51, 4, 4, 4, 4, 4, 52, 53, 4, 4, 4,\n-            4, 4, 4, 4, 54, 4, 4, 4, 4, 55, 56, 57, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 58, 4, 2, 59, 2, 2, 2, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 54, 55, 56, 57, 4, 4, 4, 4, 58, 59, 60, 4, 61, 62, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 63, 4, 2, 64, 2, 2, 2, 65, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 59, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 64, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 61, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 66, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2,\n-            2, 2, 2, 2, 54, 62, 4, 63, 17, 64, 65, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 66, 67,\n-            68, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2,\n+            2, 2, 2, 2, 2, 2, 57, 67, 4, 68, 17, 69, 70, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n+            71, 72, 73, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 69, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 33, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 70, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 74, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 33, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 21, 75, 2, 2, 2, 2, 2, 76,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 2, 71, 72, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 73, 74, 4, 4,\n-            75, 4, 4, 4, 4, 4, 4, 2, 76, 77, 78, 79, 80, 2, 2, 2, 2, 81, 82, 83, 84, 85, 86, 4, 4,\n-            4, 4, 4, 4, 4, 4, 87, 88, 89, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 90, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 2, 2, 2, 91, 2, 44, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            92, 93, 94, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 95, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            4, 4, 4, 4, 4, 4, 4, 2, 77, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            79, 80, 4, 4, 81, 4, 4, 4, 4, 4, 4, 2, 82, 83, 84, 85, 86, 2, 2, 2, 2, 87, 88, 89, 90,\n+            91, 92, 4, 4, 4, 4, 4, 4, 4, 4, 93, 94, 95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 96, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 97, 2, 44, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 98, 99, 100, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 101, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 102, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 96, 4, 4, 4, 4, 4, 4, 4,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 103, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 2, 2, 2, 2, 2, 2, 2, 2, 97, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 98, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 104, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 105, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n         ],\n         r6: &[\n             0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n             0x0000000000000000, 0x001fffffffffffff, 0x2000000000000000, 0xffffffff1fffffff,\n-            0x000000010001ffff, 0xffff0000ffffffff, 0x07ffffffffff07ff, 0xffffffff3fffffff,\n+            0x000000010001ffff, 0xffffe000ffffffff, 0x07ffffffffff07ff, 0xffffffff3fffffff,\n             0x00000000003eff0f, 0xffff03ff3fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff,\n             0x0000000fffffffff, 0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f,\n             0x007fffff003fffff, 0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff,\n@@ -950,18 +957,20 @@ pub mod derived_property {\n             0xffff01ffbfffbd7f, 0x03ff07ffffffffff, 0xf3edfdfffff99fef, 0x001f1fcfe081399f,\n             0x0000000003ff07ff, 0x0000000003ff00bf, 0xff3fffffffffffff, 0x000000003f000001,\n             0x0000000003ff0011, 0x00ffffffffffffff, 0x00000000000003ff, 0x03ff0fffe3ffffff,\n-            0xffffffff00000000, 0x800003ffffffffff, 0x01ffffffffffffff, 0xff7ffffffffffdff,\n-            0xfffc000003ff0001, 0x007ffefffffcffff, 0x0000000003ffffff, 0x00007fffffffffff,\n-            0x000000000000000f, 0x000000000000007f, 0x000003ff7fffffff, 0x001f3fffffff0000,\n-            0xe0fffff803ff000f, 0x000000000000ffff, 0x7fffffffffff001f, 0x00000000ffff8000,\n-            0x0000000100000000, 0x00001fffffffffff, 0x0000000000000003, 0x1fff07ffffffffff,\n-            0x0000000063ff01ff, 0xf807e3e000000000, 0x00003c0000000fe7, 0x000000000000001c,\n-            0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf,\n-            0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff,\n-            0xffff7fffffff7fff, 0xfffffdfffffffdff, 0xffffffffffffcff7, 0xf87fffffffffffff,\n-            0x00201fffffffffff, 0x0000fffef8000010, 0x000007dbf9ffff7f, 0x00000000007f001f,\n-            0x0af7fe96ffffffef, 0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff, 0x00000000007fffff,\n-            0x00000003ffffffff, 0x000000003fffffff, 0x0000ffffffffffff\n+            0xffffffff00000000, 0x800003ffffffffff, 0x7fffffffffffffff, 0xffffffffffff0080,\n+            0x0000000003ffffcf, 0x01ffffffffffffff, 0xff7ffffffffffdff, 0xfffc000003ff0001,\n+            0x007ffefffffcffff, 0xb47ffffffffffb7f, 0x0000000003ff00ff, 0x0000000003ffffff,\n+            0x00007fffffffffff, 0x000000000000000f, 0x000000000000007f, 0x000003ff7fffffff,\n+            0x001f3fffffff0000, 0xe0fffff803ff000f, 0x000000000000ffff, 0x7fffffffffff001f,\n+            0x00000000ffff8000, 0x0000000300000000, 0x00001fffffffffff, 0xffff000000000000,\n+            0x0fffffffffffffff, 0x1fff07ffffffffff, 0x0000000063ff01ff, 0xf807e3e000000000,\n+            0x00003c0000000fe7, 0x000000000000001c, 0xffffffffffdfffff, 0xebffde64dfffffff,\n+            0xffffffffffffffef, 0x7bffffffdfdfe7bf, 0xfffffffffffdfc5f, 0xffffff3fffffffff,\n+            0xf7fffffff7fffffd, 0xffdfffffffdfffff, 0xffff7fffffff7fff, 0xfffffdfffffffdff,\n+            0xffffffffffffcff7, 0xf87fffffffffffff, 0x00201fffffffffff, 0x0000fffef8000010,\n+            0x000007dbf9ffff7f, 0x00000000007f001f, 0x0af7fe96ffffffef, 0x5ef7f796aa96ea84,\n+            0x0ffffbee0ffffbff, 0x00000000007fffff, 0xffff0003ffffffff, 0x00000001ffffffff,\n+            0x000000003fffffff, 0x0000ffffffffffff\n         ],\n     };\n \n@@ -1027,8 +1036,8 @@ pub mod derived_property {\n             129, 130, 131, 132\n         ],\n         r3: &[\n-            0x00000110043fffff, 0x0000000001ffffff, 0x3fdfffff00000000, 0x0000000000000000,\n-            0x23fffffffffffff0, 0xfffe0003ff010000, 0x23c5fdfffff99fe1, 0x00030003b0004000,\n+            0x00000110043fffff, 0x000007ff01ffffff, 0x3fdfffff00000000, 0x0000000000000000,\n+            0x23fffffffffffff0, 0xfffe0003ff010000, 0x23c5fdfffff99fe1, 0x10030003b0004000,\n             0x036dfdfffff987e0, 0x001c00005e000000, 0x23edfdfffffbbfe0, 0x0200000300010000,\n             0x23edfdfffff99fe0, 0x00020003b0000000, 0x03ffc718d63dc7e8, 0x0000000000010000,\n             0x23fffdfffffddfe0, 0x0000000307000000, 0x23effdfffffddfe1, 0x0006000340000000,\n@@ -1048,8 +1057,8 @@ pub mod derived_property {\n             0x1fdc1fff0fcf1fdc, 0x8002000000000000, 0x000000001fff0000, 0xf3fffd503f2ffc84,\n             0xffffffff000043e0, 0xffff7fffffffffff, 0xffffffff7fffffff, 0x000c781fffffffff,\n             0xffff20bfffffffff, 0x000080ffffffffff, 0x7f7f7f7f007fffff, 0x000000007f7f7f7f,\n-            0x1f3e03fe000000e0, 0xfffffffee07fffff, 0xf7ffffffffffffff, 0xfffe3fffffffffe0,\n-            0x07ffffff00007fff, 0xffff000000000000, 0x00000000003fffff, 0x0000000000001fff,\n+            0x1f3e03fe000000e0, 0xfffffffee07fffff, 0xf7ffffffffffffff, 0xfffe7fffffffffe0,\n+            0x07ffffff00007fff, 0xffff000000000000, 0x000007ffffffffff, 0x0000000000001fff,\n             0x3fffffffffff0000, 0x00000c00ffff1fff, 0x80007fffffffffff, 0xffffffff3fffffff,\n             0x0000ffffffffffff, 0xfffffffcff800000, 0x00ff7ffffffff9ff, 0xff80000000000000,\n             0x00000007fffff7bb, 0x000ffffffffffffc, 0x28fc000000000000, 0xffff003ffffffc00,\n@@ -1064,58 +1073,60 @@ pub mod derived_property {\n         ],\n         r4: [\n             0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 13,\n-            14, 5, 5, 15, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+            14, 7, 15, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n             5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n+            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n         ],\n         r5: &[\n             0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15, 4, 4, 2, 2, 2,\n             2, 16, 17, 4, 4, 18, 19, 20, 21, 22, 4, 23, 4, 24, 25, 26, 27, 28, 29, 30, 4, 2, 31, 32,\n             32, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 33, 4, 34, 35, 36, 37, 38, 39, 40, 4, 41, 20,\n             42, 43, 4, 4, 5, 44, 45, 46, 4, 4, 47, 48, 45, 49, 50, 4, 51, 4, 4, 4, 4, 4, 52, 53, 4,\n-            4, 4, 4, 4, 4, 4, 54, 4, 4, 4, 4, 55, 56, 57, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 51, 4, 2, 47, 2, 2, 2, 58, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 54, 55, 56, 57, 4, 4, 4, 4, 58, 59, 60, 4, 61, 62, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 51, 4, 2, 47, 2, 2, 2, 63, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 47, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 47, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 59, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2,\n-            2, 2, 2, 2, 2, 2, 54, 20, 4, 60, 45, 61, 57, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n-            62, 63, 64, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 65, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 66, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 2, 67, 68, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 69, 70, 71, 72, 73, 2, 2, 2, 2, 74, 75, 76, 77, 78, 79, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            2, 2, 2, 2, 2, 2, 2, 2, 57, 20, 4, 65, 45, 66, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 2, 67, 68, 69, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 70, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 20, 71, 2, 2, 2, 2, 2,\n+            72, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 2, 73, 74, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 75, 76, 77, 78, 79, 2, 2, 2, 2, 80, 81, 82, 83, 84,\n+            85, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 2, 2, 2, 80, 2, 58, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            81, 82, 83, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 84, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 86, 2, 63, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 87, 88, 89, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 91, 2, 2, 2, 2, 2,\n             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 85, 4, 4, 4, 4, 4, 4, 4,\n+            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 92, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n             4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 2, 2, 2, 2, 2, 2, 2, 2, 86, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 93, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n         ],\n         r6: &[\n             0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n             0x0000000000000000, 0x001fffffffffffff, 0xffffffff1fffffff, 0x000000000001ffff,\n-            0xffff0000ffffffff, 0x003fffffffff07ff, 0xffffffff3fffffff, 0x00000000003eff0f,\n+            0xffffe000ffffffff, 0x003fffffffff07ff, 0xffffffff3fffffff, 0x00000000003eff0f,\n             0xffff00003fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff, 0x0000000fffffffff,\n             0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f, 0x007fffff003fffff,\n             0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff, 0xc0ffffffffffffff,\n@@ -1126,15 +1137,17 @@ pub mod derived_property {\n             0x00000ffffffbffff, 0xffff01ffbfffbd7f, 0x23edfdfffff99fe0, 0x00000003e0010000,\n             0x0000000000000780, 0x0000ffffffffffff, 0x00000000000000b0, 0x00007fffffffffff,\n             0x000000000f000000, 0x0000000000000010, 0x000007ffffffffff, 0x0000000003ffffff,\n-            0xffffffff00000000, 0x80000000ffffffff, 0x01ffffffffffffff, 0x00007ffffffffdff,\n-            0xfffc000000000001, 0x000000000000ffff, 0x000000000000000f, 0x000000000000007f,\n-            0x00003fffffff0000, 0xe0fffff80000000f, 0x000000000001001f, 0x00000000fff80000,\n-            0x0000000100000000, 0x00001fffffffffff, 0x0000000000000003, 0x1fff07ffffffffff,\n-            0x0000000003ff01ff, 0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef,\n-            0x7bffffffdfdfe7bf, 0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd,\n-            0xffdfffffffdfffff, 0xffff7fffffff7fff, 0xfffffdfffffffdff, 0x0000000000000ff7,\n-            0x000000000000001f, 0x0af7fe96ffffffef, 0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff,\n-            0x00000000007fffff, 0x00000003ffffffff, 0x000000003fffffff\n+            0xffffffff00000000, 0x80000000ffffffff, 0x0407fffffffff801, 0xfffffffff0010000,\n+            0x00000000000003cf, 0x01ffffffffffffff, 0x00007ffffffffdff, 0xfffc000000000001,\n+            0x000000000000ffff, 0x0001fffffffffb7f, 0x0000000000000040, 0x000000000000000f,\n+            0x000000000000007f, 0x00003fffffff0000, 0xe0fffff80000000f, 0x000000000001001f,\n+            0x00000000fff80000, 0x0000000300000000, 0x00001fffffffffff, 0xffff000000000000,\n+            0x0fffffffffffffff, 0x1fff07ffffffffff, 0x0000000003ff01ff, 0xffffffffffdfffff,\n+            0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf, 0xfffffffffffdfc5f,\n+            0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff, 0xffff7fffffff7fff,\n+            0xfffffdfffffffdff, 0x0000000000000ff7, 0x000000000000001f, 0x0af7fe96ffffffef,\n+            0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff, 0x00000000007fffff, 0xffff0003ffffffff,\n+            0x00000001ffffffff, 0x000000003fffffff\n         ],\n     };\n "}, {"sha": "d00e29d954fc6938821b18763664762abcbb6d75", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -97,9 +97,8 @@ impl Path {\n     }\n \n     pub fn default_to_global(mut self) -> Path {\n-        let name = self.segments[0].identifier.name;\n-        if !self.is_global() && name != \"$crate\" &&\n-           name != keywords::SelfValue.name() && name != keywords::Super.name() {\n+        if !self.is_global() &&\n+           !::parse::token::Ident(self.segments[0].identifier).is_path_segment_keyword() {\n             self.segments.insert(0, PathSegment::crate_root(self.span));\n         }\n         self"}, {"sha": "1eb749623d8ae3d9367f8806ec0378ad3fa4de3a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -11,7 +11,7 @@\n use abi::Abi;\n use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Pos, Span, DUMMY_SP};\n use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use ptr::P;\n@@ -768,14 +768,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n-        let expr_file_line_tuple = self.expr_tuple(span, vec![expr_file, expr_line]);\n-        let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n+        let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);\n+        let expr_loc_tuple = self.expr_tuple(span, vec![expr_file, expr_line, expr_col]);\n+        let expr_loc_ptr = self.expr_addr_of(span, expr_loc_tuple);\n         self.expr_call_global(\n             span,\n-            self.std_path(&[\"rt\", \"begin_panic\"]),\n+            self.std_path(&[\"rt\", \"begin_panic_new\"]),\n             vec![\n                 self.expr_str(span, msg),\n-                expr_file_line_ptr])\n+                expr_loc_ptr])\n     }\n \n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {"}, {"sha": "4e9e30857b1e88df08dcd51252488c2856ccaa97", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -12,7 +12,7 @@ use ast;\n use ext::tt::macro_parser;\n use parse::{ParseSess, token};\n use print::pprust;\n-use symbol::{keywords, Symbol};\n+use symbol::keywords;\n use syntax_pos::{DUMMY_SP, Span, BytePos};\n use tokenstream;\n \n@@ -199,7 +199,7 @@ fn parse_tree<I>(tree: tokenstream::TokenTree,\n             Some(tokenstream::TokenTree::Token(ident_span, token::Ident(ident))) => {\n                 let span = Span { lo: span.lo, ..ident_span };\n                 if ident.name == keywords::Crate.name() {\n-                    let ident = ast::Ident { name: Symbol::intern(\"$crate\"), ..ident };\n+                    let ident = ast::Ident { name: keywords::DollarCrate.name(), ..ident };\n                     TokenTree::Token(span, token::Ident(ident))\n                 } else {\n                     TokenTree::MetaVar(span, ident)"}, {"sha": "4b0ec1a20e33177a59fab36c1c2dfad83f965e2e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -360,6 +360,12 @@ declare_features! (\n \n     // rustc internal\n     (active, abi_thiscall, \"1.19.0\", None),\n+\n+    // Allows a test to fail without failing the whole suite\n+    (active, allow_fail, \"1.19.0\", Some(42219)),\n+\n+    // Allows unsized tuple coercion.\n+    (active, unsized_tuple_coercion, \"1.20.0\", Some(42877)),\n );\n \n declare_features! (\n@@ -818,6 +824,11 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                              \"used internally by rustc\",\n                                              cfg_fn!(rustc_attrs))),\n \n+    (\"allow_fail\", Normal, Gated(Stability::Unstable,\n+                                 \"allow_fail\",\n+                                 \"allow_fail attribute is currently unstable\",\n+                                 cfg_fn!(allow_fail))),\n+\n     // Crate level attributes\n     (\"crate_name\", CrateLevel, Ungated),\n     (\"crate_type\", CrateLevel, Ungated),\n@@ -1039,6 +1050,9 @@ pub const EXPLAIN_VIS_MATCHER: &'static str =\n pub const EXPLAIN_PLACEMENT_IN: &'static str =\n     \"placement-in expression syntax is experimental and subject to change.\";\n \n+pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n+    \"Unsized tuple coercion is not stable enough for use and is subject to change\";\n+\n struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n }"}, {"sha": "09cdf26bf1fff4390a6bd1508051efacf86b01c6", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1285,7 +1285,7 @@ impl<'a> StringReader<'a> {\n                     });\n                     let keyword_checking_token = &token::Ident(keyword_checking_ident);\n                     let last_bpos = self.pos;\n-                    if keyword_checking_token.is_any_keyword() &&\n+                    if keyword_checking_token.is_reserved_ident() &&\n                        !keyword_checking_token.is_keyword(keywords::Static) {\n                         self.err_span_(start, last_bpos, \"lifetimes cannot use keyword names\");\n                     }"}, {"sha": "c248e20b608fc4ca322ae71e29bd2ded053e889c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -511,14 +511,13 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn this_token_descr(&self) -> String {\n-        let s = self.this_token_to_string();\n-        if self.token.is_strict_keyword() {\n-            format!(\"keyword `{}`\", s)\n-        } else if self.token.is_reserved_keyword() {\n-            format!(\"reserved keyword `{}`\", s)\n-        } else {\n-            format!(\"`{}`\", s)\n-        }\n+        let prefix = match &self.token {\n+            t if t.is_special_ident() => \"reserved identifier \",\n+            t if t.is_used_keyword() => \"keyword \",\n+            t if t.is_unused_keyword() => \"reserved keyword \",\n+            _ => \"\",\n+        };\n+        format!(\"{}`{}`\", prefix, self.this_token_to_string())\n     }\n \n     pub fn unexpected_last<T>(&self, t: &token::Token) -> PResult<'a, T> {\n@@ -637,10 +636,12 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        self.check_strict_keywords();\n-        self.check_reserved_keywords();\n         match self.token {\n             token::Ident(i) => {\n+                if self.token.is_reserved_ident() {\n+                    self.span_err(self.span, &format!(\"expected identifier, found {}\",\n+                                                      self.this_token_descr()));\n+                }\n                 self.bump();\n                 Ok(i)\n             }\n@@ -713,25 +714,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Signal an error if the given string is a strict keyword\n-    pub fn check_strict_keywords(&mut self) {\n-        if self.token.is_strict_keyword() {\n-            let token_str = self.this_token_to_string();\n-            let span = self.span;\n-            self.span_err(span,\n-                          &format!(\"expected identifier, found keyword `{}`\",\n-                                  token_str));\n-        }\n-    }\n-\n-    /// Signal an error if the current token is a reserved keyword\n-    pub fn check_reserved_keywords(&mut self) {\n-        if self.token.is_reserved_keyword() {\n-            let token_str = self.this_token_to_string();\n-            self.fatal(&format!(\"`{}` is a reserved keyword\", token_str)).emit()\n-        }\n-    }\n-\n     fn check_ident(&mut self) -> bool {\n         if self.token.is_ident() {\n             true\n@@ -1659,8 +1641,10 @@ impl<'a> Parser<'a> {\n         Ok(codemap::Spanned { node: lit, span: lo.to(self.prev_span) })\n     }\n \n-    /// matches '-' lit | lit\n+    /// matches '-' lit | lit (cf. ast_validation::AstValidator::check_expr_within_pat)\n     pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+        maybe_whole_expr!(self);\n+\n         let minus_lo = self.span;\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n         let lo = self.span;\n@@ -2299,7 +2283,7 @@ impl<'a> Parser<'a> {\n                     ex = ExprKind::Break(lt, e);\n                     hi = self.prev_span;\n                 } else if self.token.is_keyword(keywords::Let) {\n-                    // Catch this syntax error here, instead of in `check_strict_keywords`, so\n+                    // Catch this syntax error here, instead of in `parse_ident`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n                     db.note(\"variable declaration using `let` is a statement\");\n@@ -3541,7 +3525,7 @@ impl<'a> Parser<'a> {\n                 // Parse box pat\n                 let subpat = self.parse_pat()?;\n                 pat = PatKind::Box(subpat);\n-            } else if self.token.is_ident() && !self.token.is_any_keyword() &&\n+            } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n                       self.parse_as_ident() {\n                 // Parse ident @ pat\n                 // This can give false positives and parse nullary enums,\n@@ -3816,7 +3800,7 @@ impl<'a> Parser<'a> {\n \n     fn is_union_item(&self) -> bool {\n         self.token.is_keyword(keywords::Union) &&\n-        self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword())\n+        self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n \n     fn is_defaultness(&self) -> bool {"}, {"sha": "834ac38af9870473db68bf4f2a3df298d655851e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -89,7 +89,7 @@ impl Lit {\n fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n     let ident_token: Token = Ident(ident);\n \n-    !ident_token.is_any_keyword() ||\n+    !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n         keywords::Do.name(),\n@@ -112,7 +112,7 @@ fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n fn ident_can_begin_type(ident: ast::Ident) -> bool {\n     let ident_token: Token = Ident(ident);\n \n-    !ident_token.is_any_keyword() ||\n+    !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n         keywords::For.name(),\n@@ -319,7 +319,7 @@ impl Token {\n \n     pub fn is_path_start(&self) -> bool {\n         self == &ModSep || self.is_qpath_start() || self.is_path() ||\n-        self.is_path_segment_keyword() || self.is_ident() && !self.is_any_keyword()\n+        self.is_path_segment_keyword() || self.is_ident() && !self.is_reserved_ident()\n     }\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n@@ -331,26 +331,31 @@ impl Token {\n         match self.ident() {\n             Some(id) => id.name == keywords::Super.name() ||\n                         id.name == keywords::SelfValue.name() ||\n-                        id.name == keywords::SelfType.name(),\n+                        id.name == keywords::SelfType.name() ||\n+                        id.name == keywords::DollarCrate.name(),\n             None => false,\n         }\n     }\n \n-    /// Returns `true` if the token is either a strict or reserved keyword.\n-    pub fn is_any_keyword(&self) -> bool {\n-        self.is_strict_keyword() || self.is_reserved_keyword()\n+    // Returns true for reserved identifiers used internally for elided lifetimes,\n+    // unnamed method parameters, crate root module, error recovery etc.\n+    pub fn is_special_ident(&self) -> bool {\n+        match self.ident() {\n+            Some(id) => id.name <= keywords::DollarCrate.name(),\n+            _ => false,\n+        }\n     }\n \n-    /// Returns `true` if the token is a strict keyword.\n-    pub fn is_strict_keyword(&self) -> bool {\n+    /// Returns `true` if the token is a keyword used in the language.\n+    pub fn is_used_keyword(&self) -> bool {\n         match self.ident() {\n             Some(id) => id.name >= keywords::As.name() && id.name <= keywords::While.name(),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n-    pub fn is_reserved_keyword(&self) -> bool {\n+    pub fn is_unused_keyword(&self) -> bool {\n         match self.ident() {\n             Some(id) => id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name(),\n             _ => false,\n@@ -410,6 +415,11 @@ impl Token {\n             Whitespace | Comment | Shebang(..) | Eof => return None,\n         })\n     }\n+\n+    /// Returns `true` if the token is either a special identifier or a keyword.\n+    pub fn is_reserved_ident(&self) -> bool {\n+        self.is_special_ident() || self.is_used_keyword() || self.is_unused_keyword()\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash)]"}, {"sha": "d449e412d6cc304fbb9d5c30cbc3da36d60c3661", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -760,7 +760,7 @@ pub trait PrintState<'a> {\n                         word(self.writer(), \"::\")?\n                     }\n                     if segment.identifier.name != keywords::CrateRoot.name() &&\n-                       segment.identifier.name != \"$crate\" {\n+                       segment.identifier.name != keywords::DollarCrate.name() {\n                         word(self.writer(), &segment.identifier.name.as_str())?;\n                     }\n                 }\n@@ -2374,7 +2374,7 @@ impl<'a> State<'a> {\n                           -> io::Result<()>\n     {\n         if segment.identifier.name != keywords::CrateRoot.name() &&\n-           segment.identifier.name != \"$crate\" {\n+           segment.identifier.name != keywords::DollarCrate.name() {\n             self.print_ident(segment.identifier)?;\n             if let Some(ref parameters) = segment.parameters {\n                 self.print_path_parameters(parameters, colons_before_params)?;"}, {"sha": "86f5f42eac79614c5e74646b26754db314024a8d", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -52,7 +52,8 @@ struct Test {\n     path: Vec<Ident> ,\n     bench: bool,\n     ignore: bool,\n-    should_panic: ShouldPanic\n+    should_panic: ShouldPanic,\n+    allow_fail: bool,\n }\n \n struct TestCtxt<'a> {\n@@ -133,7 +134,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                         path: self.cx.path.clone(),\n                         bench: is_bench_fn(&self.cx, &i),\n                         ignore: is_ignored(&i),\n-                        should_panic: should_panic(&i, &self.cx)\n+                        should_panic: should_panic(&i, &self.cx),\n+                        allow_fail: is_allowed_fail(&i),\n                     };\n                     self.cx.testfns.push(test);\n                     self.tests.push(i.ident);\n@@ -383,6 +385,10 @@ fn is_ignored(i: &ast::Item) -> bool {\n     i.attrs.iter().any(|attr| attr.check_name(\"ignore\"))\n }\n \n+fn is_allowed_fail(i: &ast::Item) -> bool {\n+    i.attrs.iter().any(|attr| attr.check_name(\"allow_fail\"))\n+}\n+\n fn should_panic(i: &ast::Item, cx: &TestCtxt) -> ShouldPanic {\n     match i.attrs.iter().find(|attr| attr.check_name(\"should_panic\")) {\n         Some(attr) => {\n@@ -668,14 +674,16 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n             }\n         }\n     };\n+    let allow_fail_expr = ecx.expr_bool(span, test.allow_fail);\n \n     // self::test::TestDesc { ... }\n     let desc_expr = ecx.expr_struct(\n         span,\n         test_path(\"TestDesc\"),\n         vec![field(\"name\", name_expr),\n              field(\"ignore\", ignore_expr),\n-             field(\"should_panic\", fail_expr)]);\n+             field(\"should_panic\", fail_expr),\n+             field(\"allow_fail\", allow_fail_expr)]);\n \n \n     let mut visible_path = match cx.toplevel_reexport {"}, {"sha": "35a2a2513f4e250264e2e8642bb18c8e9b2bc5ce", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -167,7 +167,7 @@ fn cs_clone(name: &str,\n             all_fields = af;\n             vdata = vdata_;\n         }\n-        EnumMatching(_, variant, ref af) => {\n+        EnumMatching(.., variant, ref af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.node.name]);\n             all_fields = af;\n             vdata = &variant.node.data;"}, {"sha": "38ed596098b2123e83618ca7b296c0e137ccb250", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -60,7 +60,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n     // based on the \"shape\".\n     let (ident, is_struct) = match *substr.fields {\n         Struct(vdata, _) => (substr.type_ident, vdata.is_struct()),\n-        EnumMatching(_, v, _) => (v.node.name, v.node.data.is_struct()),\n+        EnumMatching(_, _, v, _) => (v.node.name, v.node.data.is_struct()),\n         EnumNonMatchingCollapsed(..) |\n         StaticStruct(..) |\n         StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),"}, {"sha": "1e19cd994192e15a9b3ef634ebcfbde63122b35d", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -237,7 +237,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n                                      blk])\n         }\n \n-        EnumMatching(idx, variant, ref fields) => {\n+        EnumMatching(idx, _, variant, ref fields) => {\n             // We're not generating an AST that the borrow checker is expecting,\n             // so we need to generate a unique local variable to take the\n             // mutable loan out on, otherwise we get conflicts which don't"}, {"sha": "4acd65bbf8652cd0f1c216463b1fc6fff982240c", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -305,10 +305,10 @@ pub enum StaticFields {\n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n     Struct(&'a ast::VariantData, Vec<FieldInfo<'a>>),\n-    /// Matching variants of the enum: variant index, ast::Variant,\n+    /// Matching variants of the enum: variant index, variant count, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n-    EnumMatching(usize, &'a ast::Variant, Vec<FieldInfo<'a>>),\n+    EnumMatching(usize, usize, &'a ast::Variant, Vec<FieldInfo<'a>>),\n \n     /// Non-matching variants of the enum, but with all state hidden from\n     /// the consequent code.  The first component holds `Ident`s for all of\n@@ -1252,7 +1252,7 @@ impl<'a> MethodDef<'a> {\n                 // expressions for referencing every field of every\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n-                let substructure = EnumMatching(index, variant, field_tuples);\n+                let substructure = EnumMatching(index, variants.len(), variant, field_tuples);\n                 let arm_expr = self.call_substructure_method(cx,\n                                                              trait_,\n                                                              type_ident,\n@@ -1269,12 +1269,13 @@ impl<'a> MethodDef<'a> {\n                 // We need a default case that handles the fieldless variants.\n                 // The index and actual variant aren't meaningful in this case,\n                 // so just use whatever\n+                let substructure = EnumMatching(0, variants.len(), v, Vec::new());\n                 Some(self.call_substructure_method(cx,\n                                                    trait_,\n                                                    type_ident,\n                                                    &self_args[..],\n                                                    nonself_args,\n-                                                   &EnumMatching(0, v, Vec::new())))\n+                                                   &substructure))\n             }\n             _ if variants.len() > 1 && self_args.len() > 1 => {\n                 // Since we know that all the arguments will match if we reach"}, {"sha": "a341c21d0a126cbc5667a74fd58e7358c6a10993", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -81,7 +81,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n     let mut stmts = Vec::new();\n \n     let fields = match *substr.fields {\n-        Struct(_, ref fs) => fs,\n+        Struct(_, ref fs) | EnumMatching(_, 1, .., ref fs) => fs,\n         EnumMatching(.., ref fs) => {\n             let variant_value = deriving::call_intrinsic(cx,\n                                                          trait_span,"}, {"sha": "debac70545a99d0f2ff39c08f69bd3c006d753db", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -237,76 +237,76 @@ macro_rules! declare_keywords {(\n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n // of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n+// After modifying this list adjust `is_special_ident`, `is_used_keyword`/`is_unused_keyword`,\n // this should be rarely necessary though if the keywords are kept in alphabetic order.\n declare_keywords! {\n-    // Invalid identifier\n+    // Special reserved identifiers used internally for elided lifetimes,\n+    // unnamed method parameters, crate root module, error recovery etc.\n     (0,  Invalid,        \"\")\n-\n-    // Strict keywords used in the language.\n-    (1,  As,             \"as\")\n-    (2,  Box,            \"box\")\n-    (3,  Break,          \"break\")\n-    (4,  Const,          \"const\")\n-    (5,  Continue,       \"continue\")\n-    (6,  Crate,          \"crate\")\n-    (7,  Else,           \"else\")\n-    (8,  Enum,           \"enum\")\n-    (9,  Extern,         \"extern\")\n-    (10, False,          \"false\")\n-    (11, Fn,             \"fn\")\n-    (12, For,            \"for\")\n-    (13, If,             \"if\")\n-    (14, Impl,           \"impl\")\n-    (15, In,             \"in\")\n-    (16, Let,            \"let\")\n-    (17, Loop,           \"loop\")\n-    (18, Match,          \"match\")\n-    (19, Mod,            \"mod\")\n-    (20, Move,           \"move\")\n-    (21, Mut,            \"mut\")\n-    (22, Pub,            \"pub\")\n-    (23, Ref,            \"ref\")\n-    (24, Return,         \"return\")\n-    (25, SelfValue,      \"self\")\n-    (26, SelfType,       \"Self\")\n-    (27, Static,         \"static\")\n-    (28, Struct,         \"struct\")\n-    (29, Super,          \"super\")\n-    (30, Trait,          \"trait\")\n-    (31, True,           \"true\")\n-    (32, Type,           \"type\")\n-    (33, Unsafe,         \"unsafe\")\n-    (34, Use,            \"use\")\n-    (35, Where,          \"where\")\n-    (36, While,          \"while\")\n+    (1,  CrateRoot,      \"{{root}}\")\n+    (2,  DollarCrate,    \"$crate\")\n+\n+    // Keywords used in the language.\n+    (3,  As,             \"as\")\n+    (4,  Box,            \"box\")\n+    (5,  Break,          \"break\")\n+    (6,  Const,          \"const\")\n+    (7,  Continue,       \"continue\")\n+    (8,  Crate,          \"crate\")\n+    (9,  Else,           \"else\")\n+    (10, Enum,           \"enum\")\n+    (11, Extern,         \"extern\")\n+    (12, False,          \"false\")\n+    (13, Fn,             \"fn\")\n+    (14, For,            \"for\")\n+    (15, If,             \"if\")\n+    (16, Impl,           \"impl\")\n+    (17, In,             \"in\")\n+    (18, Let,            \"let\")\n+    (19, Loop,           \"loop\")\n+    (20, Match,          \"match\")\n+    (21, Mod,            \"mod\")\n+    (22, Move,           \"move\")\n+    (23, Mut,            \"mut\")\n+    (24, Pub,            \"pub\")\n+    (25, Ref,            \"ref\")\n+    (26, Return,         \"return\")\n+    (27, SelfValue,      \"self\")\n+    (28, SelfType,       \"Self\")\n+    (29, Static,         \"static\")\n+    (30, Struct,         \"struct\")\n+    (31, Super,          \"super\")\n+    (32, Trait,          \"trait\")\n+    (33, True,           \"true\")\n+    (34, Type,           \"type\")\n+    (35, Unsafe,         \"unsafe\")\n+    (36, Use,            \"use\")\n+    (37, Where,          \"where\")\n+    (38, While,          \"while\")\n \n     // Keywords reserved for future use.\n-    (37, Abstract,       \"abstract\")\n-    (38, Alignof,        \"alignof\")\n-    (39, Become,         \"become\")\n-    (40, Do,             \"do\")\n-    (41, Final,          \"final\")\n-    (42, Macro,          \"macro\")\n-    (43, Offsetof,       \"offsetof\")\n-    (44, Override,       \"override\")\n-    (45, Priv,           \"priv\")\n-    (46, Proc,           \"proc\")\n-    (47, Pure,           \"pure\")\n-    (48, Sizeof,         \"sizeof\")\n-    (49, Typeof,         \"typeof\")\n-    (50, Unsized,        \"unsized\")\n-    (51, Virtual,        \"virtual\")\n-    (52, Yield,          \"yield\")\n+    (39, Abstract,       \"abstract\")\n+    (40, Alignof,        \"alignof\")\n+    (41, Become,         \"become\")\n+    (42, Do,             \"do\")\n+    (43, Final,          \"final\")\n+    (44, Macro,          \"macro\")\n+    (45, Offsetof,       \"offsetof\")\n+    (46, Override,       \"override\")\n+    (47, Priv,           \"priv\")\n+    (48, Proc,           \"proc\")\n+    (49, Pure,           \"pure\")\n+    (50, Sizeof,         \"sizeof\")\n+    (51, Typeof,         \"typeof\")\n+    (52, Unsized,        \"unsized\")\n+    (53, Virtual,        \"virtual\")\n+    (54, Yield,          \"yield\")\n \n     // Weak keywords, have special meaning only in specific contexts.\n-    (53, Default,        \"default\")\n-    (54, StaticLifetime, \"'static\")\n-    (55, Union,          \"union\")\n-    (56, Catch,          \"catch\")\n-\n-    // A virtual keyword that resolves to the crate root when used in a lexical scope.\n-    (57, CrateRoot, \"{{root}}\")\n+    (55, Default,        \"default\")\n+    (56, StaticLifetime, \"'static\")\n+    (57, Union,          \"union\")\n+    (58, Catch,          \"catch\")\n }\n \n // If an interner exists in TLS, return it. Otherwise, prepare a fresh one."}, {"sha": "92cfb862b16691dafde886409044a087a9736780", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -212,6 +212,7 @@ pub struct TestDesc {\n     pub name: TestName,\n     pub ignore: bool,\n     pub should_panic: ShouldPanic,\n+    pub allow_fail: bool,\n }\n \n #[derive(Clone)]\n@@ -523,6 +524,7 @@ pub enum TestResult {\n     TrFailed,\n     TrFailedMsg(String),\n     TrIgnored,\n+    TrAllowedFail,\n     TrMetrics(MetricMap),\n     TrBench(BenchSamples),\n }\n@@ -543,6 +545,7 @@ struct ConsoleTestState<T> {\n     passed: usize,\n     failed: usize,\n     ignored: usize,\n+    allowed_fail: usize,\n     filtered_out: usize,\n     measured: usize,\n     metrics: MetricMap,\n@@ -572,6 +575,7 @@ impl<T: Write> ConsoleTestState<T> {\n             passed: 0,\n             failed: 0,\n             ignored: 0,\n+            allowed_fail: 0,\n             filtered_out: 0,\n             measured: 0,\n             metrics: MetricMap::new(),\n@@ -594,6 +598,10 @@ impl<T: Write> ConsoleTestState<T> {\n         self.write_short_result(\"ignored\", \"i\", term::color::YELLOW)\n     }\n \n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED (allowed)\", \"a\", term::color::YELLOW)\n+    }\n+\n     pub fn write_metric(&mut self) -> io::Result<()> {\n         self.write_pretty(\"metric\", term::color::CYAN)\n     }\n@@ -669,6 +677,7 @@ impl<T: Write> ConsoleTestState<T> {\n             TrOk => self.write_ok(),\n             TrFailed | TrFailedMsg(_) => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n+            TrAllowedFail => self.write_allowed_fail(),\n             TrMetrics(ref mm) => {\n                 self.write_metric()?;\n                 self.write_plain(&format!(\": {}\\n\", mm.fmt_metrics()))\n@@ -702,6 +711,7 @@ impl<T: Write> ConsoleTestState<T> {\n                         TrFailed => \"failed\".to_owned(),\n                         TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n                         TrIgnored => \"ignored\".to_owned(),\n+                        TrAllowedFail => \"failed (allowed)\".to_owned(),\n                         TrMetrics(ref mm) => mm.fmt_metrics(),\n                         TrBench(ref bs) => fmt_bench_samples(bs),\n                     },\n@@ -761,7 +771,8 @@ impl<T: Write> ConsoleTestState<T> {\n     }\n \n     pub fn write_run_finish(&mut self) -> io::Result<bool> {\n-        assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n+        assert!(self.passed + self.failed + self.ignored + self.measured +\n+                    self.allowed_fail == self.total);\n \n         if self.options.display_output {\n             self.write_outputs()?;\n@@ -778,12 +789,24 @@ impl<T: Write> ConsoleTestState<T> {\n         } else {\n             self.write_pretty(\"FAILED\", term::color::RED)?;\n         }\n-        let s = format!(\". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n-                        self.passed,\n-                        self.failed,\n-                        self.ignored,\n-                        self.measured,\n-                        self.filtered_out);\n+        let s = if self.allowed_fail > 0 {\n+            format!(\n+                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n+                self.passed,\n+                self.failed + self.allowed_fail,\n+                self.allowed_fail,\n+                self.ignored,\n+                self.measured,\n+                self.filtered_out)\n+        } else {\n+            format!(\n+                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n+                self.passed,\n+                self.failed,\n+                self.ignored,\n+                self.measured,\n+                self.filtered_out)\n+        };\n         self.write_plain(&s)?;\n         return Ok(success);\n     }\n@@ -891,6 +914,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                         st.not_failures.push((test, stdout));\n                     }\n                     TrIgnored => st.ignored += 1,\n+                    TrAllowedFail => st.allowed_fail += 1,\n                     TrMetrics(mm) => {\n                         let tname = test.name;\n                         let MetricMap(mm) = mm;\n@@ -945,12 +969,14 @@ fn should_sort_failures_before_printing_them() {\n         name: StaticTestName(\"a\"),\n         ignore: false,\n         should_panic: ShouldPanic::No,\n+        allow_fail: false,\n     };\n \n     let test_b = TestDesc {\n         name: StaticTestName(\"b\"),\n         ignore: false,\n         should_panic: ShouldPanic::No,\n+        allow_fail: false,\n     };\n \n     let mut st = ConsoleTestState {\n@@ -962,6 +988,7 @@ fn should_sort_failures_before_printing_them() {\n         passed: 0,\n         failed: 0,\n         ignored: 0,\n+        allowed_fail: 0,\n         filtered_out: 0,\n         measured: 0,\n         max_name_len: 10,\n@@ -1471,8 +1498,13 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any + Send>>) -> Tes\n                   .unwrap_or(false) {\n                 TrOk\n             } else {\n-                TrFailedMsg(format!(\"Panic did not include expected string '{}'\", msg))\n+                if desc.allow_fail {\n+                    TrAllowedFail\n+                } else {\n+                    TrFailedMsg(format!(\"Panic did not include expected string '{}'\", msg))\n+                }\n             },\n+        _ if desc.allow_fail => TrAllowedFail,\n         _ => TrFailed,\n     }\n }\n@@ -1706,6 +1738,7 @@ mod tests {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n+                allow_fail: false,\n             },\n             testfn: DynTestFn(Box::new(move |()| f())),\n         };\n@@ -1723,6 +1756,7 @@ mod tests {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n+                allow_fail: false,\n             },\n             testfn: DynTestFn(Box::new(move |()| f())),\n         };\n@@ -1742,6 +1776,7 @@ mod tests {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes,\n+                allow_fail: false,\n             },\n             testfn: DynTestFn(Box::new(move |()| f())),\n         };\n@@ -1761,6 +1796,7 @@ mod tests {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n+                allow_fail: false,\n             },\n             testfn: DynTestFn(Box::new(move |()| f())),\n         };\n@@ -1782,6 +1818,7 @@ mod tests {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_panic: ShouldPanic::YesWithMessage(expected),\n+                allow_fail: false,\n             },\n             testfn: DynTestFn(Box::new(move |()| f())),\n         };\n@@ -1799,6 +1836,7 @@ mod tests {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes,\n+                allow_fail: false,\n             },\n             testfn: DynTestFn(Box::new(move |()| f())),\n         };\n@@ -1832,6 +1870,7 @@ mod tests {\n                                  name: StaticTestName(\"1\"),\n                                  ignore: true,\n                                  should_panic: ShouldPanic::No,\n+                                 allow_fail: false,\n                              },\n                              testfn: DynTestFn(Box::new(move |()| {})),\n                          },\n@@ -1840,6 +1879,7 @@ mod tests {\n                                  name: StaticTestName(\"2\"),\n                                  ignore: false,\n                                  should_panic: ShouldPanic::No,\n+                                 allow_fail: false,\n                              },\n                              testfn: DynTestFn(Box::new(move |()| {})),\n                          }];\n@@ -1863,6 +1903,7 @@ mod tests {\n                     name: StaticTestName(name),\n                     ignore: false,\n                     should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n                 },\n                 testfn: DynTestFn(Box::new(move |()| {}))\n             })\n@@ -1944,6 +1985,7 @@ mod tests {\n                         name: DynTestName((*name).clone()),\n                         ignore: false,\n                         should_panic: ShouldPanic::No,\n+                        allow_fail: false,\n                     },\n                     testfn: DynTestFn(Box::new(move |()| testfn())),\n                 };"}, {"sha": "8e1b4fedfa4542e65f82fe124bd6433f3bd0aec5", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1 +1 @@\n-Subproject commit d8c9dfcc4f5289c09bab5736966feee2a0e69594\n+Subproject commit 8e1b4fedfa4542e65f82fe124bd6433f3bd0aec5"}, {"sha": "865cd45f708fb4034a6d2d59a305d5a93a0488ae", "filename": "src/rustllvm/.editorconfig", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Frustllvm%2F.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Frustllvm%2F.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2F.editorconfig?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,6 @@\n+[*.{h,cpp}]\n+end_of_line = lf\n+insert_final_newline = true\n+charset = utf-8\n+indent_style = space\n+indent_size = 2"}, {"sha": "7fb1eafb30da7faf58a55a4fb27be5eb7c481349", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 126, "deletions": 2, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,11 +10,14 @@\n \n #include <stdio.h>\n \n+#include <vector>\n+\n #include \"rustllvm.h\"\n \n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/Analysis/TargetTransformInfo.h\"\n #include \"llvm/IR/AutoUpgrade.h\"\n+#include \"llvm/IR/AssemblyAnnotationWriter.h\"\n #include \"llvm/Support/CBindingWrapping.h\"\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/Host.h\"\n@@ -503,8 +506,129 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n   return LLVMRustResult::Success;\n }\n \n+\n+// Callback to demangle function name\n+// Parameters:\n+// * name to be demangled\n+// * name len\n+// * output buffer\n+// * output buffer len\n+// Returns len of demangled string, or 0 if demangle failed.\n+typedef size_t (*DemangleFn)(const char*, size_t, char*, size_t);\n+\n+\n+namespace {\n+\n+class RustAssemblyAnnotationWriter : public AssemblyAnnotationWriter {\n+  DemangleFn Demangle;\n+  std::vector<char> Buf;\n+\n+public:\n+  RustAssemblyAnnotationWriter(DemangleFn Demangle) : Demangle(Demangle) {}\n+\n+  // Return empty string if demangle failed\n+  // or if name does not need to be demangled\n+  StringRef CallDemangle(StringRef name) {\n+    if (!Demangle) {\n+      return StringRef();\n+    }\n+\n+    if (Buf.size() < name.size() * 2) {\n+      // Semangled name usually shorter than mangled,\n+      // but allocate twice as much memory just in case\n+      Buf.resize(name.size() * 2);\n+    }\n+\n+    auto R = Demangle(name.data(), name.size(), Buf.data(), Buf.size());\n+    if (!R) {\n+      // Demangle failed.\n+      return StringRef();\n+    }\n+\n+    auto Demangled = StringRef(Buf.data(), R);\n+    if (Demangled == name) {\n+      // Do not print anything if demangled name is equal to mangled.\n+      return StringRef();\n+    }\n+\n+    return Demangled;\n+  }\n+\n+  void emitFunctionAnnot(const Function *F,\n+                         formatted_raw_ostream &OS) override {\n+    StringRef Demangled = CallDemangle(F->getName());\n+    if (Demangled.empty()) {\n+        return;\n+    }\n+\n+    OS << \"; \" << Demangled << \"\\n\";\n+  }\n+\n+  void emitInstructionAnnot(const Instruction *I,\n+                            formatted_raw_ostream &OS) override {\n+    const char *Name;\n+    const Value *Value;\n+    if (const CallInst *CI = dyn_cast<CallInst>(I)) {\n+      Name = \"call\";\n+      Value = CI->getCalledValue();\n+    } else if (const InvokeInst* II = dyn_cast<InvokeInst>(I)) {\n+      Name = \"invoke\";\n+      Value = II->getCalledValue();\n+    } else {\n+      // Could demangle more operations, e. g.\n+      // `store %place, @function`.\n+      return;\n+    }\n+\n+    if (!Value->hasName()) {\n+      return;\n+    }\n+\n+    StringRef Demangled = CallDemangle(Value->getName());\n+    if (Demangled.empty()) {\n+      return;\n+    }\n+\n+    OS << \"; \" << Name << \" \" << Demangled << \"\\n\";\n+  }\n+};\n+\n+class RustPrintModulePass : public ModulePass {\n+  raw_ostream* OS;\n+  DemangleFn Demangle;\n+public:\n+  static char ID;\n+  RustPrintModulePass() : ModulePass(ID), OS(nullptr), Demangle(nullptr) {}\n+  RustPrintModulePass(raw_ostream &OS, DemangleFn Demangle)\n+      : ModulePass(ID), OS(&OS), Demangle(Demangle) {}\n+\n+  bool runOnModule(Module &M) override {\n+    RustAssemblyAnnotationWriter AW(Demangle);\n+\n+    M.print(*OS, &AW, false);\n+\n+    return false;\n+  }\n+\n+  void getAnalysisUsage(AnalysisUsage &AU) const override {\n+    AU.setPreservesAll();\n+  }\n+\n+  static StringRef name() { return \"RustPrintModulePass\"; }\n+};\n+\n+} // namespace\n+\n+namespace llvm {\n+  void initializeRustPrintModulePassPass(PassRegistry&);\n+}\n+\n+char RustPrintModulePass::ID = 0;\n+INITIALIZE_PASS(RustPrintModulePass, \"print-rust-module\",\n+                \"Print rust module to stderr\", false, false)\n+\n extern \"C\" void LLVMRustPrintModule(LLVMPassManagerRef PMR, LLVMModuleRef M,\n-                                    const char *Path) {\n+                                    const char *Path, DemangleFn Demangle) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   std::string ErrorInfo;\n \n@@ -515,7 +639,7 @@ extern \"C\" void LLVMRustPrintModule(LLVMPassManagerRef PMR, LLVMModuleRef M,\n \n   formatted_raw_ostream FOS(OS);\n \n-  PM->add(createPrintModulePass(FOS));\n+  PM->add(new RustPrintModulePass(FOS, Demangle));\n \n   PM->run(*unwrap(M));\n }"}, {"sha": "37ba3264452650a19f6d47b819c2ac8a2e6adcde", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2017-06-19\n+2017-06-27"}, {"sha": "c5bf3a77b6c8f4ba27003646e6d176a3bab35c55", "filename": "src/test/compile-fail/E0604.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0604.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    1u32 as char; //~ ERROR E0604\n+}"}, {"sha": "add3fd8fd8ac28c1b81735672fa0b629a9a663bf", "filename": "src/test/compile-fail/E0605.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0605.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0605.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0605.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = 0u8;\n+    x as Vec<u8>; //~ ERROR E0605\n+                  //~| NOTE an `as` expression can only be used to convert between primitive types\n+\n+    let v = 0 as *const u8;\n+    v as &u8; //~ ERROR E0605\n+              //~| NOTE an `as` expression can only be used to convert between primitive types\n+}"}, {"sha": "55071736bfe51918241beb893a90e3193794e000", "filename": "src/test/compile-fail/E0606.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0606.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0606.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0606.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    &0u8 as u8; //~ ERROR E0606\n+}"}, {"sha": "fa761f2c17896149398c421df6984145b72df3b3", "filename": "src/test/compile-fail/E0607.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0607.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0607.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0607.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = 0 as *const u8;\n+    v as *const [u8]; //~ ERROR E0607\n+}"}, {"sha": "a5a5ff7218dcfe26150499924ba76594dfe2fded", "filename": "src/test/compile-fail/E0619.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0619.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0619.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0619.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x;\n+\n+    match x {\n+        (..) => {} //~ ERROR E0619\n+        _ => {}\n+    }\n+}\n+"}, {"sha": "5e945dfa5c8207e15b4b6915e4f7d08c8785fd6e", "filename": "src/test/compile-fail/E0620.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0620.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0620.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0620.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let _foo = &[1_usize, 2] as [usize]; //~ ERROR E0620\n+}"}, {"sha": "980461bedae55446604d8c635416d466aa1faf00", "filename": "src/test/compile-fail/E0621-does-not-trigger-for-closures.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0621-does-not-trigger-for-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0621-does-not-trigger-for-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0621-does-not-trigger-for-closures.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we give the generic E0495 when one of the free regions is\n+// bound in a closure (rather than suggesting a change to the signature\n+// of the closure, which is not specified in `foo` but rather in `invoke`).\n+\n+// FIXME - This might be better as a UI test, but the finer details\n+// of the error seem to vary on different machines.\n+fn invoke<'a, F>(x: &'a i32, f: F) -> &'a i32\n+where F: FnOnce(&'a i32, &i32) -> &'a i32\n+{\n+    let y = 22;\n+    f(x, &y)\n+}\n+\n+fn foo<'a>(x: &'a i32) {\n+    invoke(&x, |a, b| if a > b { a } else { b }); //~ ERROR E0495\n+}\n+\n+fn main() {}"}, {"sha": "f2bde5b03648be1db5d6f97e97103f7a17911150", "filename": "src/test/compile-fail/E0622.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0622.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2FE0622.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0622.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -11,6 +11,6 @@\n #![feature(intrinsics)]\n extern \"rust-intrinsic\" {\n     pub static breakpoint : unsafe extern \"rust-intrinsic\" fn();\n-    //~^ ERROR intrinsic has wrong type\n+    //~^ ERROR intrinsic must be a function [E0622]\n }\n-fn main() { unsafe { breakpoint(); } }\n\\ No newline at end of file\n+fn main() { unsafe { breakpoint(); } }", "previous_filename": "src/test/compile-fail/invalid-intrinsic.rs"}, {"sha": "d62f6b0f1a37140aa870e30cbcc5313533396926", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -38,11 +38,13 @@ pub fn f1_int_uint() {\n pub fn f1_uint_uint() {\n     f1(2u32, 4u32);\n     //~^ ERROR `u32: Foo` is not satisfied\n+    //~| ERROR `u32: Foo` is not satisfied\n }\n \n pub fn f1_uint_int() {\n     f1(2u32, 4i32);\n     //~^ ERROR `u32: Foo` is not satisfied\n+    //~| ERROR `u32: Foo` is not satisfied\n }\n \n pub fn f2_int() {"}, {"sha": "ab22d352480739d3fe27520993523b4df654acf5", "filename": "src/test/compile-fail/cast-from-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: non-scalar cast: `()` as `u32`\n+// error-pattern: non-primitive cast: `()` as `u32`\n fn main() { let u = (assert!(true) as u32); }"}, {"sha": "d5a998c6e4b6b944884c6135beac62f29cf74742", "filename": "src/test/compile-fail/cast-to-bare-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -13,8 +13,8 @@ fn foo(_x: isize) { }\n fn main() {\n     let v: u64 = 5;\n     let x = foo as extern \"C\" fn() -> isize;\n-    //~^ ERROR non-scalar cast\n+    //~^ ERROR non-primitive cast\n     let y = v as extern \"Rust\" fn(isize) -> (isize, isize);\n-    //~^ ERROR non-scalar cast\n+    //~^ ERROR non-primitive cast\n     y(x());\n }"}, {"sha": "27d9e8a42b188c58759ff50ac7410f893d33cf65", "filename": "src/test/compile-fail/cast-to-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: non-scalar cast: `u32` as `()`\n+// error-pattern: non-primitive cast: `u32` as `()`\n fn main() { let u = 0u32 as (); }"}, {"sha": "6584c16c9dec67cfdbb3d6966dcb56d6ada51b10", "filename": "src/test/compile-fail/closure-no-fn-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,5 +14,5 @@\n fn main() {\n     let b = 0u8;\n     let baz: fn() -> u8 = (|| { b }) as fn() -> u8;\n-    //~^ ERROR non-scalar cast\n+    //~^ ERROR non-primitive cast\n }"}, {"sha": "0479f5cce65379ed73bd43b46f1356bde316f564", "filename": "src/test/compile-fail/coerce-to-bang-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -17,7 +17,7 @@ fn cast_a() {\n }\n \n fn cast_b() {\n-    let y = 22 as !; //~ ERROR non-scalar cast\n+    let y = 22 as !; //~ ERROR non-primitive cast\n }\n \n fn main() { }"}, {"sha": "e221fc6e9e055503a941d42720aabdc0cfe8601e", "filename": "src/test/compile-fail/dollar-crate-is-keyword-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {}\n+\n+macro_rules! m {\n+    () => {\n+        use a::$crate; //~ ERROR unresolved import `a::$crate`\n+        use a::$crate::b; //~ ERROR unresolved import `a::$crate::b`\n+        type A = a::$crate; //~ ERROR cannot find type `$crate` in module `a`\n+    }\n+}\n+\n+m!();\n+\n+fn main() {}"}, {"sha": "70597a230a886f53365e53bed3db763d7e51ff1b", "filename": "src/test/compile-fail/dollar-crate-is-keyword.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! m {\n+    () => {\n+        struct $crate {} //~ ERROR expected identifier, found reserved identifier `$crate`\n+\n+        use $crate; // OK\n+                    //~^ WARN `$crate` may not be imported\n+        use $crate as $crate; //~ ERROR expected identifier, found reserved identifier `$crate`\n+                              //~^ WARN `$crate` may not be imported\n+    }\n+}\n+\n+m!();\n+\n+fn main() {}"}, {"sha": "1c3bad5ba56434357fd5e9eef7588ef058f70e13", "filename": "src/test/compile-fail/dst-bad-assign-3.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Forbid assignment into a dynamically sized type.\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+//~^ WARNING trait bounds are not (yet) enforced\n+\n+#[derive(PartialEq,Eq)]\n+struct Bar;\n+\n+#[derive(PartialEq,Eq)]\n+struct Bar1 {\n+    f: isize\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> isize;\n+}\n+\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> isize {\n+        self.f\n+    }\n+}\n+\n+pub fn main() {\n+    // Assignment.\n+    let f5: &mut Fat<ToBar> = &mut (5, \"some str\", Bar1 {f :42});\n+    let z: Box<ToBar> = Box::new(Bar1 {f: 36});\n+    f5.2 = Bar1 {f: 36};\n+    //~^ ERROR mismatched types\n+    //~| expected type `ToBar`\n+    //~| found type `Bar1`\n+    //~| expected trait ToBar, found struct `Bar1`\n+    //~| ERROR `ToBar: std::marker::Sized` is not satisfied\n+}"}, {"sha": "b0de84a53007258bd394517b85cc4d58c4a1f7b7", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,6 +10,8 @@\n \n // Attempt to change the type as well as unsizing.\n \n+#![feature(unsized_tuple_coercion)]\n+\n struct Fat<T: ?Sized> {\n     ptr: T\n }\n@@ -29,4 +31,16 @@ pub fn main() {\n     let f2: &Fat<Foo> = &f1;\n     let f3: &Fat<Bar> = f2;\n     //~^ ERROR `Foo: Bar` is not satisfied\n+\n+    // Tuple with a vec of isize.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1;\n+    let f3: &([usize],) = f2;\n+    //~^ ERROR mismatched types\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1;\n+    let f3: &(Bar,) = f2;\n+    //~^ ERROR `Foo: Bar` is not satisfied\n }"}, {"sha": "9e92f649b2d5696acd2d8d67fbddf0bed421eca6", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -28,4 +28,14 @@ pub fn main() {\n     let f1 = Fat { ptr: Foo };\n     let f2: &Fat<Foo> = &f1;\n     let f3: &mut Fat<Bar> = f2; //~ ERROR mismatched types\n+\n+    // Tuple with a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1;\n+    let f3: &mut ([isize],) = f2; //~ ERROR mismatched types\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1;\n+    let f3: &mut (Bar,) = f2; //~ ERROR mismatched types\n }"}, {"sha": "35a147c15bb433beb6baf7f168a3b98dbb4d3af5", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,6 +10,8 @@\n \n // Attempt to extend the lifetime as well as unsizing.\n \n+#![feature(unsized_tuple_coercion)]\n+\n struct Fat<T: ?Sized> {\n     ptr: T\n }\n@@ -28,6 +30,16 @@ fn baz<'a>() {\n     let f1 = Fat { ptr: Foo };\n     let f2: &Fat<Foo> = &f1; //~ ERROR `f1` does not live long enough\n     let f3: &'a Fat<Bar> = f2;\n+\n+    // Tuple with a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a ([isize],) = f2;\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a (Bar,) = f2;\n }\n \n pub fn main() {"}, {"sha": "874b7588ff9bb572a2a01530c48ac43389568d25", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,6 +10,8 @@\n \n // Attempt to coerce from unsized to sized.\n \n+#![feature(unsized_tuple_coercion)]\n+\n struct Fat<T: ?Sized> {\n     ptr: T\n }\n@@ -22,4 +24,12 @@ pub fn main() {\n     //~| expected type `&Fat<[isize; 3]>`\n     //~| found type `&Fat<[isize]>`\n     //~| expected array of 3 elements, found slice\n+\n+    // Tuple with a vec of isizes.\n+    let f1: &([isize],) = &([1, 2, 3],);\n+    let f2: &([isize; 3],) = f1;\n+    //~^ ERROR mismatched types\n+    //~| expected type `&([isize; 3],)`\n+    //~| found type `&([isize],)`\n+    //~| expected array of 3 elements, found slice\n }"}, {"sha": "0c812b1d815ab000da92254d3c9cf6d4affb9a6e", "filename": "src/test/compile-fail/dst-bad-deep-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Try to initialise a DST struct where the lost information is deeply nested.\n+// This is an error because it requires an unsized rvalue. This is a problem\n+// because it would require stack allocation of an unsized temporary (*g in the\n+// test).\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+pub fn main() {\n+    let f: ([isize; 3],) = ([5, 6, 7],);\n+    let g: &([isize],) = &f;\n+    let h: &(([isize],),) = &(*g,);\n+    //~^ ERROR `[isize]: std::marker::Sized` is not satisfied\n+}"}, {"sha": "bc2dc1cc5d4c83923f349f8062462af9bc79f020", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -22,7 +22,7 @@ fn main() {\n     a as isize; //~ ERROR casting\n     a as i16; //~ ERROR casting `&[i32]` as `i16` is invalid\n     a as u32; //~ ERROR casting `&[i32]` as `u32` is invalid\n-    b as usize; //~ ERROR non-scalar cast\n+    b as usize; //~ ERROR non-primitive cast\n     p as usize;\n     //~^ ERROR casting\n     //~^^ HELP cast through a thin pointer"}, {"sha": "1124740280960de2f7a63106294cec0df364f7b4", "filename": "src/test/compile-fail/feature-gate-allow_fail.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow_fail.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that #[allow_fail] is feature-gated\n+\n+#[allow_fail] //~ ERROR allow_fail attribute is currently unstable\n+fn ok_to_fail() {\n+    assert!(false);\n+}\n+"}, {"sha": "4ddde01126363524b22040d662bd5d792d28a411", "filename": "src/test/compile-fail/feature-gate-unsized_tuple_coercion.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unsized_tuple_coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unsized_tuple_coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unsized_tuple_coercion.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let _ : &(Send,) = &((),);\n+    //~^ ERROR Unsized tuple coercion is not stable enough\n+}"}, {"sha": "2d00f339f33a066607fbf6eee018501ce5557422", "filename": "src/test/compile-fail/issue-10991.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let nil = ();\n-    let _t = nil as usize; //~ ERROR: non-scalar cast: `()` as `usize`\n+    let _t = nil as usize; //~ ERROR: non-primitive cast: `()` as `usize`\n }"}, {"sha": "c23fc4f334472bee36f321981f2e44078bc71d83", "filename": "src/test/compile-fail/issue-22289.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0 as &std::any::Any; //~ ERROR non-scalar cast\n+    0 as &std::any::Any; //~ ERROR non-primitive cast\n }"}, {"sha": "2128c4206301b3848968c48eb9db804b5a75a17e", "filename": "src/test/compile-fail/issue-22312.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -19,7 +19,7 @@ pub trait Array2D: Index<usize> {\n         }\n         let i = y * self.columns() + x;\n         let indexer = &(*self as &Index<usize, Output = <Self as Index<usize>>::Output>);\n-        //~^ERROR non-scalar cast\n+        //~^ERROR non-primitive cast\n         Some(indexer.index(i))\n     }\n }"}, {"sha": "129f7c8b1ea0eb8b203f45b4f5f15dc6262bb295", "filename": "src/test/compile-fail/issue-23046.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -24,7 +24,7 @@ pub fn let_<'var, VAR, F: for<'v: 'var> Fn(Expr<'v, VAR>) -> Expr<'v, VAR>>\n }\n \n fn main() {\n-    let ex = |x| {\n-        let_(add(x,x), |y| { //~ ERROR type annotations needed\n+    let ex = |x| { //~ ERROR type annotations needed\n+        let_(add(x,x), |y| {\n             let_(add(x, x), |x|x)})};\n }"}, {"sha": "d735e184d5cd568f3c0461d11e9bebb8e9b483b4", "filename": "src/test/compile-fail/issue-2995.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn bad (p: *const isize) {\n-    let _q: &isize = p as &isize; //~ ERROR non-scalar cast\n+    let _q: &isize = p as &isize; //~ ERROR non-primitive cast\n }\n \n fn main() { }"}, {"sha": "896728b6da0f1df15d6b1a26f692556cd869f3cc", "filename": "src/test/compile-fail/issue-38954.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-38954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-38954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-38954.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n fn _test(ref _p: str) {}\n+//~^ ERROR the trait bound `str: std::marker::Sized` is not satisfied [E0277]\n \n-#[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "06573b42b592db5c0dd61dc9ce62f311e39af538", "filename": "src/test/compile-fail/issue-42312.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-42312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-42312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-42312.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub trait Foo {\n+    fn baz(_: Self::Target) where Self: Deref {}\n+    //~^ ERROR `<Self as std::ops::Deref>::Target: std::marker::Sized` is not satisfied\n+}\n+\n+pub fn f(_: ToString) {}\n+//~^ ERROR the trait bound `std::string::ToString + 'static: std::marker::Sized` is not satisfied\n+\n+fn main() { }"}, {"sha": "ebb1ec425d1da8bc3423704a50602255591432d9", "filename": "src/test/compile-fail/issue-42880.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-42880.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fissue-42880.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-42880.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type Value = String;\n+\n+fn main() {\n+    let f = |&Value::String(_)| (); //~ ERROR no associated item named\n+\n+    let vec: Vec<Value> = Vec::new();\n+    vec.last().map(f);\n+}"}, {"sha": "0abbc05eef05dd7b84bcd578b3ef6413001c2ed1", "filename": "src/test/compile-fail/nonscalar-cast.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:non-scalar cast\n-\n #[derive(Debug)]\n struct foo {\n     x: isize\n }\n \n fn main() {\n-    println!(\"{}\", foo{ x: 1 } as isize);\n+    println!(\"{}\", foo{ x: 1 } as isize); //~ non-primitive cast: `foo` as `isize` [E0605]\n }"}, {"sha": "15375936b898c80de754ba8191984790bda0e5e4", "filename": "src/test/compile-fail/on-unimplemented/multiple-impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -44,12 +44,18 @@ fn main() {\n     //~^ ERROR E0277\n     //~| NOTE trait message\n     //~| NOTE required by\n+    //~| ERROR E0277\n+    //~| NOTE trait message\n     Index::index(&[] as &[i32], Foo(2u32));\n     //~^ ERROR E0277\n     //~| NOTE on impl for Foo\n     //~| NOTE required by\n+    //~| ERROR E0277\n+    //~| NOTE on impl for Foo\n     Index::index(&[] as &[i32], Bar(2u32));\n     //~^ ERROR E0277\n     //~| NOTE on impl for Bar\n     //~| NOTE required by\n+    //~| ERROR E0277\n+    //~| NOTE on impl for Bar\n }"}, {"sha": "66d612baab4e8648b80a6275cf9c318e8aba0988", "filename": "src/test/compile-fail/on-unimplemented/on-impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -33,4 +33,6 @@ fn main() {\n     //~^ ERROR E0277\n     //~| NOTE a usize is required\n     //~| NOTE required by\n+    //~| ERROR E0277\n+    //~| NOTE a usize is required\n }"}, {"sha": "afb2cbb7db397395619453d0c9c2c98a23899f1d", "filename": "src/test/compile-fail/patkind-litrange-no-expr.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fpatkind-litrange-no-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fpatkind-litrange-no-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpatkind-litrange-no-expr.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! enum_number {\n+    ($name:ident { $($variant:ident = $value:expr, )* }) => {\n+        enum $name {\n+            $($variant = $value,)*\n+        }\n+\n+        fn foo(value: i32) -> Option<$name> {\n+            match value {\n+                $( $value => Some($name::$variant), )* // PatKind::Lit\n+                $( $value ... 42 => Some($name::$variant), )* // PatKind::Range\n+                _ => None\n+            }\n+        }\n+    }\n+}\n+\n+enum_number!(Change {\n+    Pos = 1,\n+    Neg = -1,\n+    Arith = 1 + 1, //~ ERROR arbitrary expressions aren't allowed in patterns\n+                   //~^ ERROR arbitrary expressions aren't allowed in patterns\n+                   //~^^ ERROR only char and numeric types are allowed in range patterns\n+});\n+\n+fn main() {}\n+"}, {"sha": "220537633eaf12291d6f99b18df7af814b5e90b3", "filename": "src/test/compile-fail/tag-variant-cast-non-nullary.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Ftag-variant-cast-non-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Ftag-variant-cast-non-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-variant-cast-non-nullary.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern: non-scalar cast\n-\n enum non_nullary {\n     nullary,\n     other(isize),\n }\n \n fn main() {\n     let v = non_nullary::nullary;\n-    let val = v as isize;\n+    let val = v as isize; //~ ERROR non-primitive cast: `non_nullary` as `isize` [E0605]\n }"}, {"sha": "2a5d25e6b98dd0497286a83883c518c64a5ceef0", "filename": "src/test/compile-fail/uninhabited-enum-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -11,7 +11,7 @@\n enum E {}\n \n fn f(e: E) {\n-    println!(\"{}\", (e as isize).to_string());   //~ ERROR non-scalar cast\n+    println!(\"{}\", (e as isize).to_string());   //~ ERROR non-primitive cast\n }\n \n fn main() {}"}, {"sha": "e96e0ea3aec3623ec0d57b2a3e4aae3927c2adaf", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -54,6 +54,7 @@ fn f9<X: ?Sized>(x1: Box<S<X>>) {\n fn f10<X: ?Sized>(x1: Box<S<X>>) {\n     f5(&(32, *x1));\n     //~^ ERROR `X: std::marker::Sized` is not satisfied\n+    //~| ERROR `X: std::marker::Sized` is not satisfied\n }\n \n pub fn main() {"}, {"sha": "6b5286bf0a7da9e969f4704714fa5b08e59727ef", "filename": "src/test/compile-fail/use-self-type.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fuse-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fuse-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-self-type.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    fn f() {}\n+    fn g() {\n+        use Self::f; //~ ERROR unresolved import\n+        pub(in Self::f) struct Z; //~ ERROR Use of undeclared type or module `Self`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9b88e38e085546feb68ef1435e7aa7a66334b182", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,13 +14,11 @@\n // Check that bounds on type parameters (other than `Self`) do not\n // influence variance.\n \n-#[rustc_variance]\n-trait Getter<T> { //~ ERROR [o, o]\n+trait Getter<T> {\n     fn get(&self) -> T;\n }\n \n-#[rustc_variance]\n-trait Setter<T> { //~ ERROR [o, o]\n+trait Setter<T> {\n     fn get(&self, T);\n }\n \n@@ -34,20 +32,6 @@ enum TestEnum<U,T:Setter<U>> { //~ ERROR [*, +]\n     Foo(T)\n }\n \n-#[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR [o, o, o]\n-    fn getter(&self, u: U) -> T;\n-}\n-\n-#[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR [o, o]\n-}\n-\n-#[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR [o, o]\n-    fn getter<T:Getter<U>>(&self);\n-}\n-\n #[rustc_variance]\n struct TestContraStruct<U,T:Setter<U>> { //~ ERROR [*, +]\n     t: T"}, {"sha": "5075dd2ceedc093ba972f70c5d952e6332bdc508", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -36,37 +36,14 @@ struct TestIndirect2<A:'static, B:'static> { //~ ERROR [o, o]\n     m: TestMut<B, A>\n }\n \n-#[rustc_variance]\n-trait Getter<A> { //~ ERROR [o, o]\n+trait Getter<A> {\n     fn get(&self) -> A;\n }\n \n-#[rustc_variance]\n-trait Setter<A> { //~ ERROR [o, o]\n-    fn set(&mut self, a: A);\n-}\n-\n-#[rustc_variance]\n-trait GetterSetter<A> { //~ ERROR [o, o]\n-    fn get(&self) -> A;\n+trait Setter<A> {\n     fn set(&mut self, a: A);\n }\n \n-#[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR [o, o]\n-    // Here, the use of `A` in the method bound *does* affect\n-    // variance.  Think of it as if the method requested a dictionary\n-    // for `T:Getter<A>`.  Since this dictionary is an input, it is\n-    // contravariant, and the Getter is covariant w/r/t A, yielding an\n-    // overall contravariant result.\n-    fn do_it<T:Getter<A>>(&self);\n-}\n-\n-#[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR [o, o]\n-    fn do_it<T:Setter<A>>(&self);\n-}\n-\n #[rustc_variance]\n struct TestObject<A, R> { //~ ERROR [o, o]\n     n: Box<Setter<A>+Send>,"}, {"sha": "c7dcaf4137e5d6cc752080e8b9a90e3db1ddf882", "filename": "src/test/parse-fail/macro-keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-fn macro() {  //~ ERROR `macro` is a reserved keyword\n+fn macro() {  //~ ERROR expected identifier, found reserved keyword `macro`\n }\n \n pub fn main() {"}, {"sha": "a75dc7e57a9a265526af8b83134ee1b4dc0581e0", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -85,6 +85,6 @@ fn main() {\n     let (result, _) = rustc_driver::run_compiler(\n         &args, &mut JitCalls, Some(box JitLoader), None);\n     if let Err(n) = result {\n-        panic!(\"Error {}\", n);\n+        panic!(\"Error {:?}\", n);\n     }\n }"}, {"sha": "1ae66a28a849ea4fa85c5810dc0ce1e100219d97", "filename": "src/test/run-pass-valgrind/dst-dtor-3.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-3.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+static mut DROP_RAN: bool = false;\n+\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        unsafe { DROP_RAN = true; }\n+    }\n+}\n+\n+trait Trait { fn dummy(&self) { } }\n+impl Trait for Foo {}\n+\n+pub fn main() {\n+    {\n+        let _x: Box<(i32, Trait)> = Box::<(i32, Foo)>::new((42, Foo));\n+    }\n+    unsafe {\n+        assert!(DROP_RAN);\n+    }\n+}"}, {"sha": "e416f25bc03a0141ae35f566316f565a060bb6c6", "filename": "src/test/run-pass-valgrind/dst-dtor-4.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-4.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+static mut DROP_RAN: isize = 0;\n+\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        unsafe { DROP_RAN += 1; }\n+    }\n+}\n+\n+pub fn main() {\n+    {\n+        let _x: Box<(i32, [Foo])> = Box::<(i32, [Foo; 3])>::new((42, [Foo, Foo, Foo]));\n+    }\n+    unsafe {\n+        assert_eq!(DROP_RAN, 3);\n+    }\n+}"}, {"sha": "7cc547dcc04e25860c3e495fb88b64a50aa3d469", "filename": "src/test/run-pass/allocator-alloc-one.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(alloc, allocator_api, heap_api, unique)]\n+\n+extern crate alloc;\n+\n+use alloc::heap::HeapAlloc;\n+use alloc::allocator::Alloc;\n+\n+fn main() {\n+    unsafe {\n+        let ptr = HeapAlloc.alloc_one::<i32>().unwrap_or_else(|e| {\n+            HeapAlloc.oom(e)\n+        });\n+        *ptr.as_ptr() = 4;\n+        assert_eq!(*ptr.as_ptr(), 4);\n+        HeapAlloc.dealloc_one(ptr);\n+    }\n+}"}, {"sha": "d8d42f2cba281c5cc75095f97d19633fe9cfae43", "filename": "src/test/run-pass/associated-types-sugar-path.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -15,8 +15,6 @@ use std::ops::Deref;\n pub trait Foo {\n     type A;\n     fn boo(&self) -> Self::A;\n-\n-    fn baz(_: Self::Target) where Self: Deref {}\n }\n \n impl Foo for isize {"}, {"sha": "18b2fbe015b425ee89c4c4cb87242fbf975a022a", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -45,8 +45,8 @@ impl<'a> Hasher for FakeHasher<'a> {\n     }\n }\n \n-fn fake_hash(v: &mut Vec<u8>, e: E) {\n-    e.hash(&mut FakeHasher(v));\n+fn fake_hash<A: Hash>(v: &mut Vec<u8>, a: A) {\n+    a.hash(&mut FakeHasher(v));\n }\n \n fn main() {\n@@ -69,4 +69,13 @@ fn main() {\n     fake_hash(&mut va, E::A);\n     fake_hash(&mut vb, E::B);\n     assert!(va != vb);\n+\n+    // issue #39137: single variant enum hash should not hash discriminant\n+    #[derive(Hash)]\n+    enum SingleVariantEnum {\n+        A(u8),\n+    }\n+    let mut v = vec![];\n+    fake_hash(&mut v, SingleVariantEnum::A(17));\n+    assert_eq!(vec![17], v);\n }"}, {"sha": "b1d6c732e7fbb0a9caecb48a8733a84cd11751ff", "filename": "src/test/run-pass/dst-irrefutable-bind.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unsized_tuple_coercion)]\n+\n struct Test<T: ?Sized>(T);\n \n fn main() {\n@@ -21,4 +23,14 @@ fn main() {\n     let slice = &[1,2,3];\n     let x = Test(&slice);\n     let Test(&_slice) = x;\n+\n+\n+    let x = (10, [1,2,3]);\n+    let x : &(i32, [i32]) = &x;\n+\n+    let & ref _y = x;\n+\n+    let slice = &[1,2,3];\n+    let x = (10, &slice);\n+    let (_, &_slice) = x;\n }"}, {"sha": "9ebfbee8a330213363a9906b518d9685cf13694e", "filename": "src/test/run-pass/dst-raw.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-raw.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -11,6 +11,8 @@\n // Test DST raw pointers\n \n \n+#![feature(unsized_tuple_coercion)]\n+\n trait Trait {\n     fn foo(&self) -> isize;\n }\n@@ -45,6 +47,14 @@ pub fn main() {\n     };\n     assert_eq!(r, 42);\n \n+    // raw DST tuple\n+    let p = (A { f: 42 },);\n+    let o: *const (Trait,) = &p;\n+    let r = unsafe {\n+        (&*o).0.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n     // raw slice\n     let a: *const [_] = &[1, 2, 3];\n     unsafe {\n@@ -72,6 +82,15 @@ pub fn main() {\n         assert_eq!(len, 3);\n     }\n \n+    // raw DST tuple with slice\n+    let c: *const ([_],) = &([1, 2, 3],);\n+    unsafe {\n+        let b = (&*c).0[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).0.len();\n+        assert_eq!(len, 3);\n+    }\n+\n     // all of the above with *mut\n     let mut x = A { f: 42 };\n     let z: *mut Trait = &mut x;\n@@ -87,6 +106,13 @@ pub fn main() {\n     };\n     assert_eq!(r, 42);\n \n+    let mut p = (A { f: 42 },);\n+    let o: *mut (Trait,) = &mut p;\n+    let r = unsafe {\n+        (&*o).0.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n     let a: *mut [_] = &mut [1, 2, 3];\n     unsafe {\n         let b = (*a)[2];\n@@ -110,4 +136,12 @@ pub fn main() {\n         let len = (&*c).f.len();\n         assert_eq!(len, 3);\n     }\n+\n+    let c: *mut ([_],) = &mut ([1, 2, 3],);\n+    unsafe {\n+        let b = (&*c).0[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).0.len();\n+        assert_eq!(len, 3);\n+    }\n }"}, {"sha": "9803e26f5f8591a47cad98b813f10702b1100de1", "filename": "src/test/run-pass/dst-trait-tuple.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(unused_features)]\n+#![feature(box_syntax)]\n+#![feature(unsized_tuple_coercion)]\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+struct Bar1 {\n+    f: isize\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> isize;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+    fn to_val(&self) -> isize {\n+        0\n+    }\n+}\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> isize {\n+        self.f\n+    }\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<ToBar>) {\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!(x.2.to_bar(), Bar);\n+    assert_eq!(x.2.to_val(), 42);\n+\n+    let y = &x.2;\n+    assert_eq!(y.to_bar(), Bar);\n+    assert_eq!(y.to_val(), 42);\n+}\n+\n+fn bar(x: &ToBar) {\n+    assert_eq!(x.to_bar(), Bar);\n+    assert_eq!(x.to_val(), 42);\n+}\n+\n+fn baz(x: &Fat<Fat<ToBar>>) {\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!((x.2).0, 8);\n+    assert_eq!((x.2).1, \"deep str\");\n+    assert_eq!((x.2).2.to_bar(), Bar);\n+    assert_eq!((x.2).2.to_val(), 42);\n+\n+    let y = &(x.2).2;\n+    assert_eq!(y.to_bar(), Bar);\n+    assert_eq!(y.to_val(), 42);\n+\n+}\n+\n+pub fn main() {\n+    let f1 = (5, \"some str\", Bar1 {f :42});\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<ToBar> = f2;\n+    foo(f3);\n+    let f4: &Fat<ToBar> = &f1;\n+    foo(f4);\n+    let f5: &Fat<ToBar> = &(5, \"some str\", Bar1 {f :42});\n+    foo(f5);\n+\n+    // Zero size object.\n+    let f6: &Fat<ToBar> = &(5, \"some str\", Bar);\n+    assert_eq!(f6.2.to_bar(), Bar);\n+\n+    // &*\n+    //\n+    let f7: Box<ToBar> = Box::new(Bar1 {f :42});\n+    bar(&*f7);\n+\n+    // Deep nesting\n+    let f1 = (5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n+    baz(&f1);\n+    let f2 = &f1;\n+    baz(f2);\n+    let f3: &Fat<Fat<ToBar>> = f2;\n+    baz(f3);\n+    let f4: &Fat<Fat<ToBar>> = &f1;\n+    baz(f4);\n+    let f5: &Fat<Fat<ToBar>> = &(5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n+    baz(f5);\n+}"}, {"sha": "a788e25218eb46c044da5ba6d4e10335eeb6ee2c", "filename": "src/test/run-pass/dst-tuple-sole.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// As dst-tuple.rs, but the unsized field is the only field in the tuple.\n+\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+type Fat<T: ?Sized> = (T,);\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.0;\n+    assert_eq!(x.0.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.0[1], 2);\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.0;\n+    let bar = Bar;\n+    assert_eq!(x.0.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.0[1].to_bar(), bar);\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &([1, 2, 3],);\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = ([bar, bar, bar],);\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &([bar, bar, bar],);\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut ([1, 2, 3],);\n+    f5.0[1] = 34;\n+    assert_eq!(f5.0[0], 1);\n+    assert_eq!(f5.0[1], 34);\n+    assert_eq!(f5.0[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &([],);\n+    assert!(f5.0.is_empty());\n+    let f5: &Fat<[Bar]> = &([],);\n+    assert!(f5.0.is_empty());\n+}"}, {"sha": "2f5b28495b8aed7c3d8b3b0745dadcbf57b18ec1", "filename": "src/test/run-pass/dst-tuple.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdst-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-tuple.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(unknown_features)]\n+#![feature(box_syntax)]\n+#![feature(unsized_tuple_coercion)]\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.2;\n+    assert_eq!(x.2.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.2[1], 2);\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.2;\n+    let bar = Bar;\n+    assert_eq!(x.2.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.2[1].to_bar(), bar);\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+}\n+\n+fn foo3(x: &Fat<Fat<[isize]>>) {\n+    let y = &(x.2).2;\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!((x.2).0, 8);\n+    assert_eq!((x.2).1, \"deep str\");\n+    assert_eq!((x.2).2.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!((x.2).2[1], 2);\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = (5, \"some str\", [1, 2, 3]);\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &(5, \"some str\", [1, 2, 3]);\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = (5, \"some str\", [bar, bar, bar]);\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &(5, \"some str\", [bar, bar, bar]);\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut (5, \"some str\", [1, 2, 3]);\n+    f5.2[1] = 34;\n+    assert_eq!(f5.2[0], 1);\n+    assert_eq!(f5.2[1], 34);\n+    assert_eq!(f5.2[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &(5, \"some str\", []);\n+    assert!(f5.2.is_empty());\n+    let f5: &Fat<[Bar]> = &(5, \"some str\", []);\n+    assert!(f5.2.is_empty());\n+\n+    // Deeply nested.\n+    let f1 = (5, \"some str\", (8, \"deep str\", [1, 2, 3]));\n+    foo3(&f1);\n+    let f2 = &f1;\n+    foo3(f2);\n+    let f3: &Fat<Fat<[isize]>> = f2;\n+    foo3(f3);\n+    let f4: &Fat<Fat<[isize]>> = &f1;\n+    foo3(f4);\n+    let f5: &Fat<Fat<[isize]>> = &(5, \"some str\", (8, \"deep str\", [1, 2, 3]));\n+    foo3(f5);\n+\n+    // Box.\n+    let f1 = Box::new([1, 2, 3]);\n+    assert_eq!((*f1)[1], 2);\n+    let f2: Box<[isize]> = f1;\n+    assert_eq!((*f2)[1], 2);\n+\n+    // Nested Box.\n+    let f1 : Box<Fat<[isize; 3]>> = box (5, \"some str\", [1, 2, 3]);\n+    foo(&*f1);\n+    let f2 : Box<Fat<[isize]>> = f1;\n+    foo(&*f2);\n+\n+    let f3 : Box<Fat<[isize]>> =\n+        Box::<Fat<[_; 3]>>::new((5, \"some str\", [1, 2, 3]));\n+    foo(&*f3);\n+}"}, {"sha": "bdcd3eecc696a6ffdc35805aeedc9ce21cdb3101", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -106,6 +106,18 @@ fn struct_dynamic_drop(a: &Allocator, c0: bool, c1: bool, c: bool) {\n     }\n }\n \n+fn field_assignment(a: &Allocator, c0: bool) {\n+    let mut x = (TwoPtrs(a.alloc(), a.alloc()), a.alloc());\n+\n+    x.1 = a.alloc();\n+    x.1 = a.alloc();\n+\n+    let f = (x.0).0;\n+    if c0 {\n+        (x.0).0 = f;\n+    }\n+}\n+\n fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n     let mut _v = a.alloc();\n     let mut _w = a.alloc();\n@@ -207,5 +219,8 @@ fn main() {\n     run_test(|a| struct_dynamic_drop(a, true, true, false));\n     run_test(|a| struct_dynamic_drop(a, true, true, true));\n \n+    run_test(|a| field_assignment(a, false));\n+    run_test(|a| field_assignment(a, true));\n+\n     run_test_nopanic(|a| union1(a));\n }"}, {"sha": "e602fb2d7d29a20e2f4740e15a1179dc3f5841ad", "filename": "src/test/run-pass/env.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+\n+#![feature(rand, std_panic)]\n+\n+use std::env::*;\n+use std::__rand as rand;\n+use std::__rand::Rng;\n+use std::iter::repeat;\n+use std::ffi::{OsString, OsStr};\n+\n+\n+fn make_rand_name() -> OsString {\n+    let mut rng = rand::thread_rng();\n+    let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n+                                 .collect::<String>());\n+    let n = OsString::from(n);\n+    assert!(var_os(&n).is_none());\n+    n\n+}\n+\n+fn eq(a: Option<OsString>, b: Option<&str>) {\n+    assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::new).map(|s| &*s));\n+}\n+\n+#[test]\n+fn test_set_var() {\n+    let n = make_rand_name();\n+    set_var(&n, \"VALUE\");\n+    eq(var_os(&n), Some(\"VALUE\"));\n+}\n+\n+#[test]\n+fn test_remove_var() {\n+    let n = make_rand_name();\n+    set_var(&n, \"VALUE\");\n+    remove_var(&n);\n+    eq(var_os(&n), None);\n+}\n+\n+#[test]\n+fn test_set_var_overwrite() {\n+    let n = make_rand_name();\n+    set_var(&n, \"1\");\n+    set_var(&n, \"2\");\n+    eq(var_os(&n), Some(\"2\"));\n+    set_var(&n, \"\");\n+    eq(var_os(&n), Some(\"\"));\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_var_big() {\n+    let mut s = \"\".to_string();\n+    let mut i = 0;\n+    while i < 100 {\n+        s.push_str(\"aaaaaaaaaa\");\n+        i += 1;\n+    }\n+    let n = make_rand_name();\n+    set_var(&n, &s);\n+    eq(var_os(&n), Some(&s));\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_env_set_get_huge() {\n+    let n = make_rand_name();\n+    let s = repeat(\"x\").take(10000).collect::<String>();\n+    set_var(&n, &s);\n+    eq(var_os(&n), Some(&s));\n+    remove_var(&n);\n+    eq(var_os(&n), None);\n+}\n+\n+#[test]\n+fn test_env_set_var() {\n+    let n = make_rand_name();\n+\n+    let mut e = vars_os();\n+    set_var(&n, \"VALUE\");\n+    assert!(!e.any(|(k, v)| {\n+        &*k == &*n && &*v == \"VALUE\"\n+    }));\n+\n+    assert!(vars_os().any(|(k, v)| {\n+        &*k == &*n && &*v == \"VALUE\"\n+    }));\n+}"}, {"sha": "d21ffb96bef2e5dfbcaf773a793e107067b6889e", "filename": "src/test/run-pass/issue-31260.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fissue-31260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fissue-31260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-31260.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -12,9 +12,12 @@ pub struct Struct<K: 'static> {\n     pub field: K,\n }\n \n-// Partial fix for #31260, doesn't work without {...}.\n static STRUCT: Struct<&'static [u8]> = Struct {\n     field: {&[1]}\n };\n \n+static STRUCT2: Struct<&'static [u8]> = Struct {\n+    field: &[1]\n+};\n+\n fn main() {}"}, {"sha": "5ed1295c85c76c69021fc7f89277adad71a30ee6", "filename": "src/test/run-pass/issue-37725.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fissue-37725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fissue-37725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37725.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n+    s.clone();\n+}\n+fn main() {}"}, {"sha": "43ac697edced90f5df4f6a6ec185d582bace6f4c", "filename": "src/test/run-pass/macro-pat-neg-lit.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fmacro-pat-neg-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fmacro-pat-neg-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pat-neg-lit.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! enum_number {\n+    ($name:ident { $($variant:ident = $value:expr, )* }) => {\n+        enum $name {\n+            $($variant = $value,)*\n+        }\n+\n+        fn foo(value: i32) -> Option<$name> {\n+            match value {\n+                $( $value => Some($name::$variant), )*\n+                _ => None\n+            }\n+        }\n+    }\n+}\n+\n+enum_number!(Change {\n+    Down = -1,\n+    None = 0,\n+    Up = 1,\n+});\n+\n+fn main() {\n+    if let Some(Change::Down) = foo(-1) {} else { panic!() }\n+}\n+"}, {"sha": "b3785d898baa42fe40c27c89a1e5b0fafd0c7b50", "filename": "src/test/run-pass/process-envs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fprocess-envs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fprocess-envs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-envs.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,8 +10,6 @@\n \n // ignore-emscripten\n \n-#![feature(command_envs)]\n-\n use std::process::Command;\n use std::env;\n use std::collections::HashMap;"}, {"sha": "f6119e709990a534d0382c16ed4f9247ebf73bfe", "filename": "src/test/run-pass/range_inclusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,7 +10,7 @@\n \n // Test inclusive range syntax.\n \n-#![feature(inclusive_range_syntax, inclusive_range, step_by)]\n+#![feature(inclusive_range_syntax, inclusive_range, iterator_step_by)]\n \n use std::ops::{RangeInclusive, RangeToInclusive};\n "}, {"sha": "c11a0d391a4694f241ae6a34d3cf9b794a9f1a68", "filename": "src/test/run-pass/sync-send-iterators-in-libcore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -14,7 +14,7 @@\n #![feature(iter_empty)]\n #![feature(iter_once)]\n #![feature(iter_unfold)]\n-#![feature(step_by)]\n+#![feature(iterator_step_by)]\n #![feature(str_escape)]\n \n use std::iter::{empty, once, repeat};"}, {"sha": "aa9cf76617f6930761001dd74a6217e441122dbd", "filename": "src/test/run-pass/test-allow-fail-attr.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Ftest-allow-fail-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Ftest-allow-fail-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-allow-fail-attr.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+#![feature(allow_fail)]\n+\n+#[test]\n+#[allow_fail]\n+fn test1() {\n+    panic!();\n+}\n+\n+#[test]\n+#[allow_fail]\n+fn test2() {\n+    assert!(true);\n+}"}, {"sha": "4387a43f03b6a952026e5c3fb953cfac26b33f5d", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 105, "deletions": 63, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -10,14 +10,17 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(rand)]\n #![feature(const_fn)]\n+#![feature(rand)]\n+#![feature(sort_unstable)]\n \n use std::__rand::{thread_rng, Rng};\n+use std::cell::Cell;\n+use std::cmp::Ordering;\n use std::panic;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize};\n+use std::sync::atomic::Ordering::Relaxed;\n use std::thread;\n-use std::cell::Cell;\n \n const MAX_LEN: usize = 80;\n \n@@ -45,54 +48,85 @@ static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n ];\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+static VERSIONS: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+#[derive(Clone, Eq)]\n struct DropCounter {\n     x: u32,\n     id: usize,\n+    version: Cell<usize>,\n+}\n+\n+impl PartialEq for DropCounter {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl PartialOrd for DropCounter {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.version.set(self.version.get() + 1);\n+        other.version.set(other.version.get() + 1);\n+        VERSIONS.fetch_add(2, Relaxed);\n+        self.x.partial_cmp(&other.x)\n+    }\n+}\n+\n+impl Ord for DropCounter {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n }\n \n impl Drop for DropCounter {\n     fn drop(&mut self) {\n-        DROP_COUNTS[self.id].fetch_add(1, Ordering::Relaxed);\n+        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n+        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n     }\n }\n \n-fn test(input: &[DropCounter]) {\n-    let len = input.len();\n-\n-    // Work out the total number of comparisons required to sort\n-    // this array...\n-    let mut count = 0usize;\n-    input.to_owned().sort_by(|a, b| { count += 1; a.cmp(b) });\n+macro_rules! test {\n+    ($input:ident, $func:ident) => {\n+        let len = $input.len();\n+\n+        // Work out the total number of comparisons required to sort\n+        // this array...\n+        let mut count = 0usize;\n+        $input.to_owned().$func(|a, b| { count += 1; a.cmp(b) });\n+\n+        // ... and then panic on each and every single one.\n+        for panic_countdown in 0..count {\n+            // Refresh the counters.\n+            VERSIONS.store(0, Relaxed);\n+            for i in 0..len {\n+                DROP_COUNTS[i].store(0, Relaxed);\n+            }\n \n-    // ... and then panic on each and every single one.\n-    for panic_countdown in 0..count {\n-        // Refresh the counters.\n-        for i in 0..len {\n-            DROP_COUNTS[i].store(0, Ordering::Relaxed);\n-        }\n+            let v = $input.to_owned();\n+            let _ = thread::spawn(move || {\n+                let mut v = v;\n+                let mut panic_countdown = panic_countdown;\n+                v.$func(|a, b| {\n+                    if panic_countdown == 0 {\n+                        SILENCE_PANIC.with(|s| s.set(true));\n+                        panic!();\n+                    }\n+                    panic_countdown -= 1;\n+                    a.cmp(b)\n+                })\n+            }).join();\n+\n+            // Check that the number of things dropped is exactly\n+            // what we expect (i.e. the contents of `v`).\n+            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+                let count = c.load(Relaxed);\n+                assert!(count == 1,\n+                        \"found drop count == {} for i == {}, len == {}\",\n+                        count, i, len);\n+            }\n \n-        let v = input.to_owned();\n-        let _ = thread::spawn(move || {\n-            let mut v = v;\n-            let mut panic_countdown = panic_countdown;\n-            v.sort_by(|a, b| {\n-                if panic_countdown == 0 {\n-                    SILENCE_PANIC.with(|s| s.set(true));\n-                    panic!();\n-                }\n-                panic_countdown -= 1;\n-                a.cmp(b)\n-            })\n-        }).join();\n-\n-        // Check that the number of things dropped is exactly\n-        // what we expect (i.e. the contents of `v`).\n-        for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n-            let count = c.load(Ordering::Relaxed);\n-            assert!(count == 1,\n-                    \"found drop count == {} for i == {}, len == {}\",\n-                    count, i, len);\n+            // Check that the most recent versions of values were dropped.\n+            assert_eq!(VERSIONS.load(Relaxed), 0);\n         }\n     }\n }\n@@ -106,33 +140,41 @@ fn main() {\n             prev(info);\n         }\n     }));\n+\n+    let mut rng = thread_rng();\n+\n     for len in (1..20).chain(70..MAX_LEN) {\n-        // Test on a random array.\n-        let mut rng = thread_rng();\n-        let input = (0..len).map(|id| {\n-            DropCounter {\n-                x: rng.next_u32(),\n-                id: id,\n-            }\n-        }).collect::<Vec<_>>();\n-        test(&input);\n-\n-        // Test on a sorted array with two elements randomly swapped, creating several natural\n-        // runs of random lengths. Such arrays have very high chances of hitting all code paths in\n-        // the merge procedure.\n-        for _ in 0..5 {\n-            let mut input = (0..len).map(|i|\n-                DropCounter {\n-                    x: i as u32,\n-                    id: i,\n+        for &modulus in &[5, 20, 50] {\n+            for &has_runs in &[false, true] {\n+                let mut input = (0..len)\n+                    .map(|id| {\n+                        DropCounter {\n+                            x: rng.next_u32() % modulus,\n+                            id: id,\n+                            version: Cell::new(0),\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if has_runs {\n+                    for c in &mut input {\n+                        c.x = c.id as u32;\n+                    }\n+\n+                    for _ in 0..5 {\n+                        let a = rng.gen::<usize>() % len;\n+                        let b = rng.gen::<usize>() % len;\n+                        if a < b {\n+                            input[a..b].reverse();\n+                        } else {\n+                            input.swap(a, b);\n+                        }\n+                    }\n                 }\n-            ).collect::<Vec<_>>();\n-\n-            let a = rng.gen::<usize>() % len;\n-            let b = rng.gen::<usize>() % len;\n-            input.swap(a, b);\n \n-            test(&input);\n+                test!(input, sort_by);\n+                test!(input, sort_unstable_by);\n+            }\n         }\n     }\n }"}, {"sha": "ebf7056755eab2f27b7b7a628f726c845ca1147f", "filename": "src/test/rustdoc/issue-42875.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frustdoc%2Fissue-42875.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Frustdoc%2Fissue-42875.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-42875.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --no-defaults\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/a/index.html '//code' 'use *;'\n+mod a {\n+    use *;\n+}\n+\n+// @has foo/b/index.html '//code' 'pub use *;'\n+pub mod b {\n+    pub use *;\n+}"}, {"sha": "2a6c71dbe39232abb0412ef6ff1e0f633cb31585", "filename": "src/test/ui/block-result/block-must-not-have-result-do.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-do.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "previous_filename": "src/test/compile-fail/block-must-not-have-result-do.rs"}, {"sha": "d4024f41c26fa4e4f30b604822baa8ed7c175c70", "filename": "src/test/ui/block-result/block-must-not-have-result-do.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-do.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-do.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-do.stderr?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/block-must-not-have-result-do.rs:13:9\n+   |\n+13 |         true //~  ERROR mismatched types\n+   |         ^^^^ expected (), found bool\n+   |\n+   = note: expected type `()`\n+              found type `bool`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8728685fc8b026e4f8cf4f4559278eb96c119e5c", "filename": "src/test/ui/block-result/block-must-not-have-result-res.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "previous_filename": "src/test/compile-fail/block-must-not-have-result-res.rs"}, {"sha": "f60a0c2e5f6e00f017d93882debb11da567f4f9b", "filename": "src/test/ui/block-result/block-must-not-have-result-res.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.stderr?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/block-must-not-have-result-res.rs:15:9\n+   |\n+15 |         true //~  ERROR mismatched types\n+   |         ^^^^ expected (), found bool\n+   |\n+   = note: expected type `()`\n+              found type `bool`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a0fb470e1e4d0f1887a13e7b9967184102455dc2", "filename": "src/test/ui/block-result/block-must-not-have-result-while.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "previous_filename": "src/test/compile-fail/block-must-not-have-result-while.rs"}, {"sha": "888a64c1bb1aa61a0a8d383c37b834bf276d7f85", "filename": "src/test/ui/block-result/block-must-not-have-result-while.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.stderr?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/block-must-not-have-result-while.rs:13:9\n+   |\n+13 |         true //~  ERROR mismatched types\n+   |         ^^^^ expected (), found bool\n+   |\n+   = note: expected type `()`\n+              found type `bool`\n+\n+error: aborting due to previous error\n+"}, {"sha": "530a0e415622815150b4d26221f1bbf95ea9561c", "filename": "src/test/ui/block-result/consider-removing-last-semi.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "previous_filename": "src/test/compile-fail/consider-removing-last-semi.rs"}, {"sha": "5905cfa9322a28ab753701cb9c8e07deec9d52a9", "filename": "src/test/ui/block-result/consider-removing-last-semi.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.stderr?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,30 @@\n+error[E0308]: mismatched types\n+  --> $DIR/consider-removing-last-semi.rs:11:18\n+   |\n+11 |   fn f() -> String {  //~ ERROR mismatched types\n+   |  __________________^\n+12 | |     0u8;\n+13 | |     \"bla\".to_string();  //~ HELP consider removing this semicolon\n+   | |                      - help: consider removing this semicolon\n+14 | | }\n+   | |_^ expected struct `std::string::String`, found ()\n+   |\n+   = note: expected type `std::string::String`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/consider-removing-last-semi.rs:16:18\n+   |\n+16 |   fn g() -> String {  //~ ERROR mismatched types\n+   |  __________________^\n+17 | |     \"this won't work\".to_string();\n+18 | |     \"removeme\".to_string(); //~ HELP consider removing this semicolon\n+   | |                           - help: consider removing this semicolon\n+19 | | }\n+   | |_^ expected struct `std::string::String`, found ()\n+   |\n+   = note: expected type `std::string::String`\n+              found type `()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "192f78e41cb43cdf23d71c231f4661fc63ac3870", "filename": "src/test/ui/block-result/issue-11714.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "previous_filename": "src/test/compile-fail/issue-11714.rs"}, {"sha": "376834beab0dacfc4a6b9661dbd862c1d02a3caf", "filename": "src/test/ui/block-result/issue-11714.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.stderr?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,17 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-11714.rs:11:18\n+   |\n+11 |   fn blah() -> i32 { //~ ERROR mismatched types\n+   |  __________________^\n+12 | |     1\n+13 | |\n+14 | |     ; //~ HELP consider removing this semicolon:\n+   | |     - help: consider removing this semicolon\n+15 | | }\n+   | |_^ expected i32, found ()\n+   |\n+   = note: expected type `i32`\n+              found type `()`\n+\n+error: aborting due to previous error\n+"}, {"sha": "9406199afc231904e58df233178c4f6c544673eb", "filename": "src/test/ui/block-result/issue-13428.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "previous_filename": "src/test/compile-fail/issue-13428.rs"}, {"sha": "7bd4529c46399a1a600d99b23816f43d68a1d873", "filename": "src/test/ui/block-result/issue-13428.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.stderr?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "patch": "@@ -0,0 +1,33 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13428.rs:13:20\n+   |\n+13 |   fn foo() -> String {  //~ ERROR mismatched types\n+   |  ____________________^\n+14 | |     format!(\"Hello {}\",\n+15 | |             \"world\")\n+16 | |     // Put the trailing semicolon on its own line to test that the\n+17 | |     // note message gets the offending semicolon exactly\n+18 | |     ;   //~ HELP consider removing this semicolon\n+   | |     - help: consider removing this semicolon\n+19 | | }\n+   | |_^ expected struct `std::string::String`, found ()\n+   |\n+   = note: expected type `std::string::String`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13428.rs:21:20\n+   |\n+21 |   fn bar() -> String {  //~ ERROR mismatched types\n+   |  ____________________^\n+22 | |     \"foobar\".to_string()\n+23 | |     ;   //~ HELP consider removing this semicolon\n+   | |     - help: consider removing this semicolon\n+24 | | }\n+   | |_^ expected struct `std::string::String`, found ()\n+   |\n+   = note: expected type `std::string::String`\n+              found type `()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e4ed87c3cb0cd5baac0a663c3af4a76006e38c9f", "filename": "src/test/ui/block-result/issue-13624.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd95db25b367d5d61ee9bc86b928c529747b3622/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.rs?ref=fd95db25b367d5d61ee9bc86b928c529747b3622", "previous_filename": "src/test/compile-fail/issue-13624.rs"}]}