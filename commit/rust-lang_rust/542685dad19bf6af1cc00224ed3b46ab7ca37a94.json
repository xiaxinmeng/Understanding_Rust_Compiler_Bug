{"sha": "542685dad19bf6af1cc00224ed3b46ab7ca37a94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MjY4NWRhZDE5YmY2YWYxY2MwMDIyNGVkM2I0NmFiN2NhMzdhOTQ=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-02T18:36:45Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-02T18:36:45Z"}, "message": "Merge branch 'master' of https://github.com/Manishearth/rust-clippy into #471", "tree": {"sha": "954185922f5b1b1d3320cbb176ee14426b4e3d8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/954185922f5b1b1d3320cbb176ee14426b4e3d8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/542685dad19bf6af1cc00224ed3b46ab7ca37a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/542685dad19bf6af1cc00224ed3b46ab7ca37a94", "html_url": "https://github.com/rust-lang/rust/commit/542685dad19bf6af1cc00224ed3b46ab7ca37a94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/542685dad19bf6af1cc00224ed3b46ab7ca37a94/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fa8481ba390dc9b860123950717acbb34bd39fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fa8481ba390dc9b860123950717acbb34bd39fd", "html_url": "https://github.com/rust-lang/rust/commit/0fa8481ba390dc9b860123950717acbb34bd39fd"}, {"sha": "ec5d96228a859932828470c549e673de89844d6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5d96228a859932828470c549e673de89844d6c", "html_url": "https://github.com/rust-lang/rust/commit/ec5d96228a859932828470c549e673de89844d6c"}], "stats": {"total": 830, "additions": 606, "deletions": 224}, "files": [{"sha": "2b203e8b796b8035275d190cd11124008553e174", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.32\"\n+version = \"0.0.35\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -17,7 +17,7 @@ name = \"clippy\"\n plugin = true\n \n [dependencies]\n-unicode-normalization = \"*\"\n+unicode-normalization = \"0.1\"\n \n [dev-dependencies]\n compiletest_rs = \"0.0.11\""}, {"sha": "da51da6f96bebd4dcdea6ddb70651b5acf004c44", "filename": "README.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 86 lints included in this crate:\n+There are 89 lints included in this crate:\n \n name                                                                                                     | default | meaning\n ---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -28,6 +28,7 @@ name\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                           | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n [explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)           | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                 | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n+[filter_next](https://github.com/Manishearth/rust-clippy/wiki#filter_next)                               | warn    | using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\n [float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                   | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n [identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                               | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)             | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n@@ -41,7 +42,7 @@ name\n [map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                   | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                 | warn    | a match on boolean expression; recommends `if..else` block instead\n [match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)           | warn    | a match has overlapping arms\n-[match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                         | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n+[match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                         | warn    | a match or `if let` has all arms prefixed with `&`; the match expression can be dereferenced instead\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                       | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                 | warn    | taking a number modulo 1, which always returns 0\n [mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                       | allow   | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n@@ -56,10 +57,11 @@ name\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                   | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)     | warn    | nonsensical combination of options for opening a file\n [ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                   | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n-[option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)             | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`)\n-[option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)   | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`)\n+[option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)             | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\n+[option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)   | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\n [option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                 | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n [out_of_bounds_indexing](https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing)         | deny    | out of bound constant indexing\n+[panic_params](https://github.com/Manishearth/rust-clippy/wiki#panic_params)                             | warn    | missing parameters in `panic!`\n [precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                 | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n [ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                       | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n [range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)                 | warn    | using Range::step_by(0), which produces an infinite iterator\n@@ -68,6 +70,7 @@ name\n [redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                   | warn    | using `name @ _` in a pattern\n [result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)                 | allow   | using `Result.unwrap()`, which might be better handled\n [reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)                 | warn    | Iterating over an empty range, such as `10..0` or `5..5`\n+[search_is_some](https://github.com/Manishearth/rust-clippy/wiki#search_is_some)                         | warn    | using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`\n [shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                             | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                               | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n [shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                     | allow   | The name is re-bound without even using the original value"}, {"sha": "f0dbf390ebb3d1320231a4dcf218145db2587046", "filename": "src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -6,9 +6,9 @@ use reexport::*;\n use syntax::codemap::Span;\n use syntax::attr::*;\n use syntax::ast::{Attribute, MetaList, MetaWord};\n-use utils::{in_macro, match_path, span_lint};\n+use utils::{in_macro, match_path, span_lint, BEGIN_UNWIND};\n \n-/// **What it does:** This lint warns on items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n+/// **What it does:** This lint `Warn`s on items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n ///\n /// **Why is this bad?** While there are valid uses of this annotation (and once you know when to use it, by all means `allow` this lint), it's a common newbie-mistake to pepper one's code with it.\n ///\n@@ -94,7 +94,7 @@ fn is_relevant_expr(expr: &Expr) -> bool {\n         ExprRet(None) | ExprBreak(_) => false,\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(_, ref path) = path_expr.node {\n-                !match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+                !match_path(path, &BEGIN_UNWIND)\n             } else { true }\n         }\n         _ => true"}, {"sha": "ce01f591c59a24a6679170e3c6588f31597718d1", "filename": "src/block_in_if_condition.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblock_in_if_condition.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::{LateLintPass, LateContext, LintArray, LintPass};\n use rustc_front::intravisit::{Visitor, walk_expr};\n use utils::*;\n \n-/// **What it does:** This lint checks for `if` conditions that use blocks to contain an expression.\n+/// **What it does:** This lint checks for `if` conditions that use blocks to contain an expression. It is `Warn` by default.\n ///\n /// **Why is this bad?** It isn't really rust style, same as using parentheses to contain expressions.\n ///\n@@ -15,7 +15,7 @@ declare_lint! {\n     \"braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\"\n }\n \n-/// **What it does:** This lint checks for `if` conditions that use blocks containing statements, or conditions that use closures with blocks.\n+/// **What it does:** This lint checks for `if` conditions that use blocks containing statements, or conditions that use closures with blocks. It is `Warn` by default.\n ///\n /// **Why is this bad?** Using blocks in the condition makes it hard to read.\n ///\n@@ -74,23 +74,30 @@ impl LateLintPass for BlockInIfCondition {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprIf(ref check, ref then, _) = expr.node {\n             if let ExprBlock(ref block) = check.node {\n-                if block.stmts.is_empty() {\n-                    if let Some(ref ex) = block.expr {\n-                        // don't dig into the expression here, just suggest that they remove\n-                        // the block\n-\n-                        span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_EXPR, check.span,\n-                            BRACED_EXPR_MESSAGE,\n-                            &format!(\"try\\nif {} {} ... \", snippet_block(cx, ex.span, \"..\"),\n+                if block.rules == DefaultBlock {\n+                    if block.stmts.is_empty() {\n+                        if let Some(ref ex) = block.expr {\n+                            // don't dig into the expression here, just suggest that they remove\n+                            // the block\n+                            if differing_macro_contexts(expr.span, ex.span) {\n+                                return;\n+                            }\n+                            span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_EXPR, check.span,\n+                                BRACED_EXPR_MESSAGE,\n+                                &format!(\"try\\nif {} {} ... \", snippet_block(cx, ex.span, \"..\"),\n+                                snippet_block(cx, then.span, \"..\")));\n+                        }\n+                    } else {\n+                        if differing_macro_contexts(expr.span, block.stmts[0].span) {\n+                            return;\n+                        }\n+                        // move block higher\n+                        span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_STMT, check.span,\n+                            COMPLEX_BLOCK_MESSAGE,\n+                            &format!(\"try\\nlet res = {};\\nif res {} ... \",\n+                            snippet_block(cx, block.span, \"..\"),\n                             snippet_block(cx, then.span, \"..\")));\n                     }\n-                } else {\n-                    // move block higher\n-                    span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_STMT, check.span,\n-                        COMPLEX_BLOCK_MESSAGE,\n-                        &format!(\"try\\nlet res = {};\\nif res {} ... \",\n-                        snippet_block(cx, block.span, \"..\"),\n-                        snippet_block(cx, then.span, \"..\")));\n                 }\n             } else {\n                 let mut visitor = ExVisitor { found_block: None };"}, {"sha": "9d3a9e7d7c24d340803e51350a824ae3c23e0c8d", "filename": "src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -75,7 +75,7 @@ impl Constant {\n         if let ConstantInt(val, _) = *self {\n             val // TODO we may want to check the sign if any\n         } else {\n-            panic!(\"Could not convert a {:?} to u64\");\n+            panic!(\"Could not convert a {:?} to u64\", self);\n         }\n     }\n "}, {"sha": "7beb3296aac354c22bd2f341cbde9d710819a09c", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -9,7 +9,7 @@ use syntax::attr::*;\n use syntax::ast::Attribute;\n use rustc_front::intravisit::{Visitor, walk_expr};\n \n-use utils::{in_macro, LimitStack};\n+use utils::{in_macro, LimitStack, span_help_and_lint};\n \n /// **What it does:** It `Warn`s on methods with high cyclomatic complexity\n ///\n@@ -59,8 +59,8 @@ impl CyclomaticComplexity {\n         } else {\n             let rust_cc = cc + divergence - narms;\n             if rust_cc > self.limit.limit() {\n-                cx.span_lint_help(CYCLOMATIC_COMPLEXITY, span,\n-                &format!(\"The function has a cyclomatic complexity of {}.\", rust_cc),\n+                span_help_and_lint(cx, CYCLOMATIC_COMPLEXITY, span,\n+                &format!(\"The function has a cyclomatic complexity of {}\", rust_cc),\n                 \"You could split it up into multiple smaller functions\");\n             }\n         }\n@@ -140,8 +140,9 @@ fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, span: Span) {\n #[cfg(not(feature=\"debugging\"))]\n fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, span: Span) {\n     if cx.current_level(CYCLOMATIC_COMPLEXITY) != Level::Allow {\n-        cx.sess().span_note(span, &format!(\"Clippy encountered a bug calculating cyclomatic complexity \\\n-                                            (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n-                                            cc = {}, arms = {}, div = {}. Please file a bug report.\", cc, narms, div));\n+        cx.sess().span_note_without_error(span,\n+                                          &format!(\"Clippy encountered a bug calculating cyclomatic complexity \\\n+                                                    (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n+                                                    cc = {}, arms = {}, div = {}. Please file a bug report.\", cc, narms, div));\n     }\n }"}, {"sha": "4b6a8258dbe58ab930d21e33e49da65031fedd2e", "filename": "src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -14,11 +14,11 @@ use utils::span_lint;\n \n pub struct EscapePass;\n \n-/// **What it does:** This lint checks for usage of `Box<T>` where an unboxed `T` would work fine\n+/// **What it does:** This lint checks for usage of `Box<T>` where an unboxed `T` would work fine. It is `Warn` by default.\n ///\n-/// **Why is this bad?** This is an unnecessary allocation, and bad for performance\n+/// **Why is this bad?** This is an unnecessary allocation, and bad for performance. It is only necessary to allocate if you wish to move the box into something.\n ///\n-/// It is only necessary to allocate if you wish to move the box into something.\n+/// **Known problems:** None\n ///\n /// **Example:**\n ///"}, {"sha": "6b561ff7a0532d0267ed155de91242d25bad5a61", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -84,9 +84,9 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 }\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span,\n                                    \"redundant closure found\",\n-                                   || {\n+                                   |db| {\n                     if let Some(snippet) = snippet_opt(cx, caller.span) {\n-                        cx.sess().span_suggestion(expr.span,\n+                        db.span_suggestion(expr.span,\n                                                   \"remove closure as shown:\",\n                                                   snippet);\n                     }"}, {"sha": "d574fa2c336a618c9517c9049171d6f181ce0a40", "filename": "src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -135,7 +135,7 @@ fn check_len_zero(cx: &LateContext, span: Span, name: &Name,\n             has_is_empty(cx, &args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!(\n                     \"consider replacing the len comparison with `{}{}.is_empty()`\",\n-                    op, snippet(cx, args[0].span, \"_\")))\n+                    op, snippet(cx, args[0].span, \"_\")));\n             }\n     }\n }"}, {"sha": "c3e6d7828ba368ab98471bdd8277e69b8fa1d763", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -67,6 +67,7 @@ pub mod cyclomatic_complexity;\n pub mod escape;\n pub mod misc_early;\n pub mod array_indexing;\n+pub mod panic;\n \n mod reexport {\n     pub use syntax::ast::{Name, NodeId};\n@@ -123,6 +124,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n     reg.register_late_lint_pass(box misc::UsedUnderscoreBinding);\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n+    reg.register_late_lint_pass(box panic::PanicPass);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n@@ -175,9 +177,11 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_OVERLAPPING_ARM,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n+        methods::FILTER_NEXT,\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_UNWRAP_OR,\n         methods::OPTION_MAP_UNWRAP_OR_ELSE,\n+        methods::SEARCH_IS_SOME,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,\n@@ -199,6 +203,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         needless_update::NEEDLESS_UPDATE,\n         no_effect::NO_EFFECT,\n         open_options::NONSENSICAL_OPEN_OPTIONS,\n+        panic::PANIC_PARAMS,\n         precedence::PRECEDENCE,\n         ptr_arg::PTR_ARG,\n         ranges::RANGE_STEP_BY_ZERO,"}, {"sha": "9f103f4e7a80448504baf56b0c136473fb359640", "filename": "src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -50,7 +50,7 @@ declare_lint!{ pub EXPLICIT_ITER_LOOP, Warn,\n declare_lint!{ pub ITER_NEXT_LOOP, Warn,\n                \"for-looping over `_.next()` which is probably not intended\" }\n \n-/// **What it does:** This lint detects `loop + match` combinations that are easier written as a `while let` loop.\n+/// **What it does:** This lint detects `loop + match` combinations that are easier written as a `while let` loop. It is `Warn` by default.\n ///\n /// **Why is this bad?** The `while let` loop is usually shorter and more readable\n ///\n@@ -85,7 +85,7 @@ declare_lint!{ pub UNUSED_COLLECT, Warn,\n                \"`collect()`ing an iterator without using the result; this is usually better \\\n                 written as a for loop\" }\n \n-/// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative `.step_by(_)`.\n+/// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative `.step_by(_)`. It is `Warn` by default.\n ///\n /// **Why is it bad?** Such loops will either be skipped or loop until wrap-around (in debug code, this may `panic!()`). Both options are probably not intended.\n ///"}, {"sha": "ef992ad086cb42e5f221ee23f385ee594275e3a9", "filename": "src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -8,7 +8,7 @@ use utils::{walk_ptrs_ty, walk_ptrs_ty_depth};\n ///\n /// **Why is this bad?** It makes the code less readable.\n ///\n-/// **Known problems:** False negative: The lint currently misses mapping `Clone::clone` directly. Issue #436 is tracking this.\n+/// **Known problems:** None\n ///\n /// **Example:** `x.map(|e| e.clone());`\n declare_lint!(pub MAP_CLONE, Warn,"}, {"sha": "8564c36e617568ce2a2bb7a846a4a3f2cc098173", "filename": "src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -27,7 +27,7 @@ declare_lint!(pub SINGLE_MATCH, Warn,\n               \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n                is `_ => {}`) is used; recommends `if let` instead\");\n \n-/// **What it does:** This lint checks for matches where all arms match a reference, suggesting to remove the reference and deref the matched expression instead. It is `Warn` by default.\n+/// **What it does:** This lint checks for matches where all arms match a reference, suggesting to remove the reference and deref the matched expression instead. It also checks for `if let &foo = bar` blocks. It is `Warn` by default.\n ///\n /// **Why is this bad?** It just makes the code less readable. That reference destructuring adds nothing to the code.\n ///\n@@ -43,7 +43,7 @@ declare_lint!(pub SINGLE_MATCH, Warn,\n /// }\n /// ```\n declare_lint!(pub MATCH_REF_PATS, Warn,\n-              \"a match has all arms prefixed with `&`; the match expression can be \\\n+              \"a match or `if let` has all arms prefixed with `&`; the match expression can be \\\n                dereferenced instead\");\n \n /// **What it does:** This lint checks for matches where match expression is a `bool`. It suggests to replace the expression with an `if...else` block. It is `Warn` by default."}, {"sha": "a6200534e30e7c50d5eba61065f019c8aef06ef0", "filename": "src/methods.rs", "status": "modified", "additions": 206, "deletions": 105, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -5,9 +5,10 @@ use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, walk_ptrs_ty_depth,\n-    walk_ptrs_ty};\n+use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args,\n+            match_trait_method, walk_ptrs_ty_depth, walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n+use utils::MethodArgs;\n \n use self::SelfKind::*;\n use self::OutType::*;\n@@ -134,7 +135,7 @@ declare_lint!(pub OK_EXPECT, Warn,\n /// **Example:** `x.map(|a| a + 1).unwrap_or(0)`\n declare_lint!(pub OPTION_MAP_UNWRAP_OR, Warn,\n               \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n-               `map_or(a, f)`)\");\n+               `map_or(a, f)`\");\n \n /// **What it does:** This lint `Warn`s on `_.map(_).unwrap_or_else(_)`.\n ///\n@@ -145,7 +146,29 @@ declare_lint!(pub OPTION_MAP_UNWRAP_OR, Warn,\n /// **Example:** `x.map(|a| a + 1).unwrap_or_else(some_function)`\n declare_lint!(pub OPTION_MAP_UNWRAP_OR_ELSE, Warn,\n               \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n-               `map_or_else(g, f)`)\");\n+               `map_or_else(g, f)`\");\n+\n+/// **What it does:** This lint `Warn`s on `_.filter(_).next()`.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as `_.find(_)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `iter.filter(|x| x == 0).next()`\n+declare_lint!(pub FILTER_NEXT, Warn,\n+              \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\");\n+\n+/// **What it does:** This lint `Warn`s on an iterator search (such as `find()`, `position()`, or\n+/// `rposition()`) followed by a call to `is_some()`.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as `_.any(_)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `iter.find(|x| x == 0).is_some()`\n+declare_lint!(pub SEARCH_IS_SOME, Warn,\n+              \"using an iterator search followed by `is_some()`, which is more succinctly \\\n+               expressed as a call to `any()`\");\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n@@ -157,107 +180,33 @@ impl LintPass for MethodsPass {\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-\n-        if let ExprMethodCall(ref name, _, ref args) = expr.node {\n-            let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n-            match &*name.node.as_str() {\n-                \"unwrap\" if match_type(cx, obj_ty, &OPTION_PATH) => {\n-                    span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n-                              \"used unwrap() on an Option value. If you don't want \\\n-                               to handle the None case gracefully, consider using \\\n-                               expect() to provide a better panic message\");\n-                },\n-                \"unwrap\" if match_type(cx, obj_ty, &RESULT_PATH) => {\n-                    span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n-                              \"used unwrap() on a Result value. Graceful handling \\\n-                               of Err values is preferred\");\n-                },\n-                \"to_string\" if obj_ty.sty == ty::TyStr => {\n-                    let mut arg_str = snippet(cx, args[0].span, \"_\");\n-                    if ptr_depth > 1 {\n-                        arg_str = Cow::Owned(format!(\n-                            \"({}{})\",\n-                            iter::repeat('*').take(ptr_depth - 1).collect::<String>(),\n-                            arg_str));\n-                    }\n-                    span_lint(cx, STR_TO_STRING, expr.span, &format!(\n-                        \"`{}.to_owned()` is faster\", arg_str));\n-                },\n-                \"to_string\" if match_type(cx, obj_ty, &STRING_PATH) => {\n-                    span_lint(cx, STRING_TO_STRING, expr.span, \"`String.to_string()` is a no-op; use \\\n-                                                                `clone()` to make a copy\");\n-                },\n-                \"expect\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"ok\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &RESULT_PATH) {\n-                        let result_type = cx.tcx.expr_ty(&inner_args[0]);\n-                        if let Some(error_type) = get_error_type(cx, result_type) {\n-                            if has_debug_impl(error_type, cx) {\n-                                span_lint(cx, OK_EXPECT, expr.span,\n-                                         \"called `ok().expect()` on a Result \\\n-                                          value. You can call `expect` directly \\\n-                                          on the `Result`\");\n-                            }\n-                        }\n-                    }\n-                },\n-                // check Option.map(_).unwrap_or(_)\n-                \"unwrap_or\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"map\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n-                        // lint message\n-                        let msg =\n-                            \"called `map(f).unwrap_or(a)` on an Option value. This can be done \\\n-                             more directly by calling `map_or(a, f)` instead\";\n-                        // get args to map() and unwrap_or()\n-                        let map_arg = snippet(cx, inner_args[1].span, \"..\");\n-                        let unwrap_arg = snippet(cx, args[1].span, \"..\");\n-                        // lint, with note if neither arg is > 1 line and both map() and\n-                        // unwrap_or() have the same span\n-                        let multiline = map_arg.lines().count() > 1\n-                                        || unwrap_arg.lines().count() > 1;\n-                        let same_span = inner_args[1].span.expn_id == args[1].span.expn_id;\n-                        if same_span && !multiline {\n-                            span_note_and_lint(\n-                                cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n-                                &format!(\"replace this with map_or({1}, {0})\",\n-                                         map_arg, unwrap_arg)\n-                            );\n-                        }\n-                        else if same_span && multiline {\n-                            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n-                        };\n-                    }\n-                },\n-                // check Option.map(_).unwrap_or_else(_)\n-                \"unwrap_or_else\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"map\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n-                        // lint message\n-                        let msg =\n-                            \"called `map(f).unwrap_or_else(g)` on an Option value. This can be \\\n-                             done more directly by calling `map_or_else(g, f)` instead\";\n-                        // get args to map() and unwrap_or_else()\n-                        let map_arg = snippet(cx, inner_args[1].span, \"..\");\n-                        let unwrap_arg = snippet(cx, args[1].span, \"..\");\n-                        // lint, with note if neither arg is > 1 line and both map() and\n-                        // unwrap_or_else() have the same span\n-                        let multiline = map_arg.lines().count() > 1\n-                                        || unwrap_arg.lines().count() > 1;\n-                        let same_span = inner_args[1].span.expn_id == args[1].span.expn_id;\n-                        if same_span && !multiline {\n-                            span_note_and_lint(\n-                                cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n-                                &format!(\"replace this with map_or_else({1}, {0})\",\n-                                         map_arg, unwrap_arg)\n-                            );\n-                        }\n-                        else if same_span && multiline {\n-                            span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n-                        };\n-                    }\n-                },\n-                _ => {},\n+        if let ExprMethodCall(_, _, _) = expr.node {\n+            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+                lint_unwrap(cx, expr, arglists[0]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n+                lint_to_string(cx, expr, arglists[0]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n+                lint_ok_expect(cx, expr, arglists[0]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n+                lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n+                lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n+                lint_filter_next(cx, expr, arglists[0]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n+                lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n+                lint_search_is_some(cx, expr, \"position\", arglists[0], arglists[1]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n+                lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n             }\n         }\n     }\n@@ -304,6 +253,158 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `unwrap()` for `Option`s and `Result`s\n+fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n+    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&unwrap_args[0]));\n+\n+    if match_type(cx, obj_ty, &OPTION_PATH) {\n+        span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n+                  \"used unwrap() on an Option value. If you don't want to handle the None case \\\n+                   gracefully, consider using expect() to provide a better panic message\");\n+    }\n+    else if match_type(cx, obj_ty, &RESULT_PATH) {\n+        span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n+                  \"used unwrap() on a Result value. Graceful handling of Err values is preferred\");\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `to_string()` for `&str`s and `String`s\n+fn lint_to_string(cx: &LateContext, expr: &Expr, to_string_args: &MethodArgs) {\n+    let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&to_string_args[0]));\n+\n+    if obj_ty.sty == ty::TyStr {\n+        let mut arg_str = snippet(cx, to_string_args[0].span, \"_\");\n+        if ptr_depth > 1 {\n+            arg_str = Cow::Owned(format!(\n+                \"({}{})\",\n+                iter::repeat('*').take(ptr_depth - 1).collect::<String>(),\n+                arg_str));\n+        }\n+        span_lint(cx, STR_TO_STRING, expr.span,\n+                  &format!(\"`{}.to_owned()` is faster\", arg_str));\n+    }\n+    else if match_type(cx, obj_ty, &STRING_PATH) {\n+        span_lint(cx, STRING_TO_STRING, expr.span,\n+                  \"`String.to_string()` is a no-op; use `clone()` to make a copy\");\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `ok().expect()` for `Result`s\n+fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n+    // lint if the caller of `ok()` is a `Result`\n+    if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &RESULT_PATH) {\n+        let result_type = cx.tcx.expr_ty(&ok_args[0]);\n+        if let Some(error_type) = get_error_type(cx, result_type) {\n+            if has_debug_impl(error_type, cx) {\n+                span_lint(cx, OK_EXPECT, expr.span,\n+                          \"called `ok().expect()` on a Result value. You can call `expect` \\\n+                           directly on the `Result`\");\n+            }\n+        }\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `map().unwrap_or()` for `Option`s\n+fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n+                      unwrap_args: &MethodArgs) {\n+    // lint if the caller of `map()` is an `Option`\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+        // lint message\n+        let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more \\\n+                   directly by calling `map_or(a, f)` instead\";\n+        // get snippets for args to map() and unwrap_or()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or() have the same span\n+        let multiline = map_snippet.lines().count() > 1\n+                        || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n+        if same_span && !multiline {\n+            span_note_and_lint(\n+                cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n+                &format!(\"replace `map({0}).unwrap_or({1})` with `map_or({1}, {0})`\", map_snippet,\n+                         unwrap_snippet)\n+            );\n+        }\n+        else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n+        };\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `map().unwrap_or_else()` for `Option`s\n+fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n+                           unwrap_args: &MethodArgs) {\n+    // lint if the caller of `map()` is an `Option`\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+        // lint message\n+        let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more \\\n+                   directly by calling `map_or_else(g, f)` instead\";\n+        // get snippets for args to map() and unwrap_or_else()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or_else() have the same span\n+        let multiline = map_snippet.lines().count() > 1\n+                        || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n+        if same_span && !multiline {\n+            span_note_and_lint(\n+                cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n+                &format!(\"replace `map({0}).unwrap_or_else({1})` with `with map_or_else({1}, {0})`\",\n+                          map_snippet, unwrap_snippet)\n+            );\n+        }\n+        else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n+        };\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `filter().next() for Iterators`\n+fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n+    // lint if caller of `.filter().next()` is an Iterator\n+    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+        let msg = \"called `filter(p).next()` on an Iterator. This is more succinctly expressed by \\\n+                   calling `.find(p)` instead.\";\n+        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        if filter_snippet.lines().count() <= 1 { // add note if not multi-line\n+            span_note_and_lint(cx, FILTER_NEXT, expr.span, msg, expr.span,\n+                &format!(\"replace `filter({0}).next()` with `find({0})`\", filter_snippet));\n+        }\n+        else {\n+            span_lint(cx, FILTER_NEXT, expr.span, msg);\n+        }\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint searching an Iterator followed by `is_some()`\n+fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, search_args: &MethodArgs,\n+                       is_some_args: &MethodArgs) {\n+    // lint if caller of search is an Iterator\n+    if match_trait_method(cx, &*is_some_args[0], &[\"core\", \"iter\", \"Iterator\"]) {\n+        let msg = format!(\"called `is_some()` after searching an iterator with {}. This is more \\\n+                           succinctly expressed by calling `any()`.\", search_method);\n+        let search_snippet = snippet(cx, search_args[1].span, \"..\");\n+        if search_snippet.lines().count() <= 1 { // add note if not multi-line\n+            span_note_and_lint(cx, SEARCH_IS_SOME, expr.span, &msg, expr.span,\n+                &format!(\"replace `{0}({1}).is_some()` with `any({1})`\", search_method,\n+                         search_snippet));\n+        }\n+        else {\n+            span_lint(cx, SEARCH_IS_SOME, expr.span, &msg);\n+        }\n+    }\n+}\n+\n // Given a `Result<T, E>` type, return its error type (`E`)\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     if !match_type(cx, ty, &RESULT_PATH) {"}, {"sha": "2a8e064f9f4a8fcb156647097dd9c369b24edf58", "filename": "src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -8,7 +8,7 @@ use consts::{Constant, constant_simple};\n use utils::{match_def_path, span_lint};\n use self::MinMax::{Min, Max};\n \n-/// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant.\n+/// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant. It is `Warn` by default.\n ///\n /// **Why is this bad?** This is in all probability not the intended outcome. At the least it hurts readability of the code.\n ///\n@@ -37,7 +37,7 @@ impl LateLintPass for MinMaxPass {\n                     (_, None) | (Max, Some(Less)) | (Min, Some(Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span,\n-                            \"this min/max combination leads to constant result\")\n+                            \"this min/max combination leads to constant result\");\n                     }\n                 }\n             }"}, {"sha": "92276961d11c634d468df6f7b05cbd8a4694a8bc", "filename": "src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -281,7 +281,7 @@ impl LateLintPass for ModuloOne {\n     }\n }\n \n-/// **What it does:** This lint checks for patterns in the form `name @ _`.\n+/// **What it does:** This lint checks for patterns in the form `name @ _`. It is `Warn` by default.\n ///\n /// **Why is this bad?** It's almost always more readable to just use direct bindings.\n ///"}, {"sha": "db6f0e0320bc159e7ff05d65c4f00677ab373084", "filename": "src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -30,8 +30,8 @@ impl LateLintPass for MutMut {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext, ty: &Ty) {\n-        unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| span_lint(cx, MUT_MUT,\n-            ty.span, \"generally you want to avoid `&mut &mut _` if possible\"))\n+        unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| { span_lint(cx, MUT_MUT,\n+            ty.span, \"generally you want to avoid `&mut &mut _` if possible\"); });\n     }\n }\n \n@@ -52,12 +52,12 @@ fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n                     cx.tcx.expr_ty(e).sty {\n                         span_lint(cx, MUT_MUT, expr.span,\n                                   \"this expression mutably borrows a mutable reference. \\\n-                                   Consider reborrowing\")\n+                                   Consider reborrowing\");\n                 }\n             },\n             |_| {\n                 span_lint(cx, MUT_MUT, expr.span,\n-                          \"generally you want to avoid `&mut &mut _` if possible\")\n+                          \"generally you want to avoid `&mut &mut _` if possible\");\n             }\n         )\n     })"}, {"sha": "ddfd9ddcc13a23b7e1635fc94aab44babd74d582", "filename": "src/mut_reference.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -4,7 +4,7 @@ use utils::span_lint;\n use rustc::middle::ty::{TypeAndMut, TypeVariants, MethodCall, TyS};\n use syntax::ptr::P;\n \n-/// **What it does:** This lint detects giving a mutable reference to a function that only requires an immutable reference.\n+/// **What it does:** This lint detects giving a mutable reference to a function that only requires an immutable reference. It is `Warn` by default.\n ///\n /// **Why is this bad?** The immutable reference rules out all other references to the value. Also the code misleads about the intent of the call site.\n ///\n@@ -36,7 +36,7 @@ impl LateLintPass for UnnecessaryMutPassed {\n                 match borrowed_table.node_types.get(&fn_expr.id) {\n                     Some(function_type) => {\n                         if let ExprPath(_, ref path) = fn_expr.node {\n-                            check_arguments(cx, &arguments, function_type, \n+                            check_arguments(cx, &arguments, function_type,\n                                             &format!(\"{}\", path));\n                         }\n                     }\n@@ -50,7 +50,7 @@ impl LateLintPass for UnnecessaryMutPassed {\n             ExprMethodCall(ref name, _, ref arguments) => {\n                 let method_call = MethodCall::expr(e.id);\n                 match borrowed_table.method_map.get(&method_call) {\n-                    Some(method_type) => check_arguments(cx, &arguments, method_type.ty, \n+                    Some(method_type) => check_arguments(cx, &arguments, method_type.ty,\n                                                          &format!(\"{}\", name.node.as_str())),\n                     None => unreachable!(), // Just like above, this should never happen.\n                 };\n@@ -68,9 +68,9 @@ fn check_arguments(cx: &LateContext, arguments: &[P<Expr>], type_definition: &Ty\n                 TypeVariants::TyRef(_, TypeAndMut {mutbl: MutImmutable, ..}) |\n                 TypeVariants::TyRawPtr(TypeAndMut {mutbl: MutImmutable, ..}) => {\n                     if let ExprAddrOf(MutMutable, _) = argument.node {\n-                        span_lint(cx, UNNECESSARY_MUT_PASSED, \n+                        span_lint(cx, UNNECESSARY_MUT_PASSED,\n                                   argument.span, &format!(\"The function/method \\\"{}\\\" \\\n-                                  doesn't need a mutable reference\", \n+                                  doesn't need a mutable reference\",\n                                   name));\n                     }\n                 }"}, {"sha": "8899eb56d42043868cf84846862d1a640e656f83", "filename": "src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -63,7 +63,7 @@ impl LateLintPass for MutexAtomic {\n                         ty::TyInt(t) if t != ast::TyIs =>\n                             span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg)\n-                    }\n+                    };\n                 }\n             }\n         }"}, {"sha": "40d6e7d4dff8b0dbb81b2a4bd706fd95aa9244e6", "filename": "src/panic.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpanic.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -0,0 +1,49 @@\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use syntax::ast::Lit_::LitStr;\n+\n+use utils::{span_lint, in_external_macro, match_path, BEGIN_UNWIND};\n+\n+/// **What it does:** Warn about missing parameters in `panic!`.\n+///\n+/// **Known problems:** Should you want to use curly brackets in `panic!` without any parameter,\n+/// this lint will warn.\n+///\n+/// **Example:**\n+/// ```\n+/// panic!(\"This panic! is probably missing a parameter there: {}\");\n+/// ```\n+declare_lint!(pub PANIC_PARAMS, Warn, \"missing parameters in `panic!`\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct PanicPass;\n+\n+impl LintPass for PanicPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(PANIC_PARAMS)\n+    }\n+}\n+\n+impl LateLintPass for PanicPass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if_let_chain! {[\n+            in_external_macro(cx, expr.span),\n+            let ExprBlock(ref block) = expr.node,\n+            let Some(ref ex) = block.expr,\n+            let ExprCall(ref fun, ref params) = ex.node,\n+            params.len() == 2,\n+            let ExprPath(None, ref path) = fun.node,\n+            match_path(path, &BEGIN_UNWIND),\n+            let ExprLit(ref lit) = params[0].node,\n+            let LitStr(ref string, _) = lit.node,\n+            string.contains('{'),\n+            let Some(sp) = cx.sess().codemap()\n+                             .with_expn_info(expr.span.expn_id,\n+                                             |info| info.map(|i| i.call_site))\n+        ], {\n+\n+            span_lint(cx, PANIC_PARAMS, sp,\n+                      \"You probably are missing some parameter in your `panic!` call\");\n+        }}\n+    }\n+}"}, {"sha": "91ff0680b3e2f8834fa70e8b331c143e328e76cc", "filename": "src/precedence.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -4,7 +4,7 @@ use syntax::ast::*;\n \n use utils::{span_lint, snippet};\n \n-/// **What it does:** This lint checks for operations where precedence may be unclear and `Warn`'s about them by default, suggesting to add parentheses. Currently it catches the following:\n+/// **What it does:** This lint checks for operations where precedence may be unclear and `Warn`s about them by default, suggesting to add parentheses. Currently it catches the following:\n /// * mixed usage of arithmetic and bit shifting/combining operators without parentheses\n /// * a \"negative\" numeric literal (which is really a unary `-` followed by a numeric literal) followed by a method call\n ///\n@@ -33,21 +33,27 @@ impl EarlyLintPass for Precedence {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if !is_bit_op(op) { return; }\n             match (is_arith_expr(left), is_arith_expr(right)) {\n-                (true, true) =>  span_lint(cx, PRECEDENCE, expr.span, \n+                (true, true) => {\n+                    span_lint(cx, PRECEDENCE, expr.span, \n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `({}) {} ({})`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\"))),\n-                (true, false) => span_lint(cx, PRECEDENCE, expr.span, \n+                         op.to_string(), snippet(cx, right.span, \"..\")));\n+                },\n+                (true, false) => {\n+                    span_lint(cx, PRECEDENCE, expr.span, \n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `({}) {} {}`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\"))),\n-                (false, true) => span_lint(cx, PRECEDENCE, expr.span, \n+                         op.to_string(), snippet(cx, right.span, \"..\")));\n+                },\n+                (false, true) => {\n+                    span_lint(cx, PRECEDENCE, expr.span, \n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `{} {} ({})`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\"))),\n+                         op.to_string(), snippet(cx, right.span, \"..\")));\n+                },\n                 _ => (),\n             }\n         }\n@@ -57,12 +63,13 @@ impl EarlyLintPass for Precedence {\n                 if let Some(slf) = args.first() {\n                     if let ExprLit(ref lit) = slf.node {\n                         match lit.node {\n-                            LitInt(..) | LitFloat(..) | LitFloatUnsuffixed(..) =>\n+                            LitInt(..) | LitFloat(..) | LitFloatUnsuffixed(..) => {\n                                 span_lint(cx, PRECEDENCE, expr.span, &format!(\n                                     \"unary minus has lower precedence than \\\n                                      method call. Consider adding parentheses \\\n                                      to clarify your intent: -({})\",\n-                                     snippet(cx, rhs.span, \"..\"))),\n+                                     snippet(cx, rhs.span, \"..\")));\n+                            }\n                             _ => ()\n                         }\n                     }"}, {"sha": "15f9bb80d95118dee37b1f16b705ca60a90714af", "filename": "src/returns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -75,9 +75,9 @@ impl ReturnPass {\n         if in_external_macro(cx, spans.1) {return;}\n         span_lint_and_then(cx, NEEDLESS_RETURN, spans.0,\n                            \"unneeded return statement\",\n-                           || {\n+                           |db| {\n             if let Some(snippet) = snippet_opt(cx, spans.1) {\n-                cx.sess().span_suggestion(spans.0,\n+                db.span_suggestion(spans.0,\n                                           \"remove `return` as shown:\",\n                                           snippet);\n             }\n@@ -105,11 +105,11 @@ impl ReturnPass {\n \n     fn emit_let_lint(&mut self, cx: &EarlyContext, lint_span: Span, note_span: Span) {\n         if in_external_macro(cx, note_span) {return;}\n-        span_lint(cx, LET_AND_RETURN, lint_span,\n+        let mut db = span_lint(cx, LET_AND_RETURN, lint_span,\n                   \"returning the result of a let binding from a block. \\\n                    Consider returning the expression directly.\");\n         if cx.current_level(LET_AND_RETURN) != Level::Allow {\n-            cx.sess().span_note(note_span,\n+            db.span_note(note_span,\n                                 \"this expression can be directly returned\");\n         }\n     }"}, {"sha": "1210590bbcb83af2f99d342d0b8c162f48a5ae53", "filename": "src/shadow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -7,7 +7,7 @@ use rustc_front::intravisit::{Visitor, FnKind};\n use rustc::lint::*;\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n-use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint, span_note_and_lint};\n+use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint, span_note_and_lint, DiagnosticWrapper};\n \n /// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while just changing reference level or mutability. It is `Allow` by default.\n ///\n@@ -180,39 +180,39 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n \n fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init:\n         &Option<T>, prev_span: Span) where T: Deref<Target=Expr> {\n-    fn note_orig(cx: &LateContext, lint: &'static Lint, span: Span) {\n+    fn note_orig(cx: &LateContext, mut db: DiagnosticWrapper, lint: &'static Lint, span: Span) {\n         if cx.current_level(lint) != Level::Allow {\n-            cx.sess().span_note(span, \"previous binding is here\");\n+            db.span_note(span, \"previous binding is here\");\n         }\n     }\n     if let Some(ref expr) = *init {\n         if is_self_shadow(name, expr) {\n-            span_lint(cx, SHADOW_SAME, span, &format!(\n+            let db = span_lint(cx, SHADOW_SAME, span, &format!(\n                 \"{} is shadowed by itself in {}\",\n                 snippet(cx, lspan, \"_\"),\n                 snippet(cx, expr.span, \"..\")));\n-                note_orig(cx, SHADOW_SAME, prev_span);\n+                note_orig(cx, db, SHADOW_SAME, prev_span);\n         } else {\n             if contains_self(name, expr) {\n-                span_note_and_lint(cx, SHADOW_REUSE, lspan, &format!(\n+                let db = span_note_and_lint(cx, SHADOW_REUSE, lspan, &format!(\n                     \"{} is shadowed by {} which reuses the original value\",\n                     snippet(cx, lspan, \"_\"),\n                     snippet(cx, expr.span, \"..\")),\n                     expr.span, \"initialization happens here\");\n-                note_orig(cx, SHADOW_REUSE, prev_span);\n+                note_orig(cx, db, SHADOW_REUSE, prev_span);\n             } else {\n-                span_note_and_lint(cx, SHADOW_UNRELATED, lspan, &format!(\n+                let db = span_note_and_lint(cx, SHADOW_UNRELATED, lspan, &format!(\n                     \"{} is shadowed by {}\",\n                     snippet(cx, lspan, \"_\"),\n                     snippet(cx, expr.span, \"..\")),\n                     expr.span, \"initialization happens here\");\n-                note_orig(cx, SHADOW_UNRELATED, prev_span);\n+                note_orig(cx, db, SHADOW_UNRELATED, prev_span);\n             }\n         }\n     } else {\n-        span_lint(cx, SHADOW_UNRELATED, span, &format!(\n+        let db = span_lint(cx, SHADOW_UNRELATED, span, &format!(\n             \"{} shadows a previous declaration\", snippet(cx, lspan, \"_\")));\n-        note_orig(cx, SHADOW_UNRELATED, prev_span);\n+        note_orig(cx, db, SHADOW_UNRELATED, prev_span);\n     }\n }\n "}, {"sha": "861ae0bb012986e51fb0bcacc0ac925950398018", "filename": "src/strings.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -11,7 +11,7 @@ use eq_op::is_exp_equal;\n use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n use utils::STRING_PATH;\n \n-/// **What it does:** This lint matches code of the form `x = x + y` (without `let`!)\n+/// **What it does:** This lint matches code of the form `x = x + y` (without `let`!). It is `Allow` by default.\n ///\n /// **Why is this bad?** Because this expression needs another copy as opposed to `x.push_str(y)` (in practice LLVM will usually elide it, though). Despite [llogiq](https://github.com/llogiq)'s reservations, this lint also is `allow` by default, as some people opine that it's more readable.\n ///\n@@ -75,13 +75,13 @@ impl LateLintPass for StringAdd {\n                 }\n                 span_lint(cx, STRING_ADD, e.span,\n                     \"you added something to a string. \\\n-                     Consider using `String::push_str()` instead\")\n+                     Consider using `String::push_str()` instead\");\n             }\n         } else if let ExprAssign(ref target, ref src) = e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"you assigned the result of adding something to this string. \\\n-                     Consider using `String::push_str()` instead\")\n+                     Consider using `String::push_str()` instead\");\n             }\n         }\n     }"}, {"sha": "e119ef63436a3c5e645c3f51949e3c94ed12c7f1", "filename": "src/types.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -9,15 +9,13 @@ use syntax::ast::IntTy::*;\n use syntax::ast::UintTy::*;\n use syntax::ast::FloatTy::*;\n \n-use utils::{match_type, snippet, span_lint, span_help_and_lint};\n-use utils::{is_from_for_desugar, in_macro, in_external_macro};\n-use utils::{LL_PATH, VEC_PATH};\n+use utils::*;\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n pub struct TypePass;\n \n-/// **What it does:** This lint checks for use of `Box<Vec<_>>` anywhere in the code.\n+/// **What it does:** This lint checks for use of `Box<Vec<_>>` anywhere in the code. It is `Warn` by default.\n ///\n /// **Why is this bad?** `Vec` already keeps its contents in a separate area on the heap. So if you `Box` it, you just add another level of indirection without any benefit whatsoever.\n ///\n@@ -26,7 +24,8 @@ pub struct TypePass;\n /// **Example:** `struct X { values: Box<Vec<Foo>> }`\n declare_lint!(pub BOX_VEC, Warn,\n               \"usage of `Box<Vec<T>>`, vector elements are already on the heap\");\n-/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or a `VecDeque` (formerly called `RingBuf`).\n+\n+/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or a `VecDeque` (formerly called `RingBuf`). It is `Warn` by default.\n ///\n /// **Why is this bad?** Gankro says:\n ///\n@@ -49,6 +48,9 @@ impl LintPass for TypePass {\n \n impl LateLintPass for TypePass {\n     fn check_ty(&mut self, cx: &LateContext, ast_ty: &Ty) {\n+        if in_macro(cx, ast_ty.span) {\n+            return\n+        }\n         if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n             if let ty::TyBox(ref inner) = ty.sty {\n                 if match_type(cx, inner, &VEC_PATH) {"}, {"sha": "90e8e27b4f05540e18bc7ecfecf4ded656d6eea3", "filename": "src/utils.rs", "status": "modified", "additions": 90, "deletions": 26, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -8,9 +8,14 @@ use rustc::middle::ty;\n use std::borrow::Cow;\n use syntax::ast::Lit_::*;\n use syntax::ast;\n+use syntax::errors::DiagnosticBuilder;\n+use syntax::ptr::P;\n \n use rustc::session::Session;\n use std::str::FromStr;\n+use std::ops::{Deref, DerefMut};\n+\n+pub type MethodArgs = HirVec<P<Expr>>;\n \n // module DefPaths for certain structs/enums we check for\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n@@ -21,6 +26,7 @@ pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"Linke\n pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const MUTEX_PATH:  [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const CLONE_PATH:  [&'static str; 2] = [\"Clone\", \"clone\"];\n+pub const BEGIN_UNWIND:[&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n@@ -68,6 +74,10 @@ macro_rules! if_let_chain {\n     };\n }\n \n+/// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one isn't)\n+pub fn differing_macro_contexts(sp1: Span, sp2: Span) -> bool {\n+    sp1.expn_id != sp2.expn_id\n+}\n /// returns true if this expn_info was expanded by any macro\n pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id,\n@@ -135,6 +145,7 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n         false\n     }\n }\n+\n /// check if method call given in \"expr\" belongs to given trait\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n@@ -162,6 +173,31 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n         |(a, b)| a.identifier.name.as_str() == *b)\n }\n \n+/// match an Expr against a chain of methods, and return the matched Exprs. For example, if `expr`\n+/// represents the `.baz()` in `foo.bar().baz()`, `matched_method_chain(expr, &[\"bar\", \"baz\"])`\n+/// will return a Vec containing the Exprs for `.bar()` and `.baz()`\n+pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a MethodArgs>> {\n+    let mut current = expr;\n+    let mut matched = Vec::with_capacity(methods.len());\n+    for method_name in methods.iter().rev() { // method chains are stored last -> first\n+        if let ExprMethodCall(ref name, _, ref args) = current.node {\n+            if name.node.as_str() == *method_name {\n+                matched.push(args); // build up `matched` backwards\n+                current = &args[0] // go to parent expression\n+            }\n+            else {\n+                return None;\n+            }\n+        }\n+        else {\n+            return None;\n+        }\n+    }\n+    matched.reverse(); // reverse `matched`, so that it is in the same order as `methods`\n+    Some(matched)\n+}\n+\n+\n /// get the name of the item the expression is in, if available\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n@@ -277,63 +313,91 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n     } else { None }\n }\n \n+pub struct DiagnosticWrapper<'a>(pub DiagnosticBuilder<'a>);\n+\n+impl<'a> Drop for DiagnosticWrapper<'a> {\n+    fn drop(&mut self) {\n+        self.0.emit();\n+    }\n+}\n+\n+impl<'a> DerefMut for DiagnosticWrapper<'a> {\n+    fn deref_mut(&mut self) -> &mut DiagnosticBuilder<'a> {\n+        &mut self.0\n+    } \n+}\n+\n+impl<'a> Deref for DiagnosticWrapper<'a> {\n+    type Target = DiagnosticBuilder<'a>;\n+    fn deref(&self) -> &DiagnosticBuilder<'a> {\n+        &self.0\n+    } \n+}\n+\n #[cfg(not(feature=\"structured_logging\"))]\n-pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n-    cx.span_lint(lint, sp, msg);\n+pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint,\n+                                     sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n+    let mut db = cx.struct_span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+        db.fileline_help(sp, &format!(\"for further information visit \\\n             https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()))\n+            lint.name_lower()));\n     }\n+    DiagnosticWrapper(db)\n }\n \n #[cfg(feature=\"structured_logging\")]\n-pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n+pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint,\n+                                     sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n     // lint.name / lint.desc is can give details of the lint\n     // cx.sess().codemap() has all these nice functions for line/column/snippet details\n     // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n-    cx.span_lint(lint, sp, msg);\n+    let mut db = cx.struct_span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+        db.fileline_help(sp, &format!(\"for further information visit \\\n             https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()))\n+            lint.name_lower()));\n     }\n+    DiagnosticWrapper(db)\n }\n \n-pub fn span_help_and_lint<T: LintContext>(cx: &T, lint: &'static Lint, span: Span,\n-        msg: &str, help: &str) {\n-    cx.span_lint(lint, span, msg);\n+pub fn span_help_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span,\n+        msg: &str, help: &str) -> DiagnosticWrapper<'a> {\n+    let mut db = cx.struct_span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        cx.sess().fileline_help(span, &format!(\"{}\\nfor further information \\\n+        db.fileline_help(span, &format!(\"{}\\nfor further information \\\n             visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            help, lint.name_lower()))\n+            help, lint.name_lower()));\n     }\n+    DiagnosticWrapper(db)\n }\n \n-pub fn span_note_and_lint<T: LintContext>(cx: &T, lint: &'static Lint, span: Span,\n-        msg: &str, note_span: Span, note: &str) {\n-    cx.span_lint(lint, span, msg);\n+pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span,\n+        msg: &str, note_span: Span, note: &str) -> DiagnosticWrapper<'a> {\n+    let mut db = cx.struct_span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n         if note_span == span {\n-            cx.sess().fileline_note(note_span, note)\n+            db.fileline_note(note_span, note);\n         } else {\n-            cx.sess().span_note(note_span, note)\n+            db.span_note(note_span, note);\n         }\n-        cx.sess().fileline_help(span, &format!(\"for further information visit \\\n+        db.fileline_help(span, &format!(\"for further information visit \\\n             https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()))\n+            lint.name_lower()));\n     }\n+    DiagnosticWrapper(db)\n }\n \n-pub fn span_lint_and_then<T: LintContext, F>(cx: &T, lint: &'static Lint, sp: Span,\n-        msg: &str, f: F) where F: Fn() {\n-    cx.span_lint(lint, sp, msg);\n+pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span,\n+        msg: &str, f: F) -> DiagnosticWrapper<'a> where F: Fn(&mut DiagnosticWrapper) {\n+    let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n-        f();\n-        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+        f(&mut db);\n+        db.fileline_help(sp, &format!(\"for further information visit \\\n             https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()))\n+            lint.name_lower()));\n     }\n+    db\n }\n \n /// return the base type for references and raw pointers"}, {"sha": "5a4d3931606f8e1ebcd72fd083fe8682b30095e3", "filename": "src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/src%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fzero_div_zero.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -9,7 +9,7 @@ use consts::{Constant, constant_simple, FloatWidth};\n /// 0.0/0.0 with std::f32::NaN or std::f64::NaN, depending on the precision.\n pub struct ZeroDivZeroPass;\n \n-/// **What it does:** This lint checks for `0.0 / 0.0`\n+/// **What it does:** This lint checks for `0.0 / 0.0`. It is `Warn` by default.\n ///\n /// **Why is this bad?** It's less readable than `std::f32::NAN` or `std::f64::NAN`\n ///"}, {"sha": "0a68d80c339e2ca1dda4c4ad2390d3266d2551d3", "filename": "tests/compile-fail/block_in_if_condition.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fblock_in_if_condition.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -5,6 +5,15 @@\n #![deny(block_in_if_condition_stmt)]\n #![allow(unused)]\n \n+\n+macro_rules! blocky {\n+    () => {{true}}\n+}\n+\n+fn macro_if() {\n+    if blocky!() {\n+    }\n+}\n fn condition_has_block() -> i32 {\n \n     if { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n@@ -60,5 +69,14 @@ fn closure_without_block() {\n     }\n }\n \n+fn condition_is_unsafe_block() {\n+    let a: i32 = 1;\n+\n+    // this should not warn because the condition is an unsafe block\n+    if unsafe { 1u32 == std::mem::transmute(a) } {\n+        println!(\"1u32 == a\");\n+    }\n+}\n+\n fn main() {\n }"}, {"sha": "4fd98cd52ff3be4fd3e30525a7572100f857a05c", "filename": "tests/compile-fail/box_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbox_vec.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -3,6 +3,15 @@\n #![plugin(clippy)]\n #![deny(clippy)]\n \n+macro_rules! boxit {\n+    ($init:expr, $x:ty) => {\n+        let _: Box<$x> = Box::new($init);\n+    }\n+}\n+\n+fn test_macro() {\n+    boxit!(Vec::new(), Vec<u8>);\n+}\n pub fn test(foo: Box<Vec<bool>>) { //~ ERROR you seem to be trying to use `Box<Vec<T>>`\n     println!(\"{:?}\", foo.get(0))\n }\n@@ -14,4 +23,5 @@ pub fn test2(foo: Box<Fn(Vec<u32>)>) { // pass if #31 is fixed\n fn main(){\n     test(Box::new(Vec::new()));\n     test2(Box::new(|v| println!(\"{:?}\", v)));\n+    test_macro();\n }"}, {"sha": "f79440af1210f6fc684822dc995ee0cc201eaa66", "filename": "tests/compile-fail/cyclomatic_complexity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -4,7 +4,8 @@\n #![deny(cyclomatic_complexity)]\n #![allow(unused)]\n \n-fn main() { //~ ERROR: The function has a cyclomatic complexity of 28.\n+\n+fn main() { //~ERROR The function has a cyclomatic complexity of 28\n     if true {\n         println!(\"a\");\n     }"}, {"sha": "b41b28dc11e44592ac6258abdd39e70bad7bb400", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -50,7 +50,7 @@ fn option_methods() {\n     // Check OPTION_MAP_UNWRAP_OR\n     // single line case\n     let _ = opt.map(|x| x + 1) //~  ERROR called `map(f).unwrap_or(a)`\n-                               //~| NOTE replace this\n+                               //~| NOTE replace `map(|x| x + 1).unwrap_or(0)`\n                .unwrap_or(0); // should lint even though this call is on a separate line\n     // multi line cases\n     let _ = opt.map(|x| { //~ ERROR called `map(f).unwrap_or(a)`\n@@ -67,7 +67,7 @@ fn option_methods() {\n     // Check OPTION_MAP_UNWRAP_OR_ELSE\n     // single line case\n     let _ = opt.map(|x| x + 1) //~  ERROR called `map(f).unwrap_or_else(g)`\n-                               //~| NOTE replace this\n+                               //~| NOTE replace `map(|x| x + 1).unwrap_or_else(|| 0)`\n                .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n     // multi line cases\n     let _ = opt.map(|x| { //~ ERROR called `map(f).unwrap_or_else(g)`\n@@ -83,6 +83,98 @@ fn option_methods() {\n \n }\n \n+/// Struct to generate false positive for Iterator-based lints\n+#[derive(Copy, Clone)]\n+struct IteratorFalsePositives {\n+    foo: u32,\n+}\n+\n+impl IteratorFalsePositives {\n+    fn filter(self) -> IteratorFalsePositives {\n+        self\n+    }\n+\n+    fn next(self) -> IteratorFalsePositives {\n+        self\n+    }\n+\n+    fn find(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+\n+    fn position(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+\n+    fn rposition(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+}\n+\n+/// Checks implementation of FILTER_NEXT lint\n+fn filter_next() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // check single-line case\n+    let _ = v.iter().filter(|&x| *x < 0).next();\n+    //~^ ERROR called `filter(p).next()` on an Iterator.\n+    //~| NOTE replace `filter(|&x| *x < 0).next()`\n+\n+    // check multi-line case\n+    let _ = v.iter().filter(|&x| { //~ERROR called `filter(p).next()` on an Iterator.\n+                                *x < 0\n+                            }\n+                   ).next();\n+\n+    // check that we don't lint if the caller is not an Iterator\n+    let foo = IteratorFalsePositives { foo: 0 };\n+    let _ = foo.filter().next();\n+}\n+\n+/// Checks implementation of SEARCH_IS_SOME lint\n+fn search_is_some() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // check `find().is_some()`, single-line\n+    let _ = v.iter().find(|&x| *x < 0).is_some();\n+    //~^ ERROR called `is_some()` after searching\n+    //~| NOTE replace `find(|&x| *x < 0).is_some()`\n+\n+    // check `find().is_some()`, multi-line\n+    let _ = v.iter().find(|&x| { //~ERROR called `is_some()` after searching\n+                              *x < 0\n+                          }\n+                   ).is_some();\n+\n+    // check `position().is_some()`, single-line\n+    let _ = v.iter().position(|&x| x < 0).is_some();\n+    //~^ ERROR called `is_some()` after searching\n+    //~| NOTE replace `position(|&x| x < 0).is_some()`\n+\n+    // check `position().is_some()`, multi-line\n+    let _ = v.iter().position(|&x| { //~ERROR called `is_some()` after searching\n+                                  x < 0\n+                              }\n+                   ).is_some();\n+\n+    // check `rposition().is_some()`, single-line\n+    let _ = v.iter().rposition(|&x| x < 0).is_some();\n+    //~^ ERROR called `is_some()` after searching\n+    //~| NOTE replace `rposition(|&x| x < 0).is_some()`\n+\n+    // check `rposition().is_some()`, multi-line\n+    let _ = v.iter().rposition(|&x| { //~ERROR called `is_some()` after searching\n+                                   x < 0\n+                               }\n+                   ).is_some();\n+\n+    // check that we don't lint if the caller is not an Iterator\n+    let foo = IteratorFalsePositives { foo: 0 };\n+    let _ = foo.find().is_some();\n+    let _ = foo.position().is_some();\n+    let _ = foo.rposition().is_some();\n+}\n+\n fn main() {\n     use std::io;\n "}, {"sha": "36427f4330b8b1c1f7979e8ae08676f817fedce0", "filename": "tests/compile-fail/panic.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542685dad19bf6af1cc00224ed3b46ab7ca37a94/tests%2Fcompile-fail%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic.rs?ref=542685dad19bf6af1cc00224ed3b46ab7ca37a94", "patch": "@@ -0,0 +1,22 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(panic_params)]\n+\n+fn missing() {\n+    panic!(\"{}\"); //~ERROR: You probably are missing some parameter\n+}\n+\n+fn ok_sigle() {\n+    panic!(\"foo bar\");\n+}\n+\n+fn ok_multiple() {\n+    panic!(\"{}\", \"This is {ok}\");\n+}\n+\n+fn main() {\n+    missing();\n+    ok_sigle();\n+    ok_multiple();\n+}"}]}