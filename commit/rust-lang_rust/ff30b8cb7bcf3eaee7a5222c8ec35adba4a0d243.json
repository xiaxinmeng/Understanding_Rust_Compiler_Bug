{"sha": "ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "node_id": "C_kwDOAAsO6NoAKGZmMzBiOGNiN2JjZjNlYWVlN2E1MjIyYzhlYzM1YWRiYTRhMGQyNDM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-05-09T07:03:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-09T07:03:45Z"}, "message": "Rollup merge of #110583 - Ezrashaw:tweak-make-mut-spans, r=estebank\n\ntweak \"make mut\" spans when assigning to locals\n\nWork towards fixing #106857\n\nThis PR just cleans up a lot of spans which is helpful before properly fixing the issues. Best reviewed commit-by-commit.\n\nr? `@estebank`", "tree": {"sha": "d90ab8240dc85abb5809e70e78a54d647b86498c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d90ab8240dc85abb5809e70e78a54d647b86498c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkWfBRCRBK7hj4Ov3rIwAAwS0IAKYHEgTvQj6/wixMcTnf/5AL\nV4kFROrcJrIzcnN4FkLnRQ5kFuZw95A1KFK8eXlEMD8SkTsI0qsEEqw78WaXBzPB\nUmwL7+2qq2xSf0ZC5EOBJcmfTg/rLy/YGsg9ZZEumcAPN/fTns/vwEaiY3jygGXk\nwtHAXinc4WaxRDpJz7JinTTRVlPuTXAqBhggHtf2QXkyMLgRAn5Ddkn+lSPHpocG\n4I/jg4qqThz4FUbRyg5Cof+GManp9vep5K5tG+XgLEyPKJMSVBZr0koQLq2abDMS\nEVOw//wz0y4s1N/NUiZND13iQbX1LuIycj7n2c7J493evZ5oxlkHD4uDaOZVaWk=\n=If89\n-----END PGP SIGNATURE-----\n", "payload": "tree d90ab8240dc85abb5809e70e78a54d647b86498c\nparent 2ecc72217b4f134a1ae8b6433af9491bf5d26cf0\nparent 3e64e986fe1cbaa3679cd228a6900304ebf81018\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1683615825 +0530\ncommitter GitHub <noreply@github.com> 1683615825 +0530\n\nRollup merge of #110583 - Ezrashaw:tweak-make-mut-spans, r=estebank\n\ntweak \"make mut\" spans when assigning to locals\n\nWork towards fixing #106857\n\nThis PR just cleans up a lot of spans which is helpful before properly fixing the issues. Best reviewed commit-by-commit.\n\nr? `@estebank`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "html_url": "https://github.com/rust-lang/rust/commit/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ecc72217b4f134a1ae8b6433af9491bf5d26cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ecc72217b4f134a1ae8b6433af9491bf5d26cf0", "html_url": "https://github.com/rust-lang/rust/commit/2ecc72217b4f134a1ae8b6433af9491bf5d26cf0"}, {"sha": "3e64e986fe1cbaa3679cd228a6900304ebf81018", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e64e986fe1cbaa3679cd228a6900304ebf81018", "html_url": "https://github.com/rust-lang/rust/commit/3e64e986fe1cbaa3679cd228a6900304ebf81018"}], "stats": {"total": 661, "additions": 338, "deletions": 323}, "files": [{"sha": "6286033e0672d2bf2a041c1705def878ddfb582c", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 264, "deletions": 245, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -1,4 +1,4 @@\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n@@ -478,186 +478,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let label = match *local_decl.local_info() {\n-                            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n-                                let (span, suggestion) =\n-                                    suggest_ampmut_self(self.infcx.tcx, local_decl);\n-                                Some((true, span, suggestion))\n-                            }\n-\n-                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByValue(_),\n-                                opt_ty_info,\n-                                ..\n-                            })) => {\n-                                // check if the RHS is from desugaring\n-                                let opt_assignment_rhs_span =\n-                                    self.body.find_assignments(local).first().map(|&location| {\n-                                        if let Some(mir::Statement {\n-                                            source_info: _,\n-                                            kind:\n-                                                mir::StatementKind::Assign(box (\n-                                                    _,\n-                                                    mir::Rvalue::Use(mir::Operand::Copy(place)),\n-                                                )),\n-                                        }) = self.body[location.block]\n-                                            .statements\n-                                            .get(location.statement_index)\n-                                        {\n-                                            self.body.local_decls[place.local].source_info.span\n-                                        } else {\n-                                            self.body.source_info(location).span\n-                                        }\n-                                    });\n-                                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n-                                    // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => {\n-                                        self.suggest_similar_mut_method_for_for_loop(&mut err);\n-                                        err.span_label(opt_assignment_rhs_span.unwrap(), format!(\n-                                            \"this iterator yields `{pointer_sigil}` {pointer_desc}s\",\n-                                        ));\n-                                        None\n-                                    }\n-                                    // don't create labels for compiler-generated spans\n-                                    Some(_) => None,\n-                                    None => {\n-                                        let label = if name != kw::SelfLower {\n-                                            suggest_ampmut(\n-                                                self.infcx.tcx,\n-                                                local_decl,\n-                                                opt_assignment_rhs_span,\n-                                                opt_ty_info,\n-                                            )\n-                                        } else {\n-                                            match local_decl.local_info() {\n-                                                LocalInfo::User(mir::BindingForm::Var(\n-                                                    mir::VarBindingForm {\n-                                                        opt_ty_info: None, ..\n-                                                    },\n-                                                )) => {\n-                                                    let (span, sugg) = suggest_ampmut_self(\n-                                                        self.infcx.tcx,\n-                                                        local_decl,\n-                                                    );\n-                                                    (true, span, sugg)\n-                                                }\n-                                                // explicit self (eg `self: &'a Self`)\n-                                                _ => suggest_ampmut(\n-                                                    self.infcx.tcx,\n-                                                    local_decl,\n-                                                    opt_assignment_rhs_span,\n-                                                    opt_ty_info,\n-                                                ),\n-                                            }\n-                                        };\n-                                        Some(label)\n-                                    }\n-                                }\n-                            }\n-\n-                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByReference(_),\n-                                ..\n-                            })) => {\n-                                let pattern_span = local_decl.source_info.span;\n-                                suggest_ref_mut(self.infcx.tcx, pattern_span)\n-                                    .map(|replacement| (true, pattern_span, replacement))\n-                            }\n-\n-                            _ => unreachable!(),\n-                        };\n-\n-                        match label {\n-                            Some((true, err_help_span, suggested_code)) => {\n-                                let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n-                                if !is_trait_sig {\n-                                    err.span_suggestion_verbose(\n-                                        err_help_span,\n-                                        format!(\n-                                            \"consider changing this to be a mutable {pointer_desc}\"\n-                                        ),\n-                                        suggested_code,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                } else if let Some(x) = local_trait {\n-                                    err.span_suggestion_verbose(\n-                                        x,\n-                                        format!(\n-                                            \"consider changing that to be a mutable {pointer_desc}\"\n-                                        ),\n-                                        suggested_code,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                            }\n-                            Some((false, err_label_span, message)) => {\n-                                struct BindingFinder {\n-                                    span: Span,\n-                                    hir_id: Option<hir::HirId>,\n-                                }\n-\n-                                impl<'tcx> Visitor<'tcx> for BindingFinder {\n-                                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-                                        if let hir::StmtKind::Local(local) = s.kind {\n-                                            if local.pat.span == self.span {\n-                                                self.hir_id = Some(local.hir_id);\n-                                            }\n-                                        }\n-                                        hir::intravisit::walk_stmt(self, s);\n-                                    }\n-                                }\n-                                let hir_map = self.infcx.tcx.hir();\n-                                let def_id = self.body.source.def_id();\n-                                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n-                                let node = hir_map.find(hir_id);\n-                                let hir_id = if let Some(hir::Node::Item(item)) = node\n-                                    && let hir::ItemKind::Fn(.., body_id) = item.kind\n-                                {\n-                                    let body = hir_map.body(body_id);\n-                                    let mut v = BindingFinder {\n-                                        span: err_label_span,\n-                                        hir_id: None,\n-                                    };\n-                                    v.visit_body(body);\n-                                    v.hir_id\n-                                } else {\n-                                    None\n-                                };\n-                                if let Some(hir_id) = hir_id\n-                                    && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n-                                {\n-                                    let (changing, span, sugg) = match local.ty {\n-                                        Some(ty) => (\"changing\", ty.span, message),\n-                                        None => (\n-                                            \"specifying\",\n-                                            local.pat.span.shrink_to_hi(),\n-                                            format!(\": {message}\"),\n-                                        ),\n-                                    };\n-                                    err.span_suggestion_verbose(\n-                                        span,\n-                                        format!(\"consider {changing} this binding's type\"),\n-                                        sugg,\n-                                        Applicability::HasPlaceholders,\n-                                    );\n-                                } else {\n-                                    err.span_label(\n-                                        err_label_span,\n-                                        format!(\n-                                            \"consider changing this binding's type to be: `{message}`\"\n-                                        ),\n-                                    );\n-                                }\n-                            }\n-                            None => {}\n-                        }\n                         err.span_label(\n                             span,\n                             format!(\n                                 \"`{name}` is a `{pointer_sigil}` {pointer_desc}, \\\n                                  so the data it refers to cannot be {acted_on}\",\n                             ),\n                         );\n+\n+                        self.suggest_make_local_mut(&mut err, local, name);\n                     }\n                     _ => {\n                         err.span_label(\n@@ -1131,6 +960,184 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn suggest_make_local_mut(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        local: Local,\n+        name: Symbol,\n+    ) {\n+        let local_decl = &self.body.local_decls[local];\n+\n+        let (pointer_sigil, pointer_desc) =\n+            if local_decl.ty.is_ref() { (\"&\", \"reference\") } else { (\"*const\", \"pointer\") };\n+\n+        let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n+        if is_trait_sig && local_trait.is_none() {\n+            return;\n+        }\n+\n+        let decl_span = match local_trait {\n+            Some(span) => span,\n+            None => local_decl.source_info.span,\n+        };\n+\n+        let label = match *local_decl.local_info() {\n+            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n+                let suggestion = suggest_ampmut_self(self.infcx.tcx, decl_span);\n+                Some((true, decl_span, suggestion))\n+            }\n+\n+            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(_),\n+                opt_ty_info,\n+                ..\n+            })) => {\n+                // check if the RHS is from desugaring\n+                let opt_assignment_rhs_span =\n+                    self.body.find_assignments(local).first().map(|&location| {\n+                        if let Some(mir::Statement {\n+                            source_info: _,\n+                            kind:\n+                                mir::StatementKind::Assign(box (\n+                                    _,\n+                                    mir::Rvalue::Use(mir::Operand::Copy(place)),\n+                                )),\n+                        }) = self.body[location.block].statements.get(location.statement_index)\n+                        {\n+                            self.body.local_decls[place.local].source_info.span\n+                        } else {\n+                            self.body.source_info(location).span\n+                        }\n+                    });\n+                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n+                    // on for loops, RHS points to the iterator part\n+                    Some(DesugaringKind::ForLoop) => {\n+                        self.suggest_similar_mut_method_for_for_loop(err);\n+                        err.span_label(\n+                            opt_assignment_rhs_span.unwrap(),\n+                            format!(\"this iterator yields `{pointer_sigil}` {pointer_desc}s\",),\n+                        );\n+                        None\n+                    }\n+                    // don't create labels for compiler-generated spans\n+                    Some(_) => None,\n+                    None => {\n+                        let label = if name != kw::SelfLower {\n+                            suggest_ampmut(\n+                                self.infcx.tcx,\n+                                local_decl.ty,\n+                                decl_span,\n+                                opt_assignment_rhs_span,\n+                                opt_ty_info,\n+                            )\n+                        } else {\n+                            match local_decl.local_info() {\n+                                LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                                    opt_ty_info: None,\n+                                    ..\n+                                })) => {\n+                                    let sugg = suggest_ampmut_self(self.infcx.tcx, decl_span);\n+                                    (true, decl_span, sugg)\n+                                }\n+                                // explicit self (eg `self: &'a Self`)\n+                                _ => suggest_ampmut(\n+                                    self.infcx.tcx,\n+                                    local_decl.ty,\n+                                    decl_span,\n+                                    opt_assignment_rhs_span,\n+                                    opt_ty_info,\n+                                ),\n+                            }\n+                        };\n+                        Some(label)\n+                    }\n+                }\n+            }\n+\n+            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByReference(_),\n+                ..\n+            })) => {\n+                let pattern_span: Span = local_decl.source_info.span;\n+                suggest_ref_mut(self.infcx.tcx, pattern_span)\n+                    .map(|span| (true, span, \"mut \".to_owned()))\n+            }\n+\n+            _ => unreachable!(),\n+        };\n+\n+        match label {\n+            Some((true, err_help_span, suggested_code)) => {\n+                err.span_suggestion_verbose(\n+                    err_help_span,\n+                    format!(\"consider changing this to be a mutable {pointer_desc}\"),\n+                    suggested_code,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((false, err_label_span, message)) => {\n+                struct BindingFinder {\n+                    span: Span,\n+                    hir_id: Option<hir::HirId>,\n+                }\n+\n+                impl<'tcx> Visitor<'tcx> for BindingFinder {\n+                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n+                        if let hir::StmtKind::Local(local) = s.kind {\n+                            if local.pat.span == self.span {\n+                                self.hir_id = Some(local.hir_id);\n+                            }\n+                        }\n+                        hir::intravisit::walk_stmt(self, s);\n+                    }\n+                }\n+                let hir_map = self.infcx.tcx.hir();\n+                let def_id = self.body.source.def_id();\n+                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n+                let node = hir_map.find(hir_id);\n+                let hir_id = if let Some(hir::Node::Item(item)) = node\n+                && let hir::ItemKind::Fn(.., body_id) = item.kind\n+            {\n+                let body = hir_map.body(body_id);\n+                let mut v = BindingFinder {\n+                    span: err_label_span,\n+                    hir_id: None,\n+                };\n+                v.visit_body(body);\n+                v.hir_id\n+            } else {\n+                None\n+            };\n+                if let Some(hir_id) = hir_id\n+                && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n+            {\n+                let (changing, span, sugg) = match local.ty {\n+                    Some(ty) => (\"changing\", ty.span, message),\n+                    None => (\n+                        \"specifying\",\n+                        local.pat.span.shrink_to_hi(),\n+                        format!(\": {message}\"),\n+                    ),\n+                };\n+                err.span_suggestion_verbose(\n+                    span,\n+                    format!(\"consider {changing} this binding's type\"),\n+                    sugg,\n+                    Applicability::HasPlaceholders,\n+                );\n+            } else {\n+                err.span_label(\n+                    err_label_span,\n+                    format!(\n+                        \"consider changing this binding's type to be: `{message}`\"\n+                    ),\n+                );\n+            }\n+            }\n+            None => {}\n+        }\n+    }\n }\n \n pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n@@ -1160,25 +1167,18 @@ pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<\n     }\n }\n \n-fn suggest_ampmut_self<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    local_decl: &mir::LocalDecl<'tcx>,\n-) -> (Span, String) {\n-    let sp = local_decl.source_info.span;\n-    (\n-        sp,\n-        match tcx.sess.source_map().span_to_snippet(sp) {\n-            Ok(snippet) => {\n-                let lt_pos = snippet.find('\\'');\n-                if let Some(lt_pos) = lt_pos {\n-                    format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n-                } else {\n-                    \"&mut self\".to_string()\n-                }\n+fn suggest_ampmut_self<'tcx>(tcx: TyCtxt<'tcx>, span: Span) -> String {\n+    match tcx.sess.source_map().span_to_snippet(span) {\n+        Ok(snippet) => {\n+            let lt_pos = snippet.find('\\'');\n+            if let Some(lt_pos) = lt_pos {\n+                format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n+            } else {\n+                \"&mut self\".to_string()\n             }\n-            _ => \"&mut self\".to_string(),\n-        },\n-    )\n+        }\n+        _ => \"&mut self\".to_string(),\n+    }\n }\n \n // When we want to suggest a user change a local variable to be a `&mut`, there\n@@ -1198,72 +1198,89 @@ fn suggest_ampmut_self<'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    local_decl: &mir::LocalDecl<'tcx>,\n+    decl_ty: Ty<'tcx>,\n+    decl_span: Span,\n     opt_assignment_rhs_span: Option<Span>,\n     opt_ty_info: Option<Span>,\n ) -> (bool, Span, String) {\n+    // if there is a RHS and it starts with a `&` from it, then check if it is\n+    // mutable, and if not, put suggest putting `mut ` to make it mutable.\n+    // we don't have to worry about lifetime annotations here because they are\n+    // not valid when taking a reference. For example, the following is not valid Rust:\n+    //\n+    // let x: &i32 = &'a 5;\n+    //                ^^ lifetime annotation not allowed\n+    //\n     if let Some(assignment_rhs_span) = opt_assignment_rhs_span\n         && let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span)\n+        && let Some(stripped) = src.strip_prefix('&')\n     {\n-        let is_mutbl = |ty: &str| -> bool {\n-            if let Some(rest) = ty.strip_prefix(\"mut\") {\n-                match rest.chars().next() {\n-                    // e.g. `&mut x`\n-                    Some(c) if c.is_whitespace() => true,\n-                    // e.g. `&mut(x)`\n-                    Some('(') => true,\n-                    // e.g. `&mut{x}`\n-                    Some('{') => true,\n-                    // e.g. `&mutablevar`\n-                    _ => false,\n-                }\n-            } else {\n-                false\n+        let is_mut = if let Some(rest) = stripped.trim_start().strip_prefix(\"mut\") {\n+            match rest.chars().next() {\n+                // e.g. `&mut x`\n+                Some(c) if c.is_whitespace() => true,\n+                // e.g. `&mut(x)`\n+                Some('(') => true,\n+                // e.g. `&mut{x}`\n+                Some('{') => true,\n+                // e.g. `&mutablevar`\n+                _ => false,\n             }\n+        } else {\n+            false\n         };\n-        if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n-            let lt_name = &src[1..ws_pos];\n-            let ty = src[ws_pos..].trim_start();\n-            if !is_mutbl(ty) {\n-                return (true, assignment_rhs_span, format!(\"&{lt_name} mut {ty}\"));\n-            }\n-        } else if let Some(stripped) = src.strip_prefix('&') {\n-            let stripped = stripped.trim_start();\n-            if !is_mutbl(stripped) {\n-                return (true, assignment_rhs_span, format!(\"&mut {stripped}\"));\n-            }\n+        // if the reference is already mutable then there is nothing we can do\n+        // here.\n+        if !is_mut {\n+            let span = assignment_rhs_span;\n+            // shrink the span to just after the `&` in `&variable`\n+            let span = span.with_lo(span.lo() + BytePos(1)).shrink_to_lo();\n+\n+            // FIXME(Ezrashaw): returning is bad because we still might want to\n+            // update the annotated type, see #106857.\n+            return (true, span, \"mut \".to_owned());\n         }\n     }\n \n-    let (suggestibility, highlight_span) = match opt_ty_info {\n+    let (binding_exists, span) = match opt_ty_info {\n         // if this is a variable binding with an explicit type,\n-        // try to highlight that for the suggestion.\n+        // then we will suggest changing it to be mutable.\n+        // this is `Applicability::MachineApplicable`.\n         Some(ty_span) => (true, ty_span),\n \n-        // otherwise, just highlight the span associated with\n-        // the (MIR) LocalDecl.\n-        None => (false, local_decl.source_info.span),\n+        // otherwise, we'll suggest *adding* an annotated type, we'll suggest\n+        // the RHS's type for that.\n+        // this is `Applicability::HasPlaceholders`.\n+        None => (false, decl_span),\n     };\n \n-    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span)\n-        && let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace))\n+    // if the binding already exists and is a reference with a explicit\n+    // lifetime, then we can suggest adding ` mut`. this is special-cased from\n+    // the path without a explicit lifetime.\n+    if let Ok(src) = tcx.sess.source_map().span_to_snippet(span)\n+        && src.starts_with(\"&'\")\n+        // note that `&     'a T` is invalid so this is correct.\n+        && let Some(ws_pos) = src.find(char::is_whitespace)\n     {\n-        let lt_name = &src[1..ws_pos];\n-        let ty = &src[ws_pos..];\n-        return (true, highlight_span, format!(\"&{lt_name} mut{ty}\"));\n-    }\n+        let span = span.with_lo(span.lo() + BytePos(ws_pos as u32)).shrink_to_lo();\n+        (true, span, \" mut\".to_owned())\n+    // if there is already a binding, we modify it to be `mut`\n+    } else if binding_exists {\n+        // shrink the span to just after the `&` in `&variable`\n+        let span = span.with_lo(span.lo() + BytePos(1)).shrink_to_lo();\n+        (true, span, \"mut \".to_owned())\n+    } else {\n+        // otherwise, suggest that the user annotates the binding; we provide the\n+        // type of the local.\n+        let ty_mut = decl_ty.builtin_deref(true).unwrap();\n+        assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n \n-    let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-    assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n-    (\n-        suggestibility,\n-        highlight_span,\n-        if local_decl.ty.is_ref() {\n-            format!(\"&mut {}\", ty_mut.ty)\n-        } else {\n-            format!(\"*mut {}\", ty_mut.ty)\n-        },\n-    )\n+        (\n+            false,\n+            span,\n+            format!(\"{}mut {}\", if decl_ty.is_ref() {\"&\"} else {\"*\"}, ty_mut.ty)\n+        )\n+    }\n }\n \n fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n@@ -1300,11 +1317,13 @@ fn get_mut_span_in_struct_field<'tcx>(\n }\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<String> {\n-    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).ok()?;\n-    if hi_src.starts_with(\"ref\") && hi_src[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace) {\n-        let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n-        Some(replacement)\n+fn suggest_ref_mut(tcx: TyCtxt<'_>, span: Span) -> Option<Span> {\n+    let pattern_str = tcx.sess.source_map().span_to_snippet(span).ok()?;\n+    if pattern_str.starts_with(\"ref\")\n+        && pattern_str[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace)\n+    {\n+        let span = span.with_lo(span.lo() + BytePos(4)).shrink_to_lo();\n+        Some(span)\n     } else {\n         None\n     }"}, {"sha": "c33919c41cdc2c2d6bc7becb74ba5912675b2511", "filename": "tests/ui/array-slice-vec/slice-mut-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Farray-slice-vec%2Fslice-mut-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Farray-slice-vec%2Fslice-mut-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farray-slice-vec%2Fslice-mut-2.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     let _ = &mut x[2..4];\n help: consider changing this to be a mutable reference\n    |\n LL |     let x: &[isize] = &mut [1, 2, 3, 4, 5];\n-   |                       ~~~~~~~~~~~~~~~~~~~~\n+   |                        +++\n \n error: aborting due to previous error\n "}, {"sha": "cfc86ff0dc1216d2b274522b561ffd6dc6af453c", "filename": "tests/ui/borrowck/borrow-raw-address-of-deref-mutability.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     let q = &raw mut *x;\n help: consider changing this to be a mutable reference\n    |\n LL |     let x = &mut 0;\n-   |             ~~~~~~\n+   |              +++\n \n error[E0596]: cannot borrow `*x` as mutable, as it is behind a `*const` pointer\n   --> $DIR/borrow-raw-address-of-deref-mutability.rs:14:13\n@@ -18,7 +18,7 @@ LL |     let q = &raw mut *x;\n help: consider changing this to be a mutable pointer\n    |\n LL |     let x = &mut 0 as *const i32;\n-   |             ~~~~~~\n+   |              +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c161e2d95b43a06b0a1c62657c501e5449c65238", "filename": "tests/ui/borrowck/borrowck-access-permissions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-access-permissions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-access-permissions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-access-permissions.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -35,7 +35,7 @@ LL |         let _y1 = &mut *ref_x;\n help: consider changing this to be a mutable reference\n    |\n LL |         let ref_x = &mut x;\n-   |                     ~~~~~~\n+   |                      +++\n \n error[E0596]: cannot borrow `*ptr_x` as mutable, as it is behind a `*const` pointer\n   --> $DIR/borrowck-access-permissions.rs:39:23\n@@ -46,7 +46,7 @@ LL |             let _y1 = &mut *ptr_x;\n help: consider changing this to be a mutable pointer\n    |\n LL |         let ptr_x : *const _ = &mut x;\n-   |                                ~~~~~~\n+   |                                 +++\n \n error[E0596]: cannot borrow `*foo_ref.f` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-access-permissions.rs:48:18\n@@ -57,7 +57,7 @@ LL |         let _y = &mut *foo_ref.f;\n help: consider changing this to be a mutable reference\n    |\n LL |         let foo_ref = &mut foo;\n-   |                       ~~~~~~~~\n+   |                        +++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "cf0c4127d82f43dfa8fbf2c5eeebb794fa930a30", "filename": "tests/ui/borrowck/borrowck-assign-to-andmut-in-aliasable-loc.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-assign-to-andmut-in-aliasable-loc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-assign-to-andmut-in-aliasable-loc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-assign-to-andmut-in-aliasable-loc.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -6,8 +6,8 @@ LL |     *s.pointer += 1;\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn a(s: &mut S<'_>) {\n-   |         ~~~~~~~~~~\n+LL | fn a(s: &mut S) {\n+   |          +++\n \n error[E0594]: cannot assign to `*s.pointer`, which is behind a `&` reference\n   --> $DIR/borrowck-assign-to-andmut-in-aliasable-loc.rs:17:5\n@@ -17,8 +17,8 @@ LL |     *s.pointer += 1;\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn c(s: &mut &mut S<'_>) {\n-   |         ~~~~~~~~~~~~~~~\n+LL | fn c(s: &mut  &mut S) {\n+   |          +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "59ef61b19d50136390e60ca965ca8bc1208e6ecb", "filename": "tests/ui/borrowck/borrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -27,8 +27,8 @@ LL |     let x:  &mut isize = &mut **t0;\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn foo4(t0: &mut &mut isize) {\n-   |             ~~~~~~~~~~~~~~~\n+LL | fn foo4(t0: &mut  &mut isize) {\n+   |              +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "12d67d536d951e1e64d282a7bd27c24080826b3a", "filename": "tests/ui/borrowck/borrowck-issue-14498.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-issue-14498.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-issue-14498.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-issue-14498.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     ***p = 2;\n help: consider changing this to be a mutable reference\n    |\n LL |     let p = &mut y;\n-   |             ~~~~~~\n+   |              +++\n \n error[E0506]: cannot assign to `**y` because it is borrowed\n   --> $DIR/borrowck-issue-14498.rs:25:5"}, {"sha": "fb3db4e144635eba623865f27caeb01c16aafd77", "filename": "tests/ui/borrowck/borrowck-reborrow-from-mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-reborrow-from-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fborrowck-reborrow-from-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-reborrow-from-mut.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -111,7 +111,7 @@ LL |     let _bar1 = &mut foo.bar1;\n help: consider changing this to be a mutable reference\n    |\n LL | fn borrow_mut_from_imm(foo: &mut Foo) {\n-   |                             ~~~~~~~~\n+   |                              +++\n \n error: aborting due to 11 previous errors\n "}, {"sha": "2985a658fddbef1504673c48d64ee97f9fb1d1ac", "filename": "tests/ui/borrowck/issue-85765.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fissue-85765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fissue-85765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-85765.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -18,7 +18,7 @@ LL |     *r = 0;\n help: consider changing this to be a mutable reference\n    |\n LL |     let r = &mut mutvar;\n-   |             ~~~~~~~~~~~\n+   |              +++\n \n error[E0594]: cannot assign to `*x`, which is behind a `&` reference\n   --> $DIR/issue-85765.rs:19:5"}, {"sha": "b39e57d70ec65d75b2804a134ef72007cd1b3c69", "filename": "tests/ui/borrowck/mutability-errors.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fmutability-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fborrowck%2Fmutability-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fmutability-errors.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     *x = (1,);\n help: consider changing this to be a mutable reference\n    |\n LL | fn named_ref(x: &mut (i32,)) {\n-   |                 ~~~~~~~~~~~\n+   |                  +++\n \n error[E0594]: cannot assign to `x.0`, which is behind a `&` reference\n   --> $DIR/mutability-errors.rs:10:5\n@@ -18,7 +18,7 @@ LL |     x.0 = 1;\n help: consider changing this to be a mutable reference\n    |\n LL | fn named_ref(x: &mut (i32,)) {\n-   |                 ~~~~~~~~~~~\n+   |                  +++\n \n error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/mutability-errors.rs:11:5\n@@ -29,7 +29,7 @@ LL |     &mut *x;\n help: consider changing this to be a mutable reference\n    |\n LL | fn named_ref(x: &mut (i32,)) {\n-   |                 ~~~~~~~~~~~\n+   |                  +++\n \n error[E0596]: cannot borrow `x.0` as mutable, as it is behind a `&` reference\n   --> $DIR/mutability-errors.rs:12:5\n@@ -40,7 +40,7 @@ LL |     &mut x.0;\n help: consider changing this to be a mutable reference\n    |\n LL | fn named_ref(x: &mut (i32,)) {\n-   |                 ~~~~~~~~~~~\n+   |                  +++\n \n error[E0594]: cannot assign to data in a `&` reference\n   --> $DIR/mutability-errors.rs:16:5\n@@ -74,8 +74,8 @@ LL |     *x = (1,);\n    |\n help: consider changing this to be a mutable pointer\n    |\n-LL | unsafe fn named_ptr(x: *mut (i32,)) {\n-   |                        ~~~~~~~~~~~\n+LL | unsafe fn named_ptr(x: *mut const (i32,)) {\n+   |                         +++\n \n error[E0594]: cannot assign to `x.0`, which is behind a `*const` pointer\n   --> $DIR/mutability-errors.rs:24:5\n@@ -85,8 +85,8 @@ LL |     (*x).0 = 1;\n    |\n help: consider changing this to be a mutable pointer\n    |\n-LL | unsafe fn named_ptr(x: *mut (i32,)) {\n-   |                        ~~~~~~~~~~~\n+LL | unsafe fn named_ptr(x: *mut const (i32,)) {\n+   |                         +++\n \n error[E0596]: cannot borrow `*x` as mutable, as it is behind a `*const` pointer\n   --> $DIR/mutability-errors.rs:25:5\n@@ -96,8 +96,8 @@ LL |     &mut *x;\n    |\n help: consider changing this to be a mutable pointer\n    |\n-LL | unsafe fn named_ptr(x: *mut (i32,)) {\n-   |                        ~~~~~~~~~~~\n+LL | unsafe fn named_ptr(x: *mut const (i32,)) {\n+   |                         +++\n \n error[E0596]: cannot borrow `x.0` as mutable, as it is behind a `*const` pointer\n   --> $DIR/mutability-errors.rs:26:5\n@@ -107,8 +107,8 @@ LL |     &mut (*x).0;\n    |\n help: consider changing this to be a mutable pointer\n    |\n-LL | unsafe fn named_ptr(x: *mut (i32,)) {\n-   |                        ~~~~~~~~~~~\n+LL | unsafe fn named_ptr(x: *mut const (i32,)) {\n+   |                         +++\n \n error[E0594]: cannot assign to data in a `*const` pointer\n   --> $DIR/mutability-errors.rs:30:5"}, {"sha": "1904faa959861962f2718ab016dea159a84c1afa", "filename": "tests/ui/closures/2229_closure_analysis/diagnostics/mut_ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -10,7 +10,7 @@ LL |         **ref_mref_x = y;\n help: consider changing this to be a mutable reference\n    |\n LL |     let ref_mref_x = &mut mref_x;\n-   |                      ~~~~~~~~~~~\n+   |                       +++\n \n error[E0596]: cannot borrow `**mref_ref_x` as mutable, as it is behind a `&` reference\n   --> $DIR/mut_ref.rs:26:13"}, {"sha": "43647fa562b9a38465a530f694036c0847c6f704", "filename": "tests/ui/did_you_mean/issue-38147-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -6,8 +6,8 @@ LL |     f.s.push('x');\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn f(x: usize, f: &mut Foo<'_>) {\n-   |                   ~~~~~~~~~~~~\n+LL | fn f(x: usize, f: &mut Foo) {\n+   |                    +++\n \n error: aborting due to previous error\n "}, {"sha": "8ccb4cbb0c1672d03b2228d7743e6a3413bdeab0", "filename": "tests/ui/did_you_mean/issue-39544.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-39544.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -40,7 +40,7 @@ LL |         let _ = &mut other.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo1(&self, other: &mut Z) {\n-   |                           ~~~~~~\n+   |                            +++\n \n error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:25:17\n@@ -62,7 +62,7 @@ LL |         let _ = &mut other.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo2<'a>(&'a self, other: &mut Z) {\n-   |                                  ~~~~~~\n+   |                                   +++\n \n error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:30:17\n@@ -73,7 +73,7 @@ LL |         let _ = &mut self.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo3<'a>(self: &'a mut Self, other: &Z) {\n-   |                       ~~~~~~~~~~~~\n+   |                           +++\n \n error[E0596]: cannot borrow `other.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:31:17\n@@ -84,7 +84,7 @@ LL |         let _ = &mut other.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo3<'a>(self: &'a Self, other: &mut Z) {\n-   |                                        ~~~~~~\n+   |                                         +++\n \n error[E0596]: cannot borrow `other.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:35:17\n@@ -95,7 +95,7 @@ LL |         let _ = &mut other.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo4(other: &mut Z) {\n-   |                    ~~~~~~\n+   |                     +++\n \n error[E0596]: cannot borrow `z.x` as mutable, as `z` is not declared as mutable\n   --> $DIR/issue-39544.rs:41:13\n@@ -117,7 +117,7 @@ LL |     let _ = &mut w.x;\n help: consider changing this to be a mutable reference\n    |\n LL | pub fn with_arg(z: Z, w: &mut Z) {\n-   |                          ~~~~~~\n+   |                           +++\n \n error[E0594]: cannot assign to `*x.0`, which is behind a `&` reference\n   --> $DIR/issue-39544.rs:48:5"}, {"sha": "ba94a570256390de93bf9b31586be094efd9e353", "filename": "tests/ui/did_you_mean/issue-40823.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fdid_you_mean%2Fissue-40823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fdid_you_mean%2Fissue-40823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-40823.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     buf.iter_mut();\n help: consider changing this to be a mutable reference\n    |\n LL |     let mut buf = &mut [1, 2, 3, 4];\n-   |                   ~~~~~~~~~~~~~~~~~\n+   |                    +++\n \n error: aborting due to previous error\n "}, {"sha": "e4001856c388b151a6315ea7f0a985dbefb6d759", "filename": "tests/ui/error-codes/E0389.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Ferror-codes%2FE0389.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Ferror-codes%2FE0389.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0389.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     fancy_ref.num = 6;\n help: consider changing this to be a mutable reference\n    |\n LL |     let fancy_ref = &mut (&mut fancy);\n-   |                     ~~~~~~~~~~~~~~~~~\n+   |                      +++\n \n error: aborting due to previous error\n "}, {"sha": "33a9bf85e23ea080b6476ba3cb9269623732170c", "filename": "tests/ui/issues/issue-51515.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fissues%2Fissue-51515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fissues%2Fissue-51515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-51515.rs?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -1,7 +1,6 @@\n fn main() {\n     let foo = &16;\n     //~^ HELP consider changing this to be a mutable reference\n-    //~| SUGGESTION &mut 16\n     *foo = 32;\n     //~^ ERROR cannot assign to `*foo`, which is behind a `&` reference\n     let bar = foo;"}, {"sha": "88b8d2109088696971e18eb4925a35f4d957281b", "filename": "tests/ui/issues/issue-51515.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fissues%2Fissue-51515.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fissues%2Fissue-51515.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-51515.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -1,16 +1,16 @@\n error[E0594]: cannot assign to `*foo`, which is behind a `&` reference\n-  --> $DIR/issue-51515.rs:5:5\n+  --> $DIR/issue-51515.rs:4:5\n    |\n LL |     *foo = 32;\n    |     ^^^^^^^^^ `foo` is a `&` reference, so the data it refers to cannot be written\n    |\n help: consider changing this to be a mutable reference\n    |\n LL |     let foo = &mut 16;\n-   |               ~~~~~~~\n+   |                +++\n \n error[E0594]: cannot assign to `*bar`, which is behind a `&` reference\n-  --> $DIR/issue-51515.rs:9:5\n+  --> $DIR/issue-51515.rs:8:5\n    |\n LL |     *bar = 64;\n    |     ^^^^^^^^^ `bar` is a `&` reference, so the data it refers to cannot be written"}, {"sha": "bedea3890a32e73b07843aae5964b4b5e3bbbfa0", "filename": "tests/ui/issues/issue-61623.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fissues%2Fissue-61623.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fissues%2Fissue-61623.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-61623.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     f2(|| x.0, f1(x.1))\n help: consider changing this to be a mutable reference\n    |\n LL | fn f3<'a>(x: &'a mut ((), &'a mut ())) {\n-   |              ~~~~~~~~~~~~~~~~~~~~~~~~\n+   |                  +++\n \n error: aborting due to previous error\n "}, {"sha": "09b9d638afb033a1e415bda16095cbe255a3c942", "filename": "tests/ui/nll/issue-47388.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fnll%2Fissue-47388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fnll%2Fissue-47388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-47388.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     fancy_ref.num = 6;\n help: consider changing this to be a mutable reference\n    |\n LL |     let fancy_ref = &mut (&mut fancy);\n-   |                     ~~~~~~~~~~~~~~~~~\n+   |                      +++\n \n error: aborting due to previous error\n "}, {"sha": "8ccb5809e39729143a6be3d6cad8826a673aa428", "filename": "tests/ui/nll/issue-51244.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fnll%2Fissue-51244.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fnll%2Fissue-51244.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-51244.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     *my_ref = 0;\n help: consider changing this to be a mutable reference\n    |\n LL |     let ref mut my_ref @ _ = 0;\n-   |         ~~~~~~~~~~~~~~\n+   |             +++\n \n error: aborting due to previous error\n "}, {"sha": "6062b31d6883cc76715432fa06666001b65915d3", "filename": "tests/ui/nll/issue-57989.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fnll%2Fissue-57989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fnll%2Fissue-57989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-57989.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     *x = 0;\n help: consider changing this to be a mutable reference\n    |\n LL | fn f(x: &mut i32) {\n-   |         ~~~~~~~~\n+   |          +++\n \n error[E0506]: cannot assign to `*x` because it is borrowed\n   --> $DIR/issue-57989.rs:5:5"}, {"sha": "a033cc0655ef9015e027d1eb8445dc338ab2c472", "filename": "tests/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -112,7 +112,7 @@ LL |     *_x0 = U;\n help: consider changing this to be a mutable reference\n    |\n LL |     let (ref mut _x0, _x1, ref _x2, ..) = tup;\n-   |          ~~~~~~~~~~~\n+   |              +++\n \n error[E0594]: cannot assign to `*_x2`, which is behind a `&` reference\n   --> $DIR/borrowck-move-ref-pattern.rs:27:5\n@@ -123,7 +123,7 @@ LL |     *_x2 = U;\n help: consider changing this to be a mutable reference\n    |\n LL |     let (ref _x0, _x1, ref mut _x2, ..) = tup;\n-   |                        ~~~~~~~~~~~\n+   |                            +++\n \n error[E0382]: use of moved value: `tup.1`\n   --> $DIR/borrowck-move-ref-pattern.rs:28:10"}, {"sha": "80c5f9da40cea17b391292a9c856f5f1fb27c71a", "filename": "tests/ui/span/borrowck-borrow-overloaded-auto-deref-mut.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -18,7 +18,7 @@ LL |     &mut x.y\n help: consider changing this to be a mutable reference\n    |\n LL | fn deref_extend_mut_field1(x: &mut Own<Point>) -> &mut isize {\n-   |                               ~~~~~~~~~~~~~~~\n+   |                                +++\n \n error[E0499]: cannot borrow `*x` as mutable more than once at a time\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:78:19\n@@ -50,7 +50,7 @@ LL |     x.y = 3;\n help: consider changing this to be a mutable reference\n    |\n LL | fn assign_field2<'a>(x: &'a mut Own<Point>) {\n-   |                         ~~~~~~~~~~~~~~~~~~\n+   |                             +++\n \n error[E0499]: cannot borrow `*x` as mutable more than once at a time\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:101:5\n@@ -82,7 +82,7 @@ LL |     x.y_mut()\n help: consider changing this to be a mutable reference\n    |\n LL | fn deref_extend_mut_method1(x: &mut Own<Point>) -> &mut isize {\n-   |                                ~~~~~~~~~~~~~~~\n+   |                                 +++\n \n error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:129:6\n@@ -104,7 +104,7 @@ LL |     *x.y_mut() = 3;\n help: consider changing this to be a mutable reference\n    |\n LL | fn assign_method2<'a>(x: &'a mut Own<Point>) {\n-   |                          ~~~~~~~~~~~~~~~~~~\n+   |                              +++\n \n error: aborting due to 10 previous errors\n "}, {"sha": "dbd52dc2d38df44b1f26403e0b80798d204be3b7", "filename": "tests/ui/span/borrowck-borrow-overloaded-deref-mut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -18,7 +18,7 @@ LL |     &mut **x\n help: consider changing this to be a mutable reference\n    |\n LL | fn deref_extend_mut1<'a>(x: &'a mut Own<isize>) -> &'a mut isize {\n-   |                             ~~~~~~~~~~~~~~~~~~\n+   |                                 +++\n \n error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:49:6\n@@ -40,7 +40,7 @@ LL |     **x = 3;\n help: consider changing this to be a mutable reference\n    |\n LL | fn assign2<'a>(x: &'a mut Own<isize>) {\n-   |                   ~~~~~~~~~~~~~~~~~~\n+   |                       +++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "99c8fa1f932d20665033e2160f1c84a9e5b4d6d5", "filename": "tests/ui/span/borrowck-call-is-borrow-issue-12224.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -19,7 +19,7 @@ LL |     (*f)();\n help: consider changing this to be a mutable reference\n    |\n LL | fn test2<F>(f: &mut F) where F: FnMut() {\n-   |                ~~~~~~\n+   |                 +++\n \n error[E0596]: cannot borrow `f.f` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:34:5\n@@ -29,8 +29,8 @@ LL |     f.f.call_mut(())\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn test4(f: &mut Test<'_>) {\n-   |             ~~~~~~~~~~~~~\n+LL | fn test4(f: &mut Test) {\n+   |              +++\n \n error[E0507]: cannot move out of `f`, a captured variable in an `FnMut` closure\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:57:13"}, {"sha": "328197ae9f42945080a8554a33beb0b81affb698", "filename": "tests/ui/span/borrowck-call-method-from-mut-aliasable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     x.h();\n help: consider changing this to be a mutable reference\n    |\n LL | fn b(x: &mut Foo) {\n-   |         ~~~~~~~~\n+   |          +++\n \n error: aborting due to previous error\n "}, {"sha": "17fdcc622f776375073da0d5843f48bdf8b52867", "filename": "tests/ui/span/borrowck-fn-in-const-b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |         x.push(format!(\"this is broken\"));\n help: consider changing this to be a mutable reference\n    |\n LL |     fn broken(x: &mut Vec<String>) {\n-   |                  ~~~~~~~~~~~~~~~~\n+   |                   +++\n \n error: aborting due to previous error\n "}, {"sha": "805a8034c184a340613b16e14908e0fd52b9f4f9", "filename": "tests/ui/span/borrowck-object-mutability.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-object-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fborrowck-object-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-object-mutability.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     x.borrowed_mut();\n help: consider changing this to be a mutable reference\n    |\n LL | fn borrowed_receiver(x: &mut dyn Foo) {\n-   |                         ~~~~~~~~~~~~\n+   |                          +++\n \n error[E0596]: cannot borrow `*x` as mutable, as `x` is not declared as mutable\n   --> $DIR/borrowck-object-mutability.rs:18:5"}, {"sha": "06011eac674c1249907a56de0553330e576873bd", "filename": "tests/ui/span/mut-arg-hint.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fmut-arg-hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fspan%2Fmut-arg-hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fmut-arg-hint.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |         a.push_str(\"bar\");\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo(mut a: &mut String) {\n-   |                   ~~~~~~~~~~~\n+   |                    +++\n \n error[E0596]: cannot borrow `*a` as mutable, as it is behind a `&` reference\n   --> $DIR/mut-arg-hint.rs:8:5\n@@ -18,7 +18,7 @@ LL |     a.push_str(\"foo\");\n help: consider changing this to be a mutable reference\n    |\n LL | pub fn foo<'a>(mut a: &'a mut String) {\n-   |                       ~~~~~~~~~~~~~~\n+   |                           +++\n \n error[E0596]: cannot borrow `*a` as mutable, as it is behind a `&` reference\n   --> $DIR/mut-arg-hint.rs:15:9\n@@ -29,7 +29,7 @@ LL |         a.push_str(\"foo\");\n help: consider changing this to be a mutable reference\n    |\n LL |     pub fn foo(mut a: &mut String) {\n-   |                       ~~~~~~~~~~~\n+   |                        +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "6f3c78443f8293d097885a0f1267904afcb1f326", "filename": "tests/ui/suggestions/issue-68049-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -4,18 +4,18 @@ error[E0594]: cannot assign to `*input`, which is behind a `&` reference\n LL |       *input = self.0;\n    |       ^^^^^^^^^^^^^^^ `input` is a `&` reference, so the data it refers to cannot be written\n    |\n-help: consider changing that to be a mutable reference\n+help: consider changing this to be a mutable reference\n    |\n-LL |   fn example(&self, input: &mut i32); // should suggest here\n-   |                            ~~~~~~~~\n+LL |   fn example(&self, input: &mut i32) { // should not suggest here\n+   |                             +++\n \n error[E0594]: cannot assign to `self.0`, which is behind a `&` reference\n   --> $DIR/issue-68049-2.rs:17:5\n    |\n LL |     self.0 += *input;\n    |     ^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be written\n    |\n-help: consider changing that to be a mutable reference\n+help: consider changing this to be a mutable reference\n    |\n LL |   fn example(&mut self, input: &i32); // should suggest here\n    |              ~~~~~~~~~"}, {"sha": "b40439b8e372c65255e397b3a636d1e0f2ba4d08", "filename": "tests/ui/suggestions/suggest-ref-mut.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.rs?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -12,19 +12,16 @@ impl X {\n fn main() {\n     let ref foo = 16;\n     //~^ HELP\n-    //~| SUGGESTION ref mut foo\n     *foo = 32;\n     //~^ ERROR\n     if let Some(ref bar) = Some(16) {\n         //~^ HELP\n-        //~| SUGGESTION ref mut bar\n         *bar = 32;\n         //~^ ERROR\n     }\n     match 16 {\n         ref quo => { *quo = 32; },\n         //~^ ERROR\n         //~| HELP\n-        //~| SUGGESTION ref mut quo\n     }\n }"}, {"sha": "cc00022ab8e3d552bdca107b232e4b21c0c71076", "filename": "tests/ui/suggestions/suggest-ref-mut.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -10,37 +10,37 @@ LL |     fn zap(&mut self) {\n    |            ~~~~~~~~~\n \n error[E0594]: cannot assign to `*foo`, which is behind a `&` reference\n-  --> $DIR/suggest-ref-mut.rs:16:5\n+  --> $DIR/suggest-ref-mut.rs:15:5\n    |\n LL |     *foo = 32;\n    |     ^^^^^^^^^ `foo` is a `&` reference, so the data it refers to cannot be written\n    |\n help: consider changing this to be a mutable reference\n    |\n LL |     let ref mut foo = 16;\n-   |         ~~~~~~~~~~~\n+   |             +++\n \n error[E0594]: cannot assign to `*bar`, which is behind a `&` reference\n-  --> $DIR/suggest-ref-mut.rs:21:9\n+  --> $DIR/suggest-ref-mut.rs:19:9\n    |\n LL |         *bar = 32;\n    |         ^^^^^^^^^ `bar` is a `&` reference, so the data it refers to cannot be written\n    |\n help: consider changing this to be a mutable reference\n    |\n LL |     if let Some(ref mut bar) = Some(16) {\n-   |                 ~~~~~~~~~~~\n+   |                     +++\n \n error[E0594]: cannot assign to `*quo`, which is behind a `&` reference\n-  --> $DIR/suggest-ref-mut.rs:25:22\n+  --> $DIR/suggest-ref-mut.rs:23:22\n    |\n LL |         ref quo => { *quo = 32; },\n    |                      ^^^^^^^^^ `quo` is a `&` reference, so the data it refers to cannot be written\n    |\n help: consider changing this to be a mutable reference\n    |\n LL |         ref mut quo => { *quo = 32; },\n-   |         ~~~~~~~~~~~\n+   |             +++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c054ddb893d5c3e978d8361157e43c8f31df140e", "filename": "tests/ui/trivial-bounds/trivial-bounds-inconsistent-copy-reborrow.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy-reborrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243/tests%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy-reborrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy-reborrow.stderr?ref=ff30b8cb7bcf3eaee7a5222c8ec35adba4a0d243", "patch": "@@ -7,7 +7,7 @@ LL |     *t\n help: consider changing this to be a mutable reference\n    |\n LL | fn reborrow_mut<'a>(t: &'a mut &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n-   |                        ~~~~~~~~~~~~~~~~~~~\n+   |                            +++\n \n error[E0596]: cannot borrow `**t` as mutable, as it is behind a `&` reference\n   --> $DIR/trivial-bounds-inconsistent-copy-reborrow.rs:10:6\n@@ -18,7 +18,7 @@ LL |     {*t}\n help: consider changing this to be a mutable reference\n    |\n LL | fn copy_reborrow_mut<'a>(t: &'a mut &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n-   |                             ~~~~~~~~~~~~~~~~~~~\n+   |                                 +++\n \n error: aborting due to 2 previous errors\n "}]}