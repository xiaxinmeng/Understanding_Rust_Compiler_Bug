{"sha": "4891f02cff9a282df96b368b2f3f8151a78e9676", "node_id": "C_kwDOAAsO6NoAKDQ4OTFmMDJjZmY5YTI4MmRmOTZiMzY4YjJmM2Y4MTUxYTc4ZTk2NzY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-05-05T13:10:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-05T13:10:33Z"}, "message": "Rollup merge of #108801 - fee1-dead-contrib:c-str, r=compiler-errors\n\nImplement RFC 3348, `c\"foo\"` literals\n\nRFC: https://github.com/rust-lang/rfcs/pull/3348\nTracking issue: #105723", "tree": {"sha": "c9716f2b0c42263e0d44273ad5acd5bd5a338701", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9716f2b0c42263e0d44273ad5acd5bd5a338701"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4891f02cff9a282df96b368b2f3f8151a78e9676", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkVQBJCRBK7hj4Ov3rIwAA4QIIAAmBBbvaDEPVn81xhmhK3nQv\niTl9cQnnUbaD/WmuWthJipHHX8OILnIg1VRz9OeAq12/me4/dxTm+KlfYHC6vPka\nojX6DvnbaQdJrUhpDYG8cCYBsQlF6oVvJ7MdgjeA/lmjo42T3wc1BIwvFBf85M1/\nw+OktYTzvAuCDd1LlzvhM/Drm+QVMaqp5gvPGw36GqNaKgpJDXDVMC1LJe1HMDtG\nHDONgYte9wyXUiuPWmVEyESMnVptpz7USLqzsdT3aKCHY+aM/3LFP/JXwGsOuWSb\nnlloaM2B6EW0hGRBrBxgspUPl0J7go+PwGqL7cA60x8eSXVNmaEaRwXZuG5Yumo=\n=iaVF\n-----END PGP SIGNATURE-----\n", "payload": "tree c9716f2b0c42263e0d44273ad5acd5bd5a338701\nparent 3502e483213ad42468700b409ab4a4ecdd8ddf2c\nparent d30c6681751b10a14265e09e5f74f39d2a32e641\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1683292233 +0530\ncommitter GitHub <noreply@github.com> 1683292233 +0530\n\nRollup merge of #108801 - fee1-dead-contrib:c-str, r=compiler-errors\n\nImplement RFC 3348, `c\"foo\"` literals\n\nRFC: https://github.com/rust-lang/rfcs/pull/3348\nTracking issue: #105723\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4891f02cff9a282df96b368b2f3f8151a78e9676", "html_url": "https://github.com/rust-lang/rust/commit/4891f02cff9a282df96b368b2f3f8151a78e9676", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4891f02cff9a282df96b368b2f3f8151a78e9676/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3502e483213ad42468700b409ab4a4ecdd8ddf2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3502e483213ad42468700b409ab4a4ecdd8ddf2c", "html_url": "https://github.com/rust-lang/rust/commit/3502e483213ad42468700b409ab4a4ecdd8ddf2c"}, {"sha": "d30c6681751b10a14265e09e5f74f39d2a32e641", "url": "https://api.github.com/repos/rust-lang/rust/commits/d30c6681751b10a14265e09e5f74f39d2a32e641", "html_url": "https://github.com/rust-lang/rust/commit/d30c6681751b10a14265e09e5f74f39d2a32e641"}], "stats": {"total": 653, "additions": 500, "deletions": 153}, "files": [{"sha": "e3ac8a8784a7cd7e8b840f3a66bafb92ba9235ee", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -1821,6 +1821,8 @@ pub enum LitKind {\n     /// A byte string (`b\"foo\"`). Not stored as a symbol because it might be\n     /// non-utf8, and symbols only allow utf8 strings.\n     ByteStr(Lrc<[u8]>, StrStyle),\n+    /// A C String (`c\"foo\"`). Guaranteed to only have `\\0` at the end.\n+    CStr(Lrc<[u8]>, StrStyle),\n     /// A byte char (`b'f'`).\n     Byte(u8),\n     /// A character literal (`'a'`).\n@@ -1875,6 +1877,7 @@ impl LitKind {\n             // unsuffixed variants\n             LitKind::Str(..)\n             | LitKind::ByteStr(..)\n+            | LitKind::CStr(..)\n             | LitKind::Byte(..)\n             | LitKind::Char(..)\n             | LitKind::Int(_, LitIntType::Unsuffixed)"}, {"sha": "42b843482a32b386ff9bf374fd342360cebff71d", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -74,6 +74,8 @@ pub enum LitKind {\n     StrRaw(u8), // raw string delimited by `n` hash symbols\n     ByteStr,\n     ByteStrRaw(u8), // raw byte string delimited by `n` hash symbols\n+    CStr,\n+    CStrRaw(u8),\n     Err,\n }\n \n@@ -141,6 +143,10 @@ impl fmt::Display for Lit {\n                 delim = \"#\".repeat(n as usize),\n                 string = symbol\n             )?,\n+            CStr => write!(f, \"c\\\"{symbol}\\\"\")?,\n+            CStrRaw(n) => {\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize))?\n+            }\n             Integer | Float | Bool | Err => write!(f, \"{symbol}\")?,\n         }\n \n@@ -170,6 +176,7 @@ impl LitKind {\n             Float => \"float\",\n             Str | StrRaw(..) => \"string\",\n             ByteStr | ByteStrRaw(..) => \"byte string\",\n+            CStr | CStrRaw(..) => \"C string\",\n             Err => \"error\",\n         }\n     }"}, {"sha": "15a54fe13d0b78153b915778e412b270099ee9fa", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -2,9 +2,13 @@\n \n use crate::ast::{self, LitKind, MetaItemLit, StrStyle};\n use crate::token::{self, Token};\n-use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n+use rustc_lexer::unescape::{\n+    byte_from_char, unescape_byte, unescape_c_string, unescape_char, unescape_literal, CStrUnit,\n+    Mode,\n+};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n+use std::ops::Range;\n use std::{ascii, fmt, str};\n \n // Escapes a string, represented as a symbol. Reuses the original symbol,\n@@ -35,6 +39,7 @@ pub enum LitError {\n     InvalidFloatSuffix,\n     NonDecimalFloat(u32),\n     IntTooLarge(u32),\n+    NulInCStr(Range<usize>),\n }\n \n impl LitKind {\n@@ -158,6 +163,52 @@ impl LitKind {\n \n                 LitKind::ByteStr(bytes.into(), StrStyle::Raw(n))\n             }\n+            token::CStr => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::CStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(0);\n+                LitKind::CStr(buf.into(), StrStyle::Cooked)\n+            }\n+            token::CStrRaw(n) => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::RawCStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(0);\n+                LitKind::CStr(buf.into(), StrStyle::Raw(n))\n+            }\n             token::Err => LitKind::Err,\n         })\n     }\n@@ -191,6 +242,14 @@ impl fmt::Display for LitKind {\n                     string = symbol\n                 )?;\n             }\n+            LitKind::CStr(ref bytes, StrStyle::Cooked) => {\n+                write!(f, \"c\\\"{}\\\"\", escape_byte_str_symbol(bytes))?\n+            }\n+            LitKind::CStr(ref bytes, StrStyle::Raw(n)) => {\n+                // This can only be valid UTF-8.\n+                let symbol = str::from_utf8(bytes).unwrap();\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize),)?;\n+            }\n             LitKind::Int(n, ty) => {\n                 write!(f, \"{n}\")?;\n                 match ty {\n@@ -237,6 +296,8 @@ impl MetaItemLit {\n             LitKind::Str(_, ast::StrStyle::Raw(n)) => token::StrRaw(n),\n             LitKind::ByteStr(_, ast::StrStyle::Cooked) => token::ByteStr,\n             LitKind::ByteStr(_, ast::StrStyle::Raw(n)) => token::ByteStrRaw(n),\n+            LitKind::CStr(_, ast::StrStyle::Cooked) => token::CStr,\n+            LitKind::CStr(_, ast::StrStyle::Raw(n)) => token::CStrRaw(n),\n             LitKind::Byte(_) => token::Byte,\n             LitKind::Char(_) => token::Char,\n             LitKind::Int(..) => token::Integer,"}, {"sha": "b960671bf6e158aa21bab70859d8d32128b288d5", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -572,6 +572,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n             }\n         };\n     }\n+    gate_all!(c_str_literals, \"`c\\\"..\\\"` literals are experimental\");\n     gate_all!(\n         if_let_guard,\n         \"`if let` guards are experimental\","}, {"sha": "3f80728a2606b64280820c1ba80b2dfe45b06a57", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -210,6 +210,10 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n         token::ByteStrRaw(n) => {\n             format!(\"br{delim}\\\"{string}\\\"{delim}\", delim = \"#\".repeat(n as usize), string = symbol)\n         }\n+        token::CStr => format!(\"c\\\"{symbol}\\\"\"),\n+        token::CStrRaw(n) => {\n+            format!(\"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize))\n+        }\n         token::Integer | token::Float | token::Bool | token::Err => symbol.to_string(),\n     };\n "}, {"sha": "50e88ae2eeeded88a87001354979231f75cc6792", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -32,6 +32,10 @@ pub fn expand_concat(\n                 Ok(ast::LitKind::Bool(b)) => {\n                     accumulator.push_str(&b.to_string());\n                 }\n+                Ok(ast::LitKind::CStr(..)) => {\n+                    cx.span_err(e.span, \"cannot concatenate a C string literal\");\n+                    has_errors = true;\n+                }\n                 Ok(ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..)) => {\n                     cx.emit_err(errors::ConcatBytestr { span: e.span });\n                     has_errors = true;"}, {"sha": "5ef35af0a059ad4cd12a7b6e71cde3dcc2bfea6f", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -18,6 +18,11 @@ fn invalid_type_err(\n     };\n     let snippet = cx.sess.source_map().span_to_snippet(span).ok();\n     match ast::LitKind::from_token_lit(token_lit) {\n+        Ok(ast::LitKind::CStr(_, _)) => {\n+            // FIXME(c_str_literals): should concatenation of C string literals\n+            // include the null bytes in the end?\n+            cx.span_err(span, \"cannot concatenate C string literals\");\n+        }\n         Ok(ast::LitKind::Char(_)) => {\n             let sugg =\n                 snippet.map(|snippet| ConcatBytesInvalidSuggestion::CharLit { span, snippet });"}, {"sha": "891e84a2f3071d8cdbf26f2425f18f19d069b5b3", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -61,6 +61,8 @@ impl FromInternal<token::LitKind> for LitKind {\n             token::StrRaw(n) => LitKind::StrRaw(n),\n             token::ByteStr => LitKind::ByteStr,\n             token::ByteStrRaw(n) => LitKind::ByteStrRaw(n),\n+            token::CStr => LitKind::CStr,\n+            token::CStrRaw(n) => LitKind::CStrRaw(n),\n             token::Err => LitKind::Err,\n             token::Bool => unreachable!(),\n         }\n@@ -78,6 +80,8 @@ impl ToInternal<token::LitKind> for LitKind {\n             LitKind::StrRaw(n) => token::StrRaw(n),\n             LitKind::ByteStr => token::ByteStr,\n             LitKind::ByteStrRaw(n) => token::ByteStrRaw(n),\n+            LitKind::CStr => token::CStr,\n+            LitKind::CStrRaw(n) => token::CStrRaw(n),\n             LitKind::Err => token::Err,\n         }\n     }\n@@ -436,6 +440,8 @@ impl server::FreeFunctions for Rustc<'_, '_> {\n                 | token::LitKind::StrRaw(_)\n                 | token::LitKind::ByteStr\n                 | token::LitKind::ByteStrRaw(_)\n+                | token::LitKind::CStr\n+                | token::LitKind::CStrRaw(_)\n                 | token::LitKind::Err => return Err(()),\n                 token::LitKind::Integer | token::LitKind::Float => {}\n             }"}, {"sha": "7e7df0e9584383edbf821c683290d4c8f366f292", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -313,6 +313,8 @@ declare_features! (\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n     /// Allows async functions to be declared, implemented, and used in traits.\n     (active, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n+    /// Allows `c\"foo\"` literals.\n+    (active, c_str_literals, \"CURRENT_RUSTC_VERSION\", Some(105723), None),\n     /// Treat `extern \"C\"` function as nounwind.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n     /// Allows using C-variadics."}, {"sha": "1f08befb180c9e0a7246f517aff913f856d47af9", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -333,6 +333,7 @@ language_item_table! {\n     RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n \n     String,                  sym::String,              string,                     Target::Struct,         GenericRequirement::None;\n+    CStr,                    sym::CStr,                c_str,                      Target::Struct,         GenericRequirement::None;\n }\n \n pub enum GenericRequirement {"}, {"sha": "4b8fc7303a20c0bb0adaa42303f4e4fbdd8f74fb", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -1300,6 +1300,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n+            ast::LitKind::CStr(_, _) => tcx.mk_imm_ref(\n+                tcx.lifetimes.re_static,\n+                tcx.type_of(tcx.require_lang_item(hir::LangItem::CStr, Some(lit.span)))\n+                    .skip_binder(),\n+            ),\n             ast::LitKind::Err => tcx.ty_error_misc(),\n         }\n     }"}, {"sha": "c07dc19a0ac3ac2916caa6ff8d55ba81667bd294", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -186,12 +186,16 @@ pub enum LiteralKind {\n     Str { terminated: bool },\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n+    /// `c\"abc\"`, `c\"abc`\n+    CStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\". `None` indicates\n     /// an invalid literal.\n     RawStr { n_hashes: Option<u8> },\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\". `None`\n     /// indicates an invalid literal.\n     RawByteStr { n_hashes: Option<u8> },\n+    /// `cr\"abc\"`, \"cr#\"abc\"#\", `cr#\"a`. `None` indicates an invalid literal.\n+    RawCStr { n_hashes: Option<u8> },\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n@@ -357,39 +361,18 @@ impl Cursor<'_> {\n             },\n \n             // Byte literal, byte string literal, raw byte string literal or identifier.\n-            'b' => match (self.first(), self.second()) {\n-                ('\\'', _) => {\n-                    self.bump();\n-                    let terminated = self.single_quoted_string();\n-                    let suffix_start = self.pos_within_token();\n-                    if terminated {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = Byte { terminated };\n-                    Literal { kind, suffix_start }\n-                }\n-                ('\"', _) => {\n-                    self.bump();\n-                    let terminated = self.double_quoted_string();\n-                    let suffix_start = self.pos_within_token();\n-                    if terminated {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = ByteStr { terminated };\n-                    Literal { kind, suffix_start }\n-                }\n-                ('r', '\"') | ('r', '#') => {\n-                    self.bump();\n-                    let res = self.raw_double_quoted_string(2);\n-                    let suffix_start = self.pos_within_token();\n-                    if res.is_ok() {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = RawByteStr { n_hashes: res.ok() };\n-                    Literal { kind, suffix_start }\n-                }\n-                _ => self.ident_or_unknown_prefix(),\n-            },\n+            'b' => self.c_or_byte_string(\n+                |terminated| ByteStr { terminated },\n+                |n_hashes| RawByteStr { n_hashes },\n+                Some(|terminated| Byte { terminated }),\n+            ),\n+\n+            // c-string literal, raw c-string literal or identifier.\n+            'c' => self.c_or_byte_string(\n+                |terminated| CStr { terminated },\n+                |n_hashes| RawCStr { n_hashes },\n+                None,\n+            ),\n \n             // Identifier (this should be checked after other variant that can\n             // start as identifier).\n@@ -553,6 +536,47 @@ impl Cursor<'_> {\n         }\n     }\n \n+    fn c_or_byte_string(\n+        &mut self,\n+        mk_kind: impl FnOnce(bool) -> LiteralKind,\n+        mk_kind_raw: impl FnOnce(Option<u8>) -> LiteralKind,\n+        single_quoted: Option<fn(bool) -> LiteralKind>,\n+    ) -> TokenKind {\n+        match (self.first(), self.second(), single_quoted) {\n+            ('\\'', _, Some(mk_kind)) => {\n+                self.bump();\n+                let terminated = self.single_quoted_string();\n+                let suffix_start = self.pos_within_token();\n+                if terminated {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind(terminated);\n+                Literal { kind, suffix_start }\n+            }\n+            ('\"', _, _) => {\n+                self.bump();\n+                let terminated = self.double_quoted_string();\n+                let suffix_start = self.pos_within_token();\n+                if terminated {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind(terminated);\n+                Literal { kind, suffix_start }\n+            }\n+            ('r', '\"', _) | ('r', '#', _) => {\n+                self.bump();\n+                let res = self.raw_double_quoted_string(2);\n+                let suffix_start = self.pos_within_token();\n+                if res.is_ok() {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind_raw(res.ok());\n+                Literal { kind, suffix_start }\n+            }\n+            _ => self.ident_or_unknown_prefix(),\n+        }\n+    }\n+\n     fn number(&mut self, first_digit: char) -> LiteralKind {\n         debug_assert!('0' <= self.prev() && self.prev() <= '9');\n         let mut base = Base::Decimal;"}, {"sha": "c9ad54d8d980609d15416e4bdcda83df88b3b3c5", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 176, "deletions": 102, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -86,10 +86,45 @@ where\n             let res = unescape_char_or_byte(&mut chars, mode == Mode::Byte);\n             callback(0..(src.len() - chars.as_str().len()), res);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode == Mode::ByteStr, callback),\n+        Mode::Str | Mode::ByteStr => unescape_str_common(src, mode, callback),\n+\n         Mode::RawStr | Mode::RawByteStr => {\n             unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n         }\n+        Mode::CStr | Mode::RawCStr => unreachable!(),\n+    }\n+}\n+\n+/// A unit within CStr. Must not be a nul character.\n+pub enum CStrUnit {\n+    Byte(u8),\n+    Char(char),\n+}\n+\n+impl From<u8> for CStrUnit {\n+    fn from(value: u8) -> Self {\n+        CStrUnit::Byte(value)\n+    }\n+}\n+\n+impl From<char> for CStrUnit {\n+    fn from(value: char) -> Self {\n+        CStrUnit::Char(value)\n+    }\n+}\n+\n+pub fn unescape_c_string<F>(src: &str, mode: Mode, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<CStrUnit, EscapeError>),\n+{\n+    if mode == Mode::RawCStr {\n+        unescape_raw_str_or_raw_byte_str(\n+            src,\n+            mode.characters_should_be_ascii(),\n+            &mut |r, result| callback(r, result.map(CStrUnit::Char)),\n+        );\n+    } else {\n+        unescape_str_common(src, mode, callback);\n     }\n }\n \n@@ -114,34 +149,69 @@ pub enum Mode {\n     ByteStr,\n     RawStr,\n     RawByteStr,\n+    CStr,\n+    RawCStr,\n }\n \n impl Mode {\n     pub fn in_double_quotes(self) -> bool {\n         match self {\n-            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => true,\n+            Mode::Str\n+            | Mode::ByteStr\n+            | Mode::RawStr\n+            | Mode::RawByteStr\n+            | Mode::CStr\n+            | Mode::RawCStr => true,\n             Mode::Char | Mode::Byte => false,\n         }\n     }\n \n-    pub fn is_byte(self) -> bool {\n+    /// Non-byte literals should have `\\xXX` escapes that are within the ASCII range.\n+    pub fn ascii_escapes_should_be_ascii(self) -> bool {\n+        match self {\n+            Mode::Char | Mode::Str | Mode::RawStr => true,\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    /// Whether characters within the literal must be within the ASCII range\n+    pub fn characters_should_be_ascii(self) -> bool {\n+        match self {\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Str | Mode::RawStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    /// Byte literals do not allow unicode escape.\n+    pub fn is_unicode_escape_disallowed(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n-            Mode::Char | Mode::Str | Mode::RawStr => false,\n+            Mode::Char | Mode::Str | Mode::RawStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    pub fn prefix_noraw(self) -> &'static str {\n+        match self {\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => \"b\",\n+            Mode::CStr | Mode::RawCStr => \"c\",\n+            Mode::Char | Mode::Str | Mode::RawStr => \"\",\n         }\n     }\n }\n \n-fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+fn scan_escape<T: From<u8> + From<char>>(\n+    chars: &mut Chars<'_>,\n+    mode: Mode,\n+) -> Result<T, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n     let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n-        '\"' => '\"',\n-        'n' => '\\n',\n-        'r' => '\\r',\n-        't' => '\\t',\n-        '\\\\' => '\\\\',\n-        '\\'' => '\\'',\n-        '0' => '\\0',\n+        '\"' => b'\"',\n+        'n' => b'\\n',\n+        'r' => b'\\r',\n+        't' => b'\\t',\n+        '\\\\' => b'\\\\',\n+        '\\'' => b'\\'',\n+        '0' => b'\\0',\n \n         'x' => {\n             // Parse hexadecimal character code.\n@@ -154,76 +224,78 @@ fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError\n \n             let value = hi * 16 + lo;\n \n-            // For a non-byte literal verify that it is within ASCII range.\n-            if !is_byte && !is_ascii(value) {\n+            if mode.ascii_escapes_should_be_ascii() && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n-            let value = value as u8;\n \n-            value as char\n+            value as u8\n         }\n \n-        'u' => {\n-            // We've parsed '\\u', now we have to parse '{..}'.\n+        'u' => return scan_unicode(chars, mode.is_unicode_escape_disallowed()).map(Into::into),\n+        _ => return Err(EscapeError::InvalidEscape),\n+    };\n+    Ok(res.into())\n+}\n+\n+fn scan_unicode(\n+    chars: &mut Chars<'_>,\n+    is_unicode_escape_disallowed: bool,\n+) -> Result<char, EscapeError> {\n+    // We've parsed '\\u', now we have to parse '{..}'.\n \n-            if chars.next() != Some('{') {\n-                return Err(EscapeError::NoBraceInUnicodeEscape);\n-            }\n+    if chars.next() != Some('{') {\n+        return Err(EscapeError::NoBraceInUnicodeEscape);\n+    }\n \n-            // First character must be a hexadecimal digit.\n-            let mut n_digits = 1;\n-            let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n-                '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n-                '}' => return Err(EscapeError::EmptyUnicodeEscape),\n-                c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n-            };\n-\n-            // First character is valid, now parse the rest of the number\n-            // and closing brace.\n-            loop {\n-                match chars.next() {\n-                    None => return Err(EscapeError::UnclosedUnicodeEscape),\n-                    Some('_') => continue,\n-                    Some('}') => {\n-                        if n_digits > 6 {\n-                            return Err(EscapeError::OverlongUnicodeEscape);\n-                        }\n-\n-                        // Incorrect syntax has higher priority for error reporting\n-                        // than unallowed value for a literal.\n-                        if is_byte {\n-                            return Err(EscapeError::UnicodeEscapeInByte);\n-                        }\n-\n-                        break std::char::from_u32(value).ok_or_else(|| {\n-                            if value > 0x10FFFF {\n-                                EscapeError::OutOfRangeUnicodeEscape\n-                            } else {\n-                                EscapeError::LoneSurrogateUnicodeEscape\n-                            }\n-                        })?;\n-                    }\n-                    Some(c) => {\n-                        let digit: u32 =\n-                            c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n-                        n_digits += 1;\n-                        if n_digits > 6 {\n-                            // Stop updating value since we're sure that it's incorrect already.\n-                            continue;\n-                        }\n-                        value = value * 16 + digit;\n+    // First character must be a hexadecimal digit.\n+    let mut n_digits = 1;\n+    let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n+        '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n+        '}' => return Err(EscapeError::EmptyUnicodeEscape),\n+        c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n+    };\n+\n+    // First character is valid, now parse the rest of the number\n+    // and closing brace.\n+    loop {\n+        match chars.next() {\n+            None => return Err(EscapeError::UnclosedUnicodeEscape),\n+            Some('_') => continue,\n+            Some('}') => {\n+                if n_digits > 6 {\n+                    return Err(EscapeError::OverlongUnicodeEscape);\n+                }\n+\n+                // Incorrect syntax has higher priority for error reporting\n+                // than unallowed value for a literal.\n+                if is_unicode_escape_disallowed {\n+                    return Err(EscapeError::UnicodeEscapeInByte);\n+                }\n+\n+                break std::char::from_u32(value).ok_or_else(|| {\n+                    if value > 0x10FFFF {\n+                        EscapeError::OutOfRangeUnicodeEscape\n+                    } else {\n+                        EscapeError::LoneSurrogateUnicodeEscape\n                     }\n-                };\n+                });\n             }\n-        }\n-        _ => return Err(EscapeError::InvalidEscape),\n-    };\n-    Ok(res)\n+            Some(c) => {\n+                let digit: u32 = c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n+                n_digits += 1;\n+                if n_digits > 6 {\n+                    // Stop updating value since we're sure that it's incorrect already.\n+                    continue;\n+                }\n+                value = value * 16 + digit;\n+            }\n+        };\n+    }\n }\n \n #[inline]\n-fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n-    if is_byte && !c.is_ascii() {\n+fn ascii_check(c: char, characters_should_be_ascii: bool) -> Result<char, EscapeError> {\n+    if characters_should_be_ascii && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n@@ -234,7 +306,7 @@ fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n     let res = match c {\n-        '\\\\' => scan_escape(chars, is_byte),\n+        '\\\\' => scan_escape(chars, if is_byte { Mode::Byte } else { Mode::Char }),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n         _ => ascii_check(c, is_byte),\n@@ -247,9 +319,9 @@ fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, E\n \n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n+fn unescape_str_common<F, T: From<u8> + From<char>>(src: &str, mode: Mode, callback: &mut F)\n where\n-    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+    F: FnMut(Range<usize>, Result<T, EscapeError>),\n {\n     let mut chars = src.chars();\n \n@@ -266,47 +338,49 @@ where\n                         // if unescaped '\\' character is followed by '\\n'.\n                         // For details see [Rust language reference]\n                         // (https://doc.rust-lang.org/reference/tokens.html#string-literals).\n-                        skip_ascii_whitespace(&mut chars, start, callback);\n+                        skip_ascii_whitespace(&mut chars, start, &mut |range, err| {\n+                            callback(range, Err(err))\n+                        });\n                         continue;\n                     }\n-                    _ => scan_escape(&mut chars, is_byte),\n+                    _ => scan_escape::<T>(&mut chars, mode),\n                 }\n             }\n-            '\\n' => Ok('\\n'),\n-            '\\t' => Ok('\\t'),\n+            '\\n' => Ok(b'\\n'.into()),\n+            '\\t' => Ok(b'\\t'.into()),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(c, is_byte),\n+            _ => ascii_check(c, mode.characters_should_be_ascii()).map(Into::into),\n         };\n         let end = src.len() - chars.as_str().len();\n-        callback(start..end, res);\n+        callback(start..end, res.map(Into::into));\n     }\n+}\n \n-    fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n-    where\n-        F: FnMut(Range<usize>, Result<char, EscapeError>),\n-    {\n-        let tail = chars.as_str();\n-        let first_non_space = tail\n-            .bytes()\n-            .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n-            .unwrap_or(tail.len());\n-        if tail[1..first_non_space].contains('\\n') {\n-            // The +1 accounts for the escaping slash.\n-            let end = start + first_non_space + 1;\n-            callback(start..end, Err(EscapeError::MultipleSkippedLinesWarning));\n-        }\n-        let tail = &tail[first_non_space..];\n-        if let Some(c) = tail.chars().nth(0) {\n-            if c.is_whitespace() {\n-                // For error reporting, we would like the span to contain the character that was not\n-                // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n-                let end = start + first_non_space + c.len_utf8() + 1;\n-                callback(start..end, Err(EscapeError::UnskippedWhitespaceWarning));\n-            }\n+fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, EscapeError),\n+{\n+    let tail = chars.as_str();\n+    let first_non_space = tail\n+        .bytes()\n+        .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n+        .unwrap_or(tail.len());\n+    if tail[1..first_non_space].contains('\\n') {\n+        // The +1 accounts for the escaping slash.\n+        let end = start + first_non_space + 1;\n+        callback(start..end, EscapeError::MultipleSkippedLinesWarning);\n+    }\n+    let tail = &tail[first_non_space..];\n+    if let Some(c) = tail.chars().nth(0) {\n+        if c.is_whitespace() {\n+            // For error reporting, we would like the span to contain the character that was not\n+            // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n+            let end = start + first_non_space + c.len_utf8() + 1;\n+            callback(start..end, EscapeError::UnskippedWhitespaceWarning);\n         }\n-        *chars = tail.chars();\n     }\n+    *chars = tail.chars();\n }\n \n /// Takes a contents of a string literal (without quotes) and produces a"}, {"sha": "59549435233c53dad8d2cc84caa85dc35ed927a3", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -146,6 +146,12 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n         }\n+        (ast::LitKind::CStr(data, _), ty::Ref(_, inner_ty, _)) if matches!(inner_ty.kind(), ty::Adt(def, _) if Some(def.did()) == tcx.lang_items().c_str()) =>\n+        {\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n+            let allocation = tcx.mk_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+        }\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n             ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n         }"}, {"sha": "51e904890028a0e3a2d955e586af76d0344ff6d1", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -1,3 +1,5 @@\n+use std::ops::Range;\n+\n use crate::errors;\n use crate::lexer::unicode_chars::UNICODE_ARRAY;\n use crate::make_unclosed_delims_error;\n@@ -6,7 +8,7 @@ use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n use rustc_errors::{error_code, Applicability, Diagnostic, DiagnosticBuilder, StashKey};\n-use rustc_lexer::unescape::{self, Mode};\n+use rustc_lexer::unescape::{self, EscapeError, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n use rustc_session::lint::builtin::{\n@@ -204,6 +206,9 @@ impl<'a> StringReader<'a> {\n                 rustc_lexer::TokenKind::Literal { kind, suffix_start } => {\n                     let suffix_start = start + BytePos(suffix_start);\n                     let (kind, symbol) = self.cook_lexer_literal(start, suffix_start, kind);\n+                    if let token::LitKind::CStr | token::LitKind::CStrRaw(_) = kind {\n+                        self.sess.gated_spans.gate(sym::c_str_literals, self.mk_sp(start, self.pos));\n+                    }\n                     let suffix = if suffix_start < self.pos {\n                         let string = self.str_from(suffix_start);\n                         if string == \"_\" {\n@@ -415,6 +420,16 @@ impl<'a> StringReader<'a> {\n                 }\n                 self.cook_quoted(token::ByteStr, Mode::ByteStr, start, end, 2, 1) // b\" \"\n             }\n+            rustc_lexer::LiteralKind::CStr { terminated } => {\n+                if !terminated {\n+                    self.sess.span_diagnostic.span_fatal_with_code(\n+                        self.mk_sp(start + BytePos(1), end),\n+                        \"unterminated C string\",\n+                        error_code!(E0767),\n+                    )\n+                }\n+                self.cook_c_string(token::CStr, Mode::CStr, start, end, 2, 1) // c\" \"\n+            }\n             rustc_lexer::LiteralKind::RawStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n@@ -433,6 +448,15 @@ impl<'a> StringReader<'a> {\n                     self.report_raw_str_error(start, 2);\n                 }\n             }\n+            rustc_lexer::LiteralKind::RawCStr { n_hashes } => {\n+                if let Some(n_hashes) = n_hashes {\n+                    let n = u32::from(n_hashes);\n+                    let kind = token::CStrRaw(n_hashes);\n+                    self.cook_c_string(kind, Mode::RawCStr, start, end, 3 + n, 1 + n) // cr##\" \"##\n+                } else {\n+                    self.report_raw_str_error(start, 2);\n+                }\n+            }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n                 if empty_int {\n                     let span = self.mk_sp(start, end);\n@@ -648,20 +672,21 @@ impl<'a> StringReader<'a> {\n         self.sess.emit_fatal(errors::TooManyHashes { span: self.mk_sp(start, self.pos), num });\n     }\n \n-    fn cook_quoted(\n+    fn cook_common(\n         &self,\n         kind: token::LitKind,\n         mode: Mode,\n         start: BytePos,\n         end: BytePos,\n         prefix_len: u32,\n         postfix_len: u32,\n+        unescape: fn(&str, Mode, &mut dyn FnMut(Range<usize>, Result<(), EscapeError>)),\n     ) -> (token::LitKind, Symbol) {\n         let mut has_fatal_err = false;\n         let content_start = start + BytePos(prefix_len);\n         let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n-        unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n+        unescape(lit_content, mode, &mut |range, result| {\n             // Here we only check for errors. The actual unescaping is done later.\n             if let Err(err) = result {\n                 let span_with_quotes = self.mk_sp(start, end);\n@@ -692,6 +717,38 @@ impl<'a> StringReader<'a> {\n             (token::Err, self.symbol_from_to(start, end))\n         }\n     }\n+\n+    fn cook_quoted(\n+        &self,\n+        kind: token::LitKind,\n+        mode: Mode,\n+        start: BytePos,\n+        end: BytePos,\n+        prefix_len: u32,\n+        postfix_len: u32,\n+    ) -> (token::LitKind, Symbol) {\n+        self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {\n+            unescape::unescape_literal(src, mode, &mut |span, result| {\n+                callback(span, result.map(drop))\n+            })\n+        })\n+    }\n+\n+    fn cook_c_string(\n+        &self,\n+        kind: token::LitKind,\n+        mode: Mode,\n+        start: BytePos,\n+        end: BytePos,\n+        prefix_len: u32,\n+        postfix_len: u32,\n+    ) -> (token::LitKind, Symbol) {\n+        self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {\n+            unescape::unescape_c_string(src, mode, &mut |span, result| {\n+                callback(span, result.map(drop))\n+            })\n+        })\n+    }\n }\n \n pub fn nfc_normalize(string: &str) -> Symbol {"}, {"sha": "eb9625f923ab95e46771d7123d2f71a0c3c01476", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -78,8 +78,7 @@ pub(crate) fn emit_unescape_error(\n                 }\n             };\n             let sugg = sugg.unwrap_or_else(|| {\n-                let is_byte = mode.is_byte();\n-                let prefix = if is_byte { \"b\" } else { \"\" };\n+                let prefix = mode.prefix_noraw();\n                 let mut escaped = String::with_capacity(lit.len());\n                 let mut chrs = lit.chars().peekable();\n                 while let Some(first) = chrs.next() {\n@@ -97,7 +96,11 @@ pub(crate) fn emit_unescape_error(\n                     };\n                 }\n                 let sugg = format!(\"{prefix}\\\"{escaped}\\\"\");\n-                MoreThanOneCharSugg::Quotes { span: span_with_quotes, is_byte, sugg }\n+                MoreThanOneCharSugg::Quotes {\n+                    span: span_with_quotes,\n+                    is_byte: mode == Mode::Byte,\n+                    sugg,\n+                }\n             });\n             handler.emit_err(UnescapeError::MoreThanOneChar {\n                 span: span_with_quotes,\n@@ -112,7 +115,7 @@ pub(crate) fn emit_unescape_error(\n                 char_span,\n                 escaped_sugg: c.escape_default().to_string(),\n                 escaped_msg: escaped_char(c),\n-                byte: mode.is_byte(),\n+                byte: mode == Mode::Byte,\n             });\n         }\n         EscapeError::BareCarriageReturn => {\n@@ -126,12 +129,15 @@ pub(crate) fn emit_unescape_error(\n         EscapeError::InvalidEscape => {\n             let (c, span) = last_char();\n \n-            let label =\n-                if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n+            let label = if mode == Mode::Byte || mode == Mode::ByteStr {\n+                \"unknown byte escape\"\n+            } else {\n+                \"unknown character escape\"\n+            };\n             let ec = escaped_char(c);\n             let mut diag = handler.struct_span_err(span, format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n-            if c == '{' || c == '}' && !mode.is_byte() {\n+            if c == '{' || c == '}' && matches!(mode, Mode::Str | Mode::RawStr) {\n                 diag.help(\n                     \"if used in a formatting string, curly braces are escaped with `{{` and `}}`\",\n                 );\n@@ -141,7 +147,7 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n-                if !mode.is_byte() {\n+                if mode == Mode::Str || mode == Mode::Char {\n                     diag.span_suggestion(\n                         span_with_quotes,\n                         \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\","}, {"sha": "61396ee0d4aec1bc7fef1a90249f09010c482be6", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -1870,6 +1870,7 @@ impl<'a> Parser<'a> {\n         let recovered = self.recover_after_dot();\n         let token = recovered.as_ref().unwrap_or(&self.token);\n         let span = token.span;\n+\n         token::Lit::from_token(token).map(|token_lit| {\n             self.bump();\n             (token_lit, span)"}, {"sha": "a8fe560d1a760b51693f7ed8dc26089c66c476ac", "filename": "compiler/rustc_session/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_session%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_session%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fmessages.ftl?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -101,3 +101,5 @@ session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n     .help = valid widths are 8, 16, 32, 64 and 128\n \n session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}\n+\n+session_nul_in_c_str = null characters in C string literals are not supported"}, {"sha": "546c0fa8e03e358484e7b59c2c9fd84fab47c37e", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::token;\n use rustc_ast::util::literal::LitError;\n use rustc_errors::{error_code, DiagnosticMessage, EmissionGuarantee, IntoDiagnostic, MultiSpan};\n use rustc_macros::Diagnostic;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{BytePos, Span, Symbol};\n use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n \n #[derive(Diagnostic)]\n@@ -323,6 +323,13 @@ pub(crate) struct BinaryFloatLiteralNotSupported {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(session_nul_in_c_str)]\n+pub(crate) struct NulInCStr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span: Span) {\n     // Checks if `s` looks like i32 or u1234 etc.\n     fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n@@ -401,6 +408,12 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n             };\n             sess.emit_err(IntLiteralTooLarge { span, limit });\n         }\n+        LitError::NulInCStr(range) => {\n+            let lo = BytePos(span.lo().0 + range.start as u32 + 2);\n+            let hi = BytePos(span.lo().0 + range.end as u32 + 2);\n+            let span = span.with_lo(lo).with_hi(hi);\n+            sess.emit_err(NulInCStr { span });\n+        }\n     }\n }\n "}, {"sha": "58015d5d5026c908dc50137da10c15fffcc6d3df", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -441,6 +441,7 @@ symbols! {\n         bridge,\n         bswap,\n         c_str,\n+        c_str_literals,\n         c_unwind,\n         c_variadic,\n         c_void,"}, {"sha": "07b11814f965f63b15f99265a37eb1000da87b51", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -79,9 +79,9 @@ use crate::str;\n ///\n /// [str]: prim@str \"str\"\n #[derive(Hash)]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n #[stable(feature = \"core_c_str\", since = \"1.64.0\")]\n #[rustc_has_incoherent_inherent_impls]\n+#[cfg_attr(not(bootstrap), lang = \"CStr\")]\n // FIXME:\n // `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n // on `CStr` being layout-compatible with `[u8]`."}, {"sha": "caecda1bc63fdcb132d4ad040dc485858dfa5487", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -337,6 +337,8 @@ pub enum LitKind {\n     StrRaw(u8),\n     ByteStr,\n     ByteStrRaw(u8),\n+    CStr,\n+    CStrRaw(u8),\n     Err,\n }\n \n@@ -350,6 +352,8 @@ rpc_encode_decode!(\n         StrRaw(n),\n         ByteStr,\n         ByteStrRaw(n),\n+        CStr,\n+        CStrRaw(n),\n         Err,\n     }\n );"}, {"sha": "c94968b4817cbea0ecc52d857efb7fc4e567a77d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -811,7 +811,9 @@ impl<'src> Classifier<'src> {\n                 | LiteralKind::Str { .. }\n                 | LiteralKind::ByteStr { .. }\n                 | LiteralKind::RawStr { .. }\n-                | LiteralKind::RawByteStr { .. } => Class::String,\n+                | LiteralKind::RawByteStr { .. }\n+                | LiteralKind::CStr { .. }\n+                | LiteralKind::RawCStr { .. } => Class::String,\n                 // Number literals.\n                 LiteralKind::Float { .. } | LiteralKind::Int { .. } => Class::Number,\n             },"}, {"sha": "a48f4c77f857fb5cd8119d9c5aea9d1958eca4e5", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -284,6 +284,7 @@ impl<'a> NormalizedPat<'a> {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n                     LitKind::ByteStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Byte(val) => Self::LitInt(val.into()),\n+                    LitKind::CStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),\n                     LitKind::Bool(val) => Self::LitBool(val),"}, {"sha": "2f2e84fa35a12ce8f7dad577678e6bfdd504fefe", "filename": "src/tools/clippy/clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_context;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use clippy_utils::visitors::is_expr_unsafe;\n use clippy_utils::{get_parent_node, match_libc_symbol};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, Node, UnsafeSource};\n+use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, LangItem, Node, UnsafeSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n                 let val_name = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n                 let method_name = if is_type_diagnostic_item(cx, ty, sym::cstring_type) {\n                     \"as_bytes\"\n-                } else if is_type_diagnostic_item(cx, ty, sym::CStr) {\n+                } else if is_type_lang_item(cx, ty, LangItem::CStr) {\n                     \"to_bytes\"\n                 } else {\n                     return;"}, {"sha": "f75dff46624e40cf2b4bce71df762f9c333c1a67", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -304,6 +304,11 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 kind!(\"ByteStr(ref {vec})\");\n                 chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n             },\n+            LitKind::CStr(ref vec, _) => {\n+                bind!(self, vec);\n+                kind!(\"CStr(ref {vec})\");\n+                chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n+            }\n             LitKind::Str(s, _) => {\n                 bind!(self, s);\n                 kind!(\"Str({s}, _)\");"}, {"sha": "7c7ec6d334d9bc7dadff7024da2a7b5395d47246", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -211,6 +211,7 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n         LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n         LitKind::Byte(b) => Constant::Int(u128::from(b)),\n         LitKind::ByteStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::CStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n         LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {"}, {"sha": "e4b07ab8108e09f5d1a8839bf0c8f94d45d31290", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/basic.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fbasic.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -0,0 +1,7 @@\n+// run-pass\n+\n+#![feature(c_str_literals)]\n+\n+fn main() {\n+    assert_eq!(b\"test\\0\", c\"test\".to_bytes_with_nul());\n+}"}, {"sha": "b27da26ed23bbb776e79c53706ab0280ce20e1b3", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/gate.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -0,0 +1,13 @@\n+// gate-test-c_str_literals\n+\n+macro_rules! m {\n+    ($t:tt) => {}\n+}\n+\n+fn main() {\n+    c\"foo\";\n+    //~^ ERROR: `c\"..\"` literals are experimental\n+\n+    m!(c\"test\");\n+    //~^ ERROR: `c\"..\"` literals are experimental\n+}"}, {"sha": "bc0c537aada839c55f02caada18e79a432af73f4", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/gate.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.stderr?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: `c\"..\"` literals are experimental\n+  --> $DIR/gate.rs:8:5\n+   |\n+LL |     c\"foo\";\n+   |     ^^^^^^\n+   |\n+   = note: see issue #105723 <https://github.com/rust-lang/rust/issues/105723> for more information\n+   = help: add `#![feature(c_str_literals)]` to the crate attributes to enable\n+\n+error[E0658]: `c\"..\"` literals are experimental\n+  --> $DIR/gate.rs:11:8\n+   |\n+LL |     m!(c\"test\");\n+   |        ^^^^^^^\n+   |\n+   = note: see issue #105723 <https://github.com/rust-lang/rust/issues/105723> for more information\n+   = help: add `#![feature(c_str_literals)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "7bc6097f124aabfded4a9e9791611cfe4fbf9f78", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/no-nuls.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676"}, {"sha": "ff9006f6f97f1be7eed18d188e8c30ba2075743e", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/no-nuls.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.stderr?ref=4891f02cff9a282df96b368b2f3f8151a78e9676"}, {"sha": "82e8e2090d7db5ab2a25083312b18038ef9b295a", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/non-ascii.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fnon-ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4891f02cff9a282df96b368b2f3f8151a78e9676/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fnon-ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fnon-ascii.rs?ref=4891f02cff9a282df96b368b2f3f8151a78e9676", "patch": "@@ -0,0 +1,10 @@\n+// run-pass\n+\n+#![feature(c_str_literals)]\n+\n+fn main() {\n+    assert_eq!(\n+        c\"\\xEF\\x80\ud83e\udd80\\u{1F980}\".to_bytes_with_nul(),\n+        &[0xEF, 0x80, 0xF0, 0x9F, 0xA6, 0x80, 0xF0, 0x9F, 0xA6, 0x80, 0x00],\n+    );\n+}"}]}