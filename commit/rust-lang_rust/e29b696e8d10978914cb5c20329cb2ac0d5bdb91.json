{"sha": "e29b696e8d10978914cb5c20329cb2ac0d5bdb91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyOWI2OTZlOGQxMDk3ODkxNGNiNWMyMDMyOWNiMmFjMGQ1YmRiOTE=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-03T09:54:17Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-03T09:54:17Z"}, "message": "Use correct bit size when reading usize values", "tree": {"sha": "ba65a37d42f239c88831277ac5691b8ae9ecbb1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba65a37d42f239c88831277ac5691b8ae9ecbb1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e29b696e8d10978914cb5c20329cb2ac0d5bdb91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e29b696e8d10978914cb5c20329cb2ac0d5bdb91", "html_url": "https://github.com/rust-lang/rust/commit/e29b696e8d10978914cb5c20329cb2ac0d5bdb91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e29b696e8d10978914cb5c20329cb2ac0d5bdb91/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "066a284557ff6e6a2aa19084f599f167a724af7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/066a284557ff6e6a2aa19084f599f167a724af7b", "html_url": "https://github.com/rust-lang/rust/commit/066a284557ff6e6a2aa19084f599f167a724af7b"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "36cc29a2b5b5b7690c3dc92e3e8f98416dffc300", "filename": "src/fn_call.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e29b696e8d10978914cb5c20329cb2ac0d5bdb91/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29b696e8d10978914cb5c20329cb2ac0d5bdb91/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=e29b696e8d10978914cb5c20329cb2ac0d5bdb91", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n         match &link_name[..] {\n             \"malloc\" => {\n-                let size = self.value_to_scalar(args[0])?.to_u64()?;\n+                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n                 if size == 0 {\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -221,7 +221,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 //\n                 // libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n                 // is called if a `HashMap` is created the regular way.\n-                match self.value_to_scalar(args[0])?.to_u64()? {\n+                match self.value_to_scalar(args[0])?.to_usize(self)? {\n                     318 | 511 => {\n                         return err!(Unimplemented(\n                             \"miri does not support random number generators\".to_owned(),\n@@ -293,7 +293,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             \"memcmp\" => {\n                 let left = self.into_ptr(args[0].value)?;\n                 let right = self.into_ptr(args[1].value)?;\n-                let n = Size::from_bytes(self.value_to_scalar(args[2])?.to_u64()?);\n+                let n = Size::from_bytes(self.value_to_scalar(args[2])?.to_usize(self)?);\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -317,7 +317,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             \"memrchr\" => {\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let val = self.value_to_scalar(args[1])?.to_bytes()? as u8;\n-                let num = self.value_to_scalar(args[2])?.to_u64()?;\n+                let num = self.value_to_scalar(args[2])?.to_usize(self)?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().rev().position(\n                     |&c| c == val,\n                 )\n@@ -332,7 +332,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             \"memchr\" => {\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let val = self.value_to_scalar(args[1])?.to_bytes()? as u8;\n-                let num = self.value_to_scalar(args[2])?.to_u64()?;\n+                let num = self.value_to_scalar(args[2])?.to_usize(self)?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n                     |&c| c == val,\n                 )\n@@ -457,7 +457,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n \n             \"sysconf\" => {\n-                let name = self.value_to_scalar(args[0])?.to_u64()?;\n+                let name = self.value_to_scalar(args[0])?.to_usize(self)?;\n \n                 trace!(\"sysconf() called with name {}\", name);\n                 // cache the sysconf integers via miri's global cache\n@@ -646,8 +646,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         match &path[..] {\n             // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n             \"alloc::alloc::::__rust_alloc\" => {\n-                let size = self.value_to_scalar(args[0])?.to_u64()?;\n-                let align = self.value_to_scalar(args[1])?.to_u64()?;\n+                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[1])?.to_usize(self)?;\n                 if size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -660,8 +660,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::alloc::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_scalar(args[0])?.to_u64()?;\n-                let align = self.value_to_scalar(args[1])?.to_u64()?;\n+                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[1])?.to_usize(self)?;\n                 if size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -676,8 +676,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n             \"alloc::alloc::::__rust_dealloc\" => {\n                 let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let old_size = self.value_to_scalar(args[1])?.to_u64()?;\n-                let align = self.value_to_scalar(args[2])?.to_u64()?;\n+                let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n                 if old_size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -692,9 +692,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n             \"alloc::alloc::::__rust_realloc\" => {\n                 let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let old_size = self.value_to_scalar(args[1])?.to_u64()?;\n-                let align = self.value_to_scalar(args[2])?.to_u64()?;\n-                let new_size = self.value_to_scalar(args[3])?.to_u64()?;\n+                let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n+                let new_size = self.value_to_scalar(args[3])?.to_usize(self)?;\n                 if old_size == 0 || new_size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }"}, {"sha": "a29211df996bf893e406853fc726fb65ca8f43bd", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e29b696e8d10978914cb5c20329cb2ac0d5bdb91/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29b696e8d10978914cb5c20329cb2ac0d5bdb91/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e29b696e8d10978914cb5c20329cb2ac0d5bdb91", "patch": "@@ -62,7 +62,7 @@ pub trait ScalarExt {\n     fn from_isize(i: i64, ptr_size: Size) -> Self;\n     fn from_f32(f: f32) -> Self;\n     fn from_f64(f: f64) -> Self;\n-    fn to_u64(self) -> EvalResult<'static, u64>;\n+    fn to_usize<'a, 'mir, 'tcx>(self, ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>) -> EvalResult<'static, u64>;\n     fn is_null(self) -> EvalResult<'static, bool>;\n     /// HACK: this function just extracts all bits if `defined != 0`\n     /// Mainly used for args of C-functions and we should totally correctly fetch the size\n@@ -103,8 +103,8 @@ impl ScalarExt for Scalar {\n         Scalar::Bits { bits: f.to_bits() as u128, defined: 64 }\n     }\n \n-    fn to_u64(self) -> EvalResult<'static, u64> {\n-        let b = self.to_bits(Size::from_bits(64))?;\n+    fn to_usize<'a, 'mir, 'tcx>(self, ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>) -> EvalResult<'static, u64> {\n+        let b = self.to_bits(ecx.memory.pointer_size())?;\n         assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n     }"}, {"sha": "d82a345c2512aacefd8ddc866fa2b9b4f9633de3", "filename": "src/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e29b696e8d10978914cb5c20329cb2ac0d5bdb91/src%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29b696e8d10978914cb5c20329cb2ac0d5bdb91/src%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalidation.rs?ref=e29b696e8d10978914cb5c20329cb2ac0d5bdb91", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             Index(v) => {\n                 let value = self.frame().get_local(v)?;\n                 let ty = self.tcx.tcx.types.usize;\n-                let n = self.value_to_scalar(ValTy { value, ty })?.to_u64()?;\n+                let n = self.value_to_scalar(ValTy { value, ty })?.to_usize(self)?;\n                 Index(n)\n             },\n             ConstantIndex { offset, min_length, from_end } =>"}]}