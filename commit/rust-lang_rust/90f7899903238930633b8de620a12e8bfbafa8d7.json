{"sha": "90f7899903238930633b8de620a12e8bfbafa8d7", "node_id": "C_kwDOAAsO6NoAKDkwZjc4OTk5MDMyMzg5MzA2MzNiOGRlNjIwYTEyZThiZmJhZmE4ZDc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-24T12:57:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-24T12:57:51Z"}, "message": "Merge #11531\n\n11531: fix: Make fill_match_arms assist handle doc(hidden) and non_exhaustive r=Veykril a=OleStrohm\n\nFixes #11499\r\nFixes #11500\r\nThis keeps track of the relevant attributes and adds in a wildcard pat at the end of the match when necessary.\r\n\r\nI decided to do them in the same PR since they both needed the ability to add a wildcard arm, and so their changes would overlap if done separately, but I'll split them up if that seems better.\r\n\r\nThis is my first PR to rust-analyzer, so all feedback is greatly appreciated!\n\nCo-authored-by: Ole Strohm <strohm99@gmail.com>", "tree": {"sha": "f815b473104458f27c1a3dfa73d7427d3b69e639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f815b473104458f27c1a3dfa73d7427d3b69e639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90f7899903238930633b8de620a12e8bfbafa8d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiF4DPCRBK7hj4Ov3rIwAAaX0IADRoeFj72tnmo/bPOlE4dDbG\n9HFH1Gnbf6tyYwGvAwr3PhdhbANJ7z/RPHUSJRuyDBmescdkFTM8K1grKMP2vHgC\nyFyo0zeX9LvYg4W/Ea8v6lD4DOY1H5SYp+2ge5v0TGtRQLwrR1j7xGPMCDHfNGB4\njv49rlT+WX57q1sYBuTTUpfnK6aqy+emR3v5hqJnbxEDIAde8Buu0599/ko3nvnS\nSKONrhYN5Vc9sq3PauCfv419dz6IIOI2XfH7ev7MuT4yT765CCbJjJtjzbJH8eCE\nMXndpnaI9XPdTEkMCoWIhxUfEZAxryEHBPMJOUsTdsHz926POqT/JgqF6EFBLmc=\n=82y4\n-----END PGP SIGNATURE-----\n", "payload": "tree f815b473104458f27c1a3dfa73d7427d3b69e639\nparent 6b55d2f10aea2f38be83693b55e8dcf771335233\nparent f1ba7465c6a24aa80dda6b6f55f847e4b56c3275\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645707471 +0000\ncommitter GitHub <noreply@github.com> 1645707471 +0000\n\nMerge #11531\n\n11531: fix: Make fill_match_arms assist handle doc(hidden) and non_exhaustive r=Veykril a=OleStrohm\n\nFixes #11499\r\nFixes #11500\r\nThis keeps track of the relevant attributes and adds in a wildcard pat at the end of the match when necessary.\r\n\r\nI decided to do them in the same PR since they both needed the ability to add a wildcard arm, and so their changes would overlap if done separately, but I'll split them up if that seems better.\r\n\r\nThis is my first PR to rust-analyzer, so all feedback is greatly appreciated!\n\nCo-authored-by: Ole Strohm <strohm99@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90f7899903238930633b8de620a12e8bfbafa8d7", "html_url": "https://github.com/rust-lang/rust/commit/90f7899903238930633b8de620a12e8bfbafa8d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90f7899903238930633b8de620a12e8bfbafa8d7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b55d2f10aea2f38be83693b55e8dcf771335233", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b55d2f10aea2f38be83693b55e8dcf771335233", "html_url": "https://github.com/rust-lang/rust/commit/6b55d2f10aea2f38be83693b55e8dcf771335233"}, {"sha": "f1ba7465c6a24aa80dda6b6f55f847e4b56c3275", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ba7465c6a24aa80dda6b6f55f847e4b56c3275", "html_url": "https://github.com/rust-lang/rust/commit/f1ba7465c6a24aa80dda6b6f55f847e4b56c3275"}], "stats": {"total": 455, "additions": 427, "deletions": 28}, "files": [{"sha": "ec8fbb49745147cb6dc9a5e22f93f4ea7a4e71e7", "filename": "crates/ide_assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 427, "deletions": 28, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/90f7899903238930633b8de620a12e8bfbafa8d7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f7899903238930633b8de620a12e8bfbafa8d7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=90f7899903238930633b8de620a12e8bfbafa8d7", "patch": "@@ -1,11 +1,11 @@\n use std::iter::{self, Peekable};\n \n use either::Either;\n-use hir::{Adt, HasSource, ModuleDef, Semantics};\n+use hir::{Adt, Crate, HasAttrs, HasSource, ModuleDef, Semantics};\n use ide_db::helpers::{mod_path_to_ast, FamousDefs};\n use ide_db::RootDatabase;\n use itertools::Itertools;\n-use syntax::ast::{self, make, AstNode, HasName, MatchArm, MatchArmList, MatchExpr, Pat};\n+use syntax::ast::{self, make, AstNode, HasName, MatchArmList, MatchExpr, Pat};\n \n use crate::{\n     utils::{self, render_snippet, Cursor},\n@@ -52,36 +52,45 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n \n     let expr = match_expr.expr()?;\n \n-    let mut arms: Vec<MatchArm> = match_arm_list.arms().collect();\n-    if let [arm] = arms.as_slice() {\n-        if let Some(Pat::WildcardPat(..)) = arm.pat() {\n-            arms.clear();\n-        }\n-    }\n+    let mut has_catch_all_arm = false;\n \n-    let top_lvl_pats: Vec<_> = arms\n-        .iter()\n-        .filter_map(ast::MatchArm::pat)\n-        .flat_map(|pat| match pat {\n-            // Special case OrPat as separate top-level pats\n-            Pat::OrPat(or_pat) => Either::Left(or_pat.pats()),\n-            _ => Either::Right(iter::once(pat)),\n+    let top_lvl_pats: Vec<_> = match_arm_list\n+        .arms()\n+        .filter_map(|arm| Some((arm.pat()?, arm.guard().is_some())))\n+        .flat_map(|(pat, has_guard)| {\n+            match pat {\n+                // Special case OrPat as separate top-level pats\n+                Pat::OrPat(or_pat) => Either::Left(or_pat.pats()),\n+                _ => Either::Right(iter::once(pat)),\n+            }\n+            .map(move |pat| (pat, has_guard))\n+        })\n+        .map(|(pat, has_guard)| {\n+            has_catch_all_arm |= !has_guard && matches!(pat, Pat::WildcardPat(_));\n+            pat\n         })\n         // Exclude top level wildcards so that they are expanded by this assist, retains status quo in #8129.\n         .filter(|pat| !matches!(pat, Pat::WildcardPat(_)))\n         .collect();\n \n     let module = ctx.sema.scope(expr.syntax()).module()?;\n+    let (mut missing_pats, is_non_exhaustive): (\n+        Peekable<Box<dyn Iterator<Item = (ast::Pat, bool)>>>,\n+        bool,\n+    ) = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n+        let is_non_exhaustive = enum_def.is_non_exhaustive(ctx.db());\n \n-    let mut missing_pats: Peekable<Box<dyn Iterator<Item = ast::Pat>>> = if let Some(enum_def) =\n-        resolve_enum_def(&ctx.sema, &expr)\n-    {\n         let variants = enum_def.variants(ctx.db());\n \n         let missing_pats = variants\n             .into_iter()\n-            .filter_map(|variant| build_pat(ctx.db(), module, variant))\n-            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n+            .filter_map(|variant| {\n+                Some((\n+                    build_pat(ctx.db(), module, variant)?,\n+                    variant.should_be_hidden(ctx.db(), module.krate()),\n+                ))\n+            })\n+            .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n \n         let option_enum =\n             FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option().map(lift_enum);\n@@ -92,8 +101,11 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n         } else {\n             Box::new(missing_pats)\n         };\n-        missing_pats.peekable()\n+        (missing_pats.peekable(), is_non_exhaustive)\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n+        let is_non_exhaustive =\n+            enum_defs.iter().any(|enum_def| enum_def.is_non_exhaustive(ctx.db()));\n+\n         let mut n_arms = 1;\n         let variants_of_enums: Vec<Vec<ExtendedVariant>> = enum_defs\n             .into_iter()\n@@ -117,17 +129,23 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n             .multi_cartesian_product()\n             .inspect(|_| cov_mark::hit!(add_missing_match_arms_lazy_computation))\n             .map(|variants| {\n+                let is_hidden = variants\n+                    .iter()\n+                    .any(|variant| variant.should_be_hidden(ctx.db(), module.krate()));\n                 let patterns =\n                     variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n-                ast::Pat::from(make::tuple_pat(patterns))\n+\n+                (ast::Pat::from(make::tuple_pat(patterns)), is_hidden)\n             })\n-            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n-        (Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable()\n+            .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n+        ((Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable(), is_non_exhaustive)\n     } else {\n         return None;\n     };\n \n-    if missing_pats.peek().is_none() {\n+    let mut needs_catch_all_arm = is_non_exhaustive && !has_catch_all_arm;\n+\n+    if !needs_catch_all_arm && missing_pats.peek().is_none() {\n         return None;\n     }\n \n@@ -138,8 +156,10 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n         |builder| {\n             let new_match_arm_list = match_arm_list.clone_for_update();\n             let missing_arms = missing_pats\n-                .map(|pat| make::match_arm(iter::once(pat), None, make::ext::expr_todo()))\n-                .map(|it| it.clone_for_update());\n+                .map(|(pat, hidden)| {\n+                    (make::match_arm(iter::once(pat), None, make::ext::expr_todo()), hidden)\n+                })\n+                .map(|(it, hidden)| (it.clone_for_update(), hidden));\n \n             let catch_all_arm = new_match_arm_list\n                 .arms()\n@@ -159,7 +179,22 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n                 }\n             }\n             let mut first_new_arm = None;\n-            for arm in missing_arms {\n+            for (arm, hidden) in missing_arms {\n+                if hidden {\n+                    needs_catch_all_arm = !has_catch_all_arm;\n+                } else {\n+                    first_new_arm.get_or_insert_with(|| arm.clone());\n+                    new_match_arm_list.add_arm(arm);\n+                }\n+            }\n+            if needs_catch_all_arm && !has_catch_all_arm {\n+                cov_mark::hit!(added_wildcard_pattern);\n+                let arm = make::match_arm(\n+                    iter::once(make::wildcard_pat().into()),\n+                    None,\n+                    make::ext::expr_todo(),\n+                )\n+                .clone_for_update();\n                 first_new_arm.get_or_insert_with(|| arm.clone());\n                 new_match_arm_list.add_arm(arm);\n             }\n@@ -250,11 +285,29 @@ enum ExtendedVariant {\n     Variant(hir::Variant),\n }\n \n+impl ExtendedVariant {\n+    fn should_be_hidden(self, db: &RootDatabase, krate: Crate) -> bool {\n+        match self {\n+            ExtendedVariant::Variant(var) => {\n+                var.attrs(db).has_doc_hidden() && var.module(db).krate() != krate\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+\n fn lift_enum(e: hir::Enum) -> ExtendedEnum {\n     ExtendedEnum::Enum(e)\n }\n \n impl ExtendedEnum {\n+    fn is_non_exhaustive(self, db: &RootDatabase) -> bool {\n+        match self {\n+            ExtendedEnum::Enum(e) => e.attrs(db).by_key(\"non_exhaustive\").exists(),\n+            _ => false,\n+        }\n+    }\n+\n     fn variants(self, db: &RootDatabase) -> Vec<ExtendedVariant> {\n         match self {\n             ExtendedEnum::Enum(e) => {\n@@ -1280,6 +1333,352 @@ fn foo(t: bool) {\n         $0true => todo!(),\n         false => todo!(),\n     }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_fill_hidden_variants() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+    }\n+}\n+//- /e.rs crate:e\n+pub enum E { A, #[doc(hidden)] B, }\n+\"#,\n+            r#\"\n+fn foo(t: ::e::E) {\n+    match t {\n+        $0e::E::A => todo!(),\n+        _ => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_fill_hidden_variants_tuple() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: (bool, ::e::E)) {\n+    match $0t {\n+    }\n+}\n+//- /e.rs crate:e\n+pub enum E { A, #[doc(hidden)] B, }\n+\"#,\n+            r#\"\n+fn foo(t: (bool, ::e::E)) {\n+    match t {\n+        $0(true, e::E::A) => todo!(),\n+        (false, e::E::A) => todo!(),\n+        _ => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_with_only_hidden_variants() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+    }\n+}\n+//- /e.rs crate:e\n+pub enum E { #[doc(hidden)] A, }\n+\"#,\n+            r#\"\n+fn foo(t: ::e::E) {\n+    match t {\n+        ${0:_} => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_fill_wildcard_when_hidden_variants_are_explicit() {\n+        check_assist_not_applicable(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+        e::E::A => todo!(),\n+    }\n+}\n+//- /e.rs crate:e\n+pub enum E { #[doc(hidden)] A, }\n+\"#,\n+        );\n+    }\n+\n+    // FIXME: I don't think the assist should be applicable in this case\n+    #[test]\n+    fn does_not_fill_wildcard_with_wildcard() {\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+        _ => todo!(),\n+    }\n+}\n+//- /e.rs crate:e\n+pub enum E { #[doc(hidden)] A, }\n+\"#,\n+            r#\"\n+fn foo(t: ::e::E) {\n+    match t {\n+        _ => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_on_non_exhaustive_with_explicit_matches() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+        e::E::A => todo!(),\n+    }\n+}\n+//- /e.rs crate:e\n+#[non_exhaustive]\n+pub enum E { A, }\n+\"#,\n+            r#\"\n+fn foo(t: ::e::E) {\n+    match t {\n+        e::E::A => todo!(),\n+        ${0:_} => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_on_non_exhaustive_without_matches() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+    }\n+}\n+//- /e.rs crate:e\n+#[non_exhaustive]\n+pub enum E { A, }\n+\"#,\n+            r#\"\n+fn foo(t: ::e::E) {\n+    match t {\n+        $0e::E::A => todo!(),\n+        _ => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_on_non_exhaustive_with_doc_hidden() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+    }\n+}\n+//- /e.rs crate:e\n+#[non_exhaustive]\n+pub enum E { A, #[doc(hidden)] B }\"#,\n+            r#\"\n+fn foo(t: ::e::E) {\n+    match t {\n+        $0e::E::A => todo!(),\n+        _ => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_on_non_exhaustive_with_doc_hidden_with_explicit_arms() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+        e::E::A => todo!(),\n+    }\n+}\n+//- /e.rs crate:e\n+#[non_exhaustive]\n+pub enum E { A, #[doc(hidden)] B }\"#,\n+            r#\"\n+fn foo(t: ::e::E) {\n+    match t {\n+        e::E::A => todo!(),\n+        ${0:_} => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_wildcard_with_partial_wildcard() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E, b: bool) {\n+    match $0t {\n+        _ if b => todo!(),\n+    }\n+}\n+//- /e.rs crate:e\n+pub enum E { #[doc(hidden)] A, }\"#,\n+            r#\"\n+fn foo(t: ::e::E, b: bool) {\n+    match t {\n+        _ if b => todo!(),\n+        ${0:_} => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_fill_wildcard_with_partial_wildcard_and_wildcard() {\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E, b: bool) {\n+    match $0t {\n+        _ if b => todo!(),\n+        _ => todo!(),\n+    }\n+}\n+//- /e.rs crate:e\n+pub enum E { #[doc(hidden)] A, }\"#,\n+            r#\"\n+fn foo(t: ::e::E, b: bool) {\n+    match t {\n+        _ if b => todo!(),\n+        _ => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_exhaustive_doc_hidden_tuple_fills_wildcard() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+//- /main.rs crate:main deps:e\n+fn foo(t: ::e::E) {\n+    match $0t {\n+    }\n+}\n+//- /e.rs crate:e\n+#[non_exhaustive]\n+pub enum E { A, #[doc(hidden)] B, }\"#,\n+            r#\"\n+fn foo(t: ::e::E) {\n+    match t {\n+        $0e::E::A => todo!(),\n+        _ => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ignores_doc_hidden_for_crate_local_enums() {\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+enum E { A, #[doc(hidden)] B, }\n+\n+fn foo(t: E) {\n+    match $0t {\n+    }\n+}\"#,\n+            r#\"\n+enum E { A, #[doc(hidden)] B, }\n+\n+fn foo(t: E) {\n+    match t {\n+        $0E::A => todo!(),\n+        E::B => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ignores_doc_hidden_for_crate_local_enums_but_not_non_exhaustive() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+#[non_exhaustive]\n+enum E { A, #[doc(hidden)] B, }\n+\n+fn foo(t: E) {\n+    match $0t {\n+    }\n+}\"#,\n+            r#\"\n+#[non_exhaustive]\n+enum E { A, #[doc(hidden)] B, }\n+\n+fn foo(t: E) {\n+    match t {\n+        $0E::A => todo!(),\n+        E::B => todo!(),\n+        _ => todo!(),\n+    }\n }\"#,\n         );\n     }"}]}