{"sha": "8f6a06285efe12d778ff7f44067aebeed7b14428", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNmEwNjI4NWVmZTEyZDc3OGZmN2Y0NDA2N2FlYmVlZDdiMTQ0Mjg=", "commit": {"author": {"name": "Peter", "email": "peter.wilkins@polecat.com", "date": "2019-12-08T23:16:18Z"}, "committer": {"name": "Peter", "email": "peter.wilkins@polecat.com", "date": "2019-12-08T23:49:30Z"}, "message": "move from non zero impls to `libcore/convert/num.rs`", "tree": {"sha": "856b9d17a8e4700c44a2794e63ec75ecf9660397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/856b9d17a8e4700c44a2794e63ec75ecf9660397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f6a06285efe12d778ff7f44067aebeed7b14428", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f6a06285efe12d778ff7f44067aebeed7b14428", "html_url": "https://github.com/rust-lang/rust/commit/8f6a06285efe12d778ff7f44067aebeed7b14428", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f6a06285efe12d778ff7f44067aebeed7b14428/comments", "author": null, "committer": null, "parents": [{"sha": "947772fc31b96ce90f57720f74571f14e35df66b", "url": "https://api.github.com/repos/rust-lang/rust/commits/947772fc31b96ce90f57720f74571f14e35df66b", "html_url": "https://github.com/rust-lang/rust/commit/947772fc31b96ce90f57720f74571f14e35df66b"}, {"sha": "59947fcae6a40df12e33af8c8c7291014b7603e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/59947fcae6a40df12e33af8c8c7291014b7603e0", "html_url": "https://github.com/rust-lang/rust/commit/59947fcae6a40df12e33af8c8c7291014b7603e0"}], "stats": {"total": 109445, "additions": 58389, "deletions": 51056}, "files": [{"sha": "8fbbd7c4a2e49b0ac2e86dae076ce6e6248ad21e", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -150,13 +150,13 @@ All pull requests are reviewed by another person. We have a bot,\n request.\n \n If you want to request that a specific person reviews your pull request,\n-you can add an `r?` to the message. For example, [Steve][steveklabnik] usually reviews\n+you can add an `r?` to the pull request description. For example, [Steve][steveklabnik] usually reviews\n documentation changes. So if you were to make a documentation change, add\n \n     r? @steveklabnik\n \n-to the end of the message, and @rust-highfive will assign [@steveklabnik][steveklabnik] instead\n-of a random person. This is entirely optional.\n+to the end of the pull request description, and [@rust-highfive][rust-highfive] will assign\n+[@steveklabnik][steveklabnik] instead of a random person. This is entirely optional.\n \n After someone has reviewed your pull request, they will leave an annotation\n on the pull request with an `r+`. It will look something like this:"}, {"sha": "5484f24003133817e565b9e9cffa2fa219d30873", "filename": "Cargo.lock", "status": "modified", "additions": 381, "deletions": 230, "changes": 611, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -54,7 +54,7 @@ version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n dependencies = [\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -104,7 +104,7 @@ checksum = \"9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652\"\n dependencies = [\n  \"libc\",\n  \"termion\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -154,6 +154,15 @@ version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n \n+[[package]]\n+name = \"bitmaps\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"81e039a80914325b37fde728ef7693c212f0ac913d5599607d7b95a9484aae0b\"\n+dependencies = [\n+ \"typenum\",\n+]\n+\n [[package]]\n name = \"blake2-rfc\"\n version = \"0.2.18\"\n@@ -212,12 +221,6 @@ dependencies = [\n  \"toml\",\n ]\n \n-[[package]]\n-name = \"build_const\"\n-version = \"0.2.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39092a32794787acd8525ee150305ff051b0aa6cc2abaf193924f5ab05425f39\"\n-\n [[package]]\n name = \"build_helper\"\n version = \"0.1.0\"\n@@ -272,17 +275,17 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.41.0\"\n+version = \"0.42.0\"\n dependencies = [\n  \"atty\",\n  \"bytesize\",\n  \"cargo-platform\",\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"clap\",\n- \"core-foundation\",\n+ \"core-foundation 0.7.0\",\n  \"crates-io\",\n- \"crossbeam-utils 0.6.5\",\n+ \"crossbeam-utils 0.7.0\",\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n@@ -311,7 +314,7 @@ dependencies = [\n  \"num_cpus\",\n  \"opener\",\n  \"openssl\",\n- \"percent-encoding 2.0.0\",\n+ \"percent-encoding 2.1.0\",\n  \"pretty_env_logger\",\n  \"remove_dir_all\",\n  \"rustc-workspace-hack\",\n@@ -330,7 +333,7 @@ dependencies = [\n  \"unicode-width\",\n  \"url 2.1.0\",\n  \"walkdir\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -392,9 +395,13 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.37\"\n+version = \"1.0.47\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39f75544d7bbaf57560d2168f28fd649ff9c76153874db88bdbdfd839b1a7e7d\"\n+checksum = \"aa87058dce70a3ff5621797f1506cb837edd02ac4c0ae642b4542dce802908b8\"\n+dependencies = [\n+ \"jobserver\",\n+ \"num_cpus\",\n+]\n \n [[package]]\n name = \"cfg-if\"\n@@ -461,12 +468,15 @@ dependencies = [\n  \"clippy_lints\",\n  \"compiletest_rs\",\n  \"derive-new\",\n+ \"git2\",\n  \"lazy_static 1.3.0\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n  \"semver\",\n  \"serde\",\n+ \"tempfile\",\n+ \"tester\",\n ]\n \n [[package]]\n@@ -482,12 +492,12 @@ dependencies = [\n  \"itertools 0.8.0\",\n  \"lazy_static 1.3.0\",\n  \"matches\",\n- \"pulldown-cmark 0.6.0\",\n+ \"pulldown-cmark 0.6.1\",\n  \"quine-mc_cluskey\",\n  \"regex-syntax\",\n  \"semver\",\n  \"serde\",\n- \"smallvec 0.6.10\",\n+ \"smallvec 1.0.0\",\n  \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n@@ -511,6 +521,26 @@ dependencies = [\n  \"cc\",\n ]\n \n+[[package]]\n+name = \"codespan\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"de67bdcd653002a6dba3eb53850ce3a485547225d81cb6c2bbdbc5a0cba5d15d\"\n+dependencies = [\n+ \"unicode-segmentation\",\n+]\n+\n+[[package]]\n+name = \"codespan-reporting\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"efd1d915d9e2b2ad696b2cd73215a84823ef3f0e3084d90304204415921b62c6\"\n+dependencies = [\n+ \"codespan\",\n+ \"termcolor\",\n+ \"unicode-width\",\n+]\n+\n [[package]]\n name = \"colored\"\n version = \"1.6.0\"\n@@ -564,14 +594,14 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"walkdir\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.3.25\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f75b10a18fb53549fdd090846eb01c7f8593914494d1faabc4d3005c436e417a\"\n+checksum = \"d7b678957210a00ba0fbeacc23d38cbfbf29895564da1616564634351e1dac5e\"\n dependencies = [\n  \"diff\",\n  \"filetime\",\n@@ -585,7 +615,8 @@ dependencies = [\n  \"serde_derive\",\n  \"serde_json\",\n  \"tempfile\",\n- \"winapi 0.3.6\",\n+ \"tester\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -594,6 +625,34 @@ version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8ff012e225ce166d4422e0e78419d901719760f62ae2b7969ca6b564d1b54a9e\"\n \n+[[package]]\n+name = \"cookie\"\n+version = \"0.12.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"888604f00b3db336d2af898ec3c1d5d0ddf5e6d462220f2ededc33a87ac4bbd5\"\n+dependencies = [\n+ \"time\",\n+ \"url 1.7.2\",\n+]\n+\n+[[package]]\n+name = \"cookie_store\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"46750b3f362965f197996c4448e4a0935e791bf7d6631bfce9ee0af3d24c919c\"\n+dependencies = [\n+ \"cookie\",\n+ \"failure\",\n+ \"idna 0.1.5\",\n+ \"log\",\n+ \"publicsuffix\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"time\",\n+ \"try_from\",\n+ \"url 1.7.2\",\n+]\n+\n [[package]]\n name = \"core\"\n version = \"0.0.0\"\n@@ -607,7 +666,17 @@ version = \"0.6.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4e2640d6d0bf22e82bed1b73c6aef8d5dd31e5abe6666c57e6d45e2649f4f887\"\n dependencies = [\n- \"core-foundation-sys\",\n+ \"core-foundation-sys 0.6.2\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"core-foundation\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"57d24c7a13c43e870e37c1556b74555437870a04514f7685f5b354e090567171\"\n+dependencies = [\n+ \"core-foundation-sys 0.7.0\",\n  \"libc\",\n ]\n \n@@ -617,28 +686,25 @@ version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e7ca8a5221364ef15ce201e8ed2f609fc312682a8f4e0e3d4aa5879764e0fa3b\"\n \n+[[package]]\n+name = \"core-foundation-sys\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b3a71ab494c0b5b860bdc8407ae08978052417070c2ced38573a9157ad75b8ac\"\n+\n [[package]]\n name = \"crates-io\"\n-version = \"0.29.0\"\n+version = \"0.30.0\"\n dependencies = [\n  \"curl\",\n  \"failure\",\n- \"percent-encoding 2.0.0\",\n+ \"percent-encoding 2.1.0\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n  \"url 2.1.0\",\n ]\n \n-[[package]]\n-name = \"crc\"\n-version = \"1.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d663548de7f5cca343f1e0a48d14dcfb0e9eb4e079ec58883b7251539fa10aeb\"\n-dependencies = [\n- \"build_const\",\n-]\n-\n [[package]]\n name = \"crc32fast\"\n version = \"1.1.2\"\n@@ -745,6 +811,17 @@ dependencies = [\n  \"lazy_static 1.3.0\",\n ]\n \n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce446db02cdc3165b94ae73111e570793400d0794e46125cc4056c81cbb039f4\"\n+dependencies = [\n+ \"autocfg\",\n+ \"cfg-if\",\n+ \"lazy_static 1.3.0\",\n+]\n+\n [[package]]\n name = \"crypto-hash\"\n version = \"0.3.1\"\n@@ -754,7 +831,7 @@ dependencies = [\n  \"commoncrypto\",\n  \"hex 0.3.2\",\n  \"openssl\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -769,7 +846,7 @@ dependencies = [\n  \"openssl-sys\",\n  \"schannel\",\n  \"socket2\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -785,7 +862,7 @@ dependencies = [\n  \"openssl-sys\",\n  \"pkg-config\",\n  \"vcpkg\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -901,7 +978,7 @@ dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_users\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -921,6 +998,12 @@ version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ea57b42383d091c85abcc2706240b94ab2a8fa1fc81c10ff23c4de06e2a90b5e\"\n \n+[[package]]\n+name = \"dunce\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d0ad6bf6a88548d1126045c413548df1453d9be094a8ab9fd59bf1fdd338da4f\"\n+\n [[package]]\n name = \"either\"\n version = \"1.5.0\"\n@@ -1050,15 +1133,15 @@ checksum = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \n [[package]]\n name = \"flate2\"\n-version = \"1.0.6\"\n+version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2291c165c8e703ee54ef3055ad6188e3d51108e2ded18e9f2476e774fc5ad3d4\"\n+checksum = \"ad3c5233c9a940c8719031b423d7e6c16af66e031cb0420b0896f5245bf181d3\"\n dependencies = [\n+ \"cfg-if\",\n  \"crc32fast\",\n  \"libc\",\n  \"libz-sys\",\n- \"miniz-sys\",\n- \"miniz_oxide_c_api\",\n+ \"miniz_oxide\",\n ]\n \n [[package]]\n@@ -1107,7 +1190,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213\"\n dependencies = [\n  \"libc\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -1211,14 +1294,14 @@ checksum = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"wasi\",\n+ \"wasi 0.7.0\",\n ]\n \n [[package]]\n name = \"git2\"\n-version = \"0.10.0\"\n+version = \"0.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"327d698f86a7ebdfeb86a4238ccdb004828939d3a3555b6ead679541d14e36c0\"\n+checksum = \"39f27186fbb5ec67ece9a56990292bc5aed3c3fc51b9b07b0b52446b1dfb4a82\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1359,7 +1442,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a3753954f7bd71f0e671afb8b5a992d1724cf43b7f95a563cd4a0bde94659ca8\"\n dependencies = [\n  \"scopeguard 1.0.0\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -1378,9 +1461,9 @@ dependencies = [\n \n [[package]]\n name = \"http\"\n-version = \"0.1.16\"\n+version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fe67e3678f2827030e89cc4b9e7ecd16d52f132c0b940ab5005f88e821500f6a\"\n+checksum = \"d7e06e336150b178206af098a055e3621e8336027e2b4d126bda0bc64824baaf\"\n dependencies = [\n  \"bytes\",\n  \"fnv\",\n@@ -1511,13 +1594,16 @@ dependencies = [\n \n [[package]]\n name = \"im-rc\"\n-version = \"13.0.0\"\n+version = \"14.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0a0197597d095c0d11107975d3175173f810ee572c2501ff4de64f4f3f119806\"\n+checksum = \"e9ad726dce25993be6352b0bff048e4d2647440c0a673d32257c4fac49356d18\"\n dependencies = [\n- \"rustc_version\",\n+ \"bitmaps\",\n+ \"rand_core 0.5.1\",\n+ \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n+ \"version_check 0.9.1\",\n ]\n \n [[package]]\n@@ -1539,7 +1625,7 @@ dependencies = [\n  \"remove_dir_all\",\n  \"tar\",\n  \"walkdir\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n  \"xz2\",\n ]\n \n@@ -1704,7 +1790,7 @@ dependencies = [\n  \"num_cpus\",\n  \"tokio\",\n  \"tokio-codec\",\n- \"unicase 2.5.1\",\n+ \"unicase\",\n ]\n \n [[package]]\n@@ -1744,24 +1830,11 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"libflate\"\n-version = \"0.1.25\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"90c6f86f4b0caa347206f916f8b687b51d77c6ef8ff18d52dd007491fd580529\"\n-dependencies = [\n- \"adler32\",\n- \"byteorder\",\n- \"crc32fast\",\n- \"rle-decode-fast\",\n- \"take_mut\",\n-]\n-\n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8c2078aec6f4b16d1b89f6a72e4f6eb1e75ffa85312023291e89c6d3087bc8fb\"\n+checksum = \"a30f8637eb59616ee3b8a00f6adff781ee4ddd8343a615b8238de756060cc1b3\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1926,9 +1999,9 @@ checksum = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.3.3\"\n+version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9a070268274c566082efb6b2ace7743e43ba91a70d5c6982981e96d3c05ac81c\"\n+checksum = \"031bdd9d4893c983e2f69ebc4b59070feee8276a584c4aabdcb351235ea28016\"\n dependencies = [\n  \"ammonia\",\n  \"chrono\",\n@@ -1942,7 +2015,7 @@ dependencies = [\n  \"log\",\n  \"memchr\",\n  \"open\",\n- \"pulldown-cmark 0.5.3\",\n+ \"pulldown-cmark 0.6.1\",\n  \"regex\",\n  \"serde\",\n  \"serde_derive\",\n@@ -1955,35 +2028,40 @@ dependencies = [\n \n [[package]]\n name = \"mdbook-linkcheck\"\n-version = \"0.3.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"77d1f0ba4d1e6b86fa18e8853d026d7d76a97eb7eb5eb052ed80901e43b7fc10\"\n+checksum = \"c0a04db564ca37c47771f8455c825dc941ea851ff0deffcf55a04c512406b409\"\n dependencies = [\n- \"env_logger 0.6.2\",\n+ \"codespan\",\n+ \"codespan-reporting\",\n+ \"dunce\",\n+ \"either\",\n+ \"env_logger 0.7.1\",\n  \"failure\",\n+ \"http\",\n  \"log\",\n  \"mdbook\",\n- \"memchr\",\n- \"pulldown-cmark 0.5.3\",\n+ \"percent-encoding 2.1.0\",\n+ \"pulldown-cmark 0.6.1\",\n  \"rayon\",\n  \"regex\",\n  \"reqwest\",\n  \"semver\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n- \"structopt 0.2.18\",\n- \"url 1.7.2\",\n+ \"structopt\",\n ]\n \n [[package]]\n name = \"measureme\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cd21b0e6e1af976b269ce062038fe5e1b9ca2f817ab7a3af09ec4210aebf0d30\"\n+checksum = \"c420bbc064623934620b5ab2dc0cf96451b34163329e82f95e7fa1b7b99a6ac8\"\n dependencies = [\n  \"byteorder\",\n  \"memmap\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n ]\n \n@@ -1995,12 +2073,12 @@ checksum = \"2efc7bc57c883d4a4d6e3246905283d8dae951bb3bd32f49d6ef297f546e1c39\"\n \n [[package]]\n name = \"memmap\"\n-version = \"0.6.2\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n+checksum = \"6585fd95e7bb50d6cc31e20d4cf9afb4e2ba16c5846fc76793f11218da9c475b\"\n dependencies = [\n  \"libc\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2024,19 +2102,17 @@ version = \"0.3.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3e27ca21f40a310bd06d9031785f4801710d566c184a6e15bad4f1d9b65f9425\"\n dependencies = [\n- \"unicase 2.5.1\",\n+ \"unicase\",\n ]\n \n [[package]]\n name = \"mime_guess\"\n-version = \"2.0.0-alpha.6\"\n+version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"30de2e4613efcba1ec63d8133f344076952090c122992a903359be5a4f99c3ed\"\n+checksum = \"1a0ed03949aef72dbdf3116a383d7b38b4768e6f960528cd6a6044aa9ed68599\"\n dependencies = [\n  \"mime\",\n- \"phf\",\n- \"phf_codegen\",\n- \"unicase 1.4.2\",\n+ \"unicase\",\n ]\n \n [[package]]\n@@ -2048,37 +2124,15 @@ dependencies = [\n  \"macro-utils\",\n ]\n \n-[[package]]\n-name = \"miniz-sys\"\n-version = \"0.1.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0300eafb20369952951699b68243ab4334f4b10a88f411c221d444b36c40e649\"\n-dependencies = [\n- \"cc\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.2.0\"\n+version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ad30a47319c16cde58d0314f5d98202a80c9083b5f61178457403dfb14e509c\"\n+checksum = \"6f3f74f726ae935c3f514300cc6773a0c9492abc5e972d42ba0c0ebb88757625\"\n dependencies = [\n  \"adler32\",\n ]\n \n-[[package]]\n-name = \"miniz_oxide_c_api\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28edaef377517fd9fe3e085c37d892ce7acd1fbeab9239c5a36eec352d8a8b7e\"\n-dependencies = [\n- \"cc\",\n- \"crc\",\n- \"libc\",\n- \"miniz_oxide\",\n-]\n-\n [[package]]\n name = \"mio\"\n version = \"0.6.16\"\n@@ -2107,7 +2161,7 @@ dependencies = [\n  \"log\",\n  \"mio\",\n  \"miow 0.3.3\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2140,7 +2194,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"396aa0f2003d7df8395cb93e09871561ccc3e785f0acb369170e8cc74ddf9226\"\n dependencies = [\n  \"socket2\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2160,6 +2214,7 @@ dependencies = [\n  \"rand 0.7.0\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n+ \"serde\",\n  \"shell-escape\",\n  \"vergen\",\n ]\n@@ -2190,7 +2245,7 @@ checksum = \"42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2222,9 +2277,9 @@ checksum = \"0b3a5d7cc97d6d30d8b9bc8fa19bf45349ffe46241e8816f50f62f6d6aaabee1\"\n \n [[package]]\n name = \"num_cpus\"\n-version = \"1.8.0\"\n+version = \"1.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c51a3322e4bca9d212ad9a158a02abc6934d005490c054a2778df73a70aa0a30\"\n+checksum = \"bcef43580c035376c0705c42792c294b66974abbfd2789b511784023f71f3273\"\n dependencies = [\n  \"libc\",\n ]\n@@ -2247,14 +2302,14 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"998c59e83d9474c01127a96e023b7a04bb061dd286bf8bb939d31dc8d31a7448\"\n dependencies = [\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.16\"\n+version = \"0.10.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec7bd7ca4cce6dbdc77e7c1230682740d307d1218a87fb0349a571272be749f9\"\n+checksum = \"2f372b2b53ce10fb823a337aaa674e3a7d072b957c6264d0f4ff0bd86e657449\"\n dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n@@ -2281,15 +2336,15 @@ dependencies = [\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.43\"\n+version = \"0.9.52\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"33c86834957dd5b915623e94f2f4ab2c70dd8f6b70679824155d5ae21dbd495d\"\n+checksum = \"c977d08e1312e2f7e4b86f9ebaa0ed3b19d1daff75fae88bbb88108afbd801fc\"\n dependencies = [\n+ \"autocfg\",\n  \"cc\",\n  \"libc\",\n  \"openssl-src\",\n  \"pkg-config\",\n- \"rustc_version\",\n  \"vcpkg\",\n ]\n \n@@ -2359,7 +2414,7 @@ dependencies = [\n  \"tokio\",\n  \"tokio-named-pipes\",\n  \"tokio-uds\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2393,7 +2448,7 @@ dependencies = [\n  \"rand 0.6.1\",\n  \"rustc_version\",\n  \"smallvec 0.6.10\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2408,7 +2463,7 @@ dependencies = [\n  \"redox_syscall\",\n  \"rustc_version\",\n  \"smallvec 0.6.10\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2419,9 +2474,9 @@ checksum = \"31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831\"\n \n [[package]]\n name = \"percent-encoding\"\n-version = \"2.0.0\"\n+version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ba4f28a6faf4ffea762ba8f4baef48c61a6db348647c73095034041fc79dd954\"\n+checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n \n [[package]]\n name = \"pest\"\n@@ -2512,7 +2567,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"234f71a15de2288bcb7e3b6515828d22af7ec8598ee6d24c3b526fa0a80b67a0\"\n dependencies = [\n  \"siphasher\",\n- \"unicase 1.4.2\",\n ]\n \n [[package]]\n@@ -2619,28 +2673,40 @@ dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"publicsuffix\"\n+version = \"1.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9bf259a81de2b2eb9850ec990ec78e6a25319715584fd7652b9b26f96fcb1510\"\n+dependencies = [\n+ \"error-chain\",\n+ \"idna 0.2.0\",\n+ \"lazy_static 1.3.0\",\n+ \"regex\",\n+ \"url 2.1.0\",\n+]\n+\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"77043da1282374688ee212dc44b3f37ff929431de9c9adc3053bd3cee5630357\"\n dependencies = [\n  \"bitflags\",\n- \"getopts\",\n  \"memchr\",\n- \"unicase 2.5.1\",\n+ \"unicase\",\n ]\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.6.0\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"85b0ad0d4c1702965ee6bb5b4ff5e71f83850b497d497e9444302987bf9e26a4\"\n+checksum = \"1c205cc82214f3594e2d50686730314f817c67ffa80fe800cf0db78c3c2b9d9e\"\n dependencies = [\n  \"bitflags\",\n  \"getopts\",\n  \"memchr\",\n- \"unicase 2.5.1\",\n+ \"unicase\",\n ]\n \n [[package]]\n@@ -2712,7 +2778,7 @@ dependencies = [\n  \"rand_pcg\",\n  \"rand_xorshift 0.1.0\",\n  \"rustc_version\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2724,7 +2790,7 @@ dependencies = [\n  \"getrandom\",\n  \"libc\",\n  \"rand_chacha 0.2.1\",\n- \"rand_core 0.5.0\",\n+ \"rand_core 0.5.1\",\n  \"rand_hc 0.2.0\",\n ]\n \n@@ -2745,7 +2811,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03a2a90da8c7523f554344f921aa97283eadf6ac484a6d2a7d0212fa7f8d6853\"\n dependencies = [\n  \"c2-chacha\",\n- \"rand_core 0.5.0\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2762,9 +2828,9 @@ checksum = \"d0e7a549d590831370895ab7ba4ea0c1b6b011d106b5ff2da6eee112615e6dc0\"\n \n [[package]]\n name = \"rand_core\"\n-version = \"0.5.0\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"615e683324e75af5d43d8f7a39ffe3ee4a9dc42c5c701167a71dc59c3a493aca\"\n+checksum = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n dependencies = [\n  \"getrandom\",\n ]\n@@ -2784,7 +2850,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\"\n dependencies = [\n- \"rand_core 0.5.0\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2807,7 +2873,7 @@ dependencies = [\n  \"libc\",\n  \"rand_core 0.4.0\",\n  \"rdrand\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -2835,7 +2901,16 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"77d416b86801d23dde1aa643023b775c3a462efc0ed96443add11546cdf1dca8\"\n dependencies = [\n- \"rand_core 0.5.0\",\n+ \"rand_core 0.5.1\",\n+]\n+\n+[[package]]\n+name = \"rand_xoshiro\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a9fcdd2e881d02f1d9390ae47ad8e5696a9e4be7b547a1da2afbc61973217004\"\n+dependencies = [\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2934,45 +3009,43 @@ version = \"0.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e\"\n dependencies = [\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"reqwest\"\n-version = \"0.9.11\"\n+version = \"0.9.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e542d9f077c126af32536b6aacc75bb7325400eab8cd0743543be5d91660780d\"\n+checksum = \"2c2064233e442ce85c77231ebd67d9eca395207dec2127fe0bbedde4bd29a650\"\n dependencies = [\n  \"base64\",\n  \"bytes\",\n+ \"cookie\",\n+ \"cookie_store\",\n  \"encoding_rs\",\n+ \"flate2\",\n  \"futures\",\n  \"http\",\n  \"hyper\",\n  \"hyper-tls\",\n- \"libflate\",\n  \"log\",\n  \"mime\",\n  \"mime_guess\",\n  \"native-tls\",\n  \"serde\",\n  \"serde_json\",\n  \"serde_urlencoded\",\n+ \"time\",\n  \"tokio\",\n  \"tokio-executor\",\n  \"tokio-io\",\n  \"tokio-threadpool\",\n  \"tokio-timer\",\n  \"url 1.7.2\",\n  \"uuid\",\n+ \"winreg\",\n ]\n \n-[[package]]\n-name = \"rle-decode-fast\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cabe4fa914dec5870285fa7f71f602645da47c486e68486d2b4ceb4a343e90ac\"\n-\n [[package]]\n name = \"rls\"\n version = \"1.40.0\"\n@@ -3100,6 +3173,7 @@ name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap\",\n+ \"codespan-reporting\",\n  \"failure\",\n  \"mdbook\",\n  \"mdbook-linkcheck\",\n@@ -3114,7 +3188,6 @@ dependencies = [\n  \"backtrace\",\n  \"bitflags\",\n  \"byteorder\",\n- \"cc\",\n  \"chalk-engine\",\n  \"fmt_macros\",\n  \"graphviz\",\n@@ -3128,10 +3201,13 @@ dependencies = [\n  \"rustc-rayon-core 0.3.0\",\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_fs_util\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_session\",\n  \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n@@ -3396,7 +3472,7 @@ dependencies = [\n  \"smallvec 0.6.10\",\n  \"syn 0.15.35\",\n  \"url 2.1.0\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3440,10 +3516,12 @@ dependencies = [\n  \"rustc_apfloat\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_fs_util\",\n  \"rustc_incremental\",\n  \"rustc_index\",\n+ \"rustc_session\",\n  \"rustc_target\",\n  \"serialize\",\n  \"syntax\",\n@@ -3470,6 +3548,7 @@ dependencies = [\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n  \"ena\",\n@@ -3478,6 +3557,7 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n+ \"measureme\",\n  \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n  \"rustc-rayon 0.3.0\",\n@@ -3499,12 +3579,14 @@ dependencies = [\n  \"rustc\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n- \"rustc_plugin\",\n+ \"rustc_parse\",\n  \"rustc_plugin_impl\",\n  \"rustc_resolve\",\n  \"rustc_save_analysis\",\n@@ -3514,6 +3596,10 @@ dependencies = [\n  \"syntax_pos\",\n ]\n \n+[[package]]\n+name = \"rustc_error_codes\"\n+version = \"0.0.0\"\n+\n [[package]]\n name = \"rustc_errors\"\n version = \"0.0.0\"\n@@ -3529,6 +3615,15 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n+[[package]]\n+name = \"rustc_feature\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"lazy_static 1.3.0\",\n+ \"rustc_data_structures\",\n+ \"syntax_pos\",\n+]\n+\n [[package]]\n name = \"rustc_fs_util\"\n version = \"0.0.0\"\n@@ -3543,6 +3638,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n+ \"rustc_session\",\n  \"serialize\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3572,6 +3668,7 @@ dependencies = [\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n+ \"rustc_parse\",\n  \"rustc_passes\",\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n@@ -3602,7 +3699,10 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n+ \"rustc_feature\",\n  \"rustc_index\",\n+ \"rustc_session\",\n  \"rustc_target\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3647,8 +3747,10 @@ dependencies = [\n  \"memmap\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_index\",\n+ \"rustc_parse\",\n  \"rustc_target\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n@@ -3665,15 +3767,18 @@ dependencies = [\n  \"arena\",\n  \"either\",\n  \"graphviz\",\n+ \"itertools 0.8.0\",\n  \"log\",\n  \"log_settings\",\n  \"polonius-engine\",\n  \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_target\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n@@ -3693,34 +3798,46 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc_passes\"\n+name = \"rustc_parse\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags\",\n  \"log\",\n- \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n- \"rustc_index\",\n- \"rustc_target\",\n+ \"rustc_feature\",\n+ \"rustc_lexer\",\n+ \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_pos\",\n ]\n \n [[package]]\n-name = \"rustc_plugin\"\n+name = \"rustc_passes\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc_plugin_impl\",\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_index\",\n+ \"rustc_parse\",\n+ \"rustc_target\",\n+ \"syntax\",\n+ \"syntax_pos\",\n ]\n \n [[package]]\n name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc\",\n+ \"rustc_error_codes\",\n  \"rustc_metadata\",\n  \"syntax\",\n- \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -3731,6 +3848,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_typeck\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3745,7 +3863,9 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_metadata\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n@@ -3763,11 +3883,28 @@ dependencies = [\n  \"rustc\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n+ \"rustc_parse\",\n  \"serde_json\",\n  \"syntax\",\n  \"syntax_pos\",\n ]\n \n+[[package]]\n+name = \"rustc_session\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"num_cpus\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_fs_util\",\n+ \"rustc_index\",\n+ \"rustc_target\",\n+ \"serialize\",\n+ \"syntax_pos\",\n+]\n+\n [[package]]\n name = \"rustc_target\"\n version = \"0.0.0\"\n@@ -3776,6 +3913,7 @@ dependencies = [\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"serialize\",\n  \"syntax_pos\",\n ]\n@@ -3798,6 +3936,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_macros\",\n  \"rustc_target\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n@@ -3823,6 +3962,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_target\",\n@@ -3908,7 +4048,7 @@ dependencies = [\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n  \"serde_json\",\n- \"structopt 0.3.1\",\n+ \"structopt\",\n  \"term 0.6.0\",\n  \"toml\",\n  \"unicode-segmentation\",\n@@ -3938,7 +4078,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0e1a231dc10abf6749cfa5d7767f25888d484201accbd919b66ab5413c502d56\"\n dependencies = [\n  \"lazy_static 1.3.0\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3971,8 +4111,8 @@ version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"eee63d0f4a9ec776eeb30e220f0bc1e092c3ad744b2a379e3993070364d3adc2\"\n dependencies = [\n- \"core-foundation\",\n- \"core-foundation-sys\",\n+ \"core-foundation 0.6.3\",\n+ \"core-foundation-sys 0.6.2\",\n  \"libc\",\n  \"security-framework-sys\",\n ]\n@@ -3983,7 +4123,7 @@ version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9636f8989cbf61385ae4824b98c1aaa54c994d7d8b41f11c601ed799f0549a56\"\n dependencies = [\n- \"core-foundation-sys\",\n+ \"core-foundation-sys 0.6.2\",\n ]\n \n [[package]]\n@@ -4115,10 +4255,11 @@ checksum = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n \n [[package]]\n name = \"sized-chunks\"\n-version = \"0.3.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2a2eb3fe454976eefb479f78f9b394d34d661b647c6326a3a6e66f68bb12c26\"\n+checksum = \"62db64dd92b3b54314b1e216c274634ca2b3fe8da8b3873be670cb1ac4dad30f\"\n dependencies = [\n+ \"bitmaps\",\n  \"typenum\",\n ]\n \n@@ -4149,7 +4290,7 @@ dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -4181,7 +4322,7 @@ dependencies = [\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n- \"wasi\",\n+ \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n \n [[package]]\n@@ -4242,36 +4383,14 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \n-[[package]]\n-name = \"structopt\"\n-version = \"0.2.18\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"16c2cdbf9cc375f15d1b4141bc48aeef444806655cd0e904207edc8d68d86ed7\"\n-dependencies = [\n- \"clap\",\n- \"structopt-derive 0.2.18\",\n-]\n-\n [[package]]\n name = \"structopt\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2ac9d6e93dd792b217bf89cda5c14566e3043960c6f9da890c2ba5d09d07804c\"\n dependencies = [\n  \"clap\",\n- \"structopt-derive 0.3.1\",\n-]\n-\n-[[package]]\n-name = \"structopt-derive\"\n-version = \"0.2.18\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53010261a84b37689f9ed7d395165029f9cc7abb9f56bbfe86bee2597ed25107\"\n-dependencies = [\n- \"heck\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"structopt-derive\",\n ]\n \n [[package]]\n@@ -4359,9 +4478,13 @@ dependencies = [\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n+ \"rustc_session\",\n  \"scoped-tls\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n@@ -4372,14 +4495,12 @@ dependencies = [\n name = \"syntax_expand\"\n version = \"0.0.0\"\n dependencies = [\n- \"bitflags\",\n- \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n- \"rustc_index\",\n+ \"rustc_feature\",\n  \"rustc_lexer\",\n- \"scoped-tls\",\n+ \"rustc_parse\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n@@ -4393,7 +4514,10 @@ dependencies = [\n  \"fmt_macros\",\n  \"log\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_parse\",\n  \"rustc_target\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n@@ -4407,6 +4531,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n  \"cfg-if\",\n+ \"log\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_macros\",\n@@ -4415,12 +4540,6 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n-[[package]]\n-name = \"take_mut\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f764005d11ee5f36500a149ace24e00e3da98b0158b3e2d53a7495660d3f4d60\"\n-\n [[package]]\n name = \"tar\"\n version = \"0.4.20\"\n@@ -4444,7 +4563,7 @@ dependencies = [\n  \"rand 0.7.0\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -4474,7 +4593,7 @@ checksum = \"0dd90505d5006a4422d3520b30c781d480b3f36768c2fa2187c3e950bc110464\"\n dependencies = [\n  \"byteorder\",\n  \"dirs\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -4522,6 +4641,17 @@ dependencies = [\n  \"term 0.0.0\",\n ]\n \n+[[package]]\n+name = \"tester\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee72ec31009a42b53de9a6b7d8f462b493ab3b1e4767bda1fcdbb52127f13b6c\"\n+dependencies = [\n+ \"getopts\",\n+ \"libc\",\n+ \"term 0.6.0\",\n+]\n+\n [[package]]\n name = \"textwrap\"\n version = \"0.11.0\"\n@@ -4553,13 +4683,13 @@ dependencies = [\n \n [[package]]\n name = \"time\"\n-version = \"0.1.40\"\n+version = \"0.1.42\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d825be0eb33fda1a7e68012d51e9c7f451dc1a69391e7fdc197060bb8c56667b\"\n+checksum = \"db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f\"\n dependencies = [\n  \"libc\",\n  \"redox_syscall\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -4675,7 +4805,7 @@ dependencies = [\n  \"tokio-io\",\n  \"tokio-reactor\",\n  \"tokio-signal\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -4719,7 +4849,7 @@ dependencies = [\n  \"tokio-executor\",\n  \"tokio-io\",\n  \"tokio-reactor\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -4838,6 +4968,15 @@ version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e604eb7b43c06650e854be16a2a03155743d3752dd1c943f6829e26b7a36e382\"\n \n+[[package]]\n+name = \"try_from\"\n+version = \"0.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"283d3b89e1368717881a9d51dad843cc435380d8109c9e47d38780a324698d8b\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n [[package]]\n name = \"typenum\"\n version = \"1.10.0\"\n@@ -4856,22 +4995,13 @@ version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n \n-[[package]]\n-name = \"unicase\"\n-version = \"1.4.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7f4765f83163b74f957c797ad9253caf97f103fb064d3999aea9568d09fc8a33\"\n-dependencies = [\n- \"version_check\",\n-]\n-\n [[package]]\n name = \"unicase\"\n version = \"2.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2e2e6bd1e59e56598518beb94fd6db628ded570326f0a98c679a304bd9f00150\"\n dependencies = [\n- \"version_check\",\n+ \"version_check 0.1.5\",\n ]\n \n [[package]]\n@@ -4891,9 +5021,9 @@ checksum = \"6a0180bc61fc5a987082bfa111f4cc95c4caff7f9799f3e46df09163a937aa25\"\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.2.1\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aa6024fc12ddfd1c6dbc14a80fa2324d4568849869b779f6bd37e5e4c03344d1\"\n+checksum = \"e83e153d1053cbb5a118eeff7fd5be06ed99153f00dbcd8ae310c5fb2b22edc0\"\n \n [[package]]\n name = \"unicode-width\"\n@@ -4962,7 +5092,7 @@ checksum = \"75b414f6c464c879d7f9babf951f23bc3743fb7313c081b2e6ca719067ea9d61\"\n dependencies = [\n  \"idna 0.2.0\",\n  \"matches\",\n- \"percent-encoding 2.0.0\",\n+ \"percent-encoding 2.1.0\",\n  \"serde\",\n ]\n \n@@ -5022,6 +5152,12 @@ version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n \n+[[package]]\n+name = \"version_check\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"078775d0255232fb988e6fccf26ddc9d1ac274299aaedcedce21c6f72cc533ce\"\n+\n [[package]]\n name = \"vte\"\n version = \"0.3.3\"\n@@ -5038,7 +5174,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9d9d7ed3431229a144296213105a390676cc49c9b6a72bd19f3176c98e129fa1\"\n dependencies = [\n  \"same-file\",\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n  \"winapi-util\",\n ]\n \n@@ -5058,6 +5194,12 @@ name = \"wasi\"\n version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.9.0+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -5072,9 +5214,9 @@ checksum = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \n [[package]]\n name = \"winapi\"\n-version = \"0.3.6\"\n+version = \"0.3.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"92c1eb33641e276cfa214a0522acad57be5c56b10cb348b3c5117db75f3ac4b0\"\n+checksum = \"8093091eeb260906a183e6ae1abdba2ef5ef2257a21801128899c3fc699229c6\"\n dependencies = [\n  \"winapi-i686-pc-windows-gnu\",\n  \"winapi-x86_64-pc-windows-gnu\",\n@@ -5098,7 +5240,7 @@ version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7168bab6e1daee33b4557efd0e95d5ca70a03706d39fa5f3fe7a236f584b03c9\"\n dependencies = [\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -5113,10 +5255,19 @@ version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"561ed901ae465d6185fa7864d63fbd5720d0ef718366c9a4dc83cf6170d7e9ba\"\n dependencies = [\n- \"winapi 0.3.6\",\n+ \"winapi 0.3.8\",\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"winreg\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b2986deb581c4fe11b621998a5e53361efe6b48a151178d0cd9eeffa4dc6acc9\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"ws2_32-sys\"\n version = \"0.2.1\""}, {"sha": "53139877c2f92951a501dba60b494dafcd9aee02", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -7804,7 +7804,7 @@ Version 0.7 (2013-07-03)\n       * extra: Implementation of fixed output size variations of SHA-2.\n \n    * Tooling\n-      * `unused_variable`  lint mode for unused variables (default: warn).\n+      * `unused_variables` lint mode for unused variables (default: warn).\n       * `unused_unsafe` lint mode for detecting unnecessary `unsafe` blocks\n         (default: warn).\n       * `unused_mut` lint mode for identifying unused `mut` qualifiers"}, {"sha": "6937fb922de486e1231e947c58031fddc5db076d", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -25,7 +25,7 @@ fn main() {\n     let mut dylib_path = bootstrap::util::dylib_path();\n     dylib_path.insert(0, PathBuf::from(libdir.clone()));\n \n-    //FIXME(misdreavus): once stdsimd uses cfg(rustdoc) instead of cfg(dox), remove the `--cfg dox`\n+    //FIXME(misdreavus): once stdsimd uses cfg(doc) instead of cfg(dox), remove the `--cfg dox`\n     //arguments here\n     let mut cmd = Command::new(rustdoc);\n     cmd.args(&args)"}, {"sha": "bb169414886de2da6e0c37c50928b47fe0e604ef", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -102,10 +102,10 @@ def verify(path, sha_path, verbose):\n     return verified\n \n \n-def unpack(tarball, dst, verbose=False, match=None):\n+def unpack(tarball, tarball_suffix, dst, verbose=False, match=None):\n     \"\"\"Unpack the given tarball file\"\"\"\n     print(\"extracting\", tarball)\n-    fname = os.path.basename(tarball).replace(\".tar.gz\", \"\")\n+    fname = os.path.basename(tarball).replace(tarball_suffix, \"\")\n     with contextlib.closing(tarfile.open(tarball)) as tar:\n         for member in tar.getnames():\n             if \"/\" not in member:\n@@ -331,6 +331,7 @@ def __init__(self):\n         self.use_vendored_sources = ''\n         self.verbose = False\n \n+\n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n \n@@ -344,18 +345,30 @@ def download_stage0(self):\n         rustc_channel = self.rustc_channel\n         cargo_channel = self.cargo_channel\n \n+        def support_xz():\n+            try:\n+                with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n+                    temp_path = temp_file.name\n+                with tarfile.open(temp_path, \"w:xz\") as tar:\n+                    pass\n+                return True\n+            except tarfile.CompressionError:\n+                return False\n+\n         if self.rustc().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.rustc()) or\n                  self.program_out_of_date(self.rustc_stamp())):\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n-            filename = \"rust-std-{}-{}.tar.gz\".format(\n-                rustc_channel, self.build)\n+            tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n+            filename = \"rust-std-{}-{}{}\".format(\n+                rustc_channel, self.build, tarball_suffix)\n             pattern = \"rust-std-{}\".format(self.build)\n-            self._download_stage0_helper(filename, pattern)\n+            self._download_stage0_helper(filename, pattern, tarball_suffix)\n \n-            filename = \"rustc-{}-{}.tar.gz\".format(rustc_channel, self.build)\n-            self._download_stage0_helper(filename, \"rustc\")\n+            filename = \"rustc-{}-{}{}\".format(rustc_channel, self.build,\n+                                              tarball_suffix)\n+            self._download_stage0_helper(filename, \"rustc\", tarball_suffix)\n             self.fix_executable(\"{}/bin/rustc\".format(self.bin_root()))\n             self.fix_executable(\"{}/bin/rustdoc\".format(self.bin_root()))\n             with output(self.rustc_stamp()) as rust_stamp:\n@@ -365,20 +378,22 @@ def download_stage0(self):\n             # libraries/binaries that are included in rust-std with\n             # the system MinGW ones.\n             if \"pc-windows-gnu\" in self.build:\n-                filename = \"rust-mingw-{}-{}.tar.gz\".format(\n-                    rustc_channel, self.build)\n-                self._download_stage0_helper(filename, \"rust-mingw\")\n+                filename = \"rust-mingw-{}-{}{}\".format(\n+                    rustc_channel, self.build, tarball_suffix)\n+                self._download_stage0_helper(filename, \"rust-mingw\", tarball_suffix)\n \n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or\n                  self.program_out_of_date(self.cargo_stamp())):\n-            filename = \"cargo-{}-{}.tar.gz\".format(cargo_channel, self.build)\n-            self._download_stage0_helper(filename, \"cargo\")\n+            tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n+            filename = \"cargo-{}-{}{}\".format(cargo_channel, self.build,\n+                                              tarball_suffix)\n+            self._download_stage0_helper(filename, \"cargo\", tarball_suffix)\n             self.fix_executable(\"{}/bin/cargo\".format(self.bin_root()))\n             with output(self.cargo_stamp()) as cargo_stamp:\n                 cargo_stamp.write(self.date)\n \n-    def _download_stage0_helper(self, filename, pattern):\n+    def _download_stage0_helper(self, filename, pattern, tarball_suffix):\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n         rustc_cache = os.path.join(cache_dst, self.date)\n         if not os.path.exists(rustc_cache):\n@@ -388,7 +403,7 @@ def _download_stage0_helper(self, filename, pattern):\n         tarball = os.path.join(rustc_cache, filename)\n         if not os.path.exists(tarball):\n             get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n-        unpack(tarball, self.bin_root(), match=pattern, verbose=self.verbose)\n+        unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n \n     @staticmethod\n     def fix_executable(fname):\n@@ -628,7 +643,9 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n-        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2 \"\n+        # preserve existing RUSTFLAGS\n+        env.setdefault(\"RUSTFLAGS\", \"\")\n+        env[\"RUSTFLAGS\"] += \" -Cdebuginfo=2\"\n \n         build_section = \"target.{}\".format(self.build_triple())\n         target_features = []\n@@ -637,13 +654,13 @@ def build_bootstrap(self):\n         elif self.get_toml(\"crt-static\", build_section) == \"false\":\n             target_features += [\"-crt-static\"]\n         if target_features:\n-            env[\"RUSTFLAGS\"] += \"-C target-feature=\" + (\",\".join(target_features)) + \" \"\n+            env[\"RUSTFLAGS\"] += \" -C target-feature=\" + (\",\".join(target_features))\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n-            env[\"RUSTFLAGS\"] += \"-C linker=\" + target_linker + \" \"\n-        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes \"\n+            env[\"RUSTFLAGS\"] += \" -C linker=\" + target_linker\n+        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes\"\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n-            env[\"RUSTFLAGS\"] += \"-Dwarnings \"\n+            env[\"RUSTFLAGS\"] += \" -Dwarnings\"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]"}, {"sha": "99b8ddf7db1f0c704785a9fef9502150ac2e343d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -886,7 +886,18 @@ impl<'a> Builder<'a> {\n         // things still build right, please do!\n         match mode {\n             Mode::Std => metadata.push_str(\"std\"),\n-            _ => {},\n+            // When we're building rustc tools, they're built with a search path\n+            // that contains things built during the rustc build. For example,\n+            // bitflags is built during the rustc build, and is a dependency of\n+            // rustdoc as well. We're building rustdoc in a different target\n+            // directory, though, which means that Cargo will rebuild the\n+            // dependency. When we go on to build rustdoc, we'll look for\n+            // bitflags, and find two different copies: one built during the\n+            // rustc step and one that we just built. This isn't always a\n+            // problem, somehow -- not really clear why -- but we know that this\n+            // fixes things.\n+            Mode::ToolRustc => metadata.push_str(\"tool-rustc\"),\n+            _ => {}\n         }\n         cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n \n@@ -1231,7 +1242,8 @@ impl<'a> Builder<'a> {\n             cargo.arg(\"--frozen\");\n         }\n \n-        cargo.env(\"RUSTC_INSTALL_BINDIR\", &self.config.bindir);\n+        // Try to use a sysroot-relative bindir, in case it was configured absolutely.\n+        cargo.env(\"RUSTC_INSTALL_BINDIR\", self.config.bindir_relative());\n \n         self.ci_env.force_coloring_in_ci(&mut cargo);\n "}, {"sha": "b17ee098ff62ad2863ec60a01eb21e972539c800", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.40.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.41.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "f686dfe71b93733fdb4aff7296914dc76483f51a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -113,7 +113,7 @@ impl Step for Std {\n     }\n }\n \n-/// Copies third pary objects needed by various targets.\n+/// Copies third party objects needed by various targets.\n fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>)\n     -> Vec<PathBuf>\n {"}, {"sha": "0c03b95c7b251035eb5f7ce4936877b65f481f14", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -647,6 +647,20 @@ impl Config {\n         config\n     }\n \n+    /// Try to find the relative path of `bindir`, otherwise return it in full.\n+    pub fn bindir_relative(&self) -> &Path {\n+        let bindir = &self.bindir;\n+        if bindir.is_absolute() {\n+            // Try to make it relative to the prefix.\n+            if let Some(prefix) = &self.prefix {\n+                if let Ok(stripped) = bindir.strip_prefix(prefix) {\n+                    return stripped;\n+                }\n+            }\n+        }\n+        bindir\n+    }\n+\n     /// Try to find the relative path of `libdir`.\n     pub fn libdir_relative(&self) -> Option<&Path> {\n         let libdir = self.libdir.as_ref()?;"}, {"sha": "d0c9e0dbaf458eaca013794d91645b636114d3d9", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -616,6 +616,7 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"natvis/intrinsic.natvis\");\n             cp_debugger_script(\"natvis/liballoc.natvis\");\n             cp_debugger_script(\"natvis/libcore.natvis\");\n+            cp_debugger_script(\"natvis/libstd.natvis\");\n         } else {\n             cp_debugger_script(\"debugger_pretty_printers_common.py\");\n "}, {"sha": "7b49cc0a9298cc059b56e2c2670e214bf78c02a5", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -448,12 +448,12 @@ Arguments:\n \n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n-            stage: matches.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n+            stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),\n             dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_strs(\"keep-stage\")\n-                .into_iter().map(|j| j.parse().unwrap())\n+                .into_iter().map(|j| j.parse().expect(\"`keep-stage` should be a number\"))\n                 .collect(),\n             host: split(&matches.opt_strs(\"host\"))\n                 .into_iter()\n@@ -464,7 +464,7 @@ Arguments:\n                 .map(|x| INTERNER.intern_string(x))\n                 .collect::<Vec<_>>(),\n             config: cfg_file,\n-            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n+            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().expect(\"`jobs` should be a number\")),\n             cmd,\n             incremental: matches.opt_present(\"incremental\"),\n             exclude: split(&matches.opt_strs(\"exclude\"))"}, {"sha": "f8734ebdf4254213b743dfa125fbc701250addba", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -260,7 +260,7 @@ install!((self, builder, _config),\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n-            compiler: self.compiler,\n+            compiler: builder.compiler(builder.top_stage, self.target),\n         });\n         install_rustc(builder, self.compiler.stage, self.target);\n     };"}, {"sha": "7ea2bb126a641ca8fa9ceb38b327ccdd3327bcbb", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -810,6 +810,7 @@ impl Build {\n                   !target.contains(\"emscripten\") &&\n                   !target.contains(\"wasm32\") &&\n                   !target.contains(\"nvptx\") &&\n+                  !target.contains(\"fortanix\") &&\n                   !target.contains(\"fuchsia\") {\n             Some(self.cc(target))\n         } else {"}, {"sha": "be13b9aa2eb49cde97ca8cc50c24bf5be67f9415", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -294,11 +294,11 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     let mut parts = version.split('.').take(2)\n         .filter_map(|s| s.parse::<u32>().ok());\n     if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n-        if major >= 6 {\n+        if major >= 7 {\n             return\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=6.0\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=7.0\\n\\n\", version)\n }\n \n fn configure_cmake(builder: &Builder<'_>,"}, {"sha": "a858ed42badfdc7868a064655a732dfaf1c82d2a", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -570,7 +570,12 @@ impl Step for Clippy {\n             let host_libs = builder\n                 .stage_out(compiler, Mode::ToolRustc)\n                 .join(builder.cargo_dir());\n+            let target_libs = builder\n+                .stage_out(compiler, Mode::ToolRustc)\n+                .join(&self.host)\n+                .join(builder.cargo_dir());\n             cargo.env(\"HOST_LIBS\", host_libs);\n+            cargo.env(\"TARGET_LIBS\", target_libs);\n             // clippy tests need to find the driver\n             cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n "}, {"sha": "6f8a630874570324e26b750ec700d05122fca01b", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -262,13 +262,17 @@ pub enum CiEnv {\n     None,\n     /// The Azure Pipelines environment, for Linux (including Docker), Windows, and macOS builds.\n     AzurePipelines,\n+    /// The GitHub Actions environment, for Linux (including Docker), Windows and macOS builds.\n+    GitHubActions,\n }\n \n impl CiEnv {\n     /// Obtains the current CI environment.\n     pub fn current() -> CiEnv {\n         if env::var(\"TF_BUILD\").ok().map_or(false, |e| &*e == \"True\") {\n             CiEnv::AzurePipelines\n+        } else if env::var(\"GITHUB_ACTIONS\").ok().map_or(false, |e| &*e == \"true\") {\n+            CiEnv::GitHubActions\n         } else {\n             CiEnv::None\n         }"}, {"sha": "70d6bad297dce4c890ee98a1c7b611a4dd831d32", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 42, "deletions": 169, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -18,137 +18,47 @@ jobs:\n   - template: steps/run.yml\n   strategy:\n     matrix:\n-      x86_64-gnu-llvm-6.0:\n-        IMAGE: x86_64-gnu-llvm-6.0\n+      x86_64-gnu-llvm-7:\n         RUST_BACKTRACE: 1\n-\n-      dist-x86_64-linux:\n-        IMAGE: dist-x86_64-linux\n-        DEPLOY: 1\n-\n-      # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n-      # turned on, they're deployed to a different location primarily for\n-      # additional testing.\n+      dist-x86_64-linux: {}\n       dist-x86_64-linux-alt:\n         IMAGE: dist-x86_64-linux\n-        DEPLOY_ALT: 1\n-\n-      # Linux builders, remaining docker images\n-      arm-android:\n-        IMAGE: arm-android\n-\n-      armhf-gnu:\n-        IMAGE: armhf-gnu\n-\n-      dist-various-1:\n-        IMAGE: dist-various-1\n-        DEPLOY: 1\n-\n-      dist-various-2:\n-        IMAGE: dist-various-2\n-        DEPLOY: 1\n-\n-      dist-aarch64-linux:\n-        IMAGE: dist-aarch64-linux\n-        DEPLOY: 1\n-\n-      dist-android:\n-        IMAGE: dist-android\n-        DEPLOY: 1\n-\n-      dist-arm-linux:\n-        IMAGE: dist-arm-linux\n-        DEPLOY: 1\n-\n-      dist-armhf-linux:\n-        IMAGE: dist-armhf-linux\n-        DEPLOY: 1\n-\n-      dist-armv7-linux:\n-        IMAGE: dist-armv7-linux\n-        DEPLOY: 1\n-\n-      dist-i586-gnu-i586-i686-musl:\n-        IMAGE: dist-i586-gnu-i586-i686-musl\n-        DEPLOY: 1\n-\n-      dist-i686-freebsd:\n-        IMAGE: dist-i686-freebsd\n-        DEPLOY: 1\n-\n-      dist-i686-linux:\n-        IMAGE: dist-i686-linux\n-        DEPLOY: 1\n-\n-      dist-mips-linux:\n-        IMAGE: dist-mips-linux\n-        DEPLOY: 1\n-\n-      dist-mips64-linux:\n-        IMAGE: dist-mips64-linux\n-        DEPLOY: 1\n-\n-      dist-mips64el-linux:\n-        IMAGE: dist-mips64el-linux\n-        DEPLOY: 1\n-\n-      dist-mipsel-linux:\n-        IMAGE: dist-mipsel-linux\n-        DEPLOY: 1\n-\n-      dist-powerpc-linux:\n-        IMAGE: dist-powerpc-linux\n-        DEPLOY: 1\n-\n-      dist-powerpc64-linux:\n-        IMAGE: dist-powerpc64-linux\n-        DEPLOY: 1\n-\n-      dist-powerpc64le-linux:\n-        IMAGE: dist-powerpc64le-linux\n-        DEPLOY: 1\n-\n-      dist-s390x-linux:\n-        IMAGE: dist-s390x-linux\n-        DEPLOY: 1\n-\n-      dist-x86_64-freebsd:\n-        IMAGE: dist-x86_64-freebsd\n-        DEPLOY: 1\n-\n-      dist-x86_64-musl:\n-        IMAGE: dist-x86_64-musl\n-        DEPLOY: 1\n-\n-      dist-x86_64-netbsd:\n-        IMAGE: dist-x86_64-netbsd\n-        DEPLOY: 1\n-\n-      i686-gnu:\n-        IMAGE: i686-gnu\n-      i686-gnu-nopt:\n-        IMAGE: i686-gnu-nopt\n-      test-various:\n-        IMAGE: test-various\n-      wasm32:\n-        IMAGE: wasm32\n-      x86_64-gnu:\n-        IMAGE: x86_64-gnu\n-      x86_64-gnu-full-bootstrap:\n-        IMAGE: x86_64-gnu-full-bootstrap\n-      x86_64-gnu-aux:\n-        IMAGE: x86_64-gnu-aux\n+      arm-android: {}\n+      armhf-gnu: {}\n+      dist-various-1: {}\n+      dist-various-2: {}\n+      dist-aarch64-linux: {}\n+      dist-android: {}\n+      dist-arm-linux: {}\n+      dist-armhf-linux: {}\n+      dist-armv7-linux: {}\n+      dist-i586-gnu-i586-i686-musl: {}\n+      dist-i686-freebsd: {}\n+      dist-i686-linux: {}\n+      dist-mips-linux: {}\n+      dist-mips64-linux: {}\n+      dist-mips64el-linux: {}\n+      dist-mipsel-linux: {}\n+      dist-powerpc-linux: {}\n+      dist-powerpc64-linux: {}\n+      dist-powerpc64le-linux: {}\n+      dist-s390x-linux: {}\n+      dist-x86_64-freebsd: {}\n+      dist-x86_64-musl: {}\n+      dist-x86_64-netbsd: {}\n+      i686-gnu: {}\n+      i686-gnu-nopt: {}\n+      test-various: {}\n+      wasm32: {}\n+      x86_64-gnu: {}\n+      x86_64-gnu-full-bootstrap: {}\n+      x86_64-gnu-aux: {}\n       x86_64-gnu-tools:\n-        IMAGE: x86_64-gnu-tools\n         DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n-      x86_64-gnu-debug:\n-        IMAGE: x86_64-gnu-debug\n-      x86_64-gnu-nopt:\n-        IMAGE: x86_64-gnu-nopt\n-      x86_64-gnu-distcheck:\n-        IMAGE: x86_64-gnu-distcheck\n-      mingw-check:\n-        IMAGE: mingw-check\n+      x86_64-gnu-debug: {}\n+      x86_64-gnu-nopt: {}\n+      x86_64-gnu-distcheck: {}\n+      mingw-check: {}\n \n - job: macOS\n   timeoutInMinutes: 600\n@@ -176,7 +86,6 @@ jobs:\n       dist-x86_64-apple:\n         SCRIPT: ./x.py dist\n         RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n-        DEPLOY: 1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n         MACOSX_DEPLOYMENT_TARGET: 10.7\n         NO_LLVM_ASSERTIONS: 1\n@@ -186,7 +95,6 @@ jobs:\n       dist-x86_64-apple-alt:\n         SCRIPT: ./x.py dist\n         RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n-        DEPLOY_ALT: 1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n         MACOSX_DEPLOYMENT_TARGET: 10.7\n         NO_LLVM_ASSERTIONS: 1\n@@ -204,7 +112,6 @@ jobs:\n       dist-i686-apple:\n         SCRIPT: ./x.py dist\n         RUST_CONFIGURE_ARGS: --build=i686-apple-darwin --enable-full-tools --enable-profiler --set rust.jemalloc\n-        DEPLOY: 1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n         MACOSX_DEPLOYMENT_TARGET: 10.7\n         NO_LLVM_ASSERTIONS: 1\n@@ -223,37 +130,31 @@ jobs:\n     matrix:\n       # 32/64 bit MSVC tests\n       x86_64-msvc-1:\n-        MSYS_BITS: 64\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n         SCRIPT: make ci-subset-1\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       x86_64-msvc-2:\n-        MSYS_BITS: 64\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n         SCRIPT: make ci-subset-2\n       i686-msvc-1:\n-        MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n         SCRIPT: make ci-subset-1\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       i686-msvc-2:\n-        MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n         SCRIPT: make ci-subset-2\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       # MSVC aux tests\n       x86_64-msvc-aux:\n-        MSYS_BITS: 64\n         RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n       x86_64-msvc-cargo:\n-        MSYS_BITS: 64\n         SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n         VCVARS_BAT: vcvars64.bat\n@@ -262,10 +163,8 @@ jobs:\n         NO_LLVM_ASSERTIONS: 1\n       # MSVC tools tests\n       x86_64-msvc-tools:\n-        MSYS_BITS: 64\n         SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\n-        DEPLOY_TOOLSTATES_JSON: toolstates-windows.json\n \n       # 32/64-bit MinGW builds.\n       #\n@@ -281,83 +180,57 @@ jobs:\n       # came from the mingw-w64 SourceForge download site. Unfortunately\n       # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n       i686-mingw-1:\n-        MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n         SCRIPT: make ci-mingw-subset-1\n-        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n-        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-        MINGW_DIR: mingw32\n+        CUSTOM_MINGW: 1\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       i686-mingw-2:\n-        MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n         SCRIPT: make ci-mingw-subset-2\n-        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n-        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-        MINGW_DIR: mingw32\n+        CUSTOM_MINGW: 1\n       x86_64-mingw-1:\n-        MSYS_BITS: 64\n         SCRIPT: make ci-mingw-subset-1\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n-        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n-        MINGW_DIR: mingw64\n+        CUSTOM_MINGW: 1\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       x86_64-mingw-2:\n-        MSYS_BITS: 64\n         SCRIPT: make ci-mingw-subset-2\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n-        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n-        MINGW_DIR: mingw64\n+        CUSTOM_MINGW: 1\n \n       # 32/64 bit MSVC and GNU deployment\n       dist-x86_64-msvc:\n-        MSYS_BITS: 64\n         RUST_CONFIGURE_ARGS: >-\n           --build=x86_64-pc-windows-msvc\n           --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n           --enable-full-tools\n           --enable-profiler\n         SCRIPT: python x.py dist\n         DIST_REQUIRE_ALL_TOOLS: 1\n-        DEPLOY: 1\n       dist-i686-msvc:\n-        MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: >-\n           --build=i686-pc-windows-msvc\n           --target=i586-pc-windows-msvc\n           --enable-full-tools\n           --enable-profiler\n         SCRIPT: python x.py dist\n         DIST_REQUIRE_ALL_TOOLS: 1\n-        DEPLOY: 1\n       dist-i686-mingw:\n-        MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n         SCRIPT: python x.py dist\n-        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n-        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-        MINGW_DIR: mingw32\n+        CUSTOM_MINGW: 1\n         DIST_REQUIRE_ALL_TOOLS: 1\n-        DEPLOY: 1\n       dist-x86_64-mingw:\n-        MSYS_BITS: 64\n         SCRIPT: python x.py dist\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n-        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n-        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n-        MINGW_DIR: mingw64\n+        CUSTOM_MINGW: 1\n         DIST_REQUIRE_ALL_TOOLS: 1\n-        DEPLOY: 1\n \n       # \"alternate\" deployment, see .travis.yml for more info\n       dist-x86_64-msvc-alt:\n-        MSYS_BITS: 64\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n         SCRIPT: python x.py dist\n-        DEPLOY_ALT: 1"}, {"sha": "1f0be53677de22b37b3230de04daed686be09fec", "filename": "src/ci/azure-pipelines/pr.yml", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fazure-pipelines%2Fpr.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fazure-pipelines%2Fpr.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fpr.yml?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -18,10 +18,7 @@ jobs:\n     - template: steps/run.yml\n   strategy:\n     matrix:\n-      x86_64-gnu-llvm-6.0:\n-        IMAGE: x86_64-gnu-llvm-6.0\n-      mingw-check:\n-        IMAGE: mingw-check\n+      x86_64-gnu-llvm-7: {}\n+      mingw-check: {}\n       x86_64-gnu-tools:\n-        IMAGE: x86_64-gnu-tools\n         CI_ONLY_WHEN_SUBMODULES_CHANGED: 1"}, {"sha": "f536388b25b966286b216ade8ee12cfbac2bc7ef", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 13, "deletions": 76, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -8,6 +8,13 @@\n \n steps:\n \n+# Configure our CI_JOB_NAME variable which log analyzers can use for the main\n+# step to see what's going on.\n+- bash: |\n+    builder=$(echo $AGENT_JOBNAME | cut -d ' ' -f 2)\n+    echo \"##vso[task.setvariable variable=CI_JOB_NAME]$builder\"\n+  displayName: Configure Job Name\n+\n # Disable automatic line ending conversion, which is enabled by default on\n # Azure's Windows image. Having the conversion enabled caused regressions both\n # in our test suite (it broke miri tests) and in the ecosystem, since we\n@@ -21,51 +28,39 @@ steps:\n - checkout: self\n   fetchDepth: 2\n \n+- bash: src/ci/scripts/setup-environment.sh\n+  displayName: Setup environment\n+\n - bash: src/ci/scripts/should-skip-this.sh\n   displayName: Decide whether to run this job\n \n-# Spawn a background process to collect CPU usage statistics which we'll upload\n-# at the end of the build. See the comments in the script here for more\n-# information.\n-- bash: python src/ci/cpu-usage-over-time.py &> cpu-usage.csv &\n-  displayName: \"Collect CPU-usage statistics in the background\"\n+- bash: src/ci/scripts/collect-cpu-stats.sh\n+  displayName: Collect CPU-usage statistics in the background\n \n - bash: src/ci/scripts/dump-environment.sh\n   displayName: Show the current environment\n \n - bash: src/ci/scripts/install-sccache.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Install sccache\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/install-clang.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Install clang\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/switch-xcode.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Switch to Xcode 9.3\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/install-wix.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Install wix\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/install-innosetup.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Install InnoSetup\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/windows-symlink-build-dir.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Ensure the build happens on C:\\ instead of D:\\\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n@@ -74,35 +69,22 @@ steps:\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/install-msys2.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n-    SYSTEM_WORKFOLDER: $(System.Workfolder)\n   displayName: Install msys2\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/install-msys2-packages.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n-    SYSTEM_WORKFOLDER: $(System.Workfolder)\n   displayName: Install msys2 packages\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/install-mingw.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n-    SYSTEM_WORKFOLDER: $(System.Workfolder)\n   displayName: Install MinGW\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/install-ninja.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Install ninja\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/enable-docker-ipv6.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Enable IPv6 on Docker\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n@@ -116,67 +98,22 @@ steps:\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/checkout-submodules.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Checkout submodules\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/verify-line-endings.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   displayName: Verify line endings\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n # Ensure the `aws` CLI is installed so we can deploy later on, cache docker\n # images, etc.\n - bash: src/ci/scripts/install-awscli.sh\n-  env:\n-    AGENT_OS: $(Agent.OS)\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n   displayName: Install awscli\n \n-# Configure our CI_JOB_NAME variable which log analyzers can use for the main\n-# step to see what's going on.\n-- bash: |\n-    builder=$(echo $AGENT_JOBNAME | cut -d ' ' -f 2)\n-    echo \"##vso[task.setvariable variable=CI_JOB_NAME]$builder\"\n-  displayName: Configure Job Name\n-\n-# As a quick smoke check on the otherwise very fast mingw-check linux builder\n-# check our own internal scripts.\n-- bash: |\n-    set -e\n-    git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n-    cd rust-toolstate\n-    python2.7 \"$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n-    # Only check maintainers if this build is supposed to publish toolstate.\n-    # Builds that are not supposed to publish don't have the access token.\n-    if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n-      TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python2.7 \"${BUILD_SOURCESDIRECTORY}/src/tools/publish_toolstate.py\"\n-    fi\n-    cd ..\n-    rm -rf rust-toolstate\n-  env:\n-    TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)\n-  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['IMAGE'], 'mingw-check'))\n-  displayName: Verify the publish_toolstate script works\n-\n-- bash: |\n-    set -e\n-    # Remove any preexisting rustup installation since it can interfere\n-    # with the cargotest step and its auto-detection of things like Clippy in\n-    # the environment\n-    rustup self uninstall -y || true\n-    if [ \"$IMAGE\" = \"\" ]; then\n-      src/ci/run.sh\n-    else\n-      src/ci/docker/run.sh $IMAGE\n-    fi\n-  #timeoutInMinutes: 180\n+- bash: src/ci/scripts/run-build-from-ci.sh\n   timeoutInMinutes: 600\n   env:\n-    CI: true\n-    SRC: .\n     AWS_ACCESS_KEY_ID: $(SCCACHE_AWS_ACCESS_KEY_ID)\n     AWS_SECRET_ACCESS_KEY: $(SCCACHE_AWS_SECRET_ACCESS_KEY)\n     TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)"}, {"sha": "b6177b2cc9b25c826fb9e47092a4fe4ab1e25853", "filename": "src/ci/azure-pipelines/try.yml", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -14,13 +14,9 @@ jobs:\n   - template: steps/run.yml\n   strategy:\n     matrix:\n-      dist-x86_64-linux:\n-        IMAGE: dist-x86_64-linux\n-        DEPLOY: 1\n-\n+      dist-x86_64-linux: {}\n       dist-x86_64-linux-alt:\n         IMAGE: dist-x86_64-linux\n-        DEPLOY_ALT: 1\n \n # The macOS and Windows builds here are currently disabled due to them not being\n # overly necessary on `try` builds. We also don't actually have anything that\n@@ -72,7 +68,6 @@ jobs:\n #         DEPLOY: 1\n #\n #       dist-x86_64-msvc-alt:\n-#         MSYS_BITS: 64\n #         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n #         SCRIPT: python x.py dist\n #         DEPLOY_ALT: 1"}, {"sha": "872f2c3467d202729241b31dabe0936a2f37dcd9", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -16,6 +16,13 @@ for example:\n \n Images will output artifacts in an `obj` dir at the root of a repository.\n \n+**NOTE**: Re-using the same `obj` dir with different docker images with\n+the same target triple (e.g. `dist-x86_64-linux` and `dist-various-1`)\n+may result in strange linker errors, due shared library versions differing between platforms.\n+\n+If you encounter any issues when using multiple Docker images, try deleting your `obj` directory\n+before running your command.\n+\n ## Filesystem layout\n \n - Each directory, excluding `scripts` and `disabled`, corresponds to a docker image"}, {"sha": "5373612279bca109a2b276a102f74ebf000373e5", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -72,7 +72,7 @@ RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n \n # TODO: What is this?!\n # Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n-RUN curl -O https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/vexpress-v2p-ca15-tc1.dtb\n+RUN curl -O https://ci-mirrors.rust-lang.org/rustc/vexpress-v2p-ca15-tc1.dtb\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "fb067a79a5c85c93691cdf5244394982d465289f", "filename": "src/ci/docker/dist-armv7-linux/crosstool-ng.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,7 +1,7 @@\n set -ex\n \n # Mirrored from https://github.com/crosstool-ng/crosstool-ng/archive/crosstool-ng-1.24.0.tar.gz\n-url=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/crosstool-ng-1.24.0.tar.gz\"\n+url=\"https://ci-mirrors.rust-lang.org/rustc/crosstool-ng-1.24.0.tar.gz\"\n curl -Lf $url | tar xzf -\n cd crosstool-ng-crosstool-ng-1.24.0\n ./bootstrap"}, {"sha": "6bbf0928783117f58e96e3a7df472b80be27ccd0", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -135,6 +135,9 @@ ENV TARGETS=$TARGETS,armv7r-none-eabi\n ENV TARGETS=$TARGETS,armv7r-none-eabihf\n ENV TARGETS=$TARGETS,thumbv7neon-unknown-linux-gnueabihf\n \n+# riscv targets currently do not need a C compiler, as compiler_builtins\n+# doesn't currently have it enabled, and the riscv gcc compiler is not\n+# installed.\n ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n     CC_mips64el_unknown_linux_muslabi64=mips64el-linux-gnuabi64-gcc \\\n@@ -143,7 +146,12 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n     AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n-    CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++\n+    CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++ \\\n+    CC_riscv32i_unknown_none_elf=false \\\n+    CC_riscv32imc_unknown_none_elf=false \\\n+    CC_riscv32imac_unknown_none_elf=false \\\n+    CC_riscv64imac_unknown_none_elf=false \\\n+    CC_riscv64gc_unknown_none_elf=false\n \n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\"}, {"sha": "9584258d23403b12fcfbb0249cec584535852c6e", "filename": "src/ci/docker/dist-various-1/install-mips-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mips-linux-musl\n # originally from\n # https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/\n # OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\n-URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n+URL=\"https://ci-mirrors.rust-lang.org/rustc\"\n FILE=\"OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mips-linux-musl --strip-components=2\n "}, {"sha": "50a8e554b1675f789f074c09e657260f242d2ca2", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mipsel-linux-musl\n # Note that this originally came from:\n # https://downloads.openwrt.org/snapshots/trunk/malta/generic/\n # OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n-URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n+URL=\"https://ci-mirrors.rust-lang.org/rustc\"\n FILE=\"OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mipsel-linux-musl --strip-components=2\n "}, {"sha": "925d5ca0223b1f8bd7b3cb136ebd23b546331fc4", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -5,14 +5,14 @@\n set -ex\n \n # Originally from https://releases.llvm.org/9.0.0/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/clang%2Bllvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n+curl https://ci-mirrors.rust-lang.org/rustc/clang%2Bllvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n   tar xJf -\n export PATH=`pwd`/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n \n git clone https://github.com/CraneStation/wasi-libc\n \n cd wasi-libc\n-git reset --hard a94d2d04e7722b323573da2bd04e909a5763d35b\n+git reset --hard f645f498dfbbbc00a7a97874d33082d3605c3f21\n make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n \n cd .."}, {"sha": "0c7eb5fdac9bea0425b92a8c4a8f31375546b3eb", "filename": "src/ci/docker/dist-x86_64-linux/build-curl.sh", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -5,6 +5,9 @@ source shared.sh\n \n VERSION=7.66.0\n \n+# This needs to be downloaded directly from S3, it can't go through the CDN.\n+# That's because the CDN is backed by CloudFront, which requires SNI and TLSv1\n+# (without paying an absurd amount of money).\n curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/curl-$VERSION.tar.xz \\\n   | xz --decompress \\\n   | tar xf -"}, {"sha": "d8f6bdb51b8d5bad24e0995de30e5babde6d0fa9", "filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,6 +4,10 @@ set -ex\n source shared.sh\n \n VERSION=1.0.2k\n+\n+# This needs to be downloaded directly from S3, it can't go through the CDN.\n+# That's because the CDN is backed by CloudFront, which requires SNI and TLSv1\n+# (without paying an absurd amount of money).\n URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/openssl-$VERSION.tar.gz\n \n curl $URL | tar xzf -"}, {"sha": "f8697c698b9fb67aac77c9145a960e9f55437b8e", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -25,7 +25,7 @@ cd netbsd\n \n mkdir -p /x-tools/x86_64-unknown-netbsd/sysroot\n \n-URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n+URL=https://ci-mirrors.rust-lang.org/rustc\n \n # Originally from ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-$BSD/source/sets/*.tgz\n curl $URL/2018-03-01-netbsd-src.tgz | tar xzf -"}, {"sha": "b2d96aed2a9e80370010739bd24f7da54eb66481", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -19,7 +19,10 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+COPY mingw-check/validate-toolstate.sh /scripts/\n+\n ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n            python2.7 ../x.py build --stage 0 src/tools/build-manifest && \\\n-           python2.7 ../x.py test --stage 0 src/tools/compiletest\n+           python2.7 ../x.py test --stage 0 src/tools/compiletest && \\\n+           /scripts/validate-toolstate.sh"}, {"sha": "2ebf1d6d5ae7f1882a0d3864bd0b7b9244681b34", "filename": "src/ci/docker/mingw-check/validate-toolstate.sh", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,19 @@\n+#!/bin/bash\n+# A quick smoke test to make sure publish_tooolstate.py works.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+rm -rf rust-toolstate\n+git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n+cd rust-toolstate\n+python2.7 \"../../src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \\\n+    \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n+# Only check maintainers if this build is supposed to publish toolstate.\n+# Builds that are not supposed to publish don't have the access token.\n+if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n+  TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python2.7 \\\n+      \"../../src/tools/publish_toolstate.py\"\n+fi\n+cd ..\n+rm -rf rust-toolstate"}, {"sha": "f29f9f3bf1c453dcb098ca16f65b37d640b474cc", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -172,6 +172,8 @@ docker \\\n   --env CI \\\n   --env TF_BUILD \\\n   --env BUILD_SOURCEBRANCHNAME \\\n+  --env GITHUB_ACTIONS \\\n+  --env GITHUB_REF \\\n   --env TOOLSTATE_REPO_ACCESS_TOKEN \\\n   --env TOOLSTATE_REPO \\\n   --env TOOLSTATE_PUBLISH \\"}, {"sha": "5670e10be23cf7b7e6042050020cbc774688f796", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -59,7 +59,7 @@ done\n \n # Originally downloaded from:\n # https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n-URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n+URL=https://ci-mirrors.rust-lang.org/rustc/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n curl \"$URL\" | tar xJf - -C \"$sysroot\" --wildcards \"${files_to_extract[@]}\"\n \n # Fix up absolute symlinks from the system image.  This can be removed"}, {"sha": "552afbfee7c175f6d69a5cf2daafe20a24738163", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,6 +1,6 @@\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-02-sccache-x86_64-unknown-linux-musl\n+  https://ci-mirrors.rust-lang.org/rustc/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "a1c9c13fc471a463879385bcc03ab5686ab9c740", "filename": "src/ci/docker/x86_64-gnu-llvm-7/Dockerfile", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:16.04\n+FROM ubuntu:18.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n@@ -11,7 +11,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  llvm-6.0-tools \\\n+  llvm-7-tools \\\n   libedit-dev \\\n   libssl-dev \\\n   pkg-config \\\n@@ -24,7 +24,7 @@ RUN sh /scripts/sccache.sh\n # using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-6.0 \\\n+      --llvm-root=/usr/lib/llvm-7 \\\n       --enable-llvm-link-shared\n ENV SCRIPT python2.7 ../x.py test src/tools/tidy && python2.7 ../x.py test\n ", "previous_filename": "src/ci/docker/x86_64-gnu-llvm-6.0/Dockerfile"}, {"sha": "38d1d2baf25075cc06fb2f296a8a12fa66e82c0c", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -23,9 +23,7 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n-branch_name=$(getCIBranch)\n-\n-if [ ! isCI ] || [ \"$branch_name\" = \"auto\" ] || [ \"$branch_name\" = \"try\" ]; then\n+if ! isCI || isCiBranch auto || isCiBranch beta; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n fi\n "}, {"sha": "08065431f981650e7b000281c288220e80f9d4c6", "filename": "src/ci/scripts/collect-cpu-stats.sh", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Fcollect-cpu-stats.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Fcollect-cpu-stats.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fcollect-cpu-stats.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,9 @@\n+#!/bin/bash\n+# Spawn a background process to collect CPU usage statistics which we'll upload\n+# at the end of the build. See the comments in the script here for more\n+# information.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+python src/ci/cpu-usage-over-time.py &> cpu-usage.csv &"}, {"sha": "f0179994e8e4cb5c44d2c0feea09793c487dd0fe", "filename": "src/ci/scripts/install-clang.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Finstall-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Finstall-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-clang.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -17,7 +17,7 @@ if isMacOS; then\n     # Configure `AR` specifically so rustbuild doesn't try to infer it as\n     # `clang-ar` by accident.\n     ciCommandSetEnv AR \"ar\"\n-elif isWindows && [[ -z ${MINGW_URL+x} ]]; then\n+elif isWindows && [[ ${CUSTOM_MINGW-0} -ne 1 ]]; then\n     # If we're compiling for MSVC then we, like most other distribution builders,\n     # switch to clang as the compiler. This'll allow us eventually to enable LTO\n     # amongst LLVM and rustc. Note that we only do this on MSVC as I don't think"}, {"sha": "98373df7fce50d92a0249cd506e795a02523416b", "filename": "src/ci/scripts/install-mingw.sh", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Finstall-mingw.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Finstall-mingw.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-mingw.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -27,19 +27,38 @@ IFS=$'\\n\\t'\n \n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n+MINGW_ARCHIVE_32=\"i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\"\n+MINGW_ARCHIVE_64=\"x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\"\n+\n if isWindows; then\n-    if [[ -z \"${MINGW_URL+x}\" ]]; then\n-        arch=i686\n-        if [ \"$MSYS_BITS\" = \"64\" ]; then\n-          arch=x86_64\n-        fi\n+    case \"${CI_JOB_NAME}\" in\n+        *i686*)\n+            bits=32\n+            arch=i686\n+            mingw_archive=\"${MINGW_ARCHIVE_32}\"\n+            ;;\n+        *x86_64*)\n+            bits=64\n+            arch=x86_64\n+            mingw_archive=\"${MINGW_ARCHIVE_64}\"\n+            ;;\n+        *)\n+            echo \"src/ci/scripts/install-mingw.sh can't detect the builder's architecture\"\n+            echo \"please tweak it to recognize the builder named '${CI_JOB_NAME}'\"\n+            exit 1\n+            ;;\n+    esac\n+\n+    if [[ \"${CUSTOM_MINGW-0}\" -ne 1 ]]; then\n         pacman -S --noconfirm --needed mingw-w64-$arch-toolchain mingw-w64-$arch-cmake \\\n             mingw-w64-$arch-gcc mingw-w64-$arch-python2\n-        ciCommandAddPath \"${SYSTEM_WORKFOLDER}/msys2/mingw${MSYS_BITS}/bin\"\n+        ciCommandAddPath \"$(ciCheckoutPath)/msys2/mingw${bits}/bin\"\n     else\n-        curl -o mingw.7z \"${MINGW_URL}/${MINGW_ARCHIVE}\"\n+        mingw_dir=\"mingw${bits}\"\n+\n+        curl -o mingw.7z \"${MIRRORS_BASE}/${mingw_archive}\"\n         7z x -y mingw.7z > /dev/null\n-        curl -o \"${MINGW_DIR}/bin/gdborig.exe\" \"${MINGW_URL}/2017-04-20-${MSYS_BITS}bit-gdborig.exe\"\n-        ciCommandAddPath \"$(pwd)/${MINGW_DIR}/bin\"\n+        curl -o \"${mingw_dir}/bin/gdborig.exe\" \"${MIRRORS_BASE}/2017-04-20-${bits}bit-gdborig.exe\"\n+        ciCommandAddPath \"$(pwd)/${mingw_dir}/bin\"\n     fi\n fi"}, {"sha": "c9fafc7fe6b41b5bc624a4b2818878753b100930", "filename": "src/ci/scripts/install-msys2.sh", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Finstall-msys2.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Finstall-msys2.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -12,8 +12,8 @@ IFS=$'\\n\\t'\n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n if isWindows; then\n-    choco install msys2 --params=\"/InstallDir:${SYSTEM_WORKFOLDER}/msys2 /NoPath\" -y --no-progress\n-    mkdir -p \"${SYSTEM_WORKFOLDER}/msys2/home/${USERNAME}\"\n+    choco install msys2 --params=\"/InstallDir:$(ciCheckoutPath)/msys2 /NoPath\" -y --no-progress\n+    mkdir -p \"$(ciCheckoutPath)/msys2/home/${USERNAME}\"\n \n-    ciCommandAddPath \"${SYSTEM_WORKFOLDER}/msys2/usr/bin\"\n+    ciCommandAddPath \"$(ciCheckoutPath)/msys2/usr/bin\"\n fi"}, {"sha": "c02117f459de0463adb7f619398a3140dc3a05ea", "filename": "src/ci/scripts/run-build-from-ci.sh", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Frun-build-from-ci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Frun-build-from-ci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Frun-build-from-ci.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,21 @@\n+#!/bin/bash\n+# Start the CI build. You shouldn't run this locally: call either src/ci/run.sh\n+# or src/ci/docker/run.sh instead.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+export CI=\"true\"\n+export SRC=.\n+\n+# Remove any preexisting rustup installation since it can interfere\n+# with the cargotest step and its auto-detection of things like Clippy in\n+# the environment\n+rustup self uninstall -y || true\n+if [ -z \"${IMAGE+x}\" ]; then\n+    src/ci/run.sh\n+else\n+    src/ci/docker/run.sh \"${IMAGE}\"\n+fi"}, {"sha": "e126a06edab7373a12df556e6f81f2f82d409239", "filename": "src/ci/scripts/setup-environment.sh", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Fsetup-environment.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fscripts%2Fsetup-environment.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fsetup-environment.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,31 @@\n+#!/bin/bash\n+# This script guesses some environment variables based on the builder name and\n+# the current platform, to reduce the amount of variables defined in the CI\n+# configuration.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+# Builders starting with `dist-` are dist builders, but if they also end with\n+# `-alt` they are alternate dist builders.\n+if [[ \"${CI_JOB_NAME}\" = dist-* ]]; then\n+    if [[ \"${CI_JOB_NAME}\" = *-alt ]]; then\n+        echo \"alternate dist builder detected, setting DEPLOY_ALT=1\"\n+        ciCommandSetEnv DEPLOY_ALT 1\n+    else\n+        echo \"normal dist builder detected, setting DEPLOY=1\"\n+        ciCommandSetEnv DEPLOY 1\n+    fi\n+fi\n+\n+# All the Linux builds happen inside Docker.\n+if isLinux; then\n+    if [[ -z \"${IMAGE+x}\" ]]; then\n+        echo \"linux builder detected, using docker to run the build\"\n+        ciCommandSetEnv IMAGE \"${CI_JOB_NAME}\"\n+    else\n+        echo \"a custom docker image is already set\"\n+    fi\n+fi"}, {"sha": "98120f5dff95dafb63b62f2a8ac64221b88b73bb", "filename": "src/ci/shared.sh", "status": "modified", "additions": 63, "deletions": 10, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,7 +4,7 @@\n # `source shared.sh`, hence the invalid shebang and not being\n # marked as an executable file in git.\n \n-export MIRRORS_BASE=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n+export MIRRORS_BASE=\"https://ci-mirrors.rust-lang.org/rustc\"\n \n # See http://unix.stackexchange.com/questions/82598\n # Duplicated in docker/dist-various-2/shared.sh\n@@ -27,27 +27,66 @@ function retry {\n }\n \n function isCI {\n-  [ \"$CI\" = \"true\" ] || [ \"$TF_BUILD\" = \"True\" ]\n+    [[ \"${CI-false}\" = \"true\" ]] || isAzurePipelines || isGitHubActions\n+}\n+\n+function isAzurePipelines {\n+    [[ \"${TF_BUILD-False}\" = \"True\" ]]\n+}\n+\n+function isGitHubActions {\n+    [[ \"${GITHUB_ACTIONS-false}\" = \"true\" ]]\n }\n \n function isMacOS {\n-  [ \"$AGENT_OS\" = \"Darwin\" ]\n+    [[ \"${OSTYPE}\" = \"darwin\"* ]]\n }\n \n function isWindows {\n-  [ \"$AGENT_OS\" = \"Windows_NT\" ]\n+    [[ \"${OSTYPE}\" = \"cygwin\" ]] || [[ \"${OSTYPE}\" = \"msys\" ]]\n }\n \n function isLinux {\n-  [ \"$AGENT_OS\" = \"Linux\" ]\n+    [[ \"${OSTYPE}\" = \"linux-gnu\" ]]\n }\n \n-function getCIBranch {\n-  echo \"$BUILD_SOURCEBRANCHNAME\"\n+function isCiBranch {\n+    if [[ $# -ne 1 ]]; then\n+        echo \"usage: $0 <branch-name>\"\n+        exit 1\n+    fi\n+    name=\"$1\"\n+\n+    if isAzurePipelines; then\n+        [[ \"${BUILD_SOURCEBRANCHNAME}\" = \"${name}\" ]]\n+    elif isGitHubActions; then\n+        [[ \"${GITHUB_REF}\" = \"refs/heads/${name}\" ]]\n+    else\n+        echo \"isCiBranch only works inside CI!\"\n+        exit 1\n+    fi\n }\n \n function ciCommit {\n-  echo \"${BUILD_SOURCEVERSION}\"\n+    if isAzurePipelines; then\n+        echo \"${BUILD_SOURCEVERSION}\"\n+    elif isGitHubActions; then\n+        echo \"${GITHUB_SHA}\"\n+    else\n+        echo \"ciCommit only works inside CI!\"\n+        exit 1\n+    fi\n+}\n+\n+function ciCheckoutPath {\n+    if isAzurePipelines; then\n+        echo \"${SYSTEM_WORKFOLDER}\"\n+    elif isGitHubActions; then\n+        echo \"${GITHUB_WORKSPACE}\"\n+    else\n+        echo \"ciCheckoutPath only works inside CI!\"\n+        exit 1\n+    fi\n }\n \n function ciCommandAddPath {\n@@ -57,7 +96,14 @@ function ciCommandAddPath {\n     fi\n     path=\"$1\"\n \n-    echo \"##vso[task.prependpath]${path}\"\n+    if isAzurePipelines; then\n+        echo \"##vso[task.prependpath]${path}\"\n+    elif isGitHubActions; then\n+        echo \"::add-path::${value}\"\n+    else\n+        echo \"ciCommandAddPath only works inside CI!\"\n+        exit 1\n+    fi\n }\n \n function ciCommandSetEnv {\n@@ -68,5 +114,12 @@ function ciCommandSetEnv {\n     name=\"$1\"\n     value=\"$2\"\n \n-    echo \"##vso[task.setvariable variable=${name}]${value}\"\n+    if isAzurePipelines; then\n+        echo \"##vso[task.setvariable variable=${name}]${value}\"\n+    elif isGitHubActions; then\n+        echo \"::set-env name=${name}::${value}\"\n+    else\n+        echo \"ciCommandSetEnv only works inside CI!\"\n+        exit 1\n+    fi\n }"}, {"sha": "81ebaa2a3f88d4d106516c489682e64cacba4f60", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1 +1 @@\n-Subproject commit 28fa3d15b0bc67ea5e79eeff2198e4277fc61baf\n+Subproject commit 81ebaa2a3f88d4d106516c489682e64cacba4f60"}, {"sha": "6601cab4666596494a569f94aa63b7b3230e9769", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1 +1 @@\n-Subproject commit e58bc4ca104e890ac56af846877c874c432a64b5\n+Subproject commit 6601cab4666596494a569f94aa63b7b3230e9769"}, {"sha": "041c46e692a2592853aeca132c8dfe8eb5a79a9e", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1 +1 @@\n-Subproject commit 5004ad30d69f93553ceef74439fea2159d1f769e\n+Subproject commit 041c46e692a2592853aeca132c8dfe8eb5a79a9e"}, {"sha": "9e843aeb4df083522c7277179bbaa25d0507731c", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1 +1 @@\n-Subproject commit 4b21b646669e0af49fae7cae301898dc4bfaa1f0\n+Subproject commit 9e843aeb4df083522c7277179bbaa25d0507731c"}, {"sha": "4835e025826729827a94fdeb7cb85fed288d08bb", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1 +1 @@\n-Subproject commit f3197ddf2abab9abdbc029def8164f4a748b0d91\n+Subproject commit 4835e025826729827a94fdeb7cb85fed288d08bb"}, {"sha": "934380b7cfceaaa4e1b9bb0de4a372f32725520b", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1 +1 @@\n-Subproject commit 941968db2fd9c85788a4f971c8e425d46b4cb734\n+Subproject commit 934380b7cfceaaa4e1b9bb0de4a372f32725520b"}, {"sha": "2944e865663139be49c16ad612c67568e4ed9699", "filename": "src/doc/rustc/src/lints/levels.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -35,7 +35,7 @@ talk about later in this section.\n ## warn\n \n The 'warn' lint level will produce a warning if you violate the lint. For example,\n-this code runs afoul of the `unused_variable` lint:\n+this code runs afoul of the `unused_variables` lint:\n \n ```rust\n pub fn foo() {"}, {"sha": "386f6008d06aad0b1b15741662ec43fad2529cf4", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -307,18 +307,6 @@ warning: path statement with no effect\n   |\n ```\n \n-## plugin-as-library\n-\n-This lint detects when compiler plugins are used as ordinary library in\n-non-plugin crate. Some example code that triggers this lint:\n-\n-```rust,ignore\n-#![feature(plugin)]\n-#![plugin(macro_crate_test)]\n-\n-extern crate macro_crate_test;\n-```\n-\n ## private-in-public\n \n This lint detects private items in public interfaces not caught by the old implementation. Some"}, {"sha": "f982863e67b94b4e060027372809b4e9624077cc", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,8 +1,11 @@\n # The Rustdoc Book\n \n - [What is rustdoc?](what-is-rustdoc.md)\n+- [How to write documentation](how-to-write-documentation.md)\n - [Command-line arguments](command-line-arguments.md)\n - [The `#[doc]` attribute](the-doc-attribute.md)\n - [Documentation tests](documentation-tests.md)\n+- [Lints](lints.md)\n - [Passes](passes.md)\n+- [Advanced Features](advanced-features.md)\n - [Unstable features](unstable-features.md)"}, {"sha": "47bef3cdde1877c2e669305d033072bb101308cb", "filename": "src/doc/rustdoc/src/advanced-features.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,34 @@\n+# Advanced Features\n+\n+The features listed on this page fall outside the rest of the main categories.\n+\n+## `#[cfg(doc)]`: Documenting platform-/feature-specific information\n+\n+For conditional compilation, Rustdoc treats your crate the same way the compiler does: Only things\n+from the host target are available (or from the given `--target` if present), and everything else is\n+\"filtered out\" from the crate. This can cause problems if your crate is providing different things\n+on different targets and you want your documentation to reflect all the available items you\n+provide.\n+\n+If you want to make sure an item is seen by Rustdoc regardless of what platform it's targeting,\n+you can apply `#[cfg(doc)]` to it. Rustdoc sets this whenever it's building documentation, so\n+anything that uses that flag will make it into documentation it generates. To apply this to an item\n+with other `#[cfg]` filters on it, you can write something like `#[cfg(any(windows, doc))]`.\n+This will preserve the item either when built normally on Windows, or when being documented\n+anywhere.\n+\n+Please note that this feature is not passed to doctests.\n+\n+Example:\n+\n+```rust\n+/// Token struct that can only be used on Windows.\n+#[cfg(any(windows, doc))]\n+pub struct WindowsToken;\n+/// Token struct that can only be used on Unix.\n+#[cfg(any(unix, doc))]\n+pub struct UnixToken;\n+```\n+\n+Here, the respective tokens can only be used by dependent crates on their respective platforms, but\n+they will both appear in documentation."}, {"sha": "2e32ce31ecae0eb0a9c76805eff79e1c73d2c7ea", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -355,7 +355,38 @@ $ rustdoc src/lib.rs --edition 2018\n $ rustdoc --test src/lib.rs --edition 2018\n ```\n \n-This flag allows rustdoc to treat your rust code as the given edition. It will compile doctests with\n+This flag allows `rustdoc` to treat your rust code as the given edition. It will compile doctests with\n the given edition as well. As with `rustc`, the default edition that `rustdoc` will use is `2015`\n (the first edition).\n \n+## `--theme`: add a theme to the documentation output\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs --theme /path/to/your/custom-theme.css\n+```\n+\n+`rustdoc`'s default output includes two themes: `light` (the default) and\n+`dark`. This flag allows you to add custom themes to the output. Giving a CSS\n+file to this flag adds it to your documentation as an additional theme choice.\n+The theme's name is determined by its filename; a theme file named\n+`custom-theme.css` will add a theme named `custom-theme` to the documentation.\n+\n+## `--check-theme`: verify custom themes against the default theme\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc --check-theme /path/to/your/custom-theme.css\n+```\n+\n+While `rustdoc`'s HTML output is more-or-less consistent between versions, there\n+is no guarantee that a theme file will have the same effect. The `--theme` flag\n+will still allow you to add the theme to your documentation, but to ensure that\n+your theme works as expected, you can use this flag to verify that it implements\n+the same CSS rules as the official `light` theme.\n+\n+`--check-theme` is a separate mode in `rustdoc`. When `rustdoc` sees the\n+`--check-theme` flag, it discards all other flags and only performs the CSS rule\n+comparison operation."}, {"sha": "96fa4344b04b726525805979156a6a12ba25219a", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,7 +1,7 @@\n # Documentation tests\n \n `rustdoc` supports executing your documentation examples as tests. This makes sure\n-that your tests are up to date and working.\n+that examples within your documentation are up to date and working.\n \n The basic idea is this:\n "}, {"sha": "dd3aa5d4b6988ebf5ae47bd4b681f5bf19cc7c72", "filename": "src/doc/rustdoc/src/how-to-write-documentation.md", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,82 @@\n+# How to write documentation\n+\n+This chapter covers not only how to write documentation but specifically\n+how to write **good** documentation.  Something to keep in mind when\n+writing documentation is that your audience is not just yourself but others\n+who simply don't have the context you do.  It is important to be as clear\n+as you can, and as complete as possible.  As a rule of thumb: the more\n+documentation you write for your crate the better.  If an item is public\n+then it should be documented.\n+\n+## Basic structure\n+\n+It is recommended that each item's documentation follows this basic structure:\n+\n+```text\n+[short sentence explaining what it is]\n+\n+[more detailed explanation]\n+\n+[at least one code example that users can copy/paste to try it]\n+\n+[even more advanced explanations if necessary]\n+```\n+\n+This basic structure should be straightforward to follow when writing your\n+documentation and, while you might think that a code example is trivial,\n+the examples are really important because they can help your users to\n+understand what an item is, how it is used, and for what purpose it exists.\n+\n+Let's see an example coming from the [standard library] by taking a look at the\n+[`std::env::args()`][env::args] function:\n+\n+``````text\n+Returns the arguments which this program was started with (normally passed\n+via the command line).\n+\n+The first element is traditionally the path of the executable, but it can be\n+set to arbitrary text, and may not even exist. This means this property should\n+not be relied upon for security purposes.\n+\n+On Unix systems shell usually expands unquoted arguments with glob patterns\n+(such as `*` and `?`). On Windows this is not done, and such arguments are\n+passed as-is.\n+\n+# Panics\n+\n+The returned iterator will panic during iteration if any argument to the\n+process is not valid unicode. If this is not desired,\n+use the [`args_os`] function instead.\n+\n+# Examples\n+\n+```\n+use std::env;\n+\n+// Prints each argument on a separate line\n+for argument in env::args() {\n+    println!(\"{}\", argument);\n+}\n+```\n+\n+[`args_os`]: ./fn.args_os.html\n+``````\n+\n+As you can see, it follows the structure detailed above: it starts with a short\n+sentence explaining what the functions does, then it provides more information\n+and finally provides a code example.\n+\n+## Markdown\n+\n+`rustdoc` is using the [commonmark markdown specification]. You might be\n+interested into taking a look at their website to see what's possible to do.\n+\n+## Lints\n+\n+To be sure that you didn't miss any item without documentation or code examples,\n+you can take a look at the rustdoc lints [here][rustdoc-lints].\n+\n+[standard library]: https://doc.rust-lang.org/stable/std/index.html\n+[env::args]: https://doc.rust-lang.org/stable/std/env/fn.args.html\n+[commonmark markdown specification]: https://commonmark.org/\n+[rustdoc-lints]: lints.md"}, {"sha": "beb2556872df78278e0cc2b1e385fc707d9294e9", "filename": "src/doc/rustdoc/src/lints.md", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,119 @@\n+# Lints\n+\n+`rustdoc` provides lints to help you writing and testing your documentation. You\n+can use them like any other lints by doing this:\n+\n+```rust,ignore\n+#![allow(missing_docs)] // allowing the lint, no message\n+#![warn(missing_docs)] // warn if there is missing docs\n+#![deny(missing_docs)] // rustdoc will fail if there is missing docs\n+```\n+\n+Here is the list of the lints provided by `rustdoc`:\n+\n+## intra_doc_link_resolution_failure\n+\n+This lint **warns by default** and is **nightly-only**. This lint detects when\n+an intra-doc link fails to get resolved. For example:\n+\n+```rust\n+/// I want to link to [`Inexistent`] but it doesn't exist!\n+pub fn foo() {}\n+```\n+\n+You'll get a warning saying:\n+\n+```text\n+error: `[`Inexistent`]` cannot be resolved, ignoring it...\n+```\n+\n+## missing_docs\n+\n+This lint is **allowed by default**. It detects items missing documentation.\n+For example:\n+\n+```rust\n+#![warn(missing_docs)]\n+\n+pub fn undocumented() {}\n+# fn main() {}\n+```\n+\n+The `undocumented` function will then have the following warning:\n+\n+```text\n+warning: missing documentation for a function\n+  --> your-crate/lib.rs:3:1\n+   |\n+ 3 | pub fn undocumented() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+```\n+\n+## missing_doc_code_examples\n+\n+This lint is **allowed by default**. It detects when a documentation block\n+is missing a code example. For example:\n+\n+```rust\n+#![warn(missing_doc_code_examples)]\n+\n+/// There is no code example!\n+pub fn no_code_example() {}\n+# fn main() {}\n+```\n+\n+The `no_code_example` function will then have the following warning:\n+\n+```text\n+warning: Missing code example in this documentation\n+  --> your-crate/lib.rs:3:1\n+   |\n+LL | /// There is no code example!\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+```\n+\n+To fix the lint, you need to add a code example into the documentation block:\n+\n+```rust\n+/// There is no code example!\n+///\n+/// ```\n+/// println!(\"calling no_code_example...\");\n+/// no_code_example();\n+/// println!(\"we called no_code_example!\");\n+/// ```\n+pub fn no_code_example() {}\n+```\n+\n+## private_doc_tests\n+\n+This lint is **allowed by default**. It detects documentation tests when they\n+are on a private item. For example:\n+\n+```rust\n+#![warn(private_doc_tests)]\n+\n+mod foo {\n+    /// private doc test\n+    ///\n+    /// ```\n+    /// assert!(false);\n+    /// ```\n+    fn bar() {}\n+}\n+# fn main() {}\n+```\n+\n+Which will give:\n+\n+```text\n+warning: Documentation test in private item\n+  --> your-crate/lib.rs:4:1\n+   |\n+ 4 | /     /// private doc test\n+ 5 | |     ///\n+ 6 | |     /// ```\n+ 7 | |     /// assert!(false);\n+ 8 | |     /// ```\n+   | |___________^\n+```"}, {"sha": "a48526d39fd0a5fcaa0ccaca99ca909e6c4aa5bc", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -106,24 +106,24 @@ item, it will be accompanied by a banner explaining that the item is only availa\n platforms.\n \n For Rustdoc to document an item, it needs to see it, regardless of what platform it's currently\n-running on. To aid this, Rustdoc sets the flag `#[cfg(rustdoc)]` when running on your crate.\n+running on. To aid this, Rustdoc sets the flag `#[cfg(doc)]` when running on your crate.\n Combining this with the target platform of a given item allows it to appear when building your crate\n normally on that platform, as well as when building documentation anywhere.\n \n-For example, `#[cfg(any(windows, rustdoc))]` will preserve the item either on Windows or during the\n+For example, `#[cfg(any(windows, doc))]` will preserve the item either on Windows or during the\n documentation process. Then, adding a new attribute `#[doc(cfg(windows))]` will tell Rustdoc that\n the item is supposed to be used on Windows. For example:\n \n ```rust\n #![feature(doc_cfg)]\n \n /// Token struct that can only be used on Windows.\n-#[cfg(any(windows, rustdoc))]\n+#[cfg(any(windows, doc))]\n #[doc(cfg(windows))]\n pub struct WindowsToken;\n \n /// Token struct that can only be used on Unix.\n-#[cfg(any(unix, rustdoc))]\n+#[cfg(any(unix, doc))]\n #[doc(cfg(unix))]\n pub struct UnixToken;\n ```\n@@ -294,30 +294,6 @@ some consideration for their stability, and names that end in a number). Giving\n `rustdoc` will disable this sorting and instead make it print the items in the order they appear in\n the source.\n \n-### `--themes`: provide additional themes\n-\n-Using this flag looks like this:\n-\n-```bash\n-$ rustdoc src/lib.rs -Z unstable-options --themes theme.css\n-```\n-\n-Giving this flag to `rustdoc` will make it copy your theme into the generated crate docs and enable\n-it in the theme selector. Note that `rustdoc` will reject your theme file if it doesn't style\n-everything the \"light\" theme does. See `--theme-checker` below for details.\n-\n-### `--theme-checker`: verify theme CSS for validity\n-\n-Using this flag looks like this:\n-\n-```bash\n-$ rustdoc -Z unstable-options --theme-checker theme.css\n-```\n-\n-Before including your theme in crate docs, `rustdoc` will compare all the CSS rules it contains\n-against the \"light\" theme included by default. Using this flag will allow you to see which rules are\n-missing if `rustdoc` rejects your theme.\n-\n ### `--resource-suffix`: modifying the name of CSS/JavaScript in crate docs\n \n Using this flag looks like this:"}, {"sha": "949f24ab9c11eb5337050c3fadfdc51bcf3bcf91", "filename": "src/doc/unstable-book/src/language-features/cfg-sanitize.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,36 @@\n+# `cfg_sanitize`\n+\n+The tracking issue for this feature is: [#39699]\n+\n+[#39699]: https://github.com/rust-lang/rust/issues/39699\n+\n+------------------------\n+\n+The `cfg_sanitize` feature makes it possible to execute different code\n+depending on whether a particular sanitizer is enabled or not.\n+\n+## Examples\n+\n+``` rust\n+#![feature(cfg_sanitize)]\n+\n+#[cfg(sanitize = \"thread\")]\n+fn a() {\n+  // ...\n+}\n+\n+#[cfg(not(sanitize = \"thread\"))]\n+fn a() {\n+  // ...\n+}\n+\n+fn b() {\n+  if cfg!(sanitize = \"leak\") {\n+    // ...\n+  } else {\n+    // ...\n+  }\n+}\n+\n+```\n+"}, {"sha": "ee9cfcbd9dee2b9acf73b428f4ac6b0afd36dd4f", "filename": "src/doc/unstable-book/src/language-features/const-if-match.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-if-match.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-if-match.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-if-match.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,14 @@\n+# `const_if_match`\n+\n+The tracking issue for this feature is: [#49146]\n+\n+[#49146]: https://github.com/rust-lang/rust/issues/49146\n+\n+------------------------\n+\n+Allows for the use of conditionals (`if` and `match`) in a const context.\n+Const contexts include `static`, `static mut`, `const`, `const fn`, const\n+generics, and array initializers. Enabling this feature flag will also make\n+`&&` and `||` function normally in a const-context by removing the hack that\n+replaces them with their non-short-circuiting equivalents, `&` and `|`, in a\n+`const` or `static`."}, {"sha": "e75f1aea992294db3a73c571094a7b1cc0b1ce0d", "filename": "src/doc/unstable-book/src/language-features/doc-cfg.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -13,7 +13,7 @@ This attribute has two effects:\n 2. The item's doc-tests will only run on the specific platform.\n \n In addition to allowing the use of the `#[doc(cfg)]` attribute, this feature enables the use of a\n-special conditional compilation flag, `#[cfg(rustdoc)]`, set whenever building documentation on your\n+special conditional compilation flag, `#[cfg(doc)]`, set whenever building documentation on your\n crate.\n \n This feature was introduced as part of PR [#43348] to allow the platform-specific parts of the\n@@ -22,7 +22,7 @@ standard library be documented.\n ```rust\n #![feature(doc_cfg)]\n \n-#[cfg(any(windows, rustdoc))]\n+#[cfg(any(windows, doc))]\n #[doc(cfg(windows))]\n /// The application's icon in the notification area (a.k.a. system tray).\n ///"}, {"sha": "495cdee62c87dc798f6049ba5a21278d79409012", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 2, "deletions": 135, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -13,156 +13,23 @@ This feature is part of \"compiler plugins.\" It will often be used with the\n ------------------------\n \n `rustc` can load compiler plugins, which are user-provided libraries that\n-extend the compiler's behavior with new syntax extensions, lint checks, etc.\n+extend the compiler's behavior with new lint checks, etc.\n \n A plugin is a dynamic library crate with a designated *registrar* function that\n registers extensions with `rustc`. Other crates can load these extensions using\n the crate attribute `#![plugin(...)]`.  See the\n `rustc_driver::plugin` documentation for more about the\n mechanics of defining and loading a plugin.\n \n-If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n-interpreted by rustc itself.  They are provided to the plugin through the\n-`Registry`'s `args` method.\n-\n In the vast majority of cases, a plugin should *only* be used through\n `#![plugin]` and not through an `extern crate` item.  Linking a plugin would\n pull in all of libsyntax and librustc as dependencies of your crate.  This is\n-generally unwanted unless you are building another plugin.  The\n-`plugin_as_library` lint checks these guidelines.\n+generally unwanted unless you are building another plugin.\n \n The usual practice is to put compiler plugins in their own crate, separate from\n any `macro_rules!` macros or ordinary Rust code meant to be used by consumers\n of a library.\n \n-# Syntax extensions\n-\n-Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n-is the procedural macro. These are invoked the same way as [ordinary\n-macros](../../book/macros.md), but the expansion is performed by arbitrary Rust\n-code that manipulates syntax trees at\n-compile time.\n-\n-Let's write a plugin\n-[`roman_numerals.rs`](https://github.com/rust-lang/rust/blob/master/src/test/ui-fulldeps/auxiliary/roman_numerals.rs)\n-that implements Roman numeral integer literals.\n-\n-```rust,ignore\n-#![crate_type=\"dylib\"]\n-#![feature(plugin_registrar, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate rustc;\n-extern crate rustc_driver;\n-\n-use syntax::parse::token::{self, Token};\n-use syntax::tokenstream::{TokenTree, TokenStream};\n-use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n-use syntax_pos::Span;\n-use rustc_driver::plugin::Registry;\n-\n-fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: TokenStream)\n-        -> Box<dyn MacResult + 'static> {\n-\n-    static NUMERALS: &'static [(&'static str, usize)] = &[\n-        (\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400),\n-        (\"C\",  100), (\"XC\",  90), (\"L\",  50), (\"XL\",  40),\n-        (\"X\",   10), (\"IX\",   9), (\"V\",   5), (\"IV\",   4),\n-        (\"I\",    1)];\n-\n-    if args.len() != 1 {\n-        cx.span_err(\n-            sp,\n-            &format!(\"argument should be a single identifier, but got {} arguments\", args.len()));\n-        return DummyResult::any(sp);\n-    }\n-\n-    let text = match args.into_trees().next().unwrap() {\n-        TokenTree::Token(Token { kind: token::Ident(s, _), .. }) => s.to_string(),\n-        _ => {\n-            cx.span_err(sp, \"argument should be a single identifier\");\n-            return DummyResult::any(sp);\n-        }\n-    };\n-\n-    let mut text = &*text;\n-    let mut total = 0;\n-    while !text.is_empty() {\n-        match NUMERALS.iter().find(|&&(rn, _)| text.starts_with(rn)) {\n-            Some(&(rn, val)) => {\n-                total += val;\n-                text = &text[rn.len()..];\n-            }\n-            None => {\n-                cx.span_err(sp, \"invalid Roman numeral\");\n-                return DummyResult::any(sp);\n-            }\n-        }\n-    }\n-\n-    MacEager::expr(cx.expr_usize(sp, total))\n-}\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"rn\", expand_rn);\n-}\n-```\n-\n-Then we can use `rn!()` like any other macro:\n-\n-```rust,ignore\n-#![feature(plugin)]\n-#![plugin(roman_numerals)]\n-\n-fn main() {\n-    assert_eq!(rn!(MMXV), 2015);\n-}\n-```\n-\n-The advantages over a simple `fn(&str) -> u32` are:\n-\n-* The (arbitrarily complex) conversion is done at compile time.\n-* Input validation is also performed at compile time.\n-* It can be extended to allow use in patterns, which effectively gives\n-  a way to define new literal syntax for any data type.\n-\n-In addition to procedural macros, you can define new\n-[`derive`](../../reference/attributes/derive.md)-like attributes and other kinds\n-of extensions.  See `Registry::register_syntax_extension` and the\n-`SyntaxExtension` struct.  For a more involved macro example, see\n-[`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n-\n-\n-## Tips and tricks\n-\n-You can use `syntax::parse` to turn token trees into\n-higher-level syntax elements like expressions:\n-\n-```rust,ignore\n-fn expand_foo(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n-        -> Box<MacResult+'static> {\n-\n-    let mut parser = cx.new_parser_from_tts(args);\n-\n-    let expr: P<Expr> = parser.parse_expr();\n-```\n-\n-Looking through [`libsyntax` parser\n-code](https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs)\n-will give you a feel for how the parsing infrastructure works.\n-\n-Keep the `Span`s of everything you parse, for better error reporting. You can\n-wrap `Spanned` around your custom data structures.\n-\n-Calling `ExtCtxt::span_fatal` will immediately abort compilation. It's better to\n-instead call `ExtCtxt::span_err` and return `DummyResult` so that the compiler\n-can continue and find further errors.\n-\n-To print syntax fragments for debugging, you can use `span_note` together with\n-`syntax::print::pprust::*_to_string`.\n-\n # Lint plugins\n \n Plugins can extend [Rust's lint"}, {"sha": "85395d2ecdfc75b8e5593a02bda842d413e1b3c5", "filename": "src/etc/dec2flt_table.py", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fetc%2Fdec2flt_table.py", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fetc%2Fdec2flt_table.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdec2flt_table.py?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -111,14 +111,18 @@ def print_proper_powers():\n     print(\"pub const MIN_E: i16 = {};\".format(MIN_E))\n     print(\"pub const MAX_E: i16 = {};\".format(MAX_E))\n     print()\n+    print(\"#[rustfmt::skip]\")\n     typ = \"([u64; {0}], [i16; {0}])\".format(len(powers))\n-    print(\"pub const POWERS: \", typ, \" = ([\", sep='')\n+    print(\"pub const POWERS: \", typ, \" = (\", sep='')\n+    print(\"    [\")\n     for z in powers:\n-        print(\"    0x{:x},\".format(z.sig))\n-    print(\"], [\")\n+        print(\"        0x{:x},\".format(z.sig))\n+    print(\"    ],\")\n+    print(\"    [\")\n     for z in powers:\n-        print(\"    {},\".format(z.exp))\n-    print(\"]);\")\n+        print(\"        {},\".format(z.exp))\n+    print(\"    ],\")\n+    print(\");\")\n \n \n def print_short_powers(num_bits, significand_size):\n@@ -127,6 +131,7 @@ def print_short_powers(num_bits, significand_size):\n     max_e = int(ceil(log(max_sig, 5)))\n     e_range = range(max_e)\n     typ = \"[f{}; {}]\".format(num_bits, len(e_range))\n+    print(\"#[rustfmt::skip]\")\n     print(\"pub const F\", num_bits, \"_SHORT_POWERS: \", typ, \" = [\", sep='')\n     for e in e_range:\n         print(\"    1e{},\".format(e))"}, {"sha": "5da01b96fa5e36f392cdecad68eb448964eed219", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -284,10 +284,20 @@ def to_string(self):\n                 (\"(len: %i, cap: %i)\" % (length, cap)))\n \n     def children(self):\n+        saw_inaccessible = False\n         (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n         gdb_ptr = data_ptr.get_wrapped_value()\n         for index in xrange(0, length):\n-            yield (str(index), (gdb_ptr + index).dereference())\n+            if saw_inaccessible:\n+                return\n+            try:\n+                # rust-lang/rust#64343: passing deref expr to `str` allows\n+                # catching exception on garbage pointer\n+                str((gdb_ptr + index).dereference())\n+                yield (str(index), (gdb_ptr + index).dereference())\n+            except RuntimeError:\n+                saw_inaccessible = True\n+                yield (str(index), \"inaccessible\")\n \n \n class RustStdVecDequePrinter(object):"}, {"sha": "b3fc3d17af7fe15298a7cc57cec96eec6f633ba9", "filename": "src/etc/natvis/libstd.natvis", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fetc%2Fnatvis%2Flibstd.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fetc%2Fnatvis%2Flibstd.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibstd.natvis?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,102 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n+  <!--\n+    std::collection::Hash* container visualizers\n+\n+    Current std impls:\n+      std::collections::hash::set::HashSet<K, S>      is implemented in terms of...\n+      std::collections::hash::map::HashMap<K, V, S>   is implemented in terms of...\n+      hashbrown::map::HashMap<K, V, S>                is implemented in terms of...\n+      hashbrown::raw::RawTable<(K, V)>\n+\n+    Ideally, we'd teach rustc to scan dependencies/crates for .natvis files so\n+    the bulk of this could live alongside the hashbrown crate implementation,\n+    and std would just forward using e.g. <ExpandedItem>base</ExpandedItem>.\n+\n+    However, Given that std...Hash*Set* is currently implemented in terms of\n+    hashbrown...Hash*Map*, which would visualize poorly, we want to customize the\n+    look/feel at the std type level *anyways*...\n+\n+    References:\n+      https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/map.rs\n+      https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/set.rs\n+      https://github.com/rust-lang/hashbrown/blob/master/src/map.rs\n+      https://github.com/rust-lang/hashbrown/blob/master/src/set.rs\n+      https://github.com/rust-lang/hashbrown/blob/master/src/raw/mod.rs\n+  -->\n+\n+  <Type Name=\"std::collections::hash::map::HashMap&lt;*,*,*&gt;\">\n+    <DisplayString>{{ size={base.table.items} }}</DisplayString>\n+    <Expand>\n+      <Item Name=\"[size]\">base.table.items</Item>\n+      <Item Name=\"[capacity]\">base.table.items + base.table.growth_left</Item>\n+\n+      <CustomListItems>\n+        <Variable Name=\"i\" InitialValue=\"0\" />\n+        <Variable Name=\"n\" InitialValue=\"base.table.items\" />\n+        <Size>base.table.items</Size>\n+        <Loop>\n+          <Break Condition=\"n == 0\" />\n+          <If Condition=\"(base.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n+            <!-- Bucket is populated -->\n+            <Exec>n--</Exec>\n+            <Item Name=\"{base.table.data.pointer[i].__0}\">base.table.data.pointer[i].__1</Item>\n+          </If>\n+          <Exec>i++</Exec>\n+        </Loop>\n+      </CustomListItems>\n+    </Expand>\n+  </Type>\n+\n+  <Type Name=\"std::collections::hash::set::HashSet&lt;*,*&gt;\">\n+    <DisplayString>{{ size={map.base.table.items} }}</DisplayString>\n+    <Expand>\n+      <Item Name=\"[size]\">map.base.table.items</Item>\n+      <Item Name=\"[capacity]\">map.base.table.items + map.base.table.growth_left</Item>\n+\n+      <CustomListItems>\n+        <Variable Name=\"i\" InitialValue=\"0\" />\n+        <Variable Name=\"n\" InitialValue=\"map.base.table.items\" />\n+        <Size>map.base.table.items</Size>\n+        <Loop>\n+          <Break Condition=\"n == 0\" />\n+          <If Condition=\"(map.base.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n+            <!-- Bucket is populated -->\n+            <Exec>n--</Exec>\n+            <Item>map.base.table.data.pointer[i].__0</Item>\n+          </If>\n+          <Exec>i++</Exec>\n+        </Loop>\n+      </CustomListItems>\n+    </Expand>\n+  </Type>\n+\n+  <Type Name=\"hashbrown::raw::RawTable&lt;*&gt;\">\n+    <!-- RawTable has a nice and simple layout.\n+      items                     Number of *populated* values in the RawTable (less than the size of ctrl.pointer / data.pointer)\n+      growth_left               Remaining capacity before growth\n+      ctrl.pointer[i] & 0x80    Indicates the bucket is empty / should be skipped / doesn't count towards items.\n+      data.pointer[i]           The (K,V) tuple, if not empty.\n+    -->\n+    <DisplayString>{{ size={items} }}</DisplayString>\n+    <Expand>\n+      <Item Name=\"[size]\">items</Item>\n+      <Item Name=\"[capacity]\">items + growth_left</Item>\n+\n+      <CustomListItems>\n+        <Variable Name=\"i\" InitialValue=\"0\" />\n+        <Variable Name=\"n\" InitialValue=\"items\" />\n+        <Size>items</Size>\n+        <Loop>\n+          <Break Condition=\"n == 0\" />\n+          <If Condition=\"(ctrl.pointer[i] &amp; 0x80) == 0\">\n+            <!-- Bucket is populated -->\n+            <Exec>n--</Exec>\n+            <Item>data.pointer[i]</Item>\n+          </If>\n+          <Exec>i++</Exec>\n+        </Loop>\n+      </CustomListItems>\n+    </Expand>\n+  </Type>\n+</AutoVisualizer>"}, {"sha": "956298d7836b854a2be3d10535c8d84630588ec2", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,15 +1,15 @@\n use super::*;\n \n extern crate test;\n-use test::Bencher;\n use crate::boxed::Box;\n+use test::Bencher;\n \n #[test]\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let ptr = Global.alloc_zeroed(layout.clone())\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr =\n+            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         let mut i = ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());"}, {"sha": "eb5f51d9adc584b39efbc6760685828e6723ecb6", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,12 +1,12 @@\n+use std::collections::BTreeMap;\n use std::iter::Iterator;\n use std::vec::Vec;\n-use std::collections::BTreeMap;\n \n-use rand::{Rng, seq::SliceRandom, thread_rng};\n-use test::{Bencher, black_box};\n+use rand::{seq::SliceRandom, thread_rng, Rng};\n+use test::{black_box, Bencher};\n \n macro_rules! map_insert_rand_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let n: usize = $n;\n@@ -27,11 +27,11 @@ macro_rules! map_insert_rand_bench {\n             });\n             black_box(map);\n         }\n-    )\n+    };\n }\n \n macro_rules! map_insert_seq_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -50,11 +50,11 @@ macro_rules! map_insert_seq_bench {\n             });\n             black_box(map);\n         }\n-    )\n+    };\n }\n \n macro_rules! map_find_rand_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -78,11 +78,11 @@ macro_rules! map_find_rand_bench {\n                 black_box(t);\n             })\n         }\n-    )\n+    };\n }\n \n macro_rules! map_find_seq_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -101,20 +101,20 @@ macro_rules! map_find_seq_bench {\n                 black_box(x);\n             })\n         }\n-    )\n+    };\n }\n \n-map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n-map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n+map_insert_rand_bench! {insert_rand_100,    100,    BTreeMap}\n+map_insert_rand_bench! {insert_rand_10_000, 10_000, BTreeMap}\n \n-map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n-map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n+map_insert_seq_bench! {insert_seq_100,    100,    BTreeMap}\n+map_insert_seq_bench! {insert_seq_10_000, 10_000, BTreeMap}\n \n-map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n-map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n+map_find_rand_bench! {find_rand_100,    100,    BTreeMap}\n+map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n \n-map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n-map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n+map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n+map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n fn bench_iter(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n@@ -145,3 +145,28 @@ pub fn iter_1000(b: &mut Bencher) {\n pub fn iter_100000(b: &mut Bencher) {\n     bench_iter(b, 100000);\n }\n+\n+fn bench_first_and_last(b: &mut Bencher, size: i32) {\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for _ in 0..10 {\n+            black_box(map.first_key_value());\n+            black_box(map.last_key_value());\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn first_and_last_0(b: &mut Bencher) {\n+    bench_first_and_last(b, 0);\n+}\n+\n+#[bench]\n+pub fn first_and_last_100(b: &mut Bencher) {\n+    bench_first_and_last(b, 100);\n+}\n+\n+#[bench]\n+pub fn first_and_last_10k(b: &mut Bencher) {\n+    bench_first_and_last(b, 10_000);\n+}"}, {"sha": "18502ded308c73f924e04122b327c27d8d7c8129", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,7 +1,7 @@\n use std::collections::BTreeSet;\n \n use rand::{thread_rng, Rng};\n-use test::{black_box, Bencher};\n+use test::Bencher;\n \n fn random(n: usize) -> BTreeSet<usize> {\n     let mut rng = thread_rng();\n@@ -31,7 +31,6 @@ fn pos(n: usize) -> BTreeSet<i32> {\n     set\n }\n \n-\n fn stagger(n1: usize, factor: usize) -> [BTreeSet<u32>; 2] {\n     let n2 = n1 * factor;\n     let mut sets = [BTreeSet::new(), BTreeSet::new()];\n@@ -52,10 +51,7 @@ macro_rules! set_bench {\n             let sets = $sets;\n \n             // measure\n-            b.iter(|| {\n-                let x = sets[0].$set_func(&sets[1]).$result_func();\n-                black_box(x);\n-            })\n+            b.iter(|| sets[0].$set_func(&sets[1]).$result_func())\n         }\n     };\n }"}, {"sha": "9acda886064ce5e2ea5d3b5a1ac4bc2906e26996", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,3 +1,4 @@\n+#![feature(map_first_last)]\n #![feature(repr_simd)]\n #![feature(test)]\n "}, {"sha": "e20c043286e6fedd50cc43a87c616c3bda9e58b0", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,9 +1,9 @@\n use std::{mem, ptr};\n \n+use rand::distributions::{Alphanumeric, Standard};\n use rand::{thread_rng, Rng, SeedableRng};\n-use rand::distributions::{Standard, Alphanumeric};\n use rand_xorshift::XorShiftRng;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn iterator(b: &mut Bencher) {\n@@ -239,7 +239,7 @@ macro_rules! sort {\n             b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_strings {\n@@ -251,7 +251,7 @@ macro_rules! sort_strings {\n             b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of::<&str>() as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_expensive {\n@@ -273,7 +273,7 @@ macro_rules! sort_expensive {\n             });\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_lexicographic {\n@@ -284,7 +284,7 @@ macro_rules! sort_lexicographic {\n             b.iter(|| v.clone().$f(|x| x.to_string()));\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n sort!(sort, sort_small_ascending, gen_ascending, 10);\n@@ -325,57 +325,58 @@ macro_rules! reverse {\n         fn $name(b: &mut Bencher) {\n             // odd length and offset by 1 to be as unaligned as possible\n             let n = 0xFFFFF;\n-            let mut v: Vec<_> =\n-                (0..1+(n / mem::size_of::<$ty>() as u64))\n-                .map($f)\n-                .collect();\n+            let mut v: Vec<_> = (0..1 + (n / mem::size_of::<$ty>() as u64)).map($f).collect();\n             b.iter(|| black_box(&mut v[1..]).reverse());\n             b.bytes = n;\n         }\n-    }\n+    };\n }\n \n reverse!(reverse_u8, u8, |x| x as u8);\n reverse!(reverse_u16, u16, |x| x as u16);\n-reverse!(reverse_u8x3, [u8;3], |x| [x as u8, (x>>8) as u8, (x>>16) as u8]);\n+reverse!(reverse_u8x3, [u8; 3], |x| [x as u8, (x >> 8) as u8, (x >> 16) as u8]);\n reverse!(reverse_u32, u32, |x| x as u32);\n reverse!(reverse_u64, u64, |x| x as u64);\n reverse!(reverse_u128, u128, |x| x as u128);\n-#[repr(simd)] struct F64x4(f64, f64, f64, f64);\n-reverse!(reverse_simd_f64x4, F64x4, |x| { let x = x as f64; F64x4(x,x,x,x) });\n+#[repr(simd)]\n+struct F64x4(f64, f64, f64, f64);\n+reverse!(reverse_simd_f64x4, F64x4, |x| {\n+    let x = x as f64;\n+    F64x4(x, x, x, x)\n+});\n \n macro_rules! rotate {\n     ($name:ident, $gen:expr, $len:expr, $mid:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n             let size = mem::size_of_val(&$gen(1)[0]);\n             let mut v = $gen($len * 8 / size);\n-            b.iter(|| black_box(&mut v).rotate_left(($mid*8+size-1)/size));\n+            b.iter(|| black_box(&mut v).rotate_left(($mid * 8 + size - 1) / size));\n             b.bytes = (v.len() * size) as u64;\n         }\n-    }\n+    };\n }\n \n rotate!(rotate_tiny_by1, gen_random, 16, 1);\n-rotate!(rotate_tiny_half, gen_random, 16, 16/2);\n-rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16/2+1);\n+rotate!(rotate_tiny_half, gen_random, 16, 16 / 2);\n+rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16 / 2 + 1);\n \n rotate!(rotate_medium_by1, gen_random, 9158, 1);\n rotate!(rotate_medium_by727_u64, gen_random, 9158, 727);\n rotate!(rotate_medium_by727_bytes, gen_random_bytes, 9158, 727);\n rotate!(rotate_medium_by727_strings, gen_strings, 9158, 727);\n-rotate!(rotate_medium_half, gen_random, 9158, 9158/2);\n-rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158/2+1);\n+rotate!(rotate_medium_half, gen_random, 9158, 9158 / 2);\n+rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158 / 2 + 1);\n \n // Intended to use more RAM than the machine has cache\n-rotate!(rotate_huge_by1, gen_random, 5*1024*1024, 1);\n-rotate!(rotate_huge_by9199_u64, gen_random, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_strings, gen_strings, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_big, gen_big_random, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by1234577_u64, gen_random, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_strings, gen_strings, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_big, gen_big_random, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_half, gen_random, 5*1024*1024, 5*1024*1024/2);\n-rotate!(rotate_huge_half_plus_one, gen_random, 5*1024*1024, 5*1024*1024/2+1);\n+rotate!(rotate_huge_by1, gen_random, 5 * 1024 * 1024, 1);\n+rotate!(rotate_huge_by9199_u64, gen_random, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_strings, gen_strings, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_big, gen_big_random, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by1234577_u64, gen_random, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_strings, gen_strings, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_big, gen_big_random, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_half, gen_random, 5 * 1024 * 1024, 5 * 1024 * 1024 / 2);\n+rotate!(rotate_huge_half_plus_one, gen_random, 5 * 1024 * 1024, 5 * 1024 * 1024 / 2 + 1);"}, {"sha": "391475bc0c75deda0ca0e47e15f8e7ad9cb2f8f3", "filename": "src/liballoc/benches/str.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,4 +1,4 @@\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn char_iterator(b: &mut Bencher) {\n@@ -12,7 +12,9 @@ fn char_iterator_for(b: &mut Bencher) {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n     b.iter(|| {\n-        for ch in s.chars() { black_box(ch); }\n+        for ch in s.chars() {\n+            black_box(ch);\n+        }\n     });\n }\n \n@@ -40,7 +42,9 @@ fn char_iterator_rev_for(b: &mut Bencher) {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n     b.iter(|| {\n-        for ch in s.chars().rev() { black_box(ch); }\n+        for ch in s.chars().rev() {\n+            black_box(ch);\n+        }\n     });\n }\n \n@@ -79,7 +83,9 @@ fn split_ascii(b: &mut Bencher) {\n fn split_extern_fn(b: &mut Bencher) {\n     let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n     let len = s.split(' ').count();\n-    fn pred(c: char) -> bool { c == ' ' }\n+    fn pred(c: char) -> bool {\n+        c == ' '\n+    }\n \n     b.iter(|| assert_eq!(s.split(pred).count(), len));\n }\n@@ -185,16 +191,19 @@ fn bench_contains_equal(b: &mut Bencher) {\n     })\n }\n \n-\n macro_rules! make_test_inner {\n     ($s:ident, $code:expr, $name:ident, $str:expr, $iters:expr) => {\n         #[bench]\n         fn $name(bencher: &mut Bencher) {\n             let mut $s = $str;\n             black_box(&mut $s);\n-            bencher.iter(|| for _ in 0..$iters { black_box($code); });\n+            bencher.iter(|| {\n+                for _ in 0..$iters {\n+                    black_box($code);\n+                }\n+            });\n         }\n-    }\n+    };\n }\n \n macro_rules! make_test {\n@@ -261,15 +270,9 @@ make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n \n make_test!(split_a_str, s, s.split(\"a\").count());\n \n-make_test!(trim_ascii_char, s, {\n-    s.trim_matches(|c: char| c.is_ascii())\n-});\n-make_test!(trim_start_ascii_char, s, {\n-    s.trim_start_matches(|c: char| c.is_ascii())\n-});\n-make_test!(trim_end_ascii_char, s, {\n-    s.trim_end_matches(|c: char| c.is_ascii())\n-});\n+make_test!(trim_ascii_char, s, { s.trim_matches(|c: char| c.is_ascii()) });\n+make_test!(trim_start_ascii_char, s, { s.trim_start_matches(|c: char| c.is_ascii()) });\n+make_test!(trim_end_ascii_char, s, { s.trim_end_matches(|c: char| c.is_ascii()) });\n \n make_test!(find_underscore_char, s, s.find('_'));\n make_test!(rfind_underscore_char, s, s.rfind('_'));"}, {"sha": "bf2dffd1e931eecfbc52c1b48c5811e196085958", "filename": "src/liballoc/benches/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,5 +1,5 @@\n use std::collections::VecDeque;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_new(b: &mut Bencher) {"}, {"sha": "5825bdc355f2d173d4ab3aff19bd9e509aa8eb9e", "filename": "src/liballoc/benches/vec_deque_append.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -30,8 +30,5 @@ fn main() {\n \n     assert!(BENCH_N % 2 == 0);\n     let median = (durations[(l / 2) - 1] + durations[l / 2]) / 2;\n-    println!(\n-        \"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\",\n-        median.as_nanos()\n-    );\n+    println!(\"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\", median.as_nanos());\n }"}, {"sha": "51ad3a04e87fe6b7791ce14af0ff204f094b864b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -152,6 +152,33 @@ impl<T> Box<T> {\n         Box(ptr.cast().into())\n     }\n \n+    /// Constructs a new `Box` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let zero = Box::<u32>::new_zeroed();\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0)\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n+        unsafe {\n+            let mut uninit = Self::new_uninit();\n+            ptr::write_bytes::<T>(uninit.as_mut_ptr(), 0, 1);\n+            uninit\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]"}, {"sha": "5b48b594ff9079d552fbfcc3effc39fb1ac8dac6", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -598,6 +598,121 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Returns the first key-value pair in the map.\n+    /// The key in this pair is the minimum key in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// assert_eq!(map.first_key_value(), None);\n+    /// map.insert(1, \"b\");\n+    /// map.insert(2, \"a\");\n+    /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn first_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n+        where T: Ord, K: Borrow<T>\n+    {\n+        let front = first_leaf_edge(self.root.as_ref());\n+        front.right_kv().ok().map(Handle::into_kv)\n+    }\n+\n+    /// Returns the first entry in the map for in-place manipulation.\n+    /// The key of this entry is the minimum key in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Contrived way to `clear` a map:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some(entry) = map.first_entry() {\n+    ///     let (key, val) = entry.remove_entry();\n+    ///     assert!(!map.contains_key(&key));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn first_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+        where T: Ord, K: Borrow<T>\n+    {\n+        match self.length {\n+            0 => None,\n+            _ => Some(OccupiedEntry {\n+                          handle: self.root.as_mut().first_kv(),\n+                          length: &mut self.length,\n+                          _marker: PhantomData,\n+                      }),\n+        }\n+    }\n+\n+    /// Returns the last key-value pair in the map.\n+    /// The key in this pair is the maximum key in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"b\");\n+    /// map.insert(2, \"a\");\n+    /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn last_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n+        where T: Ord, K: Borrow<T>\n+    {\n+        let back = last_leaf_edge(self.root.as_ref());\n+        back.left_kv().ok().map(Handle::into_kv)\n+    }\n+\n+    /// Returns the last entry in the map for in-place manipulation.\n+    /// The key of this entry is the maximum key in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Contrived way to `clear` a map:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some(entry) = map.last_entry() {\n+    ///     let (key, val) = entry.remove_entry();\n+    ///     assert!(!map.contains_key(&key));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn last_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+        where T: Ord, K: Borrow<T>\n+    {\n+        match self.length {\n+            0 => None,\n+            _ => Some(OccupiedEntry {\n+                          handle: self.root.as_mut().last_kv(),\n+                          length: &mut self.length,\n+                          _marker: PhantomData,\n+                      }),\n+        }\n+    }\n+\n     /// Returns `true` if the map contains a value for the specified key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering"}, {"sha": "f73a24d09916bb1cbd448fb83868a541c4db84af", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,6 +1,6 @@\n+pub mod map;\n mod node;\n mod search;\n-pub mod map;\n pub mod set;\n \n #[doc(hidden)]"}, {"sha": "ab010b35f6ad1568eb3233f767abefc0437dde2d", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -596,7 +596,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n             // (We might be one-past-the-end, but that is allowed by LLVM.)\n             // Getting the pointer is tricky though.  `NodeHeader` does not have a `keys`\n             // field because we want its size to not depend on the alignment of `K`\n-            // (needed becuase `as_header` should be safe).  We cannot call `as_leaf`\n+            // (needed because `as_header` should be safe).  We cannot call `as_leaf`\n             // because we might be the shared root.\n             // For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n             // and hence just adds a size-0-align-1 field, not affecting layout)."}, {"sha": "3f3c49a2ef875246600f87cf976b1b4ea538d370", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,21 +1,23 @@\n use core::borrow::Borrow;\n use core::cmp::Ordering;\n \n-use super::node::{Handle, NodeRef, marker, ForceResult::*};\n+use super::node::{marker, ForceResult::*, Handle, NodeRef};\n \n use SearchResult::*;\n \n pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     Found(Handle<NodeRef<BorrowType, K, V, FoundType>, marker::KV>),\n-    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>)\n+    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    key: &Q\n+    key: &Q,\n ) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     loop {\n         match search_node(node, key) {\n             Found(handle) => return Found(handle),\n@@ -25,38 +27,38 @@ pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n                     node = internal.descend();\n                     continue;\n                 }\n-            }\n+            },\n         }\n     }\n }\n \n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n-    key: &Q\n+    key: &Q,\n ) -> SearchResult<BorrowType, K, V, Type, Type>\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     match search_linear(&node, key) {\n-        (idx, true) => Found(\n-            Handle::new_kv(node, idx)\n-        ),\n-        (idx, false) => SearchResult::GoDown(\n-            Handle::new_edge(node, idx)\n-        )\n+        (idx, true) => Found(Handle::new_kv(node, idx)),\n+        (idx, false) => SearchResult::GoDown(Handle::new_edge(node, idx)),\n     }\n }\n \n pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n-    key: &Q\n+    key: &Q,\n ) -> (usize, bool)\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     for (i, k) in node.keys().iter().enumerate() {\n         match key.cmp(k.borrow()) {\n-            Ordering::Greater => {},\n+            Ordering::Greater => {}\n             Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false)\n+            Ordering::Less => return (i, false),\n         }\n     }\n     (node.keys().len(), false)"}, {"sha": "85b93e0eda45bfd49235f766fa6e0ab79fe692fe", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 99, "deletions": 11, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -194,16 +194,16 @@ pub struct Difference<'a, T: 'a> {\n #[derive(Debug)]\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n-        // iterate all of self and some of other, spotting matches along the way\n+        // iterate all of `self` and some of `other`, spotting matches along the way\n         self_iter: Iter<'a, T>,\n         other_iter: Peekable<Iter<'a, T>>,\n     },\n     Search {\n-        // iterate a small set, look up in the large set\n+        // iterate `self`, look up in `other`\n         self_iter: Iter<'a, T>,\n         other_set: &'a BTreeSet<T>,\n     },\n-    Iterate(Iter<'a, T>), // simply stream self's elements\n+    Iterate(Iter<'a, T>), // simply produce all values in `self`\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -356,7 +356,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n         let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.iter().next(), self.iter().next_back())\n+            (self.first(), self.last())\n         {\n             (self_min, self_max)\n         } else {\n@@ -365,7 +365,7 @@ impl<T: Ord> BTreeSet<T> {\n             };\n         };\n         let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.iter().next(), other.iter().next_back())\n+            (other.first(), other.last())\n         {\n             (other_min, other_max)\n         } else {\n@@ -450,7 +450,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n         let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.iter().next(), self.iter().next_back())\n+            (self.first(), self.last())\n         {\n             (self_min, self_max)\n         } else {\n@@ -459,7 +459,7 @@ impl<T: Ord> BTreeSet<T> {\n             };\n         };\n         let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.iter().next(), other.iter().next_back())\n+            (other.first(), other.last())\n         {\n             (other_min, other_max)\n         } else {\n@@ -625,14 +625,14 @@ impl<T: Ord> BTreeSet<T> {\n             return false;\n         }\n         let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.iter().next(), self.iter().next_back())\n+            (self.first(), self.last())\n         {\n             (self_min, self_max)\n         } else {\n             return true; // self is empty\n         };\n         let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.iter().next(), other.iter().next_back())\n+            (other.first(), other.last())\n         {\n             (other_min, other_max)\n         } else {\n@@ -654,14 +654,12 @@ impl<T: Ord> BTreeSet<T> {\n             Less => (),\n         }\n         if self_iter.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Big difference in number of elements.\n             for next in self_iter {\n                 if !other.contains(next) {\n                     return false;\n                 }\n             }\n         } else {\n-            // Self is not much smaller than other set.\n             let mut other_iter = other.iter();\n             other_iter.next();\n             other_iter.next_back();\n@@ -702,6 +700,96 @@ impl<T: Ord> BTreeSet<T> {\n         other.is_subset(self)\n     }\n \n+    /// Returns a reference to the first value in the set, if any.\n+    /// This value is always the minimum of all values in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut map = BTreeSet::new();\n+    /// assert_eq!(map.first(), None);\n+    /// map.insert(1);\n+    /// assert_eq!(map.first(), Some(&1));\n+    /// map.insert(2);\n+    /// assert_eq!(map.first(), Some(&1));\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn first(&self) -> Option<&T> {\n+        self.map.first_key_value().map(|(k, _)| k)\n+    }\n+\n+    /// Returns a reference to the last value in the set, if any.\n+    /// This value is always the maximum of all values in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut map = BTreeSet::new();\n+    /// assert_eq!(map.first(), None);\n+    /// map.insert(1);\n+    /// assert_eq!(map.last(), Some(&1));\n+    /// map.insert(2);\n+    /// assert_eq!(map.last(), Some(&2));\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn last(&self) -> Option<&T> {\n+        self.map.last_key_value().map(|(k, _)| k)\n+    }\n+\n+    /// Removes the first value from the set and returns it, if any.\n+    /// The first value is always the minimum value in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// set.insert(1);\n+    /// while let Some(n) = set.pop_first() {\n+    ///     assert_eq!(n, 1);\n+    /// }\n+    /// assert!(set.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_first(&mut self) -> Option<T> {\n+        self.map.first_entry().map(|entry| entry.remove_entry().0)\n+    }\n+\n+    /// Removes the last value from the set and returns it, if any.\n+    /// The last value is always the maximum value in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// set.insert(1);\n+    /// while let Some(n) = set.pop_last() {\n+    ///     assert_eq!(n, 1);\n+    /// }\n+    /// assert!(set.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_last(&mut self) -> Option<T> {\n+        self.map.last_entry().map(|entry| entry.remove_entry().0)\n+    }\n+\n     /// Adds a value to the set.\n     ///\n     /// If the set did not have this value present, `true` is returned."}, {"sha": "94b92df12940098e5d68b888970e57fa553bfe1b", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -177,8 +177,7 @@ fn test_insert_prev() {\n     }\n     check_links(&m);\n     assert_eq!(m.len(), 3 + len * 2);\n-    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-                [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n }\n \n #[test]\n@@ -187,13 +186,13 @@ fn test_insert_prev() {\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {\n-            check_links(&n);\n-            let a: &[_] = &[&1, &2, &3];\n-            assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n-        })\n-        .join()\n-        .ok()\n-        .unwrap();\n+        check_links(&n);\n+        let a: &[_] = &[&1, &2, &3];\n+        assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n+    })\n+    .join()\n+    .ok()\n+    .unwrap();\n }\n \n #[test]"}, {"sha": "7795083e0580cc2d8f2fbff8081a60cd4b85c897", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -835,7 +835,8 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Shortens the `VecDeque`, dropping excess elements from the back.\n+    /// Shortens the `VecDeque`, keeping the first `len` elements and dropping\n+    /// the rest.\n     ///\n     /// If `len` is greater than the `VecDeque`'s current length, this has no\n     /// effect.\n@@ -855,8 +856,31 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn truncate(&mut self, len: usize) {\n-        for _ in len..self.len() {\n-            self.pop_back();\n+        // Safe because:\n+        //\n+        // * Any slice passed to `drop_in_place` is valid; the second case has\n+        //   `len <= front.len()` and returning on `len > self.len()` ensures\n+        //   `begin <= back.len()` in the first case\n+        // * The head of the VecDeque is moved before calling `drop_in_place`,\n+        //   so no value is dropped twice if `drop_in_place` panics\n+        unsafe {\n+            if len > self.len() {\n+                return;\n+            }\n+            let num_dropped = self.len() - len;\n+            let (front, back) = self.as_mut_slices();\n+            if len > front.len() {\n+                let begin = len - front.len();\n+                let drop_back = back.get_unchecked_mut(begin..) as *mut _;\n+                self.head = self.wrap_sub(self.head, num_dropped);\n+                ptr::drop_in_place(drop_back);\n+            } else {\n+                let drop_back = back as *mut _;\n+                let drop_front = front.get_unchecked_mut(len..) as *mut _;\n+                self.head = self.wrap_sub(self.head, num_dropped);\n+                ptr::drop_in_place(drop_front);\n+                ptr::drop_in_place(drop_back);\n+            }\n         }\n     }\n \n@@ -1117,7 +1141,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n-        self.drain(..);\n+        self.truncate(0);\n     }\n \n     /// Returns `true` if the `VecDeque` contains an element equal to the"}, {"sha": "8dc097cc088051a4fdb5d8472fa52c00840314ce", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -66,11 +66,8 @@ fn test_swap_front_back_remove() {\n         let final_len = usable_cap / 2;\n \n         for len in 0..final_len {\n-            let expected: VecDeque<_> = if back {\n-                (0..len).collect()\n-            } else {\n-                (0..len).rev().collect()\n-            };\n+            let expected: VecDeque<_> =\n+                if back { (0..len).collect() } else { (0..len).rev().collect() };\n             for tail_pos in 0..usable_cap {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n@@ -111,7 +108,6 @@ fn test_insert() {\n     // this test isn't covering what it wants to\n     let cap = tester.capacity();\n \n-\n     // len is the length *after* insertion\n     for len in 1..cap {\n         // 0, 1, 2, .., len - 1\n@@ -198,9 +194,7 @@ fn test_drain() {\n                     assert!(tester.head < tester.cap());\n \n                     // We should see the correct values in the VecDeque\n-                    let expected: VecDeque<_> = (0..drain_start)\n-                        .chain(drain_end..len)\n-                        .collect();\n+                    let expected: VecDeque<_> = (0..drain_start).chain(drain_end..len).collect();\n                     assert_eq!(expected, tester);\n                 }\n             }\n@@ -384,6 +378,41 @@ fn test_clone_from() {\n     }\n }\n \n+#[test]\n+fn test_vec_deque_truncate_drop() {\n+    static mut DROPS: u32 = 0;\n+    #[derive(Clone)]\n+    struct Elem(i32);\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let v = vec![Elem(1), Elem(2), Elem(3), Elem(4), Elem(5)];\n+    for push_front in 0..=v.len() {\n+        let v = v.clone();\n+        let mut tester = VecDeque::with_capacity(5);\n+        for (index, elem) in v.into_iter().enumerate() {\n+            if index < push_front {\n+                tester.push_front(elem);\n+            } else {\n+                tester.push_back(elem);\n+            }\n+        }\n+        assert_eq!(unsafe { DROPS }, 0);\n+        tester.truncate(3);\n+        assert_eq!(unsafe { DROPS }, 2);\n+        tester.truncate(0);\n+        assert_eq!(unsafe { DROPS }, 5);\n+        unsafe {\n+            DROPS = 0;\n+        }\n+    }\n+}\n+\n #[test]\n fn issue_53529() {\n     use crate::boxed::Box;"}, {"sha": "18ebae333098f9f42ea80c1ceb982825b5eae924", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -516,24 +516,24 @@\n \n #[unstable(feature = \"fmt_internals\", issue = \"0\")]\n pub use core::fmt::rt;\n+#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n+pub use core::fmt::Alignment;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{Formatter, Result, Write};\n+pub use core::fmt::Error;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::fmt::{write, ArgumentV1, Arguments};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Binary, Octal};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Debug, Display};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerHex, Pointer, UpperHex};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerExp, UpperExp};\n+pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::Error;\n+pub use core::fmt::{Formatter, Result, Write};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{write, ArgumentV1, Arguments};\n+pub use core::fmt::{LowerExp, UpperExp};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n-#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n-pub use core::fmt::{Alignment};\n+pub use core::fmt::{LowerHex, Pointer, UpperHex};\n \n use crate::string;\n \n@@ -568,8 +568,6 @@ use crate::string;\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();\n     let mut output = string::String::with_capacity(capacity);\n-    output\n-        .write_fmt(args)\n-        .expect(\"a formatting trait implementation returned an error\");\n+    output.write_fmt(args).expect(\"a formatting trait implementation returned an error\");\n     output\n }"}, {"sha": "422d3486f92b29cc860cc33f4868590c7562f5e7", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -98,5 +98,8 @@ macro_rules! vec {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format($crate::__export::format_args!($($arg)*)))\n+    ($($arg:tt)*) => {{\n+        let res = $crate::fmt::format($crate::__export::format_args!($($arg)*));\n+        res\n+    }}\n }"}, {"sha": "6a53b4ca1f6ca961f1c53703c3a56c5e4ca21f72", "filename": "src/liballoc/prelude/v1.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,7 +4,11 @@\n \n #![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n \n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::borrow::ToOwned;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::boxed::Box;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::string::{String, ToString};\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::vec::Vec;"}, {"sha": "b214cef30111516146e2ea14488dba664118f180", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -16,15 +16,20 @@ fn allocator_param() {\n \n     // A dumb allocator that consumes a fixed amount of fuel\n     // before allocation attempts start failing.\n-    struct BoundedAlloc { fuel: usize }\n+    struct BoundedAlloc {\n+        fuel: usize,\n+    }\n     unsafe impl Alloc for BoundedAlloc {\n         unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n             }\n             match Global.alloc(layout) {\n-                ok @ Ok(_) => { self.fuel -= size; ok }\n+                ok @ Ok(_) => {\n+                    self.fuel -= size;\n+                    ok\n+                }\n                 err @ Err(_) => err,\n             }\n         }"}, {"sha": "1ff1c3c834f4ea4c10b3ed5133ec765601f040bf", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -361,6 +361,35 @@ impl<T> Rc<T> {\n         }\n     }\n \n+    /// Constructs a new `Rc` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n+    /// incorrect usage of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let zero = Rc::<u32>::new_zeroed();\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0)\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed() -> Rc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            let mut uninit = Self::new_uninit();\n+            ptr::write_bytes::<T>(Rc::get_mut_unchecked(&mut uninit).as_mut_ptr(), 0, 1);\n+            uninit\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -897,7 +926,7 @@ impl<T: ?Sized> Rc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<RcBox<()>>()\n             .extend(value_layout).unwrap().0\n-            .pad_to_align().unwrap();\n+            .pad_to_align();\n \n         // Allocate for the layout.\n         let mem = Global.alloc(layout)\n@@ -1619,10 +1648,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// It is up to the caller to ensure that the object is still alive when accessing it through\n-    /// the pointer.\n-    ///\n-    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n+    /// or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1702,14 +1729,18 @@ impl<T> Weak<T> {\n     /// This can be used to safely get a strong reference (by calling [`upgrade`]\n     /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n     ///\n-    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n-    /// returned.\n+    /// It takes ownership of one weak count (with the exception of pointers created by [`new`],\n+    /// as these don't have any corresponding weak count).\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n-    /// is or *was* managed by an [`Rc`] and the weak count of that [`Rc`] must not have reached\n-    /// 0. It is allowed for the strong count to be 0.\n+    /// The pointer must have originated from the [`into_raw`] (or [`as_raw`], provided there was\n+    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n+    /// count.\n+    ///\n+    /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n+    /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n+    /// by [`new`]).\n     ///\n     /// # Examples\n     ///\n@@ -1734,11 +1765,13 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`null`]: ../../std/ptr/fn.null.html\n     /// [`into_raw`]: struct.Weak.html#method.into_raw\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`Rc`]: struct.Rc.html\n     /// [`Weak`]: struct.Weak.html\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`new`]: struct.Weak.html#method.new\n+    /// [`forget`]: ../../std/mem/fn.forget.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {"}, {"sha": "2f6d10c027be38bcd742a8a525d158ebada6b62b", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 92, "deletions": 81, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -82,7 +82,6 @@\n //! [`.chunks`]: ../../std/primitive.slice.html#method.chunks\n //! [`.windows`]: ../../std/primitive.slice.html#method.windows\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n // Many of the usings in this module are only used in the test configuration.\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n@@ -91,32 +90,32 @@ use core::borrow::{Borrow, BorrowMut};\n use core::cmp::Ordering::{self, Less};\n use core::mem::{self, size_of};\n use core::ptr;\n-use core::{u8, u16, u32};\n+use core::{u16, u32, u8};\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+pub use core::slice::SliceIndex;\n+#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n+pub use core::slice::{from_mut, from_ref};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{Chunks, Windows};\n+pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{Iter, IterMut};\n+pub use core::slice::{Chunks, Windows};\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+pub use core::slice::{ChunksExact, ChunksExactMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{SplitMut, ChunksMut, Split};\n+pub use core::slice::{ChunksMut, Split, SplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n+pub use core::slice::{Iter, IterMut};\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+pub use core::slice::{RChunks, RChunksExact, RChunksExactMut, RChunksMut};\n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n-#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n-pub use core::slice::{from_ref, from_mut};\n-#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-pub use core::slice::SliceIndex;\n-#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n-pub use core::slice::{ChunksExact, ChunksExactMut};\n-#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n-pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n+pub use core::slice::{RSplitN, RSplitNMut, SplitN, SplitNMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -138,9 +137,9 @@ pub use hack::to_vec;\n // `test_permutations` test\n mod hack {\n     use crate::boxed::Box;\n-    use crate::vec::Vec;\n     #[cfg(test)]\n     use crate::string::ToString;\n+    use crate::vec::Vec;\n \n     pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n         unsafe {\n@@ -153,7 +152,8 @@ mod hack {\n \n     #[inline]\n     pub fn to_vec<T>(s: &[T]) -> Vec<T>\n-        where T: Clone\n+    where\n+        T: Clone,\n     {\n         let mut vector = Vec::with_capacity(s.len());\n         vector.extend_from_slice(s);\n@@ -193,7 +193,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort(&mut self)\n-        where T: Ord\n+    where\n+        T: Ord,\n     {\n         merge_sort(self, |a, b| a.lt(b));\n     }\n@@ -246,7 +247,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort_by<F>(&mut self, mut compare: F)\n-        where F: FnMut(&T, &T) -> Ordering\n+    where\n+        F: FnMut(&T, &T) -> Ordering,\n     {\n         merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n@@ -285,7 +287,9 @@ impl<T> [T] {\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n     pub fn sort_by_key<K, F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n+    where\n+        F: FnMut(&T) -> K,\n+        K: Ord,\n     {\n         merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n@@ -325,11 +329,13 @@ impl<T> [T] {\n     #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n+    where\n+        F: FnMut(&T) -> K,\n+        K: Ord,\n     {\n         // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n         macro_rules! sort_by_key {\n-            ($t:ty, $slice:ident, $f:ident) => ({\n+            ($t:ty, $slice:ident, $f:ident) => {{\n                 let mut indices: Vec<_> =\n                     $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n                 // The elements of `indices` are unique, as they are indexed, so any sort will be\n@@ -344,19 +350,27 @@ impl<T> [T] {\n                     indices[i].1 = index;\n                     $slice.swap(i, index as usize);\n                 }\n-            })\n+            }};\n         }\n \n-        let sz_u8    = mem::size_of::<(K, u8)>();\n-        let sz_u16   = mem::size_of::<(K, u16)>();\n-        let sz_u32   = mem::size_of::<(K, u32)>();\n+        let sz_u8 = mem::size_of::<(K, u8)>();\n+        let sz_u16 = mem::size_of::<(K, u16)>();\n+        let sz_u32 = mem::size_of::<(K, u32)>();\n         let sz_usize = mem::size_of::<(K, usize)>();\n \n         let len = self.len();\n-        if len < 2 { return }\n-        if sz_u8  < sz_u16   && len <= ( u8::MAX as usize) { return sort_by_key!( u8, self, f) }\n-        if sz_u16 < sz_u32   && len <= (u16::MAX as usize) { return sort_by_key!(u16, self, f) }\n-        if sz_u32 < sz_usize && len <= (u32::MAX as usize) { return sort_by_key!(u32, self, f) }\n+        if len < 2 {\n+            return;\n+        }\n+        if sz_u8 < sz_u16 && len <= (u8::MAX as usize) {\n+            return sort_by_key!(u8, self, f);\n+        }\n+        if sz_u16 < sz_u32 && len <= (u16::MAX as usize) {\n+            return sort_by_key!(u16, self, f);\n+        }\n+        if sz_u32 < sz_usize && len <= (u32::MAX as usize) {\n+            return sort_by_key!(u32, self, f);\n+        }\n         sort_by_key!(usize, self, f)\n     }\n \n@@ -373,7 +387,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_vec(&self) -> Vec<T>\n-        where T: Clone\n+    where\n+        T: Clone,\n     {\n         // N.B., see the `hack` module in this file for more details.\n         hack::to_vec(self)\n@@ -421,7 +436,10 @@ impl<T> [T] {\n     /// b\"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n-    pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {\n+    pub fn repeat(&self, n: usize) -> Vec<T>\n+    where\n+        T: Copy,\n+    {\n         if n == 0 {\n             return Vec::new();\n         }\n@@ -486,7 +504,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n-        where Self: Concat<Item>\n+    where\n+        Self: Concat<Item>,\n     {\n         Concat::concat(self)\n     }\n@@ -503,7 +522,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n     pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n-        where Self: Join<Separator>\n+    where\n+        Self: Join<Separator>,\n     {\n         Join::join(self, sep)\n     }\n@@ -521,11 +541,11 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n     pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n-        where Self: Join<Separator>\n+    where\n+        Self: Join<Separator>,\n     {\n         Join::join(self, sep)\n     }\n-\n }\n \n #[lang = \"slice_u8_alloc\"]\n@@ -668,8 +688,8 @@ impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() +\n-            sep.len() * (slice.len() - 1);\n+        let size =\n+            slice.iter().map(|v| v.borrow().len()).sum::<usize>() + sep.len() * (slice.len() - 1);\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n@@ -734,7 +754,8 @@ impl<T: Clone> ToOwned for [T] {\n ///\n /// This is the integral subroutine of insertion sort.\n fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     if v.len() >= 2 && is_less(&v[1], &v[0]) {\n         unsafe {\n@@ -767,10 +788,7 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n             // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n-            let mut hole = InsertionHole {\n-                src: &mut *tmp,\n-                dest: &mut v[1],\n-            };\n+            let mut hole = InsertionHole { src: &mut *tmp, dest: &mut v[1] };\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n@@ -792,7 +810,9 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n \n     impl<T> Drop for InsertionHole<T> {\n         fn drop(&mut self) {\n-            unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+            }\n         }\n     }\n }\n@@ -805,7 +825,8 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n /// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n /// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n@@ -834,11 +855,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n     if mid <= len - mid {\n         // The left run is shorter.\n         ptr::copy_nonoverlapping(v, buf, mid);\n-        hole = MergeHole {\n-            start: buf,\n-            end: buf.add(mid),\n-            dest: v,\n-        };\n+        hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n \n         // Initially, these pointers point to the beginnings of their arrays.\n         let left = &mut hole.start;\n@@ -858,11 +875,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n     } else {\n         // The right run is shorter.\n         ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n-        hole = MergeHole {\n-            start: buf,\n-            end: buf.add(len - mid),\n-            dest: v_mid,\n-        };\n+        hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n \n         // Initially, these pointers point past the ends of their arrays.\n         let left = &mut hole.dest;\n@@ -905,7 +918,9 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n         fn drop(&mut self) {\n             // `T` is not a zero-sized type, so it's okay to divide by its size.\n             let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n-            unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.start, self.dest, len);\n+            }\n         }\n     }\n }\n@@ -923,7 +938,8 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 20;\n@@ -940,7 +956,7 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     // Short arrays get sorted in-place via insertion sort to avoid allocations.\n     if len <= MAX_INSERTION {\n         if len >= 2 {\n-            for i in (0..len-1).rev() {\n+            for i in (0..len - 1).rev() {\n                 insert_head(&mut v[i..], &mut is_less);\n             }\n         }\n@@ -966,14 +982,13 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n             start -= 1;\n             unsafe {\n                 if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n-                    while start > 0 && is_less(v.get_unchecked(start),\n-                                               v.get_unchecked(start - 1)) {\n+                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n                         start -= 1;\n                     }\n                     v[start..end].reverse();\n                 } else {\n-                    while start > 0 && !is_less(v.get_unchecked(start),\n-                                                v.get_unchecked(start - 1)) {\n+                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n+                    {\n                         start -= 1;\n                     }\n                 }\n@@ -988,24 +1003,22 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n         }\n \n         // Push this run onto the stack.\n-        runs.push(Run {\n-            start,\n-            len: end - start,\n-        });\n+        runs.push(Run { start, len: end - start });\n         end = start;\n \n         // Merge some pairs of adjacent runs to satisfy the invariants.\n         while let Some(r) = collapse(&runs) {\n             let left = runs[r + 1];\n             let right = runs[r];\n             unsafe {\n-                merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n-                      &mut is_less);\n+                merge(\n+                    &mut v[left.start..right.start + right.len],\n+                    left.len,\n+                    buf.as_mut_ptr(),\n+                    &mut is_less,\n+                );\n             }\n-            runs[r] = Run {\n-                start: left.start,\n-                len: left.len + right.len,\n-            };\n+            runs[r] = Run { start: left.start, len: left.len + right.len };\n             runs.remove(r + 1);\n         }\n     }\n@@ -1030,15 +1043,13 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     #[inline]\n     fn collapse(runs: &[Run]) -> Option<usize> {\n         let n = runs.len();\n-        if n >= 2 && (runs[n - 1].start == 0 ||\n-                      runs[n - 2].len <= runs[n - 1].len ||\n-                      (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len) ||\n-                      (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len)) {\n-            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n-                Some(n - 3)\n-            } else {\n-                Some(n - 2)\n-            }\n+        if n >= 2\n+            && (runs[n - 1].start == 0\n+                || runs[n - 2].len <= runs[n - 1].len\n+                || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n+                || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n+        {\n+            if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }\n         } else {\n             None\n         }"}, {"sha": "19b0086fa333cc1a25005ff83c99b105c55232eb", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -341,6 +341,35 @@ impl<T> Arc<T> {\n         }\n     }\n \n+    /// Constructs a new `Arc` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let zero = Arc::<u32>::new_zeroed();\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0)\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            let mut uninit = Self::new_uninit();\n+            ptr::write_bytes::<T>(Arc::get_mut_unchecked(&mut uninit).as_mut_ptr(), 0, 1);\n+            uninit\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -751,7 +780,7 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>()\n             .extend(value_layout).unwrap().0\n-            .pad_to_align().unwrap();\n+            .pad_to_align();\n \n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n@@ -1295,10 +1324,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// It is up to the caller to ensure that the object is still alive when accessing it through\n-    /// the pointer.\n-    ///\n-    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n+    /// or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1379,14 +1406,18 @@ impl<T> Weak<T> {\n     /// This can be used to safely get a strong reference (by calling [`upgrade`]\n     /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n     ///\n-    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n-    /// returned.\n+    /// It takes ownership of one weak count (with the exception of pointers created by [`new`],\n+    /// as these don't have any corresponding weak count).\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n-    /// is or *was* managed by an [`Arc`] and the weak count of that [`Arc`] must not have reached\n-    /// 0. It is allowed for the strong count to be 0.\n+    /// The pointer must have originated from the [`into_raw`] (or [`as_raw'], provided there was\n+    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n+    /// count.\n+    ///\n+    /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n+    /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n+    /// by [`new`]).\n     ///\n     /// # Examples\n     ///\n@@ -1411,11 +1442,13 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`new`]: struct.Weak.html#method.new\n     /// [`into_raw`]: struct.Weak.html#method.into_raw\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`Weak`]: struct.Weak.html\n     /// [`Arc`]: struct.Arc.html\n+    /// [`forget`]: ../../std/mem/fn.forget.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {"}, {"sha": "1b6e0bb291c35c17aba17233df5f574a68b8f091", "filename": "src/liballoc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,12 +1,12 @@\n //! Test for `boxed` mod.\n \n use core::any::Any;\n-use core::convert::TryInto;\n-use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n use core::clone::Clone;\n+use core::convert::TryInto;\n use core::f64;\n use core::i64;\n+use core::ops::Deref;\n+use core::result::Result::{Err, Ok};\n \n use std::boxed::Box;\n "}, {"sha": "2fbb59b0419e020422fd77aa20ec45b3d52d48ac", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,9 +1,9 @@\n use std::any::Any;\n-use std::sync::{Arc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n use std::iter::TrustedLen;\n use std::mem;\n+use std::sync::{Arc, Weak};\n \n #[test]\n fn uninhabited() {\n@@ -12,16 +12,16 @@ fn uninhabited() {\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n \n-    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    let mut a: Weak<dyn Any> = a; // Unsizing\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n }\n \n #[test]\n fn slice() {\n     let a: Arc<[u32; 3]> = Arc::new([3, 2, 1]);\n-    let a: Arc<[u32]> = a;  // Unsizing\n-    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]);  // Conversion\n+    let a: Arc<[u32]> = a; // Unsizing\n+    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]); // Conversion\n     assert_eq!(a, b);\n \n     // Exercise is_dangling() with a DST\n@@ -33,7 +33,7 @@ fn slice() {\n #[test]\n fn trait_object() {\n     let a: Arc<u32> = Arc::new(4);\n-    let a: Arc<dyn Any> = a;  // Unsizing\n+    let a: Arc<dyn Any> = a; // Unsizing\n \n     // Exercise is_dangling() with a DST\n     let mut a = Arc::downgrade(&a);\n@@ -43,7 +43,7 @@ fn trait_object() {\n     let mut b = Weak::<u32>::new();\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n-    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    let mut b: Weak<dyn Any> = b; // Unsizing\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n@@ -57,7 +57,7 @@ fn float_nan_ne() {\n \n #[test]\n fn partial_eq() {\n-    struct TestPEq (RefCell<usize>);\n+    struct TestPEq(RefCell<usize>);\n     impl PartialEq for TestPEq {\n         fn eq(&self, other: &TestPEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -74,7 +74,7 @@ fn partial_eq() {\n #[test]\n fn eq() {\n     #[derive(Eq)]\n-    struct TestEq (RefCell<usize>);\n+    struct TestEq(RefCell<usize>);\n     impl PartialEq for TestEq {\n         fn eq(&self, other: &TestEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -160,13 +160,10 @@ fn shared_from_iter_trustedlen_normal() {\n fn shared_from_iter_trustedlen_panic() {\n     // Exercise the `TrustedLen` implementation when `size_hint()` matches\n     // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n-    let iter = (0..SHARED_ITER_MAX)\n-        .map(|val| {\n-            match val {\n-                98 => panic!(\"I've almost got 99 problems.\"),\n-                _ => Box::new(val),\n-            }\n-        });\n+    let iter = (0..SHARED_ITER_MAX).map(|val| match val {\n+        98 => panic!(\"I've almost got 99 problems.\"),\n+        _ => Box::new(val),\n+    });\n     assert_trusted_len(&iter);\n     let _ = iter.collect::<Rc<[_]>>();\n \n@@ -193,16 +190,8 @@ fn shared_from_iter_trustedlen_no_fuse() {\n         }\n     }\n \n-    let vec = vec![\n-        Some(Box::new(42)),\n-        Some(Box::new(24)),\n-        None,\n-        Some(Box::new(12)),\n-    ];\n+    let vec = vec![Some(Box::new(42)), Some(Box::new(24)), None, Some(Box::new(12))];\n     let iter = Iter(vec.into_iter());\n     assert_trusted_len(&iter);\n-    assert_eq!(\n-        &[Box::new(42), Box::new(24)],\n-        &*iter.collect::<Rc<[_]>>()\n-    );\n+    assert_eq!(&[Box::new(42), Box::new(24)], &*iter.collect::<Rc<[_]>>());\n }"}, {"sha": "a896a1064d9e17070bdef52f43e9cd0cc48dce1b", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -347,7 +347,7 @@ fn assert_covariance() {\n // Destructors must be called exactly once per element.\n // FIXME: re-enable emscripten once it can unwind again\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))] // Miri does not support catching panics\n+#[cfg(not(target_os = \"emscripten\"))]\n fn panic_safe() {\n     use std::cmp;\n     use std::panic::{self, AssertUnwindSafe};\n@@ -376,7 +376,10 @@ fn panic_safe() {\n     }\n     let mut rng = thread_rng();\n     const DATASZ: usize = 32;\n+    #[cfg(not(miri))] // Miri is too slow\n     const NTEST: usize = 10;\n+    #[cfg(miri)]\n+    const NTEST: usize = 1;\n \n     // don't use 0 in the data -- we want to catch the zeroed-out case.\n     let data = (1..=DATASZ).collect::<Vec<_>>();"}, {"sha": "66782ecbeb7f6deaa686e98206be3758f03fdd28", "filename": "src/liballoc/tests/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,5 +1,5 @@\n-use std::ptr::NonNull;\n use std::mem::MaybeUninit;\n+use std::ptr::NonNull;\n \n #[test]\n fn unitialized_zero_size_box() {"}, {"sha": "27843aeaeb0c80fa236a7d17fc900d1b079ec40f", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -58,15 +58,35 @@ fn test_basic_large() {\n fn test_basic_small() {\n     let mut map = BTreeMap::new();\n     assert_eq!(map.remove(&1), None);\n+    assert_eq!(map.len(), 0);\n+    assert_eq!(map.first_key_value(), None);\n+    assert_eq!(map.last_key_value(), None);\n     assert_eq!(map.get(&1), None);\n     assert_eq!(map.insert(1, 1), None);\n+    assert_eq!(map.len(), 1);\n     assert_eq!(map.get(&1), Some(&1));\n+    assert_eq!(map.first_key_value(), Some((&1, &1)));\n+    assert_eq!(map.last_key_value(), Some((&1, &1)));\n     assert_eq!(map.insert(1, 2), Some(1));\n+    assert_eq!(map.len(), 1);\n     assert_eq!(map.get(&1), Some(&2));\n+    assert_eq!(map.first_key_value(), Some((&1, &2)));\n+    assert_eq!(map.last_key_value(), Some((&1, &2)));\n     assert_eq!(map.insert(2, 4), None);\n+    assert_eq!(map.len(), 2);\n     assert_eq!(map.get(&2), Some(&4));\n+    assert_eq!(map.first_key_value(), Some((&1, &2)));\n+    assert_eq!(map.last_key_value(), Some((&2, &4)));\n     assert_eq!(map.remove(&1), Some(2));\n+    assert_eq!(map.len(), 1);\n+    assert_eq!(map.get(&1), None);\n+    assert_eq!(map.get(&2), Some(&4));\n+    assert_eq!(map.first_key_value(), Some((&2, &4)));\n+    assert_eq!(map.last_key_value(), Some((&2, &4)));\n     assert_eq!(map.remove(&2), Some(4));\n+    assert_eq!(map.len(), 0);\n+    assert_eq!(map.first_key_value(), None);\n+    assert_eq!(map.last_key_value(), None);\n     assert_eq!(map.remove(&1), None);\n }\n \n@@ -605,6 +625,31 @@ fn test_vacant_entry_key() {\n     assert_eq!(a[key], value);\n }\n \n+#[test]\n+fn test_first_last_entry() {\n+    let mut a = BTreeMap::new();\n+    assert!(a.first_entry().is_none());\n+    assert!(a.last_entry().is_none());\n+    a.insert(1, 42);\n+    assert_eq!(a.first_entry().unwrap().key(), &1);\n+    assert_eq!(a.last_entry().unwrap().key(), &1);\n+    a.insert(2, 24);\n+    assert_eq!(a.first_entry().unwrap().key(), &1);\n+    assert_eq!(a.last_entry().unwrap().key(), &2);\n+    a.insert(0, 6);\n+    assert_eq!(a.first_entry().unwrap().key(), &0);\n+    assert_eq!(a.last_entry().unwrap().key(), &2);\n+    let (k1, v1) = a.first_entry().unwrap().remove_entry();\n+    assert_eq!(k1, 0);\n+    assert_eq!(v1, 6);\n+    let (k2, v2) = a.last_entry().unwrap().remove_entry();\n+    assert_eq!(k2, 2);\n+    assert_eq!(v2, 24);\n+    assert_eq!(a.first_entry().unwrap().key(), &1);\n+    assert_eq!(a.last_entry().unwrap().key(), &1);\n+}\n+\n+\n macro_rules! create_append_test {\n     ($name:ident, $len:expr) => {\n         #[test]"}, {"sha": "1d08ae13e054011cd3e9f9285539fb15dfc34675", "filename": "src/liballoc/tests/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -11,12 +11,7 @@ struct DeterministicRng {\n \n impl DeterministicRng {\n     fn new() -> Self {\n-        DeterministicRng {\n-            x: 0x193a6754,\n-            y: 0xa8a7d469,\n-            z: 0x97830e05,\n-            w: 0x113ba7bb,\n-        }\n+        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n     }\n \n     fn next(&mut self) -> u32 {"}, {"sha": "13cd26280227ec62931762f138a55d177564696a", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -470,6 +470,34 @@ fn test_append() {\n     assert_eq!(a.contains(&5), true);\n }\n \n+#[test]\n+fn test_first_last() {\n+    let mut a = BTreeSet::new();\n+    assert_eq!(a.first(), None);\n+    assert_eq!(a.last(), None);\n+    a.insert(1);\n+    assert_eq!(a.first(), Some(&1));\n+    assert_eq!(a.last(), Some(&1));\n+    a.insert(2);\n+    assert_eq!(a.first(), Some(&1));\n+    assert_eq!(a.last(), Some(&2));\n+    a.insert(3);\n+    assert_eq!(a.first(), Some(&1));\n+    assert_eq!(a.last(), Some(&3));\n+\n+    assert_eq!(a.len(), 3);\n+    assert_eq!(a.pop_first(), Some(1));\n+    assert_eq!(a.len(), 2);\n+    assert_eq!(a.pop_last(), Some(3));\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(a.pop_first(), Some(2));\n+    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_last(), None);\n+    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_first(), None);\n+    assert_eq!(a.len(), 0);\n+}\n+\n fn rand_data(len: usize) -> Vec<u32> {\n     let mut rng = DeterministicRng::new();\n     Vec::from_iter((0..len).map(|_| rng.next()))"}, {"sha": "605e0ef55d707080410e146cceea8c6b8a3ce76f", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -2,6 +2,7 @@\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n+#![feature(map_first_last)]\n #![feature(new_uninit)]\n #![feature(pattern)]\n #![feature(trusted_len)]"}, {"sha": "daa49c48c6a92461532c3dfe97ca08b8f0536976", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 30, "deletions": 45, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -102,7 +102,6 @@ fn test_split_off() {\n         assert_eq!(m.back(), Some(&1));\n         assert_eq!(m.front(), Some(&1));\n     }\n-\n }\n \n #[test]\n@@ -305,8 +304,7 @@ fn test_show() {\n     assert_eq!(format!(\"{:?}\", list), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n     let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-    assert_eq!(format!(\"{:?}\", list),\n-               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -446,19 +444,14 @@ fn drain_filter_true() {\n \n #[test]\n fn drain_filter_complex() {\n-\n-    {   //                [+xxx++++++xxxxx++++x+x++]\n+    {\n+        //                [+xxx++++++xxxxx++++x+x++]\n         let mut list = vec![\n-            1,\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36,\n-            37, 39\n-        ].into_iter().collect::<LinkedList<_>>();\n+            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n+            39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -471,17 +464,13 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxx++++++xxxxx++++x+x++]\n+    {\n+        // [xxx++++++xxxxx++++x+x++]\n         let mut list = vec![\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36,\n-            37, 39\n-        ].into_iter().collect::<LinkedList<_>>();\n+            2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -494,16 +483,12 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxx++++++xxxxx++++x+x]\n-        let mut list = vec![\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [xxx++++++xxxxx++++x+x]\n+        let mut list =\n+            vec![2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36]\n+                .into_iter()\n+                .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -516,11 +501,11 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxxxxxxxxx+++++++++++]\n-        let mut list = vec![\n-            2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n-            1, 3, 5, 7, 9, 11, 13, 15, 17, 19\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [xxxxxxxxxx+++++++++++]\n+        let mut list = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -530,11 +515,11 @@ fn drain_filter_complex() {\n         assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n \n-    {   // [+++++++++++xxxxxxxxxx]\n-        let mut list = vec![\n-            1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n-            2, 4, 6, 8, 10, 12, 14, 16, 18, 20\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [+++++++++++xxxxxxxxxx]\n+        let mut list = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);"}, {"sha": "e77c57d9a5a09ef38b6721587799b0191b51d71f", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,9 +1,9 @@\n use std::any::Any;\n-use std::rc::{Rc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n-use std::mem;\n use std::iter::TrustedLen;\n+use std::mem;\n+use std::rc::{Rc, Weak};\n \n #[test]\n fn uninhabited() {\n@@ -12,16 +12,16 @@ fn uninhabited() {\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n \n-    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    let mut a: Weak<dyn Any> = a; // Unsizing\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n }\n \n #[test]\n fn slice() {\n     let a: Rc<[u32; 3]> = Rc::new([3, 2, 1]);\n-    let a: Rc<[u32]> = a;  // Unsizing\n-    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]);  // Conversion\n+    let a: Rc<[u32]> = a; // Unsizing\n+    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]); // Conversion\n     assert_eq!(a, b);\n \n     // Exercise is_dangling() with a DST\n@@ -33,7 +33,7 @@ fn slice() {\n #[test]\n fn trait_object() {\n     let a: Rc<u32> = Rc::new(4);\n-    let a: Rc<dyn Any> = a;  // Unsizing\n+    let a: Rc<dyn Any> = a; // Unsizing\n \n     // Exercise is_dangling() with a DST\n     let mut a = Rc::downgrade(&a);\n@@ -43,7 +43,7 @@ fn trait_object() {\n     let mut b = Weak::<u32>::new();\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n-    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    let mut b: Weak<dyn Any> = b; // Unsizing\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n@@ -57,7 +57,7 @@ fn float_nan_ne() {\n \n #[test]\n fn partial_eq() {\n-    struct TestPEq (RefCell<usize>);\n+    struct TestPEq(RefCell<usize>);\n     impl PartialEq for TestPEq {\n         fn eq(&self, other: &TestPEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -74,7 +74,7 @@ fn partial_eq() {\n #[test]\n fn eq() {\n     #[derive(Eq)]\n-    struct TestEq (RefCell<usize>);\n+    struct TestEq(RefCell<usize>);\n     impl PartialEq for TestEq {\n         fn eq(&self, other: &TestEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -156,13 +156,10 @@ fn shared_from_iter_trustedlen_normal() {\n fn shared_from_iter_trustedlen_panic() {\n     // Exercise the `TrustedLen` implementation when `size_hint()` matches\n     // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n-    let iter = (0..SHARED_ITER_MAX)\n-        .map(|val| {\n-            match val {\n-                98 => panic!(\"I've almost got 99 problems.\"),\n-                _ => Box::new(val),\n-            }\n-        });\n+    let iter = (0..SHARED_ITER_MAX).map(|val| match val {\n+        98 => panic!(\"I've almost got 99 problems.\"),\n+        _ => Box::new(val),\n+    });\n     assert_trusted_len(&iter);\n     let _ = iter.collect::<Rc<[_]>>();\n \n@@ -189,16 +186,8 @@ fn shared_from_iter_trustedlen_no_fuse() {\n         }\n     }\n \n-    let vec = vec![\n-        Some(Box::new(42)),\n-        Some(Box::new(24)),\n-        None,\n-        Some(Box::new(12)),\n-    ];\n+    let vec = vec![Some(Box::new(42)), Some(Box::new(24)), None, Some(Box::new(12))];\n     let iter = Iter(vec.into_iter());\n     assert_trusted_len(&iter);\n-    assert_eq!(\n-        &[Box::new(42), Box::new(24)],\n-        &*iter.collect::<Rc<[_]>>()\n-    );\n+    assert_eq!(&[Box::new(42), Box::new(24)], &*iter.collect::<Rc<[_]>>());\n }"}, {"sha": "d9707b95740785bc4600d0973da1c2f6b5f093a9", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,7 +4,6 @@ use std::mem;\n use std::panic;\n use std::rc::Rc;\n use std::sync::atomic::{Ordering::Relaxed, AtomicUsize};\n-use std::thread;\n \n use rand::{Rng, RngCore, thread_rng};\n use rand::seq::SliceRandom;\n@@ -1406,11 +1405,9 @@ fn test_box_slice_clone() {\n #[test]\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support threads\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n-    use std::thread::spawn;\n \n     struct Canary {\n         count: Arc<AtomicUsize>,\n@@ -1446,15 +1443,14 @@ fn test_box_slice_clone_panics() {\n         panics: true,\n     };\n \n-    spawn(move || {\n+    std::panic::catch_unwind(move || {\n             // When xs is dropped, +5.\n             let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n                 .into_boxed_slice();\n \n             // When panic is cloned, +3.\n             xs.clone();\n         })\n-        .join()\n         .unwrap_err();\n \n     // Total = 8\n@@ -1566,7 +1562,7 @@ macro_rules! test {\n             }\n \n             let v = $input.to_owned();\n-            let _ = thread::spawn(move || {\n+            let _ = std::panic::catch_unwind(move || {\n                 let mut v = v;\n                 let mut panic_countdown = panic_countdown;\n                 v.$func(|a, b| {\n@@ -1577,7 +1573,7 @@ macro_rules! test {\n                     panic_countdown -= 1;\n                     a.cmp(b)\n                 })\n-            }).join();\n+            });\n \n             // Check that the number of things dropped is exactly\n             // what we expect (i.e., the contents of `v`).\n@@ -1598,7 +1594,6 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n-#[cfg(not(miri))] // Miri does not support threads\n fn panic_safe() {\n     let prev = panic::take_hook();\n     panic::set_hook(Box::new(move |info| {\n@@ -1609,8 +1604,18 @@ fn panic_safe() {\n \n     let mut rng = thread_rng();\n \n-    for len in (1..20).chain(70..MAX_LEN) {\n-        for &modulus in &[5, 20, 50] {\n+    #[cfg(not(miri))] // Miri is too slow\n+    let lens = (1..20).chain(70..MAX_LEN);\n+    #[cfg(not(miri))] // Miri is too slow\n+    let moduli = &[5, 20, 50];\n+\n+    #[cfg(miri)]\n+    let lens = (1..13);\n+    #[cfg(miri)]\n+    let moduli = &[10];\n+\n+    for len in lens {\n+        for &modulus in moduli {\n             for &has_runs in &[false, true] {\n                 let mut input = (0..len)\n                     .map(|id| {\n@@ -1643,6 +1648,9 @@ fn panic_safe() {\n             }\n         }\n     }\n+\n+    // Set default panic hook again.\n+    drop(panic::take_hook());\n }\n \n #[test]"}, {"sha": "9ee254f99acdfa34611443c5fee088580fa79f66", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -944,10 +944,9 @@ fn drain_filter_complex() {\n     }\n }\n \n-// Miri does not support catching panics\n // FIXME: re-enable emscripten once it can unwind again\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))]\n+#[cfg(not(target_os = \"emscripten\"))]\n fn drain_filter_consumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;\n@@ -985,7 +984,7 @@ fn drain_filter_consumed_panic() {\n         };\n         let drain = data.drain_filter(filter);\n \n-        // NOTE: The DrainFilter is explictly consumed\n+        // NOTE: The DrainFilter is explicitly consumed\n         drain.for_each(drop);\n     });\n \n@@ -999,7 +998,7 @@ fn drain_filter_consumed_panic() {\n \n // FIXME: Re-enable emscripten once it can catch panics\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))] // Miri does not support catching panics\n+#[cfg(not(target_os = \"emscripten\"))]\n fn drain_filter_unconsumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;"}, {"sha": "5a0162a536175295cb89b0e9897afc6efe88395e", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,8 +1,8 @@\n-use std::fmt::Debug;\n-use std::collections::{VecDeque, vec_deque::Drain};\n use std::collections::TryReserveError::*;\n+use std::collections::{vec_deque::Drain, VecDeque};\n+use std::fmt::Debug;\n use std::mem::size_of;\n-use std::{usize, isize};\n+use std::{isize, usize};\n \n use crate::hash;\n \n@@ -148,34 +148,20 @@ fn test_param_taggy() {\n \n #[test]\n fn test_param_taggypar() {\n-    test_parameterized::<Taggypar<i32>>(Onepar::<i32>(1),\n-                                        Twopar::<i32>(1, 2),\n-                                        Threepar::<i32>(1, 2, 3),\n-                                        Twopar::<i32>(17, 42));\n+    test_parameterized::<Taggypar<i32>>(\n+        Onepar::<i32>(1),\n+        Twopar::<i32>(1, 2),\n+        Threepar::<i32>(1, 2, 3),\n+        Twopar::<i32>(17, 42),\n+    );\n }\n \n #[test]\n fn test_param_reccy() {\n-    let reccy1 = RecCy {\n-        x: 1,\n-        y: 2,\n-        t: One(1),\n-    };\n-    let reccy2 = RecCy {\n-        x: 345,\n-        y: 2,\n-        t: Two(1, 2),\n-    };\n-    let reccy3 = RecCy {\n-        x: 1,\n-        y: 777,\n-        t: Three(1, 2, 3),\n-    };\n-    let reccy4 = RecCy {\n-        x: 19,\n-        y: 252,\n-        t: Two(17, 42),\n-    };\n+    let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n+    let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n+    let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n+    let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n     test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n }\n \n@@ -320,8 +306,7 @@ fn test_mut_rev_iter_wrap() {\n     assert_eq!(d.pop_front(), Some(1));\n     d.push_back(4);\n \n-    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(),\n-               vec![4, 3, 2]);\n+    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(), vec![4, 3, 2]);\n }\n \n #[test]\n@@ -372,7 +357,6 @@ fn test_mut_rev_iter() {\n \n #[test]\n fn test_into_iter() {\n-\n     // Empty iter\n     {\n         let d: VecDeque<i32> = VecDeque::new();\n@@ -431,7 +415,6 @@ fn test_into_iter() {\n \n #[test]\n fn test_drain() {\n-\n     // Empty iter\n     {\n         let mut d: VecDeque<i32> = VecDeque::new();\n@@ -650,12 +633,8 @@ fn test_show() {\n     let ringbuf: VecDeque<_> = (0..10).collect();\n     assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"]\n-        .iter()\n-        .cloned()\n-        .collect();\n-    assert_eq!(format!(\"{:?}\", ringbuf),\n-               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n+    assert_eq!(format!(\"{:?}\", ringbuf), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -955,7 +934,6 @@ fn test_append_permutations() {\n             // doesn't pop more values than are pushed\n             for src_pop_back in 0..(src_push_back + src_push_front) {\n                 for src_pop_front in 0..(src_push_back + src_push_front - src_pop_back) {\n-\n                     let src = construct_vec_deque(\n                         src_push_back,\n                         src_pop_back,\n@@ -966,8 +944,8 @@ fn test_append_permutations() {\n                     for dst_push_back in 0..MAX {\n                         for dst_push_front in 0..MAX {\n                             for dst_pop_back in 0..(dst_push_back + dst_push_front) {\n-                                for dst_pop_front\n-                                    in 0..(dst_push_back + dst_push_front - dst_pop_back)\n+                                for dst_pop_front in\n+                                    0..(dst_push_back + dst_push_front - dst_pop_back)\n                                 {\n                                     let mut dst = construct_vec_deque(\n                                         dst_push_back,\n@@ -1124,7 +1102,6 @@ fn test_reserve_exact_2() {\n #[test]\n #[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n-\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n     // * > isize::MAX should always fail\n@@ -1158,22 +1135,27 @@ fn test_try_reserve() {\n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             // Check usize::MAX does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n@@ -1186,47 +1168,54 @@ fn test_try_reserve() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should always overflow in the add-to-len\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should fail in the mul-by-size\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n     }\n-\n }\n \n #[test]\n #[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n-\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n \n@@ -1247,21 +1236,26 @@ fn test_try_reserve_exact() {\n \n         if guards_against_isize {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n@@ -1273,36 +1267,46 @@ fn test_try_reserve_exact() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n-\n }\n \n #[test]\n@@ -1404,9 +1408,8 @@ fn test_rotate_right_parts() {\n #[test]\n fn test_rotate_left_random() {\n     let shifts = [\n-        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n-        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n-        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1, 4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11, 9, 4, 12, 3,\n+        12, 9, 11, 1, 7, 9, 7, 2,\n     ];\n     let n = 12;\n     let mut v: VecDeque<_> = (0..n).collect();\n@@ -1423,9 +1426,8 @@ fn test_rotate_left_random() {\n #[test]\n fn test_rotate_right_random() {\n     let shifts = [\n-        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n-        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n-        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1, 4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11, 9, 4, 12, 3,\n+        12, 9, 11, 1, 7, 9, 7, 2,\n     ];\n     let n = 12;\n     let mut v: VecDeque<_> = (0..n).collect();\n@@ -1447,8 +1449,7 @@ fn test_try_fold_empty() {\n #[test]\n fn test_try_fold_none() {\n     let v: VecDeque<u32> = (0..12).collect();\n-    assert_eq!(None, v.into_iter().try_fold(0, |a, b|\n-        if b < 11 { Some(a + b) } else { None }));\n+    assert_eq!(None, v.into_iter().try_fold(0, |a, b| if b < 11 { Some(a + b) } else { None }));\n }\n \n #[test]\n@@ -1463,7 +1464,6 @@ fn test_try_fold_unit() {\n     assert_eq!(Some(()), v.into_iter().try_fold((), |(), ()| Some(())));\n }\n \n-\n #[test]\n fn test_try_fold_unit_none() {\n     let v: std::collections::VecDeque<()> = [(); 10].iter().cloned().collect();\n@@ -1534,7 +1534,7 @@ fn test_try_rfold_rotated() {\n \n #[test]\n fn test_try_rfold_moves_iter() {\n-    let v : VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n+    let v: VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n     let mut iter = v.into_iter();\n     assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n     assert_eq!(iter.next_back(), Some(&70));"}, {"sha": "1a700b990569c39ac854f72150200a3131e64463", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -629,6 +629,8 @@ impl<T> Vec<T> {\n     /// The capacity will remain at least as large as both the length\n     /// and the supplied value.\n     ///\n+    /// # Panics\n+    ///\n     /// Panics if the current capacity is smaller than the supplied\n     /// minimum capacity.\n     ///\n@@ -727,25 +729,20 @@ impl<T> Vec<T> {\n     /// [`drain`]: #method.drain\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: usize) {\n-        if mem::needs_drop::<T>() {\n-            let current_len = self.len;\n-            unsafe {\n-                let mut ptr = self.as_mut_ptr().add(self.len);\n-                // Set the final length at the end, keeping in mind that\n-                // dropping an element might panic. Works around a missed\n-                // optimization, as seen in the following issue:\n-                // https://github.com/rust-lang/rust/issues/51802\n-                let mut local_len = SetLenOnDrop::new(&mut self.len);\n-\n-                // drop any extra elements\n-                for _ in len..current_len {\n-                    local_len.decrement_len(1);\n-                    ptr = ptr.offset(-1);\n-                    ptr::drop_in_place(ptr);\n-                }\n+        // This is safe because:\n+        //\n+        // * the slice passed to `drop_in_place` is valid; the `len > self.len`\n+        //   case avoids creating an invalid slice, and\n+        // * the `len` of the vector is shrunk before calling `drop_in_place`,\n+        //   such that no value will be dropped twice in case `drop_in_place`\n+        //   were to panic once (if it panics twice, the program aborts).\n+        unsafe {\n+            if len > self.len {\n+                return;\n             }\n-        } else if len <= self.len {\n+            let s = self.get_unchecked_mut(len..) as *mut _;\n             self.len = len;\n+            ptr::drop_in_place(s);\n         }\n     }\n \n@@ -861,7 +858,7 @@ impl<T> Vec<T> {\n     ///\n     /// [`truncate`]: #method.truncate\n     /// [`resize`]: #method.resize\n-    /// [`extend`]: #method.extend-1\n+    /// [`extend`]: ../../std/iter/trait.Extend.html#tymethod.extend\n     /// [`clear`]: #method.clear\n     ///\n     /// # Safety\n@@ -1338,10 +1335,9 @@ impl<T> Vec<T> {\n \n     /// Splits the collection into two at the given index.\n     ///\n-    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n-    /// and the returned `Self` contains elements `[at, len)`.\n-    ///\n-    /// Note that the capacity of `self` does not change.\n+    /// Returns a newly allocated vector containing the elements in the range\n+    /// `[at, len)`. After the call, the original vector will be left containing\n+    /// the elements `[0, at)` with its previous capacity unchanged.\n     ///\n     /// # Panics\n     ///\n@@ -1630,11 +1626,6 @@ impl<'a> SetLenOnDrop<'a> {\n     fn increment_len(&mut self, increment: usize) {\n         self.local_len += increment;\n     }\n-\n-    #[inline]\n-    fn decrement_len(&mut self, decrement: usize) {\n-        self.local_len -= decrement;\n-    }\n }\n \n impl Drop for SetLenOnDrop<'_> {\n@@ -2712,6 +2703,9 @@ impl<T> ExactSizeIterator for Drain<'_, T> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Drain<'_, T> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Drain<'_, T> {}\n \n@@ -2848,7 +2842,7 @@ pub struct DrainFilter<'a, T, F>\n     old_len: usize,\n     /// The filter test predicate.\n     pred: F,\n-    /// A flag that indicates a panic has occured in the filter test prodicate.\n+    /// A flag that indicates a panic has occurred in the filter test prodicate.\n     /// This is used as a hint in the drop implmentation to prevent consumption\n     /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n     /// backshifted in the `vec`, but no further items will be dropped or"}, {"sha": "20248f7f6c13e374e471f423a37b48ef14556f24", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -53,7 +53,7 @@ pub struct Layout {\n \n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `LayoutErr` if either of the following conditions\n+    /// or returns `LayoutErr` if any of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must not be zero,\n@@ -137,7 +137,7 @@ impl Layout {\n     #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n-        // See rationale in `new` for why this us using an unsafe variant below\n+        // See rationale in `new` for why this is using an unsafe variant below\n         debug_assert!(Layout::from_size_align(size, align).is_ok());\n         unsafe {\n             Layout::from_size_align_unchecked(size, align)\n@@ -196,7 +196,7 @@ impl Layout {\n         //    valid.\n         //\n         // 2. `len + align - 1` can overflow by at most `align - 1`,\n-        //    so the &-mask wth `!(align - 1)` will ensure that in the\n+        //    so the &-mask with `!(align - 1)` will ensure that in the\n         //    case of overflow, `len_rounded_up` will itself be 0.\n         //    Thus the returned padding, when added to `len`, yields 0,\n         //    which trivially satisfies the alignment `align`.\n@@ -213,18 +213,19 @@ impl Layout {\n     /// Creates a layout by rounding the size of this layout up to a multiple\n     /// of the layout's alignment.\n     ///\n-    /// Returns `Err` if the padded size would overflow.\n-    ///\n     /// This is equivalent to adding the result of `padding_needed_for`\n     /// to the layout's current size.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n-    pub fn pad_to_align(&self) -> Result<Layout, LayoutErr> {\n+    pub fn pad_to_align(&self) -> Layout {\n         let pad = self.padding_needed_for(self.align());\n-        let new_size = self.size().checked_add(pad)\n-            .ok_or(LayoutErr { private: () })?;\n+        // This cannot overflow. Quoting from the invariant of Layout:\n+        // > `size`, when rounded up to the nearest multiple of `align`,\n+        // > must not overflow (i.e., the rounded value must be less than\n+        // > `usize::MAX`)\n+        let new_size = self.size() + pad;\n \n-        Layout::from_size_align(new_size, self.align())\n+        Layout::from_size_align(new_size, self.align()).unwrap()\n     }\n \n     /// Creates a layout describing the record for `n` instances of"}, {"sha": "466750fc7d2c63035f6f4cc46cba596ccf5827fe", "filename": "src/libcore/any.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -68,7 +68,7 @@ use crate::intrinsics;\n // Any trait\n ///////////////////////////////////////////////////////////////////////////////\n \n-/// A type to emulate dynamic typing.\n+/// A trait to emulate dynamic typing.\n ///\n /// Most types implement `Any`. However, any type which contains a non-`'static` reference does not.\n /// See the [module-level documentation][mod] for more details.\n@@ -452,7 +452,7 @@ impl TypeId {\n /// The current implementation uses the same infrastructure as compiler\n /// diagnostics and debuginfo, but this is not guaranteed.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```rust\n /// assert_eq!(\n@@ -465,3 +465,42 @@ impl TypeId {\n pub const fn type_name<T: ?Sized>() -> &'static str {\n     intrinsics::type_name::<T>()\n }\n+\n+/// Returns the name of the type of the pointed-to value as a string slice.\n+/// This is the same as `type_name::<T>()`, but can be used where the type of a\n+/// variable is not easily available.\n+///\n+/// # Note\n+///\n+/// This is intended for diagnostic use. The exact contents and format of the\n+/// string are not specified, other than being a best-effort description of the\n+/// type. For example, `type_name_of::<Option<String>>(None)` could return the\n+/// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n+/// `\"foobar\"`. In addition, the output may change between versions of the\n+/// compiler.\n+///\n+/// The type name should not be considered a unique identifier of a type;\n+/// multiple types may share the same type name.\n+///\n+/// The current implementation uses the same infrastructure as compiler\n+/// diagnostics and debuginfo, but this is not guaranteed.\n+///\n+/// # Examples\n+///\n+/// Prints the default integer and float types.\n+///\n+/// ```rust\n+/// #![feature(type_name_of_val)]\n+/// use std::any::type_name_of_val;\n+///\n+/// let x = 1;\n+/// println!(\"{}\", type_name_of_val(&x));\n+/// let y = 1.0;\n+/// println!(\"{}\", type_name_of_val(&y));\n+/// ```\n+#[unstable(feature = \"type_name_of_val\", issue = \"66359\")]\n+#[rustc_const_unstable(feature = \"const_type_name\")]\n+pub const fn type_name_of_val<T: ?Sized>(val: &T) -> &'static str {\n+    let _ = val;\n+    type_name::<T>()\n+}"}, {"sha": "aab9463e3aade248452fb74a883dd77e92ab28a4", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -92,6 +92,18 @@ where\n             mem::transmute::<&[MaybeUninit<T>], &[T]>(slice)\n         }\n     }\n+\n+    /// Returns a mutable slice of all elements that have not been yielded yet.\n+    fn as_mut_slice(&mut self) -> &mut [T] {\n+        // This transmute is safe, same as in `as_slice` above.\n+        let slice = &mut self.data[self.alive.clone()];\n+        // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n+        // the size and alignment of `T`. Furthermore, we know that all\n+        // elements within `alive` are properly initialized.\n+        unsafe {\n+            mem::transmute::<&mut [MaybeUninit<T>], &mut [T]>(slice)\n+        }\n+    }\n }\n \n \n@@ -184,10 +196,12 @@ where\n     [T; N]: LengthAtMost32,\n {\n     fn drop(&mut self) {\n-        // We simply drop each element via `for_each`. This should not incur\n-        // any significant runtime overhead and avoids adding another `unsafe`\n-        // block.\n-        self.by_ref().for_each(drop);\n+        // SAFETY: This is safe: `as_mut_slice` returns exactly the sub-slice\n+        // of elements that have not been moved out yet and that remain\n+        // to be dropped.\n+        unsafe {\n+            ptr::drop_in_place(self.as_mut_slice())\n+        }\n     }\n }\n "}, {"sha": "38d248d701d4a96138aec8877b50ead1bd5fd792", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,5 +1,5 @@\n //! Implementations of things like `Eq` for fixed-length arrays\n-//! up to a certain length. Eventually we should able to generalize\n+//! up to a certain length. Eventually, we should be able to generalize\n //! to all lengths.\n //!\n //! *[See also the array primitive type](../../std/primitive.array.html).*\n@@ -14,10 +14,8 @@ use crate::hash::{Hash, self};\n use crate::marker::Unsize;\n use crate::slice::{Iter, IterMut};\n \n-#[cfg(not(bootstrap))]\n mod iter;\n \n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n pub use iter::IntoIter;\n "}, {"sha": "e78dfd1ed4abfca43a6b2d1d304b78ff505790ca", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -12,8 +12,8 @@\n #![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n \n use crate::fmt;\n-use crate::ops::Range;\n use crate::iter::FusedIterator;\n+use crate::ops::Range;\n use crate::str::from_utf8_unchecked;\n \n /// An iterator over the escaped version of a byte.\n@@ -100,15 +100,15 @@ pub fn escape_default(c: u8) -> EscapeDefault {\n         b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n         b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n         b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n-        b'\\x20' ..= b'\\x7e' => ([c, 0, 0, 0], 1),\n+        b'\\x20'..=b'\\x7e' => ([c, 0, 0, 0], 1),\n         _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n     };\n \n     return EscapeDefault { range: 0..len, data };\n \n     fn hexify(b: u8) -> u8 {\n         match b {\n-            0 ..= 9 => b'0' + b,\n+            0..=9 => b'0' + b,\n             _ => b'a' + b - 10,\n         }\n     }\n@@ -117,9 +117,15 @@ pub fn escape_default(c: u8) -> EscapeDefault {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeDefault {\n     type Item = u8;\n-    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n-    fn last(mut self) -> Option<u8> { self.next_back() }\n+    fn next(&mut self) -> Option<u8> {\n+        self.range.next().map(|i| self.data[i])\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.range.size_hint()\n+    }\n+    fn last(mut self) -> Option<u8> {\n+        self.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl DoubleEndedIterator for EscapeDefault {"}, {"sha": "2dcdf2b6fe9f71e60080c0e66cf07abaa2f408fe", "filename": "src/libcore/benches/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -35,7 +35,7 @@ macro_rules! from_str_bench {\n                     .iter()\n                     .cycle()\n                     .take(5_000)\n-                    .filter_map(|s| <($t)>::from_str(s).ok())\n+                    .filter_map(|s| <$t>::from_str(s).ok())\n                     .max()\n             })\n         }\n@@ -51,7 +51,7 @@ macro_rules! from_str_radix_bench {\n                     .iter()\n                     .cycle()\n                     .take(5_000)\n-                    .filter_map(|s| <($t)>::from_str_radix(s, $radix).ok())\n+                    .filter_map(|s| <$t>::from_str_radix(s, $radix).ok())\n                     .max()\n             })\n         }"}, {"sha": "1b3c254a05f98126a3ff6b0a47ed1b407dba3671", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -9,12 +9,12 @@ impl bool {\n     /// ```\n     /// #![feature(bool_to_option)]\n     ///\n-    /// assert_eq!(false.then(0), None);\n-    /// assert_eq!(true.then(0), Some(0));\n+    /// assert_eq!(false.then_some(0), None);\n+    /// assert_eq!(true.then_some(0), Some(0));\n     /// ```\n     #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n     #[inline]\n-    pub fn then<T>(self, t: T) -> Option<T> {\n+    pub fn then_some<T>(self, t: T) -> Option<T> {\n         if self {\n             Some(t)\n         } else {\n@@ -29,12 +29,12 @@ impl bool {\n     /// ```\n     /// #![feature(bool_to_option)]\n     ///\n-    /// assert_eq!(false.then_with(|| 0), None);\n-    /// assert_eq!(true.then_with(|| 0), Some(0));\n+    /// assert_eq!(false.then(|| 0), None);\n+    /// assert_eq!(true.then(|| 0), Some(0));\n     /// ```\n     #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n     #[inline]\n-    pub fn then_with<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n+    pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n         if self {\n             Some(f())\n         } else {"}, {"sha": "03f32e726187b09ea86af46601df58465cd16c31", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1545,9 +1545,46 @@ impl<T: ?Sized> UnsafeCell<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn get(&self) -> *mut T {\n         // We can just cast the pointer from `UnsafeCell<T>` to `T` because of\n-        // #[repr(transparent)]\n+        // #[repr(transparent)]. This exploits libstd's special status, there is\n+        // no guarantee for user code that this will work in future versions of the compiler!\n         self as *const UnsafeCell<T> as *const T as *mut T\n     }\n+\n+    /// Gets a mutable pointer to the wrapped value.\n+    /// The difference to [`get`] is that this function accepts a raw pointer,\n+    /// which is useful to avoid the creation of temporary references.\n+    ///\n+    /// The result can be cast to a pointer of any kind.\n+    /// Ensure that the access is unique (no active references, mutable or not)\n+    /// when casting to `&mut T`, and ensure that there are no mutations\n+    /// or mutable aliases going on when casting to `&T`.\n+    ///\n+    /// [`get`]: #method.get\n+    ///\n+    /// # Examples\n+    ///\n+    /// Gradual initialization of an `UnsafeCell` requires `raw_get`, as\n+    /// calling `get` would require creating a reference to uninitialized data:\n+    ///\n+    /// ```\n+    /// #![feature(unsafe_cell_raw_get)]\n+    /// use std::cell::UnsafeCell;\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let m = MaybeUninit::<UnsafeCell<i32>>::uninit();\n+    /// unsafe { UnsafeCell::raw_get(m.as_ptr()).write(5); }\n+    /// let uc = unsafe { m.assume_init() };\n+    ///\n+    /// assert_eq!(uc.into_inner(), 5);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"unsafe_cell_raw_get\", issue = \"66358\")]\n+    pub const fn raw_get(this: *const Self) -> *mut T {\n+        // We can just cast the pointer from `UnsafeCell<T>` to `T` because of\n+        // #[repr(transparent)]. This exploits libstd's special status, there is\n+        // no guarantee for user code that this will work in future versions of the compiler!\n+        this as *const T as *mut T\n+    }\n }\n \n #[stable(feature = \"unsafe_cell_default\", since = \"1.10.0\")]"}, {"sha": "dd21c72e745dd70498f59caf1220b999ff4be538", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -158,7 +158,6 @@ impl From<u8> for char {\n     }\n }\n \n-\n /// An error which can be returned when parsing a char.\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -167,16 +166,16 @@ pub struct ParseCharError {\n }\n \n impl ParseCharError {\n-    #[unstable(feature = \"char_error_internals\",\n-               reason = \"this method should not be available publicly\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"char_error_internals\",\n+        reason = \"this method should not be available publicly\",\n+        issue = \"0\"\n+    )]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n         match self.kind {\n-            CharErrorKind::EmptyString => {\n-                \"cannot parse char from empty string\"\n-            },\n-            CharErrorKind::TooManyChars => \"too many characters in string\"\n+            CharErrorKind::EmptyString => \"cannot parse char from empty string\",\n+            CharErrorKind::TooManyChars => \"too many characters in string\",\n         }\n     }\n }\n@@ -194,7 +193,6 @@ impl fmt::Display for ParseCharError {\n     }\n }\n \n-\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n impl FromStr for char {\n     type Err = ParseCharError;\n@@ -203,18 +201,13 @@ impl FromStr for char {\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         let mut chars = s.chars();\n         match (chars.next(), chars.next()) {\n-            (None, _) => {\n-                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n-            },\n+            (None, _) => Err(ParseCharError { kind: CharErrorKind::EmptyString }),\n             (Some(c), None) => Ok(c),\n-            _ => {\n-                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n-            }\n+            _ => Err(ParseCharError { kind: CharErrorKind::TooManyChars }),\n         }\n     }\n }\n \n-\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl TryFrom<u32> for char {\n     type Error = CharTryFromError;\n@@ -304,11 +297,7 @@ pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n     }\n     if num < radix {\n         let num = num as u8;\n-        if num < 10 {\n-            Some((b'0' + num) as char)\n-        } else {\n-            Some((b'a' + num - 10) as char)\n-        }\n+        if num < 10 { Some((b'0' + num) as char) } else { Some((b'a' + num - 10) as char) }\n     } else {\n         None\n     }"}, {"sha": "5e7784730e3c9c56141712d816641ac68690c0bc", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -8,7 +8,8 @@ use super::from_u32_unchecked;\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[derive(Clone, Debug)]\n pub struct DecodeUtf16<I>\n-    where I: Iterator<Item = u16>\n+where\n+    I: Iterator<Item = u16>,\n {\n     iter: I,\n     buf: Option<u16>,\n@@ -70,10 +71,7 @@ pub struct DecodeUtf16Error {\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[inline]\n pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n-    DecodeUtf16 {\n-        iter: iter.into_iter(),\n-        buf: None,\n-    }\n+    DecodeUtf16 { iter: iter.into_iter(), buf: None }\n }\n \n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n@@ -83,7 +81,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n     fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n         let u = match self.buf.take() {\n             Some(buf) => buf,\n-            None => self.iter.next()?\n+            None => self.iter.next()?,\n         };\n \n         if u < 0xD800 || 0xDFFF < u {"}, {"sha": "1ec614edbe2ebdd1d67728e2e613fcda3f946489", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -130,11 +130,7 @@ impl char {\n             }\n         };\n \n-        if val < radix {\n-            Some(val)\n-        } else {\n-            None\n-        }\n+        if val < radix { Some(val) } else { None }\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n@@ -950,11 +946,7 @@ impl char {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> char {\n-        if self.is_ascii() {\n-            (*self as u8).to_ascii_uppercase() as char\n-        } else {\n-            *self\n-        }\n+        if self.is_ascii() { (*self as u8).to_ascii_uppercase() as char } else { *self }\n     }\n \n     /// Makes a copy of the value in its ASCII lower case equivalent.\n@@ -982,11 +974,7 @@ impl char {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> char {\n-        if self.is_ascii() {\n-            (*self as u8).to_ascii_lowercase() as char\n-        } else {\n-            *self\n-        }\n+        if self.is_ascii() { (*self as u8).to_ascii_lowercase() as char } else { *self }\n     }\n \n     /// Checks that two values are an ASCII case-insensitive match."}, {"sha": "a655ee6e7e32ae542c353662dadeea32a4194930", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -24,14 +24,14 @@ mod decode;\n mod methods;\n \n // stable re-exports\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::convert::{from_u32, from_digit};\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n pub use self::convert::from_u32_unchecked;\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-pub use self::convert::ParseCharError;\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub use self::convert::CharTryFromError;\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+pub use self::convert::ParseCharError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::convert::{from_digit, from_u32};\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n \n@@ -45,13 +45,13 @@ use crate::fmt::{self, Write};\n use crate::iter::FusedIterator;\n \n // UTF-8 ranges and tags for encoding characters\n-const TAG_CONT: u8     = 0b1000_0000;\n-const TAG_TWO_B: u8    = 0b1100_0000;\n-const TAG_THREE_B: u8  = 0b1110_0000;\n-const TAG_FOUR_B: u8   = 0b1111_0000;\n-const MAX_ONE_B: u32   =     0x80;\n-const MAX_TWO_B: u32   =    0x800;\n-const MAX_THREE_B: u32 =  0x10000;\n+const TAG_CONT: u8 = 0b1000_0000;\n+const TAG_TWO_B: u8 = 0b1100_0000;\n+const TAG_THREE_B: u8 = 0b1110_0000;\n+const TAG_FOUR_B: u8 = 0b1111_0000;\n+const MAX_ONE_B: u32 = 0x80;\n+const MAX_TWO_B: u32 = 0x800;\n+const MAX_THREE_B: u32 = 0x10000;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -190,11 +190,11 @@ impl Iterator for EscapeUnicode {\n         match self.state {\n             EscapeUnicodeState::Done => None,\n \n-            EscapeUnicodeState::RightBrace |\n-            EscapeUnicodeState::Value |\n-            EscapeUnicodeState::LeftBrace |\n-            EscapeUnicodeState::Type |\n-            EscapeUnicodeState::Backslash => Some('}'),\n+            EscapeUnicodeState::RightBrace\n+            | EscapeUnicodeState::Value\n+            | EscapeUnicodeState::LeftBrace\n+            | EscapeUnicodeState::Type\n+            | EscapeUnicodeState::Backslash => Some('}'),\n         }\n     }\n }\n@@ -204,14 +204,15 @@ impl ExactSizeIterator for EscapeUnicode {\n     #[inline]\n     fn len(&self) -> usize {\n         // The match is a single memory access with no branching\n-        self.hex_digit_idx + match self.state {\n-            EscapeUnicodeState::Done => 0,\n-            EscapeUnicodeState::RightBrace => 1,\n-            EscapeUnicodeState::Value => 2,\n-            EscapeUnicodeState::LeftBrace => 3,\n-            EscapeUnicodeState::Type => 4,\n-            EscapeUnicodeState::Backslash => 5,\n-        }\n+        self.hex_digit_idx\n+            + match self.state {\n+                EscapeUnicodeState::Done => 0,\n+                EscapeUnicodeState::RightBrace => 1,\n+                EscapeUnicodeState::Value => 2,\n+                EscapeUnicodeState::LeftBrace => 3,\n+                EscapeUnicodeState::Type => 4,\n+                EscapeUnicodeState::Backslash => 5,\n+            }\n     }\n }\n \n@@ -238,7 +239,7 @@ impl fmt::Display for EscapeUnicode {\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n-    state: EscapeDefaultState\n+    state: EscapeDefaultState,\n }\n \n #[derive(Clone, Debug)]\n@@ -284,24 +285,20 @@ impl Iterator for EscapeDefault {\n             EscapeDefaultState::Backslash(c) if n == 0 => {\n                 self.state = EscapeDefaultState::Char(c);\n                 Some('\\\\')\n-            },\n+            }\n             EscapeDefaultState::Backslash(c) if n == 1 => {\n                 self.state = EscapeDefaultState::Done;\n                 Some(c)\n-            },\n+            }\n             EscapeDefaultState::Backslash(_) => {\n                 self.state = EscapeDefaultState::Done;\n                 None\n-            },\n+            }\n             EscapeDefaultState::Char(c) => {\n                 self.state = EscapeDefaultState::Done;\n \n-                if n == 0 {\n-                    Some(c)\n-                } else {\n-                    None\n-                }\n-            },\n+                if n == 0 { Some(c) } else { None }\n+            }\n             EscapeDefaultState::Done => None,\n             EscapeDefaultState::Unicode(ref mut i) => i.nth(n),\n         }\n@@ -355,12 +352,16 @@ pub struct EscapeDebug(EscapeDefault);\n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n impl Iterator for EscapeDebug {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n }\n \n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-impl ExactSizeIterator for EscapeDebug { }\n+impl ExactSizeIterator for EscapeDebug {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDebug {}\n@@ -440,7 +441,7 @@ impl CaseMappingIter {\n     fn new(chars: [char; 3]) -> CaseMappingIter {\n         if chars[2] == '\\0' {\n             if chars[1] == '\\0' {\n-                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n+                CaseMappingIter::One(chars[0]) // Including if chars[0] == '\\0'\n             } else {\n                 CaseMappingIter::Two(chars[0], chars[1])\n             }\n@@ -493,9 +494,7 @@ impl fmt::Display for CaseMappingIter {\n                 f.write_char(b)?;\n                 f.write_char(c)\n             }\n-            CaseMappingIter::One(c) => {\n-                f.write_char(c)\n-            }\n+            CaseMappingIter::One(c) => f.write_char(c),\n             CaseMappingIter::Zero => Ok(()),\n         }\n     }"}, {"sha": "6e7a46ba62aabf2c39f77e0103d5cd6a13650d56", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -107,7 +107,7 @@\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n-pub trait Clone : Sized {\n+pub trait Clone: Sized {\n     /// Returns a copy of the value.\n     ///\n     /// # Examples\n@@ -137,24 +137,34 @@ pub trait Clone : Sized {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n-pub macro Clone($item:item) { /* compiler built-in */ }\n+pub macro Clone($item:item) {\n+    /* compiler built-in */\n+}\n \n // FIXME(aburka): these structs are used solely by #[derive] to\n // assert that every component of a type implements Clone or Copy.\n //\n // These structs should never appear in user code.\n #[doc(hidden)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"derive_clone_copy\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"0\")]\n-pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: crate::marker::PhantomData<T> }\n+#[unstable(\n+    feature = \"derive_clone_copy\",\n+    reason = \"deriving hack, should not be public\",\n+    issue = \"0\"\n+)]\n+pub struct AssertParamIsClone<T: Clone + ?Sized> {\n+    _field: crate::marker::PhantomData<T>,\n+}\n #[doc(hidden)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"derive_clone_copy\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"0\")]\n-pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: crate::marker::PhantomData<T> }\n+#[unstable(\n+    feature = \"derive_clone_copy\",\n+    reason = \"deriving hack, should not be public\",\n+    issue = \"0\"\n+)]\n+pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n+    _field: crate::marker::PhantomData<T>,\n+}\n \n /// Implementations of `Clone` for primitive types.\n ///\n@@ -185,7 +195,7 @@ mod impls {\n         bool char\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.41.0\")]\n     impl Clone for ! {\n         #[inline]\n         fn clone(&self) -> Self {\n@@ -217,5 +227,4 @@ mod impls {\n             *self\n         }\n     }\n-\n }"}, {"sha": "a5f355cd9a73ec333c51d2deea214324f6bade77", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -135,17 +135,23 @@ use self::Ordering::*;\n /// By changing `impl PartialEq for Book` to `impl PartialEq<BookFormat> for Book`,\n /// we allow `BookFormat`s to be compared with `Book`s.\n ///\n-/// You can also combine these implementations to let the `==` operator work with\n-/// two different types:\n-///\n-/// ```\n+/// A comparison like the one above, which ignores some fields of the struct,\n+/// can be dangerous. It can easily lead to an unintended violation of the\n+/// requirements for a partial equivalence relation. For example, if we kept\n+/// the above implementation of `PartialEq<Book>` for `BookFormat` and added an\n+/// implementation of `PartialEq<Book>` for `Book` (either via a `#[derive]` or\n+/// via the manual implementation from the first example) then the result would\n+/// violate transitivity:\n+///\n+/// ```should_panic\n /// #[derive(PartialEq)]\n /// enum BookFormat {\n ///     Paperback,\n ///     Hardback,\n ///     Ebook,\n /// }\n ///\n+/// #[derive(PartialEq)]\n /// struct Book {\n ///     isbn: i32,\n ///     format: BookFormat,\n@@ -163,18 +169,16 @@ use self::Ordering::*;\n ///     }\n /// }\n ///\n-/// impl PartialEq for Book {\n-///     fn eq(&self, other: &Book) -> bool {\n-///         self.isbn == other.isbn\n-///     }\n-/// }\n+/// fn main() {\n+///     let b1 = Book { isbn: 1, format: BookFormat::Paperback };\n+///     let b2 = Book { isbn: 2, format: BookFormat::Paperback };\n ///\n-/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n-/// let b2 = Book { isbn: 3, format: BookFormat::Ebook };\n+///     assert!(b1 == BookFormat::Paperback);\n+///     assert!(BookFormat::Paperback == b2);\n ///\n-/// assert!(b1 == BookFormat::Paperback);\n-/// assert!(BookFormat::Ebook != b1);\n-/// assert!(b1 == b2);\n+///     // The following should hold by transitivity but doesn't.\n+///     assert!(b1 == b2); // <-- PANICS\n+/// }\n /// ```\n ///\n /// # Examples\n@@ -460,9 +464,9 @@ impl<T: PartialOrd> PartialOrd for Reverse<T> {\n     #[inline]\n     fn le(&self, other: &Self) -> bool { other.0 <= self.0 }\n     #[inline]\n-    fn ge(&self, other: &Self) -> bool { other.0 >= self.0 }\n-    #[inline]\n     fn gt(&self, other: &Self) -> bool { other.0 > self.0 }\n+    #[inline]\n+    fn ge(&self, other: &Self) -> bool { other.0 >= self.0 }\n }\n \n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n@@ -530,7 +534,6 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n-#[lang = \"ord\"]\n #[doc(alias = \"<\")]\n #[doc(alias = \">\")]\n #[doc(alias = \"<=\")]\n@@ -1128,24 +1131,24 @@ mod impls {\n \n     ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.41.0\")]\n     impl PartialEq for ! {\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.41.0\")]\n     impl Eq for ! {}\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.41.0\")]\n     impl PartialOrd for ! {\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.41.0\")]\n     impl Ord for ! {\n         fn cmp(&self, _: &!) -> Ordering {\n             *self\n@@ -1172,9 +1175,9 @@ mod impls {\n         #[inline]\n         fn le(&self, other: & &B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: & &B) -> bool { PartialOrd::ge(*self, *other) }\n-        #[inline]\n         fn gt(&self, other: & &B) -> bool { PartialOrd::gt(*self, *other) }\n+        #[inline]\n+        fn ge(&self, other: & &B) -> bool { PartialOrd::ge(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Ord for &A where A: Ord {\n@@ -1204,9 +1207,9 @@ mod impls {\n         #[inline]\n         fn le(&self, other: &&mut B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: &&mut B) -> bool { PartialOrd::ge(*self, *other) }\n-        #[inline]\n         fn gt(&self, other: &&mut B) -> bool { PartialOrd::gt(*self, *other) }\n+        #[inline]\n+        fn ge(&self, other: &&mut B) -> bool { PartialOrd::ge(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Ord for &mut A where A: Ord {"}, {"sha": "5414d9ac2344ab25a287596a97ba973d5cf9c672", "filename": "src/libcore/convert/mod.rs", "status": "renamed", "additions": 46, "deletions": 105, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -40,7 +40,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::fmt;\n+mod num;\n+\n+#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+pub use num::FloatToInt;\n \n /// The identity function.\n ///\n@@ -97,7 +100,9 @@ use crate::fmt;\n /// ```\n #[stable(feature = \"convert_id\", since = \"1.33.0\")]\n #[inline]\n-pub const fn identity<T>(x: T) -> T { x }\n+pub const fn identity<T>(x: T) -> T {\n+    x\n+}\n \n /// Used to do a cheap reference-to-reference conversion.\n ///\n@@ -366,12 +371,10 @@ pub trait Into<T>: Sized {\n /// [`from`]: trait.From.html#tymethod.from\n /// [book]: ../../book/ch09-00-error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(\n-    on(\n-        all(_Self=\"&str\", T=\"std::string::String\"),\n-        note=\"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n-    )\n-)]\n+#[rustc_on_unimplemented(on(\n+    all(_Self = \"&str\", T = \"std::string::String\"),\n+    note = \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n+))]\n pub trait From<T>: Sized {\n     /// Performs the conversion.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -426,9 +429,7 @@ pub trait TryInto<T>: Sized {\n /// - `TryFrom<T> for U` implies [`TryInto`]`<U> for T`\n /// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n /// is implemented and cannot fail -- the associated `Error` type for\n-/// calling `T::try_from()` on a value of type `T` is [`Infallible`].\n-/// When the [`!`] type is stabilized [`Infallible`] and [`!`] will be\n-/// equivalent.\n+/// calling `T::try_from()` on a value of type `T` is [`!`].\n ///\n /// `TryFrom<T>` can be implemented as follows:\n ///\n@@ -477,7 +478,6 @@ pub trait TryInto<T>: Sized {\n /// [`TryInto`]: trait.TryInto.html\n /// [`i32::MAX`]: ../../std/i32/constant.MAX.html\n /// [`!`]: ../../std/primitive.never.html\n-/// [`Infallible`]: enum.Infallible.html\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error.\n@@ -495,7 +495,9 @@ pub trait TryFrom<T>: Sized {\n \n // As lifts over &\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsRef<U> for &T where T: AsRef<U>\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &T\n+where\n+    T: AsRef<U>,\n {\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n@@ -504,7 +506,9 @@ impl<T: ?Sized, U: ?Sized> AsRef<U> for &T where T: AsRef<U>\n \n // As lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T where T: AsRef<U>\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T\n+where\n+    T: AsRef<U>,\n {\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n@@ -521,7 +525,9 @@ impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T where T: AsRef<U>\n \n // AsMut lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T where T: AsMut<U>\n+impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T\n+where\n+    T: AsMut<U>,\n {\n     fn as_mut(&mut self) -> &mut U {\n         (*self).as_mut()\n@@ -538,7 +544,9 @@ impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T where T: AsMut<U>\n \n // From implies Into\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, U> Into<U> for T where U: From<T>\n+impl<T, U> Into<U> for T\n+where\n+    U: From<T>,\n {\n     fn into(self) -> U {\n         U::from(self)\n@@ -548,7 +556,9 @@ impl<T, U> Into<U> for T where U: From<T>\n // From (and thus Into) is reflexive\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> From<T> for T {\n-    fn from(t: T) -> T { t }\n+    fn from(t: T) -> T {\n+        t\n+    }\n }\n \n /// **Stability note:** This impl does not yet exist, but we are\n@@ -557,16 +567,20 @@ impl<T> From<T> for T {\n ///\n /// [#64715]: https://github.com/rust-lang/rust/issues/64715\n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-#[cfg(not(bootstrap))]\n-#[rustc_reservation_impl=\"permitting this impl would forbid us from adding \\\n-`impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n+#[allow(unused_attributes)] // FIXME(#58633): do a principled fix instead.\n+#[rustc_reservation_impl = \"permitting this impl would forbid us from adding \\\n+                            `impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n impl<T> From<!> for T {\n-    fn from(t: !) -> T { t }\n+    fn from(t: !) -> T {\n+        t\n+    }\n }\n \n // TryFrom implies TryInto\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl<T, U> TryInto<U> for T where U: TryFrom<T>\n+impl<T, U> TryInto<U> for T\n+where\n+    U: TryFrom<T>,\n {\n     type Error = U::Error;\n \n@@ -578,7 +592,10 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl<T, U> TryFrom<U> for T where U: Into<T> {\n+impl<T, U> TryFrom<U> for T\n+where\n+    U: Into<T>,\n+{\n     type Error = Infallible;\n \n     fn try_from(value: U) -> Result<Self, Self::Error> {\n@@ -616,9 +633,9 @@ impl AsRef<str> for str {\n // THE NO-ERROR ERROR TYPE\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// The error type for errors that can never happen.\n+/// A type alias for [the `!` \u201cnever\u201d type][never].\n ///\n-/// Since this enum has no variant, a value of this type can never actually exist.\n+/// `Infallible` represents types of errors that can never happen since `!` has no valid values.\n /// This can be useful for generic APIs that use [`Result`] and parameterize the error type,\n /// to indicate that the result is always [`Ok`].\n ///\n@@ -635,91 +652,15 @@ impl AsRef<str> for str {\n /// }\n /// ```\n ///\n-/// # Future compatibility\n-///\n-/// This enum has the same role as [the `!` \u201cnever\u201d type][never],\n-/// which is unstable in this version of Rust.\n-/// When `!` is stabilized, we plan to make `Infallible` a type alias to it:\n-///\n-/// ```ignore (illustrates future std change)\n-/// pub type Infallible = !;\n-/// ```\n-///\n-/// \u2026 and eventually deprecate `Infallible`.\n-///\n-///\n-/// However there is one case where `!` syntax can be used\n-/// before `!` is stabilized as a full-fleged type: in the position of a function\u2019s return type.\n-/// Specifically, it is possible implementations for two different function pointer types:\n+/// # Eventual deprecation\n ///\n-/// ```\n-/// trait MyTrait {}\n-/// impl MyTrait for fn() -> ! {}\n-/// impl MyTrait for fn() -> std::convert::Infallible {}\n-/// ```\n-///\n-/// With `Infallible` being an enum, this code is valid.\n-/// However when `Infallible` becomes an alias for the never type,\n-/// the two `impl`s will start to overlap\n-/// and therefore will be disallowed by the language\u2019s trait coherence rules.\n+/// Previously, `Infallible` was defined as `enum Infallible {}`.\n+/// Now that it is merely a type alias to `!`, we will eventually deprecate `Infallible`.\n ///\n /// [`Ok`]: ../result/enum.Result.html#variant.Ok\n /// [`Result`]: ../result/enum.Result.html\n /// [`TryFrom`]: trait.TryFrom.html\n /// [`Into`]: trait.Into.html\n /// [never]: ../../std/primitive.never.html\n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-#[derive(Copy)]\n-pub enum Infallible {}\n-\n-#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl Clone for Infallible {\n-    fn clone(&self) -> Infallible {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl fmt::Debug for Infallible {\n-    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl fmt::Display for Infallible {\n-    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl PartialEq for Infallible {\n-    fn eq(&self, _: &Infallible) -> bool {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl Eq for Infallible {}\n-\n-#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl PartialOrd for Infallible {\n-    fn partial_cmp(&self, _other: &Self) -> Option<crate::cmp::Ordering> {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl Ord for Infallible {\n-    fn cmp(&self, _other: &Self) -> crate::cmp::Ordering {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl From<!> for Infallible {\n-    fn from(x: !) -> Self {\n-        x\n-    }\n-}\n+pub type Infallible = !;", "previous_filename": "src/libcore/convert.rs"}, {"sha": "6f5ee756f58f6f350d5bf2e18a75f1738a8cac7b", "filename": "src/libcore/convert/num.rs", "status": "added", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,449 @@\n+use super::{From, TryFrom};\n+use crate::num::TryFromIntError;\n+\n+mod private {\n+    /// This trait being unreachable from outside the crate\n+    /// prevents other implementations of the `FloatToInt` trait,\n+    /// which allows potentially adding more trait methods after the trait is `#[stable]`.\n+    #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+    pub trait Sealed {}\n+}\n+\n+/// Supporting trait for inherent methods of `f32` and `f64` such as `round_unchecked_to`.\n+/// Typically doesn\u2019t need to be used directly.\n+#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+pub trait FloatToInt<Int>: private::Sealed + Sized {\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[doc(hidden)]\n+    unsafe fn approx_unchecked(self) -> Int;\n+}\n+\n+macro_rules! impl_float_to_int {\n+    ( $Float: ident => $( $Int: ident )+ ) => {\n+        #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+        impl private::Sealed for $Float {}\n+        $(\n+            #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+            impl FloatToInt<$Int> for $Float {\n+                #[cfg(not(bootstrap))]\n+                #[doc(hidden)]\n+                #[inline]\n+                unsafe fn approx_unchecked(self) -> $Int {\n+                    crate::intrinsics::float_to_int_approx_unchecked(self)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+impl_float_to_int!(f32 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+impl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+\n+// Conversion traits for primitive integer and float types\n+// Conversions T -> T are covered by a blanket impl and therefore excluded\n+// Some conversions from and to usize/isize are not implemented due to portability concerns\n+macro_rules! impl_from {\n+    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n+        #[$attr]\n+        #[doc = $doc]\n+        impl From<$Small> for $Large {\n+            #[inline]\n+            fn from(small: $Small) -> $Large {\n+                small as $Large\n+            }\n+        }\n+    };\n+    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n+        impl_from!($Small,\n+                   $Large,\n+                   #[$attr],\n+                   concat!(\"Converts `\",\n+                           stringify!($Small),\n+                           \"` to `\",\n+                           stringify!($Large),\n+                           \"` losslessly.\"));\n+    }\n+}\n+\n+macro_rules! impl_from_bool {\n+    ($target: ty, #[$attr:meta]) => {\n+        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n+            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n+values.\n+\n+# Examples\n+\n+```\n+assert_eq!(\", stringify!($target), \"::from(true), 1);\n+assert_eq!(\", stringify!($target), \"::from(false), 0);\n+```\"));\n+    };\n+}\n+\n+// Bool -> Any\n+impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+\n+// Unsigned -> Unsigned\n+impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Signed -> Signed\n+impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Unsigned -> Signed\n+impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n+// which imply that pointer-sized integers must be at least 16 bits:\n+// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n+impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+\n+// RISC-V defines the possibility of a 128-bit address space (RV128).\n+\n+// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n+// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n+// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n+\n+// Note: integers can only be represented with full precision in a float if\n+// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n+// Lossy float conversions are not implemented at this time.\n+\n+// Signed -> Float\n+impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Unsigned -> Float\n+impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Float -> Float\n+impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(value: $source) -> Result<Self, Self::Error> {\n+                Ok(value as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// only negative bounds\n+macro_rules! try_from_lower_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u >= 0 {\n+                    Ok(u as $target)\n+                } else {\n+                    Err(TryFromIntError(()))\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// unsigned to signed (only positive bound)\n+macro_rules! try_from_upper_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u > (<$target>::max_value() as $source) {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// all other cases\n+macro_rules! try_from_both_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                let min = <$target>::min_value() as $source;\n+                let max = <$target>::max_value() as $source;\n+                if u < min || u > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+macro_rules! rev {\n+    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n+        $mac!($target, $source);\n+    )*}\n+}\n+\n+// intra-sign conversions\n+try_from_upper_bounded!(u16, u8);\n+try_from_upper_bounded!(u32, u16, u8);\n+try_from_upper_bounded!(u64, u32, u16, u8);\n+try_from_upper_bounded!(u128, u64, u32, u16, u8);\n+\n+try_from_both_bounded!(i16, i8);\n+try_from_both_bounded!(i32, i16, i8);\n+try_from_both_bounded!(i64, i32, i16, i8);\n+try_from_both_bounded!(i128, i64, i32, i16, i8);\n+\n+// unsigned-to-signed\n+try_from_upper_bounded!(u8, i8);\n+try_from_upper_bounded!(u16, i8, i16);\n+try_from_upper_bounded!(u32, i8, i16, i32);\n+try_from_upper_bounded!(u64, i8, i16, i32, i64);\n+try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n+\n+// signed-to-unsigned\n+try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n+try_from_lower_bounded!(i16, u16, u32, u64, u128);\n+try_from_lower_bounded!(i32, u32, u64, u128);\n+try_from_lower_bounded!(i64, u64, u128);\n+try_from_lower_bounded!(i128, u128);\n+try_from_both_bounded!(i16, u8);\n+try_from_both_bounded!(i32, u16, u8);\n+try_from_both_bounded!(i64, u32, u16, u8);\n+try_from_both_bounded!(i128, u64, u32, u16, u8);\n+\n+// usize/isize\n+try_from_upper_bounded!(usize, isize);\n+try_from_lower_bounded!(isize, usize);\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8);\n+    try_from_unbounded!(usize, u16, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16);\n+    try_from_unbounded!(usize, i32, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8);\n+    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8);\n+    try_from_unbounded!(isize, i16, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16);\n+    rev!(try_from_both_bounded, usize, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n+    rev!(try_from_both_bounded, isize, i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16);\n+    try_from_unbounded!(usize, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32);\n+    try_from_unbounded!(usize, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16);\n+    try_from_lower_bounded!(isize, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16);\n+    try_from_unbounded!(isize, i32, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32);\n+    rev!(try_from_upper_bounded, usize, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n+    rev!(try_from_both_bounded, usize, i64, i128);\n+\n+    rev!(try_from_unbounded, isize, u16);\n+    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n+    rev!(try_from_unbounded, isize, i32);\n+    rev!(try_from_both_bounded, isize, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16, u32);\n+    try_from_unbounded!(usize, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n+    try_from_unbounded!(usize, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16, u32);\n+    try_from_lower_bounded!(isize, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16, i32);\n+    try_from_unbounded!(isize, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32, u64);\n+    rev!(try_from_upper_bounded, usize, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n+    rev!(try_from_both_bounded, usize, i128);\n+\n+    rev!(try_from_unbounded, isize, u16, u32);\n+    rev!(try_from_upper_bounded, isize, u64, u128);\n+    rev!(try_from_unbounded, isize, i32, i64);\n+    rev!(try_from_both_bounded, isize, i128);\n+}\n+\n+// Conversion traits for non-zero integer types\n+use crate::num::NonZeroI128;\n+use crate::num::NonZeroI16;\n+use crate::num::NonZeroI32;\n+use crate::num::NonZeroI64;\n+use crate::num::NonZeroI8;\n+use crate::num::NonZeroIsize;\n+use crate::num::NonZeroU128;\n+use crate::num::NonZeroU16;\n+use crate::num::NonZeroU32;\n+use crate::num::NonZeroU64;\n+use crate::num::NonZeroU8;\n+use crate::num::NonZeroUsize;\n+\n+macro_rules! nzint_impl_from {\n+    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n+        #[$attr]\n+        #[doc = $doc]\n+        impl From<$Small> for $Large {\n+            #[inline]\n+            fn from(small: $Small) -> $Large {\n+                // SAFETY: input type guarantees the value is non-zero\n+                unsafe {\n+                    <$Large>::new_unchecked(small.get().into())\n+                }\n+            }\n+        }\n+    };\n+    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n+        nzint_impl_from!($Small,\n+                   $Large,\n+                   #[$attr],\n+                   concat!(\"Converts `\",\n+                           stringify!($Small),\n+                           \"` to `\",\n+                           stringify!($Large),\n+                           \"` losslessly.\"));\n+    }\n+}\n+\n+// Non-zero Unsigned -> Non-zero Unsigned\n+nzint_impl_from! { NonZeroU8, NonZeroU16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU8, NonZeroU32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU8, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU8, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU8, NonZeroUsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU16, NonZeroU32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU16, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU16, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU16, NonZeroUsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU32, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU32, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU64, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+\n+// Non-zero Signed -> Non-zero Signed\n+nzint_impl_from! { NonZeroI8, NonZeroI16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI8, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI8, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI8, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI8, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI16, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI16, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI16, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI16, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI32, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI32, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroI64, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+\n+// NonZero UnSigned -> Non-zero Signed\n+nzint_impl_from! { NonZeroU8, NonZeroI16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU8, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU8, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU8, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU8, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU16, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU16, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU16, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU32, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU32, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n+nzint_impl_from! { NonZeroU64, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }"}, {"sha": "15ac3aea8b7baa2832e726fdd31325a5ab43dfb8", "filename": "src/libcore/default.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -119,7 +119,9 @@ pub trait Default: Sized {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n-pub macro Default($item:item) { /* compiler built-in */ }\n+pub macro Default($item:item) {\n+    /* compiler built-in */\n+}\n \n macro_rules! default_impl {\n     ($t:ty, $v:expr, $doc:tt) => {"}, {"sha": "74ec24939a3109716e91f1c7d61cdc192480a876", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 164, "deletions": 119, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,5 +1,4 @@\n #![stable(feature = \"\", since = \"1.30.0\")]\n-\n #![allow(non_camel_case_types)]\n \n //! Utilities related to FFI bindings.\n@@ -36,12 +35,20 @@ use crate::ops::{Deref, DerefMut};\n #[repr(u8)]\n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub enum c_void {\n-    #[unstable(feature = \"c_void_variant\", reason = \"temporary implementation detail\",\n-               issue = \"0\")]\n-    #[doc(hidden)] __variant1,\n-    #[unstable(feature = \"c_void_variant\", reason = \"temporary implementation detail\",\n-               issue = \"0\")]\n-    #[doc(hidden)] __variant2,\n+    #[unstable(\n+        feature = \"c_void_variant\",\n+        reason = \"temporary implementation detail\",\n+        issue = \"0\"\n+    )]\n+    #[doc(hidden)]\n+    __variant1,\n+    #[unstable(\n+        feature = \"c_void_variant\",\n+        reason = \"temporary implementation detail\",\n+        issue = \"0\"\n+    )]\n+    #[doc(hidden)]\n+    __variant2,\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -53,17 +60,20 @@ impl fmt::Debug for c_void {\n \n /// Basic implementation of a `va_list`.\n // The name is WIP, using `VaListImpl` for now.\n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n #[repr(transparent)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     ptr: *mut c_void,\n@@ -73,16 +83,19 @@ pub struct VaListImpl<'f> {\n     _marker: PhantomData<&'f mut &'f c_void>,\n }\n \n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> fmt::Debug for VaListImpl<'f> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"va_list* {:p}\", self.ptr)\n@@ -97,10 +110,12 @@ impl<'f> fmt::Debug for VaListImpl<'f> {\n #[cfg(all(target_arch = \"aarch64\", not(target_os = \"ios\"), not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     stack: *mut c_void,\n@@ -115,10 +130,12 @@ pub struct VaListImpl<'f> {\n #[cfg(all(target_arch = \"powerpc\", not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     gpr: u8,\n@@ -133,10 +150,12 @@ pub struct VaListImpl<'f> {\n #[cfg(all(target_arch = \"x86_64\", not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     gp_offset: i32,\n@@ -149,76 +168,86 @@ pub struct VaListImpl<'f> {\n /// A wrapper for a `va_list`\n #[repr(transparent)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n pub struct VaList<'a, 'f: 'a> {\n-    #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-                  not(target_arch = \"x86_64\")),\n-              all(target_arch = \"aarch64\", target_os = \"ios\"),\n-              target_arch = \"wasm32\",\n-              target_arch = \"asmjs\",\n-              windows))]\n+    #[cfg(any(\n+        all(\n+            not(target_arch = \"aarch64\"),\n+            not(target_arch = \"powerpc\"),\n+            not(target_arch = \"x86_64\")\n+        ),\n+        all(target_arch = \"aarch64\", target_os = \"ios\"),\n+        target_arch = \"wasm32\",\n+        target_arch = \"asmjs\",\n+        windows\n+    ))]\n     inner: VaListImpl<'f>,\n \n-    #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n-                  target_arch = \"x86_64\"),\n-              any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n-              not(target_arch = \"wasm32\"),\n-              not(target_arch = \"asmjs\"),\n-              not(windows)))]\n+    #[cfg(all(\n+        any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+        any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+        not(target_arch = \"wasm32\"),\n+        not(target_arch = \"asmjs\"),\n+        not(windows)\n+    ))]\n     inner: &'a mut VaListImpl<'f>,\n \n     _marker: PhantomData<&'a mut VaListImpl<'f>>,\n }\n \n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n     #[inline]\n     pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n-        VaList {\n-            inner: VaListImpl { ..*self },\n-            _marker: PhantomData,\n-        }\n+        VaList { inner: VaListImpl { ..*self }, _marker: PhantomData }\n     }\n }\n \n-#[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n-              target_arch = \"x86_64\"),\n-          any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n-          not(target_arch = \"wasm32\"),\n-          not(target_arch = \"asmjs\"),\n-          not(windows)))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(all(\n+    any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+    any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+    not(target_arch = \"wasm32\"),\n+    not(target_arch = \"asmjs\"),\n+    not(windows)\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n     #[inline]\n     pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n-        VaList {\n-            inner: self,\n-            _marker: PhantomData,\n-        }\n+        VaList { inner: self, _marker: PhantomData }\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n     type Target = VaListImpl<'f>;\n \n@@ -228,10 +257,12 @@ impl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'a, 'f: 'a> DerefMut for VaList<'a, 'f> {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut VaListImpl<'f> {\n@@ -252,10 +283,12 @@ mod sealed_trait {\n     /// Trait which whitelists the allowed types to be used with [VaList::arg]\n     ///\n     /// [VaList::va_arg]: struct.VaList.html#method.arg\n-    #[unstable(feature = \"c_variadic\",\n-               reason = \"the `c_variadic` feature has not been properly tested on \\\n-                         all supported platforms\",\n-               issue = \"44930\")]\n+    #[unstable(\n+        feature = \"c_variadic\",\n+        reason = \"the `c_variadic` feature has not been properly tested on \\\n+                  all supported platforms\",\n+        issue = \"44930\"\n+    )]\n     pub trait VaArgSafe {}\n }\n \n@@ -271,25 +304,31 @@ macro_rules! impl_va_arg_safe {\n     }\n }\n \n-impl_va_arg_safe!{i8, i16, i32, i64, usize}\n-impl_va_arg_safe!{u8, u16, u32, u64, isize}\n-impl_va_arg_safe!{f64}\n+impl_va_arg_safe! {i8, i16, i32, i64, usize}\n+impl_va_arg_safe! {u8, u16, u32, u64, isize}\n+impl_va_arg_safe! {f64}\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<T> sealed_trait::VaArgSafe for *mut T {}\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<T> sealed_trait::VaArgSafe for *const T {}\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Advance to the next arg.\n     #[inline]\n@@ -299,18 +338,22 @@ impl<'f> VaListImpl<'f> {\n \n     /// Copies the `va_list` at the current location.\n     pub unsafe fn with_copy<F, R>(&self, f: F) -> R\n-            where F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R {\n+    where\n+        F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R,\n+    {\n         let mut ap = self.clone();\n         let ret = f(ap.as_va_list());\n         va_end(&mut ap);\n         ret\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> Clone for VaListImpl<'f> {\n     #[inline]\n     fn clone(&self) -> Self {\n@@ -323,10 +366,12 @@ impl<'f> Clone for VaListImpl<'f> {\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> Drop for VaListImpl<'f> {\n     fn drop(&mut self) {\n         // FIXME: this should call `va_end`, but there's no clean way to"}, {"sha": "284e94926dc8524f173dc13ea263a5488fbf50e6", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 86, "deletions": 37, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,4 +1,4 @@\n-use crate::fmt::{Formatter, Result, LowerExp, UpperExp, Display, Debug};\n+use crate::fmt::{Debug, Display, Formatter, LowerExp, Result, UpperExp};\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n \n@@ -7,9 +7,14 @@ use crate::num::flt2dec;\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]\n-fn float_to_decimal_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                    sign: flt2dec::Sign, precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common_exact<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n@@ -19,43 +24,65 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n         // we decided whether that is valid or not.\n         // We can do this only because we are libstd and coupled to the compiler.\n         // (FWIW, using `freeze` would not be enough; `flt2dec::Part` is an enum!)\n-        let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n-                                                    *num, sign, precision,\n-                                                    false, buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_exact_fixed_str(\n+            flt2dec::strategy::grisu::format_exact,\n+            *num,\n+            sign,\n+            precision,\n+            false,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n // up using the combined stack space of both functions in some cases.\n #[inline(never)]\n-fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                       sign: flt2dec::Sign, precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common_shortest<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n-                                                 sign, precision, false, buf.get_mut(),\n-                                                 parts.get_mut());\n+        let formatted = flt2dec::to_shortest_str(\n+            flt2dec::strategy::grisu::format_shortest,\n+            *num,\n+            sign,\n+            precision,\n+            false,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_decimal_common<T>(fmt: &mut Formatter<'_>, num: &T,\n-                              negative_zero: bool, min_precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    negative_zero: bool,\n+    min_precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     let force_sign = fmt.sign_plus();\n     let sign = match (force_sign, negative_zero) {\n         (false, false) => flt2dec::Sign::Minus,\n-        (false, true)  => flt2dec::Sign::MinusRaw,\n-        (true,  false) => flt2dec::Sign::MinusPlus,\n-        (true,  true)  => flt2dec::Sign::MinusPlusRaw,\n+        (false, true) => flt2dec::Sign::MinusRaw,\n+        (true, false) => flt2dec::Sign::MinusPlus,\n+        (true, true) => flt2dec::Sign::MinusPlusRaw,\n     };\n \n     if let Some(precision) = fmt.precision {\n@@ -68,50 +95,72 @@ fn float_to_decimal_common<T>(fmt: &mut Formatter<'_>, num: &T,\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]\n-fn float_to_exponential_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                        sign: flt2dec::Sign, precision: usize,\n-                                        upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_exponential_common_exact<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+    upper: bool,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n-                                                  *num, sign, precision,\n-                                                  upper, buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_exact_exp_str(\n+            flt2dec::strategy::grisu::format_exact,\n+            *num,\n+            sign,\n+            precision,\n+            upper,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n // up using the combined stack space of both functions in some cases.\n #[inline(never)]\n-fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter<'_>,\n-                                           num: &T, sign: flt2dec::Sign,\n-                                           upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_exponential_common_shortest<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    upper: bool,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n-                                                     *num, sign, (0, 0), upper,\n-                                                     buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_shortest_exp_str(\n+            flt2dec::strategy::grisu::format_shortest,\n+            *num,\n+            sign,\n+            (0, 0),\n+            upper,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Common code of floating point LowerExp and UpperExp.\n fn float_to_exponential_common<T>(fmt: &mut Formatter<'_>, num: &T, upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     let force_sign = fmt.sign_plus();\n     let sign = match force_sign {\n         false => flt2dec::Sign::Minus,\n-        true  => flt2dec::Sign::MinusPlus,\n+        true => flt2dec::Sign::MinusPlus,\n     };\n \n     if let Some(precision) = fmt.precision {\n@@ -123,7 +172,7 @@ fn float_to_exponential_common<T>(fmt: &mut Formatter<'_>, num: &T, upper: bool)\n }\n \n macro_rules! floating {\n-    ($ty:ident) => (\n+    ($ty:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Debug for $ty {\n             fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n@@ -151,7 +200,7 @@ macro_rules! floating {\n                 float_to_exponential_common(fmt, self, true)\n             }\n         }\n-    )\n+    };\n }\n \n floating! { f32 }"}, {"sha": "e2f49ee25a756f92b58b6521852d8fc485035e45", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 120, "deletions": 119, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,7 +4,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::cell::{UnsafeCell, Cell, RefCell, Ref, RefMut};\n+use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n use crate::marker::PhantomData;\n use crate::mem;\n use crate::num::flt2dec;\n@@ -13,9 +13,9 @@ use crate::result;\n use crate::slice;\n use crate::str;\n \n+mod builders;\n mod float;\n mod num;\n-mod builders;\n \n #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n /// Possible alignments returned by `Formatter::align`\n@@ -33,10 +33,9 @@ pub enum Alignment {\n }\n \n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n+pub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n \n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-           issue = \"0\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n #[doc(hidden)]\n pub mod rt {\n     pub mod v1;\n@@ -234,7 +233,7 @@ pub struct Formatter<'a> {\n     width: Option<usize>,\n     precision: Option<usize>,\n \n-    buf: &'a mut (dyn Write+'a),\n+    buf: &'a mut (dyn Write + 'a),\n     curarg: slice::Iter<'a, ArgumentV1<'a>>,\n     args: &'a [ArgumentV1<'a>],\n }\n@@ -260,8 +259,7 @@ struct Void {\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[derive(Copy, Clone)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-           issue = \"0\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n #[doc(hidden)]\n pub struct ArgumentV1<'a> {\n     value: &'a Void,\n@@ -275,21 +273,13 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new<'b, T>(x: &'b T,\n-                      f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n-        unsafe {\n-            ArgumentV1 {\n-                formatter: mem::transmute(f),\n-                value: mem::transmute(x)\n-            }\n-        }\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n+        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n         ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n@@ -305,21 +295,23 @@ impl<'a> ArgumentV1<'a> {\n \n // flags available in the v1 format of format_args\n #[derive(Copy, Clone)]\n-enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, DebugLowerHex, DebugUpperHex }\n+enum FlagV1 {\n+    SignPlus,\n+    SignMinus,\n+    Alternate,\n+    SignAwareZeroPad,\n+    DebugLowerHex,\n+    DebugUpperHex,\n+}\n \n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new_v1(pieces: &'a [&'a str],\n-                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n-        Arguments {\n-            pieces,\n-            fmt: None,\n-            args,\n-        }\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new_v1(pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        Arguments { pieces, fmt: None, args }\n     }\n \n     /// This function is used to specify nonstandard formatting parameters.\n@@ -328,29 +320,26 @@ impl<'a> Arguments<'a> {\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n     /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new_v1_formatted(pieces: &'a [&'a str],\n-                            args: &'a [ArgumentV1<'a>],\n-                            fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n-        Arguments {\n-            pieces,\n-            fmt: Some(fmt),\n-            args,\n-        }\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new_v1_formatted(\n+        pieces: &'a [&'a str],\n+        args: &'a [ArgumentV1<'a>],\n+        fmt: &'a [rt::v1::Argument],\n+    ) -> Arguments<'a> {\n+        Arguments { pieces, fmt: Some(fmt), args }\n     }\n \n     /// Estimates the length of the formatted text.\n     ///\n     /// This is intended to be used for setting initial `String` capacity\n     /// when using `format!`. Note: this is neither the lower nor upper bound.\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n     pub fn estimated_capacity(&self) -> usize {\n-        let pieces_length: usize = self.pieces.iter()\n-            .map(|x| x.len()).sum();\n+        let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n \n         if self.args.is_empty() {\n             pieces_length\n@@ -514,10 +503,13 @@ impl Display for Arguments<'_> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    on(crate_local, label=\"`{Self}` cannot be formatted using `{{:?}}`\",\n-                    note=\"add `#[derive(Debug)]` or manually implement `{Debug}`\"),\n-    message=\"`{Self}` doesn't implement `{Debug}`\",\n-    label=\"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\",\n+    on(\n+        crate_local,\n+        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n+        note = \"add `#[derive(Debug)]` or manually implement `{Debug}`\"\n+    ),\n+    message = \"`{Self}` doesn't implement `{Debug}`\",\n+    label = \"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\"\n )]\n #[doc(alias = \"{:?}\")]\n #[rustc_diagnostic_item = \"debug_trait\"]\n@@ -553,7 +545,9 @@ pub(crate) mod macros {\n     #[rustc_builtin_macro]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Debug($item:item) { /* compiler built-in */ }\n+    pub macro Debug($item:item) {\n+        /* compiler built-in */\n+    }\n }\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n@@ -594,14 +588,14 @@ pub use macros::Debug;\n /// ```\n #[rustc_on_unimplemented(\n     on(\n-        _Self=\"std::path::Path\",\n-        label=\"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n-        note=\"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n-              as they may contain non-Unicode data\"\n+        _Self = \"std::path::Path\",\n+        label = \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n+        note = \"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n+                as they may contain non-Unicode data\"\n     ),\n-    message=\"`{Self}` doesn't implement `{Display}`\",\n-    label=\"`{Self}` cannot be formatted with the default formatter\",\n-    note=\"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\",\n+    message = \"`{Self}` doesn't implement `{Display}`\",\n+    label = \"`{Self}` cannot be formatted with the default formatter\",\n+    note = \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\"\n )]\n #[doc(alias = \"{}\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -668,7 +662,7 @@ pub trait Display {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         let val = self.0;\n ///\n-///         write!(f, \"{:o}\", val) // delegate to i32's implementation\n+///         fmt::Octal::fmt(&val, f) // delegate to i32's implementation\n ///     }\n /// }\n ///\n@@ -718,7 +712,7 @@ pub trait Octal {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         let val = self.0;\n ///\n-///         write!(f, \"{:b}\", val) // delegate to i32's implementation\n+///         fmt::Binary::fmt(&val, f) // delegate to i32's implementation\n ///     }\n /// }\n ///\n@@ -777,7 +771,7 @@ pub trait Binary {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         let val = self.0;\n ///\n-///         write!(f, \"{:x}\", val) // delegate to i32's implementation\n+///         fmt::LowerHex::fmt(&val, f) // delegate to i32's implementation\n ///     }\n /// }\n ///\n@@ -830,7 +824,7 @@ pub trait LowerHex {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         let val = self.0;\n ///\n-///         write!(f, \"{:X}\", val) // delegate to i32's implementation\n+///         fmt::UpperHex::fmt(&val, f) // delegate to i32's implementation\n ///     }\n /// }\n ///\n@@ -875,7 +869,8 @@ pub trait UpperHex {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n ///\n-///         write!(f, \"{:p}\", self as *const Length)\n+///         let ptr = self as *const Self;\n+///         fmt::Pointer::fmt(&ptr, f)\n ///     }\n /// }\n ///\n@@ -1073,7 +1068,9 @@ impl PostPadding {\n \n impl<'a> Formatter<'a> {\n     fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n-        where 'b: 'c, F: FnOnce(&'b mut (dyn Write+'b)) -> &'c mut (dyn Write+'c)\n+    where\n+        'b: 'c,\n+        F: FnOnce(&'b mut (dyn Write + 'b)) -> &'c mut (dyn Write + 'c),\n     {\n         Formatter {\n             // We want to change this\n@@ -1106,7 +1103,7 @@ impl<'a> Formatter<'a> {\n \n         // Extract the correct argument\n         let value = match arg.position {\n-            rt::v1::Position::Next => { *self.curarg.next().unwrap() }\n+            rt::v1::Position::Next => *self.curarg.next().unwrap(),\n             rt::v1::Position::At(i) => self.args[i],\n         };\n \n@@ -1118,12 +1115,8 @@ impl<'a> Formatter<'a> {\n         match *cnt {\n             rt::v1::Count::Is(n) => Some(n),\n             rt::v1::Count::Implied => None,\n-            rt::v1::Count::Param(i) => {\n-                self.args[i].as_usize()\n-            }\n-            rt::v1::Count::NextParam => {\n-                self.curarg.next()?.as_usize()\n-            }\n+            rt::v1::Count::Param(i) => self.args[i].as_usize(),\n+            rt::v1::Count::NextParam => self.curarg.next()?.as_usize(),\n         }\n     }\n \n@@ -1174,18 +1167,16 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn pad_integral(&mut self,\n-                        is_nonnegative: bool,\n-                        prefix: &str,\n-                        buf: &str)\n-                        -> Result {\n+    pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {\n         let mut width = buf.len();\n \n         let mut sign = None;\n         if !is_nonnegative {\n-            sign = Some('-'); width += 1;\n+            sign = Some('-');\n+            width += 1;\n         } else if self.sign_plus() {\n-            sign = Some('+'); width += 1;\n+            sign = Some('+');\n+            width += 1;\n         }\n \n         let prefix = if self.alternate() {\n@@ -1201,11 +1192,7 @@ impl<'a> Formatter<'a> {\n             if let Some(c) = sign {\n                 f.buf.write_char(c)?;\n             }\n-            if let Some(prefix) = prefix {\n-                f.buf.write_str(prefix)\n-            } else {\n-                Ok(())\n-            }\n+            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }\n         }\n \n         // The `width` field is more of a `min-width` parameter at this point.\n@@ -1301,9 +1288,7 @@ impl<'a> Formatter<'a> {\n             None => self.buf.write_str(s),\n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n-            Some(width) if s.chars().count() >= width => {\n-                self.buf.write_str(s)\n-            }\n+            Some(width) if s.chars().count() >= width => self.buf.write_str(s),\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n@@ -1321,17 +1306,16 @@ impl<'a> Formatter<'a> {\n     fn padding(\n         &mut self,\n         padding: usize,\n-        default: rt::v1::Alignment\n+        default: rt::v1::Alignment,\n     ) -> result::Result<PostPadding, Error> {\n         let align = match self.align {\n             rt::v1::Alignment::Unknown => default,\n-            _ => self.align\n+            _ => self.align,\n         };\n \n         let (pre_pad, post_pad) = match align {\n             rt::v1::Alignment::Left => (0, padding),\n-            rt::v1::Alignment::Right |\n-            rt::v1::Alignment::Unknown => (padding, 0),\n+            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown => (padding, 0),\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n@@ -1368,7 +1352,8 @@ impl<'a> Formatter<'a> {\n \n             // remaining parts go through the ordinary padding process.\n             let len = formatted.len();\n-            let ret = if width <= len { // no padding\n+            let ret = if width <= len {\n+                // no padding\n                 self.write_formatted_parts(&formatted)\n             } else {\n                 let post_padding = self.padding(width - len, align)?;\n@@ -1473,10 +1458,14 @@ impl<'a> Formatter<'a> {\n \n     /// Flags for formatting\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.24.0\",\n-                       reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n-                                 or `sign_aware_zero_pad` methods instead\")]\n-    pub fn flags(&self) -> u32 { self.flags }\n+    #[rustc_deprecated(\n+        since = \"1.24.0\",\n+        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n+                  or `sign_aware_zero_pad` methods instead\"\n+    )]\n+    pub fn flags(&self) -> u32 {\n+        self.flags\n+    }\n \n     /// Character used as 'fill' whenever there is alignment.\n     ///\n@@ -1506,7 +1495,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn fill(&self) -> char { self.fill }\n+    pub fn fill(&self) -> char {\n+        self.fill\n+    }\n \n     /// Flag indicating what form of alignment was requested.\n     ///\n@@ -1574,7 +1565,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn width(&self) -> Option<usize> { self.width }\n+    pub fn width(&self) -> Option<usize> {\n+        self.width\n+    }\n \n     /// Optionally specified precision for numeric types.\n     ///\n@@ -1601,7 +1594,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn precision(&self) -> Option<usize> { self.precision }\n+    pub fn precision(&self) -> Option<usize> {\n+        self.precision\n+    }\n \n     /// Determines if the `+` flag was specified.\n     ///\n@@ -1629,7 +1624,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }\n+    pub fn sign_plus(&self) -> bool {\n+        self.flags & (1 << FlagV1::SignPlus as u32) != 0\n+    }\n \n     /// Determines if the `-` flag was specified.\n     ///\n@@ -1655,7 +1652,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }\n+    pub fn sign_minus(&self) -> bool {\n+        self.flags & (1 << FlagV1::SignMinus as u32) != 0\n+    }\n \n     /// Determines if the `#` flag was specified.\n     ///\n@@ -1680,7 +1679,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }\n+    pub fn alternate(&self) -> bool {\n+        self.flags & (1 << FlagV1::Alternate as u32) != 0\n+    }\n \n     /// Determines if the `0` flag was specified.\n     ///\n@@ -1709,9 +1710,13 @@ impl<'a> Formatter<'a> {\n \n     // FIXME: Decide what public API we want for these two flags.\n     // https://github.com/rust-lang/rust/issues/48584\n-    fn debug_lower_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0 }\n+    fn debug_lower_hex(&self) -> bool {\n+        self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0\n+    }\n \n-    fn debug_upper_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0 }\n+    fn debug_upper_hex(&self) -> bool {\n+        self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0\n+    }\n \n     /// Creates a [`DebugStruct`] builder designed to assist with creation of\n     /// [`fmt::Debug`] implementations for structs.\n@@ -1935,14 +1940,14 @@ macro_rules! fmt_refs {\n \n fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[stable(feature = \"never_type\", since = \"1.41.0\")]\n impl Debug for ! {\n     fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n         *self\n     }\n }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[stable(feature = \"never_type\", since = \"1.41.0\")]\n impl Display for ! {\n     fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n         *self\n@@ -2067,11 +2072,15 @@ impl<T: ?Sized> Pointer for &mut T {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Debug for *const T {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> Result { Pointer::fmt(self, f) }\n+    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        Pointer::fmt(self, f)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Debug for *mut T {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> Result { Pointer::fmt(self, f) }\n+    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        Pointer::fmt(self, f)\n+    }\n }\n \n macro_rules! peel {\n@@ -2129,21 +2138,15 @@ impl<T: ?Sized> Debug for PhantomData<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n-        f.debug_struct(\"Cell\")\n-            .field(\"value\", &self.get())\n-            .finish()\n+        f.debug_struct(\"Cell\").field(\"value\", &self.get()).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n         match self.try_borrow() {\n-            Ok(borrow) => {\n-                f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &borrow)\n-                    .finish()\n-            }\n+            Ok(borrow) => f.debug_struct(\"RefCell\").field(\"value\", &borrow).finish(),\n             Err(_) => {\n                 // The RefCell is mutably borrowed so we can't look at its value\n                 // here. Show a placeholder instead.\n@@ -2155,9 +2158,7 @@ impl<T: ?Sized + Debug> Debug for RefCell<T> {\n                     }\n                 }\n \n-                f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &BorrowedPlaceholder)\n-                    .finish()\n+                f.debug_struct(\"RefCell\").field(\"value\", &BorrowedPlaceholder).finish()\n             }\n         }\n     }"}, {"sha": "0db8d86ebbf529cc56f89ece36e15ff4275478b5", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -192,7 +192,8 @@ pub trait Hash {\n     /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n-        where Self: Sized\n+    where\n+        Self: Sized,\n     {\n         for piece in data {\n             piece.hash(state);\n@@ -206,7 +207,9 @@ pub(crate) mod macros {\n     #[rustc_builtin_macro]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Hash($item:item) { /* compiler built-in */ }\n+    pub macro Hash($item:item) {\n+        /* compiler built-in */\n+    }\n }\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n@@ -666,7 +669,6 @@ mod impls {\n         }\n     }\n \n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized + Hash> Hash for &T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n@@ -689,9 +691,7 @@ mod impls {\n                 state.write_usize(*self as *const () as usize);\n             } else {\n                 // Fat pointer\n-                let (a, b) = unsafe {\n-                    *(self as *const Self as *const (usize, usize))\n-                };\n+                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n                 state.write_usize(a);\n                 state.write_usize(b);\n             }\n@@ -706,9 +706,7 @@ mod impls {\n                 state.write_usize(*self as *const () as usize);\n             } else {\n                 // Fat pointer\n-                let (a, b) = unsafe {\n-                    *(self as *const Self as *const (usize, usize))\n-                };\n+                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n                 state.write_usize(a);\n                 state.write_usize(b);\n             }"}, {"sha": "0aa3b97ebcf15d6725ad2598f537dd5259c9cae6", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,10 +4,10 @@\n \n #![allow(deprecated)] // the types in this module are deprecated\n \n-use crate::marker::PhantomData;\n-use crate::ptr;\n use crate::cmp;\n+use crate::marker::PhantomData;\n use crate::mem;\n+use crate::ptr;\n \n /// An implementation of SipHash 1-3.\n ///\n@@ -16,8 +16,10 @@ use crate::mem;\n ///\n /// See: <https://131002.net/siphash>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n #[doc(hidden)]\n pub struct SipHasher13 {\n@@ -28,8 +30,10 @@ pub struct SipHasher13 {\n ///\n /// See: <https://131002.net/siphash/>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n@@ -48,8 +52,10 @@ struct SipHasher24 {\n /// it is not intended for cryptographic purposes. As such, all\n /// cryptographic uses of this implementation are _strongly discouraged_.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher(SipHasher24);\n \n@@ -58,9 +64,9 @@ struct Hasher<S: Sip> {\n     k0: u64,\n     k1: u64,\n     length: usize, // how many bytes we've processed\n-    state: State, // hash State\n-    tail: u64, // unprocessed bytes le\n-    ntail: usize, // how many bytes in tail are valid\n+    state: State,  // hash State\n+    tail: u64,     // unprocessed bytes le\n+    ntail: usize,  // how many bytes in tail are valid\n     _marker: PhantomData<S>,\n }\n \n@@ -78,18 +84,23 @@ struct State {\n }\n \n macro_rules! compress {\n-    ($state:expr) => ({\n-        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n-    });\n-    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n-    ({\n-        $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\n+    ($state:expr) => {{ compress!($state.v0, $state.v1, $state.v2, $state.v3) }};\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) => {{\n+        $v0 = $v0.wrapping_add($v1);\n+        $v1 = $v1.rotate_left(13);\n+        $v1 ^= $v0;\n         $v0 = $v0.rotate_left(32);\n-        $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\n-        $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\n-        $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\n+        $v2 = $v2.wrapping_add($v3);\n+        $v3 = $v3.rotate_left(16);\n+        $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3);\n+        $v3 = $v3.rotate_left(21);\n+        $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1);\n+        $v1 = $v1.rotate_left(17);\n+        $v1 ^= $v2;\n         $v2 = $v2.rotate_left(32);\n-    });\n+    }};\n }\n \n /// Loads an integer of the desired type from a byte stream, in LE order. Uses\n@@ -98,15 +109,16 @@ macro_rules! compress {\n ///\n /// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n macro_rules! load_int_le {\n-    ($buf:expr, $i:expr, $int_ty:ident) =>\n-    ({\n-       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n-       let mut data = 0 as $int_ty;\n-       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n-                                &mut data as *mut _ as *mut u8,\n-                                mem::size_of::<$int_ty>());\n-       data.to_le()\n-    });\n+    ($buf:expr, $i:expr, $int_ty:ident) => {{\n+        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+        let mut data = 0 as $int_ty;\n+        ptr::copy_nonoverlapping(\n+            $buf.get_unchecked($i),\n+            &mut data as *mut _ as *mut u8,\n+            mem::size_of::<$int_ty>(),\n+        );\n+        data.to_le()\n+    }};\n }\n \n /// Loads an u64 using up to 7 bytes of a byte slice.\n@@ -137,43 +149,47 @@ impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n-        SipHasher(SipHasher24 {\n-            hasher: Hasher::new_with_keys(key0, key1)\n-        })\n+        SipHasher(SipHasher24 { hasher: Hasher::new_with_keys(key0, key1) })\n     }\n }\n \n impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n-        SipHasher13 {\n-            hasher: Hasher::new_with_keys(key0, key1)\n-        }\n+        SipHasher13 { hasher: Hasher::new_with_keys(key0, key1) }\n     }\n }\n \n@@ -184,12 +200,7 @@ impl<S: Sip> Hasher<S> {\n             k0: key0,\n             k1: key1,\n             length: 0,\n-            state: State {\n-                v0: 0,\n-                v1: 0,\n-                v2: 0,\n-                v3: 0,\n-            },\n+            state: State { v0: 0, v1: 0, v2: 0, v3: 0 },\n             tail: 0,\n             ntail: 0,\n             _marker: PhantomData,\n@@ -294,7 +305,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n             self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n             if length < needed {\n                 self.ntail += length;\n-                return\n+                return;\n             } else {\n                 self.state.v3 ^= self.tail;\n                 S::c_rounds(&mut self.state);"}, {"sha": "a295e65bb5511cb7de07e0758ac971ea0404271e", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -113,7 +113,7 @@ pub fn spin_loop() {\n pub fn black_box<T>(dummy: T) -> T {\n     // We need to \"use\" the argument in some way LLVM can't introspect, and on\n     // targets that support it we can typically leverage inline assembly to do\n-    // this. LLVM's intepretation of inline assembly is that it's, well, a black\n+    // this. LLVM's interpretation of inline assembly is that it's, well, a black\n     // box. This isn't the greatest implementation since it probably deoptimizes\n     // more than we want, but it's so far good enough.\n     unsafe {"}, {"sha": "18aae59573d7d56a0707f586617bf86570a816ad", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -697,7 +697,6 @@ extern \"rust-intrinsic\" {\n     pub fn panic_if_uninhabited<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n-    #[cfg(not(bootstrap))]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Creates a value initialized to zero.\n@@ -940,6 +939,7 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_transmute\")]\n     pub fn transmute<T, U>(e: T) -> U;\n \n     /// Returns `true` if the actual type given as `T` requires drop\n@@ -1144,6 +1144,11 @@ extern \"rust-intrinsic\" {\n     /// May assume inputs are finite.\n     pub fn frem_fast<T>(a: T, b: T) -> T;\n \n+    /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n+    /// https://github.com/rust-lang/rust/issues/10184\n+    #[cfg(not(bootstrap))]\n+    pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n+\n \n     /// Returns the number of bits set in an integer type `T`\n     pub fn ctpop<T>(x: T) -> T;\n@@ -1280,7 +1285,7 @@ extern \"rust-intrinsic\" {\n     /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n     pub fn unchecked_add<T>(x: T, y: T) -> T;\n \n-    /// Returns the result of an unchecked substraction, resulting in\n+    /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n     pub fn unchecked_sub<T>(x: T, y: T) -> T;\n \n@@ -1346,8 +1351,14 @@ extern \"rust-intrinsic\" {\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n \n     /// See documentation of `<*const T>::offset_from` for details.\n-    #[cfg(not(bootstrap))]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n+\n+    /// Internal hook used by Miri to implement unwinding.\n+    /// Compiles to a NOP during non-Miri codegen.\n+    ///\n+    /// Perma-unstable: do not use\n+    #[cfg(not(bootstrap))]\n+    pub fn miri_start_panic(data: *mut (dyn crate::any::Any + crate::marker::Send)) -> ();\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "0a7a9f26f891257211a68aff95006aed783eb152", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 91, "deletions": 37, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,7 +1,7 @@\n use crate::fmt;\n use crate::ops::Try;\n \n-use super::super::{Iterator, DoubleEndedIterator, FusedIterator};\n+use super::super::{DoubleEndedIterator, FusedIterator, Iterator};\n use super::Map;\n \n /// An iterator that maps each element to an iterator, and yields the elements\n@@ -15,7 +15,7 @@ use super::Map;\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FlatMap<I, U: IntoIterator, F> {\n-    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>,\n }\n impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n     pub(in super::super) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n@@ -28,7 +28,9 @@ impl<I: Clone, U, F: Clone> Clone for FlatMap<I, U, F>\n where\n     U: Clone + IntoIterator<IntoIter: Clone>,\n {\n-    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n+    fn clone(&self) -> Self {\n+        FlatMap { inner: self.inner.clone() }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -43,26 +45,35 @@ where\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n+where\n+    F: FnMut(I::Item) -> U,\n {\n     type Item = U::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+    fn next(&mut self) -> Option<U::Item> {\n+        self.inner.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_fold(init, fold)\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.fold(init, fold)\n     }\n@@ -75,26 +86,37 @@ where\n     U: IntoIterator<IntoIter: DoubleEndedIterator>,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        self.inner.next_back()\n+    }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_rfold(init, fold)\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.rfold(init, fold)\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+where\n+    I: FusedIterator,\n+    U: IntoIterator,\n+    F: FnMut(I::Item) -> U,\n+{\n+}\n \n /// An iterator that flattens one level of nesting in an iterator of things\n /// that can be turned into iterators.\n@@ -133,7 +155,9 @@ where\n     I: Clone + Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n     U: Clone + Iterator,\n {\n-    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+    fn clone(&self) -> Self {\n+        Flatten { inner: self.inner.clone() }\n+    }\n }\n \n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n@@ -145,21 +169,29 @@ where\n     type Item = U::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+    fn next(&mut self) -> Option<U::Item> {\n+        self.inner.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_fold(init, fold)\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.fold(init, fold)\n     }\n@@ -172,18 +204,24 @@ where\n     U: DoubleEndedIterator,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        self.inner.next_back()\n+    }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_rfold(init, fold)\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.rfold(init, fold)\n     }\n@@ -194,7 +232,8 @@ impl<I, U> FusedIterator for Flatten<I>\n where\n     I: FusedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n     U: Iterator,\n-{}\n+{\n+}\n \n /// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n /// this type.\n@@ -222,7 +261,9 @@ where\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.frontiter {\n-                if let elt@Some(_) = inner.next() { return elt }\n+                if let elt @ Some(_) = inner.next() {\n+                    return elt;\n+                }\n             }\n             match self.iter.next() {\n                 None => return self.backiter.as_mut()?.next(),\n@@ -238,13 +279,16 @@ where\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n             ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n-            _ => (lo, None)\n+            _ => (lo, None),\n         }\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         #[inline]\n         fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n@@ -277,7 +321,8 @@ where\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         #[inline]\n         fn flatten<U: Iterator, Acc>(\n@@ -286,7 +331,8 @@ where\n             move |acc, iter| iter.fold(acc, &mut *fold)\n         }\n \n-        self.frontiter.into_iter()\n+        self.frontiter\n+            .into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .fold(init, flatten(fold))\n@@ -302,7 +348,9 @@ where\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.backiter {\n-                if let elt@Some(_) = inner.next_back() { return elt }\n+                if let elt @ Some(_) = inner.next_back() {\n+                    return elt;\n+                }\n             }\n             match self.iter.next_back() {\n                 None => return self.frontiter.as_mut()?.next_back(),\n@@ -312,14 +360,18 @@ where\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         #[inline]\n         fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n             backiter: &'a mut Option<T::IntoIter>,\n             fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n-        ) -> impl FnMut(Acc, T) -> R + 'a where\n+        ) -> impl FnMut(Acc, T) -> R + 'a\n+        where\n             T::IntoIter: DoubleEndedIterator,\n         {\n             move |acc, x| {\n@@ -348,7 +400,8 @@ where\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         #[inline]\n         fn flatten<U: DoubleEndedIterator, Acc>(\n@@ -357,7 +410,8 @@ where\n             move |acc, iter| iter.rfold(acc, &mut *fold)\n         }\n \n-        self.frontiter.into_iter()\n+        self.frontiter\n+            .into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .rfold(init, flatten(fold))"}, {"sha": "63036f516a0a4fc1d4a15544bd431e761a999246", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -20,10 +20,14 @@ pub trait Step: Clone + PartialOrd + Sized {\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n-    /// Replaces this step with `1`, returning itself.\n+    /// Replaces this step with `1`, returning a clone of itself.\n+    ///\n+    /// The output of this method should always be greater than the output of replace_zero.\n     fn replace_one(&mut self) -> Self;\n \n-    /// Replaces this step with `0`, returning itself.\n+    /// Replaces this step with `0`, returning a clone of itself.\n+    ///\n+    /// The output of this method should always be less than the output of replace_one.\n     fn replace_zero(&mut self) -> Self;\n \n     /// Adds one to this step, returning the result."}, {"sha": "ffac7d4e995389981fcb65d557cba78457751df4", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -12,23 +12,29 @@ use super::{FusedIterator, TrustedLen};\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n-    element: A\n+    element: A,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { Some(self.element.clone()) }\n+    fn next(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n+    fn next_back(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -91,7 +97,7 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n-    Repeat{element: elt}\n+    Repeat { element: elt }\n }\n \n /// An iterator that repeats elements of type `A` endlessly by\n@@ -104,18 +110,22 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n #[derive(Copy, Clone, Debug)]\n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n pub struct RepeatWith<F> {\n-    repeater: F\n+    repeater: F,\n }\n \n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { Some((self.repeater)()) }\n+    fn next(&mut self) -> Option<A> {\n+        Some((self.repeater)())\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n }\n \n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n@@ -213,7 +223,7 @@ impl<T> Iterator for Empty<T> {\n         None\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>){\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (0, Some(0))\n     }\n }\n@@ -283,7 +293,7 @@ pub const fn empty<T>() -> Empty<T> {\n #[derive(Clone, Debug)]\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub struct Once<T> {\n-    inner: crate::option::IntoIter<T>\n+    inner: crate::option::IntoIter<T>,\n }\n \n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n@@ -530,7 +540,8 @@ pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n #[inline]\n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n pub fn from_fn<T, F>(f: F) -> FromFn<F>\n-    where F: FnMut() -> Option<T>\n+where\n+    F: FnMut() -> Option<T>,\n {\n     FromFn(f)\n }\n@@ -547,7 +558,8 @@ pub struct FromFn<F>(F);\n \n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n impl<T, F> Iterator for FromFn<F>\n-    where F: FnMut() -> Option<T>\n+where\n+    F: FnMut() -> Option<T>,\n {\n     type Item = T;\n \n@@ -577,15 +589,13 @@ impl<F> fmt::Debug for FromFn<F> {\n /// ```\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n+where\n+    F: FnMut(&T) -> Option<T>,\n {\n     // If this function returned `impl Iterator<Item=T>`\n     // it could be based on `unfold` and not need a dedicated type.\n     // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n-    Successors {\n-        next: first,\n-        succ,\n-    }\n+    Successors { next: first, succ }\n }\n \n /// An new iterator where each successive item is computed based on the preceding one.\n@@ -603,7 +613,8 @@ pub struct Successors<T, F> {\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n impl<T, F> Iterator for Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n+where\n+    F: FnMut(&T) -> Option<T>,\n {\n     type Item = T;\n \n@@ -616,24 +627,16 @@ impl<T, F> Iterator for Successors<T, F>\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.next.is_some() {\n-            (1, None)\n-        } else {\n-            (0, Some(0))\n-        }\n+        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n     }\n }\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> FusedIterator for Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n-{}\n+impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Successors\")\n-            .field(\"next\", &self.next)\n-            .finish()\n+        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n     }\n }"}, {"sha": "65af671ddf2045005f24cf1a8b92a1eea5eb7e4b", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,6 +1,6 @@\n-use crate::ops::{Mul, Add};\n-use crate::num::Wrapping;\n use crate::iter;\n+use crate::num::Wrapping;\n+use crate::ops::{Add, Mul};\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n@@ -17,7 +17,7 @@ pub trait Sum<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n     /// \"summing up\" the items.\n     #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n+    fn sum<I: Iterator<Item = A>>(iter: I) -> Self;\n }\n \n /// Trait to represent types that can be created by multiplying elements of an\n@@ -36,7 +36,7 @@ pub trait Product<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n     /// multiplying the items.\n     #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n+    fn product<I: Iterator<Item = A>>(iter: I) -> Self;\n }\n \n // N.B., explicitly use Add and Mul here to inherit overflow checks\n@@ -115,9 +115,10 @@ macro_rules! float_sum_product {\n integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n float_sum_product! { f32 f64 }\n \n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+#[stable(feature = \"iter_arith_traits_result\", since = \"1.16.0\")]\n impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n-    where T: Sum<U>,\n+where\n+    T: Sum<U>,\n {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n@@ -137,21 +138,24 @@ impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     /// assert_eq!(res, Ok(3));\n     /// ```\n     fn sum<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n+    where\n+        I: Iterator<Item = Result<U, E>>,\n     {\n         iter::process_results(iter, |i| i.sum())\n     }\n }\n \n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+#[stable(feature = \"iter_arith_traits_result\", since = \"1.16.0\")]\n impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n-    where T: Product<U>,\n+where\n+    T: Product<U>,\n {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n     /// the product of all elements is returned.\n     fn product<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n+    where\n+        I: Iterator<Item = Result<U, E>>,\n     {\n         iter::process_results(iter, |i| i.product())\n     }"}, {"sha": "d6ae5cfe9e00e86147358de9996c063e89461f70", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -91,9 +91,9 @@\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    message=\"a collection of type `{Self}` cannot be built from an iterator \\\n+    message=\"a value of type `{Self}` cannot be built from an iterator \\\n              over elements of type `{A}`\",\n-    label=\"a collection of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n+    label=\"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n )]\n pub trait FromIterator<A>: Sized {\n     /// Creates a value from an iterator."}, {"sha": "104724d9fb63a2bae43f7e5c14f0fa08a0928054", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,5 +1,5 @@\n-use crate::ops::Try;\n use crate::iter::LoopState;\n+use crate::ops::Try;\n \n /// An iterator able to yield elements from both ends.\n ///\n@@ -113,7 +113,9 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"iter_nth_back\", since = \"1.37.0\")]\n     fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in self.rev() {\n-            if n == 0 { return Some(x) }\n+            if n == 0 {\n+                return Some(x);\n+            }\n             n -= 1;\n         }\n         None\n@@ -157,7 +159,7 @@ pub trait DoubleEndedIterator: Iterator {\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok=B>\n+        R: Try<Ok = B>,\n     {\n         let mut accum = init;\n         while let Some(x) = self.next_back() {\n@@ -279,7 +281,7 @@ pub trait DoubleEndedIterator: Iterator {\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,\n-        P: FnMut(&Self::Item) -> bool\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n         fn check<T>("}, {"sha": "61e8b07511a6741f0f86993ea0907db9f1a55d3d", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -201,12 +201,13 @@ pub trait Iterator {\n \n     /// Consumes the iterator, counting the number of iterations and returning it.\n     ///\n-    /// This method will evaluate the iterator until its [`next`] returns\n-    /// [`None`]. Once [`None`] is encountered, `count()` returns the number of\n-    /// times it called [`next`].\n+    /// This method will call [`next`] repeatedly until [`None`] is encountered,\n+    /// returning the number of times it saw [`Some`]. Note that [`next`] has to be\n+    /// called at least once even if the iterator does not have any elements.\n     ///\n     /// [`next`]: #tymethod.next\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n     ///\n     /// # Overflow Behavior\n     ///\n@@ -1254,7 +1255,7 @@ pub trait Iterator {\n         Fuse::new(self)\n     }\n \n-    /// Do something with each element of an iterator, passing the value on.\n+    /// Does something with each element of an iterator, passing the value on.\n     ///\n     /// When using iterators, you'll often chain several of them together.\n     /// While working on such code, you might want to check out what's\n@@ -1547,7 +1548,7 @@ pub trait Iterator {\n         (left, right)\n     }\n \n-    /// Reorder the elements of this iterator *in-place* according to the given predicate,\n+    /// Reorders the elements of this iterator *in-place* according to the given predicate,\n     /// such that all those that return `true` precede all those that return `false`.\n     /// Returns the number of `true` elements found.\n     ///"}, {"sha": "8a514f1e78e807d6efe5889931709ba6a241b52e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -74,6 +74,8 @@\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n+#![cfg_attr(not(bootstrap), feature(const_ptr_offset_from))]\n+#![cfg_attr(not(bootstrap), feature(const_type_name))]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]\n@@ -85,7 +87,7 @@\n #![feature(iter_once_with)]\n #![feature(lang_items)]\n #![feature(link_llvm_intrinsics)]\n-#![feature(never_type)]\n+#![cfg_attr(bootstrap, feature(never_type))]\n #![feature(nll)]\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n@@ -100,6 +102,7 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n+#![cfg_attr(not(bootstrap), feature(track_caller))]\n #![feature(transparent_unions)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]\n@@ -121,7 +124,6 @@\n #![feature(hexagon_target_feature)]\n #![feature(const_int_conversion)]\n #![feature(const_transmute)]\n-#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]"}, {"sha": "cf460745ffa3032faea6500731a7c0cffcbeda80", "filename": "src/libcore/macros/mod.rs", "status": "renamed", "additions": 142, "deletions": 91, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,30 +1,4 @@\n-/// Panics the current thread.\n-///\n-/// For details, see `std::macros`.\n-#[cfg(bootstrap)]\n-#[macro_export]\n-#[allow_internal_unstable(core_panic, panic_internals)]\n-#[stable(feature = \"core\", since = \"1.6.0\")]\n-macro_rules! panic {\n-    () => (\n-        $crate::panic!(\"explicit panic\")\n-    );\n-    ($msg:expr) => ({\n-        $crate::panicking::panic(&($msg, $crate::file!(), $crate::line!(), $crate::column!()))\n-    });\n-    ($msg:expr,) => (\n-        $crate::panic!($msg)\n-    );\n-    ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+),\n-                                     &($crate::file!(), $crate::line!(), $crate::column!()))\n-    });\n-}\n-\n-/// Panics the current thread.\n-///\n-/// For details, see `std::macros`.\n-#[cfg(not(bootstrap))]\n+#[doc(include = \"panic.md\")]\n #[macro_export]\n #[allow_internal_unstable(core_panic,\n     // FIXME(anp, eddyb) `core_intrinsics` is used here to allow calling\n@@ -363,13 +337,17 @@ macro_rules! matches {\n #[rustc_deprecated(since = \"1.39.0\", reason = \"use the `?` operator instead\")]\n #[doc(alias = \"?\")]\n macro_rules! r#try {\n-    ($expr:expr) => (match $expr {\n-        $crate::result::Result::Ok(val) => val,\n-        $crate::result::Result::Err(err) => {\n-            return $crate::result::Result::Err($crate::convert::From::from(err))\n+    ($expr:expr) => {\n+        match $expr {\n+            $crate::result::Result::Ok(val) => val,\n+            $crate::result::Result::Err(err) => {\n+                return $crate::result::Result::Err($crate::convert::From::from(err));\n+            }\n         }\n-    });\n-    ($expr:expr,) => ($crate::r#try!($expr));\n+    };\n+    ($expr:expr,) => {\n+        $crate::r#try!($expr)\n+    };\n }\n \n /// Writes formatted data into a buffer.\n@@ -760,8 +738,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! compile_error {\n-        ($msg:expr) => ({ /* compiler built-in */ });\n-        ($msg:expr,) => ({ /* compiler built-in */ })\n+        ($msg:expr) => {{ /* compiler built-in */ }};\n+        ($msg:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Constructs parameters for the other string-formatting macros.\n@@ -814,20 +792,23 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! format_args {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+        ($fmt:expr) => {{ /* compiler built-in */ }};\n+        ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Same as `format_args`, but adds a newline in the end.\n-    #[unstable(feature = \"format_args_nl\", issue = \"0\",\n-               reason = \"`format_args_nl` is only for internal \\\n-                         language use and is subject to change\")]\n+    #[unstable(\n+        feature = \"format_args_nl\",\n+        issue = \"0\",\n+        reason = \"`format_args_nl` is only for internal \\\n+                  language use and is subject to change\"\n+    )]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! format_args_nl {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+        ($fmt:expr) => {{ /* compiler built-in */ }};\n+        ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Inspects an environment variable at compile time.\n@@ -865,8 +846,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ })\n+        ($name:expr) => {{ /* compiler built-in */ }};\n+        ($name:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Optionally inspects an environment variable at compile time.\n@@ -892,8 +873,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! option_env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ })\n+        ($name:expr) => {{ /* compiler built-in */ }};\n+        ($name:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Concatenates identifiers into one identifier.\n@@ -920,13 +901,16 @@ pub(crate) mod builtin {\n     /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n     /// # }\n     /// ```\n-    #[unstable(feature = \"concat_idents\", issue = \"29599\",\n-               reason = \"`concat_idents` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"concat_idents\",\n+        issue = \"29599\",\n+        reason = \"`concat_idents` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! concat_idents {\n-        ($($e:ident),+) => ({ /* compiler built-in */ });\n-        ($($e:ident,)+) => ({ /* compiler built-in */ })\n+        ($($e:ident),+) => {{ /* compiler built-in */ }};\n+        ($($e:ident,)+) => {{ /* compiler built-in */ }};\n     }\n \n     /// Concatenates literals into a static string slice.\n@@ -948,8 +932,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! concat {\n-        ($($e:expr),*) => ({ /* compiler built-in */ });\n-        ($($e:expr,)*) => ({ /* compiler built-in */ })\n+        ($($e:expr),*) => {{ /* compiler built-in */ }};\n+        ($($e:expr,)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Expands to the line number on which it was invoked.\n@@ -976,7 +960,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! line { () => { /* compiler built-in */ } }\n+    macro_rules! line {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Expands to the column number at which it was invoked.\n     ///\n@@ -1002,7 +990,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! column { () => { /* compiler built-in */ } }\n+    macro_rules! column {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Expands to the file name in which it was invoked.\n     ///\n@@ -1027,7 +1019,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! file { () => { /* compiler built-in */ } }\n+    macro_rules! file {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Stringifies its arguments.\n     ///\n@@ -1047,7 +1043,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! stringify { ($($t:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! stringify {\n+        ($($t:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n@@ -1083,8 +1083,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include_str {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Includes a file as a reference to a byte array.\n@@ -1121,8 +1121,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include_bytes {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Expands to a string that represents the current module path.\n@@ -1145,7 +1145,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! module_path { () => { /* compiler built-in */ } }\n+    macro_rules! module_path {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Evaluates boolean combinations of configuration flags at compile-time.\n     ///\n@@ -1170,7 +1174,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! cfg { ($($cfg:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! cfg {\n+        ($($cfg:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Parses a file as an expression or an item according to the context.\n     ///\n@@ -1215,8 +1223,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Asserts that a boolean expression is `true` at runtime.\n@@ -1268,85 +1276,128 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! assert {\n-        ($cond:expr) => ({ /* compiler built-in */ });\n-        ($cond:expr,) => ({ /* compiler built-in */ });\n-        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ })\n+        ($cond:expr) => {{ /* compiler built-in */ }};\n+        ($cond:expr,) => {{ /* compiler built-in */ }};\n+        ($cond:expr, $($arg:tt)+) => {{ /* compiler built-in */ }};\n     }\n \n     /// Inline assembly.\n     ///\n     /// Read the [unstable book] for the usage.\n     ///\n     /// [unstable book]: ../unstable-book/library-features/asm.html\n-    #[unstable(feature = \"asm\", issue = \"29722\",\n-               reason = \"inline assembly is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"asm\",\n+        issue = \"29722\",\n+        reason = \"inline assembly is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! asm { (\"assembly template\"\n+    macro_rules! asm {\n+        (\"assembly template\"\n                         : $(\"output\"(operand),)*\n                         : $(\"input\"(operand),)*\n                         : $(\"clobbers\",)*\n-                        : $(\"options\",)*) => { /* compiler built-in */ } }\n+                        : $(\"options\",)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Module-level inline assembly.\n-    #[unstable(feature = \"global_asm\", issue = \"35119\",\n-               reason = \"`global_asm!` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"global_asm\",\n+        issue = \"35119\",\n+        reason = \"`global_asm!` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! global_asm { (\"assembly\") => { /* compiler built-in */ } }\n+    macro_rules! global_asm {\n+        (\"assembly\") => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Prints passed tokens into the standard output.\n-    #[unstable(feature = \"log_syntax\", issue = \"29598\",\n-               reason = \"`log_syntax!` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"log_syntax\",\n+        issue = \"29598\",\n+        reason = \"`log_syntax!` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! log_syntax { ($($arg:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! log_syntax {\n+        ($($arg:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Enables or disables tracing functionality used for debugging other macros.\n-    #[unstable(feature = \"trace_macros\", issue = \"29598\",\n-               reason = \"`trace_macros` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"trace_macros\",\n+        issue = \"29598\",\n+        reason = \"`trace_macros` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! trace_macros {\n-        (true) => ({ /* compiler built-in */ });\n-        (false) => ({ /* compiler built-in */ })\n+        (true) => {{ /* compiler built-in */ }};\n+        (false) => {{ /* compiler built-in */ }};\n     }\n \n     /// Attribute macro applied to a function to turn it into a unit test.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro test($item:item) { /* compiler built-in */ }\n+    pub macro test($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n-    #[unstable(soft, feature = \"test\", issue = \"50297\",\n-               reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n+    #[unstable(\n+        feature = \"test\",\n+        issue = \"50297\",\n+        soft,\n+        reason = \"`bench` is a part of custom test frameworks which are unstable\"\n+    )]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro bench($item:item) { /* compiler built-in */ }\n+    pub macro bench($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n-    #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n-               reason = \"custom test frameworks are an unstable feature\")]\n+    #[unstable(\n+        feature = \"custom_test_frameworks\",\n+        issue = \"50297\",\n+        reason = \"custom test frameworks are an unstable feature\"\n+    )]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro test_case($item:item) { /* compiler built-in */ }\n+    pub macro test_case($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro global_allocator($item:item) { /* compiler built-in */ }\n+    pub macro global_allocator($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n-    pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n+    pub macro RustcDecodable($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro RustcEncodable($item:item) { /* compiler built-in */ }\n+    pub macro RustcEncodable($item:item) {\n+        /* compiler built-in */\n+    }\n }", "previous_filename": "src/libcore/macros.rs"}, {"sha": "3ecfc43be049b534478bb5bdaf58dfac63f31a94", "filename": "src/libcore/macros/panic.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmacros%2Fpanic.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmacros%2Fpanic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fpanic.md?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -0,0 +1,47 @@\n+Panics the current thread.\n+\n+This allows a program to terminate immediately and provide feedback\n+to the caller of the program. `panic!` should be used when a program reaches\n+an unrecoverable state.\n+\n+This macro is the perfect way to assert conditions in example code and in\n+tests. `panic!` is closely tied with the `unwrap` method of both [`Option`]\n+and [`Result`][runwrap] enums. Both implementations call `panic!` when they are set\n+to None or Err variants.\n+\n+This macro is used to inject panic into a Rust thread, causing the thread to\n+panic entirely. Each thread's panic can be reaped as the `Box<Any>` type,\n+and the single-argument form of the `panic!` macro will be the value which\n+is transmitted.\n+\n+[`Result`] enum is often a better solution for recovering from errors than\n+using the `panic!` macro. This macro should be used to avoid proceeding using\n+incorrect values, such as from external sources. Detailed information about\n+error handling is found in the [book].\n+\n+The multi-argument form of this macro panics with a string and has the\n+[`format!`] syntax for building a string.\n+\n+See also the macro [`compile_error!`], for raising errors during compilation.\n+\n+[runwrap]: ../std/result/enum.Result.html#method.unwrap\n+[`Option`]: ../std/option/enum.Option.html#method.unwrap\n+[`Result`]: ../std/result/enum.Result.html\n+[`format!`]: ../std/macro.format.html\n+[`compile_error!`]: ../std/macro.compile_error.html\n+[book]: ../book/ch09-00-error-handling.html\n+\n+# Current implementation\n+\n+If the main thread panics it will terminate all your threads and end your\n+program with code `101`.\n+\n+# Examples\n+\n+```should_panic\n+# #![allow(unreachable_code)]\n+panic!();\n+panic!(\"this is a terrible mistake!\");\n+panic!(4); // panic with the value of 4 to be collected elsewhere\n+panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n+```"}, {"sha": "86ee673cea941589af8af9b764ee3e02688f6e94", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -146,7 +146,6 @@ pub trait Unsize<T: ?Sized> {\n ///\n /// [RFC1445]: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md\n /// [issue 63438]: https://github.com/rust-lang/rust/issues/63438\n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"structural_match\", issue = \"31434\")]\n #[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(PartialEq)]`\")]\n #[lang = \"structural_peq\"]\n@@ -197,7 +196,6 @@ pub trait StructuralPartialEq {\n /// As a hack to work around this, we use two separate traits injected by each\n /// of the two derives (`#[derive(PartialEq)]` and `#[derive(Eq)]`) and check\n /// that both of them are present as part of structural-match checking.\n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"structural_match\", issue = \"31434\")]\n #[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(Eq)]`\")]\n #[lang = \"structural_teq\"]\n@@ -517,11 +515,9 @@ macro_rules! impls{\n             }\n         }\n \n-        #[cfg(not(bootstrap))]\n         #[unstable(feature = \"structural_match\", issue = \"31434\")]\n         impl<T: ?Sized> StructuralPartialEq for $t<T> { }\n \n-        #[cfg(not(bootstrap))]\n         #[unstable(feature = \"structural_match\", issue = \"31434\")]\n         impl<T: ?Sized> StructuralEq for $t<T> { }\n         )\n@@ -778,7 +774,7 @@ mod copy_impls {\n         bool char\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.41.0\")]\n     impl Copy for ! {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "34fc0618ea2ae182655e4db3e02b95a2ef9c846f", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,5 +1,5 @@\n-use crate::ptr;\n use crate::ops::{Deref, DerefMut};\n+use crate::ptr;\n \n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n ///"}, {"sha": "6661df2ae0d8414c4a17e27102fc3b4d7acf345f", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,3 +1,5 @@\n+use crate::any::type_name;\n+use crate::fmt;\n use crate::intrinsics;\n use crate::mem::ManuallyDrop;\n \n@@ -232,6 +234,13 @@ impl<T: Copy> Clone for MaybeUninit<T> {\n     }\n }\n \n+#[stable(feature = \"maybe_uninit_debug\", since = \"1.41.0\")]\n+impl<T> fmt::Debug for MaybeUninit<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(type_name::<Self>())\n+    }\n+}\n+\n impl<T> MaybeUninit<T> {\n     /// Creates a new `MaybeUninit<T>` initialized with the given value.\n     /// It is safe to call [`assume_init`] on the return value of this function."}, {"sha": "bba441464ff35bf22452748bd111b82829249b00", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -45,8 +45,9 @@ pub use crate::intrinsics::transmute;\n /// `mem::forget` from safe code does not fundamentally change Rust's safety\n /// guarantees.\n ///\n-/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n-/// so `forget` is only recommended for specialized use cases like those shown below.\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable.\n+/// The need comes up in some specialized use cases for FFI or unsafe code, but even\n+/// then, [`ManuallyDrop`] is typically preferred.\n ///\n /// Because forgetting a value is allowed, any `unsafe` code you write must\n /// allow for this possibility. You cannot return a value and expect that the\n@@ -68,7 +69,35 @@ pub use crate::intrinsics::transmute;\n /// ```\n ///\n /// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code.\n+/// up in unsafe or FFI code. However, [`ManuallyDrop`] is usually preferred\n+/// for such cases, e.g.:\n+///\n+/// ```\n+/// use std::mem::ManuallyDrop;\n+///\n+/// let v = vec![65, 122];\n+/// // Before we disassemble `v` into its raw parts, make sure it\n+/// // does not get dropped!\n+/// let mut v = ManuallyDrop::new(v);\n+/// // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n+/// let ptr = v.as_mut_ptr();\n+/// let cap = v.capacity();\n+/// // Finally, build a `String`.\n+/// let s = unsafe { String::from_raw_parts(ptr, 2, cap) };\n+/// assert_eq!(s, \"Az\");\n+/// // `s` is implicitly dropped and its memory deallocated.\n+/// ```\n+///\n+/// Using `ManuallyDrop` here has two advantages:\n+///\n+/// * We do not \"touch\" `v` after disassembling it. For some types, operations\n+///   such as passing ownership (to a funcion like `mem::forget`) requires them to actually\n+///   be fully owned right now; that is a promise we do not want to make here as we are\n+///   in the process of transferring ownership to the new `String` we are building.\n+/// * In case of an unexpected panic, `ManuallyDrop` is not dropped, but if the panic\n+///   occurs before `mem::forget` was called we might end up dropping invalid data,\n+///   or double-dropping. In other words, `ManuallyDrop` errs on the side of leaking\n+///   instead of erring on the side of dropping.\n ///\n /// [drop]: fn.drop.html\n /// [uninit]: fn.uninitialized.html\n@@ -78,6 +107,7 @@ pub use crate::intrinsics::transmute;\n /// [leak]: ../../std/boxed/struct.Box.html#method.leak\n /// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n /// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [`ManuallyDrop`]: struct.ManuallyDrop.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n@@ -744,20 +774,20 @@ pub fn drop<T>(_x: T) { }\n ///     bar: u8,\n /// }\n ///\n-/// let foo_slice = [10u8];\n+/// let foo_array = [10u8];\n ///\n /// unsafe {\n-///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n-///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n+///     // Copy the data from 'foo_array' and treat it as a 'Foo'\n+///     let mut foo_struct: Foo = mem::transmute_copy(&foo_array);\n ///     assert_eq!(foo_struct.bar, 10);\n ///\n ///     // Modify the copied data\n ///     foo_struct.bar = 20;\n ///     assert_eq!(foo_struct.bar, 20);\n /// }\n ///\n-/// // The contents of 'foo_slice' should not have changed\n-/// assert_eq!(foo_slice, [10]);\n+/// // The contents of 'foo_array' should not have changed\n+/// assert_eq!(foo_array, [10]);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b8ddd5322a1da04245272c1dfdc98f0c8aa99d67", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -12,13 +12,15 @@\n // This module is only for dec2flt and flt2dec, and only public because of coretests.\n // It is not intended to ever be stabilized.\n #![doc(hidden)]\n-#![unstable(feature = \"core_private_bignum\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"core_private_bignum\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n #![macro_use]\n \n-use crate::mem;\n use crate::intrinsics;\n+use crate::mem;\n \n /// Arithmetic operations required by bignums.\n pub trait FullOps: Sized {\n@@ -36,10 +38,8 @@ pub trait FullOps: Sized {\n \n     /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n     /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n-    fn full_div_rem(self,\n-                    other: Self,\n-                    borrow: Self)\n-                    -> (Self /* quotient */, Self /* remainder */);\n+    fn full_div_rem(self, other: Self, borrow: Self)\n+    -> (Self /* quotient */, Self /* remainder */);\n }\n \n macro_rules! impl_full_ops {\n@@ -98,7 +98,7 @@ impl_full_ops! {\n const SMALL_POW5: [(u64, usize); 3] = [(125, 3), (15625, 6), (1_220_703_125, 13)];\n \n macro_rules! define_bignum {\n-    ($name:ident: type=$ty:ty, n=$n:expr) => (\n+    ($name:ident: type=$ty:ty, n=$n:expr) => {\n         /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n         ///\n         /// This is backed by a fixed-size array of given type (\"digit\").\n@@ -115,7 +115,7 @@ macro_rules! define_bignum {\n             size: usize,\n             /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n             /// where `W` is the number of bits in the digit type.\n-            base: [$ty; $n]\n+            base: [$ty; $n],\n         }\n \n         impl $name {\n@@ -180,7 +180,7 @@ macro_rules! define_bignum {\n                 }\n                 // This could be optimized with leading_zeros() and bit shifts, but that's\n                 // probably not worth the hassle.\n-                let digitbits = mem::size_of::<$ty>()* 8;\n+                let digitbits = mem::size_of::<$ty>() * 8;\n                 let mut i = nonzero.len() * digitbits - 1;\n                 while self.get_bit(i) == 0 {\n                     i -= 1;\n@@ -272,12 +272,12 @@ macro_rules! define_bignum {\n                 let bits = bits % digitbits;\n \n                 assert!(digits < $n);\n-                debug_assert!(self.base[$n-digits..].iter().all(|&v| v == 0));\n-                debug_assert!(bits == 0 || (self.base[$n-digits-1] >> (digitbits - bits)) == 0);\n+                debug_assert!(self.base[$n - digits..].iter().all(|&v| v == 0));\n+                debug_assert!(bits == 0 || (self.base[$n - digits - 1] >> (digitbits - bits)) == 0);\n \n                 // shift by `digits * digitbits` bits\n                 for i in (0..self.size).rev() {\n-                    self.base[i+digits] = self.base[i];\n+                    self.base[i + digits] = self.base[i];\n                 }\n                 for i in 0..digits {\n                     self.base[i] = 0;\n@@ -287,14 +287,14 @@ macro_rules! define_bignum {\n                 let mut sz = self.size + digits;\n                 if bits > 0 {\n                     let last = sz;\n-                    let overflow = self.base[last-1] >> (digitbits - bits);\n+                    let overflow = self.base[last - 1] >> (digitbits - bits);\n                     if overflow > 0 {\n                         self.base[last] = overflow;\n                         sz += 1;\n                     }\n-                    for i in (digits+1..last).rev() {\n-                        self.base[i] = (self.base[i] << bits) |\n-                                       (self.base[i-1] >> (digitbits - bits));\n+                    for i in (digits + 1..last).rev() {\n+                        self.base[i] =\n+                            (self.base[i] << bits) | (self.base[i - 1] >> (digitbits - bits));\n                     }\n                     self.base[digits] <<= bits;\n                     // self.base[..digits] is zero, no need to shift\n@@ -331,7 +331,6 @@ macro_rules! define_bignum {\n                 self\n             }\n \n-\n             /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n             /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n             /// and returns its own mutable reference.\n@@ -342,7 +341,9 @@ macro_rules! define_bignum {\n \n                     let mut retsz = 0;\n                     for (i, &a) in aa.iter().enumerate() {\n-                        if a == 0 { continue; }\n+                        if a == 0 {\n+                            continue;\n+                        }\n                         let mut sz = bb.len();\n                         let mut carry = 0;\n                         for (j, &b) in bb.iter().enumerate() {\n@@ -430,11 +431,12 @@ macro_rules! define_bignum {\n         }\n \n         impl crate::cmp::PartialEq for $name {\n-            fn eq(&self, other: &$name) -> bool { self.base[..] == other.base[..] }\n+            fn eq(&self, other: &$name) -> bool {\n+                self.base[..] == other.base[..]\n+            }\n         }\n \n-        impl crate::cmp::Eq for $name {\n-        }\n+        impl crate::cmp::Eq for $name {}\n \n         impl crate::cmp::PartialOrd for $name {\n             fn partial_cmp(&self, other: &$name) -> crate::option::Option<crate::cmp::Ordering> {\n@@ -462,17 +464,17 @@ macro_rules! define_bignum {\n             fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                 use crate::mem;\n \n-                let sz = if self.size < 1 {1} else {self.size};\n+                let sz = if self.size < 1 { 1 } else { self.size };\n                 let digitlen = mem::size_of::<$ty>() * 2;\n \n-                write!(f, \"{:#x}\", self.base[sz-1])?;\n-                for &v in self.base[..sz-1].iter().rev() {\n+                write!(f, \"{:#x}\", self.base[sz - 1])?;\n+                for &v in self.base[..sz - 1].iter().rev() {\n                     write!(f, \"_{:01$x}\", v, digitlen)?;\n                 }\n                 crate::result::Result::Ok(())\n             }\n         }\n-    )\n+    };\n }\n \n /// The digit type for `Big32x40`."}, {"sha": "c5f6903f379c405cc294695ddb5d129044ba67c0", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,11 +1,11 @@\n //! The various algorithms from the paper.\n \n use crate::cmp::min;\n-use crate::cmp::Ordering::{Less, Equal, Greater};\n-use crate::num::diy_float::Fp;\n-use crate::num::dec2flt::table;\n-use crate::num::dec2flt::rawfp::{self, Unpacked, RawFloat, fp_to_float, next_float, prev_float};\n+use crate::cmp::Ordering::{Equal, Greater, Less};\n use crate::num::dec2flt::num::{self, Big};\n+use crate::num::dec2flt::rawfp::{self, fp_to_float, next_float, prev_float, RawFloat, Unpacked};\n+use crate::num::dec2flt::table;\n+use crate::num::diy_float::Fp;\n \n /// Number of significand bits in Fp\n const P: u32 = 64;\n@@ -23,17 +23,17 @@ fn power_of_ten(e: i16) -> Fp {\n \n // In most architectures, floating point operations have an explicit bit size, therefore the\n // precision of the computation is determined on a per-operation basis.\n-#[cfg(any(not(target_arch=\"x86\"), target_feature=\"sse2\"))]\n+#[cfg(any(not(target_arch = \"x86\"), target_feature = \"sse2\"))]\n mod fpu_precision {\n-    pub fn set_precision<T>() { }\n+    pub fn set_precision<T>() {}\n }\n \n // On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.\n // The x87 FPU operates with 80 bits of precision by default, which means that operations will\n // round to 80 bits causing double rounding to happen when values are eventually represented as\n // 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n // computations are performed in the desired precision.\n-#[cfg(all(target_arch=\"x86\", not(target_feature=\"sse2\")))]\n+#[cfg(all(target_arch = \"x86\", not(target_feature = \"sse2\")))]\n mod fpu_precision {\n     use crate::mem::size_of;\n "}, {"sha": "6fe9af8cbd8ee93bd2cd00067a398a0f594a233d", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -78,23 +78,25 @@\n //! turned into {positive,negative} {zero,infinity}.\n \n #![doc(hidden)]\n-#![unstable(feature = \"dec2flt\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"dec2flt\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n use crate::fmt;\n use crate::str::FromStr;\n \n-use self::parse::{parse_decimal, Decimal, Sign, ParseResult};\n use self::num::digits_to_big;\n+use self::parse::{parse_decimal, Decimal, ParseResult, Sign};\n use self::rawfp::RawFloat;\n \n mod algorithm;\n-mod table;\n mod num;\n+mod table;\n // These two have their own tests.\n-pub mod rawfp;\n pub mod parse;\n+pub mod rawfp;\n \n macro_rules! from_str_float_impl {\n     ($t:ty) => {\n@@ -155,7 +157,7 @@ macro_rules! from_str_float_impl {\n                 dec2flt(src)\n             }\n         }\n-    }\n+    };\n }\n from_str_float_impl!(f32);\n from_str_float_impl!(f64);\n@@ -171,7 +173,7 @@ from_str_float_impl!(f64);\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseFloatError {\n-    kind: FloatErrorKind\n+    kind: FloatErrorKind,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -181,10 +183,12 @@ enum FloatErrorKind {\n }\n \n impl ParseFloatError {\n-    #[unstable(feature = \"int_error_internals\",\n-               reason = \"available through Error trait and this method should \\\n-                         not be exposed publicly\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"0\"\n+    )]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n         match self.kind {\n@@ -222,7 +226,7 @@ fn extract_sign(s: &str) -> (Sign, &str) {\n /// Converts a decimal string into a floating point number.\n fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     if s.is_empty() {\n-        return Err(pfe_empty())\n+        return Err(pfe_empty());\n     }\n     let (sign, s) = extract_sign(s);\n     let flt = match parse_decimal(s) {\n@@ -232,8 +236,10 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n         ParseResult::Invalid => match s {\n             \"inf\" => T::INFINITY,\n             \"NaN\" => T::NAN,\n-            _ => { return Err(pfe_invalid()); }\n-        }\n+            _ => {\n+                return Err(pfe_invalid());\n+            }\n+        },\n     };\n \n     match sign {"}, {"sha": "208783dd32fd5df8c271cbb0c69e308b4f3e1f2b", "filename": "src/libcore/num/dec2flt/num.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -2,7 +2,7 @@\n \n // FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.\n \n-use crate::cmp::Ordering::{self, Less, Equal, Greater};\n+use crate::cmp::Ordering::{self, Equal, Greater, Less};\n \n pub use crate::num::bignum::Big32x40 as Big;\n \n@@ -36,7 +36,10 @@ pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n /// 1. using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and\n /// 2. piecing together the results of `integral.parse()` and `fractional.parse()` is\n ///    more complicated than this entire function.\n-pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'a u8> {\n+pub fn from_str_unchecked<'a, T>(bytes: T) -> u64\n+where\n+    T: IntoIterator<Item = &'a u8>,\n+{\n     let mut result = 0;\n     for &c in bytes {\n         result = result * 10 + (c - b'0') as u64;\n@@ -61,14 +64,9 @@ pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n pub fn to_u64(x: &Big) -> u64 {\n     assert!(x.bit_length() < 64);\n     let d = x.digits();\n-    if d.len() < 2 {\n-        d[0] as u64\n-    } else {\n-        (d[1] as u64) << 32 | d[0] as u64\n-    }\n+    if d.len() < 2 { d[0] as u64 } else { (d[1] as u64) << 32 | d[0] as u64 }\n }\n \n-\n /// Extracts a range of bits.\n \n /// Index 0 is the least significant bit and the range is half-open as usual."}, {"sha": "93b08bce853c7e44e143229016be2572232b07af", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -10,8 +10,8 @@\n //! modules rely on to not panic (or overflow) in turn.\n //! To make matters worse, all that happens in a single pass over the input.\n //! So, be careful when modifying anything, and double-check with the other modules.\n+use self::ParseResult::{Invalid, ShortcutToInf, ShortcutToZero, Valid};\n use super::num;\n-use self::ParseResult::{Valid, ShortcutToInf, ShortcutToZero, Invalid};\n \n #[derive(Debug)]\n pub enum Sign {"}, {"sha": "a127c6c3fa7ceef4b886664e4ae35da7a95951b2", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -17,15 +17,15 @@\n //! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n //! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n //! That algorithm needs only next_float() which does handle subnormals and zeros.\n-use crate::cmp::Ordering::{Less, Equal, Greater};\n+use crate::cmp::Ordering::{Equal, Greater, Less};\n use crate::convert::{TryFrom, TryInto};\n-use crate::ops::{Add, Mul, Div, Neg};\n use crate::fmt::{Debug, LowerExp};\n-use crate::num::diy_float::Fp;\n-use crate::num::FpCategory::{Infinite, Zero, Subnormal, Normal, Nan};\n-use crate::num::FpCategory;\n use crate::num::dec2flt::num::{self, Big};\n use crate::num::dec2flt::table;\n+use crate::num::diy_float::Fp;\n+use crate::num::FpCategory;\n+use crate::num::FpCategory::{Infinite, Nan, Normal, Subnormal, Zero};\n+use crate::ops::{Add, Div, Mul, Neg};\n \n #[derive(Copy, Clone, Debug)]\n pub struct Unpacked {\n@@ -44,13 +44,8 @@ impl Unpacked {\n /// See the parent module's doc comment for why this is necessary.\n ///\n /// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n-pub trait RawFloat\n-    : Copy\n-    + Debug\n-    + LowerExp\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Neg<Output=Self>\n+pub trait RawFloat:\n+    Copy + Debug + LowerExp + Mul<Output = Self> + Div<Output = Self> + Neg<Output = Self>\n {\n     const INFINITY: Self;\n     const NAN: Self;\n@@ -144,7 +139,7 @@ macro_rules! other_constants {\n         const INFINITY: Self = $crate::$type::INFINITY;\n         const NAN: Self = $crate::$type::NAN;\n         const ZERO: Self = 0.0;\n-    }\n+    };\n }\n \n impl RawFloat for f32 {\n@@ -163,11 +158,8 @@ impl RawFloat for f32 {\n         let bits = self.to_bits();\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n+        let mantissa =\n+            if exponent == 0 { (bits & 0x7fffff) << 1 } else { (bits & 0x7fffff) | 0x800000 };\n         // Exponent bias + mantissa shift\n         exponent -= 127 + 23;\n         (mantissa as u64, exponent, sign)\n@@ -188,12 +180,17 @@ impl RawFloat for f32 {\n         table::F32_SHORT_POWERS[e]\n     }\n \n-    fn classify(self) -> FpCategory { self.classify() }\n-    fn to_bits(self) -> Self::Bits { self.to_bits() }\n-    fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n+    fn classify(self) -> FpCategory {\n+        self.classify()\n+    }\n+    fn to_bits(self) -> Self::Bits {\n+        self.to_bits()\n+    }\n+    fn from_bits(v: Self::Bits) -> Self {\n+        Self::from_bits(v)\n+    }\n }\n \n-\n impl RawFloat for f64 {\n     type Bits = u64;\n \n@@ -235,9 +232,15 @@ impl RawFloat for f64 {\n         table::F64_SHORT_POWERS[e]\n     }\n \n-    fn classify(self) -> FpCategory { self.classify() }\n-    fn to_bits(self) -> Self::Bits { self.to_bits() }\n-    fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n+    fn classify(self) -> FpCategory {\n+        self.classify()\n+    }\n+    fn to_bits(self) -> Self::Bits {\n+        self.to_bits()\n+    }\n+    fn from_bits(v: Self::Bits) -> Self {\n+        Self::from_bits(v)\n+    }\n }\n \n /// Converts an `Fp` to the closest machine float type.\n@@ -248,7 +251,7 @@ pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n     let e = x.e + 63;\n     if e > T::MAX_EXP {\n         panic!(\"fp_to_float: exponent {} too large\", e)\n-    }  else if e > T::MIN_EXP {\n+    } else if e > T::MIN_EXP {\n         encode_normal(round_normal::<T>(x))\n     } else {\n         panic!(\"fp_to_float: exponent {} too small\", e)\n@@ -278,14 +281,15 @@ pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n /// Inverse of `RawFloat::unpack()` for normalized numbers.\n /// Panics if the significand or exponent are not valid for normalized numbers.\n pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n-    debug_assert!(T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n-        \"encode_normal: significand not normalized\");\n+    debug_assert!(\n+        T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n+        \"encode_normal: significand not normalized\"\n+    );\n     // Remove the hidden bit\n     let sig_enc = x.sig & !(1 << T::EXPLICIT_SIG_BITS);\n     // Adjust the exponent for exponent bias and mantissa shift\n     let k_enc = x.k + T::MAX_EXP + T::EXPLICIT_SIG_BITS as i16;\n-    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP,\n-        \"encode_normal: exponent out of range\");\n+    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP, \"encode_normal: exponent out of range\");\n     // Leave sign bit at 0 (\"+\"), our numbers are all positive\n     let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\n     T::from_bits(bits.try_into().unwrap_or_else(|_| unreachable!()))\n@@ -315,7 +319,7 @@ pub fn big_to_fp(f: &Big) -> Fp {\n         Equal | Greater => match leading.checked_add(1) {\n             Some(f) => Fp { f, e }.normalize(),\n             None => Fp { f: 1 << 63, e: e + 1 },\n-        }\n+        },\n     }\n }\n \n@@ -354,8 +358,6 @@ pub fn next_float<T: RawFloat>(x: T) -> T {\n         // want, and the mantissa bits become zero. Because of the hidden bit convention, this\n         // too is exactly what we want!\n         // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\n-        Zero | Subnormal | Normal => {\n-            T::from_bits(x.to_bits() + T::Bits::from(1u8))\n-        }\n+        Zero | Subnormal | Normal => T::from_bits(x.to_bits() + T::Bits::from(1u8)),\n     }\n }"}, {"sha": "1bd94ffa04e0e327b011271e294c4b8f5e20ec57", "filename": "src/libcore/num/dec2flt/table.rs", "status": "modified", "additions": 1231, "deletions": 1225, "changes": 2456, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,1232 +4,1237 @@\n pub const MIN_E: i16 = -305;\n pub const MAX_E: i16 = 305;\n \n-pub const POWERS: ([u64; 611], [i16; 611]) = ([\n-    0xe0b62e2929aba83c,\n-    0x8c71dcd9ba0b4926,\n-    0xaf8e5410288e1b6f,\n-    0xdb71e91432b1a24b,\n-    0x892731ac9faf056f,\n-    0xab70fe17c79ac6ca,\n-    0xd64d3d9db981787d,\n-    0x85f0468293f0eb4e,\n-    0xa76c582338ed2622,\n-    0xd1476e2c07286faa,\n-    0x82cca4db847945ca,\n-    0xa37fce126597973d,\n-    0xcc5fc196fefd7d0c,\n-    0xff77b1fcbebcdc4f,\n-    0x9faacf3df73609b1,\n-    0xc795830d75038c1e,\n-    0xf97ae3d0d2446f25,\n-    0x9becce62836ac577,\n-    0xc2e801fb244576d5,\n-    0xf3a20279ed56d48a,\n-    0x9845418c345644d7,\n-    0xbe5691ef416bd60c,\n-    0xedec366b11c6cb8f,\n-    0x94b3a202eb1c3f39,\n-    0xb9e08a83a5e34f08,\n-    0xe858ad248f5c22ca,\n-    0x91376c36d99995be,\n-    0xb58547448ffffb2e,\n-    0xe2e69915b3fff9f9,\n-    0x8dd01fad907ffc3c,\n-    0xb1442798f49ffb4b,\n-    0xdd95317f31c7fa1d,\n-    0x8a7d3eef7f1cfc52,\n-    0xad1c8eab5ee43b67,\n-    0xd863b256369d4a41,\n-    0x873e4f75e2224e68,\n-    0xa90de3535aaae202,\n-    0xd3515c2831559a83,\n-    0x8412d9991ed58092,\n-    0xa5178fff668ae0b6,\n-    0xce5d73ff402d98e4,\n-    0x80fa687f881c7f8e,\n-    0xa139029f6a239f72,\n-    0xc987434744ac874f,\n-    0xfbe9141915d7a922,\n-    0x9d71ac8fada6c9b5,\n-    0xc4ce17b399107c23,\n-    0xf6019da07f549b2b,\n-    0x99c102844f94e0fb,\n-    0xc0314325637a193a,\n-    0xf03d93eebc589f88,\n-    0x96267c7535b763b5,\n-    0xbbb01b9283253ca3,\n-    0xea9c227723ee8bcb,\n-    0x92a1958a7675175f,\n-    0xb749faed14125d37,\n-    0xe51c79a85916f485,\n-    0x8f31cc0937ae58d3,\n-    0xb2fe3f0b8599ef08,\n-    0xdfbdcece67006ac9,\n-    0x8bd6a141006042be,\n-    0xaecc49914078536d,\n-    0xda7f5bf590966849,\n-    0x888f99797a5e012d,\n-    0xaab37fd7d8f58179,\n-    0xd5605fcdcf32e1d7,\n-    0x855c3be0a17fcd26,\n-    0xa6b34ad8c9dfc070,\n-    0xd0601d8efc57b08c,\n-    0x823c12795db6ce57,\n-    0xa2cb1717b52481ed,\n-    0xcb7ddcdda26da269,\n-    0xfe5d54150b090b03,\n-    0x9efa548d26e5a6e2,\n-    0xc6b8e9b0709f109a,\n-    0xf867241c8cc6d4c1,\n-    0x9b407691d7fc44f8,\n-    0xc21094364dfb5637,\n-    0xf294b943e17a2bc4,\n-    0x979cf3ca6cec5b5b,\n-    0xbd8430bd08277231,\n-    0xece53cec4a314ebe,\n-    0x940f4613ae5ed137,\n-    0xb913179899f68584,\n-    0xe757dd7ec07426e5,\n-    0x9096ea6f3848984f,\n-    0xb4bca50b065abe63,\n-    0xe1ebce4dc7f16dfc,\n-    0x8d3360f09cf6e4bd,\n-    0xb080392cc4349ded,\n-    0xdca04777f541c568,\n-    0x89e42caaf9491b61,\n-    0xac5d37d5b79b6239,\n-    0xd77485cb25823ac7,\n-    0x86a8d39ef77164bd,\n-    0xa8530886b54dbdec,\n-    0xd267caa862a12d67,\n-    0x8380dea93da4bc60,\n-    0xa46116538d0deb78,\n-    0xcd795be870516656,\n-    0x806bd9714632dff6,\n-    0xa086cfcd97bf97f4,\n-    0xc8a883c0fdaf7df0,\n-    0xfad2a4b13d1b5d6c,\n-    0x9cc3a6eec6311a64,\n-    0xc3f490aa77bd60fd,\n-    0xf4f1b4d515acb93c,\n-    0x991711052d8bf3c5,\n-    0xbf5cd54678eef0b7,\n-    0xef340a98172aace5,\n-    0x9580869f0e7aac0f,\n-    0xbae0a846d2195713,\n-    0xe998d258869facd7,\n-    0x91ff83775423cc06,\n-    0xb67f6455292cbf08,\n-    0xe41f3d6a7377eeca,\n-    0x8e938662882af53e,\n-    0xb23867fb2a35b28e,\n-    0xdec681f9f4c31f31,\n-    0x8b3c113c38f9f37f,\n-    0xae0b158b4738705f,\n-    0xd98ddaee19068c76,\n-    0x87f8a8d4cfa417ca,\n-    0xa9f6d30a038d1dbc,\n-    0xd47487cc8470652b,\n-    0x84c8d4dfd2c63f3b,\n-    0xa5fb0a17c777cf0a,\n-    0xcf79cc9db955c2cc,\n-    0x81ac1fe293d599c0,\n-    0xa21727db38cb0030,\n-    0xca9cf1d206fdc03c,\n-    0xfd442e4688bd304b,\n-    0x9e4a9cec15763e2f,\n-    0xc5dd44271ad3cdba,\n-    0xf7549530e188c129,\n-    0x9a94dd3e8cf578ba,\n-    0xc13a148e3032d6e8,\n-    0xf18899b1bc3f8ca2,\n-    0x96f5600f15a7b7e5,\n-    0xbcb2b812db11a5de,\n-    0xebdf661791d60f56,\n-    0x936b9fcebb25c996,\n-    0xb84687c269ef3bfb,\n-    0xe65829b3046b0afa,\n-    0x8ff71a0fe2c2e6dc,\n-    0xb3f4e093db73a093,\n-    0xe0f218b8d25088b8,\n-    0x8c974f7383725573,\n-    0xafbd2350644eead0,\n-    0xdbac6c247d62a584,\n-    0x894bc396ce5da772,\n-    0xab9eb47c81f5114f,\n-    0xd686619ba27255a3,\n-    0x8613fd0145877586,\n-    0xa798fc4196e952e7,\n-    0xd17f3b51fca3a7a1,\n-    0x82ef85133de648c5,\n-    0xa3ab66580d5fdaf6,\n-    0xcc963fee10b7d1b3,\n-    0xffbbcfe994e5c620,\n-    0x9fd561f1fd0f9bd4,\n-    0xc7caba6e7c5382c9,\n-    0xf9bd690a1b68637b,\n-    0x9c1661a651213e2d,\n-    0xc31bfa0fe5698db8,\n-    0xf3e2f893dec3f126,\n-    0x986ddb5c6b3a76b8,\n-    0xbe89523386091466,\n-    0xee2ba6c0678b597f,\n-    0x94db483840b717f0,\n-    0xba121a4650e4ddec,\n-    0xe896a0d7e51e1566,\n-    0x915e2486ef32cd60,\n-    0xb5b5ada8aaff80b8,\n-    0xe3231912d5bf60e6,\n-    0x8df5efabc5979c90,\n-    0xb1736b96b6fd83b4,\n-    0xddd0467c64bce4a1,\n-    0x8aa22c0dbef60ee4,\n-    0xad4ab7112eb3929e,\n-    0xd89d64d57a607745,\n-    0x87625f056c7c4a8b,\n-    0xa93af6c6c79b5d2e,\n-    0xd389b47879823479,\n-    0x843610cb4bf160cc,\n-    0xa54394fe1eedb8ff,\n-    0xce947a3da6a9273e,\n-    0x811ccc668829b887,\n-    0xa163ff802a3426a9,\n-    0xc9bcff6034c13053,\n-    0xfc2c3f3841f17c68,\n-    0x9d9ba7832936edc1,\n-    0xc5029163f384a931,\n-    0xf64335bcf065d37d,\n-    0x99ea0196163fa42e,\n-    0xc06481fb9bcf8d3a,\n-    0xf07da27a82c37088,\n-    0x964e858c91ba2655,\n-    0xbbe226efb628afeb,\n-    0xeadab0aba3b2dbe5,\n-    0x92c8ae6b464fc96f,\n-    0xb77ada0617e3bbcb,\n-    0xe55990879ddcaabe,\n-    0x8f57fa54c2a9eab7,\n-    0xb32df8e9f3546564,\n-    0xdff9772470297ebd,\n-    0x8bfbea76c619ef36,\n-    0xaefae51477a06b04,\n-    0xdab99e59958885c5,\n-    0x88b402f7fd75539b,\n-    0xaae103b5fcd2a882,\n-    0xd59944a37c0752a2,\n-    0x857fcae62d8493a5,\n-    0xa6dfbd9fb8e5b88f,\n-    0xd097ad07a71f26b2,\n-    0x825ecc24c8737830,\n-    0xa2f67f2dfa90563b,\n-    0xcbb41ef979346bca,\n-    0xfea126b7d78186bd,\n-    0x9f24b832e6b0f436,\n-    0xc6ede63fa05d3144,\n-    0xf8a95fcf88747d94,\n-    0x9b69dbe1b548ce7d,\n-    0xc24452da229b021c,\n-    0xf2d56790ab41c2a3,\n-    0x97c560ba6b0919a6,\n-    0xbdb6b8e905cb600f,\n-    0xed246723473e3813,\n-    0x9436c0760c86e30c,\n-    0xb94470938fa89bcf,\n-    0xe7958cb87392c2c3,\n-    0x90bd77f3483bb9ba,\n-    0xb4ecd5f01a4aa828,\n-    0xe2280b6c20dd5232,\n-    0x8d590723948a535f,\n-    0xb0af48ec79ace837,\n-    0xdcdb1b2798182245,\n-    0x8a08f0f8bf0f156b,\n-    0xac8b2d36eed2dac6,\n-    0xd7adf884aa879177,\n-    0x86ccbb52ea94baeb,\n-    0xa87fea27a539e9a5,\n-    0xd29fe4b18e88640f,\n-    0x83a3eeeef9153e89,\n-    0xa48ceaaab75a8e2b,\n-    0xcdb02555653131b6,\n-    0x808e17555f3ebf12,\n-    0xa0b19d2ab70e6ed6,\n-    0xc8de047564d20a8c,\n-    0xfb158592be068d2f,\n-    0x9ced737bb6c4183d,\n-    0xc428d05aa4751e4d,\n-    0xf53304714d9265e0,\n-    0x993fe2c6d07b7fac,\n-    0xbf8fdb78849a5f97,\n-    0xef73d256a5c0f77d,\n-    0x95a8637627989aae,\n-    0xbb127c53b17ec159,\n-    0xe9d71b689dde71b0,\n-    0x9226712162ab070e,\n-    0xb6b00d69bb55c8d1,\n-    0xe45c10c42a2b3b06,\n-    0x8eb98a7a9a5b04e3,\n-    0xb267ed1940f1c61c,\n-    0xdf01e85f912e37a3,\n-    0x8b61313bbabce2c6,\n-    0xae397d8aa96c1b78,\n-    0xd9c7dced53c72256,\n-    0x881cea14545c7575,\n-    0xaa242499697392d3,\n-    0xd4ad2dbfc3d07788,\n-    0x84ec3c97da624ab5,\n-    0xa6274bbdd0fadd62,\n-    0xcfb11ead453994ba,\n-    0x81ceb32c4b43fcf5,\n-    0xa2425ff75e14fc32,\n-    0xcad2f7f5359a3b3e,\n-    0xfd87b5f28300ca0e,\n-    0x9e74d1b791e07e48,\n-    0xc612062576589ddb,\n-    0xf79687aed3eec551,\n-    0x9abe14cd44753b53,\n-    0xc16d9a0095928a27,\n-    0xf1c90080baf72cb1,\n-    0x971da05074da7bef,\n-    0xbce5086492111aeb,\n-    0xec1e4a7db69561a5,\n-    0x9392ee8e921d5d07,\n-    0xb877aa3236a4b449,\n-    0xe69594bec44de15b,\n-    0x901d7cf73ab0acd9,\n-    0xb424dc35095cd80f,\n-    0xe12e13424bb40e13,\n-    0x8cbccc096f5088cc,\n-    0xafebff0bcb24aaff,\n-    0xdbe6fecebdedd5bf,\n-    0x89705f4136b4a597,\n-    0xabcc77118461cefd,\n-    0xd6bf94d5e57a42bc,\n-    0x8637bd05af6c69b6,\n-    0xa7c5ac471b478423,\n-    0xd1b71758e219652c,\n-    0x83126e978d4fdf3b,\n-    0xa3d70a3d70a3d70a,\n-    0xcccccccccccccccd,\n-    0x8000000000000000,\n-    0xa000000000000000,\n-    0xc800000000000000,\n-    0xfa00000000000000,\n-    0x9c40000000000000,\n-    0xc350000000000000,\n-    0xf424000000000000,\n-    0x9896800000000000,\n-    0xbebc200000000000,\n-    0xee6b280000000000,\n-    0x9502f90000000000,\n-    0xba43b74000000000,\n-    0xe8d4a51000000000,\n-    0x9184e72a00000000,\n-    0xb5e620f480000000,\n-    0xe35fa931a0000000,\n-    0x8e1bc9bf04000000,\n-    0xb1a2bc2ec5000000,\n-    0xde0b6b3a76400000,\n-    0x8ac7230489e80000,\n-    0xad78ebc5ac620000,\n-    0xd8d726b7177a8000,\n-    0x878678326eac9000,\n-    0xa968163f0a57b400,\n-    0xd3c21bcecceda100,\n-    0x84595161401484a0,\n-    0xa56fa5b99019a5c8,\n-    0xcecb8f27f4200f3a,\n-    0x813f3978f8940984,\n-    0xa18f07d736b90be5,\n-    0xc9f2c9cd04674edf,\n-    0xfc6f7c4045812296,\n-    0x9dc5ada82b70b59e,\n-    0xc5371912364ce305,\n-    0xf684df56c3e01bc7,\n-    0x9a130b963a6c115c,\n-    0xc097ce7bc90715b3,\n-    0xf0bdc21abb48db20,\n-    0x96769950b50d88f4,\n-    0xbc143fa4e250eb31,\n-    0xeb194f8e1ae525fd,\n-    0x92efd1b8d0cf37be,\n-    0xb7abc627050305ae,\n-    0xe596b7b0c643c719,\n-    0x8f7e32ce7bea5c70,\n-    0xb35dbf821ae4f38c,\n-    0xe0352f62a19e306f,\n-    0x8c213d9da502de45,\n-    0xaf298d050e4395d7,\n-    0xdaf3f04651d47b4c,\n-    0x88d8762bf324cd10,\n-    0xab0e93b6efee0054,\n-    0xd5d238a4abe98068,\n-    0x85a36366eb71f041,\n-    0xa70c3c40a64e6c52,\n-    0xd0cf4b50cfe20766,\n-    0x82818f1281ed44a0,\n-    0xa321f2d7226895c8,\n-    0xcbea6f8ceb02bb3a,\n-    0xfee50b7025c36a08,\n-    0x9f4f2726179a2245,\n-    0xc722f0ef9d80aad6,\n-    0xf8ebad2b84e0d58c,\n-    0x9b934c3b330c8577,\n-    0xc2781f49ffcfa6d5,\n-    0xf316271c7fc3908b,\n-    0x97edd871cfda3a57,\n-    0xbde94e8e43d0c8ec,\n-    0xed63a231d4c4fb27,\n-    0x945e455f24fb1cf9,\n-    0xb975d6b6ee39e437,\n-    0xe7d34c64a9c85d44,\n-    0x90e40fbeea1d3a4b,\n-    0xb51d13aea4a488dd,\n-    0xe264589a4dcdab15,\n-    0x8d7eb76070a08aed,\n-    0xb0de65388cc8ada8,\n-    0xdd15fe86affad912,\n-    0x8a2dbf142dfcc7ab,\n-    0xacb92ed9397bf996,\n-    0xd7e77a8f87daf7fc,\n-    0x86f0ac99b4e8dafd,\n-    0xa8acd7c0222311bd,\n-    0xd2d80db02aabd62c,\n-    0x83c7088e1aab65db,\n-    0xa4b8cab1a1563f52,\n-    0xcde6fd5e09abcf27,\n-    0x80b05e5ac60b6178,\n-    0xa0dc75f1778e39d6,\n-    0xc913936dd571c84c,\n-    0xfb5878494ace3a5f,\n-    0x9d174b2dcec0e47b,\n-    0xc45d1df942711d9a,\n-    0xf5746577930d6501,\n-    0x9968bf6abbe85f20,\n-    0xbfc2ef456ae276e9,\n-    0xefb3ab16c59b14a3,\n-    0x95d04aee3b80ece6,\n-    0xbb445da9ca61281f,\n-    0xea1575143cf97227,\n-    0x924d692ca61be758,\n-    0xb6e0c377cfa2e12e,\n-    0xe498f455c38b997a,\n-    0x8edf98b59a373fec,\n-    0xb2977ee300c50fe7,\n-    0xdf3d5e9bc0f653e1,\n-    0x8b865b215899f46d,\n-    0xae67f1e9aec07188,\n-    0xda01ee641a708dea,\n-    0x884134fe908658b2,\n-    0xaa51823e34a7eedf,\n-    0xd4e5e2cdc1d1ea96,\n-    0x850fadc09923329e,\n-    0xa6539930bf6bff46,\n-    0xcfe87f7cef46ff17,\n-    0x81f14fae158c5f6e,\n-    0xa26da3999aef774a,\n-    0xcb090c8001ab551c,\n-    0xfdcb4fa002162a63,\n-    0x9e9f11c4014dda7e,\n-    0xc646d63501a1511e,\n-    0xf7d88bc24209a565,\n-    0x9ae757596946075f,\n-    0xc1a12d2fc3978937,\n-    0xf209787bb47d6b85,\n-    0x9745eb4d50ce6333,\n-    0xbd176620a501fc00,\n-    0xec5d3fa8ce427b00,\n-    0x93ba47c980e98ce0,\n-    0xb8a8d9bbe123f018,\n-    0xe6d3102ad96cec1e,\n-    0x9043ea1ac7e41393,\n-    0xb454e4a179dd1877,\n-    0xe16a1dc9d8545e95,\n-    0x8ce2529e2734bb1d,\n-    0xb01ae745b101e9e4,\n-    0xdc21a1171d42645d,\n-    0x899504ae72497eba,\n-    0xabfa45da0edbde69,\n-    0xd6f8d7509292d603,\n-    0x865b86925b9bc5c2,\n-    0xa7f26836f282b733,\n-    0xd1ef0244af2364ff,\n-    0x8335616aed761f1f,\n-    0xa402b9c5a8d3a6e7,\n-    0xcd036837130890a1,\n-    0x802221226be55a65,\n-    0xa02aa96b06deb0fe,\n-    0xc83553c5c8965d3d,\n-    0xfa42a8b73abbf48d,\n-    0x9c69a97284b578d8,\n-    0xc38413cf25e2d70e,\n-    0xf46518c2ef5b8cd1,\n-    0x98bf2f79d5993803,\n-    0xbeeefb584aff8604,\n-    0xeeaaba2e5dbf6785,\n-    0x952ab45cfa97a0b3,\n-    0xba756174393d88e0,\n-    0xe912b9d1478ceb17,\n-    0x91abb422ccb812ef,\n-    0xb616a12b7fe617aa,\n-    0xe39c49765fdf9d95,\n-    0x8e41ade9fbebc27d,\n-    0xb1d219647ae6b31c,\n-    0xde469fbd99a05fe3,\n-    0x8aec23d680043bee,\n-    0xada72ccc20054aea,\n-    0xd910f7ff28069da4,\n-    0x87aa9aff79042287,\n-    0xa99541bf57452b28,\n-    0xd3fa922f2d1675f2,\n-    0x847c9b5d7c2e09b7,\n-    0xa59bc234db398c25,\n-    0xcf02b2c21207ef2f,\n-    0x8161afb94b44f57d,\n-    0xa1ba1ba79e1632dc,\n-    0xca28a291859bbf93,\n-    0xfcb2cb35e702af78,\n-    0x9defbf01b061adab,\n-    0xc56baec21c7a1916,\n-    0xf6c69a72a3989f5c,\n-    0x9a3c2087a63f6399,\n-    0xc0cb28a98fcf3c80,\n-    0xf0fdf2d3f3c30b9f,\n-    0x969eb7c47859e744,\n-    0xbc4665b596706115,\n-    0xeb57ff22fc0c795a,\n-    0x9316ff75dd87cbd8,\n-    0xb7dcbf5354e9bece,\n-    0xe5d3ef282a242e82,\n-    0x8fa475791a569d11,\n-    0xb38d92d760ec4455,\n-    0xe070f78d3927556b,\n-    0x8c469ab843b89563,\n-    0xaf58416654a6babb,\n-    0xdb2e51bfe9d0696a,\n-    0x88fcf317f22241e2,\n-    0xab3c2fddeeaad25b,\n-    0xd60b3bd56a5586f2,\n-    0x85c7056562757457,\n-    0xa738c6bebb12d16d,\n-    0xd106f86e69d785c8,\n-    0x82a45b450226b39d,\n-    0xa34d721642b06084,\n-    0xcc20ce9bd35c78a5,\n-    0xff290242c83396ce,\n-    0x9f79a169bd203e41,\n-    0xc75809c42c684dd1,\n-    0xf92e0c3537826146,\n-    0x9bbcc7a142b17ccc,\n-    0xc2abf989935ddbfe,\n-    0xf356f7ebf83552fe,\n-    0x98165af37b2153df,\n-    0xbe1bf1b059e9a8d6,\n-    0xeda2ee1c7064130c,\n-    0x9485d4d1c63e8be8,\n-    0xb9a74a0637ce2ee1,\n-    0xe8111c87c5c1ba9a,\n-    0x910ab1d4db9914a0,\n-    0xb54d5e4a127f59c8,\n-    0xe2a0b5dc971f303a,\n-    0x8da471a9de737e24,\n-    0xb10d8e1456105dad,\n-    0xdd50f1996b947519,\n-    0x8a5296ffe33cc930,\n-    0xace73cbfdc0bfb7b,\n-    0xd8210befd30efa5a,\n-    0x8714a775e3e95c78,\n-    0xa8d9d1535ce3b396,\n-    0xd31045a8341ca07c,\n-    0x83ea2b892091e44e,\n-    0xa4e4b66b68b65d61,\n-    0xce1de40642e3f4b9,\n-    0x80d2ae83e9ce78f4,\n-    0xa1075a24e4421731,\n-    0xc94930ae1d529cfd,\n-    0xfb9b7cd9a4a7443c,\n-    0x9d412e0806e88aa6,\n-    0xc491798a08a2ad4f,\n-    0xf5b5d7ec8acb58a3,\n-    0x9991a6f3d6bf1766,\n-    0xbff610b0cc6edd3f,\n-    0xeff394dcff8a948f,\n-    0x95f83d0a1fb69cd9,\n-    0xbb764c4ca7a44410,\n-    0xea53df5fd18d5514,\n-    0x92746b9be2f8552c,\n-    0xb7118682dbb66a77,\n-    0xe4d5e82392a40515,\n-    0x8f05b1163ba6832d,\n-    0xb2c71d5bca9023f8,\n-    0xdf78e4b2bd342cf7,\n-    0x8bab8eefb6409c1a,\n-    0xae9672aba3d0c321,\n-    0xda3c0f568cc4f3e9,\n-    0x8865899617fb1871,\n-    0xaa7eebfb9df9de8e,\n-    0xd51ea6fa85785631,\n-    0x8533285c936b35df,\n-    0xa67ff273b8460357,\n-    0xd01fef10a657842c,\n-    0x8213f56a67f6b29c,\n-    0xa298f2c501f45f43,\n-    0xcb3f2f7642717713,\n-    0xfe0efb53d30dd4d8,\n-    0x9ec95d1463e8a507,\n-    0xc67bb4597ce2ce49,\n-    0xf81aa16fdc1b81db,\n-    0x9b10a4e5e9913129,\n-    0xc1d4ce1f63f57d73,\n-    0xf24a01a73cf2dcd0,\n-    0x976e41088617ca02,\n-    0xbd49d14aa79dbc82,\n-    0xec9c459d51852ba3,\n-    0x93e1ab8252f33b46,\n-    0xb8da1662e7b00a17,\n-    0xe7109bfba19c0c9d,\n-    0x906a617d450187e2,\n-    0xb484f9dc9641e9db,\n-    0xe1a63853bbd26451,\n-    0x8d07e33455637eb3,\n-    0xb049dc016abc5e60,\n-    0xdc5c5301c56b75f7,\n-    0x89b9b3e11b6329bb,\n-    0xac2820d9623bf429,\n-    0xd732290fbacaf134,\n-    0x867f59a9d4bed6c0,\n-    0xa81f301449ee8c70,\n-    0xd226fc195c6a2f8c,\n-    0x83585d8fd9c25db8,\n-    0xa42e74f3d032f526,\n-    0xcd3a1230c43fb26f,\n-    0x80444b5e7aa7cf85,\n-    0xa0555e361951c367,\n-    0xc86ab5c39fa63441,\n-    0xfa856334878fc151,\n-    0x9c935e00d4b9d8d2,\n-    0xc3b8358109e84f07,\n-    0xf4a642e14c6262c9,\n-    0x98e7e9cccfbd7dbe,\n-    0xbf21e44003acdd2d,\n-    0xeeea5d5004981478,\n-    0x95527a5202df0ccb,\n-    0xbaa718e68396cffe,\n-    0xe950df20247c83fd,\n-    0x91d28b7416cdd27e,\n-], [\n-    -1077,\n-    -1073,\n-    -1070,\n-    -1067,\n-    -1063,\n-    -1060,\n-    -1057,\n-    -1053,\n-    -1050,\n-    -1047,\n-    -1043,\n-    -1040,\n-    -1037,\n-    -1034,\n-    -1030,\n-    -1027,\n-    -1024,\n-    -1020,\n-    -1017,\n-    -1014,\n-    -1010,\n-    -1007,\n-    -1004,\n-    -1000,\n-    -997,\n-    -994,\n-    -990,\n-    -987,\n-    -984,\n-    -980,\n-    -977,\n-    -974,\n-    -970,\n-    -967,\n-    -964,\n-    -960,\n-    -957,\n-    -954,\n-    -950,\n-    -947,\n-    -944,\n-    -940,\n-    -937,\n-    -934,\n-    -931,\n-    -927,\n-    -924,\n-    -921,\n-    -917,\n-    -914,\n-    -911,\n-    -907,\n-    -904,\n-    -901,\n-    -897,\n-    -894,\n-    -891,\n-    -887,\n-    -884,\n-    -881,\n-    -877,\n-    -874,\n-    -871,\n-    -867,\n-    -864,\n-    -861,\n-    -857,\n-    -854,\n-    -851,\n-    -847,\n-    -844,\n-    -841,\n-    -838,\n-    -834,\n-    -831,\n-    -828,\n-    -824,\n-    -821,\n-    -818,\n-    -814,\n-    -811,\n-    -808,\n-    -804,\n-    -801,\n-    -798,\n-    -794,\n-    -791,\n-    -788,\n-    -784,\n-    -781,\n-    -778,\n-    -774,\n-    -771,\n-    -768,\n-    -764,\n-    -761,\n-    -758,\n-    -754,\n-    -751,\n-    -748,\n-    -744,\n-    -741,\n-    -738,\n-    -735,\n-    -731,\n-    -728,\n-    -725,\n-    -721,\n-    -718,\n-    -715,\n-    -711,\n-    -708,\n-    -705,\n-    -701,\n-    -698,\n-    -695,\n-    -691,\n-    -688,\n-    -685,\n-    -681,\n-    -678,\n-    -675,\n-    -671,\n-    -668,\n-    -665,\n-    -661,\n-    -658,\n-    -655,\n-    -651,\n-    -648,\n-    -645,\n-    -642,\n-    -638,\n-    -635,\n-    -632,\n-    -628,\n-    -625,\n-    -622,\n-    -618,\n-    -615,\n-    -612,\n-    -608,\n-    -605,\n-    -602,\n-    -598,\n-    -595,\n-    -592,\n-    -588,\n-    -585,\n-    -582,\n-    -578,\n-    -575,\n-    -572,\n-    -568,\n-    -565,\n-    -562,\n-    -558,\n-    -555,\n-    -552,\n-    -549,\n-    -545,\n-    -542,\n-    -539,\n-    -535,\n-    -532,\n-    -529,\n-    -525,\n-    -522,\n-    -519,\n-    -515,\n-    -512,\n-    -509,\n-    -505,\n-    -502,\n-    -499,\n-    -495,\n-    -492,\n-    -489,\n-    -485,\n-    -482,\n-    -479,\n-    -475,\n-    -472,\n-    -469,\n-    -465,\n-    -462,\n-    -459,\n-    -455,\n-    -452,\n-    -449,\n-    -446,\n-    -442,\n-    -439,\n-    -436,\n-    -432,\n-    -429,\n-    -426,\n-    -422,\n-    -419,\n-    -416,\n-    -412,\n-    -409,\n-    -406,\n-    -402,\n-    -399,\n-    -396,\n-    -392,\n-    -389,\n-    -386,\n-    -382,\n-    -379,\n-    -376,\n-    -372,\n-    -369,\n-    -366,\n-    -362,\n-    -359,\n-    -356,\n-    -353,\n-    -349,\n-    -346,\n-    -343,\n-    -339,\n-    -336,\n-    -333,\n-    -329,\n-    -326,\n-    -323,\n-    -319,\n-    -316,\n-    -313,\n-    -309,\n-    -306,\n-    -303,\n-    -299,\n-    -296,\n-    -293,\n-    -289,\n-    -286,\n-    -283,\n-    -279,\n-    -276,\n-    -273,\n-    -269,\n-    -266,\n-    -263,\n-    -259,\n-    -256,\n-    -253,\n-    -250,\n-    -246,\n-    -243,\n-    -240,\n-    -236,\n-    -233,\n-    -230,\n-    -226,\n-    -223,\n-    -220,\n-    -216,\n-    -213,\n-    -210,\n-    -206,\n-    -203,\n-    -200,\n-    -196,\n-    -193,\n-    -190,\n-    -186,\n-    -183,\n-    -180,\n-    -176,\n-    -173,\n-    -170,\n-    -166,\n-    -163,\n-    -160,\n-    -157,\n-    -153,\n-    -150,\n-    -147,\n-    -143,\n-    -140,\n-    -137,\n-    -133,\n-    -130,\n-    -127,\n-    -123,\n-    -120,\n-    -117,\n-    -113,\n-    -110,\n-    -107,\n-    -103,\n-    -100,\n-    -97,\n-    -93,\n-    -90,\n-    -87,\n-    -83,\n-    -80,\n-    -77,\n-    -73,\n-    -70,\n-    -67,\n-    -63,\n-    -60,\n-    -57,\n-    -54,\n-    -50,\n-    -47,\n-    -44,\n-    -40,\n-    -37,\n-    -34,\n-    -30,\n-    -27,\n-    -24,\n-    -20,\n-    -17,\n-    -14,\n-    -10,\n-    -7,\n-    -4,\n-    0,\n-    3,\n-    6,\n-    10,\n-    13,\n-    16,\n-    20,\n-    23,\n-    26,\n-    30,\n-    33,\n-    36,\n-    39,\n-    43,\n-    46,\n-    49,\n-    53,\n-    56,\n-    59,\n-    63,\n-    66,\n-    69,\n-    73,\n-    76,\n-    79,\n-    83,\n-    86,\n-    89,\n-    93,\n-    96,\n-    99,\n-    103,\n-    106,\n-    109,\n-    113,\n-    116,\n-    119,\n-    123,\n-    126,\n-    129,\n-    132,\n-    136,\n-    139,\n-    142,\n-    146,\n-    149,\n-    152,\n-    156,\n-    159,\n-    162,\n-    166,\n-    169,\n-    172,\n-    176,\n-    179,\n-    182,\n-    186,\n-    189,\n-    192,\n-    196,\n-    199,\n-    202,\n-    206,\n-    209,\n-    212,\n-    216,\n-    219,\n-    222,\n-    226,\n-    229,\n-    232,\n-    235,\n-    239,\n-    242,\n-    245,\n-    249,\n-    252,\n-    255,\n-    259,\n-    262,\n-    265,\n-    269,\n-    272,\n-    275,\n-    279,\n-    282,\n-    285,\n-    289,\n-    292,\n-    295,\n-    299,\n-    302,\n-    305,\n-    309,\n-    312,\n-    315,\n-    319,\n-    322,\n-    325,\n-    328,\n-    332,\n-    335,\n-    338,\n-    342,\n-    345,\n-    348,\n-    352,\n-    355,\n-    358,\n-    362,\n-    365,\n-    368,\n-    372,\n-    375,\n-    378,\n-    382,\n-    385,\n-    388,\n-    392,\n-    395,\n-    398,\n-    402,\n-    405,\n-    408,\n-    412,\n-    415,\n-    418,\n-    422,\n-    425,\n-    428,\n-    431,\n-    435,\n-    438,\n-    441,\n-    445,\n-    448,\n-    451,\n-    455,\n-    458,\n-    461,\n-    465,\n-    468,\n-    471,\n-    475,\n-    478,\n-    481,\n-    485,\n-    488,\n-    491,\n-    495,\n-    498,\n-    501,\n-    505,\n-    508,\n-    511,\n-    515,\n-    518,\n-    521,\n-    524,\n-    528,\n-    531,\n-    534,\n-    538,\n-    541,\n-    544,\n-    548,\n-    551,\n-    554,\n-    558,\n-    561,\n-    564,\n-    568,\n-    571,\n-    574,\n-    578,\n-    581,\n-    584,\n-    588,\n-    591,\n-    594,\n-    598,\n-    601,\n-    604,\n-    608,\n-    611,\n-    614,\n-    617,\n-    621,\n-    624,\n-    627,\n-    631,\n-    634,\n-    637,\n-    641,\n-    644,\n-    647,\n-    651,\n-    654,\n-    657,\n-    661,\n-    664,\n-    667,\n-    671,\n-    674,\n-    677,\n-    681,\n-    684,\n-    687,\n-    691,\n-    694,\n-    697,\n-    701,\n-    704,\n-    707,\n-    711,\n-    714,\n-    717,\n-    720,\n-    724,\n-    727,\n-    730,\n-    734,\n-    737,\n-    740,\n-    744,\n-    747,\n-    750,\n-    754,\n-    757,\n-    760,\n-    764,\n-    767,\n-    770,\n-    774,\n-    777,\n-    780,\n-    784,\n-    787,\n-    790,\n-    794,\n-    797,\n-    800,\n-    804,\n-    807,\n-    810,\n-    813,\n-    817,\n-    820,\n-    823,\n-    827,\n-    830,\n-    833,\n-    837,\n-    840,\n-    843,\n-    847,\n-    850,\n-    853,\n-    857,\n-    860,\n-    863,\n-    867,\n-    870,\n-    873,\n-    877,\n-    880,\n-    883,\n-    887,\n-    890,\n-    893,\n-    897,\n-    900,\n-    903,\n-    907,\n-    910,\n-    913,\n-    916,\n-    920,\n-    923,\n-    926,\n-    930,\n-    933,\n-    936,\n-    940,\n-    943,\n-    946,\n-    950,\n-]);\n+#[rustfmt::skip]\n+pub const POWERS: ([u64; 611], [i16; 611]) = (\n+    [\n+        0xe0b62e2929aba83c,\n+        0x8c71dcd9ba0b4926,\n+        0xaf8e5410288e1b6f,\n+        0xdb71e91432b1a24b,\n+        0x892731ac9faf056f,\n+        0xab70fe17c79ac6ca,\n+        0xd64d3d9db981787d,\n+        0x85f0468293f0eb4e,\n+        0xa76c582338ed2622,\n+        0xd1476e2c07286faa,\n+        0x82cca4db847945ca,\n+        0xa37fce126597973d,\n+        0xcc5fc196fefd7d0c,\n+        0xff77b1fcbebcdc4f,\n+        0x9faacf3df73609b1,\n+        0xc795830d75038c1e,\n+        0xf97ae3d0d2446f25,\n+        0x9becce62836ac577,\n+        0xc2e801fb244576d5,\n+        0xf3a20279ed56d48a,\n+        0x9845418c345644d7,\n+        0xbe5691ef416bd60c,\n+        0xedec366b11c6cb8f,\n+        0x94b3a202eb1c3f39,\n+        0xb9e08a83a5e34f08,\n+        0xe858ad248f5c22ca,\n+        0x91376c36d99995be,\n+        0xb58547448ffffb2e,\n+        0xe2e69915b3fff9f9,\n+        0x8dd01fad907ffc3c,\n+        0xb1442798f49ffb4b,\n+        0xdd95317f31c7fa1d,\n+        0x8a7d3eef7f1cfc52,\n+        0xad1c8eab5ee43b67,\n+        0xd863b256369d4a41,\n+        0x873e4f75e2224e68,\n+        0xa90de3535aaae202,\n+        0xd3515c2831559a83,\n+        0x8412d9991ed58092,\n+        0xa5178fff668ae0b6,\n+        0xce5d73ff402d98e4,\n+        0x80fa687f881c7f8e,\n+        0xa139029f6a239f72,\n+        0xc987434744ac874f,\n+        0xfbe9141915d7a922,\n+        0x9d71ac8fada6c9b5,\n+        0xc4ce17b399107c23,\n+        0xf6019da07f549b2b,\n+        0x99c102844f94e0fb,\n+        0xc0314325637a193a,\n+        0xf03d93eebc589f88,\n+        0x96267c7535b763b5,\n+        0xbbb01b9283253ca3,\n+        0xea9c227723ee8bcb,\n+        0x92a1958a7675175f,\n+        0xb749faed14125d37,\n+        0xe51c79a85916f485,\n+        0x8f31cc0937ae58d3,\n+        0xb2fe3f0b8599ef08,\n+        0xdfbdcece67006ac9,\n+        0x8bd6a141006042be,\n+        0xaecc49914078536d,\n+        0xda7f5bf590966849,\n+        0x888f99797a5e012d,\n+        0xaab37fd7d8f58179,\n+        0xd5605fcdcf32e1d7,\n+        0x855c3be0a17fcd26,\n+        0xa6b34ad8c9dfc070,\n+        0xd0601d8efc57b08c,\n+        0x823c12795db6ce57,\n+        0xa2cb1717b52481ed,\n+        0xcb7ddcdda26da269,\n+        0xfe5d54150b090b03,\n+        0x9efa548d26e5a6e2,\n+        0xc6b8e9b0709f109a,\n+        0xf867241c8cc6d4c1,\n+        0x9b407691d7fc44f8,\n+        0xc21094364dfb5637,\n+        0xf294b943e17a2bc4,\n+        0x979cf3ca6cec5b5b,\n+        0xbd8430bd08277231,\n+        0xece53cec4a314ebe,\n+        0x940f4613ae5ed137,\n+        0xb913179899f68584,\n+        0xe757dd7ec07426e5,\n+        0x9096ea6f3848984f,\n+        0xb4bca50b065abe63,\n+        0xe1ebce4dc7f16dfc,\n+        0x8d3360f09cf6e4bd,\n+        0xb080392cc4349ded,\n+        0xdca04777f541c568,\n+        0x89e42caaf9491b61,\n+        0xac5d37d5b79b6239,\n+        0xd77485cb25823ac7,\n+        0x86a8d39ef77164bd,\n+        0xa8530886b54dbdec,\n+        0xd267caa862a12d67,\n+        0x8380dea93da4bc60,\n+        0xa46116538d0deb78,\n+        0xcd795be870516656,\n+        0x806bd9714632dff6,\n+        0xa086cfcd97bf97f4,\n+        0xc8a883c0fdaf7df0,\n+        0xfad2a4b13d1b5d6c,\n+        0x9cc3a6eec6311a64,\n+        0xc3f490aa77bd60fd,\n+        0xf4f1b4d515acb93c,\n+        0x991711052d8bf3c5,\n+        0xbf5cd54678eef0b7,\n+        0xef340a98172aace5,\n+        0x9580869f0e7aac0f,\n+        0xbae0a846d2195713,\n+        0xe998d258869facd7,\n+        0x91ff83775423cc06,\n+        0xb67f6455292cbf08,\n+        0xe41f3d6a7377eeca,\n+        0x8e938662882af53e,\n+        0xb23867fb2a35b28e,\n+        0xdec681f9f4c31f31,\n+        0x8b3c113c38f9f37f,\n+        0xae0b158b4738705f,\n+        0xd98ddaee19068c76,\n+        0x87f8a8d4cfa417ca,\n+        0xa9f6d30a038d1dbc,\n+        0xd47487cc8470652b,\n+        0x84c8d4dfd2c63f3b,\n+        0xa5fb0a17c777cf0a,\n+        0xcf79cc9db955c2cc,\n+        0x81ac1fe293d599c0,\n+        0xa21727db38cb0030,\n+        0xca9cf1d206fdc03c,\n+        0xfd442e4688bd304b,\n+        0x9e4a9cec15763e2f,\n+        0xc5dd44271ad3cdba,\n+        0xf7549530e188c129,\n+        0x9a94dd3e8cf578ba,\n+        0xc13a148e3032d6e8,\n+        0xf18899b1bc3f8ca2,\n+        0x96f5600f15a7b7e5,\n+        0xbcb2b812db11a5de,\n+        0xebdf661791d60f56,\n+        0x936b9fcebb25c996,\n+        0xb84687c269ef3bfb,\n+        0xe65829b3046b0afa,\n+        0x8ff71a0fe2c2e6dc,\n+        0xb3f4e093db73a093,\n+        0xe0f218b8d25088b8,\n+        0x8c974f7383725573,\n+        0xafbd2350644eead0,\n+        0xdbac6c247d62a584,\n+        0x894bc396ce5da772,\n+        0xab9eb47c81f5114f,\n+        0xd686619ba27255a3,\n+        0x8613fd0145877586,\n+        0xa798fc4196e952e7,\n+        0xd17f3b51fca3a7a1,\n+        0x82ef85133de648c5,\n+        0xa3ab66580d5fdaf6,\n+        0xcc963fee10b7d1b3,\n+        0xffbbcfe994e5c620,\n+        0x9fd561f1fd0f9bd4,\n+        0xc7caba6e7c5382c9,\n+        0xf9bd690a1b68637b,\n+        0x9c1661a651213e2d,\n+        0xc31bfa0fe5698db8,\n+        0xf3e2f893dec3f126,\n+        0x986ddb5c6b3a76b8,\n+        0xbe89523386091466,\n+        0xee2ba6c0678b597f,\n+        0x94db483840b717f0,\n+        0xba121a4650e4ddec,\n+        0xe896a0d7e51e1566,\n+        0x915e2486ef32cd60,\n+        0xb5b5ada8aaff80b8,\n+        0xe3231912d5bf60e6,\n+        0x8df5efabc5979c90,\n+        0xb1736b96b6fd83b4,\n+        0xddd0467c64bce4a1,\n+        0x8aa22c0dbef60ee4,\n+        0xad4ab7112eb3929e,\n+        0xd89d64d57a607745,\n+        0x87625f056c7c4a8b,\n+        0xa93af6c6c79b5d2e,\n+        0xd389b47879823479,\n+        0x843610cb4bf160cc,\n+        0xa54394fe1eedb8ff,\n+        0xce947a3da6a9273e,\n+        0x811ccc668829b887,\n+        0xa163ff802a3426a9,\n+        0xc9bcff6034c13053,\n+        0xfc2c3f3841f17c68,\n+        0x9d9ba7832936edc1,\n+        0xc5029163f384a931,\n+        0xf64335bcf065d37d,\n+        0x99ea0196163fa42e,\n+        0xc06481fb9bcf8d3a,\n+        0xf07da27a82c37088,\n+        0x964e858c91ba2655,\n+        0xbbe226efb628afeb,\n+        0xeadab0aba3b2dbe5,\n+        0x92c8ae6b464fc96f,\n+        0xb77ada0617e3bbcb,\n+        0xe55990879ddcaabe,\n+        0x8f57fa54c2a9eab7,\n+        0xb32df8e9f3546564,\n+        0xdff9772470297ebd,\n+        0x8bfbea76c619ef36,\n+        0xaefae51477a06b04,\n+        0xdab99e59958885c5,\n+        0x88b402f7fd75539b,\n+        0xaae103b5fcd2a882,\n+        0xd59944a37c0752a2,\n+        0x857fcae62d8493a5,\n+        0xa6dfbd9fb8e5b88f,\n+        0xd097ad07a71f26b2,\n+        0x825ecc24c8737830,\n+        0xa2f67f2dfa90563b,\n+        0xcbb41ef979346bca,\n+        0xfea126b7d78186bd,\n+        0x9f24b832e6b0f436,\n+        0xc6ede63fa05d3144,\n+        0xf8a95fcf88747d94,\n+        0x9b69dbe1b548ce7d,\n+        0xc24452da229b021c,\n+        0xf2d56790ab41c2a3,\n+        0x97c560ba6b0919a6,\n+        0xbdb6b8e905cb600f,\n+        0xed246723473e3813,\n+        0x9436c0760c86e30c,\n+        0xb94470938fa89bcf,\n+        0xe7958cb87392c2c3,\n+        0x90bd77f3483bb9ba,\n+        0xb4ecd5f01a4aa828,\n+        0xe2280b6c20dd5232,\n+        0x8d590723948a535f,\n+        0xb0af48ec79ace837,\n+        0xdcdb1b2798182245,\n+        0x8a08f0f8bf0f156b,\n+        0xac8b2d36eed2dac6,\n+        0xd7adf884aa879177,\n+        0x86ccbb52ea94baeb,\n+        0xa87fea27a539e9a5,\n+        0xd29fe4b18e88640f,\n+        0x83a3eeeef9153e89,\n+        0xa48ceaaab75a8e2b,\n+        0xcdb02555653131b6,\n+        0x808e17555f3ebf12,\n+        0xa0b19d2ab70e6ed6,\n+        0xc8de047564d20a8c,\n+        0xfb158592be068d2f,\n+        0x9ced737bb6c4183d,\n+        0xc428d05aa4751e4d,\n+        0xf53304714d9265e0,\n+        0x993fe2c6d07b7fac,\n+        0xbf8fdb78849a5f97,\n+        0xef73d256a5c0f77d,\n+        0x95a8637627989aae,\n+        0xbb127c53b17ec159,\n+        0xe9d71b689dde71b0,\n+        0x9226712162ab070e,\n+        0xb6b00d69bb55c8d1,\n+        0xe45c10c42a2b3b06,\n+        0x8eb98a7a9a5b04e3,\n+        0xb267ed1940f1c61c,\n+        0xdf01e85f912e37a3,\n+        0x8b61313bbabce2c6,\n+        0xae397d8aa96c1b78,\n+        0xd9c7dced53c72256,\n+        0x881cea14545c7575,\n+        0xaa242499697392d3,\n+        0xd4ad2dbfc3d07788,\n+        0x84ec3c97da624ab5,\n+        0xa6274bbdd0fadd62,\n+        0xcfb11ead453994ba,\n+        0x81ceb32c4b43fcf5,\n+        0xa2425ff75e14fc32,\n+        0xcad2f7f5359a3b3e,\n+        0xfd87b5f28300ca0e,\n+        0x9e74d1b791e07e48,\n+        0xc612062576589ddb,\n+        0xf79687aed3eec551,\n+        0x9abe14cd44753b53,\n+        0xc16d9a0095928a27,\n+        0xf1c90080baf72cb1,\n+        0x971da05074da7bef,\n+        0xbce5086492111aeb,\n+        0xec1e4a7db69561a5,\n+        0x9392ee8e921d5d07,\n+        0xb877aa3236a4b449,\n+        0xe69594bec44de15b,\n+        0x901d7cf73ab0acd9,\n+        0xb424dc35095cd80f,\n+        0xe12e13424bb40e13,\n+        0x8cbccc096f5088cc,\n+        0xafebff0bcb24aaff,\n+        0xdbe6fecebdedd5bf,\n+        0x89705f4136b4a597,\n+        0xabcc77118461cefd,\n+        0xd6bf94d5e57a42bc,\n+        0x8637bd05af6c69b6,\n+        0xa7c5ac471b478423,\n+        0xd1b71758e219652c,\n+        0x83126e978d4fdf3b,\n+        0xa3d70a3d70a3d70a,\n+        0xcccccccccccccccd,\n+        0x8000000000000000,\n+        0xa000000000000000,\n+        0xc800000000000000,\n+        0xfa00000000000000,\n+        0x9c40000000000000,\n+        0xc350000000000000,\n+        0xf424000000000000,\n+        0x9896800000000000,\n+        0xbebc200000000000,\n+        0xee6b280000000000,\n+        0x9502f90000000000,\n+        0xba43b74000000000,\n+        0xe8d4a51000000000,\n+        0x9184e72a00000000,\n+        0xb5e620f480000000,\n+        0xe35fa931a0000000,\n+        0x8e1bc9bf04000000,\n+        0xb1a2bc2ec5000000,\n+        0xde0b6b3a76400000,\n+        0x8ac7230489e80000,\n+        0xad78ebc5ac620000,\n+        0xd8d726b7177a8000,\n+        0x878678326eac9000,\n+        0xa968163f0a57b400,\n+        0xd3c21bcecceda100,\n+        0x84595161401484a0,\n+        0xa56fa5b99019a5c8,\n+        0xcecb8f27f4200f3a,\n+        0x813f3978f8940984,\n+        0xa18f07d736b90be5,\n+        0xc9f2c9cd04674edf,\n+        0xfc6f7c4045812296,\n+        0x9dc5ada82b70b59e,\n+        0xc5371912364ce305,\n+        0xf684df56c3e01bc7,\n+        0x9a130b963a6c115c,\n+        0xc097ce7bc90715b3,\n+        0xf0bdc21abb48db20,\n+        0x96769950b50d88f4,\n+        0xbc143fa4e250eb31,\n+        0xeb194f8e1ae525fd,\n+        0x92efd1b8d0cf37be,\n+        0xb7abc627050305ae,\n+        0xe596b7b0c643c719,\n+        0x8f7e32ce7bea5c70,\n+        0xb35dbf821ae4f38c,\n+        0xe0352f62a19e306f,\n+        0x8c213d9da502de45,\n+        0xaf298d050e4395d7,\n+        0xdaf3f04651d47b4c,\n+        0x88d8762bf324cd10,\n+        0xab0e93b6efee0054,\n+        0xd5d238a4abe98068,\n+        0x85a36366eb71f041,\n+        0xa70c3c40a64e6c52,\n+        0xd0cf4b50cfe20766,\n+        0x82818f1281ed44a0,\n+        0xa321f2d7226895c8,\n+        0xcbea6f8ceb02bb3a,\n+        0xfee50b7025c36a08,\n+        0x9f4f2726179a2245,\n+        0xc722f0ef9d80aad6,\n+        0xf8ebad2b84e0d58c,\n+        0x9b934c3b330c8577,\n+        0xc2781f49ffcfa6d5,\n+        0xf316271c7fc3908b,\n+        0x97edd871cfda3a57,\n+        0xbde94e8e43d0c8ec,\n+        0xed63a231d4c4fb27,\n+        0x945e455f24fb1cf9,\n+        0xb975d6b6ee39e437,\n+        0xe7d34c64a9c85d44,\n+        0x90e40fbeea1d3a4b,\n+        0xb51d13aea4a488dd,\n+        0xe264589a4dcdab15,\n+        0x8d7eb76070a08aed,\n+        0xb0de65388cc8ada8,\n+        0xdd15fe86affad912,\n+        0x8a2dbf142dfcc7ab,\n+        0xacb92ed9397bf996,\n+        0xd7e77a8f87daf7fc,\n+        0x86f0ac99b4e8dafd,\n+        0xa8acd7c0222311bd,\n+        0xd2d80db02aabd62c,\n+        0x83c7088e1aab65db,\n+        0xa4b8cab1a1563f52,\n+        0xcde6fd5e09abcf27,\n+        0x80b05e5ac60b6178,\n+        0xa0dc75f1778e39d6,\n+        0xc913936dd571c84c,\n+        0xfb5878494ace3a5f,\n+        0x9d174b2dcec0e47b,\n+        0xc45d1df942711d9a,\n+        0xf5746577930d6501,\n+        0x9968bf6abbe85f20,\n+        0xbfc2ef456ae276e9,\n+        0xefb3ab16c59b14a3,\n+        0x95d04aee3b80ece6,\n+        0xbb445da9ca61281f,\n+        0xea1575143cf97227,\n+        0x924d692ca61be758,\n+        0xb6e0c377cfa2e12e,\n+        0xe498f455c38b997a,\n+        0x8edf98b59a373fec,\n+        0xb2977ee300c50fe7,\n+        0xdf3d5e9bc0f653e1,\n+        0x8b865b215899f46d,\n+        0xae67f1e9aec07188,\n+        0xda01ee641a708dea,\n+        0x884134fe908658b2,\n+        0xaa51823e34a7eedf,\n+        0xd4e5e2cdc1d1ea96,\n+        0x850fadc09923329e,\n+        0xa6539930bf6bff46,\n+        0xcfe87f7cef46ff17,\n+        0x81f14fae158c5f6e,\n+        0xa26da3999aef774a,\n+        0xcb090c8001ab551c,\n+        0xfdcb4fa002162a63,\n+        0x9e9f11c4014dda7e,\n+        0xc646d63501a1511e,\n+        0xf7d88bc24209a565,\n+        0x9ae757596946075f,\n+        0xc1a12d2fc3978937,\n+        0xf209787bb47d6b85,\n+        0x9745eb4d50ce6333,\n+        0xbd176620a501fc00,\n+        0xec5d3fa8ce427b00,\n+        0x93ba47c980e98ce0,\n+        0xb8a8d9bbe123f018,\n+        0xe6d3102ad96cec1e,\n+        0x9043ea1ac7e41393,\n+        0xb454e4a179dd1877,\n+        0xe16a1dc9d8545e95,\n+        0x8ce2529e2734bb1d,\n+        0xb01ae745b101e9e4,\n+        0xdc21a1171d42645d,\n+        0x899504ae72497eba,\n+        0xabfa45da0edbde69,\n+        0xd6f8d7509292d603,\n+        0x865b86925b9bc5c2,\n+        0xa7f26836f282b733,\n+        0xd1ef0244af2364ff,\n+        0x8335616aed761f1f,\n+        0xa402b9c5a8d3a6e7,\n+        0xcd036837130890a1,\n+        0x802221226be55a65,\n+        0xa02aa96b06deb0fe,\n+        0xc83553c5c8965d3d,\n+        0xfa42a8b73abbf48d,\n+        0x9c69a97284b578d8,\n+        0xc38413cf25e2d70e,\n+        0xf46518c2ef5b8cd1,\n+        0x98bf2f79d5993803,\n+        0xbeeefb584aff8604,\n+        0xeeaaba2e5dbf6785,\n+        0x952ab45cfa97a0b3,\n+        0xba756174393d88e0,\n+        0xe912b9d1478ceb17,\n+        0x91abb422ccb812ef,\n+        0xb616a12b7fe617aa,\n+        0xe39c49765fdf9d95,\n+        0x8e41ade9fbebc27d,\n+        0xb1d219647ae6b31c,\n+        0xde469fbd99a05fe3,\n+        0x8aec23d680043bee,\n+        0xada72ccc20054aea,\n+        0xd910f7ff28069da4,\n+        0x87aa9aff79042287,\n+        0xa99541bf57452b28,\n+        0xd3fa922f2d1675f2,\n+        0x847c9b5d7c2e09b7,\n+        0xa59bc234db398c25,\n+        0xcf02b2c21207ef2f,\n+        0x8161afb94b44f57d,\n+        0xa1ba1ba79e1632dc,\n+        0xca28a291859bbf93,\n+        0xfcb2cb35e702af78,\n+        0x9defbf01b061adab,\n+        0xc56baec21c7a1916,\n+        0xf6c69a72a3989f5c,\n+        0x9a3c2087a63f6399,\n+        0xc0cb28a98fcf3c80,\n+        0xf0fdf2d3f3c30b9f,\n+        0x969eb7c47859e744,\n+        0xbc4665b596706115,\n+        0xeb57ff22fc0c795a,\n+        0x9316ff75dd87cbd8,\n+        0xb7dcbf5354e9bece,\n+        0xe5d3ef282a242e82,\n+        0x8fa475791a569d11,\n+        0xb38d92d760ec4455,\n+        0xe070f78d3927556b,\n+        0x8c469ab843b89563,\n+        0xaf58416654a6babb,\n+        0xdb2e51bfe9d0696a,\n+        0x88fcf317f22241e2,\n+        0xab3c2fddeeaad25b,\n+        0xd60b3bd56a5586f2,\n+        0x85c7056562757457,\n+        0xa738c6bebb12d16d,\n+        0xd106f86e69d785c8,\n+        0x82a45b450226b39d,\n+        0xa34d721642b06084,\n+        0xcc20ce9bd35c78a5,\n+        0xff290242c83396ce,\n+        0x9f79a169bd203e41,\n+        0xc75809c42c684dd1,\n+        0xf92e0c3537826146,\n+        0x9bbcc7a142b17ccc,\n+        0xc2abf989935ddbfe,\n+        0xf356f7ebf83552fe,\n+        0x98165af37b2153df,\n+        0xbe1bf1b059e9a8d6,\n+        0xeda2ee1c7064130c,\n+        0x9485d4d1c63e8be8,\n+        0xb9a74a0637ce2ee1,\n+        0xe8111c87c5c1ba9a,\n+        0x910ab1d4db9914a0,\n+        0xb54d5e4a127f59c8,\n+        0xe2a0b5dc971f303a,\n+        0x8da471a9de737e24,\n+        0xb10d8e1456105dad,\n+        0xdd50f1996b947519,\n+        0x8a5296ffe33cc930,\n+        0xace73cbfdc0bfb7b,\n+        0xd8210befd30efa5a,\n+        0x8714a775e3e95c78,\n+        0xa8d9d1535ce3b396,\n+        0xd31045a8341ca07c,\n+        0x83ea2b892091e44e,\n+        0xa4e4b66b68b65d61,\n+        0xce1de40642e3f4b9,\n+        0x80d2ae83e9ce78f4,\n+        0xa1075a24e4421731,\n+        0xc94930ae1d529cfd,\n+        0xfb9b7cd9a4a7443c,\n+        0x9d412e0806e88aa6,\n+        0xc491798a08a2ad4f,\n+        0xf5b5d7ec8acb58a3,\n+        0x9991a6f3d6bf1766,\n+        0xbff610b0cc6edd3f,\n+        0xeff394dcff8a948f,\n+        0x95f83d0a1fb69cd9,\n+        0xbb764c4ca7a44410,\n+        0xea53df5fd18d5514,\n+        0x92746b9be2f8552c,\n+        0xb7118682dbb66a77,\n+        0xe4d5e82392a40515,\n+        0x8f05b1163ba6832d,\n+        0xb2c71d5bca9023f8,\n+        0xdf78e4b2bd342cf7,\n+        0x8bab8eefb6409c1a,\n+        0xae9672aba3d0c321,\n+        0xda3c0f568cc4f3e9,\n+        0x8865899617fb1871,\n+        0xaa7eebfb9df9de8e,\n+        0xd51ea6fa85785631,\n+        0x8533285c936b35df,\n+        0xa67ff273b8460357,\n+        0xd01fef10a657842c,\n+        0x8213f56a67f6b29c,\n+        0xa298f2c501f45f43,\n+        0xcb3f2f7642717713,\n+        0xfe0efb53d30dd4d8,\n+        0x9ec95d1463e8a507,\n+        0xc67bb4597ce2ce49,\n+        0xf81aa16fdc1b81db,\n+        0x9b10a4e5e9913129,\n+        0xc1d4ce1f63f57d73,\n+        0xf24a01a73cf2dcd0,\n+        0x976e41088617ca02,\n+        0xbd49d14aa79dbc82,\n+        0xec9c459d51852ba3,\n+        0x93e1ab8252f33b46,\n+        0xb8da1662e7b00a17,\n+        0xe7109bfba19c0c9d,\n+        0x906a617d450187e2,\n+        0xb484f9dc9641e9db,\n+        0xe1a63853bbd26451,\n+        0x8d07e33455637eb3,\n+        0xb049dc016abc5e60,\n+        0xdc5c5301c56b75f7,\n+        0x89b9b3e11b6329bb,\n+        0xac2820d9623bf429,\n+        0xd732290fbacaf134,\n+        0x867f59a9d4bed6c0,\n+        0xa81f301449ee8c70,\n+        0xd226fc195c6a2f8c,\n+        0x83585d8fd9c25db8,\n+        0xa42e74f3d032f526,\n+        0xcd3a1230c43fb26f,\n+        0x80444b5e7aa7cf85,\n+        0xa0555e361951c367,\n+        0xc86ab5c39fa63441,\n+        0xfa856334878fc151,\n+        0x9c935e00d4b9d8d2,\n+        0xc3b8358109e84f07,\n+        0xf4a642e14c6262c9,\n+        0x98e7e9cccfbd7dbe,\n+        0xbf21e44003acdd2d,\n+        0xeeea5d5004981478,\n+        0x95527a5202df0ccb,\n+        0xbaa718e68396cffe,\n+        0xe950df20247c83fd,\n+        0x91d28b7416cdd27e,\n+    ],\n+    [\n+        -1077,\n+        -1073,\n+        -1070,\n+        -1067,\n+        -1063,\n+        -1060,\n+        -1057,\n+        -1053,\n+        -1050,\n+        -1047,\n+        -1043,\n+        -1040,\n+        -1037,\n+        -1034,\n+        -1030,\n+        -1027,\n+        -1024,\n+        -1020,\n+        -1017,\n+        -1014,\n+        -1010,\n+        -1007,\n+        -1004,\n+        -1000,\n+        -997,\n+        -994,\n+        -990,\n+        -987,\n+        -984,\n+        -980,\n+        -977,\n+        -974,\n+        -970,\n+        -967,\n+        -964,\n+        -960,\n+        -957,\n+        -954,\n+        -950,\n+        -947,\n+        -944,\n+        -940,\n+        -937,\n+        -934,\n+        -931,\n+        -927,\n+        -924,\n+        -921,\n+        -917,\n+        -914,\n+        -911,\n+        -907,\n+        -904,\n+        -901,\n+        -897,\n+        -894,\n+        -891,\n+        -887,\n+        -884,\n+        -881,\n+        -877,\n+        -874,\n+        -871,\n+        -867,\n+        -864,\n+        -861,\n+        -857,\n+        -854,\n+        -851,\n+        -847,\n+        -844,\n+        -841,\n+        -838,\n+        -834,\n+        -831,\n+        -828,\n+        -824,\n+        -821,\n+        -818,\n+        -814,\n+        -811,\n+        -808,\n+        -804,\n+        -801,\n+        -798,\n+        -794,\n+        -791,\n+        -788,\n+        -784,\n+        -781,\n+        -778,\n+        -774,\n+        -771,\n+        -768,\n+        -764,\n+        -761,\n+        -758,\n+        -754,\n+        -751,\n+        -748,\n+        -744,\n+        -741,\n+        -738,\n+        -735,\n+        -731,\n+        -728,\n+        -725,\n+        -721,\n+        -718,\n+        -715,\n+        -711,\n+        -708,\n+        -705,\n+        -701,\n+        -698,\n+        -695,\n+        -691,\n+        -688,\n+        -685,\n+        -681,\n+        -678,\n+        -675,\n+        -671,\n+        -668,\n+        -665,\n+        -661,\n+        -658,\n+        -655,\n+        -651,\n+        -648,\n+        -645,\n+        -642,\n+        -638,\n+        -635,\n+        -632,\n+        -628,\n+        -625,\n+        -622,\n+        -618,\n+        -615,\n+        -612,\n+        -608,\n+        -605,\n+        -602,\n+        -598,\n+        -595,\n+        -592,\n+        -588,\n+        -585,\n+        -582,\n+        -578,\n+        -575,\n+        -572,\n+        -568,\n+        -565,\n+        -562,\n+        -558,\n+        -555,\n+        -552,\n+        -549,\n+        -545,\n+        -542,\n+        -539,\n+        -535,\n+        -532,\n+        -529,\n+        -525,\n+        -522,\n+        -519,\n+        -515,\n+        -512,\n+        -509,\n+        -505,\n+        -502,\n+        -499,\n+        -495,\n+        -492,\n+        -489,\n+        -485,\n+        -482,\n+        -479,\n+        -475,\n+        -472,\n+        -469,\n+        -465,\n+        -462,\n+        -459,\n+        -455,\n+        -452,\n+        -449,\n+        -446,\n+        -442,\n+        -439,\n+        -436,\n+        -432,\n+        -429,\n+        -426,\n+        -422,\n+        -419,\n+        -416,\n+        -412,\n+        -409,\n+        -406,\n+        -402,\n+        -399,\n+        -396,\n+        -392,\n+        -389,\n+        -386,\n+        -382,\n+        -379,\n+        -376,\n+        -372,\n+        -369,\n+        -366,\n+        -362,\n+        -359,\n+        -356,\n+        -353,\n+        -349,\n+        -346,\n+        -343,\n+        -339,\n+        -336,\n+        -333,\n+        -329,\n+        -326,\n+        -323,\n+        -319,\n+        -316,\n+        -313,\n+        -309,\n+        -306,\n+        -303,\n+        -299,\n+        -296,\n+        -293,\n+        -289,\n+        -286,\n+        -283,\n+        -279,\n+        -276,\n+        -273,\n+        -269,\n+        -266,\n+        -263,\n+        -259,\n+        -256,\n+        -253,\n+        -250,\n+        -246,\n+        -243,\n+        -240,\n+        -236,\n+        -233,\n+        -230,\n+        -226,\n+        -223,\n+        -220,\n+        -216,\n+        -213,\n+        -210,\n+        -206,\n+        -203,\n+        -200,\n+        -196,\n+        -193,\n+        -190,\n+        -186,\n+        -183,\n+        -180,\n+        -176,\n+        -173,\n+        -170,\n+        -166,\n+        -163,\n+        -160,\n+        -157,\n+        -153,\n+        -150,\n+        -147,\n+        -143,\n+        -140,\n+        -137,\n+        -133,\n+        -130,\n+        -127,\n+        -123,\n+        -120,\n+        -117,\n+        -113,\n+        -110,\n+        -107,\n+        -103,\n+        -100,\n+        -97,\n+        -93,\n+        -90,\n+        -87,\n+        -83,\n+        -80,\n+        -77,\n+        -73,\n+        -70,\n+        -67,\n+        -63,\n+        -60,\n+        -57,\n+        -54,\n+        -50,\n+        -47,\n+        -44,\n+        -40,\n+        -37,\n+        -34,\n+        -30,\n+        -27,\n+        -24,\n+        -20,\n+        -17,\n+        -14,\n+        -10,\n+        -7,\n+        -4,\n+        0,\n+        3,\n+        6,\n+        10,\n+        13,\n+        16,\n+        20,\n+        23,\n+        26,\n+        30,\n+        33,\n+        36,\n+        39,\n+        43,\n+        46,\n+        49,\n+        53,\n+        56,\n+        59,\n+        63,\n+        66,\n+        69,\n+        73,\n+        76,\n+        79,\n+        83,\n+        86,\n+        89,\n+        93,\n+        96,\n+        99,\n+        103,\n+        106,\n+        109,\n+        113,\n+        116,\n+        119,\n+        123,\n+        126,\n+        129,\n+        132,\n+        136,\n+        139,\n+        142,\n+        146,\n+        149,\n+        152,\n+        156,\n+        159,\n+        162,\n+        166,\n+        169,\n+        172,\n+        176,\n+        179,\n+        182,\n+        186,\n+        189,\n+        192,\n+        196,\n+        199,\n+        202,\n+        206,\n+        209,\n+        212,\n+        216,\n+        219,\n+        222,\n+        226,\n+        229,\n+        232,\n+        235,\n+        239,\n+        242,\n+        245,\n+        249,\n+        252,\n+        255,\n+        259,\n+        262,\n+        265,\n+        269,\n+        272,\n+        275,\n+        279,\n+        282,\n+        285,\n+        289,\n+        292,\n+        295,\n+        299,\n+        302,\n+        305,\n+        309,\n+        312,\n+        315,\n+        319,\n+        322,\n+        325,\n+        328,\n+        332,\n+        335,\n+        338,\n+        342,\n+        345,\n+        348,\n+        352,\n+        355,\n+        358,\n+        362,\n+        365,\n+        368,\n+        372,\n+        375,\n+        378,\n+        382,\n+        385,\n+        388,\n+        392,\n+        395,\n+        398,\n+        402,\n+        405,\n+        408,\n+        412,\n+        415,\n+        418,\n+        422,\n+        425,\n+        428,\n+        431,\n+        435,\n+        438,\n+        441,\n+        445,\n+        448,\n+        451,\n+        455,\n+        458,\n+        461,\n+        465,\n+        468,\n+        471,\n+        475,\n+        478,\n+        481,\n+        485,\n+        488,\n+        491,\n+        495,\n+        498,\n+        501,\n+        505,\n+        508,\n+        511,\n+        515,\n+        518,\n+        521,\n+        524,\n+        528,\n+        531,\n+        534,\n+        538,\n+        541,\n+        544,\n+        548,\n+        551,\n+        554,\n+        558,\n+        561,\n+        564,\n+        568,\n+        571,\n+        574,\n+        578,\n+        581,\n+        584,\n+        588,\n+        591,\n+        594,\n+        598,\n+        601,\n+        604,\n+        608,\n+        611,\n+        614,\n+        617,\n+        621,\n+        624,\n+        627,\n+        631,\n+        634,\n+        637,\n+        641,\n+        644,\n+        647,\n+        651,\n+        654,\n+        657,\n+        661,\n+        664,\n+        667,\n+        671,\n+        674,\n+        677,\n+        681,\n+        684,\n+        687,\n+        691,\n+        694,\n+        697,\n+        701,\n+        704,\n+        707,\n+        711,\n+        714,\n+        717,\n+        720,\n+        724,\n+        727,\n+        730,\n+        734,\n+        737,\n+        740,\n+        744,\n+        747,\n+        750,\n+        754,\n+        757,\n+        760,\n+        764,\n+        767,\n+        770,\n+        774,\n+        777,\n+        780,\n+        784,\n+        787,\n+        790,\n+        794,\n+        797,\n+        800,\n+        804,\n+        807,\n+        810,\n+        813,\n+        817,\n+        820,\n+        823,\n+        827,\n+        830,\n+        833,\n+        837,\n+        840,\n+        843,\n+        847,\n+        850,\n+        853,\n+        857,\n+        860,\n+        863,\n+        867,\n+        870,\n+        873,\n+        877,\n+        880,\n+        883,\n+        887,\n+        890,\n+        893,\n+        897,\n+        900,\n+        903,\n+        907,\n+        910,\n+        913,\n+        916,\n+        920,\n+        923,\n+        926,\n+        930,\n+        933,\n+        936,\n+        940,\n+        943,\n+        946,\n+        950,\n+    ],\n+);\n \n+#[rustfmt::skip]\n pub const F32_SHORT_POWERS: [f32; 11] = [\n     1e0,\n     1e1,\n@@ -1244,6 +1249,7 @@ pub const F32_SHORT_POWERS: [f32; 11] = [\n     1e10,\n ];\n \n+#[rustfmt::skip]\n pub const F64_SHORT_POWERS: [f64; 23] = [\n     1e0,\n     1e1,"}, {"sha": "0e601d45a2124ba8bfc569641fe7e9f5eb4102b4", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -3,9 +3,11 @@\n // This module is only for dec2flt and flt2dec, and only public because of coretests.\n // It is not intended to ever be stabilized.\n #![doc(hidden)]\n-#![unstable(feature = \"core_private_diy_float\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"core_private_diy_float\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n /// A custom 64-bit floating point type, representing `f * 2^e`.\n #[derive(Copy, Clone, Debug)]\n@@ -74,9 +76,6 @@ impl Fp {\n         assert!(edelta >= 0);\n         let edelta = edelta as usize;\n         assert_eq!(self.f << edelta >> edelta, self.f);\n-        Fp {\n-            f: self.f << edelta,\n-            e,\n-        }\n+        Fp { f: self.f << edelta, e }\n     }\n }"}, {"sha": "ac06f95e244b6f97c407804b0812dac9d151fa12", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -7,9 +7,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(bootstrap))]\n+use crate::convert::FloatToInt;\n #[cfg(not(test))]\n use crate::intrinsics;\n-\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -26,7 +27,7 @@ pub const DIGITS: u32 = 6;\n \n /// [Machine epsilon] value for `f32`.\n ///\n-/// This is the difference between `1.0` and the next largest representable number.\n+/// This is the difference between `1.0` and the next larger representable number.\n ///\n /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -75,6 +76,12 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n+    /// The full circle constant (\u03c4)\n+    ///\n+    /// Equal to 2\u03c0.\n+    #[unstable(feature = \"tau_constant\", issue = \"66770\")]\n+    pub const TAU: f32 = 6.28318530717958647692528676655900577_f32;\n+\n     /// \u03c0/2\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n@@ -394,6 +401,35 @@ impl f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n+    /// Rounds toward zero and converts to any primitive integer type,\n+    /// assuming that the value is finite and fits in that type.\n+    ///\n+    /// ```\n+    /// #![feature(float_approx_unchecked_to)]\n+    ///\n+    /// let value = 4.6_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// assert_eq!(rounded, 4);\n+    ///\n+    /// let value = -128.9_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n+    /// assert_eq!(rounded, std::i8::MIN);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The value must:\n+    ///\n+    /// * Not be `NaN`\n+    /// * Not be infinite\n+    /// * Be representable in the return type `Int`, after truncating off its fractional part\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[inline]\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+        FloatToInt::<Int>::approx_unchecked(self)\n+    }\n+\n     /// Raw transmutation to `u32`.\n     ///\n     /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms."}, {"sha": "794f77fcfc1be379e879214ee5a4cd2672ac9ae8", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -7,9 +7,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(bootstrap))]\n+use crate::convert::FloatToInt;\n #[cfg(not(test))]\n use crate::intrinsics;\n-\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -26,7 +27,7 @@ pub const DIGITS: u32 = 15;\n \n /// [Machine epsilon] value for `f64`.\n ///\n-/// This is the difference between `1.0` and the next largest representable number.\n+/// This is the difference between `1.0` and the next larger representable number.\n ///\n /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -75,6 +76,12 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n+    /// The full circle constant (\u03c4)\n+    ///\n+    /// Equal to 2\u03c0.\n+    #[unstable(feature = \"tau_constant\", issue = \"66770\")]\n+    pub const TAU: f64 = 6.28318530717958647692528676655900577_f64;\n+\n     /// \u03c0/2\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n@@ -407,6 +414,35 @@ impl f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n+    /// Rounds toward zero and converts to any primitive integer type,\n+    /// assuming that the value is finite and fits in that type.\n+    ///\n+    /// ```\n+    /// #![feature(float_approx_unchecked_to)]\n+    ///\n+    /// let value = 4.6_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// assert_eq!(rounded, 4);\n+    ///\n+    /// let value = -128.9_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n+    /// assert_eq!(rounded, std::i8::MIN);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The value must:\n+    ///\n+    /// * Not be `NaN`\n+    /// * Not be infinite\n+    /// * Be representable in the return type `Int`, after truncating off its fractional part\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[inline]\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+        FloatToInt::<Int>::approx_unchecked(self)\n+    }\n+\n     /// Raw transmutation to `u64`.\n     ///\n     /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms."}, {"sha": "2b74effbe2e988e5ae7645091a1e6d95cba985e9", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,8 +1,8 @@\n //! Decodes a floating-point value into individual parts and error ranges.\n \n-use crate::{f32, f64};\n-use crate::num::FpCategory;\n use crate::num::dec2flt::rawfp::RawFloat;\n+use crate::num::FpCategory;\n+use crate::{f32, f64};\n \n /// Decoded unsigned finite value, such that:\n ///\n@@ -47,11 +47,15 @@ pub trait DecodableFloat: RawFloat + Copy {\n }\n \n impl DecodableFloat for f32 {\n-    fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }\n+    fn min_pos_norm_value() -> Self {\n+        f32::MIN_POSITIVE\n+    }\n }\n \n impl DecodableFloat for f64 {\n-    fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }\n+    fn min_pos_norm_value() -> Self {\n+        f64::MIN_POSITIVE\n+    }\n }\n \n /// Returns a sign (true when negative) and `FullDecoded` value\n@@ -67,20 +71,29 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n             // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n             // Float::integer_decode always preserves the exponent,\n             // so the mantissa is scaled for subnormals.\n-            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1,\n-                                          exp, inclusive: even })\n+            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1, exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n             let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n             if mant == minnorm.0 {\n                 // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                 // where maxmant = minnormmant * 2 - 1\n-                FullDecoded::Finite(Decoded { mant: mant << 2, minus: 1, plus: 2,\n-                                              exp: exp - 2, inclusive: even })\n+                FullDecoded::Finite(Decoded {\n+                    mant: mant << 2,\n+                    minus: 1,\n+                    plus: 2,\n+                    exp: exp - 2,\n+                    inclusive: even,\n+                })\n             } else {\n                 // neighbors: (mant - 1, exp) -- (mant, exp) -- (mant + 1, exp)\n-                FullDecoded::Finite(Decoded { mant: mant << 1, minus: 1, plus: 1,\n-                                              exp: exp - 1, inclusive: even })\n+                FullDecoded::Finite(Decoded {\n+                    mant: mant << 1,\n+                    minus: 1,\n+                    plus: 1,\n+                    exp: exp - 1,\n+                    inclusive: even,\n+                })\n             }\n         }\n     };"}, {"sha": "63df5613453238988f1720f79eaf6fec1b97ca74", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 145, "deletions": 51, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -116,15 +116,17 @@ functions.\n // while this is extensively documented, this is in principle private which is\n // only made public for testing. do not expose us.\n #![doc(hidden)]\n-#![unstable(feature = \"flt2dec\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"flt2dec\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n+pub use self::decoder::{decode, DecodableFloat, Decoded, FullDecoded};\n use crate::i16;\n-pub use self::decoder::{decode, DecodableFloat, FullDecoded, Decoded};\n \n-pub mod estimator;\n pub mod decoder;\n+pub mod estimator;\n \n /// Digit-generation algorithms.\n pub mod strategy {\n@@ -144,17 +146,24 @@ pub const MAX_SIG_DIGITS: usize = 17;\n #[doc(hidden)]\n pub fn round_up(d: &mut [u8], n: usize) -> Option<u8> {\n     match d[..n].iter().rposition(|&c| c != b'9') {\n-        Some(i) => { // d[i+1..n] is all nines\n+        Some(i) => {\n+            // d[i+1..n] is all nines\n             d[i] += 1;\n-            for j in i+1..n { d[j] = b'0'; }\n+            for j in i + 1..n {\n+                d[j] = b'0';\n+            }\n             None\n         }\n-        None if n > 0 => { // 999..999 rounds to 1000..000 with an increased exponent\n+        None if n > 0 => {\n+            // 999..999 rounds to 1000..000 with an increased exponent\n             d[0] = b'1';\n-            for j in 1..n { d[j] = b'0'; }\n+            for j in 1..n {\n+                d[j] = b'0';\n+            }\n             Some(b'0')\n         }\n-        None => { // an empty buffer rounds up (a bit strange but reasonable)\n+        None => {\n+            // an empty buffer rounds up (a bit strange but reasonable)\n             Some(b'1')\n         }\n     }\n@@ -176,8 +185,19 @@ impl<'a> Part<'a> {\n     pub fn len(&self) -> usize {\n         match *self {\n             Part::Zero(nzeroes) => nzeroes,\n-            Part::Num(v) => if v < 1_000 { if v < 10 { 1 } else if v < 100 { 2 } else { 3 } }\n-                            else { if v < 10_000 { 4 } else { 5 } },\n+            Part::Num(v) => {\n+                if v < 1_000 {\n+                    if v < 10 {\n+                        1\n+                    } else if v < 100 {\n+                        2\n+                    } else {\n+                        3\n+                    }\n+                } else {\n+                    if v < 10_000 { 4 } else { 5 }\n+                }\n+            }\n             Part::Copy(buf) => buf.len(),\n         }\n     }\n@@ -190,7 +210,9 @@ impl<'a> Part<'a> {\n         if out.len() >= len {\n             match *self {\n                 Part::Zero(nzeroes) => {\n-                    for c in &mut out[..nzeroes] { *c = b'0'; }\n+                    for c in &mut out[..nzeroes] {\n+                        *c = b'0';\n+                    }\n                 }\n                 Part::Num(mut v) => {\n                     for c in out[..len].iter_mut().rev() {\n@@ -234,7 +256,9 @@ impl<'a> Formatted<'a> {\n     /// Returns the number of written bytes, or `None` if the buffer is not enough.\n     /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n     pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n-        if out.len() < self.sign.len() { return None; }\n+        if out.len() < self.sign.len() {\n+            return None;\n+        }\n         out[..self.sign.len()].copy_from_slice(self.sign);\n \n         let mut written = self.sign.len();\n@@ -254,8 +278,12 @@ impl<'a> Formatted<'a> {\n /// it will be ignored and full digits will be printed. It is only used to print\n /// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n /// it will only print given digits and nothing else.\n-fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n-                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+fn digits_to_dec_str<'a>(\n+    buf: &'a [u8],\n+    exp: i16,\n+    frac_digits: usize,\n+    parts: &'a mut [Part<'a>],\n+) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n     assert!(buf[0] > b'0');\n     assert!(parts.len() >= 4);\n@@ -322,8 +350,13 @@ fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n /// it will be ignored and full digits will be printed. It is only used to print\n /// additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n /// it will only print the given digits and nothing else.\n-fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,\n-                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+fn digits_to_exp_str<'a>(\n+    buf: &'a [u8],\n+    exp: i16,\n+    min_ndigits: usize,\n+    upper: bool,\n+    parts: &'a mut [Part<'a>],\n+) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n     assert!(buf[0] > b'0');\n     assert!(parts.len() >= 6);\n@@ -359,11 +392,11 @@ fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: boo\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Sign {\n     /// Prints `-` only for the negative non-zero values.\n-    Minus,        // -inf -1  0  0  1  inf nan\n+    Minus, // -inf -1  0  0  1  inf nan\n     /// Prints `-` only for any negative values (including the negative zero).\n-    MinusRaw,     // -inf -1 -0  0  1  inf nan\n+    MinusRaw, // -inf -1 -0  0  1  inf nan\n     /// Prints `-` for the negative non-zero values, or `+` otherwise.\n-    MinusPlus,    // -inf -1 +0 +0 +1 +inf nan\n+    MinusPlus, // -inf -1 +0 +0 +1 +inf nan\n     /// Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n     MinusPlusRaw, // -inf -1 -0 +0 +1 +inf nan\n }\n@@ -374,11 +407,35 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n     match (*decoded, sign) {\n         (FullDecoded::Nan, _) => b\"\",\n         (FullDecoded::Zero, Sign::Minus) => b\"\",\n-        (FullDecoded::Zero, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n+        (FullDecoded::Zero, Sign::MinusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"\"\n+            }\n+        }\n         (FullDecoded::Zero, Sign::MinusPlus) => b\"+\",\n-        (FullDecoded::Zero, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n-        (_, Sign::Minus) | (_, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n-        (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n+        (FullDecoded::Zero, Sign::MinusPlusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"+\"\n+            }\n+        }\n+        (_, Sign::Minus) | (_, Sign::MinusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"\"\n+            }\n+        }\n+        (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"+\"\n+            }\n+        }\n     }\n }\n \n@@ -400,10 +457,19 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n /// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n /// There should be at least 4 parts available, due to the worst case like\n /// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n-pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n-                                 sign: Sign, frac_digits: usize, _upper: bool,\n-                                 buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+pub fn to_shortest_str<'a, T, F>(\n+    mut format_shortest: F,\n+    v: T,\n+    sign: Sign,\n+    frac_digits: usize,\n+    _upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     assert!(parts.len() >= 4);\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n \n@@ -419,7 +485,8 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if frac_digits > 0 { // [0.][0000]\n+            if frac_digits > 0 {\n+                // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n                 Formatted { sign, parts: &parts[..2] }\n@@ -430,8 +497,7 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n         }\n         FullDecoded::Finite(ref decoded) => {\n             let (len, exp) = format_shortest(decoded, buf);\n-            Formatted { sign,\n-                        parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+            Formatted { sign, parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n         }\n     }\n }\n@@ -455,10 +521,19 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n /// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n /// There should be at least 6 parts available, due to the worst case like\n /// `[+][1][.][2345][e][-][6]`.\n-pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n-                                     sign: Sign, dec_bounds: (i16, i16), upper: bool,\n-                                     buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+pub fn to_shortest_exp_str<'a, T, F>(\n+    mut format_shortest: F,\n+    v: T,\n+    sign: Sign,\n+    dec_bounds: (i16, i16),\n+    upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     assert!(parts.len() >= 6);\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n     assert!(dec_bounds.0 <= dec_bounds.1);\n@@ -534,10 +609,19 @@ fn estimate_max_buf_len(exp: i16) -> usize {\n /// (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n /// There should be at least 6 parts available, due to the worst case like\n /// `[+][1][.][2345][e][-][6]`.\n-pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n-                                  sign: Sign, ndigits: usize, upper: bool,\n-                                  buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+pub fn to_exact_exp_str<'a, T, F>(\n+    mut format_exact: F,\n+    v: T,\n+    sign: Sign,\n+    ndigits: usize,\n+    upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+{\n     assert!(parts.len() >= 6);\n     assert!(ndigits > 0);\n \n@@ -553,7 +637,8 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if ndigits > 1 { // [0.][0000][e0]\n+            if ndigits > 1 {\n+                // [0.][0000][e0]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(ndigits - 1);\n                 parts[2] = Part::Copy(if upper { b\"E0\" } else { b\"e0\" });\n@@ -569,8 +654,7 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n \n             let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n             let (len, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n-            Formatted { sign,\n-                        parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n+            Formatted { sign, parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n         }\n     }\n }\n@@ -590,10 +674,19 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n /// (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n /// There should be at least 4 parts available, due to the worst case like\n /// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n-pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n-                                    sign: Sign, frac_digits: usize, _upper: bool,\n-                                    buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+pub fn to_exact_fixed_str<'a, T, F>(\n+    mut format_exact: F,\n+    v: T,\n+    sign: Sign,\n+    frac_digits: usize,\n+    _upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+{\n     assert!(parts.len() >= 4);\n \n     let (negative, full_decoded) = decode(v);\n@@ -608,7 +701,8 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if frac_digits > 0 { // [0.][0000]\n+            if frac_digits > 0 {\n+                // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n                 Formatted { sign, parts: &parts[..2] }\n@@ -631,7 +725,8 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                 // `exp` was. this does not include the case that the restriction has been met\n                 // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n                 debug_assert_eq!(len, 0);\n-                if frac_digits > 0 { // [0.][0000]\n+                if frac_digits > 0 {\n+                    // [0.][0000]\n                     parts[0] = Part::Copy(b\"0.\");\n                     parts[1] = Part::Zero(frac_digits);\n                     Formatted { sign, parts: &parts[..2] }\n@@ -640,8 +735,7 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                     Formatted { sign, parts: &parts[..1] }\n                 }\n             } else {\n-                Formatted { sign,\n-                            parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+                Formatted { sign, parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n             }\n         }\n     }"}, {"sha": "c8de0004352efed9e9fd24d961b4bce2ec6fee75", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 100, "deletions": 43, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -6,38 +6,54 @@\n \n use crate::cmp::Ordering;\n \n-use crate::num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n-use crate::num::flt2dec::estimator::estimate_scaling_factor;\n-use crate::num::bignum::Digit32 as Digit;\n use crate::num::bignum::Big32x40 as Big;\n+use crate::num::bignum::Digit32 as Digit;\n+use crate::num::flt2dec::estimator::estimate_scaling_factor;\n+use crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n \n-static POW10: [Digit; 10] = [1, 10, 100, 1000, 10000, 100000,\n-                             1000000, 10000000, 100000000, 1000000000];\n-static TWOPOW10: [Digit; 10] = [2, 20, 200, 2000, 20000, 200000,\n-                                2000000, 20000000, 200000000, 2000000000];\n+static POW10: [Digit; 10] =\n+    [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];\n+static TWOPOW10: [Digit; 10] =\n+    [2, 20, 200, 2000, 20000, 200000, 2000000, 20000000, 200000000, 2000000000];\n \n // precalculated arrays of `Digit`s for 10^(2^n)\n static POW10TO16: [Digit; 2] = [0x6fc10000, 0x2386f2];\n static POW10TO32: [Digit; 4] = [0, 0x85acef81, 0x2d6d415b, 0x4ee];\n static POW10TO64: [Digit; 7] = [0, 0, 0xbf6a1f01, 0x6e38ed64, 0xdaa797ed, 0xe93ff9f4, 0x184f03];\n-static POW10TO128: [Digit; 14] =\n-    [0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08,\n-     0xbccdb0da, 0xa6337f19, 0xe91f2603, 0x24e];\n-static POW10TO256: [Digit; 27] =\n-    [0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6,\n-     0xcf4a6e70, 0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e,\n-     0xcc5573c0, 0x65f9ef17, 0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7];\n+static POW10TO128: [Digit; 14] = [\n+    0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08, 0xbccdb0da,\n+    0xa6337f19, 0xe91f2603, 0x24e,\n+];\n+static POW10TO256: [Digit; 27] = [\n+    0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6, 0xcf4a6e70,\n+    0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e, 0xcc5573c0, 0x65f9ef17,\n+    0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7,\n+];\n \n #[doc(hidden)]\n pub fn mul_pow10(x: &mut Big, n: usize) -> &mut Big {\n     debug_assert!(n < 512);\n-    if n &   7 != 0 { x.mul_small(POW10[n & 7]); }\n-    if n &   8 != 0 { x.mul_small(POW10[8]); }\n-    if n &  16 != 0 { x.mul_digits(&POW10TO16); }\n-    if n &  32 != 0 { x.mul_digits(&POW10TO32); }\n-    if n &  64 != 0 { x.mul_digits(&POW10TO64); }\n-    if n & 128 != 0 { x.mul_digits(&POW10TO128); }\n-    if n & 256 != 0 { x.mul_digits(&POW10TO256); }\n+    if n & 7 != 0 {\n+        x.mul_small(POW10[n & 7]);\n+    }\n+    if n & 8 != 0 {\n+        x.mul_small(POW10[8]);\n+    }\n+    if n & 16 != 0 {\n+        x.mul_digits(&POW10TO16);\n+    }\n+    if n & 32 != 0 {\n+        x.mul_digits(&POW10TO32);\n+    }\n+    if n & 64 != 0 {\n+        x.mul_digits(&POW10TO64);\n+    }\n+    if n & 128 != 0 {\n+        x.mul_digits(&POW10TO128);\n+    }\n+    if n & 256 != 0 {\n+        x.mul_digits(&POW10TO256);\n+    }\n     x\n }\n \n@@ -52,13 +68,30 @@ fn div_2pow10(x: &mut Big, mut n: usize) -> &mut Big {\n }\n \n // only usable when `x < 16 * scale`; `scaleN` should be `scale.mul_small(N)`\n-fn div_rem_upto_16<'a>(x: &'a mut Big, scale: &Big,\n-                       scale2: &Big, scale4: &Big, scale8: &Big) -> (u8, &'a mut Big) {\n+fn div_rem_upto_16<'a>(\n+    x: &'a mut Big,\n+    scale: &Big,\n+    scale2: &Big,\n+    scale4: &Big,\n+    scale8: &Big,\n+) -> (u8, &'a mut Big) {\n     let mut d = 0;\n-    if *x >= *scale8 { x.sub(scale8); d += 8; }\n-    if *x >= *scale4 { x.sub(scale4); d += 4; }\n-    if *x >= *scale2 { x.sub(scale2); d += 2; }\n-    if *x >= *scale  { x.sub(scale);  d += 1; }\n+    if *x >= *scale8 {\n+        x.sub(scale8);\n+        d += 8;\n+    }\n+    if *x >= *scale4 {\n+        x.sub(scale4);\n+        d += 4;\n+    }\n+    if *x >= *scale2 {\n+        x.sub(scale2);\n+        d += 2;\n+    }\n+    if *x >= *scale {\n+        x.sub(scale);\n+        d += 1;\n+    }\n     debug_assert!(*x < *scale);\n     (d, x)\n }\n@@ -85,7 +118,7 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n \n     // `a.cmp(&b) < rounding` is `if d.inclusive {a <= b} else {a < b}`\n-    let rounding = if d.inclusive {Ordering::Greater} else {Ordering::Equal};\n+    let rounding = if d.inclusive { Ordering::Greater } else { Ordering::Equal };\n \n     // estimate `k_0` from original inputs satisfying `10^(k_0-1) < high <= 10^(k_0+1)`.\n     // the tight bound `k` satisfying `10^(k-1) < high <= 10^k` is calculated later.\n@@ -132,9 +165,12 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n     }\n \n     // cache `(2, 4, 8) * scale` for digit generation.\n-    let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n-    let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n-    let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+    let mut scale2 = scale.clone();\n+    scale2.mul_pow2(1);\n+    let mut scale4 = scale.clone();\n+    scale4.mul_pow2(2);\n+    let mut scale8 = scale.clone();\n+    scale8.mul_pow2(3);\n \n     let mut down;\n     let mut up;\n@@ -186,7 +222,9 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n         // - keep generating otherwise.\n         down = mant.cmp(&minus) < rounding;\n         up = scale.cmp(mant.clone().add(&plus)) < rounding;\n-        if down || up { break; } // we have the shortest representation, proceed to the rounding\n+        if down || up {\n+            break;\n+        } // we have the shortest representation, proceed to the rounding\n \n         // restore the invariants.\n         // this makes the algorithm always terminating: `minus` and `plus` always increases,\n@@ -269,22 +307,40 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n     if len > 0 {\n         // cache `(2, 4, 8) * scale` for digit generation.\n         // (this can be expensive, so do not calculate them when the buffer is empty.)\n-        let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n-        let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n-        let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+        let mut scale2 = scale.clone();\n+        scale2.mul_pow2(1);\n+        let mut scale4 = scale.clone();\n+        scale4.mul_pow2(2);\n+        let mut scale8 = scale.clone();\n+        scale8.mul_pow2(3);\n \n         for i in 0..len {\n-            if mant.is_zero() { // following digits are all zeroes, we stop here\n+            if mant.is_zero() {\n+                // following digits are all zeroes, we stop here\n                 // do *not* try to perform rounding! rather, fill remaining digits.\n-                for c in &mut buf[i..len] { *c = b'0'; }\n+                for c in &mut buf[i..len] {\n+                    *c = b'0';\n+                }\n                 return (len, k);\n             }\n \n             let mut d = 0;\n-            if mant >= scale8 { mant.sub(&scale8); d += 8; }\n-            if mant >= scale4 { mant.sub(&scale4); d += 4; }\n-            if mant >= scale2 { mant.sub(&scale2); d += 2; }\n-            if mant >= scale  { mant.sub(&scale);  d += 1; }\n+            if mant >= scale8 {\n+                mant.sub(&scale8);\n+                d += 8;\n+            }\n+            if mant >= scale4 {\n+                mant.sub(&scale4);\n+                d += 4;\n+            }\n+            if mant >= scale2 {\n+                mant.sub(&scale2);\n+                d += 2;\n+            }\n+            if mant >= scale {\n+                mant.sub(&scale);\n+                d += 1;\n+            }\n             debug_assert!(mant < scale);\n             debug_assert!(d < 10);\n             buf[i] = b'0' + d;\n@@ -296,8 +352,9 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n     // if the following digits are exactly 5000..., check the prior digit and try to\n     // round to even (i.e., avoid rounding up when the prior digit is even).\n     let order = mant.cmp(scale.mul_small(5));\n-    if order == Ordering::Greater || (order == Ordering::Equal &&\n-                                      (len == 0 || buf[len-1] & 1 == 1)) {\n+    if order == Ordering::Greater\n+        || (order == Ordering::Equal && (len == 0 || buf[len - 1] & 1 == 1))\n+    {\n         // if rounding up changes the length, the exponent should also change.\n         // but we've been requested a fixed number of digits, so do not alter the buffer...\n         if let Some(c) = round_up(buf, len) {"}, {"sha": "1e2db212dd0de03a22acc82b504caa37d410d0da", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 169, "deletions": 123, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -6,12 +6,13 @@\n //!   accurately with integers. SIGPLAN Not. 45, 6 (June 2010), 233-243.\n \n use crate::num::diy_float::Fp;\n-use crate::num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n-\n+use crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n \n // see the comments in `format_shortest_opt` for the rationale.\n-#[doc(hidden)] pub const ALPHA: i16 = -60;\n-#[doc(hidden)] pub const GAMMA: i16 = -32;\n+#[doc(hidden)]\n+pub const ALPHA: i16 = -60;\n+#[doc(hidden)]\n+pub const GAMMA: i16 = -32;\n \n /*\n # the following Python code generates this table:\n@@ -24,92 +25,95 @@ for i in xrange(-308, 333, 8):\n */\n \n #[doc(hidden)]\n-pub static CACHED_POW10: [(u64, i16, i16); 81] = [ // (f, e, k)\n+pub static CACHED_POW10: [(u64, i16, i16); 81] = [\n+    // (f, e, k)\n     (0xe61acf033d1a45df, -1087, -308),\n     (0xab70fe17c79ac6ca, -1060, -300),\n     (0xff77b1fcbebcdc4f, -1034, -292),\n     (0xbe5691ef416bd60c, -1007, -284),\n-    (0x8dd01fad907ffc3c,  -980, -276),\n-    (0xd3515c2831559a83,  -954, -268),\n-    (0x9d71ac8fada6c9b5,  -927, -260),\n-    (0xea9c227723ee8bcb,  -901, -252),\n-    (0xaecc49914078536d,  -874, -244),\n-    (0x823c12795db6ce57,  -847, -236),\n-    (0xc21094364dfb5637,  -821, -228),\n-    (0x9096ea6f3848984f,  -794, -220),\n-    (0xd77485cb25823ac7,  -768, -212),\n-    (0xa086cfcd97bf97f4,  -741, -204),\n-    (0xef340a98172aace5,  -715, -196),\n-    (0xb23867fb2a35b28e,  -688, -188),\n-    (0x84c8d4dfd2c63f3b,  -661, -180),\n-    (0xc5dd44271ad3cdba,  -635, -172),\n-    (0x936b9fcebb25c996,  -608, -164),\n-    (0xdbac6c247d62a584,  -582, -156),\n-    (0xa3ab66580d5fdaf6,  -555, -148),\n-    (0xf3e2f893dec3f126,  -529, -140),\n-    (0xb5b5ada8aaff80b8,  -502, -132),\n-    (0x87625f056c7c4a8b,  -475, -124),\n-    (0xc9bcff6034c13053,  -449, -116),\n-    (0x964e858c91ba2655,  -422, -108),\n-    (0xdff9772470297ebd,  -396, -100),\n-    (0xa6dfbd9fb8e5b88f,  -369,  -92),\n-    (0xf8a95fcf88747d94,  -343,  -84),\n-    (0xb94470938fa89bcf,  -316,  -76),\n-    (0x8a08f0f8bf0f156b,  -289,  -68),\n-    (0xcdb02555653131b6,  -263,  -60),\n-    (0x993fe2c6d07b7fac,  -236,  -52),\n-    (0xe45c10c42a2b3b06,  -210,  -44),\n-    (0xaa242499697392d3,  -183,  -36),\n-    (0xfd87b5f28300ca0e,  -157,  -28),\n-    (0xbce5086492111aeb,  -130,  -20),\n-    (0x8cbccc096f5088cc,  -103,  -12),\n-    (0xd1b71758e219652c,   -77,   -4),\n-    (0x9c40000000000000,   -50,    4),\n-    (0xe8d4a51000000000,   -24,   12),\n-    (0xad78ebc5ac620000,     3,   20),\n-    (0x813f3978f8940984,    30,   28),\n-    (0xc097ce7bc90715b3,    56,   36),\n-    (0x8f7e32ce7bea5c70,    83,   44),\n-    (0xd5d238a4abe98068,   109,   52),\n-    (0x9f4f2726179a2245,   136,   60),\n-    (0xed63a231d4c4fb27,   162,   68),\n-    (0xb0de65388cc8ada8,   189,   76),\n-    (0x83c7088e1aab65db,   216,   84),\n-    (0xc45d1df942711d9a,   242,   92),\n-    (0x924d692ca61be758,   269,  100),\n-    (0xda01ee641a708dea,   295,  108),\n-    (0xa26da3999aef774a,   322,  116),\n-    (0xf209787bb47d6b85,   348,  124),\n-    (0xb454e4a179dd1877,   375,  132),\n-    (0x865b86925b9bc5c2,   402,  140),\n-    (0xc83553c5c8965d3d,   428,  148),\n-    (0x952ab45cfa97a0b3,   455,  156),\n-    (0xde469fbd99a05fe3,   481,  164),\n-    (0xa59bc234db398c25,   508,  172),\n-    (0xf6c69a72a3989f5c,   534,  180),\n-    (0xb7dcbf5354e9bece,   561,  188),\n-    (0x88fcf317f22241e2,   588,  196),\n-    (0xcc20ce9bd35c78a5,   614,  204),\n-    (0x98165af37b2153df,   641,  212),\n-    (0xe2a0b5dc971f303a,   667,  220),\n-    (0xa8d9d1535ce3b396,   694,  228),\n-    (0xfb9b7cd9a4a7443c,   720,  236),\n-    (0xbb764c4ca7a44410,   747,  244),\n-    (0x8bab8eefb6409c1a,   774,  252),\n-    (0xd01fef10a657842c,   800,  260),\n-    (0x9b10a4e5e9913129,   827,  268),\n-    (0xe7109bfba19c0c9d,   853,  276),\n-    (0xac2820d9623bf429,   880,  284),\n-    (0x80444b5e7aa7cf85,   907,  292),\n-    (0xbf21e44003acdd2d,   933,  300),\n-    (0x8e679c2f5e44ff8f,   960,  308),\n-    (0xd433179d9c8cb841,   986,  316),\n-    (0x9e19db92b4e31ba9,  1013,  324),\n-    (0xeb96bf6ebadf77d9,  1039,  332),\n+    (0x8dd01fad907ffc3c, -980, -276),\n+    (0xd3515c2831559a83, -954, -268),\n+    (0x9d71ac8fada6c9b5, -927, -260),\n+    (0xea9c227723ee8bcb, -901, -252),\n+    (0xaecc49914078536d, -874, -244),\n+    (0x823c12795db6ce57, -847, -236),\n+    (0xc21094364dfb5637, -821, -228),\n+    (0x9096ea6f3848984f, -794, -220),\n+    (0xd77485cb25823ac7, -768, -212),\n+    (0xa086cfcd97bf97f4, -741, -204),\n+    (0xef340a98172aace5, -715, -196),\n+    (0xb23867fb2a35b28e, -688, -188),\n+    (0x84c8d4dfd2c63f3b, -661, -180),\n+    (0xc5dd44271ad3cdba, -635, -172),\n+    (0x936b9fcebb25c996, -608, -164),\n+    (0xdbac6c247d62a584, -582, -156),\n+    (0xa3ab66580d5fdaf6, -555, -148),\n+    (0xf3e2f893dec3f126, -529, -140),\n+    (0xb5b5ada8aaff80b8, -502, -132),\n+    (0x87625f056c7c4a8b, -475, -124),\n+    (0xc9bcff6034c13053, -449, -116),\n+    (0x964e858c91ba2655, -422, -108),\n+    (0xdff9772470297ebd, -396, -100),\n+    (0xa6dfbd9fb8e5b88f, -369, -92),\n+    (0xf8a95fcf88747d94, -343, -84),\n+    (0xb94470938fa89bcf, -316, -76),\n+    (0x8a08f0f8bf0f156b, -289, -68),\n+    (0xcdb02555653131b6, -263, -60),\n+    (0x993fe2c6d07b7fac, -236, -52),\n+    (0xe45c10c42a2b3b06, -210, -44),\n+    (0xaa242499697392d3, -183, -36),\n+    (0xfd87b5f28300ca0e, -157, -28),\n+    (0xbce5086492111aeb, -130, -20),\n+    (0x8cbccc096f5088cc, -103, -12),\n+    (0xd1b71758e219652c, -77, -4),\n+    (0x9c40000000000000, -50, 4),\n+    (0xe8d4a51000000000, -24, 12),\n+    (0xad78ebc5ac620000, 3, 20),\n+    (0x813f3978f8940984, 30, 28),\n+    (0xc097ce7bc90715b3, 56, 36),\n+    (0x8f7e32ce7bea5c70, 83, 44),\n+    (0xd5d238a4abe98068, 109, 52),\n+    (0x9f4f2726179a2245, 136, 60),\n+    (0xed63a231d4c4fb27, 162, 68),\n+    (0xb0de65388cc8ada8, 189, 76),\n+    (0x83c7088e1aab65db, 216, 84),\n+    (0xc45d1df942711d9a, 242, 92),\n+    (0x924d692ca61be758, 269, 100),\n+    (0xda01ee641a708dea, 295, 108),\n+    (0xa26da3999aef774a, 322, 116),\n+    (0xf209787bb47d6b85, 348, 124),\n+    (0xb454e4a179dd1877, 375, 132),\n+    (0x865b86925b9bc5c2, 402, 140),\n+    (0xc83553c5c8965d3d, 428, 148),\n+    (0x952ab45cfa97a0b3, 455, 156),\n+    (0xde469fbd99a05fe3, 481, 164),\n+    (0xa59bc234db398c25, 508, 172),\n+    (0xf6c69a72a3989f5c, 534, 180),\n+    (0xb7dcbf5354e9bece, 561, 188),\n+    (0x88fcf317f22241e2, 588, 196),\n+    (0xcc20ce9bd35c78a5, 614, 204),\n+    (0x98165af37b2153df, 641, 212),\n+    (0xe2a0b5dc971f303a, 667, 220),\n+    (0xa8d9d1535ce3b396, 694, 228),\n+    (0xfb9b7cd9a4a7443c, 720, 236),\n+    (0xbb764c4ca7a44410, 747, 244),\n+    (0x8bab8eefb6409c1a, 774, 252),\n+    (0xd01fef10a657842c, 800, 260),\n+    (0x9b10a4e5e9913129, 827, 268),\n+    (0xe7109bfba19c0c9d, 853, 276),\n+    (0xac2820d9623bf429, 880, 284),\n+    (0x80444b5e7aa7cf85, 907, 292),\n+    (0xbf21e44003acdd2d, 933, 300),\n+    (0x8e679c2f5e44ff8f, 960, 308),\n+    (0xd433179d9c8cb841, 986, 316),\n+    (0x9e19db92b4e31ba9, 1013, 324),\n+    (0xeb96bf6ebadf77d9, 1039, 332),\n ];\n \n-#[doc(hidden)] pub const CACHED_POW10_FIRST_E: i16 = -1087;\n-#[doc(hidden)] pub const CACHED_POW10_LAST_E: i16 = 1039;\n+#[doc(hidden)]\n+pub const CACHED_POW10_FIRST_E: i16 = -1087;\n+#[doc(hidden)]\n+pub const CACHED_POW10_LAST_E: i16 = 1039;\n \n #[doc(hidden)]\n pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) {\n@@ -128,30 +132,39 @@ pub fn max_pow10_no_more_than(x: u32) -> (u8, u32) {\n     debug_assert!(x > 0);\n \n     const X9: u32 = 10_0000_0000;\n-    const X8: u32 =  1_0000_0000;\n-    const X7: u32 =    1000_0000;\n-    const X6: u32 =     100_0000;\n-    const X5: u32 =      10_0000;\n-    const X4: u32 =       1_0000;\n-    const X3: u32 =         1000;\n-    const X2: u32 =          100;\n-    const X1: u32 =           10;\n+    const X8: u32 = 1_0000_0000;\n+    const X7: u32 = 1000_0000;\n+    const X6: u32 = 100_0000;\n+    const X5: u32 = 10_0000;\n+    const X4: u32 = 1_0000;\n+    const X3: u32 = 1000;\n+    const X2: u32 = 100;\n+    const X1: u32 = 10;\n \n     if x < X4 {\n-        if x < X2 { if x < X1 {(0,  1)} else {(1, X1)} }\n-        else      { if x < X3 {(2, X2)} else {(3, X3)} }\n+        if x < X2 {\n+            if x < X1 { (0, 1) } else { (1, X1) }\n+        } else {\n+            if x < X3 { (2, X2) } else { (3, X3) }\n+        }\n     } else {\n-        if x < X6      { if x < X5 {(4, X4)} else {(5, X5)} }\n-        else if x < X8 { if x < X7 {(6, X6)} else {(7, X7)} }\n-        else           { if x < X9 {(8, X8)} else {(9, X9)} }\n+        if x < X6 {\n+            if x < X5 { (4, X4) } else { (5, X5) }\n+        } else if x < X8 {\n+            if x < X7 { (6, X6) } else { (7, X7) }\n+        } else {\n+            if x < X9 { (8, X8) } else { (9, X9) }\n+        }\n     }\n }\n \n /// The shortest mode implementation for Grisu.\n ///\n /// It returns `None` when it would return an inexact representation otherwise.\n-pub fn format_shortest_opt(d: &Decoded,\n-                           buf: &mut [u8]) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+pub fn format_shortest_opt(\n+    d: &Decoded,\n+    buf: &mut [u8],\n+) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n     assert!(d.mant > 0);\n     assert!(d.minus > 0);\n     assert!(d.plus > 0);\n@@ -208,8 +221,8 @@ pub fn format_shortest_opt(d: &Decoded,\n     // we start with the correct repr within the unsafe region, and try to find the closest repr\n     // to `v` which is also within the safe region. if we can't, we give up.\n     let plus1 = plus.f + 1;\n-//  let plus0 = plus.f - 1; // only for explanation\n-//  let minus0 = minus.f + 1; // only for explanation\n+    //  let plus0 = plus.f - 1; // only for explanation\n+    //  let minus0 = minus.f + 1; // only for explanation\n     let minus1 = minus.f - 1;\n     let e = -plus.e as usize; // shared exponent\n \n@@ -235,14 +248,15 @@ pub fn format_shortest_opt(d: &Decoded,\n     // (e.g., `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n     // the algorithm relies on the later verification phase to exclude `y`.\n     let delta1 = plus1 - minus1;\n-//  let delta1int = (delta1 >> e) as usize; // only for explanation\n+    //  let delta1int = (delta1 >> e) as usize; // only for explanation\n     let delta1frac = delta1 & ((1 << e) - 1);\n \n     // render integral parts, while checking for the accuracy at each step.\n     let mut kappa = max_kappa as i16;\n     let mut ten_kappa = max_ten_kappa; // 10^kappa\n     let mut remainder = plus1int; // digits yet to be rendered\n-    loop { // we always have at least one digit to render, as `plus1 >= 10^kappa`\n+    loop {\n+        // we always have at least one digit to render, as `plus1 >= 10^kappa`\n         // invariants:\n         // - `delta1int <= remainder < 10^(kappa+1)`\n         // - `plus1int = d[0..n-1] * 10^(kappa+1) + remainder`\n@@ -281,7 +295,8 @@ pub fn format_shortest_opt(d: &Decoded,\n     let mut remainder = plus1frac;\n     let mut threshold = delta1frac;\n     let mut ulp = 1;\n-    loop { // the next digit should be significant as we've tested that before breaking out\n+    loop {\n+        // the next digit should be significant as we've tested that before breaking out\n         // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n         // - `remainder < 2^e`\n         // - `plus1frac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n@@ -300,8 +315,15 @@ pub fn format_shortest_opt(d: &Decoded,\n \n         if r < threshold {\n             let ten_kappa = 1 << e; // implicit divisor\n-            return round_and_weed(&mut buf[..i], exp, r, threshold,\n-                                  (plus1 - v.f) * ulp, ten_kappa, ulp);\n+            return round_and_weed(\n+                &mut buf[..i],\n+                exp,\n+                r,\n+                threshold,\n+                (plus1 - v.f) * ulp,\n+                ten_kappa,\n+                ulp,\n+            );\n         }\n \n         // restore invariants\n@@ -325,8 +347,15 @@ pub fn format_shortest_opt(d: &Decoded,\n     // - `plus1v = (plus1 - v) * k` (and also, `threshold > plus1v` from prior invariants)\n     // - `ten_kappa = 10^kappa * k`\n     // - `ulp = 2^-e * k`\n-    fn round_and_weed(buf: &mut [u8], exp: i16, remainder: u64, threshold: u64, plus1v: u64,\n-                      ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+    fn round_and_weed(\n+        buf: &mut [u8],\n+        exp: i16,\n+        remainder: u64,\n+        threshold: u64,\n+        plus1v: u64,\n+        ten_kappa: u64,\n+        ulp: u64,\n+    ) -> Option<(usize, i16)> {\n         assert!(!buf.is_empty());\n \n         // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n@@ -381,10 +410,11 @@ pub fn format_shortest_opt(d: &Decoded,\n             //\n             // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n             // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n-            while plus1w < plus1v_up &&\n-                  threshold - plus1w >= ten_kappa &&\n-                  (plus1w + ten_kappa < plus1v_up ||\n-                   plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up) {\n+            while plus1w < plus1v_up\n+                && threshold - plus1w >= ten_kappa\n+                && (plus1w + ten_kappa < plus1v_up\n+                    || plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up)\n+            {\n                 *last -= 1;\n                 debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n                 plus1w += ten_kappa;\n@@ -395,10 +425,11 @@ pub fn format_shortest_opt(d: &Decoded,\n         //\n         // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n         // replaced by `plus1v_down` instead. overflow analysis equally holds.\n-        if plus1w < plus1v_down &&\n-           threshold - plus1w >= ten_kappa &&\n-           (plus1w + ten_kappa < plus1v_down ||\n-            plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down) {\n+        if plus1w < plus1v_down\n+            && threshold - plus1w >= ten_kappa\n+            && (plus1w + ten_kappa < plus1v_down\n+                || plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down)\n+        {\n             return None;\n         }\n \n@@ -428,8 +459,11 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n /// The exact and fixed mode implementation for Grisu.\n ///\n /// It returns `None` when it would return an inexact representation otherwise.\n-pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n-                                -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+pub fn format_exact_opt(\n+    d: &Decoded,\n+    buf: &mut [u8],\n+    limit: i16,\n+) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n     assert!(d.mant > 0);\n     assert!(d.mant < (1 << 61)); // we need at least three bits of additional precision\n     assert!(!buf.is_empty());\n@@ -489,7 +523,8 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n     let mut kappa = max_kappa as i16;\n     let mut ten_kappa = max_ten_kappa; // 10^kappa\n     let mut remainder = vint; // digits yet to be rendered\n-    loop { // we always have at least one digit to render\n+    loop {\n+        // we always have at least one digit to render\n         // invariants:\n         // - `remainder < 10^(kappa+1)`\n         // - `vint = d[0..n-1] * 10^(kappa+1) + remainder`\n@@ -575,8 +610,15 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n     // - `remainder = (v % 10^kappa) * k`\n     // - `ten_kappa = 10^kappa * k`\n     // - `ulp = 2^-e * k`\n-    fn possibly_round(buf: &mut [u8], mut len: usize, mut exp: i16, limit: i16,\n-                      remainder: u64, ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+    fn possibly_round(\n+        buf: &mut [u8],\n+        mut len: usize,\n+        mut exp: i16,\n+        limit: i16,\n+        remainder: u64,\n+        ten_kappa: u64,\n+        ulp: u64,\n+    ) -> Option<(usize, i16)> {\n         debug_assert!(remainder < ten_kappa);\n \n         //           10^kappa\n@@ -593,7 +635,9 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n         //\n         // error is too large that there are at least three possible representations\n         // between `v - 1 ulp` and `v + 1 ulp`. we cannot determine which one is correct.\n-        if ulp >= ten_kappa { return None; }\n+        if ulp >= ten_kappa {\n+            return None;\n+        }\n \n         //    10^kappa\n         //   :<------->:\n@@ -607,7 +651,9 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n         // in fact, 1/2 ulp is enough to introduce two possible representations.\n         // (remember that we need a unique representation for both `v - 1 ulp` and `v + 1 ulp`.)\n         // this won't overflow, as `ulp < ten_kappa` from the first check.\n-        if ten_kappa - ulp <= ulp { return None; }\n+        if ten_kappa - ulp <= ulp {\n+            return None;\n+        }\n \n         //     remainder\n         //       :<->|                           :"}, {"sha": "d1f518d52dd72735577a5450cbe8efed76ebb866", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 97, "deletions": 495, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,7 +4,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::convert::{TryFrom, Infallible};\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n@@ -132,7 +131,7 @@ macro_rules! from_str_radix_nzint_impl {\n }\n \n from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\n-                             NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n+NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n \n /// Provides intentionally-wrapped arithmetic on `T`.\n ///\n@@ -163,8 +162,7 @@ from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n #[repr(transparent)]\n-pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                       pub T);\n+pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n@@ -209,33 +207,35 @@ impl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n }\n \n // All these modules are technically private and only exposed for coretests:\n-pub mod flt2dec;\n-pub mod dec2flt;\n pub mod bignum;\n+pub mod dec2flt;\n pub mod diy_float;\n+pub mod flt2dec;\n \n mod wrapping;\n \n macro_rules! usize_isize_to_xe_bytes_doc {\n-    () => {\"\n+    () => {\n+        \"\n \n **Note**: This function returns an array of length 2, 4 or 8 bytes\n depending on the target pointer size.\n \n-\"}\n+\"\n+    };\n }\n \n-\n macro_rules! usize_isize_from_xe_bytes_doc {\n-    () => {\"\n+    () => {\n+        \"\n \n **Note**: This function takes an array of length 2, 4 or 8 bytes\n depending on the target pointer size.\n \n-\"}\n+\"\n+    };\n }\n \n-// `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n     ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr, $Feature:expr,\n      $EndFeature:expr, $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n@@ -2240,70 +2240,69 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n #[lang = \"i8\"]\n impl i8 {\n     int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\", 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n-        \"[0x12]\", \"[0x12]\", \"\", \"\" }\n+    \"[0x12]\", \"[0x12]\", \"\", \"\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n     int_impl! { i16, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n-        \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n+    \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n     int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n-        \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n-        \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n+    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n+    \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n     int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\", 12,\n-         \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n-         \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n+    \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n+    \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n     int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n-        170141183460469231731687303715884105727, \"\", \"\", 16,\n-        \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n-        \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n-        \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n-          0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n-          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\", \"\", \"\" }\n+    170141183460469231731687303715884105727, \"\", \"\", 16,\n+    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n+    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n+    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n+      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n+      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\", \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n     int_impl! { isize, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n-        \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n-        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n+    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n     int_impl! { isize, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n-        \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n-        \"[0x12, 0x34, 0x56, 0x78]\",\n-        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n+    \"[0x12, 0x34, 0x56, 0x78]\",\n+    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n     int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\",\n-        12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n-         \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-         usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n+     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n-// `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n         $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n@@ -4063,8 +4062,7 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n #[lang = \"u8\"]\n impl u8 {\n     uint_impl! { u8, u8, 8, 255, \"\", \"\", 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n-        \"[0x12]\", \"\", \"\" }\n-\n+    \"[0x12]\", \"\", \"\" }\n \n     /// Checks if the value is within the ASCII range.\n     ///\n@@ -4230,7 +4228,7 @@ impl u8 {\n     pub fn is_ascii_alphabetic(&self) -> bool {\n         match *self {\n             b'A'..=b'Z' | b'a'..=b'z' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4265,7 +4263,7 @@ impl u8 {\n     pub fn is_ascii_uppercase(&self) -> bool {\n         match *self {\n             b'A'..=b'Z' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4300,7 +4298,7 @@ impl u8 {\n     pub fn is_ascii_lowercase(&self) -> bool {\n         match *self {\n             b'a'..=b'z' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4338,7 +4336,7 @@ impl u8 {\n     pub fn is_ascii_alphanumeric(&self) -> bool {\n         match *self {\n             b'0'..=b'9' | b'A'..=b'Z' | b'a'..=b'z' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4373,7 +4371,7 @@ impl u8 {\n     pub fn is_ascii_digit(&self) -> bool {\n         match *self {\n             b'0'..=b'9' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4411,7 +4409,7 @@ impl u8 {\n     pub fn is_ascii_hexdigit(&self) -> bool {\n         match *self {\n             b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4450,7 +4448,7 @@ impl u8 {\n     pub fn is_ascii_punctuation(&self) -> bool {\n         match *self {\n             b'!'..=b'/' | b':'..=b'@' | b'['..=b'`' | b'{'..=b'~' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4485,7 +4483,7 @@ impl u8 {\n     pub fn is_ascii_graphic(&self) -> bool {\n         match *self {\n             b'!'..=b'~' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4537,7 +4535,7 @@ impl u8 {\n     pub fn is_ascii_whitespace(&self) -> bool {\n         match *self {\n             b'\\t' | b'\\n' | b'\\x0C' | b'\\r' | b' ' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -4574,67 +4572,67 @@ impl u8 {\n     pub fn is_ascii_control(&self) -> bool {\n         match *self {\n             b'\\0'..=b'\\x1F' | b'\\x7F' => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n }\n \n #[lang = \"u16\"]\n impl u16 {\n     uint_impl! { u16, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n-        \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n+    \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n     uint_impl! { u32, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-        \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n+    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n     uint_impl! { u64, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n-        \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n-        \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-        \"\", \"\"}\n+    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n+    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+    \"\", \"\"}\n }\n \n #[lang = \"u128\"]\n impl u128 {\n     uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\", 16,\n-        \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n-        \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n-        \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n-          0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n-          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n-         \"\", \"\"}\n+    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n+    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n+    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n+      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n+      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n+     \"\", \"\"}\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n     uint_impl! { usize, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n-        \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n-        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n+    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n     uint_impl! { usize, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-        \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n-        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n+    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n     uint_impl! { usize, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n-        \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n-        \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-        usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n+    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n /// A classification of floating point numbers.\n@@ -4703,13 +4701,15 @@ from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n /// The error type returned when a checked integral type conversion fails.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromIntError(());\n+pub struct TryFromIntError(pub(crate) ());\n \n impl TryFromIntError {\n-    #[unstable(feature = \"int_error_internals\",\n-               reason = \"available through Error trait and this method should \\\n-                         not be exposed publicly\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"0\"\n+    )]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n         \"out of range integral type conversion attempted\"\n@@ -4724,222 +4724,12 @@ impl fmt::Display for TryFromIntError {\n }\n \n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl From<Infallible> for TryFromIntError {\n-    fn from(x: Infallible) -> TryFromIntError {\n-        match x {}\n-    }\n-}\n-\n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n impl From<!> for TryFromIntError {\n     fn from(never: !) -> TryFromIntError {\n-        // Match rather than coerce to make sure that code like\n-        // `From<Infallible> for TryFromIntError` above will keep working\n-        // when `Infallible` becomes an alias to `!`.\n         match never {}\n     }\n }\n \n-// no possible bounds violation\n-macro_rules! try_from_unbounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(value: $source) -> Result<Self, Self::Error> {\n-                Ok(value as $target)\n-            }\n-        }\n-    )*}\n-}\n-\n-// only negative bounds\n-macro_rules! try_from_lower_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u >= 0 {\n-                    Ok(u as $target)\n-                } else {\n-                    Err(TryFromIntError(()))\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// unsigned to signed (only positive bound)\n-macro_rules! try_from_upper_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u > (<$target>::max_value() as $source) {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// all other cases\n-macro_rules! try_from_both_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                let min = <$target>::min_value() as $source;\n-                let max = <$target>::max_value() as $source;\n-                if u < min || u > max {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-macro_rules! rev {\n-    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n-        $mac!($target, $source);\n-    )*}\n-}\n-\n-// intra-sign conversions\n-try_from_upper_bounded!(u16, u8);\n-try_from_upper_bounded!(u32, u16, u8);\n-try_from_upper_bounded!(u64, u32, u16, u8);\n-try_from_upper_bounded!(u128, u64, u32, u16, u8);\n-\n-try_from_both_bounded!(i16, i8);\n-try_from_both_bounded!(i32, i16, i8);\n-try_from_both_bounded!(i64, i32, i16, i8);\n-try_from_both_bounded!(i128, i64, i32, i16, i8);\n-\n-// unsigned-to-signed\n-try_from_upper_bounded!(u8, i8);\n-try_from_upper_bounded!(u16, i8, i16);\n-try_from_upper_bounded!(u32, i8, i16, i32);\n-try_from_upper_bounded!(u64, i8, i16, i32, i64);\n-try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n-\n-// signed-to-unsigned\n-try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n-try_from_lower_bounded!(i16, u16, u32, u64, u128);\n-try_from_lower_bounded!(i32, u32, u64, u128);\n-try_from_lower_bounded!(i64, u64, u128);\n-try_from_lower_bounded!(i128, u128);\n-try_from_both_bounded!(i16, u8);\n-try_from_both_bounded!(i32, u16, u8);\n-try_from_both_bounded!(i64, u32, u16, u8);\n-try_from_both_bounded!(i128, u64, u32, u16, u8);\n-\n-// usize/isize\n-try_from_upper_bounded!(usize, isize);\n-try_from_lower_bounded!(isize, usize);\n-\n-#[cfg(target_pointer_width = \"16\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16);\n-    try_from_unbounded!(usize, i32, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8);\n-    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8);\n-    try_from_unbounded!(isize, i16, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16);\n-    rev!(try_from_both_bounded, usize, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_both_bounded, isize, i32, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32);\n-    try_from_unbounded!(usize, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16);\n-    try_from_lower_bounded!(isize, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16);\n-    try_from_unbounded!(isize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32);\n-    rev!(try_from_upper_bounded, usize, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n-    rev!(try_from_both_bounded, usize, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u16);\n-    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i32);\n-    rev!(try_from_both_bounded, isize, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n-    try_from_unbounded!(usize, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16, u32);\n-    try_from_lower_bounded!(isize, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16, i32);\n-    try_from_unbounded!(isize, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32, u64);\n-    rev!(try_from_upper_bounded, usize, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n-    rev!(try_from_both_bounded, usize, i128);\n-\n-    rev!(try_from_unbounded, isize, u16, u32);\n-    rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i32, i64);\n-    rev!(try_from_both_bounded, isize, i128);\n-}\n-\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n@@ -4978,9 +4768,11 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n     use self::IntErrorKind::*;\n     use self::ParseIntError as PIE;\n \n-    assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n+    assert!(\n+        radix >= 2 && radix <= 36,\n+        \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+        radix\n+    );\n \n     if src.is_empty() {\n         return Err(PIE { kind: Empty });\n@@ -5061,10 +4853,12 @@ pub struct ParseIntError {\n }\n \n /// Enum to store the various types of errors that can cause parsing an integer to fail.\n-#[unstable(feature = \"int_error_matching\",\n-           reason = \"it can be useful to match errors when making error messages \\\n-                     for integer parsing\",\n-           issue = \"22639\")]\n+#[unstable(\n+    feature = \"int_error_matching\",\n+    reason = \"it can be useful to match errors when making error messages \\\n+              for integer parsing\",\n+    issue = \"22639\"\n+)]\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[non_exhaustive]\n pub enum IntErrorKind {\n@@ -5090,17 +4884,21 @@ pub enum IntErrorKind {\n \n impl ParseIntError {\n     /// Outputs the detailed cause of parsing an integer failing.\n-    #[unstable(feature = \"int_error_matching\",\n-               reason = \"it can be useful to match errors when making error messages \\\n-                         for integer parsing\",\n-               issue = \"22639\")]\n+    #[unstable(\n+        feature = \"int_error_matching\",\n+        reason = \"it can be useful to match errors when making error messages \\\n+                  for integer parsing\",\n+        issue = \"22639\"\n+    )]\n     pub fn kind(&self) -> &IntErrorKind {\n         &self.kind\n     }\n-    #[unstable(feature = \"int_error_internals\",\n-               reason = \"available through Error trait and this method should \\\n-                         not be exposed publicly\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"0\"\n+    )]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n         match self.kind {\n@@ -5122,199 +4920,3 @@ impl fmt::Display for ParseIntError {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::num::dec2flt::ParseFloatError;\n-\n-// Conversion traits for primitive integer and float types\n-// Conversions T -> T are covered by a blanket impl and therefore excluded\n-// Some conversions from and to usize/isize are not implemented due to portability concerns\n-macro_rules! impl_from {\n-    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n-        #[$attr]\n-        #[doc = $doc]\n-        impl From<$Small> for $Large {\n-            #[inline]\n-            fn from(small: $Small) -> $Large {\n-                small as $Large\n-            }\n-        }\n-    };\n-    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n-        impl_from!($Small,\n-                   $Large,\n-                   #[$attr],\n-                   concat!(\"Converts `\",\n-                           stringify!($Small),\n-                           \"` to `\",\n-                           stringify!($Large),\n-                           \"` losslessly.\"));\n-    }\n-}\n-\n-macro_rules! impl_from_bool {\n-    ($target: ty, #[$attr:meta]) => {\n-        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n-            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n-values.\n-\n-# Examples\n-\n-```\n-assert_eq!(\", stringify!($target), \"::from(true), 1);\n-assert_eq!(\", stringify!($target), \"::from(false), 0);\n-```\"));\n-    };\n-}\n-\n-// Bool -> Any\n-impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-\n-// Unsigned -> Unsigned\n-impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Signed -> Signed\n-impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Unsigned -> Signed\n-impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n-// which imply that pointer-sized integers must be at least 16 bits:\n-// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n-impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-\n-// RISC-V defines the possibility of a 128-bit address space (RV128).\n-\n-// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n-// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n-// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n-\n-\n-// Note: integers can only be represented with full precision in a float if\n-// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n-// Lossy float conversions are not implemented at this time.\n-\n-// Signed -> Float\n-impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Unsigned -> Float\n-impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Float -> Float\n-impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Conversion traits for non-zero integer types\n-macro_rules! nzint_impl_from {\n-    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n-        #[$attr]\n-        #[doc = $doc]\n-        impl From<$Small> for $Large {\n-            #[inline]\n-            fn from(small: $Small) -> $Large {\n-                // SAFETY: input type guarantees the value is non-zero\n-                unsafe {\n-                    <$Large>::new_unchecked(small.get().into())\n-                }\n-            }\n-        }\n-    };\n-    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n-        nzint_impl_from!($Small,\n-                   $Large,\n-                   #[$attr],\n-                   concat!(\"Converts `\",\n-                           stringify!($Small),\n-                           \"` to `\",\n-                           stringify!($Large),\n-                           \"` losslessly.\"));\n-    }\n-}\n-\n-// Non-zero Unsigned -> Non-zero Unsigned\n-nzint_impl_from! { NonZeroU8, NonZeroU16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU8, NonZeroU32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU8, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU8, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU8, NonZeroUsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU16, NonZeroU32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU16, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU16, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU16, NonZeroUsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU32, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU32, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU64, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-\n-// Non-zero Signed -> Non-zero Signed\n-nzint_impl_from! { NonZeroI8, NonZeroI16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI8, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI8, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI8, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI8, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI16, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI16, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI16, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI16, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI32, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI32, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroI64, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-\n-// NonZero UnSigned -> Non-zero Signed\n-nzint_impl_from! { NonZeroU8, NonZeroI16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU8, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU8, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU8, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU8, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU16, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU16, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU16, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU32, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU32, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n-nzint_impl_from! { NonZeroU64, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }"}, {"sha": "0ddfbd02aa5b02250b453f8d5e31dc10da69130a", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -4,7 +4,7 @@ use crate::ops::*;\n \n #[allow(unused_macros)]\n macro_rules! sh_impl_signed {\n-    ($t:ident, $f:ident) => (\n+    ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -19,7 +19,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -44,7 +44,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -54,11 +54,11 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n-    )\n+    };\n }\n \n macro_rules! sh_impl_unsigned {\n-    ($t:ident, $f:ident) => (\n+    ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -69,7 +69,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -90,7 +90,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -100,7 +100,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n-    )\n+    };\n }\n \n // FIXME (#23545): uncomment the remaining impls"}, {"sha": "59a72799e256726e20dbf7728f4c94298269d7d9", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -66,19 +66,13 @@\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    on(\n-        all(_Self=\"{integer}\", Rhs=\"{float}\"),\n-        message=\"cannot add a float to an integer\",\n-    ),\n-    on(\n-        all(_Self=\"{float}\", Rhs=\"{integer}\"),\n-        message=\"cannot add an integer to a float\",\n-    ),\n-    message=\"cannot add `{Rhs}` to `{Self}`\",\n-    label=\"no implementation for `{Self} + {Rhs}`\",\n+    on(all(_Self = \"{integer}\", Rhs = \"{float}\"), message = \"cannot add a float to an integer\",),\n+    on(all(_Self = \"{float}\", Rhs = \"{integer}\"), message = \"cannot add an integer to a float\",),\n+    message = \"cannot add `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} + {Rhs}`\"\n )]\n #[doc(alias = \"+\")]\n-pub trait Add<Rhs=Self> {\n+pub trait Add<Rhs = Self> {\n     /// The resulting type after applying the `+` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -173,10 +167,12 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot subtract `{Rhs}` from `{Self}`\",\n-                         label=\"no implementation for `{Self} - {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot subtract `{Rhs}` from `{Self}`\",\n+    label = \"no implementation for `{Self} - {Rhs}`\"\n+)]\n #[doc(alias = \"-\")]\n-pub trait Sub<Rhs=Self> {\n+pub trait Sub<Rhs = Self> {\n     /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -293,10 +289,12 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot multiply `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} * {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot multiply `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} * {Rhs}`\"\n+)]\n #[doc(alias = \"*\")]\n-pub trait Mul<Rhs=Self> {\n+pub trait Mul<Rhs = Self> {\n     /// The resulting type after applying the `*` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -417,10 +415,12 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot divide `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} / {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot divide `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} / {Rhs}`\"\n+)]\n #[doc(alias = \"/\")]\n-pub trait Div<Rhs=Self> {\n+pub trait Div<Rhs = Self> {\n     /// The resulting type after applying the `/` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -502,10 +502,12 @@ div_impl_float! { f32 f64 }\n /// ```\n #[lang = \"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot mod `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} % {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot mod `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} % {Rhs}`\"\n+)]\n #[doc(alias = \"%\")]\n-pub trait Rem<Rhs=Self> {\n+pub trait Rem<Rhs = Self> {\n     /// The resulting type after applying the `%` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -534,7 +536,6 @@ macro_rules! rem_impl_integer {\n \n rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-\n macro_rules! rem_impl_float {\n     ($($t:ty)*) => ($(\n \n@@ -616,8 +617,6 @@ pub trait Neg {\n     fn neg(self) -> Self::Output;\n }\n \n-\n-\n macro_rules! neg_impl_core {\n     ($id:ident => $body:expr, $($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -679,11 +678,13 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"add_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot add-assign `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} += {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot add-assign `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} += {Rhs}`\"\n+)]\n #[doc(alias = \"+\")]\n #[doc(alias = \"+=\")]\n-pub trait AddAssign<Rhs=Self> {\n+pub trait AddAssign<Rhs = Self> {\n     /// Performs the `+=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn add_assign(&mut self, rhs: Rhs);\n@@ -735,11 +736,13 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"sub_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot subtract-assign `{Rhs}` from `{Self}`\",\n-                         label=\"no implementation for `{Self} -= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot subtract-assign `{Rhs}` from `{Self}`\",\n+    label = \"no implementation for `{Self} -= {Rhs}`\"\n+)]\n #[doc(alias = \"-\")]\n #[doc(alias = \"-=\")]\n-pub trait SubAssign<Rhs=Self> {\n+pub trait SubAssign<Rhs = Self> {\n     /// Performs the `-=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn sub_assign(&mut self, rhs: Rhs);\n@@ -782,11 +785,13 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"mul_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot multiply-assign `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} *= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot multiply-assign `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} *= {Rhs}`\"\n+)]\n #[doc(alias = \"*\")]\n #[doc(alias = \"*=\")]\n-pub trait MulAssign<Rhs=Self> {\n+pub trait MulAssign<Rhs = Self> {\n     /// Performs the `*=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn mul_assign(&mut self, rhs: Rhs);\n@@ -829,11 +834,13 @@ mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"div_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot divide-assign `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} /= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot divide-assign `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} /= {Rhs}`\"\n+)]\n #[doc(alias = \"/\")]\n #[doc(alias = \"/=\")]\n-pub trait DivAssign<Rhs=Self> {\n+pub trait DivAssign<Rhs = Self> {\n     /// Performs the `/=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn div_assign(&mut self, rhs: Rhs);\n@@ -879,11 +886,13 @@ div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"rem_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot mod-assign `{Self}` by `{Rhs}``\",\n-                         label=\"no implementation for `{Self} %= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot mod-assign `{Self}` by `{Rhs}``\",\n+    label = \"no implementation for `{Self} %= {Rhs}`\"\n+)]\n #[doc(alias = \"%\")]\n #[doc(alias = \"%=\")]\n-pub trait RemAssign<Rhs=Self> {\n+pub trait RemAssign<Rhs = Self> {\n     /// Performs the `%=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn rem_assign(&mut self, rhs: Rhs);"}, {"sha": "bcfff4a223bec7b63fad2b0f3d96c00dae05c9bc", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -112,9 +112,11 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitand\"]\n #[doc(alias = \"&\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} & {Rhs}`\",\n-                         label=\"no implementation for `{Self} & {Rhs}`\")]\n-pub trait BitAnd<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} & {Rhs}`\",\n+    label = \"no implementation for `{Self} & {Rhs}`\"\n+)]\n+pub trait BitAnd<Rhs = Self> {\n     /// The resulting type after applying the `&` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -196,9 +198,11 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitor\"]\n #[doc(alias = \"|\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} | {Rhs}`\",\n-                         label=\"no implementation for `{Self} | {Rhs}`\")]\n-pub trait BitOr<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} | {Rhs}`\",\n+    label = \"no implementation for `{Self} | {Rhs}`\"\n+)]\n+pub trait BitOr<Rhs = Self> {\n     /// The resulting type after applying the `|` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -283,9 +287,11 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitxor\"]\n #[doc(alias = \"^\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} ^ {Rhs}`\",\n-                         label=\"no implementation for `{Self} ^ {Rhs}`\")]\n-pub trait BitXor<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} ^ {Rhs}`\",\n+    label = \"no implementation for `{Self} ^ {Rhs}`\"\n+)]\n+pub trait BitXor<Rhs = Self> {\n     /// The resulting type after applying the `^` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -371,9 +377,11 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"shl\"]\n #[doc(alias = \"<<\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} << {Rhs}`\",\n-                         label=\"no implementation for `{Self} << {Rhs}`\")]\n-pub trait Shl<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} << {Rhs}`\",\n+    label = \"no implementation for `{Self} << {Rhs}`\"\n+)]\n+pub trait Shl<Rhs = Self> {\n     /// The resulting type after applying the `<<` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -385,7 +393,7 @@ pub trait Shl<Rhs=Self> {\n }\n \n macro_rules! shl_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for $t {\n             type Output = $t;\n@@ -398,7 +406,7 @@ macro_rules! shl_impl {\n         }\n \n         forward_ref_binop! { impl Shl, shl for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shl_impl_all {\n@@ -480,9 +488,11 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n #[lang = \"shr\"]\n #[doc(alias = \">>\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} >> {Rhs}`\",\n-                         label=\"no implementation for `{Self} >> {Rhs}`\")]\n-pub trait Shr<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} >> {Rhs}`\",\n+    label = \"no implementation for `{Self} >> {Rhs}`\"\n+)]\n+pub trait Shr<Rhs = Self> {\n     /// The resulting type after applying the `>>` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -494,7 +504,7 @@ pub trait Shr<Rhs=Self> {\n }\n \n macro_rules! shr_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shr<$f> for $t {\n             type Output = $t;\n@@ -507,7 +517,7 @@ macro_rules! shr_impl {\n         }\n \n         forward_ref_binop! { impl Shr, shr for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shr_impl_all {\n@@ -596,9 +606,11 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n #[lang = \"bitand_assign\"]\n #[doc(alias = \"&=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} &= {Rhs}`\",\n-                         label=\"no implementation for `{Self} &= {Rhs}`\")]\n-pub trait BitAndAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} &= {Rhs}`\",\n+    label = \"no implementation for `{Self} &= {Rhs}`\"\n+)]\n+pub trait BitAndAssign<Rhs = Self> {\n     /// Performs the `&=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, rhs: Rhs);\n@@ -645,9 +657,11 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitor_assign\"]\n #[doc(alias = \"|=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} |= {Rhs}`\",\n-                         label=\"no implementation for `{Self} |= {Rhs}`\")]\n-pub trait BitOrAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} |= {Rhs}`\",\n+    label = \"no implementation for `{Self} |= {Rhs}`\"\n+)]\n+pub trait BitOrAssign<Rhs = Self> {\n     /// Performs the `|=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitor_assign(&mut self, rhs: Rhs);\n@@ -694,9 +708,11 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitxor_assign\"]\n #[doc(alias = \"^=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} ^= {Rhs}`\",\n-                         label=\"no implementation for `{Self} ^= {Rhs}`\")]\n-pub trait BitXorAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} ^= {Rhs}`\",\n+    label = \"no implementation for `{Self} ^= {Rhs}`\"\n+)]\n+pub trait BitXorAssign<Rhs = Self> {\n     /// Performs the `^=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitxor_assign(&mut self, rhs: Rhs);\n@@ -741,16 +757,18 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"shl_assign\"]\n #[doc(alias = \"<<=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} <<= {Rhs}`\",\n-                         label=\"no implementation for `{Self} <<= {Rhs}`\")]\n-pub trait ShlAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} <<= {Rhs}`\",\n+    label = \"no implementation for `{Self} <<= {Rhs}`\"\n+)]\n+pub trait ShlAssign<Rhs = Self> {\n     /// Performs the `<<=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shl_assign(&mut self, rhs: Rhs);\n }\n \n macro_rules! shl_assign_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for $t {\n             #[inline]\n@@ -761,7 +779,7 @@ macro_rules! shl_assign_impl {\n         }\n \n         forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shl_assign_impl_all {\n@@ -809,16 +827,18 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n #[lang = \"shr_assign\"]\n #[doc(alias = \">>=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} >>= {Rhs}`\",\n-                         label=\"no implementation for `{Self} >>= {Rhs}`\")]\n-pub trait ShrAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} >>= {Rhs}`\",\n+    label = \"no implementation for `{Self} >>= {Rhs}`\"\n+)]\n+pub trait ShrAssign<Rhs = Self> {\n     /// Performs the `>>=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shr_assign(&mut self, rhs: Rhs);\n }\n \n macro_rules! shr_assign_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for $t {\n             #[inline]\n@@ -829,7 +849,7 @@ macro_rules! shr_assign_impl {\n         }\n \n         forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shr_assign_impl_all {"}, {"sha": "f521355a90722a07ae2c57d1eae8f29dab72e480", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -76,14 +76,18 @@ pub trait Deref {\n impl<T: ?Sized> Deref for &T {\n     type Target = T;\n \n-    fn deref(&self) -> &T { *self }\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for &mut T {\n     type Target = T;\n \n-    fn deref(&self) -> &T { *self }\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n }\n \n /// Used for mutable dereferencing operations, like in `*v = 1;`.\n@@ -165,7 +169,9 @@ pub trait DerefMut: Deref {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for &mut T {\n-    fn deref_mut(&mut self) -> &mut T { *self }\n+    fn deref_mut(&mut self) -> &mut T {\n+        *self\n+    }\n }\n \n /// Indicates that a struct can be used as a method receiver, without the"}, {"sha": "505a65cee3de0265f5f0047395b656805e4ee33a", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -57,13 +57,16 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n-    message=\"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `Fn<{Args}>` closure, found `{Self}`\",\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+    ),\n+    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-pub trait Fn<Args> : FnMut<Args> {\n+pub trait Fn<Args>: FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n@@ -136,17 +139,16 @@ pub trait Fn<Args> : FnMut<Args> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n     on(\n-        all(Args=\"(char,)\", _Self=\"std::string::String\"),\n-        note=\"borrowing the `{Self}` might fix the problem\"\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n     ),\n-    message=\"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `FnMut<{Args}>` closure, found `{Self}`\",\n+    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-pub trait FnMut<Args> : FnOnce<Args> {\n+pub trait FnMut<Args>: FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n@@ -211,9 +213,12 @@ pub trait FnMut<Args> : FnOnce<Args> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n-    message=\"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `FnOnce<{Args}>` closure, found `{Self}`\",\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+    ),\n+    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n@@ -229,26 +234,29 @@ pub trait FnOnce<Args> {\n \n mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> Fn<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> Fn<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnMut<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> FnMut<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnOnce<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> FnOnce<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         type Output = F::Output;\n \n@@ -258,17 +266,19 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnMut<A> for &mut F\n-        where F : FnMut<A>\n+    impl<A, F: ?Sized> FnMut<A> for &mut F\n+    where\n+        F: FnMut<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (*self).call_mut(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnOnce<A> for &mut F\n-        where F : FnMut<A>\n+    impl<A, F: ?Sized> FnOnce<A> for &mut F\n+    where\n+        F: FnMut<A>,\n     {\n         type Output = F::Output;\n         extern \"rust-call\" fn call_once(self, args: A) -> F::Output {"}, {"sha": "aae0691122415ce4d3d766b294a026314da048db", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -51,8 +51,8 @@\n /// ```\n #[lang = \"index\"]\n #[rustc_on_unimplemented(\n-    message=\"the type `{Self}` cannot be indexed by `{Idx}`\",\n-    label=\"`{Self}` cannot be indexed by `{Idx}`\",\n+    message = \"the type `{Self}` cannot be indexed by `{Idx}`\",\n+    label = \"`{Self}` cannot be indexed by `{Idx}`\"\n )]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"]\")]\n@@ -142,22 +142,22 @@ pub trait Index<Idx: ?Sized> {\n #[lang = \"index_mut\"]\n #[rustc_on_unimplemented(\n     on(\n-        _Self=\"&str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"&str\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n     on(\n-        _Self=\"str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"str\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n     on(\n-        _Self=\"std::string::String\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"std::string::String\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n-    message=\"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n-    label=\"`{Self}` cannot be mutably indexed by `{Idx}`\",\n+    message = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n+    label = \"`{Self}` cannot be mutably indexed by `{Idx}`\"\n )]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"[\")]"}, {"sha": "80ab906961ee79b5f344bdbb221d98831e9f5fad", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -156,12 +156,12 @@ mod r#try;\n mod unsize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::arith::{Add, Sub, Mul, Div, Rem, Neg};\n+pub use self::arith::{Add, Div, Mul, Neg, Rem, Sub};\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-pub use self::arith::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+pub use self::arith::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::bit::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+pub use self::bit::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n \n@@ -184,7 +184,7 @@ pub use self::index::{Index, IndexMut};\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-pub use self::range::{RangeInclusive, RangeToInclusive, RangeBounds, Bound};\n+pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n \n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::r#try::Try;"}, {"sha": "a2250337a4dcab131b63c2c3590e2d535f0490c4", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -399,11 +399,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[inline]\n     #[rustc_promotable]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self {\n-            start,\n-            end,\n-            is_empty: None,\n-        }\n+        Self { start, end, is_empty: None }\n     }\n \n     /// Returns the lower bound of the range (inclusive)."}, {"sha": "a748ee87ef99aa7ff915a872092522b2a7c35d33", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -5,27 +5,15 @@\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-#[cfg_attr(bootstrap, rustc_on_unimplemented(\n-   on(all(\n-       any(from_method=\"from_error\", from_method=\"from_ok\"),\n-       from_desugaring=\"QuestionMark\"),\n-      message=\"the `?` operator can only be used in a \\\n-               function that returns `Result` or `Option` \\\n-               (or another type that implements `{Try}`)\",\n-      label=\"cannot use the `?` operator in a function that returns `{Self}`\"),\n-   on(all(from_method=\"into_result\", from_desugaring=\"QuestionMark\"),\n-      message=\"the `?` operator can only be applied to values \\\n-               that implement `{Try}`\",\n-      label=\"the `?` operator cannot be applied to type `{Self}`\")\n-))]\n #[cfg_attr(not(bootstrap), rustc_on_unimplemented(\n on(all(\n any(from_method=\"from_error\", from_method=\"from_ok\"),\n from_desugaring=\"QuestionMark\"),\n message=\"the `?` operator can only be used in {ItemContext} \\\n                that returns `Result` or `Option` \\\n                (or another type that implements `{Try}`)\",\n-label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\"),\n+label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\n+enclosing_scope=\"this function should return `Result` or `Option` to accept `?`\"),\n on(all(from_method=\"into_result\", from_desugaring=\"QuestionMark\"),\n message=\"the `?` operator can only be applied to values \\\n                that implement `{Try}`\","}, {"sha": "80fb5642a6a76d87228ab661fb03659858ca879a", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -39,35 +39,34 @@ pub trait CoerceUnsized<T: ?Sized> {\n \n // &mut T -> &mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n // &mut T -> &U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n // &mut T -> *mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n // &mut T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n \n // &T -> &U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n // &T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n \n // *mut T -> *mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n // *mut T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n // *const T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n-\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n \n /// This is used for object safety, to check that a method's receiver type can be dispatched on.\n ///\n@@ -90,13 +89,13 @@ pub trait DispatchFromDyn<T> {\n \n // &T -> &U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n // &mut T -> &mut U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n // *const T -> *const U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n // *mut T -> *mut U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}"}, {"sha": "2066a484dac8091a3a294227c15093dca5e4d403", "filename": "src/libcore/option.rs", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -138,8 +138,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n-use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n+use crate::{\n+    convert, fmt, hint, mem,\n+    ops::{self, Deref, DerefMut},\n+};\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -230,7 +233,10 @@ impl<T> Option<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n-    pub fn contains<U>(&self, x: &U) -> bool where U: PartialEq<T> {\n+    pub fn contains<U>(&self, x: &U) -> bool\n+    where\n+        U: PartialEq<T>,\n+    {\n         match self {\n             Some(y) => x == y,\n             None => false,\n@@ -291,16 +297,13 @@ impl<T> Option<T> {\n         }\n     }\n \n-\n     /// Converts from [`Pin`]`<&Option<T>>` to `Option<`[`Pin`]`<&T>>`.\n     ///\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n-        unsafe {\n-            Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n-        }\n+        unsafe { Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x)) }\n     }\n \n     /// Converts from [`Pin`]`<&mut Option<T>>` to `Option<`[`Pin`]`<&mut T>>`.\n@@ -309,9 +312,7 @@ impl<T> Option<T> {\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n-        unsafe {\n-            Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x))\n-        }\n+        unsafe { Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x)) }\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n@@ -690,7 +691,7 @@ impl<T> Option<T> {\n     pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n         if let Some(x) = self {\n             if predicate(&x) {\n-                return Some(x)\n+                return Some(x);\n             }\n         }\n         None\n@@ -1228,7 +1229,9 @@ impl<T> Default for Option<T> {\n     /// assert!(opt.is_none());\n     /// ```\n     #[inline]\n-    fn default() -> Option<T> { None }\n+    fn default() -> Option<T> {\n+        None\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1302,7 +1305,7 @@ impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n \n #[derive(Clone, Debug)]\n struct Item<A> {\n-    opt: Option<A>\n+    opt: Option<A>,\n }\n \n impl<A> Iterator for Item<A> {\n@@ -1344,22 +1347,30 @@ unsafe impl<A> TrustedLen for Item<A> {}\n /// [`Option::iter`]: enum.Option.html#method.iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n+pub struct Iter<'a, A: 'a> {\n+    inner: Item<&'a A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n+    fn next(&mut self) -> Option<&'a A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<&'a A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1390,22 +1401,30 @@ impl<A> Clone for Iter<'_, A> {\n /// [`Option::iter_mut`]: enum.Option.html#method.iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n+pub struct IterMut<'a, A: 'a> {\n+    inner: Item<&'a mut A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n+    fn next(&mut self) -> Option<&'a mut A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<&'a mut A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1427,22 +1446,30 @@ unsafe impl<A> TrustedLen for IterMut<'_, A> {}\n /// [`Option::into_iter`]: enum.Option.html#method.into_iter\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<A> { inner: Item<A> }\n+pub struct IntoIter<A> {\n+    inner: Item<A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.inner.next() }\n+    fn next(&mut self) -> Option<A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1523,14 +1550,11 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     ///\n     /// [`Iterator`]: ../iter/trait.Iterator.html\n     #[inline]\n-    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {\n+    fn from_iter<I: IntoIterator<Item = Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        iter.into_iter()\n-            .map(|x| x.ok_or(()))\n-            .collect::<Result<_, _>>()\n-            .ok()\n+        iter.into_iter().map(|x| x.ok_or(())).collect::<Result<_, _>>().ok()\n     }\n }\n "}, {"sha": "e924ee2036988781481131303e75f4fa1ae18330", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -167,7 +167,7 @@ impl fmt::Display for PanicInfo<'_> {\n ///\n /// panic!(\"Normal panic\");\n /// ```\n-#[cfg_attr(not(bootstrap), lang = \"panic_location\")]\n+#[lang = \"panic_location\"]\n #[derive(Debug)]\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub struct Location<'a> {\n@@ -176,6 +176,60 @@ pub struct Location<'a> {\n     col: u32,\n }\n \n+impl<'a> Location<'a> {\n+    /// Returns the source location of the caller of this function. If that function's caller is\n+    /// annotated then its call location will be returned, and so on up the stack to the first call\n+    /// within a non-tracked function body.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(track_caller)]\n+    /// use core::panic::Location;\n+    ///\n+    /// /// Returns the [`Location`] at which it is called.\n+    /// #[track_caller]\n+    /// fn get_caller_location() -> &'static Location<'static> {\n+    ///     Location::caller()\n+    /// }\n+    ///\n+    /// /// Returns a [`Location`] from within this function's definition.\n+    /// fn get_just_one_location() -> &'static Location<'static> {\n+    ///     get_caller_location()\n+    /// }\n+    ///\n+    /// let fixed_location = get_just_one_location();\n+    /// assert_eq!(fixed_location.file(), file!());\n+    /// assert_eq!(fixed_location.line(), 15);\n+    /// assert_eq!(fixed_location.column(), 5);\n+    ///\n+    /// // running the same untracked function in a different location gives us the same result\n+    /// let second_fixed_location = get_just_one_location();\n+    /// assert_eq!(fixed_location.file(), second_fixed_location.file());\n+    /// assert_eq!(fixed_location.line(), second_fixed_location.line());\n+    /// assert_eq!(fixed_location.column(), second_fixed_location.column());\n+    ///\n+    /// let this_location = get_caller_location();\n+    /// assert_eq!(this_location.file(), file!());\n+    /// assert_eq!(this_location.line(), 29);\n+    /// assert_eq!(this_location.column(), 21);\n+    ///\n+    /// // running the tracked function in a different location produces a different value\n+    /// let another_location = get_caller_location();\n+    /// assert_eq!(this_location.file(), another_location.file());\n+    /// assert_ne!(this_location.line(), another_location.line());\n+    /// assert_ne!(this_location.column(), another_location.column());\n+    /// ```\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"track_caller\",\n+               reason = \"uses #[track_caller] which is not yet stable\",\n+               issue = \"47809\")]\n+    #[track_caller]\n+    pub const fn caller() -> &'static Location<'static> {\n+        crate::intrinsics::caller_location()\n+    }\n+}\n+\n impl<'a> Location<'a> {\n     #![unstable(feature = \"panic_internals\",\n                 reason = \"internal details of the implementation of the `panic!` \\\n@@ -266,6 +320,16 @@ impl fmt::Display for Location<'_> {\n #[unstable(feature = \"std_internals\", issue = \"0\")]\n #[doc(hidden)]\n pub unsafe trait BoxMeUp {\n-    fn box_me_up(&mut self) -> *mut (dyn Any + Send);\n+    /// Take full ownership of the contents.\n+    /// The return type is actually `Box<dyn Any + Send>`, but we cannot use `Box` in libcore.\n+    ///\n+    /// After this method got called, only some dummy default value is left in `self`.\n+    /// Calling this method twice, or calling `get` after calling this method, is an error.\n+    ///\n+    /// The argument is borrowed because the panic runtime (`__rust_start_panic`) only\n+    /// gets a borrowed `dyn BoxMeUp`.\n+    fn take_box(&mut self) -> *mut (dyn Any + Send);\n+\n+    /// Just borrow the contents.\n     fn get(&mut self) -> &(dyn Any + Send);\n }"}, {"sha": "5a8d647396ddab6b3f5512f0d35e69b43332b355", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 8, "deletions": 67, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -6,19 +6,18 @@\n //! interface for panicking is:\n //!\n //! ```\n-//! # use std::fmt;\n-//! fn panic_impl(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> !\n+//! fn panic_impl(pi: &core::panic::PanicInfo<'_>) -> !\n //! # { loop {} }\n //! ```\n //!\n //! This definition allows for panicking with any general message, but it does not\n-//! allow for failing with a `Box<Any>` value. The reason for this is that libcore\n-//! is not allowed to allocate.\n+//! allow for failing with a `Box<Any>` value. (`PanicInfo` just contains a `&(dyn Any + Send)`,\n+//! for which we fill in a dummy value in `PanicInfo::internal_constructor`.)\n+//! The reason for this is that libcore is not allowed to allocate.\n //!\n //! This module contains a few other panicking functions, but these are just the\n //! necessary lang items for the compiler. All panics are funneled through this\n-//! one function. Currently, the actual symbol is declared in the standard\n-//! library, but the location of this may change over time.\n+//! one function. The actual symbol is declared through the `#[panic_handler]` attribute.\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -31,33 +30,11 @@\n use crate::fmt;\n use crate::panic::{Location, PanicInfo};\n \n-#[cfg(bootstrap)]\n #[cold]\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n #[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n-#[lang = \"panic\"]\n-pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n-    if cfg!(feature = \"panic_immediate_abort\") {\n-        unsafe { super::intrinsics::abort() }\n-    }\n-\n-    // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n-    // reduce size overhead. The format_args! macro uses str's Display trait to\n-    // write expr, which calls Formatter::pad, which must accommodate string\n-    // truncation and padding (even though none is used here). Using\n-    // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n-    // output binary, saving up to a few kilobytes.\n-    let (expr, file, line, col) = *expr_file_line_col;\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line, col))\n-}\n-\n-#[cfg(not(bootstrap))]\n-#[cold]\n-// never inline unless panic_immediate_abort to avoid code\n-// bloat at the call sites as much as possible\n-#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n-#[lang = \"panic\"]\n+#[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { super::intrinsics::abort() }\n@@ -72,24 +49,9 @@ pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n     panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), location)\n }\n \n-#[cfg(bootstrap)]\n-#[cold]\n-#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n-#[lang = \"panic_bounds_check\"]\n-fn panic_bounds_check(file_line_col: &(&'static str, u32, u32),\n-                     index: usize, len: usize) -> ! {\n-    if cfg!(feature = \"panic_immediate_abort\") {\n-        unsafe { super::intrinsics::abort() }\n-    }\n-\n-    panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n-                           len, index), file_line_col)\n-}\n-\n-#[cfg(not(bootstrap))]\n #[cold]\n #[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n-#[lang = \"panic_bounds_check\"]\n+#[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { super::intrinsics::abort() }\n@@ -101,28 +63,6 @@ fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n     )\n }\n \n-#[cfg(bootstrap)]\n-#[cold]\n-#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n-#[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n-pub fn panic_fmt(fmt: fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u32)) -> ! {\n-    if cfg!(feature = \"panic_immediate_abort\") {\n-        unsafe { super::intrinsics::abort() }\n-    }\n-\n-    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n-    extern \"Rust\" {\n-        #[lang = \"panic_impl\"]\n-        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n-    }\n-\n-    let (file, line, col) = *file_line_col;\n-    let location = Location::internal_constructor(file, line, col);\n-    let pi = PanicInfo::internal_constructor(Some(&fmt), &location);\n-    unsafe { panic_impl(&pi) }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[cold]\n #[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n #[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n@@ -132,6 +72,7 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n     }\n \n     // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+    // that gets resolved to the `#[panic_handler]` function.\n     extern \"Rust\" {\n         #[lang = \"panic_impl\"]\n         fn panic_impl(pi: &PanicInfo<'_>) -> !;"}, {"sha": "88fa718ae9e62c37cb5ff890cf62c23c0fbb98ec", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -374,10 +374,10 @@\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n \n+use crate::cmp::{self, PartialEq, PartialOrd};\n use crate::fmt;\n use crate::marker::{Sized, Unpin};\n-use crate::cmp::{self, PartialEq, PartialOrd};\n-use crate::ops::{Deref, DerefMut, Receiver, CoerceUnsized, DispatchFromDyn};\n+use crate::ops::{CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Receiver};\n \n /// A pinned pointer.\n ///\n@@ -646,7 +646,8 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U> where\n+    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>\n+    where\n         F: FnOnce(&T) -> &U,\n     {\n         let pointer = &*self.pointer;\n@@ -698,7 +699,8 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn get_mut(self) -> &'a mut T\n-        where T: Unpin,\n+    where\n+        T: Unpin,\n     {\n         self.pointer\n     }\n@@ -735,7 +737,8 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U> where\n+    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>\n+    where\n         F: FnOnce(&mut T) -> &mut U,\n     {\n         let pointer = Pin::get_unchecked_mut(self);\n@@ -789,13 +792,7 @@ impl<P: fmt::Pointer> fmt::Pointer for Pin<P> {\n // for other reasons, though, so we just need to take care not to allow such\n // impls to land in std.\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<P, U> CoerceUnsized<Pin<U>> for Pin<P>\n-where\n-    P: CoerceUnsized<U>,\n-{}\n+impl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P>\n-where\n-    P: DispatchFromDyn<U>,\n-{}\n+impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}"}, {"sha": "66b5a90b77b919f6f6a1c894e3f185e2a64a5de2", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -25,25 +25,25 @@ pub use crate::mem::drop;\n pub use crate::clone::Clone;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::cmp::{PartialEq, PartialOrd, Eq, Ord};\n+pub use crate::cmp::{Eq, Ord, PartialEq, PartialOrd};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::convert::{AsRef, AsMut, Into, From};\n+pub use crate::convert::{AsMut, AsRef, From, Into};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use crate::default::Default;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{Iterator, Extend, IntoIterator};\n+pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n+pub use crate::iter::{Extend, IntoIterator, Iterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::option::Option::{self, Some, None};\n+pub use crate::option::Option::{self, None, Some};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::result::Result::{self, Ok, Err};\n+pub use crate::result::Result::{self, Err, Ok};\n \n // Re-exported built-in macros\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n@@ -56,37 +56,14 @@ pub use crate::hash::macros::Hash;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::{\n-    asm,\n-    assert,\n-    cfg,\n-    column,\n-    compile_error,\n-    concat,\n-    concat_idents,\n-    env,\n-    file,\n-    format_args,\n-    format_args_nl,\n-    global_asm,\n-    include,\n-    include_bytes,\n-    include_str,\n-    line,\n-    log_syntax,\n-    module_path,\n-    option_env,\n-    stringify,\n-    trace_macros,\n+    asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n+    format_args_nl, global_asm, include, include_bytes, include_str, line, log_syntax, module_path,\n+    option_env, stringify, trace_macros,\n };\n \n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n #[doc(no_inline)]\n pub use crate::macros::builtin::{\n-    RustcDecodable,\n-    RustcEncodable,\n-    bench,\n-    global_allocator,\n-    test,\n-    test_case,\n+    bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n };"}, {"sha": "1e051dbebcaf82519fce4f8ff3cced23daffe80f", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1074,17 +1074,22 @@ impl<T: ?Sized> *const T {\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n     ///\n-    /// When calling this method, you have to ensure that if the pointer is\n-    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n-    /// size of `T`) and points to an initialized instance of `T`. This applies\n-    /// even if the result of this method is unused!\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    /// - it is properly aligned\n+    /// - it must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n     /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. It is up to the\n-    /// caller to ensure that for the duration of this lifetime, the memory this\n-    /// pointer points to does not get written to outside of `UnsafeCell<U>`.\n+    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n+    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n+    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// [here]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -1301,7 +1306,6 @@ impl<T: ?Sized> *const T {\n     /// }\n     /// ```\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n-    #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\")]\n     #[inline]\n     pub const unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n@@ -1313,21 +1317,6 @@ impl<T: ?Sized> *const T {\n         intrinsics::ptr_offset_from(self, origin)\n     }\n \n-    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n-    #[inline]\n-    #[cfg(bootstrap)]\n-    /// bootstrap\n-    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n-        let pointee_size = mem::size_of::<T>();\n-        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n-\n-        // This is the same sequence that Clang emits for pointer subtraction.\n-        // It can be neither `nsw` nor `nuw` because the input is treated as\n-        // unsigned but then the output is treated as signed, so neither works.\n-        let d = isize::wrapping_sub(self as _, origin as _);\n-        intrinsics::exact_div(d, pointee_size as _)\n-    }\n-\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///\n@@ -1945,18 +1934,23 @@ impl<T: ?Sized> *mut T {\n     /// of the returned pointer, nor can it ensure that the lifetime `'a`\n     /// returned is indeed a valid lifetime for the contained data.\n     ///\n-    /// When calling this method, you have to ensure that if the pointer is\n-    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n-    /// size of `T`) and points to an initialized instance of `T`. This applies\n-    /// even if the result of this method is unused!\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    /// - it is properly aligned\n+    /// - it must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is the only safe approach is to ensure that they are indeed initialized.)\n     ///\n     /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. It is up to the\n-    /// caller to ensure that for the duration of this lifetime, the memory this\n-    /// pointer points to does not get accessed through any other pointer.\n+    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n+    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n+    /// the memory this pointer points to must not get accessed (read or written)\n+    /// through any other pointer.\n     ///\n+    /// [here]: crate::ptr#safety\n     /// [`as_ref`]: #method.as_ref\n     ///\n     /// # Examples"}, {"sha": "a121389bef3c9e5ad0bdfc56d963601fa7cc9b44", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,11 +1,11 @@\n+use crate::cmp::Ordering;\n use crate::convert::From;\n-use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::fmt;\n use crate::hash;\n use crate::marker::Unsize;\n use crate::mem;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n-use crate::cmp::Ordering;\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -48,12 +48,12 @@ pub struct NonNull<T: ?Sized> {\n /// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n // N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Send for NonNull<T> { }\n+impl<T: ?Sized> !Send for NonNull<T> {}\n \n /// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n // N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Sync for NonNull<T> { }\n+impl<T: ?Sized> !Sync for NonNull<T> {}\n \n impl<T: Sized> NonNull<T> {\n     /// Creates a new `NonNull` that is dangling, but well-aligned.\n@@ -91,11 +91,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        if !ptr.is_null() {\n-            Some(unsafe { Self::new_unchecked(ptr) })\n-        } else {\n-            None\n-        }\n+        if !ptr.is_null() { Some(unsafe { Self::new_unchecked(ptr) }) } else { None }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n@@ -131,9 +127,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> NonNull<U> {\n-        unsafe {\n-            NonNull::new_unchecked(self.as_ptr() as *mut U)\n-        }\n+        unsafe { NonNull::new_unchecked(self.as_ptr() as *mut U) }\n     }\n }\n \n@@ -146,13 +140,13 @@ impl<T: ?Sized> Clone for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Copy for NonNull<T> { }\n+impl<T: ?Sized> Copy for NonNull<T> {}\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> fmt::Debug for NonNull<T> {"}, {"sha": "546b7c9d777f59c39c99cc67a10d062192656afb", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,8 +1,8 @@\n use crate::convert::From;\n-use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::fmt;\n use crate::marker::{PhantomData, Unsize};\n use crate::mem;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::NonNull;\n \n // ignore-tidy-undocumented-unsafe\n@@ -27,9 +27,12 @@ use crate::ptr::NonNull;\n ///\n /// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n /// for any type which upholds Unique's aliasing requirements.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\",\n-           reason = \"use `NonNull` instead and consider `PhantomData<T>` \\\n-                     (if you also use `#[may_dangle]`), `Send`, and/or `Sync`\")]\n+#[unstable(\n+    feature = \"ptr_internals\",\n+    issue = \"0\",\n+    reason = \"use `NonNull` instead and consider `PhantomData<T>` \\\n+              (if you also use `#[may_dangle]`), `Send`, and/or `Sync`\"\n+)]\n #[doc(hidden)]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n@@ -48,14 +51,14 @@ pub struct Unique<T: ?Sized> {\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n+unsafe impl<T: Send + ?Sized> Send for Unique<T> {}\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n+unsafe impl<T: Sync + ?Sized> Sync for Unique<T> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: Sized> Unique<T> {\n@@ -71,9 +74,7 @@ impl<T: Sized> Unique<T> {\n     // FIXME: rename to dangling() to match NonNull?\n     #[inline]\n     pub const fn empty() -> Self {\n-        unsafe {\n-            Unique::new_unchecked(mem::align_of::<T>() as *mut T)\n-        }\n+        unsafe { Unique::new_unchecked(mem::align_of::<T>() as *mut T) }\n     }\n }\n \n@@ -128,9 +129,7 @@ impl<T: ?Sized> Unique<T> {\n     /// Casts to a pointer of another type.\n     #[inline]\n     pub const fn cast<U>(self) -> Unique<U> {\n-        unsafe {\n-            Unique::new_unchecked(self.as_ptr() as *mut U)\n-        }\n+        unsafe { Unique::new_unchecked(self.as_ptr() as *mut U) }\n     }\n }\n \n@@ -143,13 +142,13 @@ impl<T: ?Sized> Clone for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Copy for Unique<T> { }\n+impl<T: ?Sized> Copy for Unique<T> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> fmt::Debug for Unique<T> {"}, {"sha": "1a0845f3a6dda5a16fd84bd873ee6fc8f8ae6273", "filename": "src/libcore/result.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -514,6 +514,28 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n+    /// Applies a function to the contained value (if any),\n+    /// or returns the provided default (if not).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_map_or)]\n+    /// let x: Result<_, &str> = Ok(\"foo\");\n+    /// assert_eq!(x.map_or(42, |v| v.len()), 3);\n+    ///\n+    /// let x: Result<&str, _> = Err(\"bar\");\n+    /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_map_or\", issue = \"66293\")]\n+    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n+        match self {\n+            Ok(t) => f(t),\n+            Err(_) => default,\n+        }\n+    }\n+\n     /// Maps a `Result<T, E>` to `U` by applying a function to a\n     /// contained [`Ok`] value, or a fallback function to a\n     /// contained [`Err`] value.\n@@ -529,7 +551,6 @@ impl<T, E> Result<T, E> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(result_map_or_else)]\n     /// let k = 21;\n     ///\n     /// let x : Result<_, &str> = Ok(\"foo\");\n@@ -539,9 +560,12 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.map_or_else(|e| k * 2, |v| v.len()), 42);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"result_map_or_else\", issue = \"53268\")]\n-    pub fn map_or_else<U, M: FnOnce(T) -> U, F: FnOnce(E) -> U>(self, fallback: F, map: M) -> U {\n-        self.map(map).unwrap_or_else(fallback)\n+    #[stable(feature = \"result_map_or_else\", since = \"1.41.0\")]\n+    pub fn map_or_else<U, D: FnOnce(E) -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {\n+        match self {\n+            Ok(t) => f(t),\n+            Err(e) => default(e),\n+        }\n     }\n \n     /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a"}, {"sha": "019832e16f89cd20d25f6c508c55d5bfa081e72f", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 73, "deletions": 51, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -20,13 +20,16 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n-        unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n+        unsafe {\n+            ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+        }\n     }\n }\n \n /// Shifts the first element to the right until it encounters a greater or equal element.\n fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     unsafe {\n@@ -36,10 +39,7 @@ fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n             let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n-            let mut hole = CopyOnDrop {\n-                src: &mut *tmp,\n-                dest: v.get_unchecked_mut(1),\n-            };\n+            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.get_unchecked_mut(1) };\n             ptr::copy_nonoverlapping(v.get_unchecked(1), v.get_unchecked_mut(0), 1);\n \n             for i in 2..len {\n@@ -58,7 +58,8 @@ fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n \n /// Shifts the last element to the left until it encounters a smaller or equal element.\n fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     unsafe {\n@@ -68,13 +69,10 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n             let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n-            let mut hole = CopyOnDrop {\n-                src: &mut *tmp,\n-                dest: v.get_unchecked_mut(len - 2),\n-            };\n+            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.get_unchecked_mut(len - 2) };\n             ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);\n \n-            for i in (0..len-2).rev() {\n+            for i in (0..len - 2).rev() {\n                 if !is_less(&*tmp, v.get_unchecked(i)) {\n                     break;\n                 }\n@@ -93,7 +91,8 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n /// Returns `true` if the slice is sorted at the end. This function is `O(n)` worst-case.\n #[cold]\n fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Maximum number of adjacent out-of-order pairs that will get shifted.\n     const MAX_STEPS: usize = 5;\n@@ -136,17 +135,19 @@ fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n \n /// Sorts a slice using insertion sort, which is `O(n^2)` worst-case.\n fn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     for i in 1..v.len() {\n-        shift_tail(&mut v[..i+1], is_less);\n+        shift_tail(&mut v[..i + 1], is_less);\n     }\n }\n \n /// Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n #[cold]\n pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // This binary heap respects the invariant `parent >= child`.\n     let mut sift_down = |v: &mut [T], mut node| {\n@@ -156,11 +157,8 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n             let right = 2 * node + 2;\n \n             // Choose the greater child.\n-            let greater = if right < v.len() && is_less(&v[left], &v[right]) {\n-                right\n-            } else {\n-                left\n-            };\n+            let greater =\n+                if right < v.len() && is_less(&v[left], &v[right]) { right } else { left };\n \n             // Stop if the invariant holds at `node`.\n             if greater >= v.len() || !is_less(&v[node], &v[greater]) {\n@@ -174,12 +172,12 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n     };\n \n     // Build the heap in linear time.\n-    for i in (0 .. v.len() / 2).rev() {\n+    for i in (0..v.len() / 2).rev() {\n         sift_down(v, i);\n     }\n \n     // Pop maximal elements from the heap.\n-    for i in (1 .. v.len()).rev() {\n+    for i in (1..v.len()).rev() {\n         v.swap(0, i);\n         sift_down(&mut v[..i], 0);\n     }\n@@ -195,7 +193,8 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n ///\n /// [pdf]: http://drops.dagstuhl.de/opus/volltexte/2016/6389/pdf/LIPIcs-ESA-2016-38.pdf\n fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Number of elements in a typical block.\n     const BLOCK: usize = 128;\n@@ -298,8 +297,16 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n         let count = cmp::min(width(start_l, end_l), width(start_r, end_r));\n \n         if count > 0 {\n-            macro_rules! left { () => { l.offset(*start_l as isize) } }\n-            macro_rules! right { () => { r.offset(-(*start_r as isize) - 1) } }\n+            macro_rules! left {\n+                () => {\n+                    l.offset(*start_l as isize)\n+                };\n+            }\n+            macro_rules! right {\n+                () => {\n+                    r.offset(-(*start_r as isize) - 1)\n+                };\n+            }\n \n             // Instead of swapping one pair at the time, it is more efficient to perform a cyclic\n             // permutation. This is not strictly equivalent to swapping, but produces a similar\n@@ -379,7 +386,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n /// 1. Number of elements smaller than `v[pivot]`.\n /// 2. True if `v` was already partitioned.\n fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let (mid, was_partitioned) = {\n         // Place the pivot at the beginning of slice.\n@@ -390,10 +398,7 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n         // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n         // operation panics, the pivot will be automatically written back into the slice.\n         let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-        let _pivot_guard = CopyOnDrop {\n-            src: &mut *tmp,\n-            dest: pivot,\n-        };\n+        let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n         let pivot = &*tmp;\n \n         // Find the first pair of out-of-order elements.\n@@ -429,7 +434,8 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n /// Returns the number of elements equal to the pivot. It is assumed that `v` does not contain\n /// elements smaller than the pivot.\n fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Place the pivot at the beginning of slice.\n     v.swap(0, pivot);\n@@ -439,10 +445,7 @@ fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n     let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-    let _pivot_guard = CopyOnDrop {\n-        src: &mut *tmp,\n-        dest: pivot,\n-    };\n+    let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n     let pivot = &*tmp;\n \n     // Now partition the slice.\n@@ -528,7 +531,8 @@ fn break_patterns<T>(v: &mut [T]) {\n ///\n /// Elements in `v` might be reordered in the process.\n fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Minimum length to choose the median-of-medians method.\n     // Shorter slices use the simple median-of-three method.\n@@ -596,7 +600,8 @@ fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n /// `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n /// this function will immediately switch to heapsort.\n fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: usize)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 20;\n@@ -650,7 +655,7 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n                 let mid = partition_equal(v, pivot, is_less);\n \n                 // Continue sorting elements greater than the pivot.\n-                v = &mut {v}[mid..];\n+                v = &mut { v }[mid..];\n                 continue;\n             }\n         }\n@@ -661,7 +666,7 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n         was_partitioned = was_p;\n \n         // Split the slice into `left`, `pivot`, and `right`.\n-        let (left, right) = {v}.split_at_mut(mid);\n+        let (left, right) = { v }.split_at_mut(mid);\n         let (pivot, right) = right.split_at_mut(1);\n         let pivot = &pivot[0];\n \n@@ -681,7 +686,8 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n \n /// Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\n pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Sorting has no meaningful behavior on zero-sized types.\n     if mem::size_of::<T>() == 0 {\n@@ -694,8 +700,13 @@ pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n     recurse(v, &mut is_less, None, limit);\n }\n \n-fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_less: &mut F\n-                                    , mut pred: Option<&'a T>) where F: FnMut(&T, &T) -> bool\n+fn partition_at_index_loop<'a, T, F>(\n+    mut v: &'a mut [T],\n+    mut index: usize,\n+    is_less: &mut F,\n+    mut pred: Option<&'a T>,\n+) where\n+    F: FnMut(&T, &T) -> bool,\n {\n     loop {\n         // For slices of up to this length it's probably faster to simply sort them.\n@@ -731,7 +742,7 @@ fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_l\n         let (mid, _) = partition(v, pivot, is_less);\n \n         // Split the slice into `left`, `pivot`, and `right`.\n-        let (left, right) = {v}.split_at_mut(mid);\n+        let (left, right) = { v }.split_at_mut(mid);\n         let (pivot, right) = right.split_at_mut(1);\n         let pivot = &pivot[0];\n \n@@ -749,11 +760,16 @@ fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_l\n     }\n }\n \n-pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n-                                -> (&mut [T], &mut T, &mut [T]) where F: FnMut(&T, &T) -> bool\n+pub fn partition_at_index<T, F>(\n+    v: &mut [T],\n+    index: usize,\n+    mut is_less: F,\n+) -> (&mut [T], &mut T, &mut [T])\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n-    use cmp::Ordering::Less;\n     use cmp::Ordering::Greater;\n+    use cmp::Ordering::Less;\n \n     if index >= v.len() {\n         panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n@@ -764,14 +780,20 @@ pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n     } else if index == v.len() - 1 {\n         // Find max element and place it in the last position of the array. We're free to use\n         // `unwrap()` here because we know v must not be empty.\n-        let (max_index, _) = v.iter().enumerate().max_by(\n-            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        let (max_index, _) = v\n+            .iter()\n+            .enumerate()\n+            .max_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n+            .unwrap();\n         v.swap(max_index, index);\n     } else if index == 0 {\n         // Find min element and place it in the first position of the array. We're free to use\n         // `unwrap()` here because we know v must not be empty.\n-        let (min_index, _) = v.iter().enumerate().min_by(\n-            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        let (min_index, _) = v\n+            .iter()\n+            .enumerate()\n+            .min_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n+            .unwrap();\n         v.swap(min_index, index);\n     } else {\n         partition_at_index_loop(v, index, &mut is_less, None);"}, {"sha": "b2a420f3c43778cc06d992c62dbaaa89410f931a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -3371,8 +3371,8 @@ impl str {\n     /// An iterator over the disjoint matches of a pattern within the given string\n     /// slice.\n     ///\n-    /// The pattern can be any type that implements the Pattern trait. Notable\n-    /// examples are `&str`, [`char`], and closures that determines the split.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n     ///\n     /// # Iterator behavior\n     ///"}, {"sha": "6e1aac00c7bc5401e536dcba652394b4afb6428e", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 104, "deletions": 36, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -27,7 +27,7 @@\n //!\n //! Atomic variables are safe to share between threads (they implement [`Sync`])\n //! but they do not themselves provide the mechanism for sharing and follow the\n-//! [threading model](../../../std/thread/index.html#the-threading-model) of rust.\n+//! [threading model](../../../std/thread/index.html#the-threading-model) of Rust.\n //! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n //! atomically-reference-counted shared pointer).\n //!\n@@ -162,14 +162,14 @@ pub fn spin_loop_hint() {\n /// This type has the same in-memory representation as a [`bool`].\n ///\n /// [`bool`]: ../../../std/primitive.bool.html\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(C, align(1))]\n pub struct AtomicBool {\n     v: UnsafeCell<u8>,\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n     /// Creates an `AtomicBool` initialized to `false`.\n@@ -179,14 +179,14 @@ impl Default for AtomicBool {\n }\n \n // Send is implicitly implemented for AtomicBool.\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Sync for AtomicBool {}\n \n /// A raw pointer type which can be safely shared between threads.\n ///\n /// This type has the same in-memory representation as a `*mut T`.\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n #[cfg_attr(target_pointer_width = \"32\", repr(C, align(4)))]\n@@ -195,7 +195,7 @@ pub struct AtomicPtr<T> {\n     p: UnsafeCell<*mut T>,\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n     /// Creates a null `AtomicPtr<T>`.\n@@ -204,10 +204,10 @@ impl<T> Default for AtomicPtr<T> {\n     }\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for AtomicPtr<T> {}\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n@@ -308,7 +308,7 @@ pub enum Ordering {\n /// An [`AtomicBool`] initialized to `false`.\n ///\n /// [`AtomicBool`]: struct.AtomicBool.html\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(\n     since = \"1.34.0\",\n@@ -317,7 +317,7 @@ pub enum Ordering {\n )]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n     ///\n@@ -802,9 +802,46 @@ impl AtomicBool {\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n+\n+    /// Returns a mutable pointer to the underlying [`bool`].\n+    ///\n+    /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n+    /// This method is mostly useful for FFI, where the function signature may use\n+    /// `*mut bool` instead of `&AtomicBool`.\n+    ///\n+    /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n+    /// atomic types work with interior mutability. All modifications of an atomic change the value\n+    /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n+    /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n+    /// restriction: operations on it must be atomic.\n+    ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (extern-declaration)\n+    /// # fn main() {\n+    /// use std::sync::atomic::AtomicBool;\n+    /// extern {\n+    ///     fn my_atomic_op(arg: *mut bool);\n+    /// }\n+    ///\n+    /// let mut atomic = AtomicBool::new(true);\n+    /// unsafe {\n+    ///     my_atomic_op(atomic.as_mut_ptr());\n+    /// }\n+    /// # }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_mut_ptr\",\n+           reason = \"recently added\",\n+           issue = \"66893\")]\n+    pub fn as_mut_ptr(&self) -> *mut bool {\n+        self.v.get() as *mut bool\n+    }\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n impl<T> AtomicPtr<T> {\n     /// Creates a new `AtomicPtr`.\n     ///\n@@ -1114,7 +1151,7 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n impl From<bool> for AtomicBool {\n     /// Converts a `bool` into an `AtomicBool`.\n@@ -1130,14 +1167,14 @@ impl From<bool> for AtomicBool {\n     fn from(b: bool) -> Self { Self::new(b) }\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n impl<T> From<*mut T> for AtomicPtr<T> {\n     #[inline]\n     fn from(p: *mut T) -> Self { Self::new(p) }\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n macro_rules! atomic_int {\n     ($cfg_cas:meta,\n      $stable:meta,\n@@ -1891,11 +1928,48 @@ assert_eq!(min_foo, 12);\n                 }\n             }\n \n+            doc_comment! {\n+                concat!(\"Returns a mutable pointer to the underlying integer.\n+\n+Doing non-atomic reads and writes on the resulting integer can be a data race.\n+This method is mostly useful for FFI, where the function signature may use\n+`*mut \", stringify!($int_type), \"` instead of `&\", stringify!($atomic_type), \"`.\n+\n+Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n+atomic types work with interior mutability. All modifications of an atomic change the value\n+through a shared reference, and can do so safely as long as they use atomic operations. Any\n+use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n+restriction: operations on it must be atomic.\n+\n+# Examples\n+\n+```ignore (extern-declaration)\n+# fn main() {\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+extern {\n+    fn my_atomic_op(arg: *mut \", stringify!($int_type), \");\n+}\n+\n+let mut atomic = \", stringify!($atomic_type), \"::new(1);\n+unsafe {\n+    my_atomic_op(atomic.as_mut_ptr());\n+}\n+# }\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_mut_ptr\",\n+                       reason = \"recently added\",\n+                       issue = \"66893\")]\n+                pub fn as_mut_ptr(&self) -> *mut $int_type {\n+                    self.v.get()\n+                }\n+            }\n         }\n     }\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n atomic_int! {\n     cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1912,7 +1986,7 @@ atomic_int! {\n     \"AtomicI8::new(0)\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n atomic_int! {\n     cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1929,7 +2003,7 @@ atomic_int! {\n     \"AtomicU8::new(0)\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n+#[cfg(target_has_atomic_load_store = \"16\")]\n atomic_int! {\n     cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1946,7 +2020,7 @@ atomic_int! {\n     \"AtomicI16::new(0)\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n+#[cfg(target_has_atomic_load_store = \"16\")]\n atomic_int! {\n     cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1963,7 +2037,7 @@ atomic_int! {\n     \"AtomicU16::new(0)\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n+#[cfg(target_has_atomic_load_store = \"32\")]\n atomic_int! {\n     cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1980,7 +2054,7 @@ atomic_int! {\n     \"AtomicI32::new(0)\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n+#[cfg(target_has_atomic_load_store = \"32\")]\n atomic_int! {\n     cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1997,10 +2071,7 @@ atomic_int! {\n     \"AtomicU32::new(0)\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n-#[cfg(any(\n-    all(bootstrap, target_has_atomic = \"64\"),\n-    target_has_atomic_load_store = \"64\"\n-))]\n+#[cfg(target_has_atomic_load_store = \"64\")]\n atomic_int! {\n     cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2017,10 +2088,7 @@ atomic_int! {\n     \"AtomicI64::new(0)\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n-#[cfg(any(\n-    all(bootstrap, target_has_atomic = \"64\"),\n-    target_has_atomic_load_store = \"64\"\n-))]\n+#[cfg(target_has_atomic_load_store = \"64\")]\n atomic_int! {\n     cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2071,22 +2139,22 @@ atomic_int! {\n     \"AtomicU128::new(0)\",\n     u128 AtomicU128 ATOMIC_U128_INIT\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[cfg(target_pointer_width = \"16\")]\n macro_rules! ptr_width {\n     () => { 2 }\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[cfg(target_pointer_width = \"32\")]\n macro_rules! ptr_width {\n     () => { 4 }\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[cfg(target_pointer_width = \"64\")]\n macro_rules! ptr_width {\n     () => { 8 }\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n atomic_int!{\n     cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n@@ -2103,7 +2171,7 @@ atomic_int!{\n     \"AtomicIsize::new(0)\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n atomic_int!{\n     cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n@@ -2530,23 +2598,23 @@ pub fn compiler_fence(order: Ordering) {\n }\n \n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl fmt::Debug for AtomicBool {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\n impl<T> fmt::Pointer for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "27760749c1d4b63ddca3afbf14d25da6d2c5ef3e", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -8,4 +8,4 @@ pub use self::poll::Poll;\n \n mod wake;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-pub use self::wake::{Context, Waker, RawWaker, RawWakerVTable};\n+pub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};"}, {"sha": "d567ae545774ef56726de81f2a55c2ac3bb3be96", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -11,10 +11,7 @@ use crate::result::Result;\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-    Ready(\n-        #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-        T\n-    ),\n+    Ready(#[stable(feature = \"futures_api\", since = \"1.36.0\")] T),\n \n     /// Represents that a value is not ready yet.\n     ///\n@@ -29,7 +26,8 @@ impl<T> Poll<T> {\n     /// Changes the ready value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(t) => Poll::Ready(f(t)),\n@@ -59,7 +57,8 @@ impl<T, E> Poll<Result<T, E>> {\n     /// Changes the success value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(Ok(t)) => Poll::Ready(Ok(f(t))),\n@@ -71,7 +70,8 @@ impl<T, E> Poll<Result<T, E>> {\n     /// Changes the error value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n-        where F: FnOnce(E) -> U\n+    where\n+        F: FnOnce(E) -> U,\n     {\n         match self {\n             Poll::Ready(Ok(t)) => Poll::Ready(Ok(t)),\n@@ -85,7 +85,8 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     /// Changes the success value of this `Poll` with the closure provided.\n     #[unstable(feature = \"poll_map\", issue = \"63514\")]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(f(t)))),\n@@ -98,7 +99,8 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     /// Changes the error value of this `Poll` with the closure provided.\n     #[unstable(feature = \"poll_map\", issue = \"63514\")]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n-        where F: FnOnce(E) -> U\n+    where\n+        F: FnOnce(E) -> U,\n     {\n         match self {\n             Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(t))),"}, {"sha": "0759ff93ea85f0da49acb9f346068da1b0622a83", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -40,10 +40,7 @@ impl RawWaker {\n     #[rustc_promotable]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n-        RawWaker {\n-            data,\n-            vtable,\n-        }\n+        RawWaker { data, vtable }\n     }\n }\n \n@@ -160,12 +157,7 @@ impl RawWakerVTable {\n         wake_by_ref: unsafe fn(*const ()),\n         drop: unsafe fn(*const ()),\n     ) -> Self {\n-        Self {\n-            clone,\n-            wake,\n-            wake_by_ref,\n-            drop,\n-        }\n+        Self { clone, wake, wake_by_ref, drop }\n     }\n }\n \n@@ -188,10 +180,7 @@ impl<'a> Context<'a> {\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     #[inline]\n     pub fn from_waker(waker: &'a Waker) -> Self {\n-        Context {\n-            waker,\n-            _marker: PhantomData,\n-        }\n+        Context { waker, _marker: PhantomData }\n     }\n \n     /// Returns a reference to the `Waker` for the current task.\n@@ -205,9 +194,7 @@ impl<'a> Context<'a> {\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl fmt::Debug for Context<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Context\")\n-            .field(\"waker\", &self.waker)\n-            .finish()\n+        f.debug_struct(\"Context\").field(\"waker\", &self.waker).finish()\n     }\n }\n \n@@ -291,9 +278,7 @@ impl Waker {\n     #[inline]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub unsafe fn from_raw(waker: RawWaker) -> Waker {\n-        Waker {\n-            waker,\n-        }\n+        Waker { waker }\n     }\n }\n "}, {"sha": "e89eb2c7f94d5731a04e320de4427c0dc4d2af68", "filename": "src/libcore/tests/bool.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftests%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftests%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fbool.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,7 +1,7 @@\n #[test]\n fn test_bool_to_option() {\n-    assert_eq!(false.then(0), None);\n-    assert_eq!(true.then(0), Some(0));\n-    assert_eq!(false.then_with(|| 0), None);\n-    assert_eq!(true.then_with(|| 0), Some(0));\n+    assert_eq!(false.then_some(0), None);\n+    assert_eq!(true.then_some(0), Some(0));\n+    assert_eq!(false.then(|| 0), None);\n+    assert_eq!(true.then(|| 0), Some(0));\n }"}, {"sha": "50a3ec046ad1374a52f8c6fdeafb50a881ef14cf", "filename": "src/libcore/tests/num/bignum.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,4 +1,3 @@\n-use std::prelude::v1::*;\n use core::num::bignum::tests::Big8x3 as Big;\n \n #[test]"}, {"sha": "f85369ce40b8db256f8e48e450561ffbc144048a", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,4 +1,3 @@\n-use std::prelude::v1::*;\n use std::{str, i16, f32, f64, fmt};\n \n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};"}, {"sha": "0c545b4d88714f3d34f50502fc6720fa611f8657", "filename": "src/libcore/tests/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,4 +1,3 @@\n-use std::prelude::v1::*;\n use super::super::*;\n use core::num::bignum::Big32x40 as Big;\n use core::num::flt2dec::strategy::dragon::*;"}, {"sha": "70ec1e42fd71b6981d27c8c02e2e0ee4fd198f07", "filename": "src/libcore/time.rs", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -12,9 +12,9 @@\n //! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n //! ```\n \n-use crate::{fmt, u64};\n use crate::iter::Sum;\n-use crate::ops::{Add, Sub, Mul, Div, AddAssign, SubAssign, MulAssign, DivAssign};\n+use crate::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+use crate::{fmt, u64};\n \n const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;\n@@ -131,8 +131,8 @@ impl Duration {\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn new(secs: u64, nanos: u32) -> Duration {\n-        let secs = secs.checked_add((nanos / NANOS_PER_SEC) as u64)\n-            .expect(\"overflow in Duration::new\");\n+        let secs =\n+            secs.checked_add((nanos / NANOS_PER_SEC) as u64).expect(\"overflow in Duration::new\");\n         let nanos = nanos % NANOS_PER_SEC;\n         Duration { secs, nanos }\n     }\n@@ -252,7 +252,9 @@ impl Duration {\n     /// [`subsec_nanos`]: #method.subsec_nanos\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n-    pub const fn as_secs(&self) -> u64 { self.secs }\n+    pub const fn as_secs(&self) -> u64 {\n+        self.secs\n+    }\n \n     /// Returns the fractional part of this `Duration`, in whole milliseconds.\n     ///\n@@ -271,7 +273,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n     #[inline]\n-    pub const fn subsec_millis(&self) -> u32 { self.nanos / NANOS_PER_MILLI }\n+    pub const fn subsec_millis(&self) -> u32 {\n+        self.nanos / NANOS_PER_MILLI\n+    }\n \n     /// Returns the fractional part of this `Duration`, in whole microseconds.\n     ///\n@@ -290,7 +294,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n     #[inline]\n-    pub const fn subsec_micros(&self) -> u32 { self.nanos / NANOS_PER_MICRO }\n+    pub const fn subsec_micros(&self) -> u32 {\n+        self.nanos / NANOS_PER_MICRO\n+    }\n \n     /// Returns the fractional part of this `Duration`, in nanoseconds.\n     ///\n@@ -309,7 +315,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n-    pub const fn subsec_nanos(&self) -> u32 { self.nanos }\n+    pub const fn subsec_nanos(&self) -> u32 {\n+        self.nanos\n+    }\n \n     /// Returns the total number of whole milliseconds contained by this `Duration`.\n     ///\n@@ -388,10 +396,7 @@ impl Duration {\n                 }\n             }\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration {\n-                secs,\n-                nanos,\n-            })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }\n@@ -455,14 +460,11 @@ impl Duration {\n         let total_nanos = self.nanos as u64 * rhs as u64;\n         let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n         let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n-        if let Some(secs) = self.secs\n-            .checked_mul(rhs as u64)\n-            .and_then(|s| s.checked_add(extra_secs)) {\n+        if let Some(secs) =\n+            self.secs.checked_mul(rhs as u64).and_then(|s| s.checked_add(extra_secs))\n+        {\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration {\n-                secs,\n-                nanos,\n-            })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }\n@@ -549,9 +551,8 @@ impl Duration {\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n     pub fn from_secs_f64(secs: f64) -> Duration {\n-        const MAX_NANOS_F64: f64 =\n-            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n-        let nanos =  secs * (NANOS_PER_SEC as f64);\n+        const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f64;\n+        let nanos = secs * (NANOS_PER_SEC as f64);\n         if !nanos.is_finite() {\n             panic!(\"got non-finite value when converting float to duration\");\n         }\n@@ -561,7 +562,7 @@ impl Duration {\n         if nanos < 0.0 {\n             panic!(\"underflow when converting float to duration\");\n         }\n-        let nanos =  nanos as u128;\n+        let nanos = nanos as u128;\n         Duration {\n             secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n             nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n@@ -584,9 +585,8 @@ impl Duration {\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n     pub fn from_secs_f32(secs: f32) -> Duration {\n-        const MAX_NANOS_F32: f32 =\n-            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f32;\n-        let nanos =  secs * (NANOS_PER_SEC as f32);\n+        const MAX_NANOS_F32: f32 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f32;\n+        let nanos = secs * (NANOS_PER_SEC as f32);\n         if !nanos.is_finite() {\n             panic!(\"got non-finite value when converting float to duration\");\n         }\n@@ -596,7 +596,7 @@ impl Duration {\n         if nanos < 0.0 {\n             panic!(\"underflow when converting float to duration\");\n         }\n-        let nanos =  nanos as u128;\n+        let nanos = nanos as u128;\n         Duration {\n             secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n             nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n@@ -799,9 +799,8 @@ macro_rules! sum_durations {\n         let mut total_nanos: u64 = 0;\n \n         for entry in $iter {\n-            total_secs = total_secs\n-                .checked_add(entry.secs)\n-                .expect(\"overflow in iter::sum over durations\");\n+            total_secs =\n+                total_secs.checked_add(entry.secs).expect(\"overflow in iter::sum over durations\");\n             total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n                 Some(n) => n,\n                 None => {\n@@ -816,23 +815,20 @@ macro_rules! sum_durations {\n             .checked_add(total_nanos / NANOS_PER_SEC as u64)\n             .expect(\"overflow in iter::sum over durations\");\n         total_nanos = total_nanos % NANOS_PER_SEC as u64;\n-        Duration {\n-            secs: total_secs,\n-            nanos: total_nanos as u32,\n-        }\n+        Duration { secs: total_secs, nanos: total_nanos as u32 }\n     }};\n }\n \n #[stable(feature = \"duration_sum\", since = \"1.16.0\")]\n impl Sum for Duration {\n-    fn sum<I: Iterator<Item=Duration>>(iter: I) -> Duration {\n+    fn sum<I: Iterator<Item = Duration>>(iter: I) -> Duration {\n         sum_durations!(iter)\n     }\n }\n \n #[stable(feature = \"duration_sum\", since = \"1.16.0\")]\n impl<'a> Sum<&'a Duration> for Duration {\n-    fn sum<I: Iterator<Item=&'a Duration>>(iter: I) -> Duration {\n+    fn sum<I: Iterator<Item = &'a Duration>>(iter: I) -> Duration {\n         sum_durations!(iter)\n     }\n }\n@@ -922,9 +918,7 @@ impl fmt::Debug for Duration {\n             } else {\n                 // SAFETY: We are only writing ASCII digits into the buffer and it was\n                 // initialized with '0's, so it contains valid UTF8.\n-                let s = unsafe {\n-                    crate::str::from_utf8_unchecked(&buf[..end])\n-                };\n+                let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n \n                 // If the user request a precision > 9, we pad '0's at the end.\n                 let w = f.precision().unwrap_or(pos);"}, {"sha": "9f8a3a1de420116d50f89d515f9930d8120ac44c", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,7 +1,7 @@\n // See src/libstd/primitive_docs.rs for documentation.\n \n-use crate::cmp::*;\n use crate::cmp::Ordering::*;\n+use crate::cmp::*;\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {"}, {"sha": "b7fba88a540f9012dbc01efd9b5758d86e30709d", "filename": "src/libcore/unicode/bool_trie.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Fbool_trie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Fbool_trie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fbool_trie.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -19,16 +19,16 @@\n /// non-BMP range of most Unicode sets.\n pub struct BoolTrie {\n     // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n-    pub r1: [u64; 32],   // leaves\n+    pub r1: [u64; 32], // leaves\n \n     // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n     pub r2: [u8; 992],      // first level\n-    pub r3: &'static [u64],  // leaves\n+    pub r3: &'static [u64], // leaves\n \n     // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n-    pub r4: [u8; 256],       // first level\n-    pub r5: &'static [u8],   // second level\n-    pub r6: &'static [u64],  // leaves\n+    pub r4: [u8; 256],      // first level\n+    pub r5: &'static [u8],  // second level\n+    pub r6: &'static [u64], // leaves\n }\n impl BoolTrie {\n     pub fn lookup(&self, c: char) -> bool {\n@@ -48,7 +48,7 @@ impl BoolTrie {\n \n pub struct SmallBoolTrie {\n     pub(crate) r1: &'static [u8],  // first level\n-    pub(crate) r2: &'static [u64],  // leaves\n+    pub(crate) r2: &'static [u64], // leaves\n }\n \n impl SmallBoolTrie {"}, {"sha": "91db6381c9b6670ccc5a69e29feeac257cb017c5", "filename": "src/libcore/unicode/printable.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Fprintable.py", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Fprintable.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.py?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -111,16 +111,19 @@ def compress_normal(normal):\n     return compressed\n \n def print_singletons(uppers, lowers, uppersname, lowersname):\n+    print(\"#[rustfmt::skip]\")\n     print(\"const {}: &[(u8, u8)] = &[\".format(uppersname))\n     for u, c in uppers:\n         print(\"    ({:#04x}, {}),\".format(u, c))\n     print(\"];\")\n+    print(\"#[rustfmt::skip]\")\n     print(\"const {}: &[u8] = &[\".format(lowersname))\n     for i in range(0, len(lowers), 8):\n         print(\"    {}\".format(\" \".join(\"{:#04x},\".format(l) for l in lowers[i:i+8])))\n     print(\"];\")\n \n def print_normal(normal, normalname):\n+    print(\"#[rustfmt::skip]\")\n     print(\"const {}: &[u8] = &[\".format(normalname))\n     for v in normal:\n         print(\"    {}\".format(\" \".join(\"{:#04x},\".format(i) for i in v)))\n@@ -170,8 +173,7 @@ def main():\n // NOTE: The following code was generated by \"src/libcore/unicode/printable.py\",\n //       do not edit directly!\n \n-fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n-         normal: &[u8]) -> bool {\n+fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8], normal: &[u8]) -> bool {\n     let xupper = (x >> 8) as u8;\n     let mut lowerstart = 0;\n     for &(upper, lowercount) in singletonuppers {"}, {"sha": "eee9ea52ef0d2e2387c8d6ef43c0682e6f2b8454", "filename": "src/libcore/unicode/printable.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Fprintable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Fprintable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,8 +1,7 @@\n // NOTE: The following code was generated by \"src/libcore/unicode/printable.py\",\n //       do not edit directly!\n \n-fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n-         normal: &[u8]) -> bool {\n+fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8], normal: &[u8]) -> bool {\n     let xupper = (x >> 8) as u8;\n     let mut lowerstart = 0;\n     for &(upper, lowercount) in singletonuppers {\n@@ -70,6 +69,7 @@ pub(crate) fn is_printable(x: char) -> bool {\n     }\n }\n \n+#[rustfmt::skip]\n const SINGLETONS0U: &[(u8, u8)] = &[\n     (0x00, 1),\n     (0x03, 5),\n@@ -113,6 +113,7 @@ const SINGLETONS0U: &[(u8, u8)] = &[\n     (0xfe, 3),\n     (0xff, 9),\n ];\n+#[rustfmt::skip]\n const SINGLETONS0L: &[u8] = &[\n     0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n     0x58, 0x8b, 0x8c, 0x90, 0x1c, 0x1d, 0xdd, 0x0e,\n@@ -152,6 +153,7 @@ const SINGLETONS0L: &[u8] = &[\n     0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9, 0xd0, 0xd1,\n     0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n ];\n+#[rustfmt::skip]\n const SINGLETONS1U: &[(u8, u8)] = &[\n     (0x00, 6),\n     (0x01, 1),\n@@ -189,6 +191,7 @@ const SINGLETONS1U: &[(u8, u8)] = &[\n     (0xf9, 6),\n     (0xfa, 2),\n ];\n+#[rustfmt::skip]\n const SINGLETONS1L: &[u8] = &[\n     0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n     0x9e, 0x9f, 0x06, 0x07, 0x09, 0x36, 0x3d, 0x3e,\n@@ -212,6 +215,7 @@ const SINGLETONS1L: &[u8] = &[\n     0xa4, 0xaa, 0xaf, 0xb0, 0xc0, 0xd0, 0x0c, 0x72,\n     0xa3, 0xa4, 0xcb, 0xcc, 0x6e, 0x6f,\n ];\n+#[rustfmt::skip]\n const NORMAL0: &[u8] = &[\n     0x00, 0x20,\n     0x5f, 0x22,\n@@ -355,6 +359,7 @@ const NORMAL0: &[u8] = &[\n     0x1b, 0x03,\n     0x0f, 0x0d,\n ];\n+#[rustfmt::skip]\n const NORMAL1: &[u8] = &[\n     0x5e, 0x22,\n     0x7b, 0x05,"}, {"sha": "3fa125e8fea15fc9921ce35af4660c76554f619c", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -2,19 +2,16 @@\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case, clippy::unreadable_literal)]\n \n-use crate::unicode::version::UnicodeVersion;\n use crate::unicode::bool_trie::{BoolTrie, SmallBoolTrie};\n+use crate::unicode::version::UnicodeVersion;\n \n /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n /// `char` and `str` methods are based on.\n #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n-    major: 12,\n-    minor: 1,\n-    micro: 0,\n-    _priv: (),\n-};\n+pub const UNICODE_VERSION: UnicodeVersion =\n+    UnicodeVersion { major: 12, minor: 1, micro: 0, _priv: () };\n pub(crate) mod general_category {\n+    #[rustfmt::skip]\n     const Cc_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 0\n@@ -28,6 +25,7 @@ pub(crate) mod general_category {\n         Cc_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const N_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x03ff000000000000, 0x0000000000000000, 0x720c000000000000, 0x0000000000000000,\n@@ -138,10 +136,10 @@ pub(crate) mod general_category {\n     pub fn N(c: char) -> bool {\n         N_table.lookup(c)\n     }\n-\n }\n \n pub(crate) mod derived_property {\n+    #[rustfmt::skip]\n     const Alphabetic_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n@@ -327,6 +325,7 @@ pub(crate) mod derived_property {\n         Alphabetic_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Case_Ignorable_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0400408000000000, 0x0000000140000000, 0x0190a10000000000, 0x0000000000000000,\n@@ -464,6 +463,7 @@ pub(crate) mod derived_property {\n         Case_Ignorable_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Cased_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n@@ -565,6 +565,7 @@ pub(crate) mod derived_property {\n         Cased_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Grapheme_Extend_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -689,6 +690,7 @@ pub(crate) mod derived_property {\n         Grapheme_Extend_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Lowercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe00000000, 0x0420040000000000, 0xff7fffff80000000,\n@@ -789,6 +791,7 @@ pub(crate) mod derived_property {\n         Lowercase_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Uppercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000007fffffe, 0x0000000000000000, 0x000000007f7fffff,\n@@ -889,10 +892,10 @@ pub(crate) mod derived_property {\n     pub fn Uppercase(c: char) -> bool {\n         Uppercase_table.lookup(c)\n     }\n-\n }\n \n pub(crate) mod property {\n+    #[rustfmt::skip]\n     const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -912,20 +915,19 @@ pub(crate) mod property {\n     pub fn White_Space(c: char) -> bool {\n         White_Space_table.lookup(c)\n     }\n-\n }\n \n pub(crate) mod conversions {\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n-            None        => [c, '\\0', '\\0'],\n+            None => [c, '\\0', '\\0'],\n             Some(index) => to_lowercase_table[index].1,\n         }\n     }\n \n     pub fn to_upper(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_uppercase_table) {\n-            None        => [c, '\\0', '\\0'],\n+            None => [c, '\\0', '\\0'],\n             Some(index) => to_uppercase_table[index].1,\n         }\n     }\n@@ -934,6 +936,7 @@ pub(crate) mod conversions {\n         table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n     }\n \n+    #[rustfmt::skip]\n     const to_lowercase_table: &[(char, [char; 3])] = &[\n         ('\\u{41}', ['\\u{61}', '\\0', '\\0']), ('\\u{42}', ['\\u{62}', '\\0', '\\0']), ('\\u{43}',\n         ['\\u{63}', '\\0', '\\0']), ('\\u{44}', ['\\u{64}', '\\0', '\\0']), ('\\u{45}', ['\\u{65}', '\\0',\n@@ -1558,6 +1561,7 @@ pub(crate) mod conversions {\n         ('\\u{1e920}', ['\\u{1e942}', '\\0', '\\0']), ('\\u{1e921}', ['\\u{1e943}', '\\0', '\\0'])\n     ];\n \n+    #[rustfmt::skip]\n     const to_uppercase_table: &[(char, [char; 3])] = &[\n         ('\\u{61}', ['\\u{41}', '\\0', '\\0']), ('\\u{62}', ['\\u{42}', '\\0', '\\0']), ('\\u{63}',\n         ['\\u{43}', '\\0', '\\0']), ('\\u{64}', ['\\u{44}', '\\0', '\\0']), ('\\u{65}', ['\\u{45}', '\\0',\n@@ -2228,5 +2232,4 @@ pub(crate) mod conversions {\n         ('\\u{1e940}', ['\\u{1e91e}', '\\0', '\\0']), ('\\u{1e941}', ['\\u{1e91f}', '\\0', '\\0']),\n         ('\\u{1e942}', ['\\u{1e920}', '\\0', '\\0']), ('\\u{1e943}', ['\\u{1e921}', '\\0', '\\0'])\n     ];\n-\n }"}, {"sha": "97df92a56da66ea2b0527a35d4a5eb28f6457390", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -81,8 +81,8 @@ class UnicodeFiles(object):\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case, clippy::unreadable_literal)]\n \n-use crate::unicode::version::UnicodeVersion;\n use crate::unicode::bool_trie::{{BoolTrie, SmallBoolTrie}};\n+use crate::unicode::version::UnicodeVersion;\n \"\"\".format(year=datetime.datetime.now().year)\n \n # Mapping taken from Table 12 from:\n@@ -555,6 +555,8 @@ def generate_table(\n     if is_pub:\n         pub_string = \"pub \"\n \n+    yield \"\\n\"\n+    yield \"    #[rustfmt::skip]\\n\"\n     yield \"    %sconst %s: %s = &[\\n\" % (pub_string, name, decl_type)\n \n     data = []\n@@ -568,7 +570,7 @@ def generate_table(\n     for table_line in generate_table_lines(\"\".join(data).split(\",\"), 8):\n         yield table_line\n \n-    yield \"\\n    ];\\n\\n\"\n+    yield \"\\n    ];\\n\"\n \n \n def compute_trie(raw_data, chunk_size):\n@@ -634,6 +636,9 @@ def generate_bool_trie(name, codepoint_ranges, is_pub=False):\n     pub_string = \"\"\n     if is_pub:\n         pub_string = \"pub \"\n+\n+    yield \"\\n\"\n+    yield \"    #[rustfmt::skip]\\n\"\n     yield \"    %sconst %s: &super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name)\n     yield \"        r1: [\\n\"\n     data = (\"0x%016x\" % chunk for chunk in chunks[:0x800 // chunk_size])\n@@ -678,7 +683,7 @@ def generate_bool_trie(name, codepoint_ranges, is_pub=False):\n         yield fragment\n     yield \"\\n        ],\\n\"\n \n-    yield \"    };\\n\\n\"\n+    yield \"    };\\n\"\n \n \n def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n@@ -700,6 +705,8 @@ def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n     if is_pub:\n         pub_string = \"pub \"\n \n+    yield \"\\n\"\n+    yield \"    #[rustfmt::skip]\\n\"\n     yield (\"    %sconst %s: &super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n            % (pub_string, name))\n \n@@ -717,7 +724,7 @@ def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n         yield fragment\n     yield \"\\n        ],\\n\"\n \n-    yield \"    };\\n\\n\"\n+    yield \"    };\\n\"\n \n \n def generate_property_module(mod, grouped_categories, category_subset):\n@@ -726,7 +733,7 @@ def generate_property_module(mod, grouped_categories, category_subset):\n     Generate Rust code for module defining properties.\n     \"\"\"\n \n-    yield \"pub(crate) mod %s {\\n\" % mod\n+    yield \"pub(crate) mod %s {\" % mod\n     for cat in sorted(category_subset):\n         if cat in (\"Cc\", \"White_Space\"):\n             generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n@@ -736,9 +743,10 @@ def generate_property_module(mod, grouped_categories, category_subset):\n         for fragment in generator:\n             yield fragment\n \n+        yield \"\\n\"\n         yield \"    pub fn %s(c: char) -> bool {\\n\" % cat\n         yield \"        %s_table.lookup(c)\\n\" % cat\n-        yield \"    }\\n\\n\"\n+        yield \"    }\\n\"\n \n     yield \"}\\n\\n\"\n \n@@ -753,21 +761,21 @@ def generate_conversions_module(unicode_data):\n     yield \"\"\"\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n-            None        => [c, '\\\\0', '\\\\0'],\n+            None => [c, '\\\\0', '\\\\0'],\n             Some(index) => to_lowercase_table[index].1,\n         }\n     }\n \n     pub fn to_upper(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_uppercase_table) {\n-            None        => [c, '\\\\0', '\\\\0'],\n+            None => [c, '\\\\0', '\\\\0'],\n             Some(index) => to_uppercase_table[index].1,\n         }\n     }\n \n     fn bsearch_case_table(c: char, table: &[(char, [char; 3])]) -> Option<usize> {\n         table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n-    }\\n\\n\"\"\"\n+    }\\n\"\"\"\n \n     decl_type = \"&[(char, [char; 3])]\"\n     format_conversion = lambda x: \"({},[{},{},{}])\".format(*(\n@@ -827,13 +835,9 @@ def main():\n     /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n     /// `char` and `str` methods are based on.\n     #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-    pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {{\n-        major: {version.major},\n-        minor: {version.minor},\n-        micro: {version.micro},\n-        _priv: (),\n-    }};\n-    \"\"\").format(version=unicode_version)\n+    pub const UNICODE_VERSION: UnicodeVersion =\n+        UnicodeVersion {{ major: {v.major}, minor: {v.minor}, micro: {v.micro}, _priv: () }};\n+    \"\"\").format(v=unicode_version)\n     buf.write(unicode_version_notice)\n \n     get_path = lambda f: get_unicode_file_path(unicode_version, f)"}, {"sha": "f41f4a5e94a76ee5b585b9575636cfa4b7e66aab", "filename": "src/libcore/unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -15,7 +15,7 @@ use crate::iter::FromIterator;\n /// ```\n #[stable(feature = \"unit_from_iter\", since = \"1.23.0\")]\n impl FromIterator<()> for () {\n-    fn from_iter<I: IntoIterator<Item=()>>(iter: I) -> Self {\n+    fn from_iter<I: IntoIterator<Item = ()>>(iter: I) -> Self {\n         iter.into_iter().for_each(|()| {})\n     }\n }"}, {"sha": "2ecbe770729b5b278f21213df8902e31104ef224", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -11,6 +11,7 @@\n #![feature(nll)]\n #![feature(rustc_private)]\n #![feature(unicode_internals)]\n+#![feature(bool_to_option)]\n \n pub use Piece::*;\n pub use Position::*;\n@@ -442,20 +443,9 @@ impl<'a> Parser<'a> {\n             Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => {\n+                Some(&(_, c)) if rustc_lexer::is_id_start(c) => {\n                     Some(ArgumentNamed(Symbol::intern(self.word())))\n                 }\n-                Some(&(pos, c)) if c == '_' => {\n-                    let invalid_name = self.string(pos);\n-                    self.err_with_note(format!(\"invalid argument name `{}`\", invalid_name),\n-                                       \"invalid argument name\",\n-                                       \"argument names cannot start with an underscore\",\n-                                        self.to_span_index(pos).to(\n-                                            self.to_span_index(pos + invalid_name.len())\n-                                        ),\n-                                        );\n-                    Some(ArgumentNamed(Symbol::intern(invalid_name)))\n-                },\n \n                 // This is an `ArgumentNext`.\n                 // Record the fact and do the resolution after parsing the\n@@ -611,22 +601,34 @@ impl<'a> Parser<'a> {\n     /// Rust identifier, except that it can't start with `_` character.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c != '_' && rustc_lexer::is_id_start(c) => {\n+            Some(&(pos, c)) if rustc_lexer::is_id_start(c) => {\n                 self.cur.next();\n                 pos\n             }\n             _ => {\n-                return &self.input[..0];\n+                return \"\";\n             }\n         };\n+        let mut end = None;\n         while let Some(&(pos, c)) = self.cur.peek() {\n             if rustc_lexer::is_id_continue(c) {\n                 self.cur.next();\n             } else {\n-                return &self.input[start..pos];\n+                end = Some(pos);\n+                break;\n             }\n         }\n-        &self.input[start..self.input.len()]\n+        let end = end.unwrap_or(self.input.len());\n+        let word = &self.input[start..end];\n+        if word == \"_\" {\n+            self.err_with_note(\n+                \"invalid argument name `_`\",\n+                \"invalid argument name\",\n+                \"argument name cannot be a single underscore\",\n+                self.to_span_index(start).to(self.to_span_index(end)),\n+            );\n+        }\n+        word\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal\n@@ -643,11 +645,7 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n         }\n-        if found {\n-            Some(cur)\n-        } else {\n-            None\n-        }\n+        found.then_some(cur)\n     }\n }\n "}, {"sha": "5509f47bc8858ccdc5a668f71cf9f4f001ab32ff", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -21,7 +21,6 @@\n // Rust's \"try\" function, but if we're aborting on panics we just call the\n // function as there's nothing else we need to do here.\n #[rustc_std_internal_symbol]\n-#[allow(improper_ctypes)]\n pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                               data: *mut u8,\n                                               _data_ptr: *mut usize,"}, {"sha": "242eb6750b3dfdb5a0f163ec009ec8d8e54c11f6", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -130,7 +130,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>, foreign_e\n fn interpret_cs_action(cs_action: u64, lpad: usize, foreign_exception: bool) -> EHAction {\n     if cs_action == 0 {\n         // If cs_action is 0 then this is a cleanup (Drop::drop). We run these\n-        // for both Rust panics and foriegn exceptions.\n+        // for both Rust panics and foreign exceptions.\n         EHAction::Cleanup(lpad)\n     } else if foreign_exception {\n         // catch_unwind should not catch foreign exceptions, only Rust panics."}, {"sha": "3a14197c77bec3ba289315fc1cfb8773f58a6a2f", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -69,7 +69,6 @@ mod dwarf;\n // hairy and tightly coupled, for more information see the compiler's\n // implementation of this.\n #[no_mangle]\n-#[allow(improper_ctypes)]\n pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                                   data: *mut u8,\n                                                   data_ptr: *mut usize,\n@@ -92,5 +91,14 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n #[unwind(allowed)]\n pub unsafe extern \"C\" fn __rust_start_panic(payload: usize) -> u32 {\n     let payload = payload as *mut &mut dyn BoxMeUp;\n-    imp::panic(Box::from_raw((*payload).box_me_up()))\n+    let payload = (*payload).take_box();\n+\n+    // Miri panic support: cfg'd out of normal builds just to be sure.\n+    // When going through normal codegen, `miri_start_panic` is a NOP, so the\n+    // Miri-enabled sysroot still supports normal unwinding. But when executed in\n+    // Miri, this line initiates unwinding.\n+    #[cfg(miri)]\n+    core::intrinsics::miri_start_panic(payload);\n+\n+    imp::panic(Box::from_raw(payload))\n }"}, {"sha": "ff9a215d339e3c39db32005c9119862e12f70182", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -98,9 +98,6 @@ use libc::{c_int, c_uint, c_void};\n mod imp {\n     pub type ptr_t = *mut u8;\n \n-    #[cfg(bootstrap)]\n-    pub const NAME1: [u8; 7] = [b'.', b'P', b'A', b'_', b'K', 0, 0];\n-\n     macro_rules! ptr {\n         (0) => (core::ptr::null_mut());\n         ($e:expr) => ($e as *mut u8);\n@@ -112,9 +109,6 @@ mod imp {\n mod imp {\n     pub type ptr_t = u32;\n \n-    #[cfg(bootstrap)]\n-    pub const NAME1: [u8; 7] = [b'.', b'P', b'E', b'A', b'_', b'K', 0];\n-\n     extern \"C\" {\n         pub static __ImageBase: u8;\n     }\n@@ -161,17 +155,11 @@ pub struct _PMD {\n pub struct _TypeDescriptor {\n     pub pVFTable: *const u8,\n     pub spare: *mut u8,\n-    #[cfg(bootstrap)]\n-    pub name: [u8; 7],\n-    #[cfg(not(bootstrap))]\n     pub name: [u8; 11],\n }\n \n // Note that we intentionally ignore name mangling rules here: we don't want C++\n // to be able to catch Rust panics by simply declaring a `struct rust_panic`.\n-#[cfg(bootstrap)]\n-use imp::NAME1 as TYPE_NAME;\n-#[cfg(not(bootstrap))]\n const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n \n static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n@@ -194,9 +182,6 @@ static mut CATCHABLE_TYPE: _CatchableType = _CatchableType {\n         pdisp: -1,\n         vdisp: 0,\n     },\n-    #[cfg(bootstrap)]\n-    sizeOrOffset: mem::size_of::<*mut u64>() as c_int,\n-    #[cfg(not(bootstrap))]\n     sizeOrOffset: mem::size_of::<[u64; 2]>() as c_int,\n     copy_function: ptr!(0),\n };\n@@ -218,8 +203,7 @@ extern \"C\" {\n // an argument to the C++ personality function.\n //\n // Again, I'm not entirely sure what this is describing, it just seems to work.\n-#[cfg_attr(bootstrap, lang = \"msvc_try_filter\")]\n-#[cfg_attr(not(any(test, bootstrap)), lang = \"eh_catch_typeinfo\")]\n+#[cfg_attr(not(test), lang = \"eh_catch_typeinfo\")]\n static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n     pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n     spare: core::ptr::null_mut(),\n@@ -238,12 +222,8 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // exception (constructed above).\n     let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n     let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n-    let mut ptrs_ptr = ptrs.as_mut_ptr();\n-    let throw_ptr = if cfg!(bootstrap) {\n-        &mut ptrs_ptr as *mut _ as *mut _\n-    } else {\n-        ptrs_ptr as *mut _\n-    };\n+    let ptrs_ptr = ptrs.as_mut_ptr();\n+    let throw_ptr = ptrs_ptr as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n     // pointers between these structure are just that, pointers. On 64-bit MSVC,"}, {"sha": "87cd8fcb14385490c9bf560cd79d928e10f63ba5", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -25,7 +25,6 @@\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n-#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(rustc_attrs)]\n #![feature(specialization)]\n "}, {"sha": "791d72d6b77a77521e236ad9f0508419cbe09c23", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -10,10 +10,6 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-# Prevent cc from upgrading all the way to 1.0.46,\n-# which fails the build (see e.g. #65445.)\n-cc = \"=1.0.37\"\n-\n arena = { path = \"../libarena\" }\n bitflags = \"1.2.1\"\n fmt_macros = { path = \"../libfmt_macros\" }\n@@ -26,6 +22,7 @@ rustc-rayon = \"0.3.0\"\n rustc-rayon-core = \"0.3.0\"\n polonius-engine  = \"0.10.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n+rustc_feature = { path = \"../librustc_feature\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n@@ -40,4 +37,6 @@ byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n-measureme = \"0.4\"\n+measureme = \"0.5\"\n+rustc_error_codes = { path = \"../librustc_error_codes\" }\n+rustc_session = { path = \"../librustc_session\" }"}, {"sha": "eb7a17098015468304fc21395657360e1c0f938e", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -23,17 +23,17 @@ macro_rules! arena_types {\n             [] generics: rustc::ty::Generics,\n             [] trait_def: rustc::ty::TraitDef,\n             [] adt_def: rustc::ty::AdtDef,\n-            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::Body<$tcx>>,\n-            [] mir: rustc::mir::Body<$tcx>,\n+            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::BodyAndCache<$tcx>>,\n+            [] mir: rustc::mir::BodyAndCache<$tcx>,\n             [] steal_promoted: rustc::ty::steal::Steal<\n                 rustc_index::vec::IndexVec<\n                     rustc::mir::Promoted,\n-                    rustc::mir::Body<$tcx>\n+                    rustc::mir::BodyAndCache<$tcx>\n                 >\n             >,\n             [] promoted: rustc_index::vec::IndexVec<\n                 rustc::mir::Promoted,\n-                rustc::mir::Body<$tcx>\n+                rustc::mir::BodyAndCache<$tcx>\n             >,\n             [] tables: rustc::ty::TypeckTables<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,\n@@ -93,14 +93,15 @@ macro_rules! arena_types {\n                         rustc::hir::def_id::CrateNum\n                     >\n                 >,\n+            [few] hir_forest: rustc::hir::map::Forest,\n             [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n                 syntax::symbol::Symbol,\n                 rustc::hir::def_id::DefId,\n             >,\n             [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n             [few] lint_levels: rustc::lint::LintLevelMap,\n             [few] stability_index: rustc::middle::stability::Index<'tcx>,\n-            [few] features: syntax::feature_gate::Features,\n+            [few] features: rustc_feature::Features,\n             [few] all_traits: Vec<rustc::hir::def_id::DefId>,\n             [few] privacy_access_levels: rustc::middle::privacy::AccessLevels,\n             [few] target_features_whitelist: rustc_data_structures::fx::FxHashMap<"}, {"sha": "e3b36be5696b3ca1d44d1fa35b46ee2f57b4a85c", "filename": "src/librustc/benches/dispatch.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Fbenches%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Fbenches%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Fdispatch.rs?ref=947772fc31b96ce90f57720f74571f14e35df66b", "patch": "@@ -1,34 +0,0 @@\n-use test::Bencher;\n-\n-// Static/dynamic method dispatch\n-\n-struct Struct {\n-    field: isize\n-}\n-\n-trait Trait {\n-    fn method(&self) -> isize;\n-}\n-\n-impl Trait for Struct {\n-    fn method(&self) -> isize {\n-        self.field\n-    }\n-}\n-\n-#[bench]\n-fn trait_vtable_method_call(b: &mut Bencher) {\n-    let s = Struct { field: 10 };\n-    let t = &s as &Trait;\n-    b.iter(|| {\n-        t.method()\n-    });\n-}\n-\n-#[bench]\n-fn trait_static_method_call(b: &mut Bencher) {\n-    let s = Struct { field: 10 };\n-    b.iter(|| {\n-        s.method()\n-    });\n-}"}, {"sha": "6b624028896ac15c8628e1c1d8135cbca02d5995", "filename": "src/librustc/benches/lib.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -1,6 +1,63 @@\n+#![feature(slice_patterns)]\n #![feature(test)]\n \n extern crate test;\n \n-mod dispatch;\n-mod pattern;\n+use test::Bencher;\n+\n+// Static/dynamic method dispatch\n+\n+struct Struct {\n+    field: isize\n+}\n+\n+trait Trait {\n+    fn method(&self) -> isize;\n+}\n+\n+impl Trait for Struct {\n+    fn method(&self) -> isize {\n+        self.field\n+    }\n+}\n+\n+#[bench]\n+fn trait_vtable_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    let t = &s as &dyn Trait;\n+    b.iter(|| {\n+        t.method()\n+    });\n+}\n+\n+#[bench]\n+fn trait_static_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    b.iter(|| {\n+        s.method()\n+    });\n+}\n+\n+// Overhead of various match forms\n+\n+#[bench]\n+fn option_some(b: &mut Bencher) {\n+    let x = Some(10);\n+    b.iter(|| {\n+        match x {\n+            Some(y) => y,\n+            None => 11\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn vec_pattern(b: &mut Bencher) {\n+    let x = [1,2,3,4,5,6];\n+    b.iter(|| {\n+        match x {\n+            [1,2,3,..] => 10,\n+            _ => 11,\n+        }\n+    });\n+}"}, {"sha": "fd8cc5b83fd5a85ce2cbdd18642c3dfba17a4226", "filename": "src/librustc/benches/pattern.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Fbenches%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Fbenches%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Fpattern.rs?ref=947772fc31b96ce90f57720f74571f14e35df66b", "patch": "@@ -1,25 +0,0 @@\n-use test::Bencher;\n-\n-// Overhead of various match forms\n-\n-#[bench]\n-fn option_some(b: &mut Bencher) {\n-    let x = Some(10);\n-    b.iter(|| {\n-        match x {\n-            Some(y) => y,\n-            None => 11\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn vec_pattern(b: &mut Bencher) {\n-    let x = [1,2,3,4,5,6];\n-    b.iter(|| {\n-        match x {\n-            [1,2,3,..] => 10,\n-            _ => 11,\n-        }\n-    });\n-}"}, {"sha": "17ab0c187a2fc1c4a14c88c60dd6a4f63f55fa61", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -578,7 +578,7 @@ impl<'tcx> DepNodeParams<'tcx> for HirId {\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n-         RustcEncodable, RustcDecodable)]\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct WorkProductId {\n     hash: Fingerprint\n }\n@@ -599,7 +599,3 @@ impl WorkProductId {\n         }\n     }\n }\n-\n-impl_stable_hash_for!(struct crate::dep_graph::WorkProductId {\n-    hash\n-});"}, {"sha": "d952bf7ab9e2541ee18f8d4c62e4c8a3ea14a494", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -710,14 +710,25 @@ impl DepGraph {\n                                 return None\n                             }\n                             None => {\n-                                if !tcx.sess.has_errors() {\n+                                if !tcx.sess.has_errors_or_delayed_span_bugs() {\n                                     bug!(\"try_mark_previous_green() - Forcing the DepNode \\\n                                           should have set its color\")\n                                 } else {\n-                                    // If the query we just forced has resulted\n-                                    // in some kind of compilation error, we\n-                                    // don't expect that the corresponding\n-                                    // dep-node color has been updated.\n+                                    // If the query we just forced has resulted in\n+                                    // some kind of compilation error, we cannot rely on\n+                                    // the dep-node color having been properly updated.\n+                                    // This means that the query system has reached an\n+                                    // invalid state. We let the compiler continue (by\n+                                    // returning `None`) so it can emit error messages\n+                                    // and wind down, but rely on the fact that this\n+                                    // invalid state will not be persisted to the\n+                                    // incremental compilation cache because of\n+                                    // compilation errors being present.\n+                                    debug!(\"try_mark_previous_green({:?}) - END - \\\n+                                            dependency {:?} resulted in compilation error\",\n+                                           dep_node,\n+                                           dep_dep_node);\n+                                    return None\n                                 }\n                             }\n                         }"}, {"sha": "a1321d50f28bb99bab97983b352781e41b0a916a", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428", "patch": "@@ -5,7 +5,6 @@ mod prev;\n mod query;\n mod safe;\n mod serialized;\n-pub mod cgu_reuse_tracker;\n \n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, RecoverKey, label_strs};\n pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps, hash_result};"}, {"sha": "f40b892a06bf24230a9132ede389d318023a8610", "filename": "src/librustc/error_codes.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=947772fc31b96ce90f57720f74571f14e35df66b"}, {"sha": "ea1c585176d57c837e9cb6c310fc1cb3338cf3de", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "231b054f9748d19d1641dd80f82dd571da18f4a6", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a4557a0776ca4dad56f6317cd4554d8722114696", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "e13f6cabb5296296b8d3106e73ae17b20094fb55", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 95, "deletions": 29, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "f8465baeb1305e917a1b4757f2b173fa3163beb0", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "ff9d8c85df8b9dd3661df2d3092faf3bb354d3ab", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 60, "deletions": 70, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "8f9f3983262372fdcd28e8782d6e6855c4ed933c", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "91b4971cd92be1016c988fe903d6a04be1ecdfdc", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "5bf5a93ad010271833671248ea41dbb6916ef412", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "66bb3a8d883a4670136cf944604725aaa1557777", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 62, "deletions": 128, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "97228c8f2403882df34d8ccd17279960f046693e", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a069331582ea67096a8f0c8c34f8aad58e59b045", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "8b35839c182ac921db0480899ad4c432d64108bd", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 10, "deletions": 91, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "066359bd4e0361b67178d0b8b96a5bebc75ad653", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "417305139e472ee58a4e30c9c1d29a6a2e8b6a53", "filename": "src/librustc/ich/impls_misc.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_misc.rs?ref=947772fc31b96ce90f57720f74571f14e35df66b"}, {"sha": "6499e56325a42aca2aa41bdc2287eaaecbcafe01", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 7, "deletions": 354, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "7f50d859cde3a544ca2d56255db2cf42ea0890df", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "ece438266c0c249bee7af39491a5d52439a85d77", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "1fa814dc14efb52702a778007b3f6305946f5862", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "b0f65ac6e1b3437440221c98ada4d8adc9fde09e", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 9, "deletions": 62, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "825e98cedb9e07eda7f4f5cb01a8860bdd2694aa", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a2f0531f0af36e0150d2ef1ffd06bb33bf108801", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "58c1498faa9dedbe017a69f05f810dcb2af0a3b0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 257, "deletions": 49, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "32eecdf01a31fc7d908cd6036572cd1efb621ab4", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a431b541fa42fbd4d4353b72d29876397354cebe", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "09cfbf850a57dfb76d219b38991c6d2765270311", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "0abdeb719934452c319006fa5d33cce59d48f4da", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "3b4d06aab27ef6827334fab02e3049b2739831b8", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "01ba748c4e1f9a3d6dd3ce43f01afd19ce69e897", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "4b933735fc75f4eb472869de845881a0b0750c20", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "32b51da920d66e722debe391980f9c8f4aa3284c", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "11f86a619b5c2a41795a882fa281288e1844b8ad", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "49c095c69d6c4bfacf986573fe1e290f60b65808", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "b3ddffc8b12f1e782629aa45c9026d2f76163e23", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "1e0feb6a7da8d97606ff91989a37caa365250ba1", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "9b197c1ecb14076ff8c38d2a5bf5d20e19ced3ba", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "fd8ccce6833522d3368e16704133f4ce220effc0", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "f9443376a935ac6bef69f64c604c18802f790ced", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "3e28145c0fa0a544b7022a2050fa74a93ea322a6", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "402449ce6cc2032cb0465f1e61ba56f4cf506194", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "613f66d7ffd7ee2422151a22fa4734ac1e82df47", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "8ad6990a75dafde22bc5f83f394f71659ca27364", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "24b87ffc80c2a5b60a425a1a17dfa6683080560b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "c4bc9773d23128369f91c1a7d3d4f1e78535c514", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "7f72154e42c61eb0f7fcb447d12e04a295a4c33a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "10c0c63995ca276c7f3e9f2ae15ec185e3d24d65", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "f29d1a3789aea493275d1e91a7ecde847b705fb7", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a8d886866795eef22f1760bc105d0d53fdaa0eb5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 244, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "2bda0c0bef02daf5fa589bf033e29f85120dc51d", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "324b01316fa4a63216b153ef005240e9e332cc24", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "7182f031824025ae74579522461e017390f262c1", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "6f7a022eccfb843538a55875ee37b93aca02be27", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "e6f8521216b3cd02fc735fe7fcfdc9ca12976dfd", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "cbf336fdbe2f3cd69627c81f94a8f689644e2a6e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "removed", "additions": 0, "deletions": 1508, "changes": 1508, "blob_url": "https://github.com/rust-lang/rust/blob/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947772fc31b96ce90f57720f74571f14e35df66b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=947772fc31b96ce90f57720f74571f14e35df66b"}, {"sha": "aa6f28398289fa77e55681f568610682d703bae2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "c13c44c413d776fe45942b409b6ac7e21e2c4958", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "54aafe2114dac04cef756414a9a55658d33cb608", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "48c1226232f1376311400dd171718a64a1337720", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "0704771f6ee95447abd31d18843b5a227f6e5aa2", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 239, "deletions": 23, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "f849361e08be9e0b0dbfd36267a8972af043e586", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "0dec7c071bfeee860a176578dd964ea336c09143", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "fff876752db55ab971a45126f726f5a81742f092", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "0b27f512e55b8c44b36d4f9d64837fe1ef5ee314", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a038ca23ae92d6e1939d420cb937fec91148cf7b", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 41, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a7f5a2269251530c93cccdb2310c4b26e76d9ae2", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 207, "deletions": 343, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "34daf185b29527e182d47ee790835f1ead8ec6e3", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a66a49f103f68f0d6a4b66747a7b733c1e01f535", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "703e0cc78c207b73821d12f58e21d19cc81284bc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 56, "deletions": 10, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "538b13c79ce1ccd45960bcf98850a44d5079321e", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "a0d9f52d28ad5eaca6dc146234a84a9a67137a06", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 89, "deletions": 87, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "933bc06c21efedfd2086cd052a0c119c65815acf", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "35017d6330da31555805556276b32139d5099d16", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 388, "deletions": 151, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "d94e004db29789ae02a6b1c56d72e688ced9ba60", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 36, "deletions": 47, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "604f39dcf293b3503a82355461208a10251be27b", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "c345b9a969c908fcdacdeb86e7025d2d9bc9a89d", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "785b4122d087359eee25fab69bd84cdc02c73ccf", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "be846287e290c1a5a4b993efb3beacda8ba7fe40", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "66683cab95960409216a1a795d78c018b6d31c9a", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "09c7f45c22b0a32f364de4dcda1b3b658950f4e3", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "d6cd2cce425cb6f29d4953d5d9bd82f6032f04da", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "ee8b73f86a61a033520a68361326684dc1123675", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "8ea800cced2134a351b7b541032305748b4830ae", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "6f45d76a8e9d7d9b4ffd23a06848aa7195de5613", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "f905d5a019ec8c3d30a2a608a91ecc5669fe7a4a", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "83d51b6d3ebf78500cd227dd13080ebe078d2455", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "c0a0cbe9a3876029ae201bd03874ed69639de6d8", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "76292f9dea085cc29425c9e2a7da6c07c52e2b09", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "5f324527a2725b3d1aa65b095c9128cf7b1b106e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 159, "deletions": 191, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "88a2db3dc622399516848966b5790bf316ea6bb4", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "b8ddf6078bda6e1d20aabb978a6529afeadeed96", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}, {"sha": "8c300da11fcbf67e5b0e77fa64183dd46b26467a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6a06285efe12d778ff7f44067aebeed7b14428/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=8f6a06285efe12d778ff7f44067aebeed7b14428"}]}