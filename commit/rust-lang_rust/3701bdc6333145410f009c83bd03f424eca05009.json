{"sha": "3701bdc6333145410f009c83bd03f424eca05009", "node_id": "C_kwDOAAsO6NoAKDM3MDFiZGM2MzMzMTQ1NDEwZjAwOWM4M2JkMDNmNDI0ZWNhMDUwMDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-18T09:29:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-18T09:29:21Z"}, "message": "Auto merge of #107329 - joboet:optimize_lazylock, r=m-ou-se\n\nOptimize `LazyLock` size\n\nThe initialization function was unnecessarily stored separately from the data to be initialized. Since both cannot exist at the same time, a `union` can be used, with the `Once` acting as discriminant. This unfortunately requires some extra methods on `Once` so that `Drop` can be implemented correctly and efficiently.\n\n`@rustbot` label +T-libs +A-atomic", "tree": {"sha": "cabec78c289224033894c07fa509d6d5a99c9617", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cabec78c289224033894c07fa509d6d5a99c9617"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3701bdc6333145410f009c83bd03f424eca05009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3701bdc6333145410f009c83bd03f424eca05009", "html_url": "https://github.com/rust-lang/rust/commit/3701bdc6333145410f009c83bd03f424eca05009", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3701bdc6333145410f009c83bd03f424eca05009/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d819a4b8f45b170e7c2c415df20cfa2e0cbbf7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d819a4b8f45b170e7c2c415df20cfa2e0cbbf7f", "html_url": "https://github.com/rust-lang/rust/commit/6d819a4b8f45b170e7c2c415df20cfa2e0cbbf7f"}, {"sha": "6520488e37f39a11affd776ab1283a0a3fe8087e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6520488e37f39a11affd776ab1283a0a3fe8087e", "html_url": "https://github.com/rust-lang/rust/commit/6520488e37f39a11affd776ab1283a0a3fe8087e"}], "stats": {"total": 137, "additions": 120, "deletions": 17}, "files": [{"sha": "7e85d6a063a785fba7e5e182cc9c4e9d55ff2323", "filename": "library/std/src/sync/lazy_lock.rs", "status": "modified", "additions": 70, "deletions": 16, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs?ref=3701bdc6333145410f009c83bd03f424eca05009", "patch": "@@ -1,8 +1,21 @@\n-use crate::cell::Cell;\n+use crate::cell::UnsafeCell;\n use crate::fmt;\n+use crate::mem::ManuallyDrop;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n-use crate::sync::OnceLock;\n+use crate::sync::Once;\n+\n+use super::once::ExclusiveState;\n+\n+// We use the state of a Once as discriminant value. Upon creation, the state is\n+// \"incomplete\" and `f` contains the initialization closure. In the first call to\n+// `call_once`, `f` is taken and run. If it succeeds, `value` is set and the state\n+// is changed to \"complete\". If it panics, the Once is poisoned, so none of the\n+// two fields is initialized.\n+union Data<T, F> {\n+    value: ManuallyDrop<T>,\n+    f: ManuallyDrop<F>,\n+}\n \n /// A value which is initialized on the first access.\n ///\n@@ -43,16 +56,17 @@ use crate::sync::OnceLock;\n /// ```\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub struct LazyLock<T, F = fn() -> T> {\n-    cell: OnceLock<T>,\n-    init: Cell<Option<F>>,\n+    once: Once,\n+    data: UnsafeCell<Data<T, F>>,\n }\n+\n impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     /// Creates a new lazy value with the given initializing\n     /// function.\n     #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new(f: F) -> LazyLock<T, F> {\n-        LazyLock { cell: OnceLock::new(), init: Cell::new(Some(f)) }\n+        LazyLock { once: Once::new(), data: UnsafeCell::new(Data { f: ManuallyDrop::new(f) }) }\n     }\n \n     /// Forces the evaluation of this lazy value and\n@@ -74,10 +88,50 @@ impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn force(this: &LazyLock<T, F>) -> &T {\n-        this.cell.get_or_init(|| match this.init.take() {\n-            Some(f) => f(),\n-            None => panic!(\"Lazy instance has previously been poisoned\"),\n-        })\n+        this.once.call_once(|| {\n+            // SAFETY: `call_once` only runs this closure once, ever.\n+            let data = unsafe { &mut *this.data.get() };\n+            let f = unsafe { ManuallyDrop::take(&mut data.f) };\n+            let value = f();\n+            data.value = ManuallyDrop::new(value);\n+        });\n+\n+        // SAFETY:\n+        // There are four possible scenarios:\n+        // * the closure was called and initialized `value`.\n+        // * the closure was called and panicked, so this point is never reached.\n+        // * the closure was not called, but a previous call initialized `value`.\n+        // * the closure was not called because the Once is poisoned, so this point\n+        //   is never reached.\n+        // So `value` has definitely been initialized and will not be modified again.\n+        unsafe { &*(*this.data.get()).value }\n+    }\n+}\n+\n+impl<T, F> LazyLock<T, F> {\n+    /// Get the inner value if it has already been initialized.\n+    fn get(&self) -> Option<&T> {\n+        if self.once.is_completed() {\n+            // SAFETY:\n+            // The closure has been run successfully, so `value` has been initialized\n+            // and will not be modified again.\n+            Some(unsafe { &*(*self.data.get()).value })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F> Drop for LazyLock<T, F> {\n+    fn drop(&mut self) {\n+        match self.once.state() {\n+            ExclusiveState::Incomplete => unsafe { ManuallyDrop::drop(&mut self.data.get_mut().f) },\n+            ExclusiveState::Complete => unsafe {\n+                ManuallyDrop::drop(&mut self.data.get_mut().value)\n+            },\n+            ExclusiveState::Poisoned => {}\n+        }\n     }\n }\n \n@@ -103,23 +157,23 @@ impl<T: Default> Default for LazyLock<T> {\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: fmt::Debug, F> fmt::Debug for LazyLock<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).finish_non_exhaustive()\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"LazyLock\").field(v).finish(),\n+            None => f.write_str(\"LazyLock(Uninit)\"),\n+        }\n     }\n }\n \n // We never create a `&F` from a `&LazyLock<T, F>` so it is fine\n // to not impl `Sync` for `F`\n-// we do create a `&mut Option<F>` in `force`, but this is\n-// properly synchronized, so it only happens once\n-// so it also does not contribute to this impl.\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-unsafe impl<T, F: Send> Sync for LazyLock<T, F> where OnceLock<T>: Sync {}\n+unsafe impl<T: Sync + Send, F: Send> Sync for LazyLock<T, F> {}\n // auto-derived `Send` impl is OK.\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: UnwindSafe> RefUnwindSafe for LazyLock<T, F> where OnceLock<T>: RefUnwindSafe {}\n+impl<T: RefUnwindSafe + UnwindSafe, F: UnwindSafe> RefUnwindSafe for LazyLock<T, F> {}\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: UnwindSafe> UnwindSafe for LazyLock<T, F> where OnceLock<T>: UnwindSafe {}\n+impl<T: UnwindSafe, F: UnwindSafe> UnwindSafe for LazyLock<T, F> {}\n \n #[cfg(test)]\n mod tests;"}, {"sha": "4edc956173b08e37d94d4e87a6b9d9f8112fee95", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=3701bdc6333145410f009c83bd03f424eca05009", "patch": "@@ -186,7 +186,7 @@ mod condvar;\n mod lazy_lock;\n mod mpmc;\n mod mutex;\n-mod once;\n+pub(crate) mod once;\n mod once_lock;\n mod poison;\n mod remutex;"}, {"sha": "1b17c31089ff2d9dba11eea7dc7bcf30980a4584", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=3701bdc6333145410f009c83bd03f424eca05009", "patch": "@@ -43,6 +43,12 @@ pub struct OnceState {\n     pub(crate) inner: sys::OnceState,\n }\n \n+pub(crate) enum ExclusiveState {\n+    Incomplete,\n+    Poisoned,\n+    Complete,\n+}\n+\n /// Initialization value for static [`Once`] values.\n ///\n /// # Examples\n@@ -248,6 +254,16 @@ impl Once {\n     pub fn is_completed(&self) -> bool {\n         self.inner.is_completed()\n     }\n+\n+    /// Returns the current state of the `Once` instance.\n+    ///\n+    /// Since this takes a mutable reference, no initialization can currently\n+    /// be running, so the state must be either \"incomplete\", \"poisoned\" or\n+    /// \"complete\".\n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        self.inner.state()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]"}, {"sha": "11fde1888ba7cf975a360031a846f401d75938a7", "filename": "library/std/src/sys/unsupported/once.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs?ref=3701bdc6333145410f009c83bd03f424eca05009", "patch": "@@ -1,5 +1,6 @@\n use crate::cell::Cell;\n use crate::sync as public;\n+use crate::sync::once::ExclusiveState;\n \n pub struct Once {\n     state: Cell<State>,\n@@ -44,6 +45,16 @@ impl Once {\n         self.state.get() == State::Complete\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match self.state.get() {\n+            State::Incomplete => ExclusiveState::Incomplete,\n+            State::Poisoned => ExclusiveState::Poisoned,\n+            State::Complete => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     #[cold]\n     #[track_caller]\n     pub fn call(&self, ignore_poisoning: bool, f: &mut impl FnMut(&public::OnceState)) {"}, {"sha": "42db5fad4b4518d270bbaea0da48ca854499c3f3", "filename": "library/std/src/sys_common/once/futex.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs?ref=3701bdc6333145410f009c83bd03f424eca05009", "patch": "@@ -4,6 +4,7 @@ use crate::sync::atomic::{\n     AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n+use crate::sync::once::ExclusiveState;\n use crate::sys::futex::{futex_wait, futex_wake_all};\n \n // On some platforms, the OS is very nice and handles the waiter queue for us.\n@@ -78,6 +79,16 @@ impl Once {\n         self.state.load(Acquire) == COMPLETE\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match *self.state.get_mut() {\n+            INCOMPLETE => ExclusiveState::Incomplete,\n+            POISONED => ExclusiveState::Poisoned,\n+            COMPLETE => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     // This uses FnMut to match the API of the generic implementation. As this\n     // implementation is quite light-weight, it is generic over the closure and\n     // so avoids the cost of dynamic dispatch."}, {"sha": "def0bcd6fac444167a13c8338d9a8b1d03129a23", "filename": "library/std/src/sys_common/once/queue.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3701bdc6333145410f009c83bd03f424eca05009/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs?ref=3701bdc6333145410f009c83bd03f424eca05009", "patch": "@@ -60,6 +60,7 @@ use crate::fmt;\n use crate::ptr;\n use crate::sync as public;\n use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n+use crate::sync::once::ExclusiveState;\n use crate::thread::{self, Thread};\n \n type Masked = ();\n@@ -121,6 +122,16 @@ impl Once {\n         self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match self.state_and_queue.get_mut().addr() {\n+            INCOMPLETE => ExclusiveState::Incomplete,\n+            POISONED => ExclusiveState::Poisoned,\n+            COMPLETE => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     // This is a non-generic function to reduce the monomorphization cost of\n     // using `call_once` (this isn't exactly a trivial or small implementation).\n     //"}]}