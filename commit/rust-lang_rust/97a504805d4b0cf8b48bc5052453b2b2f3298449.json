{"sha": "97a504805d4b0cf8b48bc5052453b2b2f3298449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YTUwNDgwNWQ0YjBjZjhiNDhiYzUwNTI0NTNiMmIyZjMyOTg0NDk=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-11-01T10:36:30Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-11-03T07:16:35Z"}, "message": "Move rendering tests to the render module", "tree": {"sha": "dd5da407ca9332898107fd51199ea49f396f7590", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd5da407ca9332898107fd51199ea49f396f7590"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97a504805d4b0cf8b48bc5052453b2b2f3298449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97a504805d4b0cf8b48bc5052453b2b2f3298449", "html_url": "https://github.com/rust-lang/rust/commit/97a504805d4b0cf8b48bc5052453b2b2f3298449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97a504805d4b0cf8b48bc5052453b2b2f3298449/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15b16917fcd55068d9aba3d4b5d87763ec5deb69", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b16917fcd55068d9aba3d4b5d87763ec5deb69", "html_url": "https://github.com/rust-lang/rust/commit/15b16917fcd55068d9aba3d4b5d87763ec5deb69"}], "stats": {"total": 2258, "additions": 1163, "deletions": 1095}, "files": [{"sha": "b54771fcd1c8d74a873df2fb1ad37719630b083a", "filename": "crates/completion/src/completions.rs", "status": "modified", "additions": 8, "deletions": 1074, "changes": 1082, "blob_url": "https://github.com/rust-lang/rust/blob/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions.rs?ref=97a504805d4b0cf8b48bc5052453b2b2f3298449", "patch": "@@ -14,15 +14,9 @@ pub(crate) mod macro_in_item_position;\n pub(crate) mod trait_impl;\n pub(crate) mod mod_;\n \n-use hir::{HasAttrs, HirDisplay, ModPath, Mutability, ScopeDef, Type};\n-use test_utils::mark;\n+use hir::{ModPath, ScopeDef, Type};\n \n-use crate::{\n-    item::Builder,\n-    render::{ConstRender, EnumVariantRender, FunctionRender, MacroRender, TypeAliasRender},\n-    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, CompletionScore,\n-    RootDatabase,\n-};\n+use crate::{item::Builder, render::*, CompletionContext, CompletionItem};\n \n /// Represents an in-progress set of completions being built.\n #[derive(Debug, Default)]\n@@ -58,27 +52,13 @@ impl Completions {\n     }\n \n     pub(crate) fn add_field(&mut self, ctx: &CompletionContext, field: hir::Field, ty: &Type) {\n-        let is_deprecated = is_deprecated(field, ctx.db);\n-        let name = field.name(ctx.db);\n-        let mut item =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n-                .kind(CompletionItemKind::Field)\n-                .detail(ty.display(ctx.db).to_string())\n-                .set_documentation(field.docs(ctx.db))\n-                .set_deprecated(is_deprecated);\n-\n-        if let Some(score) = compute_score(ctx, &ty, &name.to_string()) {\n-            item = item.set_score(score);\n-        }\n-\n-        item.add_to(self);\n+        let item = Render::new(ctx.into()).add_field(field, ty);\n+        self.add(item);\n     }\n \n     pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), field.to_string())\n-            .kind(CompletionItemKind::Field)\n-            .detail(ty.display(ctx.db).to_string())\n-            .add_to(self);\n+        let item = Render::new(ctx.into()).add_tuple_field(field, ty);\n+        self.add(item);\n     }\n \n     pub(crate) fn add_resolution(\n@@ -87,100 +67,9 @@ impl Completions {\n         local_name: String,\n         resolution: &ScopeDef,\n     ) {\n-        use hir::ModuleDef::*;\n-\n-        let completion_kind = match resolution {\n-            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n-            _ => CompletionKind::Reference,\n-        };\n-\n-        let kind = match resolution {\n-            ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::Module,\n-            ScopeDef::ModuleDef(Function(func)) => {\n-                self.add_function(ctx, *func, Some(local_name));\n-                return;\n-            }\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Struct(_))) => CompletionItemKind::Struct,\n-            // FIXME: add CompletionItemKind::Union\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Union(_))) => CompletionItemKind::Struct,\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Enum(_))) => CompletionItemKind::Enum,\n-\n-            ScopeDef::ModuleDef(EnumVariant(var)) => {\n-                self.add_enum_variant(ctx, *var, Some(local_name));\n-                return;\n-            }\n-            ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::Const,\n-            ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::Static,\n-            ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::Trait,\n-            ScopeDef::ModuleDef(TypeAlias(..)) => CompletionItemKind::TypeAlias,\n-            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n-            ScopeDef::GenericParam(..) => CompletionItemKind::TypeParam,\n-            ScopeDef::Local(..) => CompletionItemKind::Binding,\n-            // (does this need its own kind?)\n-            ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => CompletionItemKind::TypeParam,\n-            ScopeDef::MacroDef(mac) => {\n-                self.add_macro(ctx, Some(local_name), *mac);\n-                return;\n-            }\n-            ScopeDef::Unknown => {\n-                CompletionItem::new(CompletionKind::Reference, ctx.source_range(), local_name)\n-                    .kind(CompletionItemKind::UnresolvedReference)\n-                    .add_to(self);\n-                return;\n-            }\n-        };\n-\n-        let docs = match resolution {\n-            ScopeDef::ModuleDef(Module(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Adt(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(EnumVariant(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Const(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Static(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Trait(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(ctx.db),\n-            _ => None,\n-        };\n-\n-        let mut item = CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n-        if let ScopeDef::Local(local) = resolution {\n-            let ty = local.ty(ctx.db);\n-            if !ty.is_unknown() {\n-                item = item.detail(ty.display(ctx.db).to_string());\n-            }\n-        };\n-\n-        let mut ref_match = None;\n-        if let ScopeDef::Local(local) = resolution {\n-            if let Some((active_name, active_type)) = ctx.active_name_and_type() {\n-                let ty = local.ty(ctx.db);\n-                if let Some(score) =\n-                    compute_score_from_active(&active_type, &active_name, &ty, &local_name)\n-                {\n-                    item = item.set_score(score);\n-                }\n-                ref_match = refed_type_matches(&active_type, &active_name, &ty, &local_name);\n-            }\n-        }\n-\n-        // Add `<>` for generic types\n-        if ctx.is_path_type && !ctx.has_type_args && ctx.config.add_call_parenthesis {\n-            if let Some(cap) = ctx.config.snippet_cap {\n-                let has_non_default_type_params = match resolution {\n-                    ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db),\n-                    ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db),\n-                    _ => false,\n-                };\n-                if has_non_default_type_params {\n-                    mark::hit!(inserts_angle_brackets_for_generics);\n-                    item = item\n-                        .lookup_by(local_name.clone())\n-                        .label(format!(\"{}<\u2026>\", local_name))\n-                        .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n-                }\n-            }\n+        if let Some(item) = Render::new(ctx.into()).render_resolution(local_name, resolution) {\n+            self.add(item);\n         }\n-\n-        item.kind(kind).set_documentation(docs).set_ref_match(ref_match).add_to(self)\n     }\n \n     pub(crate) fn add_macro(\n@@ -240,958 +129,3 @@ impl Completions {\n         self.add(item);\n     }\n }\n-\n-fn compute_score_from_active(\n-    active_type: &Type,\n-    active_name: &str,\n-    ty: &Type,\n-    name: &str,\n-) -> Option<CompletionScore> {\n-    // Compute score\n-    // For the same type\n-    if active_type != ty {\n-        return None;\n-    }\n-\n-    let mut res = CompletionScore::TypeMatch;\n-\n-    // If same type + same name then go top position\n-    if active_name == name {\n-        res = CompletionScore::TypeAndNameMatch\n-    }\n-\n-    Some(res)\n-}\n-fn refed_type_matches(\n-    active_type: &Type,\n-    active_name: &str,\n-    ty: &Type,\n-    name: &str,\n-) -> Option<(Mutability, CompletionScore)> {\n-    let derefed_active = active_type.remove_ref()?;\n-    let score = compute_score_from_active(&derefed_active, &active_name, &ty, &name)?;\n-    Some((\n-        if active_type.is_mutable_reference() { Mutability::Mut } else { Mutability::Shared },\n-        score,\n-    ))\n-}\n-\n-fn compute_score(ctx: &CompletionContext, ty: &Type, name: &str) -> Option<CompletionScore> {\n-    let (active_name, active_type) = ctx.active_name_and_type()?;\n-    compute_score_from_active(&active_type, &active_name, ty, name)\n-}\n-\n-fn is_deprecated(node: impl HasAttrs, db: &RootDatabase) -> bool {\n-    node.attrs(db).by_key(\"deprecated\").exists()\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::cmp::Reverse;\n-\n-    use expect_test::{expect, Expect};\n-    use test_utils::mark;\n-\n-    use crate::{\n-        test_utils::{check_edit, check_edit_with_config, do_completion, get_all_items},\n-        CompletionConfig, CompletionKind, CompletionScore,\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = do_completion(ra_fixture, CompletionKind::Reference);\n-        expect.assert_debug_eq(&actual);\n-    }\n-\n-    fn check_scores(ra_fixture: &str, expect: Expect) {\n-        fn display_score(score: Option<CompletionScore>) -> &'static str {\n-            match score {\n-                Some(CompletionScore::TypeMatch) => \"[type]\",\n-                Some(CompletionScore::TypeAndNameMatch) => \"[type+name]\",\n-                None => \"[]\".into(),\n-            }\n-        }\n-\n-        let mut completions = get_all_items(CompletionConfig::default(), ra_fixture);\n-        completions.sort_by_key(|it| (Reverse(it.score()), it.label().to_string()));\n-        let actual = completions\n-            .into_iter()\n-            .filter(|it| it.completion_kind == CompletionKind::Reference)\n-            .map(|it| {\n-                let tag = it.kind().unwrap().tag();\n-                let score = display_score(it.score());\n-                format!(\"{} {} {}\\n\", tag, it.label(), score)\n-            })\n-            .collect::<String>();\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn enum_detail_includes_record_fields() {\n-        check(\n-            r#\"\n-enum Foo { Foo { x: i32, y: i32 } }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo\",\n-                        source_range: 54..56,\n-                        delete: 54..56,\n-                        insert: \"Foo\",\n-                        kind: EnumVariant,\n-                        detail: \"{ x: i32, y: i32 }\",\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_detail_doesnt_include_tuple_fields() {\n-        check(\n-            r#\"\n-enum Foo { Foo (i32, i32) }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo(\u2026)\",\n-                        source_range: 46..48,\n-                        delete: 46..48,\n-                        insert: \"Foo($0)\",\n-                        kind: EnumVariant,\n-                        lookup: \"Foo\",\n-                        detail: \"(i32, i32)\",\n-                        trigger_call_info: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_detail_just_parentheses_for_unit() {\n-        check(\n-            r#\"\n-enum Foo { Foo }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo\",\n-                        source_range: 35..37,\n-                        delete: 35..37,\n-                        insert: \"Foo\",\n-                        kind: EnumVariant,\n-                        detail: \"()\",\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn lookup_enums_by_two_qualifiers() {\n-        check(\n-            r#\"\n-mod m {\n-    pub enum Spam { Foo, Bar(i32) }\n-}\n-fn main() { let _: m::Spam = S<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Spam::Bar(\u2026)\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"Spam::Bar($0)\",\n-                        kind: EnumVariant,\n-                        lookup: \"Spam::Bar\",\n-                        detail: \"(i32)\",\n-                        trigger_call_info: true,\n-                    },\n-                    CompletionItem {\n-                        label: \"m\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"m\",\n-                        kind: Module,\n-                    },\n-                    CompletionItem {\n-                        label: \"m::Spam::Foo\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"m::Spam::Foo\",\n-                        kind: EnumVariant,\n-                        lookup: \"Spam::Foo\",\n-                        detail: \"()\",\n-                    },\n-                    CompletionItem {\n-                        label: \"main()\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"main()$0\",\n-                        kind: Function,\n-                        lookup: \"main\",\n-                        detail: \"fn main()\",\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn sets_deprecated_flag_in_items() {\n-        check(\n-            r#\"\n-#[deprecated]\n-fn something_deprecated() {}\n-#[deprecated(since = \"1.0.0\")]\n-fn something_else_deprecated() {}\n-\n-fn main() { som<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"main()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"main()$0\",\n-                        kind: Function,\n-                        lookup: \"main\",\n-                        detail: \"fn main()\",\n-                    },\n-                    CompletionItem {\n-                        label: \"something_deprecated()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"something_deprecated()$0\",\n-                        kind: Function,\n-                        lookup: \"something_deprecated\",\n-                        detail: \"fn something_deprecated()\",\n-                        deprecated: true,\n-                    },\n-                    CompletionItem {\n-                        label: \"something_else_deprecated()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"something_else_deprecated()$0\",\n-                        kind: Function,\n-                        lookup: \"something_else_deprecated\",\n-                        detail: \"fn something_else_deprecated()\",\n-                        deprecated: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-struct A { #[deprecated] the_field: u32 }\n-fn foo() { A { the<|> } }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"the_field\",\n-                        source_range: 57..60,\n-                        delete: 57..60,\n-                        insert: \"the_field\",\n-                        kind: Field,\n-                        detail: \"u32\",\n-                        deprecated: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn renders_docs() {\n-        check(\n-            r#\"\n-struct S {\n-    /// Field docs\n-    foo:\n-}\n-impl S {\n-    /// Method docs\n-    fn bar(self) { self.<|> }\n-}\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"bar()\",\n-                        source_range: 94..94,\n-                        delete: 94..94,\n-                        insert: \"bar()$0\",\n-                        kind: Method,\n-                        lookup: \"bar\",\n-                        detail: \"fn bar(self)\",\n-                        documentation: Documentation(\n-                            \"Method docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"foo\",\n-                        source_range: 94..94,\n-                        delete: 94..94,\n-                        insert: \"foo\",\n-                        kind: Field,\n-                        detail: \"{unknown}\",\n-                        documentation: Documentation(\n-                            \"Field docs\",\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-use self::my<|>;\n-\n-/// mod docs\n-mod my { }\n-\n-/// enum docs\n-enum E {\n-    /// variant docs\n-    V\n-}\n-use self::E::*;\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"E\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"E\",\n-                        kind: Enum,\n-                        documentation: Documentation(\n-                            \"enum docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"V\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"V\",\n-                        kind: EnumVariant,\n-                        detail: \"()\",\n-                        documentation: Documentation(\n-                            \"variant docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"my\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"my\",\n-                        kind: Module,\n-                        documentation: Documentation(\n-                            \"mod docs\",\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn dont_render_attrs() {\n-        check(\n-            r#\"\n-struct S;\n-impl S {\n-    #[inline]\n-    fn the_method(&self) { }\n-}\n-fn foo(s: S) { s.<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"the_method()\",\n-                        source_range: 81..81,\n-                        delete: 81..81,\n-                        insert: \"the_method()$0\",\n-                        kind: Method,\n-                        lookup: \"the_method\",\n-                        detail: \"fn the_method(&self)\",\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn inserts_parens_for_function_calls() {\n-        mark::check!(inserts_parens_for_function_calls);\n-        check_edit(\n-            \"no_args\",\n-            r#\"\n-fn no_args() {}\n-fn main() { no_<|> }\n-\"#,\n-            r#\"\n-fn no_args() {}\n-fn main() { no_args()$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"with_args\",\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_<|> }\n-\"#,\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_args(${1:x}, ${2:y})$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self) {}\n-}\n-fn bar(s: &S) { s.f<|> }\n-\"#,\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self) {}\n-}\n-fn bar(s: &S) { s.foo()$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct S {}\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-fn bar(s: &S) {\n-    s.f<|>\n-}\n-\"#,\n-            r#\"\n-struct S {}\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-fn bar(s: &S) {\n-    s.foo(${1:x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn suppress_arg_snippets() {\n-        mark::check!(suppress_arg_snippets);\n-        check_edit_with_config(\n-            CompletionConfig { add_call_argument_snippets: false, ..CompletionConfig::default() },\n-            \"with_args\",\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_<|> }\n-\"#,\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_args($0) }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn strips_underscores_from_args() {\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n-fn main() { f<|> }\n-\"#,\n-            r#\"\n-fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n-fn main() { foo(${1:foo}, ${2:bar}, ${3:ho_ge_})$0 }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_ref_when_matching_local_in_scope() {\n-        check_edit(\n-            \"ref_arg\",\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_ar<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_arg(${1:&x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_mut_ref_when_matching_local_in_scope() {\n-        check_edit(\n-            \"ref_arg\",\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &mut Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_ar<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &mut Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_arg(${1:&mut x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_ref_when_matching_local_in_scope_for_method() {\n-        check_edit(\n-            \"apply_foo\",\n-            r#\"\n-struct Foo {}\n-struct Bar {}\n-impl Bar {\n-    fn apply_foo(&self, x: &Foo) {}\n-}\n-\n-fn main() {\n-    let x = Foo {};\n-    let y = Bar {};\n-    y.<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-struct Bar {}\n-impl Bar {\n-    fn apply_foo(&self, x: &Foo) {}\n-}\n-\n-fn main() {\n-    let x = Foo {};\n-    let y = Bar {};\n-    y.apply_foo(${1:&x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn trim_mut_keyword_in_func_completion() {\n-        check_edit(\n-            \"take_mutably\",\n-            r#\"\n-fn take_mutably(mut x: &i32) {}\n-\n-fn main() {\n-    take_m<|>\n-}\n-\"#,\n-            r#\"\n-fn take_mutably(mut x: &i32) {}\n-\n-fn main() {\n-    take_mutably(${1:x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn inserts_parens_for_tuple_enums() {\n-        mark::check!(inserts_parens_for_tuple_enums);\n-        check_edit(\n-            \"Some\",\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main() -> Option<i32> {\n-    Som<|>\n-}\n-\"#,\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main() -> Option<i32> {\n-    Some($0)\n-}\n-\"#,\n-        );\n-        check_edit(\n-            \"Some\",\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main(value: Option<i32>) {\n-    match value {\n-        Som<|>\n-    }\n-}\n-\"#,\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main(value: Option<i32>) {\n-    match value {\n-        Some($0)\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_duplicate_pattern_parens() {\n-        mark::check!(dont_duplicate_pattern_parens);\n-        check_edit(\n-            \"Var\",\n-            r#\"\n-enum E { Var(i32) }\n-fn main() {\n-    match E::Var(92) {\n-        E::<|>(92) => (),\n-    }\n-}\n-\"#,\n-            r#\"\n-enum E { Var(i32) }\n-fn main() {\n-    match E::Var(92) {\n-        E::Var(92) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_call_parens_if_fn_ptr_needed() {\n-        mark::check!(no_call_parens_if_fn_ptr_needed);\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(foo: u8, bar: u8) {}\n-struct ManualVtable { f: fn(u8, u8) }\n-\n-fn main() -> ManualVtable {\n-    ManualVtable { f: f<|> }\n-}\n-\"#,\n-            r#\"\n-fn foo(foo: u8, bar: u8) {}\n-struct ManualVtable { f: fn(u8, u8) }\n-\n-fn main() -> ManualVtable {\n-    ManualVtable { f: foo }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_parens_in_use_item() {\n-        mark::check!(no_parens_in_use_item);\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-mod m { pub fn foo() {} }\n-use crate::m::f<|>;\n-\"#,\n-            r#\"\n-mod m { pub fn foo() {} }\n-use crate::m::foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_parens_in_call() {\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(x: i32) {}\n-fn main() { f<|>(); }\n-\"#,\n-            r#\"\n-fn foo(x: i32) {}\n-fn main() { foo(); }\n-\"#,\n-        );\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct Foo;\n-impl Foo { fn foo(&self){} }\n-fn f(foo: &Foo) { foo.f<|>(); }\n-\"#,\n-            r#\"\n-struct Foo;\n-impl Foo { fn foo(&self){} }\n-fn f(foo: &Foo) { foo.foo(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn inserts_angle_brackets_for_generics() {\n-        mark::check!(inserts_angle_brackets_for_generics);\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Vec<$0>)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-type Vec<T> = (T,);\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-type Vec<T> = (T,);\n-fn foo(xs: Vec<$0>)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T = i128> {}\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-struct Vec<T = i128> {}\n-fn foo(xs: Vec)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Ve<|><i128>)\n-\"#,\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Vec<i128>)\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_insert_macro_call_parens_unncessary() {\n-        mark::check!(dont_insert_macro_call_parens_unncessary);\n-        check_edit(\n-            \"frobnicate!\",\n-            r#\"\n-//- /main.rs crate:main deps:foo\n-use foo::<|>;\n-//- /foo/lib.rs crate:foo\n-#[macro_export]\n-macro_rules frobnicate { () => () }\n-\"#,\n-            r#\"\n-use foo::frobnicate;\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"frobnicate!\",\n-            r#\"\n-macro_rules frobnicate { () => () }\n-fn main() { frob<|>!(); }\n-\"#,\n-            r#\"\n-macro_rules frobnicate { () => () }\n-fn main() { frobnicate!(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn active_param_score() {\n-        mark::check!(active_param_type_match);\n-        check_scores(\n-            r#\"\n-struct S { foo: i64, bar: u32, baz: u32 }\n-fn test(bar: u32) { }\n-fn foo(s: S) { test(s.<|>) }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn record_field_scores() {\n-        mark::check!(record_field_type_match);\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn foo(a: A) { B { bar: a.<|> }; }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn record_field_and_call_scores() {\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn f(foo: i64) {  }\n-fn foo(a: A) { B { bar: f(a.<|>) }; }\n-\"#,\n-            expect![[r#\"\n-                fd foo [type+name]\n-                fd bar []\n-                fd baz []\n-            \"#]],\n-        );\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn f(foo: i64) {  }\n-fn foo(a: A) { f(B { bar: a.<|> }); }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn prioritize_exact_ref_match() {\n-        check_scores(\n-            r#\"\n-struct WorldSnapshot { _f: () };\n-fn go(world: &WorldSnapshot) { go(w<|>) }\n-\"#,\n-            expect![[r#\"\n-                bn world [type+name]\n-                st WorldSnapshot []\n-                fn go(\u2026) []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn too_many_arguments() {\n-        check_scores(\n-            r#\"\n-struct Foo;\n-fn f(foo: &Foo) { f(foo, w<|>) }\n-\"#,\n-            expect![[r#\"\n-                st Foo []\n-                fn f(\u2026) []\n-                bn foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn guesses_macro_braces() {\n-        check_edit(\n-            \"vec!\",\n-            r#\"\n-/// Creates a [`Vec`] containing the arguments.\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-macro_rules! vec { () => {} }\n-\n-fn fn main() { v<|> }\n-\"#,\n-            r#\"\n-/// Creates a [`Vec`] containing the arguments.\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-macro_rules! vec { () => {} }\n-\n-fn fn main() { vec![$0] }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo!\",\n-            r#\"\n-/// Foo\n-///\n-/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n-/// call as `let _=foo!  { hello world };`\n-macro_rules! foo { () => {} }\n-fn main() { <|> }\n-\"#,\n-            r#\"\n-/// Foo\n-///\n-/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n-/// call as `let _=foo!  { hello world };`\n-macro_rules! foo { () => {} }\n-fn main() { foo! {$0} }\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "bf70ee478e31f4f1fe20474ba0405890e2fc4e66", "filename": "crates/completion/src/context.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcontext.rs?ref=97a504805d4b0cf8b48bc5052453b2b2f3298449", "patch": "@@ -245,19 +245,6 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n-    pub(crate) fn active_name_and_type(&self) -> Option<(String, Type)> {\n-        if let Some(record_field) = &self.record_field_syntax {\n-            mark::hit!(record_field_type_match);\n-            let (struct_field, _local) = self.sema.resolve_record_field(record_field)?;\n-            Some((struct_field.name(self.db).to_string(), struct_field.signature_ty(self.db)))\n-        } else if let Some(active_parameter) = &self.active_parameter {\n-            mark::hit!(active_param_type_match);\n-            Some((active_parameter.name.clone(), active_parameter.ty.clone()))\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);"}, {"sha": "28731e04f4b178691070ff68a40272a4f0e57b0f", "filename": "crates/completion/src/render.rs", "status": "modified", "additions": 781, "deletions": 8, "changes": 789, "blob_url": "https://github.com/rust-lang/rust/blob/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=97a504805d4b0cf8b48bc5052453b2b2f3298449", "patch": "@@ -8,11 +8,15 @@ mod enum_variant;\n mod const_;\n mod type_alias;\n \n-use hir::{Documentation, HasAttrs};\n+use hir::{Documentation, HasAttrs, HirDisplay, Mutability, ScopeDef, Type};\n use ide_db::RootDatabase;\n use syntax::TextRange;\n+use test_utils::mark;\n \n-use crate::{config::SnippetCap, CompletionContext};\n+use crate::{\n+    config::SnippetCap, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n+    CompletionScore,\n+};\n \n pub(crate) use crate::render::{\n     const_::ConstRender, enum_variant::EnumVariantRender, function::FunctionRender,\n@@ -25,33 +29,802 @@ pub(crate) struct RenderContext<'a> {\n }\n \n impl<'a> RenderContext<'a> {\n-    pub fn new(completion: &'a CompletionContext<'a>) -> RenderContext<'a> {\n+    fn new(completion: &'a CompletionContext<'a>) -> RenderContext<'a> {\n         RenderContext { completion }\n     }\n \n-    pub fn snippet_cap(&self) -> Option<SnippetCap> {\n+    fn snippet_cap(&self) -> Option<SnippetCap> {\n         self.completion.config.snippet_cap.clone()\n     }\n \n-    pub fn db(&self) -> &'a RootDatabase {\n+    fn db(&self) -> &'a RootDatabase {\n         &self.completion.db\n     }\n \n-    pub fn source_range(&self) -> TextRange {\n+    fn source_range(&self) -> TextRange {\n         self.completion.source_range()\n     }\n \n-    pub fn is_deprecated(&self, node: impl HasAttrs) -> bool {\n+    fn is_deprecated(&self, node: impl HasAttrs) -> bool {\n         node.attrs(self.db()).by_key(\"deprecated\").exists()\n     }\n \n-    pub fn docs(&self, node: impl HasAttrs) -> Option<Documentation> {\n+    fn docs(&self, node: impl HasAttrs) -> Option<Documentation> {\n         node.docs(self.db())\n     }\n+\n+    fn active_name_and_type(&self) -> Option<(String, Type)> {\n+        if let Some(record_field) = &self.completion.record_field_syntax {\n+            mark::hit!(record_field_type_match);\n+            let (struct_field, _local) = self.completion.sema.resolve_record_field(record_field)?;\n+            Some((struct_field.name(self.db()).to_string(), struct_field.signature_ty(self.db())))\n+        } else if let Some(active_parameter) = &self.completion.active_parameter {\n+            mark::hit!(active_param_type_match);\n+            Some((active_parameter.name.clone(), active_parameter.ty.clone()))\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl<'a> From<&'a CompletionContext<'a>> for RenderContext<'a> {\n     fn from(ctx: &'a CompletionContext<'a>) -> RenderContext<'a> {\n         RenderContext::new(ctx)\n     }\n }\n+\n+#[derive(Debug)]\n+pub(crate) struct Render<'a> {\n+    ctx: RenderContext<'a>,\n+}\n+\n+impl<'a> Render<'a> {\n+    pub(crate) fn new(ctx: RenderContext<'a>) -> Render<'a> {\n+        Render { ctx }\n+    }\n+\n+    pub(crate) fn add_field(&mut self, field: hir::Field, ty: &Type) -> CompletionItem {\n+        let is_deprecated = self.ctx.is_deprecated(field);\n+        let name = field.name(self.ctx.db());\n+        let mut item = CompletionItem::new(\n+            CompletionKind::Reference,\n+            self.ctx.source_range(),\n+            name.to_string(),\n+        )\n+        .kind(CompletionItemKind::Field)\n+        .detail(ty.display(self.ctx.db()).to_string())\n+        .set_documentation(field.docs(self.ctx.db()))\n+        .set_deprecated(is_deprecated);\n+\n+        if let Some(score) = compute_score(&self.ctx, &ty, &name.to_string()) {\n+            item = item.set_score(score);\n+        }\n+\n+        return item.build();\n+    }\n+\n+    pub(crate) fn add_tuple_field(&mut self, field: usize, ty: &Type) -> CompletionItem {\n+        CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), field.to_string())\n+            .kind(CompletionItemKind::Field)\n+            .detail(ty.display(self.ctx.db()).to_string())\n+            .build()\n+    }\n+\n+    pub(crate) fn render_resolution(\n+        self,\n+        local_name: String,\n+        resolution: &ScopeDef,\n+    ) -> Option<CompletionItem> {\n+        use hir::ModuleDef::*;\n+\n+        let completion_kind = match resolution {\n+            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n+            _ => CompletionKind::Reference,\n+        };\n+\n+        let kind = match resolution {\n+            ScopeDef::ModuleDef(Function(func)) => {\n+                let item = FunctionRender::new(self.ctx, Some(local_name), *func).render();\n+                return Some(item);\n+            }\n+            ScopeDef::ModuleDef(EnumVariant(var)) => {\n+                let item = EnumVariantRender::new(self.ctx, Some(local_name), *var, None).render();\n+                return Some(item);\n+            }\n+            ScopeDef::MacroDef(mac) => {\n+                let item = MacroRender::new(self.ctx, local_name, *mac).render();\n+                return item;\n+            }\n+\n+            ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::Module,\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Struct(_))) => CompletionItemKind::Struct,\n+            // FIXME: add CompletionItemKind::Union\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Union(_))) => CompletionItemKind::Struct,\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Enum(_))) => CompletionItemKind::Enum,\n+            ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::Const,\n+            ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::Static,\n+            ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::Trait,\n+            ScopeDef::ModuleDef(TypeAlias(..)) => CompletionItemKind::TypeAlias,\n+            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n+            ScopeDef::GenericParam(..) => CompletionItemKind::TypeParam,\n+            ScopeDef::Local(..) => CompletionItemKind::Binding,\n+            // (does this need its own kind?)\n+            ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => CompletionItemKind::TypeParam,\n+            ScopeDef::Unknown => {\n+                let item = CompletionItem::new(\n+                    CompletionKind::Reference,\n+                    self.ctx.source_range(),\n+                    local_name,\n+                )\n+                .kind(CompletionItemKind::UnresolvedReference)\n+                .build();\n+                return Some(item);\n+            }\n+        };\n+\n+        let docs = self.docs(resolution);\n+\n+        let mut item =\n+            CompletionItem::new(completion_kind, self.ctx.source_range(), local_name.clone());\n+        if let ScopeDef::Local(local) = resolution {\n+            let ty = local.ty(self.ctx.db());\n+            if !ty.is_unknown() {\n+                item = item.detail(ty.display(self.ctx.db()).to_string());\n+            }\n+        };\n+\n+        let mut ref_match = None;\n+        if let ScopeDef::Local(local) = resolution {\n+            if let Some((active_name, active_type)) = self.ctx.active_name_and_type() {\n+                let ty = local.ty(self.ctx.db());\n+                if let Some(score) =\n+                    compute_score_from_active(&active_type, &active_name, &ty, &local_name)\n+                {\n+                    item = item.set_score(score);\n+                }\n+                ref_match = refed_type_matches(&active_type, &active_name, &ty, &local_name);\n+            }\n+        }\n+\n+        // Add `<>` for generic types\n+        if self.ctx.completion.is_path_type\n+            && !self.ctx.completion.has_type_args\n+            && self.ctx.completion.config.add_call_parenthesis\n+        {\n+            if let Some(cap) = self.ctx.snippet_cap() {\n+                let has_non_default_type_params = match resolution {\n+                    ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(self.ctx.db()),\n+                    ScopeDef::ModuleDef(TypeAlias(it)) => {\n+                        it.has_non_default_type_params(self.ctx.db())\n+                    }\n+                    _ => false,\n+                };\n+                if has_non_default_type_params {\n+                    mark::hit!(inserts_angle_brackets_for_generics);\n+                    item = item\n+                        .lookup_by(local_name.clone())\n+                        .label(format!(\"{}<\u2026>\", local_name))\n+                        .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n+                }\n+            }\n+        }\n+\n+        let item = item.kind(kind).set_documentation(docs).set_ref_match(ref_match).build();\n+        Some(item)\n+    }\n+\n+    fn docs(&self, resolution: &ScopeDef) -> Option<Documentation> {\n+        use hir::ModuleDef::*;\n+        match resolution {\n+            ScopeDef::ModuleDef(Module(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(Adt(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(EnumVariant(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(Const(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(Static(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(Trait(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(self.ctx.db()),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+fn compute_score_from_active(\n+    active_type: &Type,\n+    active_name: &str,\n+    ty: &Type,\n+    name: &str,\n+) -> Option<CompletionScore> {\n+    // Compute score\n+    // For the same type\n+    if active_type != ty {\n+        return None;\n+    }\n+\n+    let mut res = CompletionScore::TypeMatch;\n+\n+    // If same type + same name then go top position\n+    if active_name == name {\n+        res = CompletionScore::TypeAndNameMatch\n+    }\n+\n+    Some(res)\n+}\n+fn refed_type_matches(\n+    active_type: &Type,\n+    active_name: &str,\n+    ty: &Type,\n+    name: &str,\n+) -> Option<(Mutability, CompletionScore)> {\n+    let derefed_active = active_type.remove_ref()?;\n+    let score = compute_score_from_active(&derefed_active, &active_name, &ty, &name)?;\n+    Some((\n+        if active_type.is_mutable_reference() { Mutability::Mut } else { Mutability::Shared },\n+        score,\n+    ))\n+}\n+\n+fn compute_score(ctx: &RenderContext, ty: &Type, name: &str) -> Option<CompletionScore> {\n+    let (active_name, active_type) = ctx.active_name_and_type()?;\n+    compute_score_from_active(&active_type, &active_name, ty, name)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::cmp::Reverse;\n+\n+    use expect_test::{expect, Expect};\n+    use test_utils::mark;\n+\n+    use crate::{\n+        test_utils::{check_edit, do_completion, get_all_items},\n+        CompletionConfig, CompletionKind, CompletionScore,\n+    };\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = do_completion(ra_fixture, CompletionKind::Reference);\n+        expect.assert_debug_eq(&actual);\n+    }\n+\n+    fn check_scores(ra_fixture: &str, expect: Expect) {\n+        fn display_score(score: Option<CompletionScore>) -> &'static str {\n+            match score {\n+                Some(CompletionScore::TypeMatch) => \"[type]\",\n+                Some(CompletionScore::TypeAndNameMatch) => \"[type+name]\",\n+                None => \"[]\".into(),\n+            }\n+        }\n+\n+        let mut completions = get_all_items(CompletionConfig::default(), ra_fixture);\n+        completions.sort_by_key(|it| (Reverse(it.score()), it.label().to_string()));\n+        let actual = completions\n+            .into_iter()\n+            .filter(|it| it.completion_kind == CompletionKind::Reference)\n+            .map(|it| {\n+                let tag = it.kind().unwrap().tag();\n+                let score = display_score(it.score());\n+                format!(\"{} {} {}\\n\", tag, it.label(), score)\n+            })\n+            .collect::<String>();\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn enum_detail_includes_record_fields() {\n+        check(\n+            r#\"\n+enum Foo { Foo { x: i32, y: i32 } }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo\",\n+                        source_range: 54..56,\n+                        delete: 54..56,\n+                        insert: \"Foo\",\n+                        kind: EnumVariant,\n+                        detail: \"{ x: i32, y: i32 }\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_detail_doesnt_include_tuple_fields() {\n+        check(\n+            r#\"\n+enum Foo { Foo (i32, i32) }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo(\u2026)\",\n+                        source_range: 46..48,\n+                        delete: 46..48,\n+                        insert: \"Foo($0)\",\n+                        kind: EnumVariant,\n+                        lookup: \"Foo\",\n+                        detail: \"(i32, i32)\",\n+                        trigger_call_info: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_detail_just_parentheses_for_unit() {\n+        check(\n+            r#\"\n+enum Foo { Foo }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo\",\n+                        source_range: 35..37,\n+                        delete: 35..37,\n+                        insert: \"Foo\",\n+                        kind: EnumVariant,\n+                        detail: \"()\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn lookup_enums_by_two_qualifiers() {\n+        check(\n+            r#\"\n+mod m {\n+    pub enum Spam { Foo, Bar(i32) }\n+}\n+fn main() { let _: m::Spam = S<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Spam::Bar(\u2026)\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"Spam::Bar($0)\",\n+                        kind: EnumVariant,\n+                        lookup: \"Spam::Bar\",\n+                        detail: \"(i32)\",\n+                        trigger_call_info: true,\n+                    },\n+                    CompletionItem {\n+                        label: \"m\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"m\",\n+                        kind: Module,\n+                    },\n+                    CompletionItem {\n+                        label: \"m::Spam::Foo\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"m::Spam::Foo\",\n+                        kind: EnumVariant,\n+                        lookup: \"Spam::Foo\",\n+                        detail: \"()\",\n+                    },\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"main()$0\",\n+                        kind: Function,\n+                        lookup: \"main\",\n+                        detail: \"fn main()\",\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn sets_deprecated_flag_in_items() {\n+        check(\n+            r#\"\n+#[deprecated]\n+fn something_deprecated() {}\n+#[deprecated(since = \"1.0.0\")]\n+fn something_else_deprecated() {}\n+\n+fn main() { som<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"main()$0\",\n+                        kind: Function,\n+                        lookup: \"main\",\n+                        detail: \"fn main()\",\n+                    },\n+                    CompletionItem {\n+                        label: \"something_deprecated()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"something_deprecated()$0\",\n+                        kind: Function,\n+                        lookup: \"something_deprecated\",\n+                        detail: \"fn something_deprecated()\",\n+                        deprecated: true,\n+                    },\n+                    CompletionItem {\n+                        label: \"something_else_deprecated()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"something_else_deprecated()$0\",\n+                        kind: Function,\n+                        lookup: \"something_else_deprecated\",\n+                        detail: \"fn something_else_deprecated()\",\n+                        deprecated: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+struct A { #[deprecated] the_field: u32 }\n+fn foo() { A { the<|> } }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_field\",\n+                        source_range: 57..60,\n+                        delete: 57..60,\n+                        insert: \"the_field\",\n+                        kind: Field,\n+                        detail: \"u32\",\n+                        deprecated: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn renders_docs() {\n+        check(\n+            r#\"\n+struct S {\n+    /// Field docs\n+    foo:\n+}\n+impl S {\n+    /// Method docs\n+    fn bar(self) { self.<|> }\n+}\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"bar()\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"bar()$0\",\n+                        kind: Method,\n+                        lookup: \"bar\",\n+                        detail: \"fn bar(self)\",\n+                        documentation: Documentation(\n+                            \"Method docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"foo\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"foo\",\n+                        kind: Field,\n+                        detail: \"{unknown}\",\n+                        documentation: Documentation(\n+                            \"Field docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+use self::my<|>;\n+\n+/// mod docs\n+mod my { }\n+\n+/// enum docs\n+enum E {\n+    /// variant docs\n+    V\n+}\n+use self::E::*;\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"E\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"E\",\n+                        kind: Enum,\n+                        documentation: Documentation(\n+                            \"enum docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"V\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"V\",\n+                        kind: EnumVariant,\n+                        detail: \"()\",\n+                        documentation: Documentation(\n+                            \"variant docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"my\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"my\",\n+                        kind: Module,\n+                        documentation: Documentation(\n+                            \"mod docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_render_attrs() {\n+        check(\n+            r#\"\n+struct S;\n+impl S {\n+    #[inline]\n+    fn the_method(&self) { }\n+}\n+fn foo(s: S) { s.<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_method()\",\n+                        source_range: 81..81,\n+                        delete: 81..81,\n+                        insert: \"the_method()$0\",\n+                        kind: Method,\n+                        lookup: \"the_method\",\n+                        detail: \"fn the_method(&self)\",\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn no_call_parens_if_fn_ptr_needed() {\n+        mark::check!(no_call_parens_if_fn_ptr_needed);\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(foo: u8, bar: u8) {}\n+struct ManualVtable { f: fn(u8, u8) }\n+\n+fn main() -> ManualVtable {\n+    ManualVtable { f: f<|> }\n+}\n+\"#,\n+            r#\"\n+fn foo(foo: u8, bar: u8) {}\n+struct ManualVtable { f: fn(u8, u8) }\n+\n+fn main() -> ManualVtable {\n+    ManualVtable { f: foo }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_parens_in_use_item() {\n+        mark::check!(no_parens_in_use_item);\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+mod m { pub fn foo() {} }\n+use crate::m::f<|>;\n+\"#,\n+            r#\"\n+mod m { pub fn foo() {} }\n+use crate::m::foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_parens_in_call() {\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(x: i32) {}\n+fn main() { f<|>(); }\n+\"#,\n+            r#\"\n+fn foo(x: i32) {}\n+fn main() { foo(); }\n+\"#,\n+        );\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct Foo;\n+impl Foo { fn foo(&self){} }\n+fn f(foo: &Foo) { foo.f<|>(); }\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo { fn foo(&self){} }\n+fn f(foo: &Foo) { foo.foo(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inserts_angle_brackets_for_generics() {\n+        mark::check!(inserts_angle_brackets_for_generics);\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Vec<$0>)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+type Vec<T> = (T,);\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+type Vec<T> = (T,);\n+fn foo(xs: Vec<$0>)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T = i128> {}\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+struct Vec<T = i128> {}\n+fn foo(xs: Vec)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Ve<|><i128>)\n+\"#,\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Vec<i128>)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn active_param_score() {\n+        mark::check!(active_param_type_match);\n+        check_scores(\n+            r#\"\n+struct S { foo: i64, bar: u32, baz: u32 }\n+fn test(bar: u32) { }\n+fn foo(s: S) { test(s.<|>) }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn record_field_scores() {\n+        mark::check!(record_field_type_match);\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn foo(a: A) { B { bar: a.<|> }; }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn record_field_and_call_scores() {\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn f(foo: i64) {  }\n+fn foo(a: A) { B { bar: f(a.<|>) }; }\n+\"#,\n+            expect![[r#\"\n+                fd foo [type+name]\n+                fd bar []\n+                fd baz []\n+            \"#]],\n+        );\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn f(foo: i64) {  }\n+fn foo(a: A) { f(B { bar: a.<|> }); }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn prioritize_exact_ref_match() {\n+        check_scores(\n+            r#\"\n+struct WorldSnapshot { _f: () };\n+fn go(world: &WorldSnapshot) { go(w<|>) }\n+\"#,\n+            expect![[r#\"\n+                bn world [type+name]\n+                st WorldSnapshot []\n+                fn go(\u2026) []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn too_many_arguments() {\n+        check_scores(\n+            r#\"\n+struct Foo;\n+fn f(foo: &Foo) { f(foo, w<|>) }\n+\"#,\n+            expect![[r#\"\n+                st Foo []\n+                fn f(\u2026) []\n+                bn foo []\n+            \"#]],\n+        );\n+    }\n+}"}, {"sha": "bc96cc303627871e1afa8482aa684853a6659132", "filename": "crates/completion/src/render/enum_variant.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs?ref=97a504805d4b0cf8b48bc5052453b2b2f3298449", "patch": "@@ -93,3 +93,77 @@ impl<'a> EnumVariantRender<'a> {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::mark;\n+\n+    use crate::test_utils::check_edit;\n+\n+    #[test]\n+    fn inserts_parens_for_tuple_enums() {\n+        mark::check!(inserts_parens_for_tuple_enums);\n+        check_edit(\n+            \"Some\",\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main() -> Option<i32> {\n+    Som<|>\n+}\n+\"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main() -> Option<i32> {\n+    Some($0)\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"Some\",\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main(value: Option<i32>) {\n+    match value {\n+        Som<|>\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main(value: Option<i32>) {\n+    match value {\n+        Some($0)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn dont_duplicate_pattern_parens() {\n+        mark::check!(dont_duplicate_pattern_parens);\n+        check_edit(\n+            \"Var\",\n+            r#\"\n+enum E { Var(i32) }\n+fn main() {\n+    match E::Var(92) {\n+        E::<|>(92) => (),\n+    }\n+}\n+\"#,\n+            r#\"\n+enum E { Var(i32) }\n+fn main() {\n+    match E::Var(92) {\n+        E::Var(92) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "cf3852bf66544c3cb7427c7fad55b8886764aafa", "filename": "crates/completion/src/render/function.rs", "status": "modified", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs?ref=97a504805d4b0cf8b48bc5052453b2b2f3298449", "patch": "@@ -81,3 +81,213 @@ impl<'a> FunctionRender<'a> {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::mark;\n+\n+    use crate::{\n+        test_utils::{check_edit, check_edit_with_config},\n+        CompletionConfig,\n+    };\n+\n+    #[test]\n+    fn inserts_parens_for_function_calls() {\n+        mark::check!(inserts_parens_for_function_calls);\n+        check_edit(\n+            \"no_args\",\n+            r#\"\n+fn no_args() {}\n+fn main() { no_<|> }\n+\"#,\n+            r#\"\n+fn no_args() {}\n+fn main() { no_args()$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"with_args\",\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_<|> }\n+\"#,\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_args(${1:x}, ${2:y})$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self) {}\n+}\n+fn bar(s: &S) { s.f<|> }\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self) {}\n+}\n+fn bar(s: &S) { s.foo()$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct S {}\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+fn bar(s: &S) {\n+    s.f<|>\n+}\n+\"#,\n+            r#\"\n+struct S {}\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+fn bar(s: &S) {\n+    s.foo(${1:x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn suppress_arg_snippets() {\n+        mark::check!(suppress_arg_snippets);\n+        check_edit_with_config(\n+            CompletionConfig { add_call_argument_snippets: false, ..CompletionConfig::default() },\n+            \"with_args\",\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_<|> }\n+\"#,\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_args($0) }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn strips_underscores_from_args() {\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n+fn main() { f<|> }\n+\"#,\n+            r#\"\n+fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n+fn main() { foo(${1:foo}, ${2:bar}, ${3:ho_ge_})$0 }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_mut_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&mut x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope_for_method() {\n+        check_edit(\n+            \"apply_foo\",\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.apply_foo(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trim_mut_keyword_in_func_completion() {\n+        check_edit(\n+            \"take_mutably\",\n+            r#\"\n+fn take_mutably(mut x: &i32) {}\n+\n+fn main() {\n+    take_m<|>\n+}\n+\"#,\n+            r#\"\n+fn take_mutably(mut x: &i32) {}\n+\n+fn main() {\n+    take_mutably(${1:x})$0\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "6df121c66df0c05dd1cdee6dbf7c13c525b60866", "filename": "crates/completion/src/render/macro_.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a504805d4b0cf8b48bc5052453b2b2f3298449/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs?ref=97a504805d4b0cf8b48bc5052453b2b2f3298449", "patch": "@@ -114,3 +114,93 @@ fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static s\n         .unwrap();\n     (*bra, *ket)\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::mark;\n+\n+    use crate::test_utils::check_edit;\n+\n+    #[test]\n+    fn dont_insert_macro_call_parens_unncessary() {\n+        mark::check!(dont_insert_macro_call_parens_unncessary);\n+        check_edit(\n+            \"frobnicate!\",\n+            r#\"\n+//- /main.rs crate:main deps:foo\n+use foo::<|>;\n+//- /foo/lib.rs crate:foo\n+#[macro_export]\n+macro_rules frobnicate { () => () }\n+\"#,\n+            r#\"\n+use foo::frobnicate;\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"frobnicate!\",\n+            r#\"\n+macro_rules frobnicate { () => () }\n+fn main() { frob<|>!(); }\n+\"#,\n+            r#\"\n+macro_rules frobnicate { () => () }\n+fn main() { frobnicate!(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_macro_braces() {\n+        check_edit(\n+            \"vec!\",\n+            r#\"\n+/// Creates a [`Vec`] containing the arguments.\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+macro_rules! vec { () => {} }\n+\n+fn fn main() { v<|> }\n+\"#,\n+            r#\"\n+/// Creates a [`Vec`] containing the arguments.\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+macro_rules! vec { () => {} }\n+\n+fn fn main() { vec![$0] }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo!\",\n+            r#\"\n+/// Foo\n+///\n+/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n+/// call as `let _=foo!  { hello world };`\n+macro_rules! foo { () => {} }\n+fn main() { <|> }\n+\"#,\n+            r#\"\n+/// Foo\n+///\n+/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n+/// call as `let _=foo!  { hello world };`\n+macro_rules! foo { () => {} }\n+fn main() { foo! {$0} }\n+\"#,\n+        )\n+    }\n+}"}]}