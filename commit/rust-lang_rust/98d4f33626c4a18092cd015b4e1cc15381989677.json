{"sha": "98d4f33626c4a18092cd015b4e1cc15381989677", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZDRmMzM2MjZjNGExODA5MmNkMDE1YjRlMWNjMTUzODE5ODk2Nzc=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2019-01-16T19:45:53Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2019-01-20T18:08:14Z"}, "message": "const_eval: Predetermine the layout of all locals when pushing a stack frame\n\nUsually the layout of any locals is required at least three times, once\nwhen it becomes live, once when it is written to, and once it is read\nfrom. By adding a cache for them, we can reduce the number of layout\nqueries speeding up code that is heavy on const_eval.", "tree": {"sha": "88a32a9725d798d8e3cb11ed24b8375cfcb939be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88a32a9725d798d8e3cb11ed24b8375cfcb939be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98d4f33626c4a18092cd015b4e1cc15381989677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98d4f33626c4a18092cd015b4e1cc15381989677", "html_url": "https://github.com/rust-lang/rust/commit/98d4f33626c4a18092cd015b4e1cc15381989677", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98d4f33626c4a18092cd015b4e1cc15381989677/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33e6df4b62237af312bf6e3f40a97f5bdc94949a", "url": "https://api.github.com/repos/rust-lang/rust/commits/33e6df4b62237af312bf6e3f40a97f5bdc94949a", "html_url": "https://github.com/rust-lang/rust/commit/33e6df4b62237af312bf6e3f40a97f5bdc94949a"}], "stats": {"total": 42, "additions": 24, "deletions": 18}, "files": [{"sha": "105856fecc729175ac9d15ea8360c1fc8fa8e220", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98d4f33626c4a18092cd015b4e1cc15381989677/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4f33626c4a18092cd015b4e1cc15381989677/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=98d4f33626c4a18092cd015b4e1cc15381989677", "patch": "@@ -72,6 +72,7 @@ fn mk_eval_cx_inner<'a, 'mir, 'tcx>(\n     ecx.stack.push(interpret::Frame {\n         block: mir::START_BLOCK,\n         locals: IndexVec::new(),\n+        local_layouts: IndexVec::new(),\n         instance,\n         span,\n         mir,"}, {"sha": "b2d3328a73fe8335885f97a520e35937c2ea0289", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98d4f33626c4a18092cd015b4e1cc15381989677/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4f33626c4a18092cd015b4e1cc15381989677/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=98d4f33626c4a18092cd015b4e1cc15381989677", "patch": "@@ -1,3 +1,4 @@\n+use std::cell::Cell;\n use std::fmt::Write;\n use std::mem;\n \n@@ -76,6 +77,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     pub locals: IndexVec<mir::Local, LocalValue<Tag>>,\n+    pub local_layouts: IndexVec<mir::Local, Cell<Option<TyLayout<'tcx>>>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -290,9 +292,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local\n     ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n-        let local_ty = frame.mir.local_decls[local].ty;\n-        let local_ty = self.monomorphize(local_ty, frame.instance.substs);\n-        self.layout_of(local_ty)\n+        let cell = &frame.local_layouts[local];\n+        if cell.get().is_none() {\n+            let local_ty = frame.mir.local_decls[local].ty;\n+            let local_ty = self.monomorphize(local_ty, frame.instance.substs);\n+            let layout = self.layout_of(local_ty)?;\n+            cell.set(Some(layout));\n+        }\n+\n+        Ok(cell.get().unwrap())\n     }\n \n     pub fn str_to_immediate(&mut self, s: &str) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n@@ -426,6 +434,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n+            local_layouts: IndexVec::from_elem_n(Default::default(), mir.local_decls.len()),\n             span,\n             instance,\n             stmt: 0,\n@@ -464,11 +473,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 },\n             }\n             // Finally, properly initialize all those that still have the dummy value\n-            for (local, decl) in locals.iter_mut().zip(mir.local_decls.iter()) {\n+            for (idx, local) in locals.iter_enumerated_mut() {\n                 match *local {\n                     LocalValue::Live(_) => {\n                         // This needs to be peoperly initialized.\n-                        let layout = self.layout_of(self.monomorphize(decl.ty, instance.substs))?;\n+                        let layout = self.layout_of_local(self.frame(), idx)?;\n                         *local = LocalValue::Live(self.uninit_operand(layout)?);\n                     }\n                     LocalValue::Dead => {"}, {"sha": "b2648480f203cc9eae0b588cb155be08979ea852", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98d4f33626c4a18092cd015b4e1cc15381989677/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4f33626c4a18092cd015b4e1cc15381989677/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=98d4f33626c4a18092cd015b4e1cc15381989677", "patch": "@@ -457,36 +457,30 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n     /// This is used by [priroda](https://github.com/oli-obk/priroda) to get an OpTy from a local\n-    ///\n-    /// When you know the layout of the local in advance, you can pass it as last argument\n-    pub fn access_local(\n+    fn access_local(\n         &self,\n         frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n-        layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         assert_ne!(local, mir::RETURN_PLACE);\n         let op = *frame.locals[local].access()?;\n-        let layout = from_known_layout(layout,\n-                    || self.layout_of_local(frame, local))?;\n+        let layout = self.layout_of_local(frame, local)?;\n         Ok(OpTy { op, layout })\n     }\n \n     // Evaluate a place with the goal of reading from it.  This lets us sometimes\n-    // avoid allocations.  If you already know the layout, you can pass it in\n-    // to avoid looking it up again.\n+    // avoid allocations.\n     fn eval_place_to_op(\n         &self,\n         mir_place: &mir::Place<'tcx>,\n-        layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         let op = match *mir_place {\n             Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n-            Local(local) => self.access_local(self.frame(), local, layout)?,\n+            Local(local) => self.access_local(self.frame(), local)?,\n \n             Projection(ref proj) => {\n-                let op = self.eval_place_to_op(&proj.base, None)?;\n+                let op = self.eval_place_to_op(&proj.base)?;\n                 self.operand_projection(op, &proj.elem)?\n             }\n \n@@ -510,7 +504,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // FIXME: do some more logic on `move` to invalidate the old location\n             Copy(ref place) |\n             Move(ref place) =>\n-                self.eval_place_to_op(place, layout)?,\n+                self.eval_place_to_op(place)?,\n \n             Constant(ref constant) => {\n                 let layout = from_known_layout(layout, || {"}, {"sha": "53105266b39284372354d84860652e4d2adf97ac", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98d4f33626c4a18092cd015b4e1cc15381989677/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4f33626c4a18092cd015b4e1cc15381989677/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=98d4f33626c4a18092cd015b4e1cc15381989677", "patch": "@@ -314,13 +314,14 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     stmt: usize,\n }\n \n-impl_stable_hash_for!(impl<'tcx, 'mir: 'tcx> for struct Frame<'mir, 'tcx> {\n+impl_stable_hash_for!(impl<'mir, 'tcx: 'mir> for struct Frame<'mir, 'tcx> {\n     mir,\n     instance,\n     span,\n     return_to_block,\n     return_place -> (return_place.as_ref().map(|r| &**r)),\n     locals,\n+    local_layouts -> _,\n     block,\n     stmt,\n     extra,\n@@ -339,6 +340,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             return_to_block,\n             return_place,\n             locals,\n+            local_layouts: _,\n             block,\n             stmt,\n             extra: _,"}]}