{"sha": "e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ODhmZTZmOWI4ZWQwYzQ3ZGYyZWQxN2U1MGMyZDM5MWMxZGM2NDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-13T21:38:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-13T21:39:00Z"}, "message": "rustc: Change ty::triv_ann() to take a node ID instead of a full annotation", "tree": {"sha": "7c517d4618d7f541a1076c7a4a9e7b372bf38707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c517d4618d7f541a1076c7a4a9e7b372bf38707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647", "html_url": "https://github.com/rust-lang/rust/commit/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f440b1452f79a670d2927abd42f95b79272c5d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f440b1452f79a670d2927abd42f95b79272c5d9", "html_url": "https://github.com/rust-lang/rust/commit/2f440b1452f79a670d2927abd42f95b79272c5d9"}], "stats": {"total": 203, "additions": 118, "deletions": 85}, "files": [{"sha": "5957c1fdf368370ef861e151d83e701d6ea03d91", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647", "patch": "@@ -1504,8 +1504,8 @@ fn ann_to_monotype(ctxt cx,  &node_type_table ntt, ast::ann a) -> t {\n }\n \n // Turns a type into an ann_type, using defaults for other fields.\n-fn triv_ann(&ast::ann old, t typ) -> ast::ann {\n-    ret ast::ann_type(ast::ann_tag(old), typ, none[vec[t]], none[@ts_ann]);\n+fn triv_ann(uint node_id, t typ) -> ast::ann {\n+    ret ast::ann_type(node_id, typ, none[vec[t]], none[@ts_ann]);\n }\n \n // Returns the number of distinct type parameters in the given type."}, {"sha": "024d2c67cb48815e9138f49617a70e223d31cc34", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 116, "deletions": 83, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e888fe6f9b8ed0c47df2ed17e50c2d391c1dc647", "patch": "@@ -635,8 +635,9 @@ mod Collect {\n \n             auto tpt = tup(ty_param_count, result_ty);\n             cx.type_cache.insert(variant.node.id, tpt);\n-            auto variant_t = rec(ann=triv_ann(variant.node.ann, result_ty)\n-                                 with variant.node\n+            auto variant_t = rec(\n+                ann=triv_ann(ast::ann_tag(variant.node.ann), result_ty)\n+                with variant.node\n             );\n             result += vec(fold::respan(variant.span, variant_t));\n         }\n@@ -705,7 +706,8 @@ mod Collect {\n                        &ast::def_id id, &ast::ann a) -> @ast::item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast::item_const(i, t, ex, id, triv_ann(a, typ));\n+        auto item = ast::item_const(i, t, ex, id,\n+                                    triv_ann(ast::ann_tag(a), typ));\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n@@ -714,7 +716,8 @@ mod Collect {\n                     &ast::def_id id, &ast::ann a) -> @ast::item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast::item_fn(i, f, ty_params, id, triv_ann(a, typ));\n+        auto item = ast::item_fn(i, f, ty_params, id,\n+                                 triv_ann(ast::ann_tag(a), typ));\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n@@ -725,7 +728,7 @@ mod Collect {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast::native_item_fn(i, ln, d, ty_params, id,\n-                                       triv_ann(a, typ));\n+                                       triv_ann(ast::ann_tag(a), typ));\n         ret @fold::respan[ast::native_item_](sp, item);\n     }\n \n@@ -770,7 +773,7 @@ mod Collect {\n                                      meth_ty.proto,\n                                      meth_ty.inputs,\n                                      meth_ty.output);\n-            m_ = rec(ann=triv_ann(meth.node.ann, meth_tfn)\n+            m_ = rec(ann=triv_ann(ast::ann_tag(meth.node.ann), meth_tfn)\n                      with meth.node\n             );\n             m = @rec(node=m_ with *meth);\n@@ -779,9 +782,8 @@ mod Collect {\n         auto g = bind getter(e.cx, _);\n         for (ast::obj_field fld in ob.fields) {\n             let ty::t fty = ast_ty_to_ty(e.cx.tcx, g, fld.ty);\n-            let ast::obj_field f = rec(ann=triv_ann(fld.ann, fty)\n-                                      with fld\n-            );\n+            let ast::obj_field f =\n+                rec(ann=triv_ann(ast::ann_tag(fld.ann), fty) with fld);\n             _vec::push[ast::obj_field](fields, f);\n         }\n \n@@ -792,7 +794,10 @@ mod Collect {\n                 let ty::t output = ty::mk_nil(e.cx.tcx);\n                 auto dtor_tfn = ty::mk_fn(e.cx.tcx, ast::proto_fn, inputs,\n                                          output);\n-                auto d_ = rec(ann=triv_ann(d.node.ann, dtor_tfn) with d.node);\n+                auto d_ = rec(\n+                    ann=triv_ann(ast::ann_tag(d.node.ann), dtor_tfn)\n+                    with d.node\n+                );\n                 dtor = some[@ast::method](@rec(node=d_ with *d));\n             }\n             case (none[@ast::method]) { }\n@@ -802,7 +807,8 @@ mod Collect {\n                        fields = fields,\n                        dtor = dtor\n                        with ob);\n-        auto item = ast::item_obj(i, ob_, ty_params, odid, triv_ann(a, t));\n+        auto item = ast::item_obj(i, ob_, ty_params, odid,\n+                                  triv_ann(ast::ann_tag(a), t));\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n@@ -811,7 +817,8 @@ mod Collect {\n                     &ast::def_id id, &ast::ann a) -> @ast::item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast::item_ty(i, t, ty_params, id, triv_ann(a, typ));\n+        auto item = ast::item_ty(i, t, ty_params, id,\n+                                 triv_ann(ast::ann_tag(a), typ));\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n@@ -1240,7 +1247,8 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_vec(es_1, mut, triv_ann(ann, t));\n+                e_1 = ast::expr_vec(es_1, mut,\n+                                    triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n@@ -1261,7 +1269,7 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_tup(elts_1, triv_ann(ann, t));\n+                e_1 = ast::expr_tup(elts_1, triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n@@ -1318,12 +1326,14 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_rec(fields_1, base_1, triv_ann(ann, t));\n+                e_1 = ast::expr_rec(fields_1, base_1,\n+                                    triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_bind(sube, es, triv_ann(ann, t));\n+                e_1 = ast::expr_bind(sube, es,\n+                                     triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n                 // NB: we call 'Demand::autoderef' and pass in adk only in\n@@ -1332,34 +1342,39 @@ mod Pushdown {\n                 // so there's no need.\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_call(sube, es, triv_ann(ann, t));\n+                e_1 = ast::expr_call(sube, es,\n+                                     triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_self_method(id, triv_ann(ann, t));\n+                e_1 = ast::expr_self_method(id,\n+                                            triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_binary(bop, lhs, rhs, triv_ann(ann, t));\n+                e_1 = ast::expr_binary(bop, lhs, rhs,\n+                                       triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand::autoderef.\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_unary(uop, sube, triv_ann(ann, t));\n+                e_1 = ast::expr_unary(uop, sube,\n+                                      triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_lit(lit, triv_ann(ann, t));\n+                e_1 = ast::expr_lit(lit, triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_cast(sube, ast_ty, triv_ann(ann, t));\n+                e_1 = ast::expr_cast(sube, ast_ty,\n+                                     triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n@@ -1374,56 +1389,65 @@ mod Pushdown {\n                         else_1 = some[@ast::expr](e_1);\n                     }\n                 }\n-                e_1 = ast::expr_if(cond, then_1, else_1, triv_ann(ann, t));\n+                e_1 = ast::expr_if(cond, then_1, else_1,\n+                                   triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_for(decl, seq, bloc, triv_ann(ann, t));\n+                e_1 = ast::expr_for(decl, seq, bloc,\n+                                    triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_for_each(decl, seq, bloc, triv_ann(ann, t));\n+                e_1 = ast::expr_for_each(decl, seq, bloc,\n+                                         triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_while(cond, bloc, triv_ann(ann, t));\n+                e_1 = ast::expr_while(cond, bloc,\n+                                      triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_do_while(bloc, cond, triv_ann(ann, t));\n+                e_1 = ast::expr_do_while(bloc, cond,\n+                                         triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_block(bloc, triv_ann(ann, t));\n+                e_1 = ast::expr_block(bloc, triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n-                e_1 = ast::expr_assign(lhs_1, rhs_1, triv_ann(ann, t));\n+                e_1 = ast::expr_assign(lhs_1, rhs_1,\n+                                       triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n-                e_1 = ast::expr_assign_op(op, lhs_1, rhs_1, triv_ann(ann, t));\n+                e_1 = ast::expr_assign_op(op, lhs_1, rhs_1,\n+                                          triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_field(lhs, rhs, triv_ann(ann, t));\n+                e_1 = ast::expr_field(lhs, rhs,\n+                                      triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_index(base, index, triv_ann(ann, t));\n+                e_1 = ast::expr_index(base, index,\n+                                      triv_ann(ast::ann_tag(ann), t));\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n                 auto tp_substs_0 = ty::ann_to_type_params(fcx.ccx.node_types,\n@@ -1456,17 +1480,17 @@ mod Pushdown {\n                 }\n \n                 e_1 = ast::expr_path(pth,\n-                                    ast::ann_type(ast::ann_tag(ann), t,\n-                                                  ty_params_opt,\n-                                                  none[@ts_ann]));\n+                                     ast::ann_type(ast::ann_tag(ann), t,\n+                                                   ty_params_opt,\n+                                                   none[@ts_ann]));\n                 write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n                            tup(ty_params_opt, t));\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_ext(p, args, body, expanded,\n-                                    triv_ann(ann, t));\n+                                    triv_ann(ast::ann_tag(ann), t));\n             }\n             /* FIXME: should this check the type annotations? */\n             case (ast::expr_fail(_))  { e_1 = e.node; } \n@@ -1482,7 +1506,7 @@ mod Pushdown {\n             case (ast::expr_port(?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_port(triv_ann(ann, t));\n+                e_1 = ast::expr_port(triv_ann(ast::ann_tag(ann), t));\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n@@ -1499,7 +1523,7 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_chan(es_1, triv_ann(ann, t));\n+                e_1 = ast::expr_chan(es_1, triv_ann(ast::ann_tag(ann), t));\n             }\n \n             case (ast::expr_alt(?discrim, ?arms_0, ?ann)) {\n@@ -1512,7 +1536,8 @@ mod Pushdown {\n                     auto arm_1 = rec(pat=arm_0.pat, block=block_1);\n                     arms_1 += vec(arm_1);\n                 }\n-                e_1 = ast::expr_alt(discrim, arms_1, triv_ann(ann, t));\n+                e_1 = ast::expr_alt(discrim, arms_1,\n+                                    triv_ann(ast::ann_tag(ann), t));\n             }\n \n             case (ast::expr_recv(?lval_0, ?expr_0, ?ann)) {\n@@ -1587,7 +1612,7 @@ fn writeback_local(&option::t[@fn_ctxt] env, &span sp, &@ast::local local)\n         }\n     }\n \n-    auto local_wb = @rec(ann=triv_ann(local.ann, local_ty)\n+    auto local_wb = @rec(ann=triv_ann(ast::ann_tag(local.ann), local_ty)\n                          with *local\n     );\n     ret @fold::respan[ast::decl_](sp, ast::decl_local(local_wb));\n@@ -1664,13 +1689,15 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) -> @ast::pat {\n     auto new_pat;\n     alt (pat.node) {\n         case (ast::pat_wild(?ann)) {\n-            new_pat = ast::pat_wild(triv_ann(ann, next_ty_var(fcx.ccx)));\n+            new_pat = ast::pat_wild(triv_ann(ast::ann_tag(ann),\n+                                             next_ty_var(fcx.ccx)));\n         }\n         case (ast::pat_lit(?lt, ?ann)) {\n-            new_pat = ast::pat_lit(lt, triv_ann(ann, check_lit(fcx.ccx, lt)));\n+            new_pat = ast::pat_lit(lt, triv_ann(ast::ann_tag(ann),\n+                                                check_lit(fcx.ccx, lt)));\n         }\n         case (ast::pat_bind(?id, ?def_id, ?a)) {\n-            auto ann = triv_ann(a, next_ty_var(fcx.ccx));\n+            auto ann = triv_ann(ast::ann_tag(a), next_ty_var(fcx.ccx));\n             new_pat = ast::pat_bind(id, def_id, ann);\n         }\n         case (ast::pat_tag(?p, ?subpats, ?old_ann)) {\n@@ -1879,8 +1906,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         auto rhs_1 = Pushdown::pushdown_expr(fcx,\n             expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_1), rhs_0);\n \n-        auto ann = triv_ann(a, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                       rhs_1));\n+        auto ann = triv_ann(ast::ann_tag(a),\n+                            expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_1));\n         ret tup(lhs_1, rhs_1, ann);\n     }\n \n@@ -1908,7 +1935,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n     alt (expr.node) {\n         case (ast::expr_lit(?lit, ?a)) {\n             auto typ = check_lit(fcx.ccx, lit);\n-            auto ann = triv_ann(a, typ);\n+            auto ann = triv_ann(ast::ann_tag(a), typ);\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_lit(lit, ann));\n         }\n \n@@ -1938,7 +1965,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (_) { /* fall through */ }\n             }\n \n-            auto ann = triv_ann(a, t);\n+            auto ann = triv_ann(ast::ann_tag(a), t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_binary(binop, lhs_1, rhs_1,\n                                                         ann));\n@@ -1969,7 +1996,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (_) { oper_t = strip_boxes(fcx.ccx.tcx, oper_t); }\n             }\n \n-            auto ann = triv_ann(a, oper_t);\n+            auto ann = triv_ann(ast::ann_tag(a), oper_t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_unary(unop, oper_1, ann));\n         }\n@@ -1998,14 +2025,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 fail;\n             }\n \n-            auto e = ast::expr_path(pth, triv_ann(old_ann, tpt._1));\n+            auto e = ast::expr_path(pth, triv_ann(ast::ann_tag(old_ann),\n+                                    tpt._1));\n             ret @fold::respan[ast::expr_](expr.span, e);\n         }\n \n         case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n             auto exp_ = check_expr(fcx, expanded);\n             auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, exp_);\n-            auto ann = triv_ann(a, t);\n+            auto ann = triv_ann(ast::ann_tag(a), t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_ext(p, args, body, exp_,\n                                                      ann));\n@@ -2188,7 +2216,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n             auto rhs_1 = Pushdown::pushdown_expr(fcx, item_t, rhs_0);\n \n-            auto ann = triv_ann(a, chan_t);\n+            auto ann = triv_ann(ast::ann_tag(a), chan_t);\n             auto newexpr = ast::expr_send(lhs_1, rhs_1, ann);\n             ret @fold::respan[ast::expr_](expr.span, newexpr);\n         }\n@@ -2214,7 +2242,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n             auto lhs_1 = Pushdown::pushdown_expr(fcx, item_t, lhs_0);\n \n-            auto ann = triv_ann(a, item_t);\n+            auto ann = triv_ann(ast::ann_tag(a), item_t);\n             auto newexpr = ast::expr_recv(lhs_1, rhs_1, ann);\n             ret @fold::respan[ast::expr_](expr.span, newexpr);\n         }\n@@ -2246,7 +2274,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             auto thn_1 = Pushdown::pushdown_block(fcx, elsopt_t, thn_0);\n \n-            auto ann = triv_ann(a, elsopt_t);\n+            auto ann = triv_ann(ast::ann_tag(a), elsopt_t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_if(cond_1, thn_1,\n                                                     elsopt_1, ann));\n@@ -2260,7 +2288,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = triv_ann(a, ty::mk_nil(fcx.ccx.tcx));\n+            auto ann = triv_ann(ast::ann_tag(a), ty::mk_nil(fcx.ccx.tcx));\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_for(decl_1, seq_1,\n                                                      body_1, ann));\n@@ -2271,7 +2299,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(a, ty::mk_nil(fcx.ccx.tcx));\n+            auto ann = triv_ann(ast::ann_tag(a), ty::mk_nil(fcx.ccx.tcx));\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_for_each(decl_1, seq_1,\n                                                           body_1, ann));\n@@ -2284,7 +2312,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                                   cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(a, ty::mk_nil(fcx.ccx.tcx));\n+            auto ann = triv_ann(ast::ann_tag(a), ty::mk_nil(fcx.ccx.tcx));\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_while(cond_1, body_1, ann));\n         }\n@@ -2296,8 +2324,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                                   cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(a, block_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                            body_1));\n+            auto ann = triv_ann(ast::ann_tag(a),\n+                                block_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                         body_1));\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_do_while(body_1, cond_1,\n                                                           ann));\n@@ -2349,7 +2378,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             auto expr_1 = Pushdown::pushdown_expr(fcx, pattern_ty, expr_0);\n \n-            auto ann = triv_ann(a, result_ty);\n+            auto ann = triv_ann(ast::ann_tag(a), result_ty);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_alt(expr_1, arms_1, ann));\n         }\n@@ -2359,11 +2388,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast::expr](?expr)) {\n-                    ann = triv_ann(a, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                              expr));\n+                    ann = triv_ann(ast::ann_tag(a),\n+                                   expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                           expr));\n                 }\n                 case (none[@ast::expr]) {\n-                    ann = triv_ann(a, ty::mk_nil(fcx.ccx.tcx));\n+                    ann = triv_ann(ast::ann_tag(a), ty::mk_nil(fcx.ccx.tcx));\n                 }\n             }\n             ret @fold::respan(expr.span, ast::expr_block(b_0, ann));\n@@ -2403,7 +2433,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto t_1 = ty::mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n-            auto ann = triv_ann(a, t_1);\n+            auto ann = triv_ann(ast::ann_tag(a), t_1);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_bind(result._0, result._1,\n                                                       ann));\n@@ -2432,7 +2462,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 }\n             }\n \n-            auto ann = triv_ann(a, rt_1);\n+            auto ann = triv_ann(ast::ann_tag(a), rt_1);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_call(f_1, args_1, ann));\n         }\n@@ -2467,7 +2497,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (_) { fail; }\n             }\n \n-            auto ann = triv_ann(a, t);\n+            auto ann = triv_ann(ast::ann_tag(a), t);\n \n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n@@ -2500,7 +2530,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             // FIXME: Other typechecks needed\n \n-            auto ann = triv_ann(a, ty::mk_task(fcx.ccx.tcx));\n+            auto ann = triv_ann(ast::ann_tag(a), ty::mk_task(fcx.ccx.tcx));\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_spawn(dom, name,\n                                                        f_1, args_1, ann));\n@@ -2520,7 +2550,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     \" as \" + ty_to_str(fcx.ccx.tcx, t_1));\n             }\n \n-            auto ann = triv_ann(a, t_1);\n+            auto ann = triv_ann(ast::ann_tag(a), t_1);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_cast(e_1, t, ann));\n         }\n@@ -2544,8 +2574,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 _vec::push[@ast::expr](args_1,expr_1);\n             }\n \n-            auto ann = triv_ann(a, ty::mk_vec(fcx.ccx.tcx,\n-                                             rec(ty=t, mut=mut)));\n+            auto ann = triv_ann(ast::ann_tag(a),\n+                                ty::mk_vec(fcx.ccx.tcx, rec(ty=t, mut=mut)));\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_vec(args_1, mut, ann));\n         }\n@@ -2562,7 +2592,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = triv_ann(a, ty::mk_tup(fcx.ccx.tcx, elts_mt));\n+            auto ann = triv_ann(ast::ann_tag(a),\n+                                ty::mk_tup(fcx.ccx.tcx, elts_mt));\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_tup(elts_1, ann));\n         }\n@@ -2594,7 +2625,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             alt (base) {\n                 case (none[@ast::expr]) {\n-                    ann = triv_ann(a, ty::mk_rec(fcx.ccx.tcx, fields_t));\n+                    ann = triv_ann(ast::ann_tag(a),\n+                                   ty::mk_rec(fcx.ccx.tcx, fields_t));\n                 }\n \n                 case (some[@ast::expr](?bexpr)) {\n@@ -2615,7 +2647,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                         }\n                     }\n \n-                    ann = triv_ann(a, bexpr_t);\n+                    ann = triv_ann(ast::ann_tag(a), bexpr_t);\n \n                     for (ty::field f in fields_t) {\n                         auto found = false;\n@@ -2652,7 +2684,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = triv_ann(a, args.(ix).ty);\n+                    auto ann = triv_ann(ast::ann_tag(a), args.(ix).ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n                                                                field,\n@@ -2666,7 +2698,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = triv_ann(a, fields.(ix).mt.ty);\n+                    auto ann = triv_ann(ast::ann_tag(a), fields.(ix).mt.ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n                                                                field,\n@@ -2683,7 +2715,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto meth = methods.(ix);\n                     auto t = ty::mk_fn(fcx.ccx.tcx, meth.proto,\n                                       meth.inputs, meth.output);\n-                    auto ann = triv_ann(a, t);\n+                    auto ann = triv_ann(ast::ann_tag(a), t);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_field(base_1,\n                                                                field,\n@@ -2713,7 +2745,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n-                    auto ann = triv_ann(a, mt.ty);\n+                    auto ann = triv_ann(ast::ann_tag(a), mt.ty);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_index(base_1,\n                                                                idx_1,\n@@ -2726,8 +2758,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                              \"non-integral type of str index: \"\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n-                    auto ann = triv_ann(a, ty::mk_mach(fcx.ccx.tcx,\n-                                                      common::ty_u8));\n+                    auto ann = triv_ann(ast::ann_tag(a),\n+                                        ty::mk_mach(fcx.ccx.tcx,\n+                                                    common::ty_u8));\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_index(base_1,\n                                                                idx_1,\n@@ -2745,7 +2778,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_port(?a)) {\n             auto t = next_ty_var(fcx.ccx);\n             auto pt = ty::mk_port(fcx.ccx.tcx, t);\n-            auto ann = triv_ann(a, pt);\n+            auto ann = triv_ann(ast::ann_tag(a), pt);\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_port(ann));\n         }\n \n@@ -2755,7 +2788,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             alt (struct(fcx.ccx.tcx, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n-                    auto ann = triv_ann(a, ct);\n+                    auto ann = triv_ann(ast::ann_tag(a), ct);\n                     ret @fold::respan[ast::expr_](expr.span,\n                                                 ast::expr_chan(expr_1, ann));\n                 }\n@@ -2803,7 +2836,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n             auto a_res = local.ann;\n             alt (a_res) {\n                 case (ann_none(_)) {\n-                    a_res = triv_ann(a_res, t);\n+                    a_res = triv_ann(ast::ann_tag(a_res), t);\n                 }\n                 case (_) {}\n             }\n@@ -2972,8 +3005,8 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, &ast::ident ident, &ast::_fn f,\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n-    auto fn_ann = triv_ann(ann, ty::mk_fn(ccx.tcx, f.proto, inputs,\n-                                         output_ty));\n+    auto fn_ann = triv_ann(ast::ann_tag(ann),\n+                           ty::mk_fn(ccx.tcx, f.proto, inputs, output_ty));\n \n     auto item = ast::item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold::respan[ast::item_](sp, item);"}]}