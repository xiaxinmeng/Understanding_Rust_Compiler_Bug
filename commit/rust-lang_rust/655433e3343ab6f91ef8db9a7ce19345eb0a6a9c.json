{"sha": "655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NTQzM2UzMzQzYWI2ZjkxZWY4ZGI5YTdjZTE5MzQ1ZWIwYTZhOWM=", "commit": {"author": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-01-08T05:09:48Z"}, "committer": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-01-22T18:02:40Z"}, "message": "rustpkg::version: Remove enum Version\n\nCurrently rustpkg doesn't use SemanticVersion or Tagged, so they are\nremoved. Remaining variants are replaced by `Option<~str>`.", "tree": {"sha": "826ede771eb68a17b2cca142d0561ccbea235b04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/826ede771eb68a17b2cca142d0561ccbea235b04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "html_url": "https://github.com/rust-lang/rust/commit/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/comments", "author": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa84593fc3098c4631be0887b772f0665b731a31", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa84593fc3098c4631be0887b772f0665b731a31", "html_url": "https://github.com/rust-lang/rust/commit/fa84593fc3098c4631be0887b772f0665b731a31"}], "stats": {"total": 280, "additions": 100, "deletions": 180}, "files": [{"sha": "27dfc3cae41c4772158e11d2a9272abace7fecd6", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -15,7 +15,6 @@ use crate_id::*;\n use package_source::*;\n use path_util::{platform_library_name, target_build_dir};\n use target::*;\n-use version::Version;\n use workspace::pkg_parent_workspaces;\n use workcache_support::*;\n pub use path_util::default_workspace;\n@@ -79,13 +78,13 @@ pub fn new_workcache_context(p: &Path) -> workcache::Context {\n     workcache::Context::new_with_freshness(db, cfg, Arc::new(freshness))\n }\n \n-pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n+pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Option<~str>,\n                  lib: Path) {\n     build_lib_with_cfgs(sysroot, root, name, version, lib, ~[])\n }\n \n pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str,\n-                           version: Version, lib: Path, cfgs: ~[~str]) {\n+                           version: Option<~str>, lib: Path, cfgs: ~[~str]) {\n     let cx = default_context(sysroot, root.clone());\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n@@ -102,13 +101,13 @@ pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str,\n     pkg_src.build(&cx, cfgs, []);\n }\n \n-pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n+pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Option<~str>,\n                  main: Path) {\n     build_exe_with_cfgs(sysroot, root, name, version, main, ~[])\n }\n \n pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str,\n-                           version: Version, main: Path, cfgs: ~[~str]) {\n+                           version: Option<~str>, main: Path, cfgs: ~[~str]) {\n     let cx = default_context(sysroot, root.clone());\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n@@ -129,7 +128,7 @@ pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str,\n pub fn install_pkg(cx: &BuildContext,\n                    workspace: Path,\n                    name: ~str,\n-                   version: Version,\n+                   version: Option<~str>,\n                    // For now, these inputs are assumed to be inputs to each of the crates\n                    more_inputs: ~[(~str, Path)]) { // pairs of Kind and Path\n     let crateid = CrateId{ version: version, ..CrateId::new(name)};"}, {"sha": "9415e850e98ed0e28dc711042e3140c894ac94c3", "filename": "src/librustpkg/crate_id.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fcrate_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fcrate_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate_id.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use version::{Version, NoVersion, ExactRevision};\n use std::hash::Streaming;\n use std::hash;\n use syntax::crateid;\n@@ -32,7 +31,7 @@ pub struct CrateId {\n     /// of package IDs whose short names aren't valid Rust identifiers.\n     short_name: ~str,\n     /// The requested package version.\n-    version: Version\n+    version: Option<~str>\n }\n \n impl Eq for CrateId {\n@@ -42,6 +41,13 @@ impl Eq for CrateId {\n }\n \n impl CrateId {\n+    pub fn get_version<'a>(&'a self) -> &'a str {\n+        match self.version {\n+            Some(ref ver) => ver.as_slice(),\n+            None => \"0.0\"\n+        }\n+    }\n+\n     pub fn new(s: &str) -> CrateId {\n         use conditions::bad_pkg_id::cond;\n \n@@ -52,10 +58,6 @@ impl CrateId {\n         let raw_crateid = raw_crateid.unwrap();\n         let crateid::CrateId { path, name, version } = raw_crateid;\n         let path = Path::new(path);\n-        let version = match version {\n-            Some(v) => ExactRevision(v),\n-            None => NoVersion,\n-        };\n \n         CrateId {\n             path: path,\n@@ -67,13 +69,13 @@ impl CrateId {\n     pub fn hash(&self) -> ~str {\n         // FIXME (#9639): hash should take a &[u8] so we can hash the real path\n         self.path.display().with_str(|s| {\n-            let vers = self.version.to_str();\n+            let vers = self.get_version();\n             format!(\"{}-{}-{}\", s, hash(s + vers), vers)\n         })\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {\n-        format!(\"{}{}\", self.short_name, self.version.to_str())\n+        format!(\"{}-{}\", self.short_name, self.get_version())\n     }\n \n     /// True if the ID has multiple components\n@@ -124,7 +126,7 @@ impl Iterator<(Path, Path)> for Prefixes {\n impl ToStr for CrateId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        format!(\"{}-{}\", self.path.as_str().unwrap(), self.version.to_str())\n+        format!(\"{}-{}\", self.path.as_str().unwrap(), self.get_version())\n     }\n }\n "}, {"sha": "22871179a6e3bfe1b97b930d8a405cf8542331b8", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -163,7 +163,6 @@ impl<'a> PkgScript<'a> {\n         exe.as_str().unwrap().to_owned()\n     }\n \n-\n     /// Run the contents of this package script, where <what>\n     /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n     /// Returns a pair of an exit code and list of configs (obtained by\n@@ -243,7 +242,7 @@ impl CtxMethods for BuildContext {\n \n         if args.len() < 1 {\n             match cwd_to_workspace() {\n-                None  if dir_has_crate_file(&cwd) => {\n+                None if dir_has_crate_file(&cwd) => {\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n                     let crateid = CrateId::new(cwd.filename_str().unwrap());\n                     let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, crateid);\n@@ -289,6 +288,7 @@ impl CtxMethods for BuildContext {\n             Some((crateid, dest_ws))\n         }\n     }\n+\n     fn run(&self, cmd: Command, args: ~[~str]) {\n         let cwd = os::getcwd();\n         match cmd {"}, {"sha": "fce2f9e4d0c6b135e368326114344da6c20c00fd", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -100,15 +100,15 @@ impl PkgSrc {\n             // automatically-checked-out sources go.\n             let mut result = source_workspace.join(\"src\");\n             result.push(&id.path.dir_path());\n-            result.push(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n+            result.push(id.short_name_with_version());\n             to_try.push(result);\n             let mut result = source_workspace.join(\"src\");\n             result.push(&id.path);\n             to_try.push(result);\n \n             let mut result = build_dir.join(\"src\");\n             result.push(&id.path.dir_path());\n-            result.push(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n+            result.push(id.short_name_with_version());\n             to_try.push(result.clone());\n             output_names.push(result);\n             let mut other_result = build_dir.join(\"src\");\n@@ -287,7 +287,7 @@ impl PkgSrc {\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 let url = format!(\"https://{}\", crateid.path.as_str().unwrap());\n                 debug!(\"Fetching package: git clone {} {} [version={}]\",\n-                        url, clone_target.display(), crateid.version.to_str());\n+                        url, clone_target.display(), crateid.get_version());\n \n                 let mut failed = false;\n "}, {"sha": "d8dee82d09e8aa34f3f53caae28c73401efebfef", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -14,7 +14,7 @@\n \n pub use crate_id::CrateId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n-pub use version::{Version, ExactRevision, NoVersion, split_version, split_version_general,\n+pub use version::{Version, split_version, split_version_general,\n     try_parsing_version};\n pub use rustc::metadata::filesearch::rust_path;\n use rustc::metadata::filesearch::{libdir, relative_target_lib_path};\n@@ -85,7 +85,7 @@ pub fn workspace_contains_crate_id_(crateid: &CrateId, workspace: &Path,\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n                             *might_match == crateid.short_name\n-                                && (crateid.version == *vers || crateid.version == NoVersion)\n+                                && (crateid.version == *vers || crateid.version == None)\n                         }\n                     }\n                 })\n@@ -188,7 +188,7 @@ pub fn installed_library_in_workspace(pkg_path: &Path, workspace: &Path) -> Opti\n                                                  Install,\n                                                  workspace,\n                                                  libdir(),\n-                                                 &NoVersion)\n+                                                 &None)\n     }\n }\n \n@@ -261,7 +261,8 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n                 Some(i) => {\n                     debug!(\"Maybe {} is a version\", f_name.slice(i + 1, f_name.len()));\n                     match try_parsing_version(f_name.slice(i + 1, f_name.len())) {\n-                        Some(ref found_vers) if version == found_vers => {\n+                        Some(ref found_vers) if version == &Some(found_vers.to_owned()) ||\n+                                                version == &None => {\n                             match f_name.slice(0, i).rfind('-') {\n                                 Some(j) => {\n                                     let lib_prefix = match p_path.extension_str() {\n@@ -276,7 +277,6 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n                                 }\n                                 None => break\n                             }\n-\n                        }\n                        _ => { f_name = f_name.slice(0, i); }\n                  }\n@@ -306,13 +306,13 @@ fn split_crate_id<'a>(crate_id: &'a str) -> (&'a str, Version) {\n     match split_version(crate_id) {\n         Some((name, vers)) =>\n             match vers {\n-                ExactRevision(ref v) => match v.find('-') {\n-                    Some(pos) => (name, ExactRevision(v.slice(0, pos).to_owned())),\n-                    None => (name, ExactRevision(v.to_owned()))\n+                Some(ref v) => match v.find('-') {\n+                    Some(pos) => (name, Some(v.slice(0, pos).to_owned())),\n+                    None => (name, Some(v.to_owned()))\n                 },\n                 _ => (name, vers)\n             },\n-        None => (crate_id, NoVersion)\n+        None => (crate_id, None)\n     }\n }\n \n@@ -393,8 +393,7 @@ pub fn build_pkg_id_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n                       pkg_id: &CrateId, workspace: Path) -> Path {\n-    let short_name_with_version = format!(\"{}-{}\", pkg_id.short_name,\n-                                          pkg_id.version.to_str());\n+    let short_name_with_version = pkg_id.short_name_with_version();\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n     let dir = match where {\n@@ -487,7 +486,7 @@ pub fn versionize(p: &Path, v: &Version) -> Path {\n     let q = p.filename().expect(\"path is a directory\");\n     let mut q = q.to_owned();\n     q.push('-' as u8);\n-    let vs = v.to_str();\n+    let vs = match v { &Some(ref s) => s.to_owned(), &None => ~\"0.0\" };\n     q.push_all(vs.as_bytes());\n     p.with_filename(q)\n }"}, {"sha": "2346749feb53a0da3a0516dc8f2bc2236a1f4fa5", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -14,15 +14,14 @@ use std::{run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n use std::io::fs;\n use extra::tempfile::TempDir;\n-use version::*;\n use path_util::chmod_read_only;\n \n /// Attempts to clone `source`, a local git repository, into `target`, a local\n /// directory that doesn't exist.\n /// Returns `DirToUse(p)` if the clone fails, where `p` is a newly created temporary\n /// directory (that the callee may use, for example, to check out remote sources into).\n /// Returns `CheckedOutSources` if the clone succeeded.\n-pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult {\n+pub fn safe_git_clone(source: &Path, v: &Option<~str>, target: &Path) -> CloneResult {\n     if source.exists() {\n         debug!(\"{} exists locally! Cloning it into {}\",\n                 source.display(), target.display());\n@@ -44,7 +43,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n             }\n             else {\n                 match v {\n-                    &ExactRevision(ref s) => {\n+                    &Some(ref s) => {\n                         let git_dir = target.join(\".git\");\n                         debug!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n                                 *s, target.display(), git_dir.display());\n@@ -65,7 +64,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n         } else {\n             // Check that no version was specified. There's no reason to not handle the\n             // case where a version was requested, but I haven't implemented it.\n-            assert!(*v == NoVersion);\n+            assert!(*v == None);\n             let git_dir = target.join(\".git\");\n             debug!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n                     target.display(), git_dir.display(), source.display());\n@@ -106,7 +105,7 @@ pub fn make_read_only(target: &Path) {\n }\n \n /// Source can be either a URL or a local file path.\n-pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n+pub fn git_clone_url(source: &str, target: &Path, v: &Option<~str>) {\n     use conditions::git_checkout_failed::cond;\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -120,7 +119,7 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     }\n     else {\n         match v {\n-            &ExactRevision(ref s) | &Tagged(ref s) => {\n+            &Some(ref s) => {\n                     let opt_outp = process_output_in_cwd(\"git\", [~\"checkout\", s.to_owned()],\n                                                          target);\n                     let outp = opt_outp.expect(\"Failed to exec `git`\");"}, {"sha": "be5b6859c74e438e610ffb43686ad06e11e75cea", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 48, "deletions": 53, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -25,8 +25,7 @@ use extra::treemap::TreeMap;\n use extra::getopts::groups::getopts;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n-use crate_id::{CrateId};\n-use version::{ExactRevision, NoVersion, Version};\n+use crate_id::CrateId;\n use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                target_bench_in_workspace, make_dir_rwx,\n                library_in_workspace, installed_library_in_workspace,\n@@ -63,15 +62,15 @@ fn fake_pkg() -> CrateId {\n     CrateId {\n         path: Path::new(sn.as_slice()),\n         short_name: sn,\n-        version: NoVersion\n+        version: None\n     }\n }\n \n fn git_repo_pkg() -> CrateId {\n     CrateId {\n         path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n-        version: NoVersion\n+        version: None\n     }\n }\n \n@@ -88,28 +87,24 @@ fn mk_emptier_workspace(tag: &str) -> TempDir {\n     workspace\n }\n \n-fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> TempDir {\n+fn mk_empty_workspace(crate_id: &CrateId, tag: &str) -> TempDir {\n     let workspace_dir = TempDir::new(tag).expect(\"couldn't create temp dir\");\n-    mk_workspace(workspace_dir.path(), short_name, version);\n+    mk_workspace(workspace_dir.path(), crate_id);\n     workspace_dir\n }\n \n-fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path {\n+fn mk_workspace(workspace: &Path, crate_id: &CrateId) -> Path {\n     // include version number in directory name\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let package_dir = workspace.join_many([~\"src\", format!(\"{}-{}\",\n-                                           short_name.as_str().unwrap(), version.to_str())]);\n+    let package_dir = workspace.join_many([~\"src\", crate_id.short_name_with_version()]);\n     fs::mkdir_recursive(&package_dir, io::UserRWX);\n     package_dir\n }\n \n-fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n-    let workspace_dir = mk_empty_workspace(short_name, version, \"temp_workspace\");\n+fn mk_temp_workspace(crate_id: &CrateId) -> (TempDir, Path) {\n+    let workspace_dir = mk_empty_workspace(crate_id, \"temp_workspace\");\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let package_dir = workspace_dir.path().join_many([~\"src\",\n-                                                      format!(\"{}-{}\",\n-                                                              short_name.as_str().unwrap(),\n-                                                              version.to_str())]);\n+    let package_dir = workspace_dir.path().join_many([~\"src\", crate_id.short_name_with_version()]);\n \n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n            package_dir.is_dir());\n@@ -294,7 +289,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n }\n \n fn create_local_package(crateid: &CrateId) -> TempDir {\n-    let (workspace, parent_dir) = mk_temp_workspace(&crateid.path, &crateid.version);\n+    let (workspace, parent_dir) = mk_temp_workspace(crateid);\n     debug!(\"Created empty package dir for {}, returning {}\", crateid.to_str(),\n            parent_dir.display());\n     workspace\n@@ -348,11 +343,11 @@ fn create_local_package_with_custom_build_hook(crateid: &CrateId,\n \n }\n \n-fn assert_lib_exists(repo: &Path, pkg_path: &Path, v: Version) {\n+fn assert_lib_exists(repo: &Path, pkg_path: &Path, v: Option<~str>) {\n     assert!(lib_exists(repo, pkg_path, v));\n }\n \n-fn lib_exists(repo: &Path, pkg_path: &Path, _v: Version) -> bool { // ??? version?\n+fn lib_exists(repo: &Path, pkg_path: &Path, _v: Option<~str>) -> bool { // ??? version?\n     debug!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.display(), pkg_path.display());\n     let lib = installed_library_in_workspace(pkg_path, repo);\n     debug!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n@@ -475,7 +470,7 @@ fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n                          Build,\n                          workspace,\n                          \"build\",\n-                         &NoVersion).expect(\"lib_output_file_name\")\n+                         &None).expect(\"lib_output_file_name\")\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -567,7 +562,7 @@ fn test_install_valid() {\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = {}\", sysroot.display());\n     let temp_pkg_id = fake_pkg();\n-    let (temp_workspace, _pkg_dir) = mk_temp_workspace(&temp_pkg_id.path, &NoVersion);\n+    let (temp_workspace, _pkg_dir) = mk_temp_workspace(&temp_pkg_id);\n     let temp_workspace = temp_workspace.path();\n     let ctxt = fake_ctxt(sysroot, temp_workspace);\n     debug!(\"temp_workspace = {}\", temp_workspace.display());\n@@ -624,8 +619,7 @@ fn test_install_invalid() {\n #[test]\n fn test_install_valid_external() {\n     let temp_pkg_id = CrateId::new(\"foo\");\n-    let (tempdir, _) = mk_temp_workspace(&temp_pkg_id.path,\n-                                         &temp_pkg_id.version);\n+    let (tempdir, _) = mk_temp_workspace(&temp_pkg_id);\n     let temp_workspace = tempdir.path();\n     command_line_test([~\"install\", ~\"foo\"], temp_workspace);\n \n@@ -821,7 +815,7 @@ fn rustpkg_library_target() {\n \n     add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], foo_repo);\n-    assert_lib_exists(&foo_repo.join(\".rust\"), &Path::new(\"foo\"), ExactRevision(~\"1.0\"));\n+    assert_lib_exists(&foo_repo.join(\".rust\"), &Path::new(\"foo\"), Some(~\"1.0\"));\n }\n \n #[test]\n@@ -844,7 +838,7 @@ fn package_script_with_default_build() {\n     debug!(\"package_script_with_default_build: {}\", source.display());\n     fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.0\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n-    assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n+    assert_lib_exists(dir, &Path::new(\"fancy-lib\"), None);\n     assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n     let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n     debug!(\"generated path = {}\", generated_path.display());\n@@ -875,7 +869,7 @@ fn rustpkg_install_no_arg() {\n               \"fn main() { let _x = (); }\");\n     debug!(\"install_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"install\"], &package_dir);\n-    assert_lib_exists(&tmp, &Path::new(\"foo\"), NoVersion);\n+    assert_lib_exists(&tmp, &Path::new(\"foo\"), None);\n }\n \n #[test]\n@@ -898,7 +892,7 @@ fn rustpkg_clean_no_arg() {\n #[test]\n fn rust_path_test() {\n     let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n+    let dir = mk_workspace(dir_for_path.path(), &CrateId::new(\"foo\"));\n     debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n@@ -1322,8 +1316,9 @@ fn multiple_workspaces() {\n // Copy the exact same package into directory B and install it\n // Set the RUST_PATH to A:B\n // Make a third package that uses foo, make sure we can build/install it\n-    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n-    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n+    let p_id = CrateId::new(\"foo\");\n+    let (a_loc, _pkg_dir) = mk_temp_workspace(&p_id);\n+    let (b_loc, _pkg_dir) = mk_temp_workspace(&p_id);\n     let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n     debug!(\"Trying to install foo in {}\", a_loc.display());\n     command_line_test([~\"install\", ~\"foo\"], a_loc);\n@@ -1348,7 +1343,7 @@ fn rust_path_hack_test(hack_flag: bool) {\n    let p_id = CrateId::new(\"foo\");\n    let workspace = create_local_package(&p_id);\n    let workspace = workspace.path();\n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    let foo_path = workspace.join_many([\"src\", \"foo-0.0\"]);\n    let rust_path = Some(~[(~\"RUST_PATH\",\n@@ -1357,11 +1352,11 @@ fn rust_path_hack_test(hack_flag: bool) {\n                foo_path.as_str().unwrap()))]);\n    command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n                                ~[~\"foo\"], dest_workspace, rust_path);\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), None);\n    assert_executable_exists(dest_workspace, \"foo\");\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert_built_executable_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(workspace, &Path::new(\"foo\"), NoVersion));\n+   assert!(!lib_exists(workspace, &Path::new(\"foo\"), None));\n    assert!(!executable_exists(workspace, \"foo\"));\n    assert!(!built_library_exists(workspace, \"foo\"));\n    assert!(!built_executable_exists(workspace, \"foo\"));\n@@ -1396,15 +1391,15 @@ fn rust_path_hack_cwd() {\n    fs::mkdir_recursive(&cwd, io::UserRWX);\n    writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), None);\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&cwd, &Path::new(\"foo\"), NoVersion));\n+   assert!(!lib_exists(&cwd, &Path::new(\"foo\"), None));\n    assert!(!built_library_exists(&cwd, \"foo\"));\n }\n \n@@ -1417,15 +1412,15 @@ fn rust_path_hack_multi_path() {\n    writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n    let name = ~\"foo/bar/quux\";\n \n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n    debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"quux\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"quux\"), None);\n    assert_built_library_exists(dest_workspace, name);\n-   assert!(!lib_exists(&subdir, &Path::new(\"quux\"), NoVersion));\n+   assert!(!lib_exists(&subdir, &Path::new(\"quux\"), None));\n    assert!(!built_library_exists(&subdir, name));\n }\n \n@@ -1438,15 +1433,15 @@ fn rust_path_hack_install_no_arg() {\n    assert!(make_dir_rwx(&source_dir));\n    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), None);\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&source_dir, &Path::new(\"foo\"), NoVersion));\n+   assert!(!lib_exists(&source_dir, &Path::new(\"foo\"), None));\n    assert!(!built_library_exists(cwd, \"foo\"));\n }\n \n@@ -1458,7 +1453,7 @@ fn rust_path_hack_build_no_arg() {\n    assert!(make_dir_rwx(&source_dir));\n    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n@@ -1496,7 +1491,7 @@ fn rust_path_hack_build_with_dependency() {\n fn rust_path_install_target() {\n     let dir_for_path = TempDir::new(\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n-    let mut dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n+    let mut dir = mk_workspace(dir_for_path.path(), &CrateId::new(\"foo\"));\n     debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = TempDir::new(\n@@ -1608,7 +1603,7 @@ fn notrans_flag_fail() {\n                           workspace, None, BAD_FLAG_CODE);\n         assert!(!built_executable_exists(workspace, \"foo\"));\n         assert!(!object_file_exists(workspace, \"foo\"));\n-        assert!(!lib_exists(workspace, &Path::new(\"foo\"), NoVersion));\n+        assert!(!lib_exists(workspace, &Path::new(\"foo\"), None));\n     }\n }\n \n@@ -1880,17 +1875,17 @@ fn test_recursive_deps() {\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                a_workspace,\n                                environment);\n-    assert_lib_exists(a_workspace, &Path::new(\"a\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path::new(\"b\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path::new(\"c\"), NoVersion);\n+    assert_lib_exists(a_workspace, &Path::new(\"a\"), None);\n+    assert_lib_exists(b_workspace, &Path::new(\"b\"), None);\n+    assert_lib_exists(b_workspace, &Path::new(\"c\"), None);\n }\n \n #[test]\n fn test_install_to_rust_path() {\n     let p_id = CrateId::new(\"foo\");\n     let second_workspace = create_local_package(&p_id);\n     let second_workspace = second_workspace.path();\n-    let first_workspace = mk_empty_workspace(&Path::new(\"p\"), &NoVersion, \"dest\");\n+    let first_workspace = mk_empty_workspace(&CrateId::new(\"p\"), \"dest\");\n     let first_workspace = first_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\",\n@@ -1937,7 +1932,7 @@ fn test_target_specific_install_dir() {\n                        ~\"foo\"],\n                       workspace);\n     assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n-    assert_lib_exists(workspace, &Path::new(\"foo\"), NoVersion);\n+    assert_lib_exists(workspace, &Path::new(\"foo\"), None);\n     assert!(fs::readdir(&workspace.join(\"lib\")).len() == 1);\n     assert!(workspace.join(\"bin\").is_dir());\n     assert_executable_exists(workspace, \"foo\");\n@@ -1965,7 +1960,7 @@ fn install_after_build() {\n     command_line_test([~\"build\", ~\"b\"], workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n     assert_executable_exists(workspace, b_id.short_name);\n-    assert_lib_exists(workspace, &b_id.path, NoVersion);\n+    assert_lib_exists(workspace, &b_id.path, None);\n }\n \n #[test]\n@@ -1977,7 +1972,7 @@ fn reinstall() {\n     // and make sure executable was re-installed\n     command_line_test([~\"install\", ~\"b\"], workspace);\n     assert_executable_exists(workspace, b.short_name);\n-    assert_lib_exists(workspace, &b.path, NoVersion);\n+    assert_lib_exists(workspace, &b.path, None);\n     remove_executable_file(&b, workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n     assert_executable_exists(workspace, b.short_name);\n@@ -2013,7 +2008,7 @@ fn correct_package_name_with_rust_path_hack() {\n     let bar_id = CrateId::new(\"bar\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n+    let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n     let dest_workspace = dest_workspace.path();\n \n     writeFile(&dest_workspace.join_many([\"src\", \"bar-0.0\", \"main.rs\"]),\n@@ -2145,7 +2140,7 @@ fn test_installed_read_only() {\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.0\"); // this has the effect of committing the files\n     // update crateid to what will be auto-detected\n-    temp_pkg_id.version = ExactRevision(~\"0.0\");\n+    temp_pkg_id.version = Some(~\"0.0\");\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n@@ -2202,7 +2197,7 @@ fn test_installed_local_changes() {\n                                                   \"test-pkg-0.0\"]);\n     debug!(\"---- git clone {} {}\", repo_subdir.display(), target_dir.display());\n \n-    let c_res = safe_git_clone(&repo_subdir, &NoVersion, &target_dir);\n+    let c_res = safe_git_clone(&repo_subdir, &None, &target_dir);\n \n     match c_res {\n         DirToUse(_) => fail!(\"test_installed_local_changes failed\"),"}, {"sha": "b6dba40ebd46aed7600e3d4b7053116c8ec355cb", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -13,7 +13,7 @@ extern mod rustc;\n \n use std::{os, task};\n use rustpkg::api;\n-use rustpkg::version::NoVersion;\n+use rustpkg::version::None;\n use rustpkg::workcache_support::digest_file_with_date;\n use rustpkg::exit_codes::COPY_FAILED_CODE;\n \n@@ -73,7 +73,7 @@ pub fn main() {\n         api::install_pkg(&mut cc,\n                          os::getcwd(),\n                          ~\"cdep\",\n-                         NoVersion,\n+                         None,\n                          ~[(~\"binary\", out_lib_path.clone()), (~\"file\", foo_c_name.clone())]);\n     };\n "}, {"sha": "7b1291025e40b222ae51f7195943b651a606586b", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -14,7 +14,7 @@ extern mod rustc;\n use std::os;\n use std::io::File;\n use rustpkg::api;\n-use rustpkg::version::NoVersion;\n+use rustpkg::version::None;\n \n pub fn main() {\n     let args = os::args();\n@@ -48,5 +48,5 @@ pub fn main() {\n                 for _ in xs.iter() { assert!(true); } }\".as_bytes());\n \n     let context = api::default_context(sysroot, api::default_workspace());\n-    api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", NoVersion, ~[]);\n+    api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", None, ~[]);\n }"}, {"sha": "18e773d5f15a8ec02385a7d837ab1cf62d00bc06", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -315,7 +315,7 @@ pub fn compile_input(context: &BuildContext,\n             attr::mk_name_value_item_str(@\"crate_id\",\n                                          format!(\"{}\\\\#{}\",\n                                                  pkg_id.path.as_str().unwrap(),\n-                                                 pkg_id.version.to_str()).to_managed());\n+                                                 pkg_id.get_version()).to_managed());\n \n         debug!(\"crateid attr: {:?}\", crateid_attr);\n         crate.attrs.push(attr::mk_attr(crateid_attr));"}, {"sha": "93e7a052efa06d9bf29917e18968f3d6fee7ab22", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 10, "deletions": 84, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "patch": "@@ -13,83 +13,9 @@\n \n extern mod std;\n \n-use extra::semver;\n-use std::{char, result};\n+use std::char;\n \n-#[deriving(Clone)]\n-pub enum Version {\n-    ExactRevision(~str), // Should look like a m.n.(...).x\n-    SemanticVersion(semver::Version),\n-    Tagged(~str), // String that can't be parsed as a version.\n-                  // Requirements get interpreted exactly\n-    NoVersion // user didn't specify a version -- prints as 0.0\n-}\n-\n-// Equality on versions is non-symmetric: if self is NoVersion, it's equal to\n-// anything; but if self is a precise version, it's not equal to NoVersion.\n-// We should probably make equality symmetric, and use less-than and greater-than\n-// where we currently use eq\n-impl Eq for Version {\n-    fn eq(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(ref s1), &ExactRevision(ref s2)) => *s1 == *s2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => *v1 == *v2,\n-            (&NoVersion, _) => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-impl Ord for Version {\n-    fn lt(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&NoVersion, _) => true,\n-            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 < f2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 < v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn le(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&NoVersion, _) => true,\n-            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 <= f2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 <= v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn ge(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 > f2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 > v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn gt(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 >= f2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 >= v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-\n-}\n-\n-impl ToStr for Version {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            ExactRevision(ref n) | Tagged(ref n) => format!(\"{}\", n.to_str()),\n-            SemanticVersion(ref v) => format!(\"{}\", v.to_str()),\n-            NoVersion => ~\"0.0\"\n-        }\n-    }\n-}\n-\n-pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n-    match semver::parse(vers) {\n-        Some(vers) => result::Ok(vers),\n-        None => result::Err(~\"could not parse version: invalid\")\n-    }\n-}\n+pub type Version = Option<~str>;\n \n // Being lazy since we don't have a regexp library now\n #[deriving(Eq)]\n@@ -99,7 +25,7 @@ enum ParseState {\n     SawDot\n }\n \n-pub fn try_parsing_version(s: &str) -> Option<Version> {\n+pub fn try_parsing_version(s: &str) -> Option<~str> {\n     let s = s.trim();\n     debug!(\"Attempting to parse: {}\", s);\n     let mut parse_state = Start;\n@@ -115,7 +41,7 @@ pub fn try_parsing_version(s: &str) -> Option<Version> {\n         }\n     }\n     match parse_state {\n-        SawDigit => Some(ExactRevision(s.to_owned())),\n+        SawDigit => Some(s.to_owned()),\n         _        => None\n     }\n }\n@@ -136,7 +62,7 @@ pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Vers\n         Some(i) => {\n             let path = s.slice(0, i);\n             // n.b. for now, assuming an exact revision is intended, not a SemVer\n-            Some((path, ExactRevision(s.slice(i + 1, s.len()).to_owned())))\n+            Some((path, Some(s.slice(i + 1, s.len()).to_owned())))\n         }\n         None => {\n             None\n@@ -146,11 +72,11 @@ pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Vers\n \n #[test]\n fn test_parse_version() {\n-    assert!(try_parsing_version(\"1.2\") == Some(ExactRevision(~\"1.2\")));\n-    assert!(try_parsing_version(\"1.0.17\") == Some(ExactRevision(~\"1.0.17\")));\n+    assert!(try_parsing_version(\"1.2\") == Some(~\"1.2\"));\n+    assert!(try_parsing_version(\"1.0.17\") == Some(~\"1.0.17\"));\n     assert!(try_parsing_version(\"you're_a_kitty\") == None);\n     assert!(try_parsing_version(\"42..1\") == None);\n-    assert!(try_parsing_version(\"17\") == Some(ExactRevision(~\"17\")));\n+    assert!(try_parsing_version(\"17\") == Some(~\"17\"));\n     assert!(try_parsing_version(\".1.2.3\") == None);\n     assert!(try_parsing_version(\"2.3.\") == None);\n }\n@@ -159,9 +85,9 @@ fn test_parse_version() {\n fn test_split_version() {\n     let s = \"a/b/c#0.1\";\n     debug!(\"== {:?} ==\", split_version(s));\n-    assert!(split_version(s) == Some((s.slice(0, 5), ExactRevision(~\"0.1\"))));\n+    assert!(split_version(s) == Some((s.slice(0, 5), Some(~\"0.1\"))));\n     assert!(split_version(\"a/b/c\") == None);\n     let s = \"a#1.2\";\n-    assert!(split_version(s) == Some((s.slice(0, 1), ExactRevision(~\"1.2\"))));\n+    assert!(split_version(s) == Some((s.slice(0, 1), Some(~\"1.2\"))));\n     assert!(split_version(\"a#a#3.4\") == None);\n }"}]}