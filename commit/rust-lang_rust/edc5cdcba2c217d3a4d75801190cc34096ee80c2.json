{"sha": "edc5cdcba2c217d3a4d75801190cc34096ee80c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYzVjZGNiYTJjMjE3ZDNhNGQ3NTgwMTE5MGNjMzQwOTZlZTgwYzI=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-08-01T17:29:44Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-05T16:18:57Z"}, "message": "make symbols internal when possible\n\nAdd a post-processing pass to `trans` that converts symbols from external to\ninternal when possible.  Translation with multiple compilation units initially\nmakes most symbols external, since it is not clear when translating a\ndefinition whether that symbol will need to be accessed from another\ncompilation unit.  This final pass internalizes symbols that are not reachable\nfrom other crates and not referenced from other compilation units, so that LLVM\ncan perform more aggressive optimizations on those symbols.", "tree": {"sha": "469ef4354b2ed7c75b4afc8b34d6f8f63fc87aa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/469ef4354b2ed7c75b4afc8b34d6f8f63fc87aa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edc5cdcba2c217d3a4d75801190cc34096ee80c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edc5cdcba2c217d3a4d75801190cc34096ee80c2", "html_url": "https://github.com/rust-lang/rust/commit/edc5cdcba2c217d3a4d75801190cc34096ee80c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edc5cdcba2c217d3a4d75801190cc34096ee80c2/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e09bef810a95c82fa5de08872fccffdd5e0fe1e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e09bef810a95c82fa5de08872fccffdd5e0fe1e7", "html_url": "https://github.com/rust-lang/rust/commit/e09bef810a95c82fa5de08872fccffdd5e0fe1e7"}], "stats": {"total": 83, "additions": 83, "deletions": 0}, "files": [{"sha": "bed4ded095622eb1a466e778db9861924ca78d0e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/edc5cdcba2c217d3a4d75801190cc34096ee80c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc5cdcba2c217d3a4d75801190cc34096ee80c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=edc5cdcba2c217d3a4d75801190cc34096ee80c2", "patch": "@@ -85,6 +85,7 @@ use arena::TypedArena;\n use libc::{c_uint, uint64_t};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n+use std::collections::HashSet;\n use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel, Rust, RustCall};\n@@ -2891,6 +2892,84 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     return metadata;\n }\n \n+/// Find any symbols that are defined in one compilation unit, but not declared\n+/// in any other compilation unit.  Give these symbols internal linkage.\n+fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n+    use std::c_str::CString;\n+\n+    unsafe {\n+        let mut declared = HashSet::new();\n+\n+        let iter_globals = |llmod| {\n+            ValueIter {\n+                cur: llvm::LLVMGetFirstGlobal(llmod),\n+                step: llvm::LLVMGetNextGlobal,\n+            }\n+        };\n+\n+        let iter_functions = |llmod| {\n+            ValueIter {\n+                cur: llvm::LLVMGetFirstFunction(llmod),\n+                step: llvm::LLVMGetNextFunction,\n+            }\n+        };\n+\n+        // Collect all external declarations in all compilation units.\n+        for ccx in cx.iter() {\n+            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+                let linkage = llvm::LLVMGetLinkage(val);\n+                // We only care about external declarations (not definitions)\n+                // and available_externally definitions.\n+                if !(linkage == llvm::ExternalLinkage as c_uint &&\n+                     llvm::LLVMIsDeclaration(val) != 0) &&\n+                   !(linkage == llvm::AvailableExternallyLinkage as c_uint) {\n+                    continue\n+                }\n+\n+                let name = CString::new(llvm::LLVMGetValueName(val), false);\n+                declared.insert(name);\n+            }\n+        }\n+\n+        // Examine each external definition.  If the definition is not used in\n+        // any other compilation unit, and is not reachable from other crates,\n+        // then give it internal linkage.\n+        for ccx in cx.iter() {\n+            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+                // We only care about external definitions.\n+                if !(llvm::LLVMGetLinkage(val) == llvm::ExternalLinkage as c_uint &&\n+                     llvm::LLVMIsDeclaration(val) == 0) {\n+                    continue\n+                }\n+\n+                let name = CString::new(llvm::LLVMGetValueName(val), false);\n+                if !declared.contains(&name) &&\n+                   !reachable.contains_equiv(&name.as_str().unwrap()) {\n+                    llvm::SetLinkage(val, llvm::InternalLinkage);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    struct ValueIter {\n+        cur: ValueRef,\n+        step: unsafe extern \"C\" fn(ValueRef) -> ValueRef,\n+    }\n+\n+    impl Iterator<ValueRef> for ValueIter {\n+        fn next(&mut self) -> Option<ValueRef> {\n+            let old = self.cur;\n+            if !old.is_null() {\n+                self.cur = unsafe { (self.step)(old) };\n+                Some(old)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n pub fn trans_crate(krate: ast::Crate,\n                    analysis: CrateAnalysis) -> (ty::ctxt, CrateTranslation) {\n     let CrateAnalysis { ty_cx: tcx, exp_map2, reachable, name, .. } = analysis;\n@@ -3009,6 +3088,10 @@ pub fn trans_crate(krate: ast::Crate,\n     // referenced from rt/rust_try.ll\n     reachable.push(\"rust_eh_personality_catch\".to_string());\n \n+    if codegen_units > 1 {\n+        internalize_symbols(&shared_ccx, &reachable.iter().map(|x| x.clone()).collect());\n+    }\n+\n     let metadata_module = ModuleTranslation {\n         llcx: shared_ccx.metadata_llcx(),\n         llmod: shared_ccx.metadata_llmod(),"}]}