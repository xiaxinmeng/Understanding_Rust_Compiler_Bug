{"sha": "bee40a9f984614f91626686246165111dd980359", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZTQwYTlmOTg0NjE0ZjkxNjI2Njg2MjQ2MTY1MTExZGQ5ODAzNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-28T13:41:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-28T13:41:40Z"}, "message": "auto merge of #10094 : alexcrichton/rust/issue-8704, r=pcwalton\n\nThis drops more of the old C++ runtime to rather be written in rust. A few\r\nfeatures were lost along the way, but hopefully not too many. The main loss is\r\nthat there are no longer backtraces associated with allocations (rust doesn't\r\nhave a way of acquiring those just yet). Other than that though, I believe that\r\nthe rest of the debugging utilities made their way over into rust.\r\n\r\nCloses #8704", "tree": {"sha": "a0b22ab0001c3dd0fc25e5bc2a790a4f4fec2403", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0b22ab0001c3dd0fc25e5bc2a790a4f4fec2403"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bee40a9f984614f91626686246165111dd980359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bee40a9f984614f91626686246165111dd980359", "html_url": "https://github.com/rust-lang/rust/commit/bee40a9f984614f91626686246165111dd980359", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bee40a9f984614f91626686246165111dd980359/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "672edb21d9d422486230fe7dcba60100bc077c4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/672edb21d9d422486230fe7dcba60100bc077c4c", "html_url": "https://github.com/rust-lang/rust/commit/672edb21d9d422486230fe7dcba60100bc077c4c"}, {"sha": "357ef1f69cd1ffbd3c36a9e7e171b10263d94139", "url": "https://api.github.com/repos/rust-lang/rust/commits/357ef1f69cd1ffbd3c36a9e7e171b10263d94139", "html_url": "https://github.com/rust-lang/rust/commit/357ef1f69cd1ffbd3c36a9e7e171b10263d94139"}], "stats": {"total": 905, "additions": 253, "deletions": 652}, "files": [{"sha": "f1f46975e47bbc528b3563214074d0cf362cf1ce", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -89,8 +89,6 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n               rt/miniz.cpp \\\n-              rt/memory_region.cpp \\\n-              rt/boxed_region.cpp \\\n               rt/rust_android_dummy.cpp \\\n               rt/rust_test_helpers.cpp\n "}, {"sha": "7d10061e812c32bbb30b68adfeb822dd6b4e9efc", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -158,7 +158,6 @@ pub mod raw {\n     use at_vec::capacity;\n     use cast;\n     use cast::{transmute, transmute_copy};\n-    use libc;\n     use ptr;\n     use mem;\n     use uint;\n@@ -250,7 +249,7 @@ pub mod raw {\n             use rt::task::Task;\n \n             do Local::borrow |task: &mut Task| {\n-                task.heap.realloc(ptr as *libc::c_void, size) as *()\n+                task.heap.realloc(ptr as *mut Box<()>, size) as *()\n             }\n         }\n     }"}, {"sha": "7bbc8bc32fa2aacd17ec783962e8e670bc160b45", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -11,7 +11,7 @@\n #[doc(hidden)];\n \n use libc::c_void;\n-use ptr::null;\n+use ptr;\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n@@ -37,7 +37,7 @@ unsafe fn each_live_alloc(read_next_before: bool,\n     use rt::local_heap;\n \n     let mut box = local_heap::live_allocs();\n-    while box != null() {\n+    while box != ptr::mut_null() {\n         let next_before = (*box).next;\n         let uniq = (*box).ref_count == managed::RC_MANAGED_UNIQUE;\n "}, {"sha": "0811f7bbbdc46f5a377e2e30b39c42b53d246023", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -19,6 +19,7 @@ use os;\n \n static mut MIN_STACK: uint = 4000000;\n static mut DEBUG_BORROW: bool = false;\n+static mut POISON_ON_FREE: bool = false;\n \n pub fn init() {\n     unsafe {\n@@ -33,6 +34,10 @@ pub fn init() {\n             Some(_) => DEBUG_BORROW = true,\n             None => ()\n         }\n+        match os::getenv(\"RUST_POISON_ON_FREE\") {\n+            Some(_) => POISON_ON_FREE = true,\n+            None => ()\n+        }\n     }\n }\n \n@@ -43,3 +48,7 @@ pub fn min_stack() -> uint {\n pub fn debug_borrow() -> bool {\n     unsafe { DEBUG_BORROW }\n }\n+\n+pub fn poison_on_free() -> bool {\n+    unsafe { POISON_ON_FREE }\n+}"}, {"sha": "4964db8f1c1db2de6ea8380c2bffad5b43ef4dc8", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -19,7 +19,7 @@ extern {\n }\n \n #[inline]\n-fn get_box_size(body_size: uint, body_align: uint) -> uint {\n+pub fn get_box_size(body_size: uint, body_align: uint) -> uint {\n     let header_size = size_of::<raw::Box<()>>();\n     // FIXME (#2699): This alignment calculation is suspicious. Is it right?\n     let total_size = align_to(header_size, body_align) + body_size;"}, {"sha": "d5ec6bd3f370efda7ba7b3c40f489ad06cbaf6a4", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 238, "deletions": 64, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -10,79 +10,271 @@\n \n //! The local, garbage collected heap\n \n+use cast;\n+use libc::{c_void, uintptr_t};\n use libc;\n-use libc::{c_void, uintptr_t, size_t};\n+use mem;\n use ops::Drop;\n use option::{Option, None, Some};\n+use ptr;\n+use rt::env;\n+use rt::global_heap;\n use rt::local::Local;\n use rt::task::Task;\n+use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n-type MemoryRegion = c_void;\n+// This has no meaning with out rtdebug also turned on.\n+static TRACK_ALLOCATIONS: int = 0;\n+static MAGIC: u32 = 0xbadc0ffe;\n \n-struct Env { priv opaque: () }\n+pub type Box = raw::Box<()>;\n \n-struct BoxedRegion {\n-    env: *Env,\n-    backing_region: *MemoryRegion,\n-    live_allocs: *raw::Box<()>,\n+pub struct MemoryRegion {\n+    priv allocations: ~[*AllocHeader],\n+    priv live_allocations: uint,\n }\n \n-pub type OpaqueBox = c_void;\n-pub type TypeDesc = c_void;\n-\n pub struct LocalHeap {\n-    priv memory_region: *MemoryRegion,\n-    priv boxed_region: *BoxedRegion\n+    priv memory_region: MemoryRegion,\n+\n+    priv poison_on_free: bool,\n+    priv live_allocs: *mut raw::Box<()>,\n }\n \n impl LocalHeap {\n-    #[fixed_stack_segment] #[inline(never)]\n     pub fn new() -> LocalHeap {\n-        unsafe {\n-            // XXX: These usually come from the environment\n-            let detailed_leaks = false as uintptr_t;\n-            let poison_on_free = false as uintptr_t;\n-            let region = rust_new_memory_region(detailed_leaks, poison_on_free);\n-            assert!(region.is_not_null());\n-            let boxed = rust_new_boxed_region(region, poison_on_free);\n-            assert!(boxed.is_not_null());\n-            LocalHeap {\n-                memory_region: region,\n-                boxed_region: boxed\n-            }\n+        let region = MemoryRegion {\n+            allocations: ~[],\n+            live_allocations: 0,\n+        };\n+        LocalHeap {\n+            memory_region: region,\n+            poison_on_free: env::poison_on_free(),\n+            live_allocs: ptr::mut_null(),\n         }\n     }\n \n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn alloc(&mut self, td: *TypeDesc, size: uint) -> *OpaqueBox {\n-        unsafe {\n-            return rust_boxed_region_malloc(self.boxed_region, td, size as size_t);\n+    pub fn alloc(&mut self, td: *TyDesc, size: uint) -> *mut Box {\n+        let total_size = global_heap::get_box_size(size, unsafe { (*td).align });\n+        let box = self.memory_region.malloc(total_size);\n+        {\n+            // Make sure that we can't use `mybox` outside of this scope\n+            let mybox: &mut Box = unsafe { cast::transmute(box) };\n+            // Clear out this box, and move it to the front of the live\n+            // allocations list\n+            mybox.type_desc = td;\n+            mybox.ref_count = 1;\n+            mybox.prev = ptr::mut_null();\n+            mybox.next = self.live_allocs;\n+            if !self.live_allocs.is_null() {\n+                unsafe { (*self.live_allocs).prev = box; }\n+            }\n+            self.live_allocs = box;\n         }\n+        return box;\n     }\n \n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn realloc(&mut self, ptr: *OpaqueBox, size: uint) -> *OpaqueBox {\n-        unsafe {\n-            return rust_boxed_region_realloc(self.boxed_region, ptr, size as size_t);\n+    pub fn realloc(&mut self, ptr: *mut Box, size: uint) -> *mut Box {\n+        // Make sure that we can't use `mybox` outside of this scope\n+        let total_size = size + mem::size_of::<Box>();\n+        let new_box = self.memory_region.realloc(ptr, total_size);\n+        {\n+            // Fix links because we could have moved around\n+            let mybox: &mut Box = unsafe { cast::transmute(new_box) };\n+            if !mybox.prev.is_null() {\n+                unsafe { (*mybox.prev).next = new_box; }\n+            }\n+            if !mybox.next.is_null() {\n+                unsafe { (*mybox.next).prev = new_box; }\n+            }\n         }\n+        if self.live_allocs == ptr {\n+            self.live_allocs = new_box;\n+        }\n+        return new_box;\n     }\n \n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn free(&mut self, box: *OpaqueBox) {\n-        unsafe {\n-            return rust_boxed_region_free(self.boxed_region, box);\n+    pub fn free(&mut self, box: *mut Box) {\n+        {\n+            // Make sure that we can't use `mybox` outside of this scope\n+            let mybox: &mut Box = unsafe { cast::transmute(box) };\n+            assert!(!mybox.type_desc.is_null());\n+\n+            // Unlink it from the linked list\n+            if !mybox.prev.is_null() {\n+                unsafe { (*mybox.prev).next = mybox.next; }\n+            }\n+            if !mybox.next.is_null() {\n+                unsafe { (*mybox.next).prev = mybox.prev; }\n+            }\n+            if self.live_allocs == box {\n+                self.live_allocs = mybox.next;\n+            }\n+\n+            // Destroy the box memory-wise\n+            if self.poison_on_free {\n+                unsafe {\n+                    let ptr: *mut u8 = cast::transmute(&mybox.data);\n+                    ptr::set_memory(ptr, 0xab, (*mybox.type_desc).size);\n+                }\n+            }\n+            mybox.prev = ptr::mut_null();\n+            mybox.next = ptr::mut_null();\n+            mybox.type_desc = ptr::null();\n         }\n+\n+        self.memory_region.free(box);\n     }\n }\n \n impl Drop for LocalHeap {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn drop(&mut self) {\n+        assert!(self.live_allocs.is_null());\n+    }\n+}\n+\n+#[cfg(rtdebug)]\n+struct AllocHeader {\n+    magic: u32,\n+    index: i32,\n+    size: u32,\n+}\n+#[cfg(not(rtdebug))]\n+struct AllocHeader;\n+\n+impl AllocHeader {\n+    #[cfg(rtdebug)]\n+    fn init(&mut self, size: u32) {\n+        if TRACK_ALLOCATIONS > 0 {\n+            self.magic = MAGIC;\n+            self.index = -1;\n+            self.size = size;\n+        }\n+    }\n+    #[cfg(not(rtdebug))]\n+    fn init(&mut self, _size: u32) {}\n+\n+    #[cfg(rtdebug)]\n+    fn assert_sane(&self) {\n+        if TRACK_ALLOCATIONS > 0 {\n+            rtassert!(self.magic == MAGIC);\n+        }\n+    }\n+    #[cfg(not(rtdebug))]\n+    fn assert_sane(&self) {}\n+\n+    #[cfg(rtdebug)]\n+    fn update_size(&mut self, size: u32) {\n+        if TRACK_ALLOCATIONS > 0 {\n+            self.size = size;\n+        }\n+    }\n+    #[cfg(not(rtdebug))]\n+    fn update_size(&mut self, _size: u32) {}\n+\n+    fn box(&mut self) -> *mut Box {\n+        let myaddr: uint = unsafe { cast::transmute(self) };\n+        (myaddr + AllocHeader::size()) as *mut Box\n+    }\n+\n+    fn size() -> uint {\n+        // For some platforms, 16 byte alignment is required.\n+        let ptr_size = 16;\n+        let header_size = mem::size_of::<AllocHeader>();\n+        return (header_size + ptr_size - 1) / ptr_size * ptr_size;\n+    }\n+\n+    fn from(box: *mut Box) -> *mut AllocHeader {\n+        (box as uint - AllocHeader::size()) as *mut AllocHeader\n+    }\n+}\n+\n+impl MemoryRegion {\n+    fn malloc(&mut self, size: uint) -> *mut Box {\n+        let total_size = size + AllocHeader::size();\n+        let alloc: *AllocHeader = unsafe {\n+            global_heap::malloc_raw(total_size) as *AllocHeader\n+        };\n+\n+        let alloc: &mut AllocHeader = unsafe { cast::transmute(alloc) };\n+        alloc.init(size as u32);\n+        self.claim(alloc);\n+        self.live_allocations += 1;\n+\n+        return alloc.box();\n+    }\n+\n+    fn realloc(&mut self, box: *mut Box, size: uint) -> *mut Box {\n+        rtassert!(!box.is_null());\n+        let orig_alloc = AllocHeader::from(box);\n+        unsafe { (*orig_alloc).assert_sane(); }\n+\n+        let total_size = size + AllocHeader::size();\n+        let alloc: *AllocHeader = unsafe {\n+            global_heap::realloc_raw(orig_alloc as *mut libc::c_void,\n+                                     total_size) as *AllocHeader\n+        };\n+\n+        let alloc: &mut AllocHeader = unsafe { cast::transmute(alloc) };\n+        alloc.assert_sane();\n+        alloc.update_size(size as u32);\n+        self.update(alloc, orig_alloc as *AllocHeader);\n+        return alloc.box();\n+    }\n+\n+    fn free(&mut self, box: *mut Box) {\n+        rtassert!(!box.is_null());\n+        let alloc = AllocHeader::from(box);\n         unsafe {\n-            rust_delete_boxed_region(self.boxed_region);\n-            rust_delete_memory_region(self.memory_region);\n+            (*alloc).assert_sane();\n+            self.release(cast::transmute(alloc));\n+            rtassert!(self.live_allocations > 0);\n+            self.live_allocations -= 1;\n+            global_heap::exchange_free(alloc as *libc::c_char)\n+        }\n+    }\n+\n+    #[cfg(rtdebug)]\n+    fn claim(&mut self, alloc: &mut AllocHeader) {\n+        alloc.assert_sane();\n+        if TRACK_ALLOCATIONS > 1 {\n+            alloc.index = self.allocations.len() as i32;\n+            self.allocations.push(&*alloc as *AllocHeader);\n+        }\n+    }\n+    #[cfg(not(rtdebug))]\n+    fn claim(&mut self, _alloc: &mut AllocHeader) {}\n+\n+    #[cfg(rtdebug)]\n+    fn release(&mut self, alloc: &AllocHeader) {\n+        alloc.assert_sane();\n+        if TRACK_ALLOCATIONS > 1 {\n+            rtassert!(self.allocations[alloc.index] == alloc as *AllocHeader);\n+            self.allocations[alloc.index] = ptr::null();\n+        }\n+    }\n+    #[cfg(not(rtdebug))]\n+    fn release(&mut self, _alloc: &AllocHeader) {}\n+\n+    #[cfg(rtdebug)]\n+    fn update(&mut self, alloc: &mut AllocHeader, orig: *AllocHeader) {\n+        alloc.assert_sane();\n+        if TRACK_ALLOCATIONS > 1 {\n+            rtassert!(self.allocations[alloc.index] == orig);\n+            self.allocations[alloc.index] = &*alloc as *AllocHeader;\n+        }\n+    }\n+    #[cfg(not(rtdebug))]\n+    fn update(&mut self, _alloc: &mut AllocHeader, _orig: *AllocHeader) {}\n+}\n+\n+impl Drop for MemoryRegion {\n+    fn drop(&mut self) {\n+        if self.live_allocations != 0 {\n+            rtabort!(\"leaked managed memory ({} objects)\", self.live_allocations);\n         }\n+        rtassert!(self.allocations.iter().all(|s| s.is_null()));\n     }\n }\n \n@@ -91,7 +283,7 @@ pub unsafe fn local_malloc(td: *libc::c_char, size: libc::uintptr_t) -> *libc::c\n     let task: Option<*mut Task> = Local::try_unsafe_borrow();\n     match task {\n         Some(task) => {\n-            (*task).heap.alloc(td as *libc::c_void, size as uint) as *libc::c_char\n+            (*task).heap.alloc(td as *TyDesc, size as uint) as *libc::c_char\n         }\n         None => rtabort!(\"local malloc outside of task\")\n     }\n@@ -103,34 +295,16 @@ pub unsafe fn local_free(ptr: *libc::c_char) {\n     let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n     match task_ptr {\n         Some(task) => {\n-            (*task).heap.free(ptr as *libc::c_void);\n+            (*task).heap.free(ptr as *mut Box)\n         }\n         None => rtabort!(\"local free outside of task\")\n     }\n }\n \n-pub fn live_allocs() -> *raw::Box<()> {\n-    let region = do Local::borrow |task: &mut Task| {\n-        task.heap.boxed_region\n-    };\n-\n-    return unsafe { (*region).live_allocs };\n-}\n-\n-extern {\n-    fn rust_new_memory_region(detailed_leaks: uintptr_t,\n-                               poison_on_free: uintptr_t) -> *MemoryRegion;\n-    fn rust_delete_memory_region(region: *MemoryRegion);\n-    fn rust_new_boxed_region(region: *MemoryRegion,\n-                             poison_on_free: uintptr_t) -> *BoxedRegion;\n-    fn rust_delete_boxed_region(region: *BoxedRegion);\n-    fn rust_boxed_region_malloc(region: *BoxedRegion,\n-                                td: *TypeDesc,\n-                                size: size_t) -> *OpaqueBox;\n-    fn rust_boxed_region_realloc(region: *BoxedRegion,\n-                                 ptr: *OpaqueBox,\n-                                 size: size_t) -> *OpaqueBox;\n-    fn rust_boxed_region_free(region: *BoxedRegion, box: *OpaqueBox);\n+pub fn live_allocs() -> *mut Box {\n+    do Local::borrow |task: &mut Task| {\n+        task.heap.live_allocs\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "46e80f9f4e8b79737de7b90cccd44e7df7e6bd9f", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -15,8 +15,8 @@ use unstable::intrinsics::TyDesc;\n pub struct Box<T> {\n     ref_count: uint,\n     type_desc: *TyDesc,\n-    priv prev: *Box<T>,\n-    next: *Box<T>,\n+    prev: *mut Box<T>,\n+    next: *mut Box<T>,\n     data: T\n }\n "}, {"sha": "064648a9671a171d39b04696f7934a539f35524e", "filename": "src/rt/boxed_region.cpp", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/672edb21d9d422486230fe7dcba60100bc077c4c/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/672edb21d9d422486230fe7dcba60100bc077c4c/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=672edb21d9d422486230fe7dcba60100bc077c4c", "patch": "@@ -1,99 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include \"memory_region.h\"\n-#include \"boxed_region.h\"\n-#include \"rust_globals.h\"\n-#include \"rust_util.h\"\n-\n-// #define DUMP_BOXED_REGION\n-\n-rust_opaque_box *boxed_region::malloc(type_desc *td, size_t body_size) {\n-    size_t total_size = get_box_size(body_size, td->align);\n-    rust_opaque_box *box =\n-      (rust_opaque_box*)backing_region->malloc(total_size, \"@\");\n-    box->td = td;\n-    box->ref_count = 1;\n-    box->prev = NULL;\n-    box->next = live_allocs;\n-    if (live_allocs) live_allocs->prev = box;\n-    live_allocs = box;\n-\n-    /*LOG(rust_get_current_task(), box,\n-        \"@malloc()=%p with td %p, size %lu==%lu+%lu, \"\n-        \"align %lu, prev %p, next %p\\n\",\n-        box, td, total_size, sizeof(rust_opaque_box), body_size,\n-        td->align, box->prev, box->next);*/\n-\n-    return box;\n-}\n-\n-rust_opaque_box *boxed_region::realloc(rust_opaque_box *box,\n-                                       size_t new_size) {\n-\n-    size_t total_size = new_size + sizeof(rust_opaque_box);\n-    rust_opaque_box *new_box =\n-        (rust_opaque_box*)backing_region->realloc(box, total_size);\n-    if (new_box->prev) new_box->prev->next = new_box;\n-    if (new_box->next) new_box->next->prev = new_box;\n-    if (live_allocs == box) live_allocs = new_box;\n-\n-    /*LOG(rust_get_current_task(), box,\n-        \"@realloc()=%p with orig=%p, size %lu==%lu+%lu\",\n-        new_box, box, total_size, sizeof(rust_opaque_box), new_size);*/\n-\n-    return new_box;\n-}\n-\n-\n-rust_opaque_box *boxed_region::calloc(type_desc *td, size_t body_size) {\n-    rust_opaque_box *box = malloc(td, body_size);\n-    memset(box_body(box), 0, td->size);\n-    return box;\n-}\n-\n-void boxed_region::free(rust_opaque_box *box) {\n-    // This turns out to not be true in various situations,\n-    // like when we are unwinding after a failure.\n-    //\n-    // assert(box->ref_count == 0);\n-\n-    // This however should always be true.  Helps to detect\n-    // double frees (kind of).\n-    assert(box->td != NULL);\n-\n-    /*LOG(rust_get_current_task(), box,\n-        \"@free(%p) with td %p, prev %p, next %p\\n\",\n-        box, box->td, box->prev, box->next);*/\n-\n-    if (box->prev) box->prev->next = box->next;\n-    if (box->next) box->next->prev = box->prev;\n-    if (live_allocs == box) live_allocs = box->next;\n-\n-    if (poison_on_free) {\n-        memset(box_body(box), 0xab, box->td->size);\n-    }\n-\n-    box->prev = NULL;\n-    box->next = NULL;\n-    box->td = NULL;\n-\n-    backing_region->free(box);\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "178772007e51842adabc67d9a307baeecb435ecc", "filename": "src/rt/boxed_region.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/672edb21d9d422486230fe7dcba60100bc077c4c/src%2Frt%2Fboxed_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/672edb21d9d422486230fe7dcba60100bc077c4c/src%2Frt%2Fboxed_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.h?ref=672edb21d9d422486230fe7dcba60100bc077c4c", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef BOXED_REGION_H\n-#define BOXED_REGION_H\n-\n-#include <stdlib.h>\n-\n-struct type_desc;\n-class memory_region;\n-struct rust_opaque_box;\n-struct rust_env;\n-\n-/* Tracks the data allocated by a particular task in the '@' region.\n- * Currently still relies on the standard malloc as a backing allocator, but\n- * this could be improved someday if necessary. Every allocation must provide\n- * a type descr which describes the payload (what follows the header). */\n-class boxed_region {\n-private:\n-    bool poison_on_free;\n-    memory_region *backing_region;\n-    rust_opaque_box *live_allocs;\n-\n-    size_t align_to(size_t v, size_t align) {\n-        size_t alignm1 = align - 1;\n-        v += alignm1;\n-        v &= ~alignm1;\n-        return v;\n-    }\n-\n-private:\n-    // private and undefined to disable copying\n-    boxed_region(const boxed_region& rhs);\n-    boxed_region& operator=(const boxed_region& rhs);\n-\n-public:\n-    boxed_region(memory_region *br, bool poison_on_free)\n-        : poison_on_free(poison_on_free)\n-        , backing_region(br)\n-        , live_allocs(NULL)\n-    {}\n-\n-    rust_opaque_box *first_live_alloc() { return live_allocs; }\n-\n-    rust_opaque_box *malloc(type_desc *td, size_t body_size);\n-    rust_opaque_box *calloc(type_desc *td, size_t body_size);\n-    rust_opaque_box *realloc(rust_opaque_box *box, size_t new_size);\n-    void free(rust_opaque_box *box);\n-};\n-\n-#endif /* BOXED_REGION_H */\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "4a34312c6d4a5582cfb6b7bcc64dfccbb10ddfe4", "filename": "src/rt/memory_region.cpp", "status": "removed", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/672edb21d9d422486230fe7dcba60100bc077c4c/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/672edb21d9d422486230fe7dcba60100bc077c4c/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=672edb21d9d422486230fe7dcba60100bc077c4c", "patch": "@@ -1,258 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"memory_region.h\"\n-\n-#if RUSTRT_TRACK_ALLOCATIONS >= 3\n-#include <execinfo.h>\n-#endif\n-\n-#if RUSTRT_TRACK_ALLOCATIONS >= 1\n-// For some platforms, 16 byte alignment is required.\n-#  define PTR_SIZE 16\n-#  define ALIGN_PTR(x) (((x)+PTR_SIZE-1)/PTR_SIZE*PTR_SIZE)\n-#  define HEADER_SIZE ALIGN_PTR(sizeof(alloc_header))\n-#  define MAGIC 0xbadc0ffe\n-#else\n-#  define HEADER_SIZE 0\n-#endif\n-\n-memory_region::alloc_header *memory_region::get_header(void *mem) {\n-    return (alloc_header *)((char *)mem - HEADER_SIZE);\n-}\n-\n-void *memory_region::get_data(alloc_header *ptr) {\n-    return (void*)((char *)ptr + HEADER_SIZE);\n-}\n-\n-inline void memory_region::maybe_print_backtrace(const alloc_header *header) const {\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 3\n-    if (_detailed_leaks) {\n-        backtrace_symbols_fd(header->bt + 1, header->btframes - 1, 2);\n-    }\n-#   endif\n-}\n-\n-memory_region::memory_region(bool detailed_leaks,\n-                             bool poison_on_free) :\n-    _parent(NULL), _live_allocations(0),\n-    _detailed_leaks(detailed_leaks),\n-    _poison_on_free(poison_on_free) {\n-}\n-\n-memory_region::memory_region(memory_region *parent) :\n-    _parent(parent), _live_allocations(0),\n-    _detailed_leaks(parent->_detailed_leaks),\n-    _poison_on_free(parent->_poison_on_free) {\n-}\n-\n-void memory_region::add_alloc() {\n-    _live_allocations++;\n-}\n-\n-void memory_region::dec_alloc() {\n-    _live_allocations--;\n-}\n-\n-void memory_region::free(void *mem) {\n-    // printf(\"free: ptr 0x%\" PRIxPTR\" region=%p\\n\", (uintptr_t) mem, this);\n-    if (!mem) { return; }\n-    alloc_header *alloc = get_header(mem);\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n-    assert(alloc->magic == MAGIC);\n-#   endif\n-\n-    if (_live_allocations < 1) {\n-        assert(false && \"live_allocs < 1\");\n-    }\n-    release_alloc(mem);\n-    maybe_poison(mem);\n-    ::free(alloc);\n-}\n-\n-void *\n-memory_region::realloc(void *mem, size_t orig_size) {\n-    if (!mem) {\n-        add_alloc();\n-    }\n-\n-    alloc_header *alloc = get_header(mem);\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n-    assert(alloc->magic == MAGIC);\n-#   endif\n-\n-    size_t size = orig_size + HEADER_SIZE;\n-    alloc_header *newMem = (alloc_header *)::realloc(alloc, size);\n-    if (newMem == NULL) {\n-        fprintf(stderr,\n-                \"memory_region::realloc> \"\n-                \"Out of memory allocating %ld bytes\",\n-                (long int) size);\n-        abort();\n-    }\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n-    assert(newMem->magic == MAGIC);\n-    newMem->size = orig_size;\n-#   endif\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 2\n-    if (_allocation_list[newMem->index] != alloc) {\n-        printf(\"at index %d, found %p, expected %p\\n\",\n-               alloc->index, _allocation_list[alloc->index], alloc);\n-        printf(\"realloc: ptr 0x%\" PRIxPTR \" (%s) is not in allocation_list\\n\",\n-               (uintptr_t) get_data(alloc), alloc->tag);\n-        assert(false && \"not in allocation_list\");\n-    }\n-    else {\n-        _allocation_list[newMem->index] = newMem;\n-        // printf(\"realloc: stored %p at index %d, replacing %p\\n\",\n-        //        newMem, index, mem);\n-    }\n-#   endif\n-\n-    return get_data(newMem);\n-}\n-\n-void *\n-memory_region::malloc(size_t size, const char *tag) {\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n-    size_t old_size = size;\n-#   endif\n-    size += HEADER_SIZE;\n-    alloc_header *mem = (alloc_header *)::malloc(size);\n-    if (mem == NULL) {\n-        fprintf(stderr,\n-                \"memory_region::malloc> \"\n-                \"Out of memory allocating %ld bytes\",\n-                (long int) size);\n-        abort();\n-    }\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n-    mem->magic = MAGIC;\n-    mem->tag = tag;\n-    mem->index = -1;\n-    mem->size = old_size;\n-#   endif\n-\n-    void *data = get_data(mem);\n-    claim_alloc(data);\n-\n-    return data;\n-}\n-\n-memory_region::~memory_region() {\n-    if (_live_allocations == 0 && !_detailed_leaks) {\n-        return;\n-    }\n-    char msg[128];\n-    if(_live_allocations > 0) {\n-        snprintf(msg, sizeof(msg),\n-                 \"leaked memory in rust main loop (%d objects)\",\n-                 _live_allocations);\n-    }\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 2\n-    if (_detailed_leaks) {\n-        int leak_count = 0;\n-        for (size_t i = 0; i < _allocation_list.size(); i++) {\n-            if (_allocation_list[i] != NULL) {\n-                alloc_header *header = (alloc_header*)_allocation_list[i];\n-                printf(\"allocation (%s) 0x%\" PRIxPTR \" was not freed\\n\",\n-                       header->tag,\n-                       (uintptr_t) get_data(header));\n-                ++leak_count;\n-                maybe_print_backtrace(header);\n-            }\n-        }\n-        assert(leak_count == _live_allocations);\n-    }\n-#   endif\n-\n-    if (_live_allocations > 0) {\n-        fprintf(stderr, \"%s\\n\", msg);\n-        assert(false);\n-    }\n-}\n-\n-void\n-memory_region::release_alloc(void *mem) {\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n-    alloc_header *alloc = get_header(mem);\n-    assert(alloc->magic == MAGIC);\n-#   endif\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 2\n-    if (((size_t) alloc->index) >= _allocation_list.size()) {\n-        printf(\"free: ptr 0x%\" PRIxPTR \" (%s) index %d is beyond allocation_list of size %zu\\n\",\n-               (uintptr_t) get_data(alloc), alloc->tag, alloc->index, _allocation_list.size());\n-        maybe_print_backtrace(alloc);\n-        assert(false && \"index beyond allocation_list\");\n-    }\n-    if (_allocation_list[alloc->index] != alloc) {\n-        printf(\"free: ptr 0x%\" PRIxPTR \" (%s) is not in allocation_list\\n\",\n-               (uintptr_t) get_data(alloc), alloc->tag);\n-        maybe_print_backtrace(alloc);\n-        assert(false && \"not in allocation_list\");\n-    }\n-    else {\n-        // printf(\"freed index %d\\n\", index);\n-        _allocation_list[alloc->index] = NULL;\n-        alloc->index = -1;\n-    }\n-#   endif\n-\n-    dec_alloc();\n-}\n-\n-void\n-memory_region::claim_alloc(void *mem) {\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n-    alloc_header *alloc = get_header(mem);\n-    assert(alloc->magic == MAGIC);\n-#   endif\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 2\n-    alloc->index = _allocation_list.append(alloc);\n-#   endif\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 3\n-    if (_detailed_leaks) {\n-        alloc->btframes = ::backtrace(alloc->bt, 32);\n-    }\n-#   endif\n-\n-    add_alloc();\n-}\n-\n-void\n-memory_region::maybe_poison(void *mem) {\n-\n-    if (!_poison_on_free)\n-        return;\n-\n-#   if RUSTRT_TRACK_ALLOCATIONS >= 1\n-    alloc_header *alloc = get_header(mem);\n-    memset(mem, '\\xcd', alloc->size);\n-#   endif\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "ace463ede2187eb4c5527bd049c14f9b5fc37e00", "filename": "src/rt/memory_region.h", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/672edb21d9d422486230fe7dcba60100bc077c4c/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/672edb21d9d422486230fe7dcba60100bc077c4c/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=672edb21d9d422486230fe7dcba60100bc077c4c", "patch": "@@ -1,107 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n- * The Rust runtime uses memory regions to provide a primitive level of\n- * memory management and isolation between tasks, and domains.\n- *\n- * FIXME (#2686): Implement a custom lock-free malloc / free instead of\n- *       relying solely on the standard malloc / free.\n- */\n-\n-#ifndef MEMORY_REGION_H\n-#define MEMORY_REGION_H\n-\n-#include \"rust_globals.h\"\n-#include \"sync/lock_and_signal.h\"\n-#include \"util/array_list.h\"\n-\n-// There are three levels of debugging:\n-//\n-// 0 --- no headers, no debugging support\n-// 1 --- support poison, but do not track allocations\n-// 2 --- track allocations in detail\n-// 3 --- record backtraces of every allocation\n-//\n-// NB: please do not commit code with level 2. It's\n-// hugely expensive and should only be used as a last resort.\n-#define RUSTRT_TRACK_ALLOCATIONS 0\n-\n-struct rust_env;\n-\n-class memory_region {\n-private:\n-    struct alloc_header {\n-#       if RUSTRT_TRACK_ALLOCATIONS > 0\n-        uint32_t magic;\n-        int index;\n-        const char *tag;\n-        uint32_t size;\n-#       if RUSTRT_TRACK_ALLOCATIONS >= 3\n-        void *bt[32];\n-        int btframes;\n-#       endif\n-#       endif\n-    };\n-\n-    inline alloc_header *get_header(void *mem);\n-    inline void *get_data(alloc_header *);\n-\n-    memory_region *_parent;\n-    int _live_allocations;\n-    array_list<alloc_header *> _allocation_list;\n-    const bool _detailed_leaks;\n-    const bool _poison_on_free;\n-    lock_and_signal _lock;\n-\n-    void add_alloc();\n-    void dec_alloc();\n-    void maybe_poison(void *mem);\n-\n-    void release_alloc(void *mem);\n-    void claim_alloc(void *mem);\n-\n-    void maybe_print_backtrace(const alloc_header *) const;\n-\n-private:\n-    // private and undefined to disable copying\n-    memory_region(const memory_region& rhs);\n-    memory_region& operator=(const memory_region& rhs);\n-\n-public:\n-    memory_region(bool detailed_leaks, bool poison_on_free);\n-    memory_region(memory_region *parent);\n-    void *malloc(size_t size, const char *tag);\n-    void *realloc(void *mem, size_t size);\n-    void free(void *mem);\n-    ~memory_region();\n- };\n-\n-inline void *operator new(size_t size, memory_region &region,\n-                          const char *tag) {\n-    return region.malloc(size, tag);\n-}\n-\n-inline void *operator new(size_t size, memory_region *region,\n-                          const char *tag) {\n-    return region->malloc(size, tag);\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//\n-\n-#endif /* MEMORY_REGION_H */"}, {"sha": "90cfd98bc485933ca93b3cfc5b9259e256b04727", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -13,8 +13,6 @@\n #include \"rust_util.h\"\n #include \"sync/rust_thread.h\"\n #include \"sync/lock_and_signal.h\"\n-#include \"memory_region.h\"\n-#include \"boxed_region.h\"\n #include \"vg/valgrind.h\"\n \n #include <time.h>\n@@ -477,44 +475,6 @@ rust_initialize_rt_tls_key(tls_key *key) {\n     }\n }\n \n-extern \"C\" CDECL memory_region*\n-rust_new_memory_region(uintptr_t detailed_leaks,\n-                       uintptr_t poison_on_free) {\n-    return new memory_region((bool)detailed_leaks,\n-                             (bool)poison_on_free);\n-}\n-\n-extern \"C\" CDECL void\n-rust_delete_memory_region(memory_region *region) {\n-    delete region;\n-}\n-\n-extern \"C\" CDECL boxed_region*\n-rust_new_boxed_region(memory_region *region,\n-                      uintptr_t poison_on_free) {\n-    return new boxed_region(region, poison_on_free);\n-}\n-\n-extern \"C\" CDECL void\n-rust_delete_boxed_region(boxed_region *region) {\n-    delete region;\n-}\n-\n-extern \"C\" CDECL rust_opaque_box*\n-rust_boxed_region_malloc(boxed_region *region, type_desc *td, size_t size) {\n-    return region->malloc(td, size);\n-}\n-\n-extern \"C\" CDECL rust_opaque_box*\n-rust_boxed_region_realloc(boxed_region *region, rust_opaque_box *ptr, size_t size) {\n-    return region->realloc(ptr, size);\n-}\n-\n-extern \"C\" CDECL void\n-rust_boxed_region_free(boxed_region *region, rust_opaque_box *box) {\n-    region->free(box);\n-}\n-\n typedef void *(rust_try_fn)(void*, void*);\n \n extern \"C\" CDECL uintptr_t"}, {"sha": "47c9554daa0189c95a49e6f3224e4cb287bde0cc", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bee40a9f984614f91626686246165111dd980359/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/bee40a9f984614f91626686246165111dd980359/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=bee40a9f984614f91626686246165111dd980359", "patch": "@@ -164,13 +164,6 @@ rust_uv_free_ip4_addr\n rust_uv_free_ip6_addr\n rust_initialize_rt_tls_key\n rust_dbg_next_port\n-rust_new_memory_region\n-rust_delete_memory_region\n-rust_new_boxed_region\n-rust_delete_boxed_region\n-rust_boxed_region_malloc\n-rust_boxed_region_realloc\n-rust_boxed_region_free\n rust_try\n rust_begin_unwind\n rust_valgrind_stack_register"}]}