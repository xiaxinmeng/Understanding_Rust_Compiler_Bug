{"sha": "083f1d7a37a5b439c1b9325e7860ef4fd880d418", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4M2YxZDdhMzdhNWI0MzljMWI5MzI1ZTc4NjBlZjRmZDg4MGQ0MTg=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-30T15:58:39Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-19T08:36:36Z"}, "message": "Validate constants during `const_eval_raw`", "tree": {"sha": "a4213ffbe5424013b5599f05661020db92feeb4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4213ffbe5424013b5599f05661020db92feeb4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/083f1d7a37a5b439c1b9325e7860ef4fd880d418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/083f1d7a37a5b439c1b9325e7860ef4fd880d418", "html_url": "https://github.com/rust-lang/rust/commit/083f1d7a37a5b439c1b9325e7860ef4fd880d418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/083f1d7a37a5b439c1b9325e7860ef4fd880d418/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac19c3bda18ed5b692668725f7acac988f0aa2be", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac19c3bda18ed5b692668725f7acac988f0aa2be", "html_url": "https://github.com/rust-lang/rust/commit/ac19c3bda18ed5b692668725f7acac988f0aa2be"}], "stats": {"total": 114, "additions": 62, "deletions": 52}, "files": [{"sha": "dd2731fb0a0166b459c7e777eaca264a379afd8a", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/083f1d7a37a5b439c1b9325e7860ef4fd880d418/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083f1d7a37a5b439c1b9325e7860ef4fd880d418/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=083f1d7a37a5b439c1b9325e7860ef4fd880d418", "patch": "@@ -193,21 +193,7 @@ fn validate_and_turn_into_const<'tcx>(\n     let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n     let val = (|| {\n         let mplace = ecx.raw_const_to_mplace(constant)?;\n-\n-        // FIXME do not validate promoteds until a decision on\n-        // https://github.com/rust-lang/rust/issues/67465 is made\n-        if cid.promoted.is_none() {\n-            let mut ref_tracking = RefTracking::new(mplace);\n-            while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                ecx.const_validate_operand(\n-                    mplace.into(),\n-                    path,\n-                    &mut ref_tracking,\n-                    /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n-                )?;\n-            }\n-        }\n-        // Now that we validated, turn this into a proper constant.\n+        // Turn this into a proper constant.\n         // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n         // whether they become immediates.\n         if is_static || cid.promoted.is_some() {\n@@ -221,6 +207,7 @@ fn validate_and_turn_into_const<'tcx>(\n         }\n     })();\n \n+    // FIXME: Can this ever be an error and not be a compiler bug or can we just ICE here?\n     val.map_err(|error| {\n         let err = ConstEvalErr::new(&ecx, error, None);\n         err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n@@ -319,7 +306,6 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n-        .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         .map_err(|error| {\n             let err = ConstEvalErr::new(&ecx, error, None);\n             // errors in statics are always emitted as fatal errors\n@@ -397,4 +383,37 @@ pub fn const_eval_raw_provider<'tcx>(\n                 err.report_as_error(ecx.tcx.at(ecx.cur_span()), \"could not evaluate constant\")\n             }\n         })\n+        .and_then(|mplace| {\n+            // Since evaluation had no errors, valiate the resulting constant:\n+            let validation = try {\n+                // FIXME do not validate promoteds until a decision on\n+                // https://github.com/rust-lang/rust/issues/67465 is made\n+                if cid.promoted.is_none() {\n+                    let mut ref_tracking = RefTracking::new(mplace);\n+                    while let Some((mplace, path)) = ref_tracking.todo.pop() {\n+                        ecx.const_validate_operand(\n+                            mplace.into(),\n+                            path,\n+                            &mut ref_tracking,\n+                            /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n+                        )?;\n+                    }\n+                }\n+            };\n+            if let Err(error) = validation {\n+                // Validation failed, report an error\n+                let err = ConstEvalErr::new(&ecx, error, None);\n+                Err(err.struct_error(\n+                    ecx.tcx,\n+                    \"it is undefined behavior to use this value\",\n+                    |mut diag| {\n+                        diag.note(note_on_undefined_behavior_error());\n+                        diag.emit();\n+                    },\n+                ))\n+            } else {\n+                // Convert to raw constant\n+                Ok(RawConst { alloc_id: mplace.ptr.assert_ptr().alloc_id, ty: mplace.layout.ty })\n+            }\n+        })\n }"}, {"sha": "7d9507c08fa1849637ae0432415057bd400c9f98", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/083f1d7a37a5b439c1b9325e7860ef4fd880d418/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083f1d7a37a5b439c1b9325e7860ef4fd880d418/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=083f1d7a37a5b439c1b9325e7860ef4fd880d418", "patch": "@@ -425,26 +425,28 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n+                    assert!(self.ecx.tcx.is_static(did));\n                     // See const_eval::machine::MemoryExtra::can_access_statics for why\n                     // this check is so important.\n                     // This check is reachable when the const just referenced the static,\n                     // but never read it (so we never entered `before_access_global`).\n                     // We also need to do it here instead of going on to avoid running\n                     // into the `before_access_global` check during validation.\n-                    if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n+                    if !self.may_ref_to_static {\n                         throw_validation_failure!(self.path,\n                             { \"a {} pointing to a static variable\", kind }\n                         );\n                     }\n-                    // `extern static` cannot be validated as they have no body.\n-                    // FIXME: Statics from other crates are also skipped.\n-                    // They might be checked at a different type, but for now we\n-                    // want to avoid recursing too deeply.  We might miss const-invalid data,\n+                    // We skip checking other statics. These statics must be sound by themselves,\n+                    // and the only way to get broken statics here is by using unsafe code.\n+                    // The reasons we don't check other statics is twofold. For one, in all sound\n+                    // cases, the static was already validated on its own, and second, we trigger\n+                    // cycle errors if we try to compute the value of the other static and that\n+                    // static refers back to us.\n+                    // We might miss const-invalid data,\n                     // but things are still sound otherwise (in particular re: consts\n                     // referring to statics).\n-                    if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n-                        return Ok(());\n-                    }\n+                    return Ok(());\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!"}, {"sha": "e1f3e5bb27a8f730631c9df4a64053e9a0b07b16", "filename": "src/test/ui/consts/const-eval/double_check2.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/083f1d7a37a5b439c1b9325e7860ef4fd880d418/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083f1d7a37a5b439c1b9325e7860ef4fd880d418/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.rs?ref=083f1d7a37a5b439c1b9325e7860ef4fd880d418", "patch": "@@ -1,3 +1,11 @@\n+// check-pass\n+\n+// This test exhibits undefined behavior, but it is impossible to prevent generally during\n+// const eval, even if possible to prevent in the cases here. The reason it's impossible in general\n+// is that we run into query cycles even *without* UB, just because we're checking for UB.\n+// We do not detect it if you create references to statics\n+// in ways that are UB.\n+\n enum Foo {\n     A = 5,\n     B = 42,\n@@ -13,11 +21,14 @@ union Union {\n     u8: &'static u8,\n }\n static BAR: u8 = 5;\n-static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n-    Union { u8: &BAR }.foo,\n-    Union { u8: &BAR }.bar,\n-)};\n-static FOO2: (&Foo, &Bar) = unsafe {(std::mem::transmute(&BAR), std::mem::transmute(&BAR))};\n-//~^ undefined behavior\n+static FOO: (&Foo, &Bar) = unsafe {\n+    (\n+        // undefined behavior\n+        Union { u8: &BAR }.foo,\n+        Union { u8: &BAR }.bar,\n+    )\n+};\n+static FOO2: (&Foo, &Bar) = unsafe { (std::mem::transmute(&BAR), std::mem::transmute(&BAR)) };\n+//^ undefined behavior\n \n fn main() {}"}, {"sha": "84f60809156d0201d9543c09695b39b8bcb02db7", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac19c3bda18ed5b692668725f7acac988f0aa2be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac19c3bda18ed5b692668725f7acac988f0aa2be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=ac19c3bda18ed5b692668725f7acac988f0aa2be", "patch": "@@ -1,22 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/double_check2.rs:16:1\n-   |\n-LL | / static FOO: (&Foo, &Bar) = unsafe {(\n-LL | |     Union { u8: &BAR }.foo,\n-LL | |     Union { u8: &BAR }.bar,\n-LL | | )};\n-   | |___^ type validation failed: encountered 0x05 at .1.<deref>.<enum-tag>, but expected a valid enum tag\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/double_check2.rs:20:1\n-   |\n-LL | static FOO2: (&Foo, &Bar) = unsafe {(std::mem::transmute(&BAR), std::mem::transmute(&BAR))};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x05 at .1.<deref>.<enum-tag>, but expected a valid enum tag\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}]}