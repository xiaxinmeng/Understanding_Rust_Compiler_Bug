{"sha": "8cf9e9efcadef137b9f04c741115aa8664a5a910", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZjllOWVmY2FkZWYxMzdiOWYwNGM3NDExMTVhYTg2NjRhNWE5MTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-17T11:16:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-17T11:16:10Z"}, "message": "Rollup merge of #68746 - matthewjasper:metahygiene, r=petrochenkov\n\nMake macro metavars respect (non-)hygiene\n\nThis makes them more consistent with other name resolution while not breaking any code on crater.", "tree": {"sha": "be7fda22926e5869219e8741eecb9f6c51da520d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be7fda22926e5869219e8741eecb9f6c51da520d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf9e9efcadef137b9f04c741115aa8664a5a910", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJecLF7CRBK7hj4Ov3rIwAAdHIIAGB5D/sn6zs57PPM/aYLWruh\nonE4bYXihNY9kx7iXrHUl9+A0755FAzWH8sICsm850lpjxlZdnFqO24ozF6yAvjy\nCATiXxPsv4/EzogpH50YZTZ6pK+t4frKYxUejUCdxrdglvE6xNY+p0Y3tiHSVkjB\nYX71u9/pEmamkG2S1AZKPLanozS7McSgKxre1D23GOL/9Gj5C6dPKbf5+qvoYJdi\ns+H8n/F/D/LtSH2JHaEfBuznB2pe+kRNpstoMDJWLQEI1tGjtYOS+tl2+eWrQUF2\nG5quZgquvSU+AvfpU8ha4IhqwrdFA29qkWXdp9ILeZ4s8NUd+lpzams92JudAXk=\n=OT0r\n-----END PGP SIGNATURE-----\n", "payload": "tree be7fda22926e5869219e8741eecb9f6c51da520d\nparent 5e9ebf4da3522c479aea9c242cb3686f8d6afa78\nparent ec862703fde44d23f7da8bc5fdd94a63354d5daf\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584443770 +0100\ncommitter GitHub <noreply@github.com> 1584443770 +0100\n\nRollup merge of #68746 - matthewjasper:metahygiene, r=petrochenkov\n\nMake macro metavars respect (non-)hygiene\n\nThis makes them more consistent with other name resolution while not breaking any code on crater.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf9e9efcadef137b9f04c741115aa8664a5a910", "html_url": "https://github.com/rust-lang/rust/commit/8cf9e9efcadef137b9f04c741115aa8664a5a910", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf9e9efcadef137b9f04c741115aa8664a5a910/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "html_url": "https://github.com/rust-lang/rust/commit/5e9ebf4da3522c479aea9c242cb3686f8d6afa78"}, {"sha": "ec862703fde44d23f7da8bc5fdd94a63354d5daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec862703fde44d23f7da8bc5fdd94a63354d5daf", "html_url": "https://github.com/rust-lang/rust/commit/ec862703fde44d23f7da8bc5fdd94a63354d5daf"}], "stats": {"total": 135, "additions": 111, "deletions": 24}, "files": [{"sha": "582c26162ed6d29e2cfb72cef169c71f7c7a5073", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=8cf9e9efcadef137b9f04c741115aa8664a5a910", "patch": "@@ -112,7 +112,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_session::lint::builtin::META_VARIABLE_MISUSE;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::kw;\n-use rustc_span::{symbol::Ident, MultiSpan, Span};\n+use rustc_span::{symbol::MacroRulesNormalizedIdent, MultiSpan, Span};\n \n use smallvec::SmallVec;\n \n@@ -179,7 +179,7 @@ struct BinderInfo {\n }\n \n /// An environment of meta-variables to their binder information.\n-type Binders = FxHashMap<Ident, BinderInfo>;\n+type Binders = FxHashMap<MacroRulesNormalizedIdent, BinderInfo>;\n \n /// The state at which we entered a macro definition in the RHS of another macro definition.\n struct MacroState<'a> {\n@@ -245,6 +245,7 @@ fn check_binders(\n             if macros.is_empty() {\n                 sess.span_diagnostic.span_bug(span, \"unexpected MetaVar in lhs\");\n             }\n+            let name = MacroRulesNormalizedIdent::new(name);\n             // There are 3 possibilities:\n             if let Some(prev_info) = binders.get(&name) {\n                 // 1. The meta-variable is already bound in the current LHS: This is an error.\n@@ -264,6 +265,7 @@ fn check_binders(\n             if !macros.is_empty() {\n                 sess.span_diagnostic.span_bug(span, \"unexpected MetaVarDecl in nested lhs\");\n             }\n+            let name = MacroRulesNormalizedIdent::new(name);\n             if let Some(prev_info) = get_binder_info(macros, binders, name) {\n                 // Duplicate binders at the top-level macro definition are errors. The lint is only\n                 // for nested macro definitions.\n@@ -300,7 +302,7 @@ fn check_binders(\n fn get_binder_info<'a>(\n     mut macros: &'a Stack<'a, MacroState<'a>>,\n     binders: &'a Binders,\n-    name: Ident,\n+    name: MacroRulesNormalizedIdent,\n ) -> Option<&'a BinderInfo> {\n     binders.get(&name).or_else(|| macros.find_map(|state| state.binders.get(&name)))\n }\n@@ -331,6 +333,7 @@ fn check_occurrences(\n             sess.span_diagnostic.span_bug(span, \"unexpected MetaVarDecl in rhs\")\n         }\n         TokenTree::MetaVar(span, name) => {\n+            let name = MacroRulesNormalizedIdent::new(name);\n             check_ops_is_prefix(sess, node_id, macros, binders, ops, span, name);\n         }\n         TokenTree::Delimited(_, ref del) => {\n@@ -552,7 +555,7 @@ fn check_ops_is_prefix(\n     binders: &Binders,\n     ops: &Stack<'_, KleeneToken>,\n     span: Span,\n-    name: Ident,\n+    name: MacroRulesNormalizedIdent,\n ) {\n     let macros = macros.push(MacroState { binders, ops: ops.into() });\n     // Accumulates the stacks the operators of each state until (and including when) the\n@@ -598,7 +601,7 @@ fn ops_is_prefix(\n     sess: &ParseSess,\n     node_id: NodeId,\n     span: Span,\n-    name: Ident,\n+    name: MacroRulesNormalizedIdent,\n     binder_ops: &[KleeneToken],\n     occurrence_ops: &[KleeneToken],\n ) {"}, {"sha": "3b9158f444519f1cc64c80244b9c874789242444", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=8cf9e9efcadef137b9f04c741115aa8664a5a910", "patch": "@@ -76,13 +76,13 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::mbe::{self, TokenTree};\n \n-use rustc_ast::ast::{Ident, Name};\n+use rustc_ast::ast::Name;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n use rustc_ast_pretty::pprust;\n use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n \n use rustc_errors::{FatalError, PResult};\n use rustc_span::Span;\n@@ -273,9 +273,10 @@ crate enum ParseResult<T> {\n     Error(rustc_span::Span, String),\n }\n \n-/// A `ParseResult` where the `Success` variant contains a mapping of `Ident`s to `NamedMatch`es.\n-/// This represents the mapping of metavars to the token trees they bind to.\n-crate type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n+/// A `ParseResult` where the `Success` variant contains a mapping of\n+/// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n+/// of metavars to the token trees they bind to.\n+crate type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n \n /// Count how many metavars are named in the given matcher `ms`.\n pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n@@ -368,7 +369,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n         sess: &ParseSess,\n         m: &TokenTree,\n         res: &mut I,\n-        ret_val: &mut FxHashMap<Ident, NamedMatch>,\n+        ret_val: &mut FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     ) -> Result<(), (rustc_span::Span, String)> {\n         match *m {\n             TokenTree::Sequence(_, ref seq) => {\n@@ -386,7 +387,9 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n             }\n-            TokenTree::MetaVarDecl(sp, bind_name, _) => match ret_val.entry(bind_name) {\n+            TokenTree::MetaVarDecl(sp, bind_name, _) => match ret_val\n+                .entry(MacroRulesNormalizedIdent::new(bind_name))\n+            {\n                 Vacant(spot) => {\n                     spot.insert(res.next().unwrap());\n                 }"}, {"sha": "2268c9b3854779d94ec34bfbc2d4c0efe359e866", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=8cf9e9efcadef137b9f04c741115aa8664a5a910", "patch": "@@ -22,7 +22,7 @@ use rustc_parse::Directory;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, MacroRulesNormalizedIdent, Symbol};\n use rustc_span::Span;\n \n use log::debug;\n@@ -411,7 +411,7 @@ pub fn compile_declarative_macro(\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match argument_map[&lhs_nm] {\n+    let lhses = match argument_map[&MacroRulesNormalizedIdent::new(lhs_nm)] {\n         MatchedSeq(ref s) => s\n             .iter()\n             .map(|m| {\n@@ -428,7 +428,7 @@ pub fn compile_declarative_macro(\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n-    let rhses = match argument_map[&rhs_nm] {\n+    let rhses = match argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n         MatchedSeq(ref s) => s\n             .iter()\n             .map(|m| {"}, {"sha": "1b1093c9529f4813a3b0b5997c49a4153e2a2fe0", "filename": "src/librustc_expand/mbe/transcribe.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs?ref=8cf9e9efcadef137b9f04c741115aa8664a5a910", "patch": "@@ -2,14 +2,15 @@ use crate::base::ExtCtxt;\n use crate::mbe;\n use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n \n-use rustc_ast::ast::{Ident, MacCall};\n+use rustc_ast::ast::MacCall;\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::token::{self, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::pluralize;\n use rustc_span::hygiene::{ExpnId, Transparency};\n+use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n@@ -81,7 +82,7 @@ impl Iterator for Frame {\n /// Along the way, we do some additional error checking.\n pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n-    interp: &FxHashMap<Ident, NamedMatch>,\n+    interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     src: Vec<mbe::TokenTree>,\n     transparency: Transparency,\n ) -> TokenStream {\n@@ -223,9 +224,10 @@ pub(super) fn transcribe(\n             }\n \n             // Replace the meta-var with the matched token tree from the invocation.\n-            mbe::TokenTree::MetaVar(mut sp, mut ident) => {\n+            mbe::TokenTree::MetaVar(mut sp, mut orignal_ident) => {\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n+                let ident = MacroRulesNormalizedIdent::new(orignal_ident);\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n                     if let MatchedNonterminal(ref nt) = cur_matched {\n                         // FIXME #2887: why do we apply a mark when matching a token tree meta-var\n@@ -249,9 +251,9 @@ pub(super) fn transcribe(\n                     // If we aren't able to match the meta-var, we push it back into the result but\n                     // with modified syntax context. (I believe this supports nested macros).\n                     marker.visit_span(&mut sp);\n-                    marker.visit_ident(&mut ident);\n+                    marker.visit_ident(&mut orignal_ident);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n-                    result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n+                    result.push(TokenTree::Token(Token::from_ast_ident(orignal_ident)).into());\n                 }\n             }\n \n@@ -287,8 +289,8 @@ pub(super) fn transcribe(\n /// into the right place in nested matchers. If we attempt to descend too far, the macro writer has\n /// made a mistake, and we return `None`.\n fn lookup_cur_matched<'a>(\n-    ident: Ident,\n-    interpolations: &'a FxHashMap<Ident, NamedMatch>,\n+    ident: MacroRulesNormalizedIdent,\n+    interpolations: &'a FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> Option<&'a NamedMatch> {\n     interpolations.get(&ident).map(|matched| {\n@@ -316,7 +318,7 @@ enum LockstepIterSize {\n \n     /// A `MetaVar` with an actual `MatchedSeq`. The length of the match and the name of the\n     /// meta-var are returned.\n-    Constraint(usize, Ident),\n+    Constraint(usize, MacroRulesNormalizedIdent),\n \n     /// Two `Constraint`s on the same sequence had different lengths. This is an error.\n     Contradiction(String),\n@@ -360,7 +362,7 @@ impl LockstepIterSize {\n /// multiple nested matcher sequences.\n fn lockstep_iter_size(\n     tree: &mbe::TokenTree,\n-    interpolations: &FxHashMap<Ident, NamedMatch>,\n+    interpolations: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n     use mbe::TokenTree;\n@@ -376,6 +378,7 @@ fn lockstep_iter_size(\n             })\n         }\n         TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n+            let name = MacroRulesNormalizedIdent::new(name);\n             match lookup_cur_matched(name, interpolations, repeats) {\n                 Some(matched) => match matched {\n                     MatchedNonterminal(_) => LockstepIterSize::Unconstrained,"}, {"sha": "19754c83038e21eee97ad52285d98b0de507ccce", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=8cf9e9efcadef137b9f04c741115aa8664a5a910", "patch": "@@ -983,6 +983,31 @@ impl fmt::Display for IdentPrinter {\n     }\n }\n \n+/// An newtype around `Ident` that calls [Ident::normalize_to_macro_rules] on\n+/// construction.\n+// FIXME(matthewj, petrochenkov) Use this more often, add a similar\n+// `ModernIdent` struct and use that as well.\n+#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+pub struct MacroRulesNormalizedIdent(Ident);\n+\n+impl MacroRulesNormalizedIdent {\n+    pub fn new(ident: Ident) -> Self {\n+        Self(ident.normalize_to_macro_rules())\n+    }\n+}\n+\n+impl fmt::Debug for MacroRulesNormalizedIdent {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&self.0, f)\n+    }\n+}\n+\n+impl fmt::Display for MacroRulesNormalizedIdent {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n /// An interned string.\n ///\n /// Internally, a `Symbol` is implemented as an index, and all operations"}, {"sha": "09070f0f561a6eb53ce05f756af2b954a5cadaee", "filename": "src/test/ui/hygiene/macro-metavars-legacy.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-legacy.rs?ref=8cf9e9efcadef137b9f04c741115aa8664a5a910", "patch": "@@ -0,0 +1,29 @@\n+// Ensure macro metavariables are compared with legacy hygiene\n+\n+#![feature(rustc_attrs)]\n+\n+// run-pass\n+\n+macro_rules! make_mac {\n+    ( $($dollar:tt $arg:ident),+ ) => {\n+        macro_rules! mac {\n+            ( $($dollar $arg : ident),+ ) => {\n+                $( $dollar $arg )-+\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! show_hygiene {\n+    ( $dollar:tt $arg:ident ) => {\n+        make_mac!($dollar $arg, $dollar arg);\n+    }\n+}\n+\n+show_hygiene!( $arg );\n+\n+fn main() {\n+    let x = 5;\n+    let y = 3;\n+    assert_eq!(2, mac!(x, y));\n+}"}, {"sha": "e475b5728a098d468255d3a562e32bb29a69becc", "filename": "src/test/ui/hygiene/macro-metavars-transparent.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9e9efcadef137b9f04c741115aa8664a5a910/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-transparent.rs?ref=8cf9e9efcadef137b9f04c741115aa8664a5a910", "patch": "@@ -0,0 +1,24 @@\n+// Ensure macro metavariables are not compared without removing transparent\n+// marks.\n+\n+#![feature(rustc_attrs)]\n+\n+// run-pass\n+\n+#[rustc_macro_transparency = \"transparent\"]\n+macro_rules! k {\n+    ($($s:tt)*) => {\n+        macro_rules! m {\n+            ($y:tt) => {\n+                $($s)*\n+            }\n+        }\n+    }\n+}\n+\n+k!(1 + $y);\n+\n+fn main() {\n+    let x = 2;\n+    assert_eq!(3, m!(x));\n+}"}]}