{"sha": "9c93fbf346b351795c2e526f5ff7fa693aa50609", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOTNmYmYzNDZiMzUxNzk1YzJlNTI2ZjVmZjdmYTY5M2FhNTA2MDk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-04T19:35:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-04T19:35:43Z"}, "message": "Merge #2175\n\n2175: Appease the linter by dummy doc comments r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "493ffd6bd1a63c6dd5c1db185b9eb19c067e63f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/493ffd6bd1a63c6dd5c1db185b9eb19c067e63f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c93fbf346b351795c2e526f5ff7fa693aa50609", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdwH2PCRBK7hj4Ov3rIwAAdHIIAAZKJqPbyL6ti3wztxuq7IVu\ngYcxQMETOu/Ig2hVLNwltYiWtRmCX5RygPYDHts5vN8rVIiYbZluoOA3zx6ygGih\nOqaIQvpv2xX2alLLKndPsq6FTXSCREPJIbykibIQxLwNfgDcrgKXibtBHPd/DVRE\nvlVujUTAssSaPI7S09a/vX5lPREWKp81PAqYXr+j5cGQDOXrOga3jQmuNNPZiNfr\nnRHVUcfJ0tOtT/xAZbiwwoWsX7DtaQbXFlew0/clnw3b4K6WA4R5ZKu31q1Ttg6q\n19U10bvUzYVE/OcJi0Zh/FPPMMSKM7E5sQjA8YqCZqXgqPSvh8ICsVlJmXkjj+I=\n=ITuE\n-----END PGP SIGNATURE-----\n", "payload": "tree 493ffd6bd1a63c6dd5c1db185b9eb19c067e63f0\nparent 7c0d7d3838b79ac2f4a2cb2d127c207f61134fa7\nparent 50364bd47815f4f9174d46ae33f44f7f56545b2d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1572896143 +0000\ncommitter GitHub <noreply@github.com> 1572896143 +0000\n\nMerge #2175\n\n2175: Appease the linter by dummy doc comments r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c93fbf346b351795c2e526f5ff7fa693aa50609", "html_url": "https://github.com/rust-lang/rust/commit/9c93fbf346b351795c2e526f5ff7fa693aa50609", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c93fbf346b351795c2e526f5ff7fa693aa50609/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c0d7d3838b79ac2f4a2cb2d127c207f61134fa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c0d7d3838b79ac2f4a2cb2d127c207f61134fa7", "html_url": "https://github.com/rust-lang/rust/commit/7c0d7d3838b79ac2f4a2cb2d127c207f61134fa7"}, {"sha": "50364bd47815f4f9174d46ae33f44f7f56545b2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/50364bd47815f4f9174d46ae33f44f7f56545b2d", "html_url": "https://github.com/rust-lang/rust/commit/50364bd47815f4f9174d46ae33f44f7f56545b2d"}], "stats": {"total": 518, "additions": 212, "deletions": 306}, "files": [{"sha": "a8f8446cb637455120290576f9f4262c9ebb73c3", "filename": "crates/ra_assists/src/doc_tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs?ref=9c93fbf346b351795c2e526f5ff7fa693aa50609", "patch": "@@ -5,13 +5,14 @@\n \n mod generated;\n \n-use hir::mock::MockDatabase;\n-use ra_db::FileRange;\n+use ra_db::{fixture::WithFixture, FileRange};\n use test_utils::{assert_eq_text, extract_range_or_offset};\n \n+use crate::test_db::TestDB;\n+\n fn check(assist_id: &str, before: &str, after: &str) {\n     let (selection, before) = extract_range_or_offset(before);\n-    let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+    let (db, file_id) = TestDB::with_single_file(&before);\n     let frange = FileRange { file_id, range: selection.into() };\n \n     let (_assist_id, action) = crate::assists(&db, frange)"}, {"sha": "39c1c283f47527463658ed1ee75cc3a2ed2a8992", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=9c93fbf346b351795c2e526f5ff7fa693aa50609", "patch": "@@ -9,6 +9,8 @@ mod assist_ctx;\n mod marks;\n #[cfg(test)]\n mod doc_tests;\n+#[cfg(test)]\n+mod test_db;\n \n use hir::db::HirDatabase;\n use ra_db::FileRange;\n@@ -146,20 +148,19 @@ mod assists {\n \n #[cfg(test)]\n mod helpers {\n-    use hir::mock::MockDatabase;\n-    use ra_db::FileRange;\n+    use ra_db::{fixture::WithFixture, FileRange};\n     use ra_syntax::TextRange;\n     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n-    use crate::{Assist, AssistCtx};\n+    use crate::{test_db::TestDB, Assist, AssistCtx};\n \n     pub(crate) fn check_assist(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n         after: &str,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n@@ -182,12 +183,12 @@ mod helpers {\n     }\n \n     pub(crate) fn check_assist_range(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n         after: &str,\n     ) {\n         let (range, before) = extract_range(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n@@ -204,12 +205,12 @@ mod helpers {\n     }\n \n     pub(crate) fn check_assist_target(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n         target: &str,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n@@ -224,12 +225,12 @@ mod helpers {\n     }\n \n     pub(crate) fn check_assist_range_target(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n         target: &str,\n     ) {\n         let (range, before) = extract_range(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n@@ -243,23 +244,23 @@ mod helpers {\n     }\n \n     pub(crate) fn check_assist_not_applicable(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n         assert!(assist.is_none());\n     }\n \n     pub(crate) fn check_assist_range_not_applicable(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n     ) {\n         let (range, before) = extract_range(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n         assert!(assist.is_none());\n@@ -268,16 +269,17 @@ mod helpers {\n \n #[cfg(test)]\n mod tests {\n-    use hir::mock::MockDatabase;\n-    use ra_db::FileRange;\n+    use ra_db::{fixture::WithFixture, FileRange};\n     use ra_syntax::TextRange;\n     use test_utils::{extract_offset, extract_range};\n \n+    use crate::test_db::TestDB;\n+\n     #[test]\n     fn assist_order_field_struct() {\n         let before = \"struct Foo { <|>bar: u32 }\";\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assists = super::assists(&db, frange);\n@@ -298,7 +300,7 @@ mod tests {\n             }\n         }\";\n         let (range, before) = extract_range(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assists = super::assists(&db, frange);\n         let mut assists = assists.iter();"}, {"sha": "5be7383edcd7f50bd32a626fb5a2fb32bfb7fcb5", "filename": "crates/ra_assists/src/test_db.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftest_db.rs?ref=9c93fbf346b351795c2e526f5ff7fa693aa50609", "patch": "@@ -0,0 +1,45 @@\n+//! Database used for testing `ra_assists`.\n+\n+use std::sync::Arc;\n+\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n+\n+#[salsa::database(\n+    ra_db::SourceDatabaseExtStorage,\n+    ra_db::SourceDatabaseStorage,\n+    hir::db::InternDatabaseStorage,\n+    hir::db::AstDatabaseStorage,\n+    hir::db::DefDatabaseStorage,\n+    hir::db::DefDatabase2Storage,\n+    hir::db::HirDatabaseStorage\n+)]\n+#[derive(Debug, Default)]\n+pub struct TestDB {\n+    runtime: salsa::Runtime<TestDB>,\n+}\n+\n+impl salsa::Database for TestDB {\n+    fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n+        &self.runtime\n+    }\n+}\n+\n+impl std::panic::RefUnwindSafe for TestDB {}\n+\n+impl FileLoader for TestDB {\n+    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+        FileLoaderDelegate(self).file_text(file_id)\n+    }\n+    fn resolve_relative_path(\n+        &self,\n+        anchor: FileId,\n+        relative_path: &RelativePath,\n+    ) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    }\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+        FileLoaderDelegate(self).relevant_crates(file_id)\n+    }\n+}\n+\n+impl hir::debug::HirDebugHelper for TestDB {}"}, {"sha": "c14c2ab663087357259666e060a31fdb74b79c7a", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=9c93fbf346b351795c2e526f5ff7fa693aa50609", "patch": "@@ -174,11 +174,11 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::SourceDatabase;\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n     use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n     use test_utils::{assert_eq_text, extract_offset};\n \n-    use crate::{mock::MockDatabase, source_binder::SourceAnalyzer};\n+    use crate::{source_binder::SourceAnalyzer, test_db::TestDB};\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let (off, code) = extract_offset(code);\n@@ -191,7 +191,7 @@ mod tests {\n             buf\n         };\n \n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n+        let (db, file_id) = TestDB::with_single_file(&code);\n         let file = db.parse(file_id).ok().unwrap();\n         let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n@@ -288,7 +288,7 @@ mod tests {\n     fn do_check_local_name(code: &str, expected_offset: u32) {\n         let (off, code) = extract_offset(code);\n \n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n+        let (db, file_id) = TestDB::with_single_file(&code);\n         let file = db.parse(file_id).ok().unwrap();\n         let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n             .expect(\"failed to find a name at the target offset\");"}, {"sha": "da6aa2ed89e5295d4f1ed4dd63f44d9f36a9bfe9", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=9c93fbf346b351795c2e526f5ff7fa693aa50609", "patch": "@@ -29,8 +29,6 @@ macro_rules! impl_froms {\n pub mod debug;\n \n pub mod db;\n-#[macro_use]\n-pub mod mock;\n pub mod source_binder;\n \n mod ids;\n@@ -51,6 +49,8 @@ mod code_model;\n \n pub mod from_source;\n \n+#[cfg(test)]\n+mod test_db;\n #[cfg(test)]\n mod marks;\n "}, {"sha": "ab97a09b9114c7b901507d0520b9abf15d74f8a2", "filename": "crates/ra_hir/src/mock.rs", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/7c0d7d3838b79ac2f4a2cb2d127c207f61134fa7/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0d7d3838b79ac2f4a2cb2d127c207f61134fa7/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=7c0d7d3838b79ac2f4a2cb2d127c207f61134fa7", "patch": "@@ -1,262 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use std::{panic, sync::Arc};\n-\n-use hir_expand::diagnostics::DiagnosticSink;\n-use parking_lot::Mutex;\n-use ra_cfg::CfgOptions;\n-use ra_db::{\n-    salsa, CrateGraph, CrateId, Edition, FileId, FileLoader, FileLoaderDelegate, FilePosition,\n-    RelativePath, RelativePathBuf, SourceDatabase, SourceDatabaseExt, SourceRoot, SourceRootId,\n-};\n-use rustc_hash::FxHashMap;\n-use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n-\n-use crate::{db, debug::HirDebugHelper};\n-\n-pub const WORKSPACE: SourceRootId = SourceRootId(0);\n-\n-#[salsa::database(\n-    ra_db::SourceDatabaseExtStorage,\n-    ra_db::SourceDatabaseStorage,\n-    db::InternDatabaseStorage,\n-    db::AstDatabaseStorage,\n-    db::DefDatabaseStorage,\n-    db::DefDatabase2Storage,\n-    db::HirDatabaseStorage\n-)]\n-#[derive(Debug)]\n-pub struct MockDatabase {\n-    events: Mutex<Option<Vec<salsa::Event<MockDatabase>>>>,\n-    runtime: salsa::Runtime<MockDatabase>,\n-    files: FxHashMap<String, FileId>,\n-    crate_names: Arc<FxHashMap<CrateId, String>>,\n-    file_paths: Arc<FxHashMap<FileId, String>>,\n-}\n-\n-impl panic::RefUnwindSafe for MockDatabase {}\n-\n-impl FileLoader for MockDatabase {\n-    fn file_text(&self, file_id: FileId) -> Arc<String> {\n-        FileLoaderDelegate(self).file_text(file_id)\n-    }\n-    fn resolve_relative_path(\n-        &self,\n-        anchor: FileId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n-    }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n-        FileLoaderDelegate(self).relevant_crates(file_id)\n-    }\n-}\n-\n-impl HirDebugHelper for MockDatabase {\n-    fn crate_name(&self, krate: CrateId) -> Option<String> {\n-        self.crate_names.get(&krate).cloned()\n-    }\n-\n-    fn file_path(&self, file_id: FileId) -> Option<String> {\n-        self.file_paths.get(&file_id).cloned()\n-    }\n-}\n-\n-impl MockDatabase {\n-    pub fn with_files(fixture: &str) -> MockDatabase {\n-        let (db, position) = MockDatabase::from_fixture(fixture);\n-        assert!(position.is_none());\n-        db\n-    }\n-\n-    pub fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n-        let mut db = MockDatabase::default();\n-        let mut source_root = SourceRoot::default();\n-        let file_id = db.add_file(WORKSPACE, \"/\", &mut source_root, \"/main.rs\", text);\n-        db.set_source_root(WORKSPACE, Arc::new(source_root.clone()));\n-        (db, source_root, file_id)\n-    }\n-\n-    pub fn file_id_of(&self, path: &str) -> FileId {\n-        match self.files.get(path) {\n-            Some(it) => *it,\n-            None => panic!(\"unknown file: {:?}\\nexisting files:\\n{:#?}\", path, self.files),\n-        }\n-    }\n-\n-    pub fn diagnostics(&self) -> String {\n-        let mut buf = String::new();\n-        let mut files: Vec<FileId> = self.files.values().copied().collect();\n-        files.sort();\n-        for file in files {\n-            let src = crate::Source {\n-                file_id: file.into(),\n-                ast: crate::ModuleSource::new(self, Some(file), None),\n-            };\n-            let module = crate::Module::from_definition(self, src).unwrap();\n-            module.diagnostics(\n-                self,\n-                &mut DiagnosticSink::new(|d| {\n-                    buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-                }),\n-            )\n-        }\n-        buf\n-    }\n-\n-    fn from_fixture(fixture: &str) -> (MockDatabase, Option<FilePosition>) {\n-        let mut db = MockDatabase::default();\n-\n-        let pos = db.add_fixture(fixture);\n-\n-        (db, pos)\n-    }\n-\n-    fn add_fixture(&mut self, fixture: &str) -> Option<FilePosition> {\n-        let mut position = None;\n-        let mut source_root = SourceRoot::default();\n-        let mut source_root_id = WORKSPACE;\n-        let mut source_root_prefix = \"/\".to_string();\n-        for entry in parse_fixture(fixture) {\n-            if entry.meta.starts_with(\"root\") {\n-                self.set_source_root(source_root_id, Arc::new(source_root));\n-                source_root = SourceRoot::default();\n-\n-                source_root_id = SourceRootId(source_root_id.0 + 1);\n-                source_root_prefix = entry.meta[\"root\".len()..].trim().to_string();\n-                continue;\n-            }\n-            if entry.text.contains(CURSOR_MARKER) {\n-                assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n-                position = Some(self.add_file_with_position(\n-                    source_root_id,\n-                    &source_root_prefix,\n-                    &mut source_root,\n-                    &entry.meta,\n-                    &entry.text,\n-                ));\n-            } else {\n-                self.add_file(\n-                    source_root_id,\n-                    &source_root_prefix,\n-                    &mut source_root,\n-                    &entry.meta,\n-                    &entry.text,\n-                );\n-            }\n-        }\n-        self.set_source_root(source_root_id, Arc::new(source_root));\n-        position\n-    }\n-\n-    fn add_file(\n-        &mut self,\n-        source_root_id: SourceRootId,\n-        source_root_prefix: &str,\n-        source_root: &mut SourceRoot,\n-        path: &str,\n-        text: &str,\n-    ) -> FileId {\n-        assert!(source_root_prefix.starts_with('/'));\n-        assert!(source_root_prefix.ends_with('/'));\n-        assert!(path.starts_with(source_root_prefix));\n-        let rel_path = RelativePathBuf::from_path(&path[source_root_prefix.len()..]).unwrap();\n-\n-        let is_crate_root = rel_path == \"lib.rs\" || rel_path == \"/main.rs\";\n-\n-        let file_id = FileId(self.files.len() as u32);\n-\n-        let prev = self.files.insert(path.to_string(), file_id);\n-        assert!(prev.is_none(), \"duplicate files in the text fixture\");\n-        Arc::make_mut(&mut self.file_paths).insert(file_id, path.to_string());\n-\n-        let text = Arc::new(text.to_string());\n-        self.set_file_text(file_id, text);\n-        self.set_file_relative_path(file_id, rel_path.clone());\n-        self.set_file_source_root(file_id, source_root_id);\n-        source_root.insert_file(rel_path, file_id);\n-\n-        if is_crate_root {\n-            let mut crate_graph = CrateGraph::default();\n-            crate_graph.add_crate_root(file_id, Edition::Edition2018, CfgOptions::default());\n-            self.set_crate_graph(Arc::new(crate_graph));\n-        }\n-        file_id\n-    }\n-\n-    fn add_file_with_position(\n-        &mut self,\n-        source_root_id: SourceRootId,\n-        source_root_prefix: &str,\n-        source_root: &mut SourceRoot,\n-        path: &str,\n-        text: &str,\n-    ) -> FilePosition {\n-        let (offset, text) = extract_offset(text);\n-        let file_id = self.add_file(source_root_id, source_root_prefix, source_root, path, &text);\n-        FilePosition { file_id, offset }\n-    }\n-}\n-\n-impl salsa::Database for MockDatabase {\n-    fn salsa_runtime(&self) -> &salsa::Runtime<MockDatabase> {\n-        &self.runtime\n-    }\n-\n-    fn salsa_event(&self, event: impl Fn() -> salsa::Event<MockDatabase>) {\n-        let mut events = self.events.lock();\n-        if let Some(events) = &mut *events {\n-            events.push(event());\n-        }\n-    }\n-}\n-\n-impl Default for MockDatabase {\n-    fn default() -> MockDatabase {\n-        let mut db = MockDatabase {\n-            events: Default::default(),\n-            runtime: salsa::Runtime::default(),\n-            files: FxHashMap::default(),\n-            crate_names: Default::default(),\n-            file_paths: Default::default(),\n-        };\n-        db.set_crate_graph(Default::default());\n-        db\n-    }\n-}\n-\n-impl salsa::ParallelDatabase for MockDatabase {\n-    fn snapshot(&self) -> salsa::Snapshot<MockDatabase> {\n-        salsa::Snapshot::new(MockDatabase {\n-            events: Default::default(),\n-            runtime: self.runtime.snapshot(self),\n-            // only the root database can be used to get file_id by path.\n-            files: FxHashMap::default(),\n-            file_paths: Arc::clone(&self.file_paths),\n-            crate_names: Arc::clone(&self.crate_names),\n-        })\n-    }\n-}\n-\n-impl MockDatabase {\n-    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<MockDatabase>> {\n-        *self.events.lock() = Some(Vec::new());\n-        f();\n-        self.events.lock().take().unwrap()\n-    }\n-\n-    pub fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {\n-        let events = self.log(f);\n-        events\n-            .into_iter()\n-            .filter_map(|e| match e.kind {\n-                // This pretty horrible, but `Debug` is the only way to inspect\n-                // QueryDescriptor at the moment.\n-                salsa::EventKind::WillExecute { database_key } => {\n-                    Some(format!(\"{:?}\", database_key))\n-                }\n-                _ => None,\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "5237b303af4c0a399c3c96a2180540fd9dd01b9e", "filename": "crates/ra_hir/src/test_db.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_hir%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_hir%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftest_db.rs?ref=9c93fbf346b351795c2e526f5ff7fa693aa50609", "patch": "@@ -0,0 +1,120 @@\n+//! Database used for testing `hir`.\n+\n+use std::{panic, sync::Arc};\n+\n+use hir_def::{db::DefDatabase2, ModuleId};\n+use hir_expand::diagnostics::DiagnosticSink;\n+use parking_lot::Mutex;\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath, SourceDatabase};\n+\n+use crate::{db, debug::HirDebugHelper};\n+\n+#[salsa::database(\n+    ra_db::SourceDatabaseExtStorage,\n+    ra_db::SourceDatabaseStorage,\n+    db::InternDatabaseStorage,\n+    db::AstDatabaseStorage,\n+    db::DefDatabaseStorage,\n+    db::DefDatabase2Storage,\n+    db::HirDatabaseStorage\n+)]\n+#[derive(Debug, Default)]\n+pub struct TestDB {\n+    events: Mutex<Option<Vec<salsa::Event<TestDB>>>>,\n+    runtime: salsa::Runtime<TestDB>,\n+}\n+\n+impl salsa::Database for TestDB {\n+    fn salsa_runtime(&self) -> &salsa::Runtime<TestDB> {\n+        &self.runtime\n+    }\n+\n+    fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n+        let mut events = self.events.lock();\n+        if let Some(events) = &mut *events {\n+            events.push(event());\n+        }\n+    }\n+}\n+\n+impl salsa::ParallelDatabase for TestDB {\n+    fn snapshot(&self) -> salsa::Snapshot<TestDB> {\n+        salsa::Snapshot::new(TestDB {\n+            events: Default::default(),\n+            runtime: self.runtime.snapshot(self),\n+        })\n+    }\n+}\n+\n+impl panic::RefUnwindSafe for TestDB {}\n+\n+impl FileLoader for TestDB {\n+    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+        FileLoaderDelegate(self).file_text(file_id)\n+    }\n+    fn resolve_relative_path(\n+        &self,\n+        anchor: FileId,\n+        relative_path: &RelativePath,\n+    ) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    }\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+        FileLoaderDelegate(self).relevant_crates(file_id)\n+    }\n+}\n+\n+// FIXME: improve `WithFixture` to bring useful hir debugging back\n+impl HirDebugHelper for TestDB {\n+    fn crate_name(&self, _krate: CrateId) -> Option<String> {\n+        None\n+    }\n+\n+    fn file_path(&self, _file_id: FileId) -> Option<String> {\n+        None\n+    }\n+}\n+\n+impl TestDB {\n+    pub fn diagnostics(&self) -> String {\n+        let mut buf = String::new();\n+        let crate_graph = self.crate_graph();\n+        for krate in crate_graph.iter().next() {\n+            let crate_def_map = self.crate_def_map(krate);\n+            for (module_id, _) in crate_def_map.modules.iter() {\n+                let module_id = ModuleId { krate, module_id };\n+                let module = crate::Module::from(module_id);\n+                module.diagnostics(\n+                    self,\n+                    &mut DiagnosticSink::new(|d| {\n+                        buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                    }),\n+                )\n+            }\n+        }\n+        buf\n+    }\n+}\n+\n+impl TestDB {\n+    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<TestDB>> {\n+        *self.events.lock() = Some(Vec::new());\n+        f();\n+        self.events.lock().take().unwrap()\n+    }\n+\n+    pub fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {\n+        let events = self.log(f);\n+        events\n+            .into_iter()\n+            .filter_map(|e| match e.kind {\n+                // This pretty horrible, but `Debug` is the only way to inspect\n+                // QueryDescriptor at the moment.\n+                salsa::EventKind::WillExecute { database_key } => {\n+                    Some(format!(\"{:?}\", database_key))\n+                }\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "e56b9356e9bae590cd20e143d6af1ad8102c19dc", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c93fbf346b351795c2e526f5ff7fa693aa50609/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=9c93fbf346b351795c2e526f5ff7fa693aa50609", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n use test_utils::covers;\n \n use crate::{\n-    expr::BodySourceMap, mock::MockDatabase, ty::display::HirDisplay, ty::InferenceResult,\n+    expr::BodySourceMap, test_db::TestDB, ty::display::HirDisplay, ty::InferenceResult,\n     SourceAnalyzer,\n };\n \n@@ -24,7 +24,7 @@ mod coercion;\n \n #[test]\n fn cfg_impl_block() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:foo cfg:test\n use foo::S as T;\n@@ -64,7 +64,7 @@ impl S {\n \n #[test]\n fn infer_await() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:std\n \n@@ -95,7 +95,7 @@ mod future {\n \n #[test]\n fn infer_box() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:std\n \n@@ -122,7 +122,7 @@ mod boxed {\n \n #[test]\n fn infer_adt_self() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs\n enum Nat { Succ(Self), Demo(Nat), Zero }\n@@ -141,7 +141,7 @@ fn test() {\n \n #[test]\n fn infer_try() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:std\n \n@@ -181,7 +181,7 @@ mod result {\n \n #[test]\n fn infer_for_loop() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:std\n \n@@ -223,7 +223,7 @@ mod collections {\n #[test]\n fn infer_while_let() {\n     covers!(infer_while_let);\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs\n enum Option<T> { Some(T), None }\n@@ -2484,7 +2484,7 @@ pub fn main_loop() {\n \n #[test]\n fn cross_crate_associated_method_call() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:other_crate\n fn test() {\n@@ -3378,7 +3378,7 @@ fn test() { S.foo()<|>; }\n \n #[test]\n fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:foo\n fn test() {\n@@ -3482,7 +3482,7 @@ fn test() { (&S).foo()<|>; }\n \n #[test]\n fn method_resolution_trait_from_prelude() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:other_crate\n struct S;\n@@ -4651,7 +4651,7 @@ fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n     assert_eq!(t, \"{unknown}\");\n }\n \n-fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n+fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let analyzer = SourceAnalyzer::new(db, pos.file_id, expr.syntax(), Some(pos.offset));\n@@ -4660,12 +4660,12 @@ fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n }\n \n fn type_at(content: &str) -> String {\n-    let (db, file_pos) = MockDatabase::with_position(content);\n+    let (db, file_pos) = TestDB::with_position(content);\n     type_at_pos(&db, file_pos)\n }\n \n fn infer(content: &str) -> String {\n-    let (db, _, file_id) = MockDatabase::with_single_file(content);\n+    let (db, file_id) = TestDB::with_single_file(content);\n     let source_file = db.parse(file_id).ok().unwrap();\n \n     let mut acc = String::new();\n@@ -4748,7 +4748,7 @@ fn ellipsize(mut text: String, max_len: usize) -> String {\n \n #[test]\n fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (mut db, pos) = TestDB::with_position(\n         \"\n         //- /lib.rs\n         fn foo() -> i32 {\n@@ -4788,7 +4788,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n \n #[test]\n fn no_such_field_diagnostics() {\n-    let diagnostics = MockDatabase::with_files(\n+    let diagnostics = TestDB::with_files(\n         r\"\n         //- /lib.rs\n         struct S { foo: i32, bar: () }"}]}