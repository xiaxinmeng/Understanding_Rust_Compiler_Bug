{"sha": "4158673ad7150f4fa02fbea3654e8cf1628beb0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNTg2NzNhZDcxNTBmNGZhMDJmYmVhMzY1NGU4Y2YxNjI4YmViMGI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-08T20:39:49Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T02:50:57Z"}, "message": "rustc: reduce Substs and Generics to a simple immutable API.", "tree": {"sha": "974285fd1ec91b41361cb706b267238e84a3bd40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/974285fd1ec91b41361cb706b267238e84a3bd40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4158673ad7150f4fa02fbea3654e8cf1628beb0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4158673ad7150f4fa02fbea3654e8cf1628beb0b", "html_url": "https://github.com/rust-lang/rust/commit/4158673ad7150f4fa02fbea3654e8cf1628beb0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4158673ad7150f4fa02fbea3654e8cf1628beb0b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1", "html_url": "https://github.com/rust-lang/rust/commit/bfdfa1ce1d7275bbdb89ecb116bf765f19b204e1"}], "stats": {"total": 2774, "additions": 1226, "deletions": 1548}, "files": [{"sha": "21fccd2c6132dea5bb3c97c5afc00274aa5350b4", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -1366,7 +1366,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 hir::TyPath(ref maybe_qself, ref path) => {\n                     match self.tcx.expect_def(cur_ty.id) {\n                         Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n-                            let generics = self.tcx.lookup_item_type(did).generics;\n+                            let generics = self.tcx.lookup_generics(did);\n \n                             let expected =\n                                 generics.regions.len(subst::TypeSpace) as u32;"}, {"sha": "1b65b5dae074850ad2d74951d9102f73849f4921", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 37, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -25,9 +25,7 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n use mir::tcx::LvalueTy;\n-use ty::subst;\n-use ty::subst::Substs;\n-use ty::subst::Subst;\n+use ty::subst::{Subst, Substs};\n use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n@@ -1236,43 +1234,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n-    pub fn fresh_substs_for_generics(&self,\n-                                     span: Span,\n-                                     generics: &ty::Generics<'tcx>)\n-                                     -> &'tcx subst::Substs<'tcx>\n-    {\n-        let substs = Substs::from_generics(generics, |def, _| {\n+    pub fn fresh_substs_for_item(&self,\n+                                 span: Span,\n+                                 def_id: DefId)\n+                                 -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self.tcx, def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, substs| {\n             self.type_var_for_def(span, def, substs)\n-        });\n-\n-        self.tcx.mk_substs(substs)\n-    }\n-\n-    /// Given a set of generics defined on a trait, returns a substitution mapping each output\n-    /// type/region parameter to a fresh inference variable, and mapping the self type to\n-    /// `self_ty`.\n-    pub fn fresh_substs_for_trait(&self,\n-                                  span: Span,\n-                                  generics: &ty::Generics<'tcx>,\n-                                  self_ty: Ty<'tcx>)\n-                                  -> &'tcx subst::Substs<'tcx>\n-    {\n-        assert!(generics.types.len(subst::SelfSpace) == 1);\n-        assert!(generics.types.len(subst::FnSpace) == 0);\n-\n-        let substs = Substs::from_generics(generics, |def, _| {\n-            self.region_var_for_def(span, def)\n-        }, |def, substs| {\n-            if def.space == subst::SelfSpace {\n-                self_ty\n-            } else {\n-                self.type_var_for_def(span, def, substs)\n-            }\n-        });\n-\n-        self.tcx.mk_substs(substs)\n+        })\n     }\n \n     pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {"}, {"sha": "abb22783ddc84a72badc40212a5c69e24f8dd16d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -154,14 +154,16 @@ pub trait CrateStore<'tcx> {\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> ty::TypeScheme<'tcx>;\n+                     -> Ty<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n     fn opt_item_name(&self, def: DefId) -> Option<ast::Name>;\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>;\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n+    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                         -> &'tcx ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n@@ -187,8 +189,7 @@ pub trait CrateStore<'tcx> {\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                         -> Option<DefId>;\n+    fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>>;\n \n@@ -334,7 +335,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances { bug!(\"item_variances\") }\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n+                     -> Ty<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n@@ -344,6 +345,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                            -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n+    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                         -> &'tcx ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n@@ -379,8 +382,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                         -> Option<DefId> { bug!(\"trait_of_item\") }\n+    fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n \n@@ -583,7 +585,7 @@ pub mod tls {\n     pub trait DecodingContext<'tcx> {\n         fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n         fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n-        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx>;\n+        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx>;\n         fn translate_def_id(&self, def_id: DefId) -> DefId;\n     }\n "}, {"sha": "7412b5fc8048fb3c427162101467775340aec104", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -18,7 +18,7 @@ use hir::{self, pat_util, PatKind};\n use hir::intravisit::{self, Visitor};\n \n use middle::privacy;\n-use ty::{self, TyCtxt};\n+use ty::{self, subst, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId};\n use lint;\n@@ -88,15 +88,24 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n         use ty::TypeVariants::{TyEnum, TyStruct};\n \n+        let def = self.tcx.expect_def(id);\n+\n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n-        self.tcx.tables.borrow().item_substs.get(&id)\n-            .and_then(|substs| substs.substs.self_ty())\n-            .map(|ty| match ty.sty {\n-                TyEnum(tyid, _) | TyStruct(tyid, _) => self.check_def_id(tyid.did),\n-                _ => (),\n-            });\n+        match def {\n+            Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n+            if self.tcx.trait_of_item(def.def_id()).is_some() => {\n+                if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n+                    match substs.substs.types.get(subst::SelfSpace, 0).sty {\n+                        TyEnum(tyid, _) | TyStruct(tyid, _) => {\n+                            self.check_def_id(tyid.did)\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n \n-        let def = self.tcx.expect_def(id);\n         match def {\n             Def::Const(_) | Def::AssociatedConst(..) => {\n                 self.check_def_id(def.def_id());"}, {"sha": "f511d820fac5878f5f05ee51e79b4b0efb491d36", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -1073,10 +1073,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         let variant_def = &adt_def.variants[variant];\n \n                         ppaux::parameterized(fmt, substs, variant_def.did,\n-                                             ppaux::Ns::Value, &[],\n-                                             |tcx| {\n-                            Some(tcx.lookup_item_type(variant_def.did).generics)\n-                        })?;\n+                                             ppaux::Ns::Value, &[])?;\n \n                         match variant_def.kind {\n                             ty::VariantKind::Unit => Ok(()),\n@@ -1169,9 +1166,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n         use self::Literal::*;\n         match *self {\n             Item { def_id, substs } => {\n-                ppaux::parameterized(\n-                    fmt, substs, def_id, ppaux::Ns::Value, &[],\n-                    |tcx| Some(tcx.lookup_item_type(def_id).generics))\n+                ppaux::parameterized(fmt, substs, def_id, ppaux::Ns::Value, &[])\n             }\n             Value { ref value } => {\n                 write!(fmt, \"const \")?;"}, {"sha": "e67c0ba8053d7bdca4173f68250021c3c5144b99", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -221,9 +221,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.lookup_trait_def(trait_ref.def_id)\n             .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n-                let ity = tcx.lookup_item_type(def_id);\n-                let impl_substs = self.fresh_substs_for_generics(obligation.cause.span,\n-                                                                 &ity.generics);\n+                let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()"}, {"sha": "3698027dca887202f890fc1274a5163ba0162942", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -160,10 +160,9 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n             // We can resolve the `impl Trait` to its concrete type.\n             if let Some(ty_scheme) = tcx.opt_lookup_item_type(def_id) {\n                 let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n-                let concrete_substs = Substs::new_trait(vec![], vec![], concrete_ty);\n                 let predicate = ty::TraitRef {\n                     def_id: self.predicate.def_id(),\n-                    substs: tcx.mk_substs(concrete_substs)\n+                    substs: Substs::new_trait(tcx, vec![], vec![], concrete_ty)\n                 }.to_predicate();\n \n                 let original_obligation = Obligation::new(self.cause.clone(),"}, {"sha": "b86a54f01cf499adde3b251c2a5dd967f646ad21", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -17,7 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n-use ty::subst;\n+use ty::subst::Substs;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use infer::InferCtxt;\n \n@@ -272,7 +272,7 @@ pub enum Vtable<'tcx, N> {\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: DefId,\n-    pub substs: &'tcx subst::Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n     pub nested: Vec<N>\n }\n "}, {"sha": "ecfa7930d0294d55f26a7faffccea2e6b81db79d", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -166,25 +166,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n-        let trait_def = self.lookup_trait_def(trait_def_id);\n-        let trait_predicates = self.lookup_predicates(trait_def_id);\n-        self.generics_require_sized_self(&trait_def.generics, &trait_predicates)\n+        self.generics_require_sized_self(trait_def_id)\n     }\n \n-    fn generics_require_sized_self(self,\n-                                   generics: &ty::Generics<'gcx>,\n-                                   predicates: &ty::GenericPredicates<'gcx>)\n-                                   -> bool\n-    {\n+    fn generics_require_sized_self(self, def_id: DefId) -> bool {\n         let sized_def_id = match self.lang_items.sized_trait() {\n             Some(def_id) => def_id,\n             None => { return false; /* No Sized trait, can't require it! */ }\n         };\n \n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let free_substs = self.construct_free_substs(generics,\n+        let free_substs = self.construct_free_substs(def_id,\n             self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-        let predicates = predicates.instantiate(self, &free_substs).predicates;\n+        let predicates = self.lookup_predicates(def_id);\n+        let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n                 match predicate {\n@@ -214,7 +209,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         // Any method that has a `Self : Sized` requisite is otherwise\n         // exempt from the regulations.\n-        if self.generics_require_sized_self(&method.generics, &method.predicates) {\n+        if self.generics_require_sized_self(method.def_id) {\n             return None;\n         }\n \n@@ -231,7 +226,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  -> bool\n     {\n         // Any method that has a `Self : Sized` requisite can't be called.\n-        if self.generics_require_sized_self(&method.generics, &method.predicates) {\n+        if self.generics_require_sized_self(method.def_id) {\n             return false;\n         }\n "}, {"sha": "9099d6cd740d13df8689bbc55524d1003d204478", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -42,6 +42,7 @@ use traits;\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n \n+use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::cell::RefCell;\n use std::fmt;\n@@ -1935,7 +1936,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // for `PhantomData<T>`, we pass `T`\n             ty::TyStruct(def, substs) if def.is_phantom_data() => {\n-                substs.types.get_slice(TypeSpace).to_vec()\n+                substs.types.as_full_slice().to_vec()\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n@@ -2584,30 +2585,33 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = vec![];\n+                let mut ty_params = BitVector::new(substs_a.types.len(TypeSpace));\n+                let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {\n                         assert!(p.space == TypeSpace);\n-                        let idx = p.idx as usize;\n-                        if !ty_params.contains(&idx) {\n-                            ty_params.push(idx);\n-                        }\n+                        ty_params.insert(p.idx as usize);\n+                        found = true;\n                     }\n                 }\n-                if ty_params.is_empty() {\n+                if !found {\n                     return Err(Unimplemented);\n                 }\n \n                 // Replace type parameters used in unsizing with\n                 // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n-                let mut new_substs = substs_a.clone();\n-                for &i in &ty_params {\n-                    new_substs.types.get_mut_slice(TypeSpace)[i] = tcx.types.err;\n-                }\n+                let types = substs_a.types.map_enumerated(|(_, i, ty)| {\n+                    if ty_params.contains(i) {\n+                        tcx.types.err\n+                    } else {\n+                        ty\n+                    }\n+                });\n+                let substs = Substs::new(tcx, types, substs_a.regions.clone());\n                 for &ty in fields.split_last().unwrap().1 {\n-                    if ty.subst(tcx, &new_substs).references_error() {\n+                    if ty.subst(tcx, substs).references_error() {\n                         return Err(Unimplemented);\n                     }\n                 }\n@@ -2618,11 +2622,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source structure with the target's\n                 // type parameters is a subtype of the target.\n-                for &i in &ty_params {\n-                    let param_b = *substs_b.types.get(TypeSpace, i);\n-                    new_substs.types.get_mut_slice(TypeSpace)[i] = param_b;\n-                }\n-                let new_struct = tcx.mk_struct(def, tcx.mk_substs(new_substs));\n+                let types = substs_a.types.map_enumerated(|(_, i, ty)| {\n+                    if ty_params.contains(i) {\n+                        *substs_b.types.get(TypeSpace, i)\n+                    } else {\n+                        ty\n+                    }\n+                });\n+                let substs = Substs::new(tcx, types, substs_a.regions.clone());\n+                let new_struct = tcx.mk_struct(def, substs);\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)\n@@ -2691,12 +2699,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             snapshot);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n-        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n-                                                         obligation.cause.span,\n-                                                         impl_def_id);\n+        let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,\n+                                                           impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n-                                                  &impl_substs);\n+                                                  impl_substs);\n \n         let impl_trait_ref =\n             project::normalize_with_depth(self,"}, {"sha": "42865ca927de325671b1deba26dbb9eaf4734052", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -18,7 +18,7 @@\n // fits together with the rest of the trait machinery.\n \n use super::{SelectionContext, FulfillmentContext};\n-use super::util::{fresh_type_vars_for_impl, impl_trait_ref_and_oblig};\n+use super::util::impl_trait_ref_and_oblig;\n \n use rustc_data_structures::fnv::FnvHashMap;\n use hir::def_id::DefId;\n@@ -101,7 +101,7 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     };\n \n     // directly inherent the method generics, since those do not vary across impls\n-    infcx.tcx.mk_substs(target_substs.with_method_from_subst(source_substs))\n+    source_substs.rebase_onto(infcx.tcx, source_impl, target_substs)\n }\n \n /// Is impl1 a specialization of impl2?\n@@ -141,11 +141,8 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n-    let scheme = tcx.lookup_item_type(impl1_def_id);\n-    let predicates = tcx.lookup_predicates(impl1_def_id);\n     let mut penv = tcx.construct_parameter_environment(DUMMY_SP,\n-                                                       &scheme.generics,\n-                                                       &predicates,\n+                                                       impl1_def_id,\n                                                        region::DUMMY_CODE_EXTENT);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n                              .unwrap()\n@@ -188,10 +185,10 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n-    let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n+    let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                    target_impl,\n-                                                                   &target_substs);\n+                                                                   target_substs);\n \n     // do the impls unify? If not, no specialization.\n     if let Err(_) = infcx.eq_trait_refs(true,"}, {"sha": "13193e1b2d71be0ace5fb78560cce06f5563a110", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -122,19 +122,18 @@ impl<'a, 'gcx, 'tcx> Children {\n                     if le == ge {\n                         // overlap, but no specialization; error out\n                         let trait_ref = impl_header.trait_ref.unwrap();\n+                        let self_ty = trait_ref.self_ty();\n                         Err(OverlapError {\n                             with_impl: possible_sibling,\n                             trait_desc: trait_ref.to_string(),\n-                            self_desc: trait_ref.substs.self_ty().and_then(|ty| {\n-                                // only report the Self type if it has at least\n-                                // some outer concrete shell; otherwise, it's\n-                                // not adding much information.\n-                                if ty.has_concrete_skeleton() {\n-                                    Some(ty.to_string())\n-                                } else {\n-                                    None\n-                                }\n-                            })\n+                            // only report the Self type if it has at least\n+                            // some outer concrete shell; otherwise, it's\n+                            // not adding much information.\n+                            self_desc: if self_ty.has_concrete_skeleton() {\n+                                Some(self_ty.to_string())\n+                            } else {\n+                                None\n+                            }\n                         })\n                     } else {\n                         Ok((le, ge))"}, {"sha": "1954ce1993c5e0d71eeb5e604ed6606c68c9f204", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -9,10 +9,8 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use infer::InferCtxt;\n use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n-use syntax_pos::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n \n@@ -349,19 +347,6 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n     (impl_trait_ref, impl_obligations)\n }\n \n-// determine the `self` type, using fresh variables for all variables\n-// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n-// would return ($0, $1) where $0 and $1 are freshly instantiated type\n-// variables.\n-pub fn fresh_type_vars_for_impl<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                span: Span,\n-                                                impl_def_id: DefId)\n-                                                -> &'tcx Substs<'tcx>\n-{\n-    let impl_generics = infcx.tcx.lookup_item_type(impl_def_id).generics;\n-    infcx.fresh_substs_for_generics(span, &impl_generics)\n-}\n-\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      recursion_depth: usize,\n@@ -401,7 +386,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Ok(def_id) => {\n                 Ok(ty::TraitRef {\n                     def_id: def_id,\n-                    substs: self.mk_substs(Substs::empty().with_self_ty(param_ty))\n+                    substs: Substs::new_trait(self, vec![], vec![], param_ty)\n                 })\n             }\n             Err(e) => {\n@@ -421,7 +406,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         let trait_ref = ty::TraitRef {\n             def_id: trait_def_id,\n-            substs: self.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n+            substs: Substs::new_trait(self, ty_params, vec![], param_ty)\n         };\n         predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n     }\n@@ -509,10 +494,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             TupleArgumentsFlag::No => sig.0.inputs[0],\n             TupleArgumentsFlag::Yes => self.mk_tup(sig.0.inputs.to_vec()),\n         };\n-        let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n         let trait_ref = ty::TraitRef {\n             def_id: fn_trait_def_id,\n-            substs: self.mk_substs(trait_substs),\n+            substs: Substs::new_trait(self, vec![arguments_tuple], vec![], self_ty),\n         };\n         ty::Binder((trait_ref, sig.0.output))\n     }"}, {"sha": "9356b408a51cb7a274e9ac43b918d5dc049bf908", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -63,6 +63,7 @@ pub struct CtxtArenas<'tcx> {\n     layout: TypedArena<Layout>,\n \n     // references\n+    generics: TypedArena<ty::Generics<'tcx>>,\n     trait_defs: TypedArena<ty::TraitDef<'tcx>>,\n     adt_defs: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n }\n@@ -78,6 +79,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n             stability: TypedArena::new(),\n             layout: TypedArena::new(),\n \n+            generics: TypedArena::new(),\n             trait_defs: TypedArena::new(),\n             adt_defs: TypedArena::new()\n         }\n@@ -341,7 +343,8 @@ pub struct GlobalCtxt<'tcx> {\n     pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n-    /// associated predicates.\n+    /// associated generics and predicates.\n+    pub generics: RefCell<DepTrackingMap<maps::Generics<'tcx>>>,\n     pub predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n     /// Maps from the def-id of a trait to the list of\n@@ -583,13 +586,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }\n \n+    pub fn alloc_generics(self, generics: ty::Generics<'gcx>)\n+                          -> &'gcx ty::Generics<'gcx> {\n+        self.global_interners.arenas.generics.alloc(generics)\n+    }\n+\n     pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n                             -> &'gcx ty::TraitDef<'gcx> {\n         let did = def.trait_ref.def_id;\n-        let interned = self.global_interners.arenas.trait_defs.alloc(def);\n+        let interned = self.alloc_trait_def(def);\n         if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n             bug!(\"Tried to overwrite interned TraitDef: {:?}\", prev)\n         }\n+        self.generics.borrow_mut().insert(did, interned.generics);\n         interned\n     }\n \n@@ -711,6 +720,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            generics: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),"}, {"sha": "312b09cd27dfc3621a38b2a6b836243ee2e35012", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::subst;\n+use ty::subst::{self, Substs};\n use ty::{self, Ty, TypeFlags, TypeFoldable};\n \n pub struct FlagComputation {\n@@ -207,7 +207,7 @@ impl FlagComputation {\n         self.add_substs(projection_ty.trait_ref.substs);\n     }\n \n-    fn add_substs(&mut self, substs: &subst::Substs) {\n+    fn add_substs(&mut self, substs: &Substs) {\n         self.add_tys(substs.types.as_full_slice());\n         for &r in substs.regions.as_full_slice() {\n             self.add_region(r);"}, {"sha": "2e114a801d6ed4a86de846ab4c286ef6bd93e416", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -40,7 +40,7 @@\n //! and does not need to visit anything else.\n \n use middle::region;\n-use ty::subst;\n+use ty::subst::Substs;\n use ty::adjustment;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n@@ -145,8 +145,8 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n     }\n \n     fn fold_substs(&mut self,\n-                   substs: &'tcx subst::Substs<'tcx>)\n-                   -> &'tcx subst::Substs<'tcx> {\n+                   substs: &'tcx Substs<'tcx>)\n+                   -> &'tcx Substs<'tcx> {\n         substs.super_fold_with(self)\n     }\n "}, {"sha": "d5686906e6a7b7c467d99894b4f80a85aa6d5ab0", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -10,7 +10,7 @@\n \n use dep_graph::{DepNode, DepTrackingMapConfig};\n use hir::def_id::DefId;\n-use ty;\n+use ty::{self, Ty};\n use std::marker::PhantomData;\n use std::rc::Rc;\n use syntax::{attr, ast};\n@@ -30,7 +30,8 @@ macro_rules! dep_map_ty {\n }\n \n dep_map_ty! { ImplOrTraitItems: ImplOrTraitItems(DefId) -> ty::ImplOrTraitItem<'tcx> }\n-dep_map_ty! { Tcache: ItemSignature(DefId) -> ty::TypeScheme<'tcx> }\n+dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n+dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitItemId>> }"}, {"sha": "36784e4006461ea956b9177823fc4683d4183bc8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 78, "deletions": 92, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -173,15 +173,14 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n                               -> ImplHeader<'tcx>\n     {\n         let tcx = selcx.tcx();\n-        let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n-        let impl_substs = selcx.infcx().fresh_substs_for_generics(DUMMY_SP, &impl_generics);\n+        let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n         let header = ImplHeader {\n             impl_def_id: impl_def_id,\n             self_ty: tcx.lookup_item_type(impl_def_id).ty,\n             trait_ref: tcx.impl_trait_ref(impl_def_id),\n             predicates: tcx.lookup_predicates(impl_def_id).predicates\n-        }.subst(tcx, &impl_substs);\n+        }.subst(tcx, impl_substs);\n \n         let traits::Normalized { value: mut header, obligations } =\n             traits::normalize(selcx, traits::ObligationCause::dummy(), &header);\n@@ -348,7 +347,7 @@ impl Visibility {\n #[derive(Clone, Debug)]\n pub struct Method<'tcx> {\n     pub name: Name,\n-    pub generics: Generics<'tcx>,\n+    pub generics: &'tcx Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n     pub fty: &'tcx BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n@@ -360,7 +359,7 @@ pub struct Method<'tcx> {\n \n impl<'tcx> Method<'tcx> {\n     pub fn new(name: Name,\n-               generics: ty::Generics<'tcx>,\n+               generics: &'tcx ty::Generics<'tcx>,\n                predicates: GenericPredicates<'tcx>,\n                fty: &'tcx BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n@@ -453,7 +452,7 @@ pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n     pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n-    pub substs: &'tcx subst::Substs<'tcx>\n+    pub substs: &'tcx Substs<'tcx>\n }\n \n /// With method calls, we store some extra information in\n@@ -760,13 +759,15 @@ impl RegionParameterDef {\n pub struct Generics<'tcx> {\n     pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n     pub regions: VecPerParamSpace<RegionParameterDef>,\n+    pub has_self: bool,\n }\n \n impl<'tcx> Generics<'tcx> {\n     pub fn empty() -> Generics<'tcx> {\n         Generics {\n             types: VecPerParamSpace::empty(),\n             regions: VecPerParamSpace::empty(),\n+            has_self: false,\n         }\n     }\n \n@@ -1224,7 +1225,7 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.substs.self_ty().unwrap()\n+        *self.substs.types.get(subst::SelfSpace, 0)\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n@@ -1298,23 +1299,17 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // so for now just grab environment for the impl\n                         let impl_id = tcx.map.get_parent(id);\n                         let impl_def_id = tcx.map.local_def_id(impl_id);\n-                        let scheme = tcx.lookup_item_type(impl_def_id);\n-                        let predicates = tcx.lookup_predicates(impl_def_id);\n                         tcx.construct_parameter_environment(impl_item.span,\n-                                                            &scheme.generics,\n-                                                            &predicates,\n+                                                            impl_def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n                         let method_def_id = tcx.map.local_def_id(id);\n                         match tcx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n-                                let method_generics = &method_ty.generics;\n-                                let method_bounds = &method_ty.predicates;\n                                 tcx.construct_parameter_environment(\n                                     impl_item.span,\n-                                    method_generics,\n-                                    method_bounds,\n+                                    method_ty.def_id,\n                                     tcx.region_maps.call_site_extent(id, body.id))\n                             }\n                             _ => {\n@@ -1332,11 +1327,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // so for now just grab environment for the trait\n                         let trait_id = tcx.map.get_parent(id);\n                         let trait_def_id = tcx.map.local_def_id(trait_id);\n-                        let trait_def = tcx.lookup_trait_def(trait_def_id);\n-                        let predicates = tcx.lookup_predicates(trait_def_id);\n                         tcx.construct_parameter_environment(trait_item.span,\n-                                                            &trait_def.generics,\n-                                                            &predicates,\n+                                                            trait_def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::MethodTraitItem(_, ref body) => {\n@@ -1346,8 +1338,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let method_def_id = tcx.map.local_def_id(id);\n                         match tcx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n-                                let method_generics = &method_ty.generics;\n-                                let method_bounds = &method_ty.predicates;\n                                 let extent = if let Some(ref body) = *body {\n                                     // default impl: use call_site extent as free_id_outlive bound.\n                                     tcx.region_maps.call_site_extent(id, body.id)\n@@ -1357,8 +1347,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                 };\n                                 tcx.construct_parameter_environment(\n                                     trait_item.span,\n-                                    method_generics,\n-                                    method_bounds,\n+                                    method_ty.def_id,\n                                     extent)\n                             }\n                             _ => {\n@@ -1375,13 +1364,10 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     hir::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n                         let fn_def_id = tcx.map.local_def_id(id);\n-                        let fn_scheme = tcx.lookup_item_type(fn_def_id);\n-                        let fn_predicates = tcx.lookup_predicates(fn_def_id);\n \n                         tcx.construct_parameter_environment(\n                             item.span,\n-                            &fn_scheme.generics,\n-                            &fn_predicates,\n+                            fn_def_id,\n                             tcx.region_maps.call_site_extent(id, body.id))\n                     }\n                     hir::ItemEnum(..) |\n@@ -1391,20 +1377,14 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n                         let def_id = tcx.map.local_def_id(id);\n-                        let scheme = tcx.lookup_item_type(def_id);\n-                        let predicates = tcx.lookup_predicates(def_id);\n                         tcx.construct_parameter_environment(item.span,\n-                                                            &scheme.generics,\n-                                                            &predicates,\n+                                                            def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ItemTrait(..) => {\n                         let def_id = tcx.map.local_def_id(id);\n-                        let trait_def = tcx.lookup_trait_def(def_id);\n-                        let predicates = tcx.lookup_predicates(def_id);\n                         tcx.construct_parameter_environment(item.span,\n-                                                            &trait_def.generics,\n-                                                            &predicates,\n+                                                            def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     _ => {\n@@ -1425,11 +1405,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeForeignItem(item)) => {\n                 let def_id = tcx.map.local_def_id(id);\n-                let scheme = tcx.lookup_item_type(def_id);\n-                let predicates = tcx.lookup_predicates(def_id);\n                 tcx.construct_parameter_environment(item.span,\n-                                                    &scheme.generics,\n-                                                    &predicates,\n+                                                    def_id,\n                                                     ROOT_CODE_EXTENT)\n             }\n             _ => {\n@@ -1462,7 +1439,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n /// `lookup_predicates`.\n #[derive(Clone, Debug)]\n pub struct TypeScheme<'tcx> {\n-    pub generics: Generics<'tcx>,\n+    pub generics: &'tcx Generics<'tcx>,\n     pub ty: Ty<'tcx>,\n }\n \n@@ -1917,9 +1894,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 };\n                 let sized_predicate = Binder(TraitRef {\n                     def_id: sized_trait,\n-                    substs: tcx.mk_substs(Substs::new_trait(\n-                        vec![], vec![], ty\n-                    ))\n+                    substs: Substs::new_trait(tcx, vec![], vec![], ty)\n                 }).to_predicate();\n                 let predicates = tcx.lookup_predicates(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n@@ -2170,7 +2145,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n         match self.tables.borrow().item_substs.get(&id) {\n             None => ItemSubsts {\n-                substs: self.global_tcx().mk_substs(Substs::empty())\n+                substs: Substs::empty(self.global_tcx())\n             },\n             Some(ts) => ts.clone(),\n         }\n@@ -2508,27 +2483,36 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Register a given item type\n-    pub fn register_item_type(self, did: DefId, ty: TypeScheme<'gcx>) {\n-        self.tcache.borrow_mut().insert(did, ty);\n+    pub fn register_item_type(self, did: DefId, scheme: TypeScheme<'gcx>) {\n+        self.tcache.borrow_mut().insert(did, scheme.ty);\n+        self.generics.borrow_mut().insert(did, scheme.generics);\n     }\n \n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n     pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'gcx> {\n-        lookup_locally_or_in_crate_store(\n+        let ty = lookup_locally_or_in_crate_store(\n             \"tcache\", did, &self.tcache,\n-            || self.sess.cstore.item_type(self.global_tcx(), did))\n+            || self.sess.cstore.item_type(self.global_tcx(), did));\n+\n+        TypeScheme {\n+            ty: ty,\n+            generics: self.lookup_generics(did)\n+        }\n     }\n \n     pub fn opt_lookup_item_type(self, did: DefId) -> Option<TypeScheme<'gcx>> {\n-        if let Some(scheme) = self.tcache.borrow_mut().get(&did) {\n-            return Some(scheme.clone());\n+        if did.krate != LOCAL_CRATE {\n+            return Some(self.lookup_item_type(did));\n         }\n \n-        if did.krate == LOCAL_CRATE {\n-            None\n+        if let Some(ty) = self.tcache.borrow().get(&did).cloned() {\n+            Some(TypeScheme {\n+                ty: ty,\n+                generics: self.lookup_generics(did)\n+            })\n         } else {\n-            Some(self.sess.cstore.item_type(self.global_tcx(), did))\n+            None\n         }\n     }\n \n@@ -2557,6 +2541,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.lookup_adt_def_master(did)\n     }\n \n+    /// Given the did of an item, returns its generics.\n+    pub fn lookup_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n+        lookup_locally_or_in_crate_store(\n+            \"generics\", did, &self.generics,\n+            || self.sess.cstore.item_generics(self.global_tcx(), did))\n+    }\n+\n     /// Given the did of an item, returns its full set of predicates.\n     pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n@@ -2812,18 +2803,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// If the given def ID describes an item belonging to a trait (either a\n-    /// default method or an implementation of a trait method), return the ID of\n-    /// the trait that the method belongs to. Otherwise, return `None`.\n+    /// If the given def ID describes an item belonging to a trait,\n+    /// return the ID of the trait that the trait item belongs to.\n+    /// Otherwise, return `None`.\n     pub fn trait_of_item(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.trait_of_item(self.global_tcx(), def_id);\n+            return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n+        match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(impl_or_trait_item) => {\n                 match impl_or_trait_item.container() {\n                     TraitContainer(def_id) => Some(def_id),\n-                    ImplContainer(def_id) => self.trait_id_of_impl(def_id),\n+                    ImplContainer(_) => None\n                 }\n             }\n             None => None\n@@ -2837,18 +2828,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// the same).\n     /// Otherwise, return `None`.\n     pub fn trait_item_of_item(self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n-        let impl_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n+        let impl_or_trait_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(m) => m.clone(),\n             None => return None,\n         };\n-        let name = impl_item.name();\n-        match self.trait_of_item(def_id) {\n-            Some(trait_did) => {\n-                self.trait_items(trait_did).iter()\n-                    .find(|item| item.name() == name)\n-                    .map(|item| item.id())\n+        match impl_or_trait_item.container() {\n+            TraitContainer(_) => Some(impl_or_trait_item.id()),\n+            ImplContainer(def_id) => {\n+                self.trait_id_of_impl(def_id).and_then(|trait_did| {\n+                    let name = impl_or_trait_item.name();\n+                    self.trait_items(trait_did).iter()\n+                        .find(|item| item.name() == name)\n+                        .map(|item| item.id())\n+                })\n             }\n-            None => None\n         }\n     }\n \n@@ -2860,7 +2853,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // regions, so it shouldn't matter what we use for the free id\n         let free_id_outlive = self.region_maps.node_extent(ast::DUMMY_NODE_ID);\n         ty::ParameterEnvironment {\n-            free_substs: self.mk_substs(Substs::empty()),\n+            free_substs: Substs::empty(self),\n             caller_bounds: Vec::new(),\n             implicit_region_bound: ty::ReEmpty,\n             free_id_outlive: free_id_outlive\n@@ -2872,52 +2865,45 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(self, generics: &Generics<'gcx>,\n-                                 free_id_outlive: CodeExtent) -> Substs<'gcx> {\n-        // map T => T\n-        let types = generics.types.map(|def| {\n-            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n-                    def);\n+    pub fn construct_free_substs(self, def_id: DefId,\n+                                 free_id_outlive: CodeExtent)\n+                                 -> &'gcx Substs<'gcx> {\n+\n+        let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n+            // map bound 'a => free 'a\n+            ReFree(FreeRegion { scope: free_id_outlive,\n+                                bound_region: def.to_bound_region() })\n+        }, |def, _| {\n+            // map T => T\n             self.global_tcx().mk_param_from_def(def)\n         });\n \n-        // map bound 'a => free 'a\n-        let regions = generics.regions.map(|def| {\n-            let region =\n-                ReFree(FreeRegion { scope: free_id_outlive,\n-                                    bound_region: def.to_bound_region() });\n-            debug!(\"push_region_params {:?}\", region);\n-            region\n-        });\n-\n-        Substs {\n-            types: types,\n-            regions: regions,\n-        }\n+        debug!(\"construct_parameter_environment: {:?}\", substs);\n+        substs\n     }\n \n     /// See `ParameterEnvironment` struct def'n for details.\n     /// If you were using `free_id: NodeId`, you might try `self.region_maps.item_extent(free_id)`\n     /// for the `free_id_outlive` parameter. (But note that that is not always quite right.)\n     pub fn construct_parameter_environment(self,\n                                            span: Span,\n-                                           generics: &ty::Generics<'gcx>,\n-                                           generic_predicates: &ty::GenericPredicates<'gcx>,\n+                                           def_id: DefId,\n                                            free_id_outlive: CodeExtent)\n                                            -> ParameterEnvironment<'gcx>\n     {\n         //\n         // Construct the free substs.\n         //\n \n-        let free_substs = self.construct_free_substs(generics, free_id_outlive);\n+        let free_substs = self.construct_free_substs(def_id, free_id_outlive);\n \n         //\n         // Compute the bounds on Self and the type parameters.\n         //\n \n         let tcx = self.global_tcx();\n-        let bounds = generic_predicates.instantiate(tcx, &free_substs);\n+        let generic_predicates = tcx.lookup_predicates(def_id);\n+        let bounds = generic_predicates.instantiate(tcx, free_substs);\n         let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n         let predicates = bounds.predicates;\n \n@@ -2935,7 +2921,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let unnormalized_env = ty::ParameterEnvironment {\n-            free_substs: tcx.mk_substs(free_substs),\n+            free_substs: free_substs,\n             implicit_region_bound: ty::ReScope(free_id_outlive),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,"}, {"sha": "388e8926403fd26b02595ed79048aa899958d249", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 38, "deletions": 76, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -14,7 +14,7 @@\n //! type equality, etc.\n \n use hir::def_id::DefId;\n-use ty::subst::{ParamSpace, Substs};\n+use ty::subst::Substs;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n use std::rc::Rc;\n@@ -145,82 +145,44 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                         -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n-    let mut substs = Substs::empty();\n-\n-    for &space in &ParamSpace::all() {\n-        let a_tps = a_subst.types.get_slice(space);\n-        let b_tps = b_subst.types.get_slice(space);\n-        let t_variances = variances.map(|v| v.types.get_slice(space));\n-        let tps = relate_type_params(relation, t_variances, a_tps, b_tps)?;\n-        substs.types.replace(space, tps);\n-    }\n-\n-    for &space in &ParamSpace::all() {\n-        let a_regions = a_subst.regions.get_slice(space);\n-        let b_regions = b_subst.regions.get_slice(space);\n-        let r_variances = variances.map(|v| v.regions.get_slice(space));\n-        let regions = relate_region_params(relation,\n-                                           r_variances,\n-                                           a_regions,\n-                                           b_regions)?;\n-        substs.regions.replace(space, regions);\n-    }\n-\n-    Ok(relation.tcx().mk_substs(substs))\n-}\n-\n-fn relate_type_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                         variances: Option<&[ty::Variance]>,\n-                                         a_tys: &[Ty<'tcx>],\n-                                         b_tys: &[Ty<'tcx>])\n-                                         -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-{\n-    if a_tys.len() != b_tys.len() {\n-        return Err(TypeError::TyParamSize(expected_found(relation,\n-                                                         &a_tys.len(),\n-                                                         &b_tys.len())));\n-    }\n-\n-    (0 .. a_tys.len())\n-        .map(|i| {\n-            let a_ty = a_tys[i];\n-            let b_ty = b_tys[i];\n-            let v = variances.map_or(ty::Invariant, |v| v[i]);\n-            relation.relate_with_variance(v, &a_ty, &b_ty)\n-        })\n-        .collect()\n-}\n+    let tcx = relation.tcx();\n+    let mut result = Ok(());\n+\n+    let types = a_subst.types.map_enumerated(|(space, i, a_ty)| {\n+        if result.is_err() { return tcx.types.err; }\n+\n+        let b_ty = b_subst.types.get(space, i);\n+        let variance = variances.map_or(ty::Invariant, |v| {\n+            *v.types.get(space, i)\n+        });\n+        match relation.relate_with_variance(variance, a_ty, b_ty) {\n+            Ok(ty) => ty,\n+            Err(e) => {\n+                result = Err(e);\n+                tcx.types.err\n+            }\n+        }\n+    });\n+    result?;\n+\n+    let regions = a_subst.regions.map_enumerated(|(space, i, a_r)| {\n+        if result.is_err() { return ty::ReStatic; }\n+\n+        let b_r = b_subst.regions.get(space, i);\n+        let variance = variances.map_or(ty::Invariant, |v| {\n+            *v.regions.get(space, i)\n+        });\n+        match relation.relate_with_variance(variance, a_r, b_r) {\n+            Ok(r) => r,\n+            Err(e) => {\n+                result = Err(e);\n+                ty::ReStatic\n+            }\n+        }\n+    });\n+    result?;\n \n-fn relate_region_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                           variances: Option<&[ty::Variance]>,\n-                                           a_rs: &[ty::Region],\n-                                           b_rs: &[ty::Region])\n-                                           -> RelateResult<'tcx, Vec<ty::Region>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-{\n-    let num_region_params = a_rs.len();\n-\n-    debug!(\"relate_region_params(a_rs={:?}, \\\n-            b_rs={:?}, variances={:?})\",\n-           a_rs,\n-           b_rs,\n-           variances);\n-\n-    assert_eq!(num_region_params,\n-               variances.map_or(num_region_params,\n-                                |v| v.len()));\n-\n-    assert_eq!(num_region_params, b_rs.len());\n-\n-    (0..a_rs.len())\n-        .map(|i| {\n-            let a_r = a_rs[i];\n-            let b_r = b_rs[i];\n-            let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-            relation.relate_with_variance(variance, &a_r, &b_r)\n-        })\n-        .collect()\n+    Ok(Substs::new(tcx, types, regions))\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::BareFnTy<'tcx> {"}, {"sha": "9021b0587a013e1a6f0405d95a0e10c0943ba812", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use infer::type_variable;\n-use ty::subst::{self, VecPerParamSpace};\n+use ty::subst::{Substs, VecPerParamSpace};\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n@@ -702,13 +702,11 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx subst::Substs<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let substs = subst::Substs {\n-            regions: self.regions.fold_with(folder),\n-            types: self.types.fold_with(folder)\n-        };\n-        folder.tcx().mk_substs(substs)\n+        let types = self.types.fold_with(folder);\n+        let regions = self.regions.fold_with(folder);\n+        Substs::new(folder.tcx(), types, regions)\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n@@ -839,6 +837,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n+            has_self: self.has_self\n         }\n     }\n \n@@ -1018,19 +1017,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeScheme<'tcx>  {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TypeScheme {\n-            generics: self.generics.fold_with(folder),\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.generics.visit_with(visitor) || self.ty.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::error::ExpectedFound {"}, {"sha": "f31b844f04fe6cdf093e9b3563e0680609597ff1", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -359,18 +359,7 @@ pub struct ExistentialTraitRef<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn erase_self_ty(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         trait_ref: ty::TraitRef<'tcx>)\n-                         -> ty::ExistentialTraitRef<'tcx> {\n-        let mut substs = trait_ref.substs.clone();\n-        substs.types.pop(subst::SelfSpace);\n-        ty::ExistentialTraitRef {\n-            def_id: trait_ref.def_id,\n-            substs: tcx.mk_substs(substs)\n-        }\n-    }\n-\n+impl<'tcx> ExistentialTraitRef<'tcx> {\n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n@@ -382,7 +371,7 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n \n pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n \n-impl<'a, 'gcx, 'tcx> PolyExistentialTraitRef<'tcx> {\n+impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     pub fn def_id(&self) -> DefId {\n         self.0.def_id\n     }\n@@ -391,23 +380,6 @@ impl<'a, 'gcx, 'tcx> PolyExistentialTraitRef<'tcx> {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n-\n-    /// Object types don't have a self-type specified. Therefore, when\n-    /// we convert the principal trait-ref into a normal trait-ref,\n-    /// you must give *some* self-type. A common choice is `mk_err()`\n-    /// or some skolemized type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                        self_ty: Ty<'tcx>)\n-                        -> ty::PolyTraitRef<'tcx>\n-    {\n-        // otherwise the escaping regions would be captured by the binder\n-        assert!(!self_ty.has_escaping_regions());\n-\n-        self.map_bound(|trait_ref| TraitRef {\n-            def_id: trait_ref.def_id,\n-            substs: tcx.mk_substs(trait_ref.substs.with_self_ty(self_ty)),\n-        })\n-    }\n }\n \n /// Binder is a binder for higher-ranked lifetimes. It is part of the"}, {"sha": "00537f9d6c5dc3a50ce5ccdc7ec4b5ebcdf08949", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 153, "deletions": 194, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -34,70 +34,103 @@ pub struct Substs<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    pub fn new(t: VecPerParamSpace<Ty<'tcx>>,\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               t: VecPerParamSpace<Ty<'tcx>>,\n                r: VecPerParamSpace<ty::Region>)\n-               -> Substs<'tcx>\n+               -> &'tcx Substs<'tcx>\n     {\n-        Substs { types: t, regions: r }\n+        tcx.mk_substs(Substs { types: t, regions: r })\n     }\n \n-    pub fn new_fn(t: Vec<Ty<'tcx>>,\n+    pub fn new_fn(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                  t: Vec<Ty<'tcx>>,\n                   r: Vec<ty::Region>)\n-                  -> Substs<'tcx>\n+                  -> &'tcx Substs<'tcx>\n     {\n-        Substs::new(VecPerParamSpace::new(vec![], vec![], t),\n+        Substs::new(tcx, VecPerParamSpace::new(vec![], vec![], t),\n                     VecPerParamSpace::new(vec![], vec![], r))\n     }\n \n-    pub fn new_type(t: Vec<Ty<'tcx>>,\n+    pub fn new_type(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    t: Vec<Ty<'tcx>>,\n                     r: Vec<ty::Region>)\n-                    -> Substs<'tcx>\n+                    -> &'tcx Substs<'tcx>\n     {\n-        Substs::new(VecPerParamSpace::new(vec![], t, vec![]),\n+        Substs::new(tcx, VecPerParamSpace::new(vec![], t, vec![]),\n                     VecPerParamSpace::new(vec![], r, vec![]))\n     }\n \n-    pub fn new_trait(t: Vec<Ty<'tcx>>,\n+    pub fn new_trait(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                     t: Vec<Ty<'tcx>>,\n                      r: Vec<ty::Region>,\n                      s: Ty<'tcx>)\n-                    -> Substs<'tcx>\n+                    -> &'tcx Substs<'tcx>\n     {\n-        Substs::new(VecPerParamSpace::new(vec![s], t, vec![]),\n+        Substs::new(tcx, VecPerParamSpace::new(vec![s], t, vec![]),\n                     VecPerParamSpace::new(vec![], r, vec![]))\n     }\n \n-    pub fn empty() -> Substs<'tcx> {\n-        Substs {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty(),\n-        }\n+    pub fn empty(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n+        Substs::new(tcx, VecPerParamSpace::empty(),\n+                    VecPerParamSpace::empty())\n     }\n \n     /// Creates a Substs for generic parameter definitions,\n     /// by calling closures to obtain each region and type.\n     /// The closures get to observe the Substs as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of type parameters.\n-    pub fn from_generics<FR, FT>(generics: &ty::Generics<'tcx>,\n-                                 mut mk_region: FR,\n-                                 mut mk_type: FT)\n-                                 -> Substs<'tcx>\n+    pub fn for_item<FR, FT>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                            def_id: DefId,\n+                            mut mk_region: FR,\n+                            mut mk_type: FT)\n+                            -> &'tcx Substs<'tcx>\n     where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n-        let mut substs = Substs::empty();\n+        let defs = tcx.lookup_generics(def_id);\n+        let mut substs = Substs {\n+            types: VecPerParamSpace {\n+                self_limit: 0,\n+                type_limit: 0,\n+                content: Vec::with_capacity(defs.types.content.len())\n+            },\n+            regions: VecPerParamSpace {\n+                self_limit: 0,\n+                type_limit: 0,\n+                content: Vec::with_capacity(defs.regions.content.len())\n+            }\n+        };\n+\n         for &space in &ParamSpace::all() {\n-            for def in generics.regions.get_slice(space) {\n+            for def in defs.regions.get_slice(space) {\n+                assert_eq!(def.space, space);\n+                assert!(space != SelfSpace);\n+\n                 let region = mk_region(def, &substs);\n-                assert_eq!(substs.regions.len(def.space), def.index as usize);\n-                substs.regions.push(def.space, region);\n+                substs.regions.content.push(region);\n+\n+                if space == TypeSpace {\n+                    substs.regions.type_limit += 1;\n+                }\n             }\n-            for def in generics.types.get_slice(space) {\n+\n+            for def in defs.types.get_slice(space) {\n+                assert_eq!(def.space, space);\n+\n                 let ty = mk_type(def, &substs);\n-                assert_eq!(substs.types.len(def.space), def.index as usize);\n-                substs.types.push(def.space, ty);\n+                substs.types.content.push(ty);\n+\n+                if space == SelfSpace {\n+                    substs.types.self_limit += 1;\n+                }\n+\n+                if space <= TypeSpace {\n+                    substs.types.type_limit += 1;\n+                }\n             }\n         }\n-        substs\n+\n+        Substs::new(tcx, substs.types, substs.regions)\n     }\n \n     pub fn is_noop(&self) -> bool {\n@@ -112,66 +145,32 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         *self.regions.get(def.space, def.index as usize)\n     }\n \n-    pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n-        self.types.get_self().cloned()\n-    }\n-\n-    pub fn with_self_ty(&self, self_ty: Ty<'tcx>) -> Substs<'tcx> {\n-        assert!(self.self_ty().is_none());\n-        let mut s = (*self).clone();\n-        s.types.push(SelfSpace, self_ty);\n-        s\n-    }\n-\n-    pub fn erase_regions(self) -> Substs<'tcx> {\n-        let Substs { types, regions } = self;\n-        let regions = regions.map(|_| ty::ReErased);\n-        Substs { types: types, regions: regions }\n-    }\n-\n-    pub fn with_method(self,\n-                       m_types: Vec<Ty<'tcx>>,\n-                       m_regions: Vec<ty::Region>)\n-                       -> Substs<'tcx>\n-    {\n-        let Substs { types, regions } = self;\n-        let types = types.with_slice(FnSpace, &m_types);\n-        let regions = regions.with_slice(FnSpace, &m_regions);\n-        Substs { types: types, regions: regions }\n-    }\n-\n-    pub fn with_method_from(&self,\n-                            meth_substs: &Substs<'tcx>)\n-                            -> Substs<'tcx>\n-    {\n-        let Substs { types, regions } = self.clone();\n-        let types = types.with_slice(FnSpace, meth_substs.types.get_slice(FnSpace));\n-        let regions = regions.with_slice(FnSpace, meth_substs.regions.get_slice(FnSpace));\n-        Substs { types: types, regions: regions }\n-    }\n-\n-    pub fn with_method_from_subst(&self, other: &Substs<'tcx>) -> Substs<'tcx> {\n-        let Substs { types, regions } = self.clone();\n-        let types = types.with_slice(FnSpace, other.types.get_slice(FnSpace));\n-        let regions = regions.with_slice(FnSpace, other.regions.get_slice(FnSpace));\n-        Substs { types: types, regions: regions }\n-    }\n-\n-    /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n-    pub fn to_trait_ref(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, trait_id: DefId)\n-                        -> ty::TraitRef<'tcx> {\n-        let Substs { mut types, mut regions } = self.clone();\n-        types.truncate(FnSpace, 0);\n-        regions.truncate(FnSpace, 0);\n-\n-        ty::TraitRef {\n-            def_id: trait_id,\n-            substs: tcx.mk_substs(Substs { types: types, regions: regions })\n-        }\n+    /// Transform from substitutions for a child of `source_ancestor`\n+    /// (e.g. a trait or impl) to substitutions for the same child\n+    /// in a different item, with `target_substs` as the base for\n+    /// the target impl/trait, with the source child-specific\n+    /// parameters (e.g. method parameters) on top of that base.\n+    pub fn rebase_onto(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                       source_ancestor: DefId,\n+                       target_substs: &Substs<'tcx>)\n+                       -> &'tcx Substs<'tcx> {\n+        let defs = tcx.lookup_generics(source_ancestor);\n+        assert_eq!(self.types.len(SelfSpace), defs.types.len(SelfSpace));\n+        assert_eq!(self.types.len(TypeSpace), defs.types.len(TypeSpace));\n+        assert_eq!(target_substs.types.len(FnSpace), 0);\n+        assert_eq!(defs.types.len(FnSpace), 0);\n+        assert_eq!(self.regions.len(TypeSpace), defs.regions.len(TypeSpace));\n+        assert_eq!(target_substs.regions.len(FnSpace), 0);\n+        assert_eq!(defs.regions.len(FnSpace), 0);\n+\n+        let Substs { mut types, mut regions } = target_substs.clone();\n+        types.content.extend(&self.types.as_full_slice()[defs.types.content.len()..]);\n+        regions.content.extend(&self.regions.as_full_slice()[defs.regions.content.len()..]);\n+        Substs::new(tcx, types, regions)\n     }\n }\n \n-impl<'tcx> Encodable for Substs<'tcx> {\n+impl<'tcx> Encodable for &'tcx Substs<'tcx> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n             ecx.encode_substs(rbml_w, self);\n@@ -180,19 +179,10 @@ impl<'tcx> Encodable for Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Decodable for Substs<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Substs<'tcx>, D::Error> {\n-        cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            Ok(dcx.decode_substs(rbml_r))\n-        })\n-    }\n-}\n-\n impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error> {\n         let substs = cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            let substs = dcx.decode_substs(rbml_r);\n-            dcx.tcx().mk_substs(substs)\n+            dcx.decode_substs(rbml_r)\n         });\n \n         Ok(substs)\n@@ -307,70 +297,6 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    /// Appends `value` to the vector associated with `space`.\n-    ///\n-    /// Unlike the `push` method in `Vec`, this should not be assumed\n-    /// to be a cheap operation (even when amortized over many calls).\n-    pub fn push(&mut self, space: ParamSpace, value: T) {\n-        let (_, limit) = self.limits(space);\n-        match space {\n-            SelfSpace => { self.type_limit += 1; self.self_limit += 1; }\n-            TypeSpace => { self.type_limit += 1; }\n-            FnSpace => { }\n-        }\n-        self.content.insert(limit, value);\n-    }\n-\n-    /// Appends `values` to the vector associated with `space`.\n-    ///\n-    /// Unlike the `extend` method in `Vec`, this should not be assumed\n-    /// to be a cheap operation (even when amortized over many calls).\n-    pub fn extend<I:Iterator<Item=T>>(&mut self, space: ParamSpace, values: I) {\n-        // This could be made more efficient, obviously.\n-        for item in values {\n-            self.push(space, item);\n-        }\n-    }\n-\n-    pub fn pop(&mut self, space: ParamSpace) -> Option<T> {\n-        let (start, limit) = self.limits(space);\n-        if start == limit {\n-            None\n-        } else {\n-            match space {\n-                SelfSpace => { self.type_limit -= 1; self.self_limit -= 1; }\n-                TypeSpace => { self.type_limit -= 1; }\n-                FnSpace => {}\n-            }\n-            if self.content.is_empty() {\n-                None\n-            } else {\n-                Some(self.content.remove(limit - 1))\n-            }\n-        }\n-    }\n-\n-    pub fn truncate(&mut self, space: ParamSpace, len: usize) {\n-        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n-        while self.len(space) > len {\n-            self.pop(space);\n-        }\n-    }\n-\n-    pub fn replace(&mut self, space: ParamSpace, elems: Vec<T>) {\n-        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n-        self.truncate(space, 0);\n-        for t in elems {\n-            self.push(space, t);\n-        }\n-    }\n-\n-    pub fn get_self<'a>(&'a self) -> Option<&'a T> {\n-        let v = self.get_slice(SelfSpace);\n-        assert!(v.len() <= 1);\n-        if v.is_empty() { None } else { Some(&v[0]) }\n-    }\n-\n     pub fn len(&self, space: ParamSpace) -> usize {\n         self.get_slice(space).len()\n     }\n@@ -384,19 +310,6 @@ impl<T> VecPerParamSpace<T> {\n         &self.content[start.. limit]\n     }\n \n-    pub fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n-        let (start, limit) = self.limits(space);\n-        &mut self.content[start.. limit]\n-    }\n-\n-    pub fn opt_get<'a>(&'a self,\n-                       space: ParamSpace,\n-                       index: usize)\n-                       -> Option<&'a T> {\n-        let v = self.get_slice(space);\n-        if index < v.len() { Some(&v[index]) } else { None }\n-    }\n-\n     pub fn get<'a>(&'a self, space: ParamSpace, index: usize) -> &'a T {\n         &self.get_slice(space)[index]\n     }\n@@ -409,12 +322,6 @@ impl<T> VecPerParamSpace<T> {\n         &self.content\n     }\n \n-    pub fn all_vecs<P>(&self, mut pred: P) -> bool where\n-        P: FnMut(&[T]) -> bool,\n-    {\n-        ParamSpace::all().iter().all(|&space| { pred(self.get_slice(space)) })\n-    }\n-\n     pub fn all<P>(&self, pred: P) -> bool where P: FnMut(&T) -> bool {\n         self.as_full_slice().iter().all(pred)\n     }\n@@ -424,7 +331,7 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        self.all_vecs(|v| v.is_empty())\n+        self.content.is_empty()\n     }\n \n     pub fn map<U, P>(&self, pred: P) -> VecPerParamSpace<U> where P: FnMut(&T) -> U {\n@@ -442,18 +349,6 @@ impl<T> VecPerParamSpace<T> {\n                                        self.self_limit,\n                                        self.type_limit)\n     }\n-\n-    pub fn with_slice(mut self, space: ParamSpace, slice: &[T])\n-                    -> VecPerParamSpace<T>\n-        where T: Clone\n-    {\n-        assert!(self.is_empty_in(space));\n-        for t in slice {\n-            self.push(space, t.clone());\n-        }\n-\n-        self\n-    }\n }\n \n #[derive(Clone)]\n@@ -581,7 +476,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match r {\n             ty::ReEarlyBound(data) => {\n-                match self.substs.regions.opt_get(data.space, data.index as usize) {\n+                match self.substs.regions.get_slice(data.space).get(data.index as usize) {\n                     Some(&r) => {\n                         self.shift_region_through_binders(r)\n                     }\n@@ -637,7 +532,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.opt_get(p.space, p.idx as usize);\n+        let opt_ty = self.substs.types.get_slice(p.space).get(p.idx as usize);\n         let ty = match opt_ty {\n             Some(t) => *t,\n             None => {\n@@ -718,3 +613,67 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         ty::fold::shift_region(region, self.region_binders_passed)\n     }\n }\n+\n+// Helper methods that modify substitutions.\n+\n+impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n+    pub fn from_method(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                       trait_id: DefId,\n+                       substs: &Substs<'tcx>)\n+                       -> ty::TraitRef<'tcx> {\n+        let Substs { mut types, mut regions } = substs.clone();\n+        let defs = tcx.lookup_generics(trait_id);\n+        types.content.truncate(defs.types.type_limit);\n+        regions.content.truncate(defs.regions.type_limit);\n+\n+        ty::TraitRef {\n+            def_id: trait_id,\n+            substs: Substs::new(tcx, types, regions)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ty::ExistentialTraitRef<'tcx> {\n+    pub fn erase_self_ty(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         trait_ref: ty::TraitRef<'tcx>)\n+                         -> ty::ExistentialTraitRef<'tcx> {\n+        let Substs { mut types, regions } = trait_ref.substs.clone();\n+\n+        assert_eq!(types.self_limit, 1);\n+        types.self_limit = 0;\n+        types.type_limit -= 1;\n+        types.content.remove(0);\n+\n+        ty::ExistentialTraitRef {\n+            def_id: trait_ref.def_id,\n+            substs: Substs::new(tcx, types, regions)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        self_ty: Ty<'tcx>)\n+                        -> ty::PolyTraitRef<'tcx>  {\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        self.map_bound(|trait_ref| {\n+            let Substs { mut types, regions } = trait_ref.substs.clone();\n+\n+            assert_eq!(types.self_limit, 0);\n+            types.self_limit = 1;\n+            types.type_limit += 1;\n+            types.content.insert(0, self_ty);\n+\n+            ty::TraitRef {\n+                def_id: trait_ref.def_id,\n+                substs: Substs::new(tcx, types, regions)\n+            }\n+        })\n+    }\n+}"}, {"sha": "61285e8f8b0a597ef378b284e9410f644ccdc80f", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -34,7 +34,7 @@ pub struct TraitDef<'tcx> {\n     /// `Eq`, there is a single bound `Self : Eq`). This is so that\n     /// default methods get to assume that the `Self` parameters\n     /// implements the trait.\n-    pub generics: ty::Generics<'tcx>,\n+    pub generics: &'tcx ty::Generics<'tcx>,\n \n     pub trait_ref: ty::TraitRef<'tcx>,\n \n@@ -76,7 +76,7 @@ pub struct TraitDef<'tcx> {\n impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     pub fn new(unsafety: hir::Unsafety,\n                paren_sugar: bool,\n-               generics: ty::Generics<'tcx>,\n+               generics: &'tcx ty::Generics<'tcx>,\n                trait_ref: ty::TraitRef<'tcx>,\n                associated_type_names: Vec<Name>)\n                -> TraitDef<'tcx> {"}, {"sha": "5a73439beac6ef145b1adcb14ecf7c9a780d6a8d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -11,7 +11,6 @@\n //! misc. type-system utilities too small to deserve their own file\n \n use hir::def_id::DefId;\n-use ty::subst;\n use infer::InferCtxt;\n use hir::pat_util;\n use traits::{self, Reveal};\n@@ -695,12 +694,10 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         return false;\n                     }\n \n-                    let types_a = substs_a.types.get_slice(subst::TypeSpace);\n-                    let types_b = substs_b.types.get_slice(subst::TypeSpace);\n+                    let types_a = substs_a.types.as_full_slice();\n+                    let types_b = substs_b.types.as_full_slice();\n \n-                    let mut pairs = types_a.iter().zip(types_b);\n-\n-                    pairs.all(|(&a, &b)| same_type(a, b))\n+                    types_a.iter().zip(types_b).all(|(&a, &b)| same_type(a, b))\n                 }\n                 _ => {\n                     a == b"}, {"sha": "cdbd30705236405e3195ee5bb2723f8f50995ed7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 54, "deletions": 74, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -10,7 +10,7 @@\n \n \n use hir::def_id::DefId;\n-use ty::subst::{self, Subst};\n+use ty::subst::{self, Subst, Substs};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyStruct, TyEnum};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n@@ -65,69 +65,57 @@ pub enum Ns {\n fn number_of_supplied_defaults<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                substs: &subst::Substs,\n                                                space: subst::ParamSpace,\n-                                               generics: ty::Generics<'tcx>)\n+                                               generics: &ty::Generics<'tcx>)\n                                                -> usize\n {\n-    let has_self = substs.self_ty().is_some();\n     let ty_params = generics.types.get_slice(space);\n     let tps = substs.types.get_slice(space);\n     if ty_params.last().map_or(false, |def| def.default.is_some()) {\n         let substs = tcx.lift(&substs);\n         ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n-            match def.default {\n-                Some(default) => {\n-                    if !has_self && default.has_self_ty() {\n-                        // In an object type, there is no `Self`, and\n-                        // thus if the default value references Self,\n-                        // the user will be required to give an\n-                        // explicit value. We can't even do the\n-                        // substitution below to check without causing\n-                        // an ICE. (#18956).\n-                        false\n-                    } else {\n-                        let default = tcx.lift(&default);\n-                        substs.and_then(|substs| default.subst(tcx, substs))\n-                            == Some(actual)\n-                    }\n-                }\n-                None => false\n-            }\n+            substs.and_then(|substs| def.default.subst(tcx, substs))\n+                == Some(actual)\n         }).count()\n     } else {\n         0\n     }\n }\n \n-pub fn parameterized<GG>(f: &mut fmt::Formatter,\n-                         substs: &subst::Substs,\n-                         did: DefId,\n-                         ns: Ns,\n-                         projections: &[ty::ProjectionPredicate],\n-                         get_generics: GG)\n-                         -> fmt::Result\n-    where GG: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>)\n-                                         -> Option<ty::Generics<'tcx>>\n-{\n-    if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n-        write!(f, \"<{} as \", self_ty)?;\n-    }\n+pub fn parameterized(f: &mut fmt::Formatter,\n+                     substs: &subst::Substs,\n+                     did: DefId,\n+                     ns: Ns,\n+                     projections: &[ty::ProjectionPredicate])\n+                     -> fmt::Result {\n+    let (fn_trait_kind, verbose, item_name, is_in_trait) = ty::tls::with(|tcx| {\n+        let is_in_trait = ns == Ns::Value && tcx.trait_of_item(did).is_some();\n+        if is_in_trait {\n+            write!(f, \"<{} as \", substs.types.get(subst::SelfSpace, 0))?;\n+        }\n \n-    let (fn_trait_kind, verbose, item_name) = ty::tls::with(|tcx| {\n         let (did, item_name) = if ns == Ns::Value {\n             // Try to get the impl/trait parent, if this is an\n             // associated value item (method or constant).\n-            tcx.trait_of_item(did).or_else(|| tcx.impl_of_method(did))\n-               .map_or((did, None), |parent| (parent, Some(tcx.item_name(did))))\n+            tcx.trait_of_item(did).or_else(|| {\n+                // An impl could be a trait impl or an inherent one.\n+                tcx.impl_of_method(did).map(|impl_def_id| {\n+                    tcx.trait_id_of_impl(impl_def_id)\n+                       .unwrap_or(impl_def_id)\n+                })\n+            }).map_or((did, None), |parent| (parent, Some(tcx.item_name(did))))\n         } else {\n             (did, None)\n         };\n         write!(f, \"{}\", tcx.item_path_str(did))?;\n-        Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose(), item_name))\n+        Ok((tcx.lang_items.fn_trait_kind(did),\n+            tcx.sess.verbose(),\n+            item_name,\n+            is_in_trait))\n     })?;\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args) = substs.types.get_slice(subst::TypeSpace)[0].sty {\n+        if let TyTuple(ref args) = substs.types.get(subst::TypeSpace, 0).sty {\n             return fn_sig(f, args, false, projection_ty);\n         }\n     }\n@@ -176,11 +164,8 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n         0\n     } else {\n         ty::tls::with(|tcx| {\n-            if let Some(generics) = get_generics(tcx) {\n-                number_of_supplied_defaults(tcx, substs, subst::TypeSpace, generics)\n-            } else {\n-                0\n-            }\n+            let generics = tcx.lookup_generics(did);\n+            number_of_supplied_defaults(tcx, substs, subst::TypeSpace, generics)\n         })\n     };\n \n@@ -204,7 +189,7 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     if ns == Ns::Value {\n         empty.set(true);\n \n-        if substs.self_ty().is_some() {\n+        if is_in_trait {\n             write!(f, \">\")?;\n         }\n \n@@ -288,7 +273,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n /// projection bounds, so we just stuff them altogether. But in\n /// reality we should eventually sort things out better.\n #[derive(Clone, Debug)]\n-struct TraitAndProjections<'tcx>(ty::ExistentialTraitRef<'tcx>,\n+struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>,\n                                  Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n@@ -307,21 +292,24 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n         parameterized(f, trait_ref.substs,\n                       trait_ref.def_id,\n                       Ns::Type,\n-                      projection_bounds,\n-                      |tcx| Some(tcx.lookup_trait_def(trait_ref.def_id).generics.clone()))\n+                      projection_bounds)\n     }\n }\n \n impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Generate the main trait ref, including associated types.\n         ty::tls::with(|tcx| {\n-            let principal = tcx.lift(&self.principal.0)\n-                               .expect(\"could not lift TraitRef for printing\");\n+            // Use a type that can't appear in defaults of type parameters.\n+            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+            let principal = tcx.lift(&self.principal)\n+                               .expect(\"could not lift TraitRef for printing\")\n+                               .with_self_ty(tcx, dummy_self).0;\n             let projections = self.projection_bounds.iter().map(|p| {\n-                let projection = tcx.lift(p)\n-                                    .expect(\"could not lift projection for printing\");\n-                projection.with_self_ty(tcx, tcx.types.err).0\n+                tcx.lift(p)\n+                    .expect(\"could not lift projection for printing\")\n+                    .with_self_ty(tcx, dummy_self).0\n             }).collect();\n \n             let tap = ty::Binder(TraitAndProjections(principal, projections));\n@@ -380,7 +368,7 @@ impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for subst::Substs<'tcx> {\n+impl<'tcx> fmt::Debug for Substs<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Substs[types={:?}, regions={:?}]\",\n                self.types, self.regions)\n@@ -404,7 +392,14 @@ impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", *self)\n+        ty::tls::with(|tcx| {\n+            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+            let trait_ref = tcx.lift(&ty::Binder(*self))\n+                               .expect(\"could not lift TraitRef for printing\")\n+                               .with_self_ty(tcx, dummy_self).0;\n+            parameterized(f, trait_ref.substs, trait_ref.def_id, Ns::Type, &[])\n+        })\n     }\n }\n \n@@ -813,15 +808,7 @@ impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>>\n \n impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, Ns::Type, &[],\n-                      |tcx| Some(tcx.lookup_trait_def(self.def_id).generics.clone()))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::ExistentialTraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, Ns::Type, &[],\n-                      |tcx| Some(tcx.lookup_trait_def(self.def_id).generics.clone()))\n+        parameterized(f, self.substs, self.def_id, Ns::Type, &[])\n     }\n }\n \n@@ -874,9 +861,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n \n                 write!(f, \"{} {{\", bare_fn.sig.0)?;\n-                parameterized(\n-                    f, substs, def_id, Ns::Value, &[],\n-                    |tcx| tcx.opt_lookup_item_type(def_id).map(|t| t.generics))?;\n+                parameterized(f, substs, def_id, Ns::Value, &[])?;\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {\n@@ -899,12 +884,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                           !tcx.tcache.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n-                        parameterized(\n-                            f, substs, def.did, Ns::Type, &[],\n-                            |tcx| {\n-                                tcx.opt_lookup_item_type(def.did).\n-                                    map(|t| t.generics)\n-                            })\n+                        parameterized(f, substs, def.did, Ns::Type, &[])\n                     }\n                 })\n             }\n@@ -916,7 +896,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     // by looking up the projections associated with the def_id.\n                     let item_predicates = tcx.lookup_predicates(def_id);\n                     let substs = tcx.lift(&substs).unwrap_or_else(|| {\n-                        tcx.mk_substs(subst::Substs::empty())\n+                        Substs::empty(tcx)\n                     });\n                     let bounds = item_predicates.instantiate(tcx, substs);\n "}, {"sha": "df91ec2b98d5dbb0f1b0920f781baa12f9f83459", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -859,10 +859,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-        let substs = tcx.mk_substs(Substs::new(\n+        let substs = Substs::new(tcx,\n             VecPerParamSpace::new(vec![], vec![], vec![ty]),\n-            VecPerParamSpace::new(vec![], vec![], vec![])\n-        ));\n+            VecPerParamSpace::new(vec![], vec![], vec![]));\n         let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {"}, {"sha": "d71add3258fbd888d917e991b2a80f60a1101127", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -22,8 +22,9 @@ use rustc::traits;\n use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n-use rustc::ty::{self, Ty, TyCtxt, subst};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n+use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n@@ -93,7 +94,7 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// This generally happens in late/trans const evaluation.\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n-                                        substs: Option<&'tcx subst::Substs<'tcx>>)\n+                                        substs: Option<&'tcx Substs<'tcx>>)\n                                         -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n@@ -110,7 +111,8 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n-                        let trait_id = tcx.trait_of_item(def_id).unwrap();\n+                        let trait_id = tcx.map.get_parent(node_id);\n+                        let trait_id = tcx.map.local_def_id(trait_id);\n                         resolve_trait_associated_const(tcx, ti, trait_id, substs)\n                     } else {\n                         // Technically, without knowing anything about the\n@@ -1045,16 +1047,14 @@ fn infer<'a, 'tcx>(i: ConstInt,\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n-                                                rcvr_substs: &'tcx subst::Substs<'tcx>)\n+                                                rcvr_substs: &'tcx Substs<'tcx>)\n                                                 -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n {\n-    let trait_ref = ty::Binder(\n-        rcvr_substs.clone().erase_regions().to_trait_ref(tcx, trait_id)\n-    );\n+    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n+    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n     tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),"}, {"sha": "c84b195dd4b30e5740fc07ceb2344a3338435ae2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -21,7 +21,7 @@ use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n use rustc::ty::subst;\n-use rustc::ty::subst::Subst;\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n@@ -678,8 +678,8 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_param], env.t_nil())\n         };\n \n-        let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+        let substs = Substs::new_type(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n         let t_expected = {\n@@ -713,8 +713,8 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n         };\n \n-        let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+        let substs = Substs::new_type(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = (&'a isize, fn(&'a isize))\n         //\n@@ -775,8 +775,8 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n         };\n \n-        let substs = subst::Substs::new_type(vec![], vec![re_bound1]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+        let substs = Substs::new_type(env.infcx.tcx, vec![], vec![re_bound1]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n         //"}, {"sha": "61d927239828b2124894debb7581181f9834cff7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -465,16 +465,14 @@ impl LateLintPass for MissingCopyImplementations {\n                     return;\n                 }\n                 let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n-                (def, cx.tcx.mk_struct(def,\n-                                       cx.tcx.mk_substs(Substs::empty())))\n+                (def, cx.tcx.mk_struct(def, Substs::empty(cx.tcx)))\n             }\n             hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n                 let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n-                (def, cx.tcx.mk_enum(def,\n-                                     cx.tcx.mk_substs(Substs::empty())))\n+                (def, cx.tcx.mk_enum(def, Substs::empty(cx.tcx)))\n             }\n             _ => return,\n         };\n@@ -898,7 +896,7 @@ impl LateLintPass for UnconditionalRecursion {\n                 // A trait method, from any number of possible sources.\n                 // Attempt to select a concrete impl before checking.\n                 ty::TraitContainer(trait_def_id) => {\n-                    let trait_ref = callee_substs.to_trait_ref(tcx, trait_def_id);\n+                    let trait_ref = ty::TraitRef::from_method(tcx, trait_def_id, callee_substs);\n                     let trait_ref = ty::Binder(trait_ref);\n                     let span = tcx.map.span(expr_id);\n                     let obligation =\n@@ -918,8 +916,7 @@ impl LateLintPass for UnconditionalRecursion {\n                             // If `T` is `Self`, then this call is inside\n                             // a default method definition.\n                             Ok(Some(traits::VtableParam(_))) => {\n-                                let self_ty = callee_substs.self_ty();\n-                                let on_self = self_ty.map_or(false, |t| t.is_self());\n+                                let on_self = trait_ref.self_ty().is_self();\n                                 // We can only be recurring in a default\n                                 // method if we're being called literally\n                                 // on the `Self` type."}, {"sha": "1b00eee76f69bf47b9e7643bdcaa87affb8a0999", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -34,7 +34,7 @@ use middle::const_qualif::ConstQualif;\n use rustc::hir::def::{self, Def};\n use rustc::hir::def_id::DefId;\n use middle::region;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use syntax::ast;\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n                     Ok(this.read_ty(dcx))\n                 }).unwrap(),\n                 substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(dcx.tcx.mk_substs(this.read_substs(dcx)))\n+                    Ok(this.read_substs(dcx))\n                 }).unwrap()\n             }))\n         }).unwrap()\n@@ -525,7 +525,7 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                       substs: &subst::Substs<'tcx>);\n+                       substs: &Substs<'tcx>);\n     fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                 adj: &adjustment::AutoAdjustment<'tcx>);\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     }\n \n     fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                       substs: &subst::Substs<'tcx>) {\n+                       substs: &Substs<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(&mut this.cursor,\n                                                         &ecx.ty_str_ctxt(),\n                                                         substs)));\n@@ -839,7 +839,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                           -> subst::Substs<'tcx>;\n+                           -> &'tcx Substs<'tcx>;\n     fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n                           -> ty::UpvarCapture;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -859,7 +859,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                           cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>>;\n     fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              cdata: &cstore::CrateMetadata)\n-                             -> subst::Substs<'tcx>;\n+                             -> &'tcx Substs<'tcx>;\n }\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n@@ -884,7 +884,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n     fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                              cdata: &cstore::CrateMetadata)\n-                             -> subst::Substs<'tcx>\n+                             -> &'tcx Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {\n             Ok(\n@@ -946,7 +946,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_substs<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                           -> subst::Substs<'tcx> {\n+                           -> &'tcx Substs<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::TyDecoder::with_doc(dcx.tcx, dcx.cdata.cnum, doc,\n                                              &mut |d| convert_def_id(dcx, d))\n@@ -1140,7 +1140,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {\n-                            substs: dcx.tcx.mk_substs(val_dsr.read_substs(dcx))\n+                            substs: val_dsr.read_substs(dcx)\n                         };\n                         dcx.tcx.tables.borrow_mut().item_substs.insert(\n                             id, item_substs);"}, {"sha": "99a3f3b00c8b0f4ca4824c8c457595a9a629b2d5", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -196,16 +196,11 @@ pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n // GAP 0x8d\n pub const tag_items_data_region: usize = 0x8e;\n \n-pub const tag_region_param_def: usize = 0x8f;\n-pub const tag_region_param_def_ident: usize = 0x90;\n-pub const tag_region_param_def_def_id: usize = 0x91;\n-pub const tag_region_param_def_space: usize = 0x92;\n-pub const tag_region_param_def_index: usize = 0x93;\n+pub const tag_item_generics: usize = 0x8f;\n+// GAP 0x90, 0x91, 0x92, 0x93, 0x94\n \n-pub const tag_type_param_def: usize = 0x94;\n-\n-pub const tag_item_generics: usize = 0x95;\n-pub const tag_method_ty_generics: usize = 0x96;\n+pub const tag_item_predicates: usize = 0x95;\n+// GAP 0x96\n \n pub const tag_predicate: usize = 0x97;\n // GAP 0x98, 0x99"}, {"sha": "f6d698eb969d80baa919273315ecda8a27289077", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> ty::TypeScheme<'tcx>\n+                     -> Ty<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n@@ -109,6 +109,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_super_predicates(&cdata, def.index, tcx)\n     }\n \n+    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                         -> &'tcx ty::Generics<'tcx>\n+    {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_generics(&cdata, def.index, tcx)\n+    }\n+\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n@@ -231,11 +239,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_parent_impl(&*cdata, impl_def.index)\n     }\n \n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId>\n-    {\n+    fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_trait_of_item(&cdata, def_id.index, tcx)\n+        decoder::get_trait_of_item(&cdata, def_id.index)\n     }\n \n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)"}, {"sha": "e42825ef1e549e8d7a7900d70a5dba253232bbcd", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 25, "deletions": 55, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -264,11 +264,6 @@ fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata:\n     })\n }\n \n-pub fn item_type<'a, 'tcx>(_item_id: DefId, item: rbml::Doc,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n-    doc_type(item, tcx, cdata)\n-}\n-\n fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n                            -> ty::TraitRef<'tcx> {\n     TyDecoder::with_doc(tcx, cdata.cnum, doc,\n@@ -383,7 +378,7 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n-    let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n+    let generics = doc_generics(item_doc, tcx, cdata);\n     let unsafety = parse_unsafety(item_doc);\n     let associated_type_names = parse_associated_type_names(item_doc);\n     let paren_sugar = parse_paren_sugar(item_doc);\n@@ -493,7 +488,7 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n             // from the ctor.\n             debug!(\"evaluating the ctor-type of {:?}\",\n                    variant.name);\n-            let ctor_ty = get_type(cdata, variant.did.index, tcx).ty;\n+            let ctor_ty = get_type(cdata, variant.did.index, tcx);\n             debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n                    variant.name,\n                    ctor_ty);\n@@ -513,7 +508,7 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n         } else {\n             for field in &variant.fields {\n                 debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n-                let ty = get_type(cdata, field.did.index, tcx).ty;\n+                let ty = get_type(cdata, field.did.index, tcx);\n                 field.fulfill_ty(ty);\n                 debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n                        variant.name, field.name, ty);\n@@ -530,7 +525,7 @@ pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n                                 -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n-    doc_predicates(item_doc, tcx, cdata, tag_item_generics)\n+    doc_predicates(item_doc, tcx, cdata, tag_item_predicates)\n }\n \n pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n@@ -542,17 +537,20 @@ pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n     doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n }\n \n+pub fn get_generics<'a, 'tcx>(cdata: Cmd,\n+                              item_id: DefIndex,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                              -> &'tcx ty::Generics<'tcx>\n+{\n+    let item_doc = cdata.lookup_item(item_id);\n+    doc_generics(item_doc, tcx, cdata)\n+}\n+\n pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> ty::TypeScheme<'tcx>\n+                          -> Ty<'tcx>\n {\n     let item_doc = cdata.lookup_item(id);\n-    let t = item_type(DefId { krate: cdata.cnum, index: id }, item_doc, tcx,\n-                      cdata);\n-    let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n-    ty::TypeScheme {\n-        generics: generics,\n-        ty: t\n-    }\n+    doc_type(item_doc, tcx, cdata)\n }\n \n pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n@@ -960,8 +958,8 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n             }))\n         }\n         Some('r') | Some('p') => {\n-            let generics = doc_generics(item_doc, tcx, cdata, tag_method_ty_generics);\n-            let predicates = doc_predicates(item_doc, tcx, cdata, tag_method_ty_generics);\n+            let generics = doc_generics(item_doc, tcx, cdata);\n+            let predicates = doc_predicates(item_doc, tcx, cdata, tag_item_predicates);\n             let ity = tcx.lookup_item_type(def_id).ty;\n             let fty = match ity.sty {\n                 ty::TyFnDef(_, _, fty) => fty,\n@@ -1393,10 +1391,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     }\n }\n \n-pub fn get_trait_of_item<'a, 'tcx>(cdata: Cmd,\n-                                   id: DefIndex,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                   -> Option<DefId> {\n+pub fn get_trait_of_item(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n     let item_doc = cdata.lookup_item(id);\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n@@ -1405,10 +1400,6 @@ pub fn get_trait_of_item<'a, 'tcx>(cdata: Cmd,\n     let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n-        Impl | DefaultImpl => {\n-            reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref)\n-                .map(|_| item_trait_ref(parent_item_doc, tcx, cdata).def_id)\n-        }\n         _ => None\n     }\n }\n@@ -1537,11 +1528,7 @@ pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n     };\n     let applicable = match item_family(item_doc) {\n         ImmStatic | MutStatic => true,\n-        Fn => {\n-            let ty::TypeScheme { generics, .. } = get_type(cdata, id, tcx);\n-            let no_generics = generics.types.is_empty();\n-            no_generics\n-        },\n+        Fn => get_generics(cdata, id, tcx).types.is_empty(),\n         _ => false,\n     };\n \n@@ -1573,30 +1560,13 @@ pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n \n fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          cdata: Cmd,\n-                          tag: usize)\n-                          -> ty::Generics<'tcx>\n+                          cdata: Cmd)\n+                          -> &'tcx ty::Generics<'tcx>\n {\n-    let doc = reader::get_doc(base_doc, tag);\n-\n-    let mut generics = ty::Generics::empty();\n-    for p in reader::tagged_docs(doc, tag_type_param_def) {\n-        let bd =\n-            TyDecoder::with_doc(tcx, cdata.cnum, p,\n-                                &mut |did| translate_def_id(cdata, did))\n-            .parse_type_param_def();\n-        generics.types.push(bd.space, bd);\n-    }\n-\n-    for p in reader::tagged_docs(doc, tag_region_param_def) {\n-        let bd =\n-            TyDecoder::with_doc(tcx, cdata.cnum, p,\n-                                &mut |did| translate_def_id(cdata, did))\n-            .parse_region_param_def();\n-        generics.regions.push(bd.space, bd);\n-    }\n-\n-    generics\n+    let doc = reader::get_doc(base_doc, tag_item_generics);\n+    TyDecoder::with_doc(tcx, cdata.cnum, doc,\n+                        &mut |did| translate_def_id(cdata, did))\n+        .parse_generics()\n }\n \n fn doc_predicate<'a, 'tcx>(cdata: Cmd,"}, {"sha": "1e74b3c1ef48fc99b76a9f513a2fccc7945d8be1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 41, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -175,8 +175,7 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     index: &mut CrateIndex<'a, 'tcx>,\n                                     scheme: &ty::TypeScheme<'tcx>,\n                                     predicates: &ty::GenericPredicates<'tcx>) {\n-    encode_generics(rbml_w, ecx, index,\n-                    &scheme.generics, &predicates, tag_item_generics);\n+    encode_generics(rbml_w, ecx, index, &scheme.generics, &predicates);\n     encode_type(ecx, rbml_w, scheme.ty);\n }\n \n@@ -510,50 +509,26 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n                              index: &mut CrateIndex<'a, 'tcx>,\n                              generics: &ty::Generics<'tcx>,\n-                             predicates: &ty::GenericPredicates<'tcx>,\n-                             tag: usize)\n+                             predicates: &ty::GenericPredicates<'tcx>)\n {\n-    rbml_w.start_tag(tag);\n-\n-    for param in generics.types.as_full_slice() {\n-        rbml_w.start_tag(tag_type_param_def);\n-        tyencode::enc_type_param_def(rbml_w.writer, &ecx.ty_str_ctxt(), param);\n-        rbml_w.mark_stable_position();\n-        rbml_w.end_tag();\n-    }\n-\n-    // Region parameters\n-    for param in generics.regions.as_full_slice() {\n-        rbml_w.start_tag(tag_region_param_def);\n-        tyencode::enc_region_param_def(rbml_w.writer, &ecx.ty_str_ctxt(), param);\n-        rbml_w.mark_stable_position();\n-        rbml_w.end_tag();\n-    }\n-\n-    encode_predicates_in_current_doc(rbml_w, ecx, index, predicates);\n-\n+    rbml_w.start_tag(tag_item_generics);\n+    tyencode::enc_generics(rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n+    rbml_w.mark_stable_position();\n     rbml_w.end_tag();\n-}\n \n-fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n-                                             _ecx: &EncodeContext<'a,'tcx>,\n-                                             index: &mut CrateIndex<'a, 'tcx>,\n-                                             predicates: &ty::GenericPredicates<'tcx>)\n-{\n-    for predicate in &predicates.predicates {\n-        rbml_w.wr_tagged_u32(tag_predicate,\n-            index.add_xref(XRef::Predicate(predicate.clone())));\n-    }\n+    encode_predicates(rbml_w, index, predicates, tag_item_predicates);\n }\n \n fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n-                              ecx: &EncodeContext<'a,'tcx>,\n                               index: &mut CrateIndex<'a, 'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>,\n                               tag: usize)\n {\n     rbml_w.start_tag(tag);\n-    encode_predicates_in_current_doc(rbml_w, ecx, index, predicates);\n+    for predicate in &predicates.predicates {\n+        rbml_w.wr_tagged_u32(tag_predicate,\n+            index.add_xref(XRef::Predicate(predicate.clone())));\n+    }\n     rbml_w.end_tag();\n }\n \n@@ -564,8 +539,7 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n     encode_generics(rbml_w, ecx, index,\n-                    &method_ty.generics, &method_ty.predicates,\n-                    tag_method_ty_generics);\n+                    &method_ty.generics, &method_ty.predicates);\n     encode_visibility(rbml_w, method_ty.vis);\n     encode_explicit_self(rbml_w, &method_ty.explicit_self);\n     match method_ty.explicit_self {\n@@ -695,7 +669,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &ii.attrs);\n         encode_defaultness(rbml_w, ii.defaultness);\n     } else {\n-        encode_predicates(rbml_w, ecx, index,\n+        encode_predicates(rbml_w, index,\n                           &ecx.tcx.lookup_predicates(associated_type.def_id),\n                           tag_item_generics);\n     }\n@@ -1134,9 +1108,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, index,\n-                        &trait_def.generics, &trait_predicates,\n-                        tag_item_generics);\n-        encode_predicates(rbml_w, ecx, index,\n+                        &trait_def.generics, &trait_predicates);\n+        encode_predicates(rbml_w, index,\n                           &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);"}, {"sha": "6e78cbcd28e731e663b698a6fc16d2068b041113", "filename": "src/librustc_metadata/tls_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n         ty\n     }\n \n-    fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx> {\n+    fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx> {\n         let def_id_convert = &mut |did| {\n             decoder::translate_def_id(self.crate_metadata, did)\n         };"}, {"sha": "3f0fa9073aa362f4ab54c6dc241c5d0a4348c913", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -20,8 +20,7 @@ use rustc::hir;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use middle::region;\n-use rustc::ty::subst;\n-use rustc::ty::subst::VecPerParamSpace;\n+use rustc::ty::subst::{self, Substs, VecPerParamSpace};\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n use rbml;\n@@ -132,21 +131,31 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     fn parse_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n         F: FnMut(&mut TyDecoder<'a, 'tcx>) -> T,\n     {\n-        let mut r = VecPerParamSpace::empty();\n-        for &space in &subst::ParamSpace::all() {\n+        let (mut a, mut b, mut c) =  (vec![], vec![], vec![]);\n+        for r in &mut [&mut a, &mut b, &mut c] {\n             assert_eq!(self.next(), '[');\n             while self.peek() != ']' {\n-                r.push(space, f(self));\n+                r.push(f(self));\n             }\n             assert_eq!(self.next(), ']');\n         }\n-        r\n+        VecPerParamSpace::new(a, b, c)\n     }\n \n-    pub fn parse_substs(&mut self) -> subst::Substs<'tcx> {\n+    pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n         let regions = self.parse_vec_per_param_space(|this| this.parse_region());\n         let types = self.parse_vec_per_param_space(|this| this.parse_ty());\n-        subst::Substs { types: types, regions: regions }\n+        Substs::new(self.tcx, types, regions)\n+    }\n+\n+    pub fn parse_generics(&mut self) -> &'tcx ty::Generics<'tcx> {\n+        let regions = self.parse_vec_per_param_space(|this| this.parse_region_param_def());\n+        let types = self.parse_vec_per_param_space(|this| this.parse_type_param_def());\n+        self.tcx.alloc_generics(ty::Generics {\n+            regions: regions,\n+            types: types,\n+            has_self: self.next() == 'S'\n+        })\n     }\n \n     fn parse_bound_region(&mut self) -> ty::BoundRegion {\n@@ -302,15 +311,17 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     pub fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n-        let def = self.parse_def();\n-        let substs = self.tcx.mk_substs(self.parse_substs());\n-        ty::TraitRef {def_id: def, substs: substs}\n+        ty::TraitRef {\n+            def_id: self.parse_def(),\n+            substs: self.parse_substs()\n+        }\n     }\n \n     pub fn parse_existential_trait_ref(&mut self) -> ty::ExistentialTraitRef<'tcx> {\n-        let def = self.parse_def();\n-        let substs = self.tcx.mk_substs(self.parse_substs());\n-        ty::ExistentialTraitRef {def_id: def, substs: substs}\n+        ty::ExistentialTraitRef {\n+            def_id: self.parse_def(),\n+            substs: self.parse_substs()\n+        }\n     }\n \n     pub fn parse_ty(&mut self) -> Ty<'tcx> {\n@@ -342,7 +353,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n-                return tcx.mk_enum(def, self.tcx.mk_substs(substs));\n+                return tcx.mk_enum(def, substs);\n             }\n             'x' => {\n                 assert_eq!(self.next(), '[');\n@@ -406,7 +417,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'F' => {\n                 let def_id = self.parse_def();\n-                let substs = self.tcx.mk_substs(self.parse_substs());\n+                let substs = self.parse_substs();\n                 return tcx.mk_fn_def(def_id, substs, self.parse_bare_fn_ty());\n             }\n             'G' => {\n@@ -452,7 +463,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n-                return self.tcx.mk_struct(def, self.tcx.mk_substs(substs));\n+                return self.tcx.mk_struct(def, substs);\n             }\n             'k' => {\n                 assert_eq!(self.next(), '[');\n@@ -464,7 +475,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 }\n                 assert_eq!(self.next(), '.');\n                 assert_eq!(self.next(), ']');\n-                return self.tcx.mk_closure(did, self.tcx.mk_substs(substs), tys);\n+                return self.tcx.mk_closure(did, substs, tys);\n             }\n             'P' => {\n                 assert_eq!(self.next(), '[');\n@@ -477,7 +488,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let def_id = self.parse_def();\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n-                return self.tcx.mk_anon(def_id, self.tcx.mk_substs(substs));\n+                return self.tcx.mk_anon(def_id, substs);\n             }\n             'e' => {\n                 return tcx.types.err;\n@@ -622,7 +633,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n+    fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n         let space = self.parse_param_space();\n@@ -644,7 +655,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n+    fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n         let space = self.parse_param_space();"}, {"sha": "130d15485829ab59a714c1cf32c72f7cfdcb9a84", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -19,8 +19,7 @@ use std::io::prelude::*;\n \n use rustc::hir::def_id::DefId;\n use middle::region;\n-use rustc::ty::subst;\n-use rustc::ty::subst::VecPerParamSpace;\n+use rustc::ty::subst::{self, Substs, VecPerParamSpace};\n use rustc::ty::ParamTy;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FnvHashMap;\n@@ -266,13 +265,27 @@ fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut Cursor<Vec<u8>>,\n }\n \n pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                            substs: &subst::Substs<'tcx>) {\n+                            substs: &Substs<'tcx>) {\n     enc_vec_per_param_space(w, cx, &substs.regions,\n                             |w, cx, &r| enc_region(w, cx, r));\n     enc_vec_per_param_space(w, cx, &substs.types,\n                             |w, cx, &ty| enc_ty(w, cx, ty));\n }\n \n+pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                              generics: &ty::Generics<'tcx>) {\n+    enc_vec_per_param_space(w, cx, &generics.regions,\n+                            |w, cx, r| enc_region_param_def(w, cx, r));\n+    enc_vec_per_param_space(w, cx, &generics.types,\n+                            |w, cx, ty| enc_type_param_def(w, cx, ty));\n+\n+    if generics.has_self {\n+        write!(w, \"S\");\n+    } else {\n+        write!(w, \"N\");\n+    }\n+}\n+\n pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n@@ -420,17 +433,17 @@ fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBound\n     write!(w, \".\");\n }\n \n-pub fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                    v: &ty::TypeParameterDef<'tcx>) {\n+fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                                v: &ty::TypeParameterDef<'tcx>) {\n     write!(w, \"{}:{}|{}|{}|{}|\",\n              v.name, (cx.ds)(cx.tcx, v.def_id),\n              v.space.to_uint(), v.index, (cx.ds)(cx.tcx, v.default_def_id));\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n-pub fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n-                            v: &ty::RegionParameterDef) {\n+fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n+                        v: &ty::RegionParameterDef) {\n     write!(w, \"{}:{}|{}|{}|\",\n              v.name, (cx.ds)(cx.tcx, v.def_id),\n              v.space.to_uint(), v.index);"}, {"sha": "229890483882c1af4e77ced03768cf9171cb4751", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -750,7 +750,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-    let substs = tcx.mk_substs(Substs::new_fn(vec![data.item_ty], vec![]));\n+    let substs = Substs::new_fn(tcx, vec![data.item_ty], vec![]);\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,"}, {"sha": "972e7f5be7075ed339a7cba7754e5f5bfb42d692", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -147,16 +147,16 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         params: Vec<Ty<'tcx>>)\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n         let method_name = token::intern(method_name);\n-        let substs = Substs::new_trait(params, vec![], self_ty);\n+        let substs = Substs::new_trait(self.tcx, params, vec![], self_ty);\n         for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n             match *trait_item {\n                 ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n                     if method.name == method_name {\n                         let method_ty = self.tcx.lookup_item_type(method.def_id);\n-                        let method_ty = method_ty.ty.subst(self.tcx, &substs);\n+                        let method_ty = method_ty.ty.subst(self.tcx, substs);\n                         return (method_ty, Literal::Item {\n                             def_id: method.def_id,\n-                            substs: self.tcx.mk_substs(substs),\n+                            substs: substs,\n                         });\n                     }\n                 }"}, {"sha": "6c9cf1a5625b2314de47b19ea46ec6c792fbac86", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -299,8 +299,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&rustc::hir::print::ty_to_string(&ty));\n \n-                            if let Some(def_id) = self.tcx\n-                                    .trait_of_item(self.tcx.map.local_def_id(id)) {\n+                            if let Some(def_id) = self.tcx.trait_id_of_impl(impl_id) {\n                                 result.push_str(\" as \");\n                                 result.push_str(&self.tcx.item_path_str(def_id));\n                             }"}, {"sha": "d6866b27f98a56869da645060afa69fb7a84a6ab", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -895,7 +895,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);\n         let args = [lhs_data, lhs_len, rhs_data, rhs_len];\n-        Callee::def(bcx.ccx(), did, bcx.tcx().mk_substs(Substs::empty()))\n+        Callee::def(bcx.ccx(), did, Substs::empty(bcx.tcx()))\n             .call(bcx, debug_loc, ArgVals(&args), None)\n     }\n "}, {"sha": "d48ec98a20dfb3d308a0cfa73507d9569d879269", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -48,7 +48,7 @@ use std;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::attr;\n@@ -544,7 +544,7 @@ impl<'tcx> Case<'tcx> {\n \n fn get_cases<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        adt: ty::AdtDef<'tcx>,\n-                       substs: &subst::Substs<'tcx>)\n+                       substs: &Substs<'tcx>)\n                        -> Vec<Case<'tcx>> {\n     adt.variants.iter().map(|vi| {\n         let field_tys = vi.fields.iter().map(|field| {"}, {"sha": "ee5d1d11fa0a6c7cd1192b7f7b6e7fa55949dba7", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -218,7 +218,7 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Allocate space:\n     let def_id = require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem);\n-    let r = Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n+    let r = Callee::def(bcx.ccx(), def_id, Substs::empty(bcx.tcx()))\n         .call(bcx, debug_loc, ArgVals(&[size, align]), None);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n@@ -670,11 +670,9 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n                                              source_ty: Ty<'tcx>,\n                                              target_ty: Ty<'tcx>)\n                                              -> CustomCoerceUnsized {\n-    let trait_substs = Substs::new_trait(vec![target_ty], vec![], source_ty);\n-\n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n-        substs: scx.tcx().mk_substs(trait_substs)\n+        substs: Substs::new_trait(scx.tcx(), vec![target_ty], vec![], source_ty)\n     });\n \n     match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n@@ -1410,7 +1408,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                 common::validate_substs(instance.substs);\n                 (instance.substs, Some(instance.def), Some(inlined_id))\n             }\n-            None => (ccx.tcx().mk_substs(Substs::empty()), None, None)\n+            None => (Substs::empty(ccx.tcx()), None, None)\n         };\n \n         let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n@@ -2175,7 +2173,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                     Ok(id) => id,\n                     Err(s) => ccx.sess().fatal(&s)\n                 };\n-                let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n+                let empty_substs = Substs::empty(ccx.tcx());\n                 let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx).val;\n                 let args = {\n                     let opaque_rust_main ="}, {"sha": "d50959b5ab3023d9cfaf99bec87929f8580dc6e6", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -22,7 +22,7 @@ use back::symbol_names;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::hir::map as hir_map;\n use abi::{Abi, FnType};\n@@ -105,13 +105,12 @@ impl<'tcx> Callee<'tcx> {\n     /// Function or method definition.\n     pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>,\n                    def_id: DefId,\n-                   substs: &'tcx subst::Substs<'tcx>)\n+                   substs: &'tcx Substs<'tcx>)\n                    -> Callee<'tcx> {\n         let tcx = ccx.tcx();\n \n-        if substs.self_ty().is_some() {\n-            // Only trait methods can have a Self parameter.\n-            return Callee::trait_method(ccx, def_id, substs);\n+        if let Some(trait_id) = tcx.trait_of_item(def_id) {\n+            return Callee::trait_method(ccx, trait_id, def_id, substs);\n         }\n \n         let maybe_node_id = inline::get_local_instance(ccx, def_id)\n@@ -144,24 +143,21 @@ impl<'tcx> Callee<'tcx> {\n \n     /// Trait method, which has to be resolved to an impl method.\n     pub fn trait_method<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                            trait_id: DefId,\n                             def_id: DefId,\n-                            substs: &'tcx subst::Substs<'tcx>)\n+                            substs: &'tcx Substs<'tcx>)\n                             -> Callee<'tcx> {\n         let tcx = ccx.tcx();\n \n-        let method_item = tcx.impl_or_trait_item(def_id);\n-        let trait_id = method_item.container().id();\n-        let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n-        let trait_ref = tcx.normalize_associated_type(&trait_ref);\n+        let trait_ref = ty::TraitRef::from_method(tcx, trait_id, substs);\n+        let trait_ref = tcx.normalize_associated_type(&ty::Binder(trait_ref));\n         match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n                 let impl_did = vtable_impl.impl_def_id;\n                 let mname = tcx.item_name(def_id);\n                 // create a concatenated set of substitutions which includes\n                 // those from the impl and those from the method:\n-                let impl_substs = vtable_impl.substs.with_method_from(&substs);\n-                let substs = tcx.mk_substs(impl_substs);\n-                let mth = meth::get_impl_method(tcx, impl_did, substs, mname);\n+                let mth = meth::get_impl_method(tcx, substs, impl_did, vtable_impl.substs, mname);\n \n                 // Translate the function, bypassing Callee::def.\n                 // That is because default methods have the same ID as the\n@@ -275,7 +271,7 @@ impl<'tcx> Callee<'tcx> {\n /// Given a DefId and some Substs, produces the monomorphic item type.\n fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     def_id: DefId,\n-                    substs: &'tcx subst::Substs<'tcx>)\n+                    substs: &'tcx Substs<'tcx>)\n                     -> Ty<'tcx> {\n     let ty = tcx.lookup_item_type(def_id).ty;\n     monomorphize::apply_param_substs(tcx, substs, &ty)\n@@ -427,7 +423,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n /// - `substs`: values for each of the fn/method's parameters\n fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     def_id: DefId,\n-                    substs: &'tcx subst::Substs<'tcx>)\n+                    substs: &'tcx Substs<'tcx>)\n                     -> Datum<'tcx, Rvalue> {\n     let tcx = ccx.tcx();\n "}, {"sha": "82c86928783bc37a2b29746c0db403e80cc71445", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -732,7 +732,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             create_fn_trans_item(scx.tcx(),\n                                  exchange_free_fn_def_id,\n                                  fn_substs,\n-                                 scx.tcx().mk_substs(Substs::empty()));\n+                                 Substs::empty(scx.tcx()));\n \n         output.push(exchange_free_fn_trans_item);\n     }\n@@ -753,8 +753,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    .drop_trait()\n                                    .unwrap();\n \n-        let self_type_substs = scx.tcx().mk_substs(\n-            Substs::empty().with_self_ty(ty));\n+        let self_type_substs = Substs::new_trait(scx.tcx(), vec![], vec![], ty);\n \n         let trait_ref = ty::TraitRef {\n             def_id: drop_trait_def_id,\n@@ -770,7 +769,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             let trans_item = create_fn_trans_item(scx.tcx(),\n                                                   destructor_did,\n                                                   substs,\n-                                                  scx.tcx().mk_substs(Substs::empty()));\n+                                                  Substs::empty(scx.tcx()));\n             output.push(trans_item);\n         }\n \n@@ -854,26 +853,15 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n            fn_substs,\n            param_substs);\n \n-    let is_trait_method = scx.tcx().trait_of_item(fn_def_id).is_some();\n-\n-    if is_trait_method {\n+    if let Some(trait_def_id) = scx.tcx().trait_of_item(fn_def_id) {\n         match scx.tcx().impl_or_trait_item(fn_def_id) {\n             ty::MethodTraitItem(ref method) => {\n-                match method.container {\n-                    ty::TraitContainer(trait_def_id) => {\n-                        debug!(\" => trait method, attempting to find impl\");\n-                        do_static_trait_method_dispatch(scx,\n-                                                        method,\n-                                                        trait_def_id,\n-                                                        fn_substs,\n-                                                        param_substs)\n-                    }\n-                    ty::ImplContainer(_) => {\n-                        // This is already a concrete implementation\n-                        debug!(\" => impl method\");\n-                        Some((fn_def_id, fn_substs))\n-                    }\n-                }\n+                debug!(\" => trait method, attempting to find impl\");\n+                do_static_trait_method_dispatch(scx,\n+                                                method,\n+                                                trait_def_id,\n+                                                fn_substs,\n+                                                param_substs)\n             }\n             _ => bug!()\n         }\n@@ -903,13 +891,12 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n            callee_substs,\n            param_substs);\n \n+\n     let rcvr_substs = monomorphize::apply_param_substs(tcx,\n                                                        param_substs,\n                                                        &callee_substs);\n-\n-    let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n-    let trait_ref = tcx.normalize_associated_type(&trait_ref);\n-    let vtbl = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -919,10 +906,10 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             substs: impl_substs,\n             nested: _ }) =>\n         {\n-            let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n             let impl_method = meth::get_impl_method(tcx,\n+                                                    rcvr_substs,\n                                                     impl_did,\n-                                                    tcx.mk_substs(callee_substs),\n+                                                    impl_substs,\n                                                     trait_method.name);\n             Some((impl_method.method.def_id, &impl_method.substs))\n         }\n@@ -1076,7 +1063,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                 Some(create_fn_trans_item(scx.tcx(),\n                                     impl_method.method.def_id,\n                                     impl_method.substs,\n-                                    scx.tcx().mk_substs(Substs::empty())))\n+                                    Substs::empty(scx.tcx())))\n                             } else {\n                                 None\n                             }\n@@ -1248,9 +1235,13 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n+                    let impl_substs = Substs::for_item(tcx, impl_def_id,\n+                                                       |_, _| ty::ReErased,\n+                                                       |_, _| tcx.types.err);\n                     let mth = meth::get_impl_method(tcx,\n-                                                    impl_def_id,\n                                                     callee_substs,\n+                                                    impl_def_id,\n+                                                    impl_substs,\n                                                     default_impl.name);\n \n                     assert!(mth.is_provided);"}, {"sha": "b1aaea7d984c9ee4d20b04927b1f04ba8b578ac0", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let tcx = ccx.tcx();\n         match tcx.lang_items.eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(ccx.sess()) => {\n-                Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty())).reify(ccx).val\n+                Callee::def(ccx, def_id, Substs::empty(tcx)).reify(ccx).val\n             }\n             _ => {\n                 if let Some(llpersonality) = ccx.eh_personality().get() {\n@@ -550,7 +550,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let tcx = ccx.tcx();\n         assert!(ccx.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n-            return Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty()));\n+            return Callee::def(ccx, def_id, Substs::empty(tcx));\n         }\n \n         let ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {"}, {"sha": "0e9898896778c0a0b577b5f864694db6c1927493", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -208,7 +208,7 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let arg_ids = args.iter().map(|arg| arg.pat.id);\n     let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n \n-    let substs = ccx.tcx().mk_substs(substs.clone().erase_regions());\n+    let substs = ccx.tcx().erase_regions(&substs);\n     let substs = monomorphize::apply_param_substs(ccx.tcx(),\n                                                   param_substs,\n                                                   &substs);\n@@ -222,7 +222,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> &'tcx hir::Expr {\n     let substs = ccx.tcx().node_id_item_substs(ref_expr.id).substs;\n-    let substs = ccx.tcx().mk_substs(substs.clone().erase_regions());\n+    let substs = ccx.tcx().erase_regions(&substs);\n     let substs = monomorphize::apply_param_substs(ccx.tcx(),\n                                                   param_substs,\n                                                   &substs);\n@@ -271,7 +271,7 @@ fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            param_substs: &'tcx Substs<'tcx>)\n                            -> Result<ValueRef, ConstEvalFailure> {\n     let expr = get_const_expr(ccx, def_id, ref_expr, param_substs);\n-    let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n+    let empty_substs = Substs::empty(ccx.tcx());\n     match get_const_expr_as_global(ccx, expr, ConstQualif::empty(), empty_substs, TrueConst::Yes) {\n         Err(Runtime(err)) => {\n             report_const_eval_err(ccx.tcx(), &err, expr.span, \"expression\").emit();\n@@ -1160,7 +1160,7 @@ pub fn trans_static(ccx: &CrateContext,\n         let v = if use_mir {\n             ::mir::trans_static_initializer(ccx, def_id)\n         } else {\n-            let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n+            let empty_substs = Substs::empty(ccx.tcx());\n             const_expr(ccx, expr, empty_substs, None, TrueConst::Yes)\n                 .map(|(v, _)| v)\n         }.map_err(|e| e.into_inner())?;"}, {"sha": "c31dbf8943e08972e2daee47d320e78d97c74a70", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -30,7 +30,7 @@ use monomorphize::Instance;\n use partitioning::CodegenUnit;\n use trans_item::TransItem;\n use type_::{Type, TypeNames};\n-use rustc::ty::subst::{Substs, VecPerParamSpace};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n use session::Session;\n@@ -571,16 +571,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        let scheme = self.tcx().lookup_item_type(item_def_id);\n-        self.empty_substs_for_scheme(&scheme)\n-    }\n-\n-    pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n-                                   -> &'tcx Substs<'tcx> {\n-        assert!(scheme.generics.types.is_empty());\n-        self.tcx().mk_substs(\n-            Substs::new(VecPerParamSpace::empty(),\n-                        scheme.generics.regions.map(|_| ty::ReErased)))\n+        Substs::for_item(self.tcx(), item_def_id, |_, _| ty::ReErased, |_, _| {\n+            bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n+        })\n     }\n \n     pub fn symbol_hasher(&self) -> &RefCell<Sha256> {\n@@ -999,11 +992,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n         self.shared().empty_substs_for_def_id(item_def_id)\n     }\n-\n-    pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n-                                   -> &'tcx Substs<'tcx> {\n-        self.shared().empty_substs_for_scheme(scheme)\n-    }\n }\n \n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);"}, {"sha": "8b3a8a2bfccfb87d1bff788c10f021dd08314e83", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -401,7 +401,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let expr_file_line = consts::addr_of(ccx, expr_file_line_const, align, \"panic_loc\");\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicFnLangItem);\n-    Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n+    Callee::def(ccx, did, Substs::empty(ccx.tcx()))\n         .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }\n \n@@ -429,6 +429,6 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let file_line = consts::addr_of(ccx, file_line_const, align, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n-    Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n+    Callee::def(ccx, did, Substs::empty(ccx.tcx()))\n         .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }"}, {"sha": "e80dd28c5e502963c6bb054e69870595ef8fea91", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -27,7 +27,7 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::hir::map as hir_map;\n use rustc::hir::{self, PatKind};\n use {type_of, adt, machine, monomorphize};\n@@ -315,7 +315,7 @@ impl<'tcx> TypeMap<'tcx> {\n         fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n                                             cx: &CrateContext<'a, 'tcx>,\n                                             def_id: DefId,\n-                                            substs: &subst::Substs<'tcx>,\n+                                            substs: &Substs<'tcx>,\n                                             output: &mut String) {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n@@ -346,7 +346,7 @@ impl<'tcx> TypeMap<'tcx> {\n             // Add the def-index as the second part\n             output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n \n-            let tps = substs.types.get_slice(subst::TypeSpace);\n+            let tps = substs.types.as_full_slice();\n             if !tps.is_empty() {\n                 output.push('<');\n \n@@ -1086,7 +1086,7 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n     variant: ty::VariantDef<'tcx>,\n-    substs: &'tcx subst::Substs<'tcx>,\n+    substs: &'tcx Substs<'tcx>,\n     is_simd: bool,\n     span: Span,\n }"}, {"sha": "963cc09e1ab9593010552cb8ca03c00a7ee69743", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -266,7 +266,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().lookup_item_type(fn_def_id).generics;\n+    let generics = cx.tcx().lookup_generics(fn_def_id);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n                                                       instance.substs,"}, {"sha": "20dbc8ac78eaf67fa38a0ee738c401634aea3c12", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -12,7 +12,7 @@\n \n use common::CrateContext;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n \n use rustc::hir;\n@@ -173,7 +173,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n     fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                  substs: &subst::Substs<'tcx>,\n+                                  substs: &Substs<'tcx>,\n                                   output: &mut String) {\n         if substs.types.is_empty() {\n             return;"}, {"sha": "beb589c80bfc56f27a2d9f7d1aa74b1e2872aba6", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -175,7 +175,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::ExprPath(..) => {\n                     match bcx.tcx().expect_def(expr.id) {\n                         Def::Const(did) | Def::AssociatedConst(did) => {\n-                            let empty_substs = bcx.tcx().mk_substs(Substs::empty());\n+                            let empty_substs = Substs::empty(bcx.tcx());\n                             let const_expr = consts::get_const_expr(bcx.ccx(), did, expr,\n                                                                     empty_substs);\n                             // Temporarily get cleanup scopes out of the way,"}, {"sha": "080844782f2051c31983602065c5afa43255a448", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -50,7 +50,7 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [PointerCast(bcx, v, Type::i8p(bcx.ccx())), size, align];\n-    Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n+    Callee::def(bcx.ccx(), def_id, Substs::empty(bcx.tcx()))\n         .call(bcx, debug_loc, ArgVals(&args), None).bcx\n }\n \n@@ -356,7 +356,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: tcx.lang_items.drop_trait().unwrap(),\n-        substs: tcx.mk_substs(Substs::empty().with_self_ty(t))\n+        substs: Substs::new_trait(tcx, vec![], vec![], t)\n     });\n     let vtbl = match fulfill_obligation(bcx.ccx().shared(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,"}, {"sha": "133a98a2470f042df0d68e4bd475ba56414b7814", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -15,8 +15,7 @@ use intrinsics::{self, Intrinsic};\n use libc;\n use llvm;\n use llvm::{ValueRef, TypeKind};\n-use rustc::ty::subst;\n-use rustc::ty::subst::FnSpace;\n+use rustc::ty::subst::{FnSpace, Substs};\n use abi::{Abi, FnType};\n use adt;\n use base::*;\n@@ -1284,7 +1283,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     (bcx: Block<'blk, 'tcx>,\n      name: &str,\n-     substs: &'tcx subst::Substs<'tcx>,\n+     substs: &'tcx Substs<'tcx>,\n      callee_ty: Ty<'tcx>,\n      args: Option<&[P<hir::Expr>]>,\n      llargs: &[ValueRef],"}, {"sha": "b051028ebda6b6036f880752e352163c1f6b0c31", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -15,8 +15,7 @@ use arena::TypedArena;\n use back::symbol_names;\n use llvm::{ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::{FnSpace, Subst, Substs};\n-use rustc::ty::subst;\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, Reveal};\n use abi::FnType;\n use base::*;\n@@ -221,20 +220,20 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_id: DefId,\n-                                    substs: &'tcx subst::Substs<'tcx>)\n+                                    substs: &'tcx Substs<'tcx>)\n                                     -> Vec<Option<ImplMethod<'tcx>>>\n {\n     debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n \n-    let trt_id = match tcx.impl_trait_ref(impl_id) {\n+    let trait_id = match tcx.impl_trait_ref(impl_id) {\n         Some(t_id) => t_id.def_id,\n         None       => bug!(\"make_impl_vtable: don't know how to \\\n                             make a vtable for a type impl!\")\n     };\n \n-    tcx.populate_implementations_for_trait_if_necessary(trt_id);\n+    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n-    let trait_item_def_ids = tcx.trait_item_def_ids(trt_id);\n+    let trait_item_def_ids = tcx.trait_item_def_ids(trait_id);\n     trait_item_def_ids\n         .iter()\n \n@@ -260,7 +259,7 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let name = trait_method_type.name;\n \n             // Some methods cannot be called on an object; skip those.\n-            if !tcx.is_vtable_safe_method(trt_id, &trait_method_type) {\n+            if !tcx.is_vtable_safe_method(trait_id, &trait_method_type) {\n                 debug!(\"get_vtable_methods: not vtable safe\");\n                 return None;\n             }\n@@ -270,15 +269,13 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             // the method may have some early-bound lifetimes, add\n             // regions for those\n-            let num_dummy_regions = trait_method_type.generics.regions.len(FnSpace);\n-            let dummy_regions = vec![ty::ReErased; num_dummy_regions];\n-            let method_substs = substs.clone()\n-                                      .with_method(vec![], dummy_regions);\n-            let method_substs = tcx.mk_substs(method_substs);\n+            let method_substs = Substs::for_item(tcx, trait_method_def_id,\n+                                                 |_, _| ty::ReErased,\n+                                                 |_, _| tcx.types.err);\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let mth = get_impl_method(tcx, impl_id, method_substs, name);\n+            let mth = get_impl_method(tcx, method_substs, impl_id, substs, name);\n \n             debug!(\"get_vtable_methods: mth={:?}\", mth);\n \n@@ -309,8 +306,9 @@ pub struct ImplMethod<'tcx> {\n \n /// Locates the applicable definition of a method, given its name.\n pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 impl_def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,\n+                                 impl_def_id: DefId,\n+                                 impl_substs: &'tcx Substs<'tcx>,\n                                  name: Name)\n                                  -> ImplMethod<'tcx>\n {\n@@ -322,6 +320,7 @@ pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n             let substs = tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n                 let substs = traits::translate_substs(&infcx, impl_def_id,\n                                                       substs, node_item.node);\n                 tcx.lift(&substs).unwrap_or_else(|| {"}, {"sha": "4da973bb7f946ec2d5754d27b9aba4c7389857bd", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -232,12 +232,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                  args: IndexVec<mir::Arg, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalFailure> {\n         // Try to resolve associated constants.\n-        if instance.substs.self_ty().is_some() {\n-            // Only trait items can have a Self parameter.\n-            let trait_item = ccx.tcx().impl_or_trait_item(instance.def);\n-            let trait_id = trait_item.container().id();\n-            let substs = instance.substs;\n-            let trait_ref = ty::Binder(substs.to_trait_ref(ccx.tcx(), trait_id));\n+        if let Some(trait_id) = ccx.tcx().trait_of_item(instance.def) {\n+            let trait_ref = ty::TraitRef::new(trait_id, instance.substs);\n+            let trait_ref = ty::Binder(trait_ref);\n             let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);"}, {"sha": "26278e886c29a1704c265f541fec0b9b15a5dfca", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -12,7 +12,6 @@ use llvm::ValueRef;\n use llvm;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n-use rustc::ty::subst;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n use attributes;\n@@ -33,7 +32,7 @@ use trans_item::TransItem;\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n-                                psubsts: &'tcx subst::Substs<'tcx>)\n+                                psubsts: &'tcx Substs<'tcx>)\n                                 -> (ValueRef, Ty<'tcx>) {\n     debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n@@ -174,7 +173,7 @@ pub struct Instance<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[], |_| None)\n+        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[])\n     }\n }\n "}, {"sha": "f24ab0f65578c670972a3447ef3d76c62d1d213d", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -125,6 +125,7 @@ use rustc::hir::map::DefPathData;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n+use rustc::ty::subst;\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher, SipHasher};\n use std::sync::Arc;\n@@ -486,7 +487,8 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // its self-type. If the self-type does not provide a characteristic\n             // DefId, we use the location of the impl after all.\n \n-            if let Some(self_ty) = instance.substs.self_ty() {\n+            if tcx.trait_of_item(instance.def).is_some() {\n+                let self_ty = *instance.substs.types.get(subst::SelfSpace, 0);\n                 // This is an implementation of a trait method.\n                 return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n             }"}, {"sha": "ebd4a80deb9ab93454d2c91a22591f7f7b8c014b", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -28,7 +28,7 @@ use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::subst;\n+use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n@@ -352,8 +352,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             },\n             TransItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::new(def_id,\n-                                             tcx.mk_substs(subst::Substs::empty()));\n+                let instance = Instance::new(def_id, Substs::empty(tcx));\n                 to_string_internal(tcx, \"static \", instance)\n             },\n         };\n@@ -561,7 +560,7 @@ fn push_item_name(tcx: TyCtxt,\n }\n \n fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n+                              types: &'tcx VecPerParamSpace<Ty<'tcx>>,\n                               projections: &[ty::PolyExistentialProjection<'tcx>],\n                               output: &mut String) {\n     if types.is_empty() && projections.is_empty() {"}, {"sha": "7e592d1b74d7c92bbd33e35bfbba5694ca06e9a3", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -11,7 +11,6 @@\n #![allow(non_camel_case_types)]\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst;\n use abi::FnType;\n use adt;\n use common::*;\n@@ -257,7 +256,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n-          let tps = substs.types.get_slice(subst::TypeSpace);\n+          let tps = substs.types.as_full_slice();\n           let name = llvm_type_name(cx, def.did, tps);\n           adt::incomplete_type_of(cx, &repr, &name[..])\n       }\n@@ -336,7 +335,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let tps = substs.types.get_slice(subst::TypeSpace);\n+              let tps = substs.types.as_full_slice();\n               let name = llvm_type_name(cx, def.did, tps);\n               adt::incomplete_type_of(cx, &repr, &name[..])\n           }"}, {"sha": "5655c7c8e7291ee1c00cc7d67215ea575f638812", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -81,6 +81,10 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// A cache used for the result of `ast_ty_to_ty_cache`\n     fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>>;\n \n+    /// Returns the generic type and lifetime parameters for an item.\n+    fn get_generics(&self, span: Span, id: DefId)\n+                    -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>;\n+\n     /// Identify the type scheme for an item with a type, like a type\n     /// alias, fn, or struct. This allows you to figure out the set of\n     /// type parameters defined on the item.\n@@ -348,7 +352,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         rscope: &RegionScope,\n         span: Span,\n         param_mode: PathParamMode,\n-        decl_generics: &ty::Generics<'tcx>,\n+        def_id: DefId,\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n     {\n@@ -362,19 +366,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     .span_label(span, &format!(\"only traits may use parentheses\"))\n                     .emit();\n \n-                return tcx.mk_substs(Substs::from_generics(decl_generics, |_, _| {\n+                return Substs::for_item(tcx, def_id, |_, _| {\n                     ty::ReStatic\n                 }, |_, _| {\n                     tcx.types.err\n-                }));\n+                });\n             }\n         }\n \n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_path(rscope,\n                                             span,\n                                             param_mode,\n-                                            decl_generics,\n+                                            def_id,\n                                             &item_segment.parameters,\n                                             None);\n \n@@ -392,16 +396,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         rscope: &RegionScope,\n         span: Span,\n         param_mode: PathParamMode,\n-        decl_generics: &ty::Generics<'tcx>,\n+        def_id: DefId,\n         parameters: &hir::PathParameters,\n         self_ty: Option<Ty<'tcx>>)\n         -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n         let tcx = self.tcx();\n \n-        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}, \\\n+        debug!(\"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n                parameters={:?})\",\n-               decl_generics, self_ty, parameters);\n+               def_id, self_ty, parameters);\n \n         let (lifetimes, num_types_provided) = match *parameters {\n             hir::AngleBracketedParameters(ref data) => {\n@@ -417,6 +421,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n+        let decl_generics = match self.get_generics(span, def_id) {\n+            Ok(generics) => generics,\n+            Err(ErrorReported) => {\n+                // No convenient way to recover from a cycle here. Just bail. Sorry!\n+                self.tcx().sess.abort_if_errors();\n+                bug!(\"ErrorReported returned, but no errors reports?\")\n+            }\n+        };\n         let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n         let supplied_num_region_params = lifetimes.len();\n         let regions = if expected_num_region_params == supplied_num_region_params {\n@@ -438,7 +450,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         // If a self-type was declared, one should be provided.\n-        assert_eq!(decl_generics.types.get_self().is_some(), self_ty.is_some());\n+        assert_eq!(decl_generics.has_self, self_ty.is_some());\n \n         // Check the number of type parameters supplied by the user.\n         if let Some(num_provided) = num_types_provided {\n@@ -460,7 +472,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let mut output_assoc_binding = None;\n-        let substs = Substs::from_generics(decl_generics, |def, _| {\n+        let substs = Substs::for_item(tcx, def_id, |def, _| {\n             assert_eq!(def.space, TypeSpace);\n             regions[def.index as usize]\n         }, |def, substs| {\n@@ -532,15 +544,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 vec![output_assoc_binding.unwrap_or_else(|| {\n                     // This is an error condition, but we should\n                     // get the associated type binding anyway.\n-                    self.convert_parenthesized_parameters(rscope, &substs, data).1\n+                    self.convert_parenthesized_parameters(rscope, substs, data).1\n                 })]\n             }\n         };\n \n         debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n                decl_generics, self_ty, substs);\n \n-        (tcx.mk_substs(substs), assoc_bindings)\n+        (substs, assoc_bindings)\n     }\n \n     /// Returns the appropriate lifetime to use for any output lifetimes\n@@ -803,7 +815,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self.create_substs_for_ast_path(rscope,\n                                         span,\n                                         param_mode,\n-                                        &trait_def.generics,\n+                                        trait_def_id,\n                                         &trait_segment.parameters,\n                                         Some(self_ty))\n     }\n@@ -910,10 +922,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n-        let (generics, decl_ty) = match self.get_item_type_scheme(span, did) {\n-            Ok(ty::TypeScheme { generics,  ty: decl_ty }) => {\n-                (generics, decl_ty)\n-            }\n+        let decl_ty = match self.get_item_type_scheme(span, did) {\n+            Ok(type_scheme) => type_scheme.ty,\n             Err(ErrorReported) => {\n                 return tcx.types.err;\n             }\n@@ -922,7 +932,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let substs = self.ast_path_substs_for_ty(rscope,\n                                                  span,\n                                                  param_mode,\n-                                                 &generics,\n+                                                 did,\n                                                  item_segment);\n \n         // FIXME(#12938): This is a hack until we have full support for DST.\n@@ -1682,7 +1692,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Create the anonymized type.\n                 let def_id = tcx.map.local_def_id(ast_ty.id);\n                 if let Some(anon_scope) = rscope.anon_type_scope() {\n-                    let substs = anon_scope.fresh_substs(tcx);\n+                    let substs = anon_scope.fresh_substs(self, ast_ty.span);\n                     let ty = tcx.mk_anon(tcx.map.local_def_id(ast_ty.id), substs);\n \n                     // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`."}, {"sha": "af24a7b51176ccca97c67e3f167da966e33a44a4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -547,10 +547,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Type check the path.\n-        let scheme = tcx.lookup_item_type(def.def_id());\n-        let predicates = tcx.lookup_predicates(def.def_id());\n-        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n-                                                 opt_ty, def, pat.span, pat.id);\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         self.demand_suptype(pat.span, expected, pat_ty);\n     }\n \n@@ -607,18 +604,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Type check the path.\n-        let scheme = tcx.lookup_item_type(def.def_id());\n-        let scheme = if scheme.ty.is_fn() {\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n+\n+        let pat_ty = if pat_ty.is_fn() {\n             // Replace constructor type with constructed type for tuple struct patterns.\n-            let fn_ret = tcx.no_late_bound_regions(&scheme.ty.fn_ret()).unwrap();\n-            ty::TypeScheme { ty: fn_ret, generics: scheme.generics }\n+            tcx.no_late_bound_regions(&pat_ty.fn_ret()).unwrap()\n         } else {\n             // Leave the type as is for unit structs (backward compatibility).\n-            scheme\n+            pat_ty\n         };\n-        let predicates = tcx.lookup_predicates(def.def_id());\n-        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n-                                                 opt_ty, def, pat.span, pat.id);\n+        self.write_ty(pat.id, pat_ty);\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns."}, {"sha": "9a3cbabe553314fd77bf3719a3686c8aba61bc62", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                 Some(f) => f,\n                 None => return None\n             },\n-            substs: tcx.mk_substs(Substs::new_trait(vec![], vec![], self.cur_ty))\n+            substs: Substs::new_trait(tcx, vec![], vec![], self.cur_ty)\n         };\n \n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);"}, {"sha": "3cb528eba63e0a4f44fe0a2d7c8734144927781d", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -194,10 +194,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs =\n-        trait_to_impl_substs\n-        .subst(tcx, impl_to_skol_substs).clone()\n-        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n-                     impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n+        impl_to_skol_substs.rebase_onto(tcx, impl_m.container_id(),\n+                                        trait_to_impl_substs.subst(tcx, impl_to_skol_substs));\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n@@ -208,7 +206,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            impl_m,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n-                                           &trait_to_skol_substs,\n+                                           trait_to_skol_substs,\n                                            impl_to_skol_substs) {\n         return;\n     }\n@@ -226,7 +224,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         // Normalize the associated types in the trait_bounds.\n-        let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n+        let trait_bounds = trait_m.predicates.instantiate(tcx, trait_to_skol_substs);\n \n         // Create obligations for each predicate declared by the impl\n         // definition in the context of the trait's parameter\n@@ -323,7 +321,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             infcx.parameter_environment.free_id_outlive,\n             &trait_m.fty.sig);\n         let trait_sig =\n-            trait_sig.subst(tcx, &trait_to_skol_substs);\n+            trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n             assoc::normalize_associated_types_in(&infcx,\n                                                  &mut fulfillment_cx,\n@@ -454,16 +452,14 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         // Create mapping from trait to skolemized.\n         let trait_to_skol_substs =\n-            trait_to_impl_substs\n-            .subst(tcx, impl_to_skol_substs).clone()\n-            .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n-                         impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n+            impl_to_skol_substs.rebase_onto(tcx, impl_c.container.id(),\n+                                            trait_to_impl_substs.subst(tcx, impl_to_skol_substs));\n         debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n             trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n         let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n-        let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n+        let trait_ty = trait_c.ty.subst(tcx, trait_to_skol_substs);\n         let mut origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {"}, {"sha": "7d79fc4fbf8782ba5e5369fe18ef82f7e95591d8", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use rustc::infer;\n use middle::region;\n-use rustc::ty::subst::{self, Subst};\n+use rustc::ty::subst::{self, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n use util::nodemap::FnvHashSet;\n@@ -41,16 +41,14 @@ use syntax_pos::{self, Span};\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n-    let ty::TypeScheme { generics: ref dtor_generics,\n-                         ty: dtor_self_type } = ccx.tcx.lookup_item_type(drop_impl_did);\n+    let dtor_self_type = ccx.tcx.lookup_item_type(drop_impl_did).ty;\n     let dtor_predicates = ccx.tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(adt_def, self_to_impl_substs) |\n         ty::TyStruct(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(ccx,\n                                                           drop_impl_did,\n-                                                          dtor_generics,\n-                                                          &dtor_self_type,\n+                                                          dtor_self_type,\n                                                           adt_def.did)?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(ccx,\n@@ -73,8 +71,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n     drop_impl_did: DefId,\n-    drop_impl_generics: &ty::Generics<'tcx>,\n-    drop_impl_ty: &ty::Ty<'tcx>,\n+    drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId) -> Result<(), ()>\n {\n     let tcx = ccx.tcx;\n@@ -93,8 +90,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n         let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n         let fresh_impl_substs =\n-            infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n-        let fresh_impl_self_ty = drop_impl_ty.subst(tcx, &fresh_impl_substs);\n+            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n+        let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         if let Err(_) = infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n                                        named_type, fresh_impl_self_ty) {\n@@ -131,7 +128,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n-    self_to_impl_substs: &subst::Substs<'tcx>) -> Result<(), ()> {\n+    self_to_impl_substs: &Substs<'tcx>) -> Result<(), ()> {\n \n     // Here is an example, analogous to that from\n     // `compare_impl_method`."}, {"sha": "bfedb4fa6e1a09a170d98b45ff52a9561e05250e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -36,11 +36,11 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let def_id = tcx.map.local_def_id(it.id);\n     let i_ty = tcx.lookup_item_type(def_id);\n \n-    let mut substs = Substs::empty();\n-    substs.types = i_ty.generics.types.map(|def| tcx.mk_param_from_def(def));\n+    let substs = Substs::for_item(tcx, def_id,\n+                                  |_, _| ty::ReErased,\n+                                  |def, _| tcx.mk_param_from_def(def));\n \n-    let fty = tcx.mk_fn_def(def_id, tcx.mk_substs(substs),\n-                            tcx.mk_bare_fn(ty::BareFnTy {\n+    let fty = tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: abi,\n         sig: ty::Binder(FnSig {"}, {"sha": "c071fce98965f2885929b99b6e40d6cf5765a9bb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -12,7 +12,7 @@ use super::probe;\n \n use check::{FnCtxt, callee};\n use hir::def_id::DefId;\n-use rustc::ty::subst::{self};\n+use rustc::ty::subst::{self, Substs};\n use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n@@ -42,10 +42,6 @@ struct InstantiatedMethodSig<'tcx> {\n     /// argument is the receiver.\n     method_sig: ty::FnSig<'tcx>,\n \n-    /// Substitutions for all types/early-bound-regions declared on\n-    /// the method.\n-    all_substs: subst::Substs<'tcx>,\n-\n     /// Generic bounds on the method's parameters which must be added\n     /// as pending obligations.\n     method_predicates: ty::InstantiatedPredicates<'tcx>,\n@@ -105,9 +101,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n-            method_sig, all_substs, method_predicates\n+            method_sig, method_predicates\n         } = self.instantiate_method_sig(&pick, all_substs);\n-        let all_substs = self.tcx.mk_substs(all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n@@ -198,7 +193,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn fresh_receiver_substs(&mut self,\n                              self_ty: Ty<'tcx>,\n                              pick: &probe::Pick<'tcx>)\n-                             -> &'tcx subst::Substs<'tcx>\n+                             -> &'tcx Substs<'tcx>\n     {\n         match pick.kind {\n             probe::InherentImplPick => {\n@@ -256,16 +251,13 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n             probe::TraitPick => {\n                 let trait_def_id = pick.item.container().id();\n-                let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n                 // consisting entirely of type variables. Later on in\n                 // the process we will unify the transformed-self-type\n                 // of the method with the actual type in order to\n                 // unify some of these variables.\n-                self.fresh_substs_for_trait(self.span,\n-                                            &trait_def.generics,\n-                                            self.next_ty_var())\n+                self.fresh_substs_for_item(self.span, trait_def_id)\n             }\n \n             probe::WhereClausePick(ref poly_trait_ref) => {\n@@ -308,8 +300,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_substs(&mut self,\n                                  pick: &probe::Pick<'tcx>,\n                                  mut supplied_method_types: Vec<Ty<'tcx>>,\n-                                 substs: &subst::Substs<'tcx>)\n-                                 -> subst::Substs<'tcx>\n+                                 substs: &Substs<'tcx>)\n+                                 -> &'tcx Substs<'tcx>\n     {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -335,7 +327,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n-        subst::Substs::from_generics(&method.generics, |def, _| {\n+        Substs::for_item(self.tcx, method.def_id, |def, _| {\n             if def.space != subst::FnSpace {\n                 substs.region_for_def(def)\n             } else {\n@@ -376,7 +368,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick<'tcx>,\n-                              all_substs: subst::Substs<'tcx>)\n+                              all_substs: &'tcx Substs<'tcx>)\n                               -> InstantiatedMethodSig<'tcx>\n     {\n         debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n@@ -387,7 +379,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n         let method_predicates = pick.item.as_opt_method().unwrap()\n-                                    .predicates.instantiate(self.tcx, &all_substs);\n+                                    .predicates.instantiate(self.tcx, all_substs);\n         let method_predicates = self.normalize_associated_types_in(self.span,\n                                                                    &method_predicates);\n \n@@ -405,20 +397,19 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n                method_sig);\n \n-        let method_sig = self.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n+        let method_sig = self.instantiate_type_scheme(self.span, all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={:?}\",\n                method_sig);\n \n         InstantiatedMethodSig {\n             method_sig: method_sig,\n-            all_substs: all_substs,\n             method_predicates: method_predicates,\n         }\n     }\n \n     fn add_obligations(&mut self,\n                        fty: Ty<'tcx>,\n-                       all_substs: &subst::Substs<'tcx>,\n+                       all_substs: &Substs<'tcx>,\n                        method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n         debug!(\"add_obligations: fty={:?} all_substs={:?} method_predicates={:?}\",\n                fty,"}, {"sha": "e5107af6ca04b8a01a525015c9128f01d03641d6", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -13,7 +13,7 @@\n use check::FnCtxt;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use rustc::ty::subst;\n+use rustc::ty::subst::{self, Substs};\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n@@ -189,7 +189,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(trait_def.generics.regions.is_empty());\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let substs = subst::Substs::from_generics(&trait_def.generics, |def, _| {\n+        let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, substs| {\n             if def.space == subst::SelfSpace {\n@@ -201,7 +201,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        let trait_ref = ty::TraitRef::new(trait_def_id, self.tcx.mk_substs(substs));\n+        let trait_ref = ty::TraitRef::new(trait_def_id, substs);\n \n         // Construct an obligation\n         let poly_trait_ref = trait_ref.to_poly_trait_ref();"}, {"sha": "448ea243655a809643df9adcd0ddeccc809a3812", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -16,8 +16,7 @@ use super::suggest;\n use check::{FnCtxt};\n use hir::def_id::DefId;\n use hir::def::Def;\n-use rustc::ty::subst;\n-use rustc::ty::subst::Subst;\n+use rustc::ty::subst::{self, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n@@ -80,9 +79,9 @@ struct Candidate<'tcx> {\n \n #[derive(Debug)]\n enum CandidateKind<'tcx> {\n-    InherentImplCandidate(subst::Substs<'tcx>,\n+    InherentImplCandidate(&'tcx Substs<'tcx>,\n                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n-    ExtensionImplCandidate(/* Impl */ DefId, subst::Substs<'tcx>,\n+    ExtensionImplCandidate(/* Impl */ DefId, &'tcx Substs<'tcx>,\n                            /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n     ObjectCandidate,\n     TraitCandidate,\n@@ -421,10 +420,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n \n         let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-        let impl_ty = impl_ty.subst(self.tcx, &impl_substs);\n+        let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n         // Determine the receiver type that the method itself expects.\n-        let xform_self_ty = self.xform_self_ty(&item, impl_ty, &impl_substs);\n+        let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n \n         // We can't use normalize_associated_types_in as it will pollute the\n         // fcx's fulfillment context after this probe is over.\n@@ -519,14 +518,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        trait_ref,\n                        trait_ref.substs,\n                        m);\n-                assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                           trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n-                assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                           trait_ref.substs.regions.get_slice(subst::TypeSpace).len());\n-                assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                           trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n-                assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                           trait_ref.substs.regions.get_slice(subst::SelfSpace).len());\n+                assert_eq!(m.generics.types.len(subst::TypeSpace),\n+                           trait_ref.substs.types.len(subst::TypeSpace));\n+                assert_eq!(m.generics.regions.len(subst::TypeSpace),\n+                           trait_ref.substs.regions.len(subst::TypeSpace));\n+                assert_eq!(m.generics.types.len(subst::SelfSpace),\n+                           trait_ref.substs.types.len(subst::SelfSpace));\n+                assert_eq!(m.generics.regions.len(subst::SelfSpace),\n+                           trait_ref.substs.regions.len(subst::SelfSpace));\n             }\n \n             // Because this trait derives from a where-clause, it\n@@ -665,7 +664,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let impl_trait_ref =\n                 self.tcx.impl_trait_ref(impl_def_id)\n                 .unwrap() // we know this is a trait impl\n-                .subst(self.tcx, &impl_substs);\n+                .subst(self.tcx, impl_substs);\n \n             debug!(\"impl_trait_ref={:?}\", impl_trait_ref);\n \n@@ -753,14 +752,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // for the purposes of our method lookup, we only take\n             // receiver type into account, so we can just substitute\n             // fresh types here to use during substitution and subtyping.\n-            let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n-            let substs = self.fresh_substs_for_trait(self.span,\n-                                                     &trait_def.generics,\n-                                                     step.self_ty);\n+            let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n+                self.region_var_for_def(self.span, def)\n+            }, |def, substs| {\n+                if def.space == subst::SelfSpace {\n+                    assert_eq!(def.index, 0);\n+                    step.self_ty\n+                } else {\n+                    assert_eq!(def.space, subst::TypeSpace);\n+                    self.type_var_for_def(self.span, def, substs)\n+                }\n+            });\n \n             let xform_self_ty = self.xform_self_ty(&item,\n                                                    step.self_ty,\n-                                                   &substs);\n+                                                   substs);\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n@@ -1192,7 +1198,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn xform_self_ty(&self,\n                      item: &ty::ImplOrTraitItem<'tcx>,\n                      impl_ty: Ty<'tcx>,\n-                     substs: &subst::Substs<'tcx>)\n+                     substs: &Substs<'tcx>)\n                      -> Ty<'tcx>\n     {\n         match item.as_opt_method() {\n@@ -1205,7 +1211,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn xform_method_self_ty(&self,\n                             method: &Rc<ty::Method<'tcx>>,\n                             impl_ty: Ty<'tcx>,\n-                            substs: &subst::Substs<'tcx>)\n+                            substs: &Substs<'tcx>)\n                             -> Ty<'tcx>\n     {\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n@@ -1236,7 +1242,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n            method.generics.regions.is_empty_in(subst::FnSpace) {\n             xform_self_ty.subst(self.tcx, substs)\n         } else {\n-            let substs = subst::Substs::from_generics(&method.generics, |def, _| {\n+            let substs = Substs::for_item(self.tcx, method.def_id, |def, _| {\n                 if def.space != subst::FnSpace {\n                     substs.region_for_def(def)\n                 } else {\n@@ -1251,14 +1257,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     self.type_var_for_def(self.span, def, cur_substs)\n                 }\n             });\n-            xform_self_ty.subst(self.tcx, &substs)\n+            xform_self_ty.subst(self.tcx, substs)\n         }\n     }\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self,\n                           impl_def_id: DefId)\n-                          -> (Ty<'tcx>, subst::Substs<'tcx>)\n+                          -> (Ty<'tcx>, &'tcx Substs<'tcx>)\n     {\n         let impl_pty = self.tcx.lookup_item_type(impl_def_id);\n \n@@ -1270,8 +1276,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             impl_pty.generics.regions.map(\n                 |_| ty::ReErased); // see erase_late_bound_regions() for an expl of why 'erased\n \n-        let substs = subst::Substs::new(type_vars, region_placeholders);\n-        (impl_pty.ty, substs)\n+        (impl_pty.ty, Substs::new(self.tcx, type_vars, region_placeholders))\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using"}, {"sha": "573dae46456baa2f3b78146e3bab014e63112671", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -54,10 +54,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.autoderef(span, ty).any(|(ty, _)| self.probe(|_| {\n                     let fn_once_substs =\n-                        Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n-                    let trait_ref =\n-                        ty::TraitRef::new(fn_once,\n-                                          tcx.mk_substs(fn_once_substs));\n+                        Substs::new_trait(tcx, vec![self.next_ty_var()], vec![], ty);\n+                    let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                     let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                     let obligation = Obligation::misc(span,\n                                                       self.body_id,"}, {"sha": "700fb2ecf42dd534d0e5705cf3bd549e5d25cec2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 46, "deletions": 74, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -90,7 +90,6 @@ use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n use rustc::ty::subst::{self, Subst, Substs};\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n@@ -745,26 +744,20 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n           match ccx.tcx.impl_trait_ref(impl_def_id) {\n               Some(impl_trait_ref) => {\n-                  let trait_def_id = impl_trait_ref.def_id;\n-\n                   check_impl_items_against_trait(ccx,\n                                                  it.span,\n                                                  impl_def_id,\n                                                  &impl_trait_ref,\n                                                  impl_items);\n-                  check_on_unimplemented(\n-                      ccx,\n-                      &ccx.tcx.lookup_trait_def(trait_def_id).generics,\n-                      it,\n-                      ccx.tcx.item_name(trait_def_id));\n+                  let trait_def_id = impl_trait_ref.def_id;\n+                  check_on_unimplemented(ccx, trait_def_id, it);\n               }\n               None => { }\n           }\n       }\n       hir::ItemTrait(..) => {\n         let def_id = ccx.tcx.map.local_def_id(it.id);\n-        let generics = &ccx.tcx.lookup_trait_def(def_id).generics;\n-        check_on_unimplemented(ccx, generics, it, it.name);\n+        check_on_unimplemented(ccx, def_id, it);\n       }\n       hir::ItemStruct(..) => {\n         check_struct(ccx, it.id, it.span);\n@@ -872,9 +865,9 @@ fn check_trait_fn_not_const<'a,'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                    generics: &ty::Generics,\n-                                    item: &hir::Item,\n-                                    name: ast::Name) {\n+                                    def_id: DefId,\n+                                    item: &hir::Item) {\n+    let generics = ccx.tcx.lookup_generics(def_id);\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n@@ -894,6 +887,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }) {\n                             Some(_) => (),\n                             None => {\n+                                let name = ccx.tcx.item_name(def_id);\n                                 span_err!(ccx.tcx.sess, attr.span, E0230,\n                                                  \"there is no type parameter \\\n                                                           {} on trait {}\",\n@@ -1301,6 +1295,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         &self.ast_ty_to_ty_cache\n     }\n \n+    fn get_generics(&self, _: Span, id: DefId)\n+                    -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>\n+    {\n+        Ok(self.tcx().lookup_generics(id))\n+    }\n+\n     fn get_item_type_scheme(&self, _: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n@@ -1364,7 +1364,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn ty_infer_for_def(&self,\n                         ty_param_def: &ty::TypeParameterDef<'tcx>,\n-                        substs: &subst::Substs<'tcx>,\n+                        substs: &Substs<'tcx>,\n                         span: Span) -> Ty<'tcx> {\n         self.type_var_for_def(span, ty_param_def, substs)\n     }\n@@ -1690,25 +1690,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  node_id: ast::NodeId)\n                                  -> Ty<'tcx> {\n         debug!(\"instantiate_type_path(did={:?}, path={:?})\", did, path);\n-        let mut type_scheme = self.tcx.lookup_item_type(did);\n-        if type_scheme.ty.is_fn() {\n+        let mut ty = self.tcx.lookup_item_type(did).ty;\n+        if ty.is_fn() {\n             // Tuple variants have fn type even in type namespace, extract true variant type from it\n-            let fn_ret = self.tcx.no_late_bound_regions(&type_scheme.ty.fn_ret()).unwrap();\n-            type_scheme = ty::TypeScheme { ty: fn_ret, generics: type_scheme.generics }\n+            ty = self.tcx.no_late_bound_regions(&type_scheme.ty.fn_ret()).unwrap();\n         }\n         let type_predicates = self.tcx.lookup_predicates(did);\n         let substs = AstConv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n                                                      PathParamMode::Optional,\n-                                                     &type_scheme.generics,\n+                                                     did,\n                                                      path.segments.last().unwrap());\n-        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", &type_scheme.ty, substs);\n+        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", ty, substs);\n         let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n         let cause = traits::ObligationCause::new(path.span, self.body_id,\n                                                  traits::ItemObligation(did));\n         self.add_obligations_for_parameters(cause, &bounds);\n \n-        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &type_scheme.ty);\n+        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &ty);\n         self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n@@ -2775,7 +2774,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let ity = self.tcx.lookup_item_type(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n-        let substs = self.fresh_substs_for_generics(span, &ity.generics);\n+        let substs = self.fresh_substs_for_item(span, did);\n         let substd_ty = self.instantiate_type_scheme(span, &substs, &ity.ty);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n@@ -3443,10 +3442,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n                                                                          expr.id, expr.span);\n               if def != Def::Err {\n-                  let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n-                                                                                     def);\n-                  self.instantiate_value_path(segments, scheme, &predicates,\n-                                              opt_ty, def, expr.span, id);\n+                  self.instantiate_value_path(segments, opt_ty, def, expr.span, id);\n               } else {\n                   self.set_tainted_by_errors();\n                   self.write_error(id);\n@@ -4036,54 +4032,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         *self.ps.borrow_mut() = prev;\n     }\n \n-    // Returns the type parameter count and the type for the given definition.\n-    fn type_scheme_and_predicates_for_def(&self,\n-                                          sp: Span,\n-                                          defn: Def)\n-                                          -> (TypeScheme<'tcx>, GenericPredicates<'tcx>) {\n-        match defn {\n-            Def::Local(_, nid) | Def::Upvar(_, nid, _, _) => {\n-                let typ = self.local_ty(sp, nid);\n-                (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n-                 ty::GenericPredicates::empty())\n-            }\n-            Def::Fn(id) | Def::Method(id) |\n-            Def::Static(id, _) | Def::Variant(_, id) |\n-            Def::Struct(id) | Def::Const(id) | Def::AssociatedConst(id) => {\n-                (self.tcx.lookup_item_type(id), self.tcx.lookup_predicates(id))\n-            }\n-            Def::Trait(_) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n-            Def::PrimTy(_) |\n-            Def::TyParam(..) |\n-            Def::Mod(..) |\n-            Def::ForeignMod(..) |\n-            Def::Label(..) |\n-            Def::SelfTy(..) |\n-            Def::Err => {\n-                span_bug!(sp, \"expected value, found {:?}\", defn);\n-            }\n-        }\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n                                   segments: &[hir::PathSegment],\n-                                  type_scheme: TypeScheme<'tcx>,\n-                                  type_predicates: &ty::GenericPredicates<'tcx>,\n                                   opt_self_ty: Option<Ty<'tcx>>,\n                                   def: Def,\n                                   span: Span,\n                                   node_id: ast::NodeId)\n                                   -> Ty<'tcx> {\n-        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n+        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={})\",\n                segments,\n                def,\n-               node_id,\n-               type_scheme);\n+               node_id);\n \n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n@@ -4210,11 +4171,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::ForeignMod(..) |\n             Def::Local(..) |\n             Def::Label(..) |\n-            Def::Upvar(..) => {}\n-\n-            Def::Err => {\n-                self.set_tainted_by_errors();\n-            }\n+            Def::Upvar(..) |\n+            Def::Err => {}\n         }\n \n         // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but\n@@ -4232,6 +4190,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             fn_segment.is_some() as usize;\n         self.tcx.prohibit_type_params(&segments[..segments.len() - poly_segments]);\n \n+        match def {\n+            Def::Local(_, nid) | Def::Upvar(_, nid, _, _) => {\n+                let ty = self.local_ty(span, nid);\n+                let ty = self.normalize_associated_types_in(span, &ty);\n+                self.write_ty(node_id, ty);\n+                self.write_substs(node_id, ty::ItemSubsts {\n+                    substs: Substs::empty(self.tcx)\n+                });\n+                return ty;\n+            }\n+            _ => {}\n+        }\n+        let scheme = self.tcx.lookup_item_type(def.def_id());\n+        let type_predicates = self.tcx.lookup_predicates(def.def_id());\n+\n         // Now we have to compare the types that the user *actually*\n         // provided against the types that were *expected*. If the user\n         // did not provide any types, then we want to substitute inference\n@@ -4240,16 +4213,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // a problem.\n         self.check_path_parameter_count(subst::TypeSpace,\n                                         span,\n-                                        &type_scheme.generics,\n+                                        scheme.generics,\n                                         !require_type_space,\n                                         &mut type_segment);\n         self.check_path_parameter_count(subst::FnSpace,\n                                         span,\n-                                        &type_scheme.generics,\n+                                        scheme.generics,\n                                         true,\n                                         &mut fn_segment);\n \n-        let substs = Substs::from_generics(&type_scheme.generics, |def, _| {\n+        let substs = Substs::for_item(self.tcx, def.def_id(), |def, _| {\n             let i = def.index as usize;\n             let segment = match def.space {\n                 subst::SelfSpace => None,\n@@ -4307,9 +4280,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n-        let substs = self.tcx.mk_substs(substs);\n         assert!(!substs.has_escaping_regions());\n-        assert!(!type_scheme.has_escaping_regions());\n+        assert!(!scheme.ty.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n@@ -4320,7 +4292,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Substitute the values for the type parameters into the type of\n         // the referenced item.\n-        let ty_substituted = self.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n+        let ty_substituted = self.instantiate_type_scheme(span, &substs, &scheme.ty);\n \n \n         if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {"}, {"sha": "6a475864f3b7d8bbb74476ca69e91559c86ecaaf", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -18,7 +18,6 @@ use hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n-use rustc::ty::subst::ParamSpace;\n use rustc::infer::{InferCtxt, FixupError};\n use rustc::util::nodemap::DefIdMap;\n use write_substs_to_tcx;\n@@ -68,7 +67,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_anon_types();\n+        wbcx.visit_anon_types(item_id);\n         wbcx.visit_deferred_obligations(item_id);\n     }\n }\n@@ -104,22 +103,20 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n \n         let free_substs = fcx.parameter_environment.free_substs;\n-        for &space in &ParamSpace::all() {\n-            for (i, r) in free_substs.regions.get_slice(space).iter().enumerate() {\n-                match *r {\n-                    ty::ReFree(ty::FreeRegion {\n-                        bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n-                    }) => {\n-                        let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                            space: space,\n-                            index: i as u32,\n-                            name: name,\n-                        });\n-                        wbcx.free_to_bound_regions.insert(def_id, bound_region);\n-                    }\n-                    _ => {\n-                        bug!(\"{:?} is not a free region for an early-bound lifetime\", r);\n-                    }\n+        for (space, i, r) in free_substs.regions.iter_enumerated() {\n+            match *r {\n+                ty::ReFree(ty::FreeRegion {\n+                    bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n+                }) => {\n+                    let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                        space: space,\n+                        index: i as u32,\n+                        name: name,\n+                    });\n+                    wbcx.free_to_bound_regions.insert(def_id, bound_region);\n+                }\n+                _ => {\n+                    bug!(\"{:?} is not a free region for an early-bound lifetime\", r);\n                 }\n             }\n         }\n@@ -300,11 +297,13 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_anon_types(&self) {\n+    fn visit_anon_types(&self, item_id: ast::NodeId) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n+        let item_def_id = self.fcx.tcx.map.local_def_id(item_id);\n+\n         let gcx = self.tcx().global_tcx();\n         for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n             let reason = ResolvingAnonTy(def_id);\n@@ -345,9 +344,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.tcache.borrow_mut().insert(def_id, ty::TypeScheme {\n+            gcx.register_item_type(def_id, ty::TypeScheme {\n                 ty: outside_ty,\n-                generics: ty::Generics::empty()\n+                generics: gcx.lookup_generics(item_def_id)\n             });\n         }\n     }"}, {"sha": "77723ea973341a1ff909ce121c3e50f779694a26", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 308, "deletions": 354, "changes": 662, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -65,7 +65,7 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n-use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace};\n+use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::{VariantKind};\n@@ -120,6 +120,7 @@ struct ItemCtxt<'a,'tcx:'a> {\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum AstConvRequest {\n+    GetGenerics(DefId),\n     GetItemTypeScheme(DefId),\n     GetTraitDef(DefId),\n     EnsureSuperPredicates(DefId),\n@@ -187,6 +188,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         err.span_label(span, &format!(\"cyclic reference\"));\n \n         match cycle[0] {\n+            AstConvRequest::GetGenerics(def_id) |\n             AstConvRequest::GetItemTypeScheme(def_id) |\n             AstConvRequest::GetTraitDef(def_id) => {\n                 err.note(\n@@ -209,6 +211,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n         for request in &cycle[1..] {\n             match *request {\n+                AstConvRequest::GetGenerics(def_id) |\n                 AstConvRequest::GetItemTypeScheme(def_id) |\n                 AstConvRequest::GetTraitDef(def_id) => {\n                     err.note(\n@@ -231,6 +234,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         }\n \n         match cycle[0] {\n+            AstConvRequest::GetGenerics(def_id) |\n             AstConvRequest::GetItemTypeScheme(def_id) |\n             AstConvRequest::GetTraitDef(def_id) => {\n                 err.note(\n@@ -303,6 +307,14 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         &self.ccx.ast_ty_to_ty_cache\n     }\n \n+    fn get_generics(&self, span: Span, id: DefId)\n+                    -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>\n+    {\n+        self.ccx.cycle_check(span, AstConvRequest::GetGenerics(id), || {\n+            Ok(generics_of_def_id(self.ccx, id))\n+        })\n+    }\n+\n     fn get_item_type_scheme(&self, span: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n@@ -544,7 +556,6 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-\n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             name: ast::Name,\n@@ -553,25 +564,22 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             sig: &hir::MethodSig,\n                             defaultness: hir::Defaultness,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n-                            rcvr_ty_generics: &ty::Generics<'tcx>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n-    let ty_generics = ty_generics_for_fn(ccx, &sig.generics, rcvr_ty_generics);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    let ty_generics = generics_of_def_id(ccx, def_id);\n \n     let ty_generic_predicates =\n         ty_generic_predicates_for_fn(ccx, &sig.generics, rcvr_ty_predicates);\n \n     let (fty, explicit_self_category) = {\n         let anon_scope = match container {\n-            ImplContainer(_) => Some(AnonTypeScope::new(&ty_generics)),\n+            ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n             TraitContainer(_) => None\n         };\n         AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                               sig, untransformed_rcvr_ty, anon_scope)\n     };\n \n-    let def_id = ccx.tcx.map.local_def_id(id);\n-    let substs = mk_item_substs(ccx.tcx, &ty_generics);\n-\n     let ty_method = ty::Method::new(name,\n                                     ty_generics,\n                                     ty_generic_predicates,\n@@ -582,16 +590,14 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def_id,\n                                     container);\n \n+    let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                ccx.tcx.map.span(id), def_id);\n     let fty = ccx.tcx.mk_fn_def(def_id, substs, ty_method.fty);\n     debug!(\"method {} (id {}) has type {:?}\",\n             name, id, fty);\n-    ccx.tcx.register_item_type(def_id, TypeScheme {\n-        generics: ty_method.generics.clone(),\n-        ty: fty\n-    });\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n-\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, fty);\n     write_ty_to_tcx(ccx, id, fty);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n \n     debug!(\"writing method type: def_id={:?} mty={:?}\",\n             def_id, ty_method);\n@@ -601,7 +607,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                           struct_generics: &ty::Generics<'tcx>,\n+                           struct_generics: &'tcx ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n                            field: &hir::StructField,\n                            ty_f: ty::FieldDefMaster<'tcx>)\n@@ -613,7 +619,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     /* add the field to the tcache */\n     ccx.tcx.register_item_type(ccx.tcx.map.local_def_id(field.id),\n                                ty::TypeScheme {\n-                                   generics: struct_generics.clone(),\n+                                   generics: struct_generics,\n                                    ty: tt\n                                });\n     ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(field.id),\n@@ -709,8 +715,9 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n-            let (scheme, predicates) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(ccx, it.id, scheme.ty);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            let scheme = type_scheme_of_def_id(ccx, def_id);\n+            let predicates = predicates_of_item(ccx, it);\n             convert_enum_variant_types(ccx,\n                                        tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n                                        scheme,\n@@ -737,7 +744,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let ty_generics = ty_generics_for_impl(ccx, generics);\n+            let ty_generics = generics_of_def_id(ccx, def_id);\n             let mut ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n@@ -746,7 +753,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             write_ty_to_tcx(ccx, it.id, selfty);\n \n             tcx.register_item_type(def_id,\n-                                   TypeScheme { generics: ty_generics.clone(),\n+                                   TypeScheme { generics: ty_generics,\n                                                 ty: selfty });\n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n@@ -791,7 +798,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                 .to_ty(&ExplicitRscope, &ty);\n                     tcx.register_item_type(ccx.tcx.map.local_def_id(impl_item.id),\n                                            TypeScheme {\n-                                               generics: ty_generics.clone(),\n+                                               generics: ty_generics,\n                                                ty: ty,\n                                            });\n                     // Trait-associated constants are always public.\n@@ -829,7 +836,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n-                                   sig, impl_item.defaultness, selfty, &ty_generics,\n+                                   sig, impl_item.defaultness, selfty,\n                                    &ty_predicates);\n                 }\n             }\n@@ -856,7 +863,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                         .to_ty(&ExplicitRscope, ty);\n                     tcx.register_item_type(ccx.tcx.map.local_def_id(trait_item.id),\n                                            TypeScheme {\n-                                               generics: trait_def.generics.clone(),\n+                                               generics: trait_def.generics,\n                                                ty: ty,\n                                            });\n                     convert_associated_const(ccx,\n@@ -898,7 +905,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                    sig,\n                                    hir::Defaultness::Default,\n                                    tcx.mk_self_type(),\n-                                   &trait_def.generics,\n                                    &trait_predicates);\n \n                 }\n@@ -917,11 +923,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                        trait_item_def_ids);\n         },\n         hir::ItemStruct(ref struct_def, _) => {\n-            let (scheme, predicates) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(ccx, it.id, scheme.ty);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            let scheme = type_scheme_of_def_id(ccx, def_id);\n+            let predicates = predicates_of_item(ccx, it);\n \n-            let it_def_id = ccx.tcx.map.local_def_id(it.id);\n-            let variant = tcx.lookup_adt_def_master(it_def_id).struct_variant();\n+            let variant = tcx.lookup_adt_def_master(def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n                 convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n@@ -933,15 +939,14 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            let (scheme, _) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(ccx, it.id, scheme.ty);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            type_scheme_of_def_id(ccx, def_id);\n+            predicates_of_item(ccx, it);\n         },\n         _ => {\n-            // This call populates the type cache with the converted type\n-            // of the item in passing. All we have to do here is to write\n-            // it into the node type table.\n-            let (scheme, _) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(ccx, it.id, scheme.ty);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            type_scheme_of_def_id(ccx, def_id);\n+            predicates_of_item(ccx, it);\n         },\n     }\n }\n@@ -952,6 +957,8 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   scheme: ty::TypeScheme<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n+    let def_id = tcx.map.local_def_id(ctor_id);\n+    tcx.generics.borrow_mut().insert(def_id, scheme.generics);\n     let ctor_ty = match variant.kind {\n         VariantKind::Unit | VariantKind::Struct => scheme.ty,\n         VariantKind::Tuple => {\n@@ -960,8 +967,8 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 .iter()\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n-            let def_id = tcx.map.local_def_id(ctor_id);\n-            let substs = mk_item_substs(tcx, &scheme.generics);\n+            let substs = mk_item_substs(&ccx.icx(&predicates),\n+                                        ccx.tcx.map.span(ctor_id), def_id);\n             tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n@@ -974,12 +981,8 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n     write_ty_to_tcx(ccx, ctor_id, ctor_ty);\n+    tcx.tcache.borrow_mut().insert(def_id, ctor_ty);\n     tcx.predicates.borrow_mut().insert(tcx.map.local_def_id(ctor_id), predicates);\n-    tcx.register_item_type(tcx.map.local_def_id(ctor_id),\n-                           TypeScheme {\n-                               generics: scheme.generics,\n-                               ty: ctor_ty\n-                           });\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1237,7 +1240,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     let (unsafety, generics, items) = match it.node {\n-        hir::ItemTrait(unsafety, ref generics, _, ref items) => (unsafety, generics, items),\n+        hir::ItemTrait(unsafety, ref generics, _, ref items) => {\n+            (unsafety, generics, items)\n+        }\n         _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n@@ -1253,9 +1258,8 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         err.emit();\n     }\n \n-    let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, generics));\n-\n-    let ty_generics = ty_generics_for_trait(ccx, it.id, substs, generics);\n+    let ty_generics = generics_of_def_id(ccx, def_id);\n+    let substs = mk_item_substs(&ccx.icx(generics), it.span, def_id);\n \n     let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n@@ -1264,51 +1268,14 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }).collect();\n \n-    let trait_ref = ty::TraitRef {\n-        def_id: def_id,\n-        substs: substs,\n-    };\n-\n+    let trait_ref = ty::TraitRef::new(def_id, substs);\n     let trait_def = ty::TraitDef::new(unsafety,\n                                       paren_sugar,\n                                       ty_generics,\n                                       trait_ref,\n                                       associated_type_names);\n \n-    return tcx.intern_trait_def(trait_def);\n-\n-    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 generics: &hir::Generics)\n-                                 -> Substs<'tcx>\n-    {\n-        let tcx = ccx.tcx;\n-\n-        // Creates a no-op substitution for the trait's type parameters.\n-        let regions =\n-            generics.lifetimes\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, def)| ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        space: TypeSpace,\n-                        index: i as u32,\n-                        name: def.lifetime.name\n-                    }))\n-                    .collect();\n-\n-        // Start with the generics in the type parameters...\n-        let types: Vec<_> =\n-            generics.ty_params\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, def)| tcx.mk_param(TypeSpace,\n-                                                 i as u32, def.name))\n-                    .collect();\n-\n-        // ...and also create the `Self` parameter.\n-        let self_ty = tcx.mk_self_type();\n-\n-        Substs::new_trait(types, regions, self_ty)\n-    }\n+    tcx.intern_trait_def(trait_def)\n }\n \n fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n@@ -1410,118 +1377,252 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     }\n }\n \n-fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                  def_id: DefId)\n-                                  -> ty::TypeScheme<'tcx>\n-{\n-    if let Some(node_id) = ccx.tcx.map.as_local_node_id(def_id) {\n-        match ccx.tcx.map.find(node_id) {\n-            Some(hir_map::NodeItem(item)) => {\n-                type_scheme_of_item(ccx, &item)\n+fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                def_id: DefId)\n+                                -> &'tcx ty::Generics<'tcx> {\n+    let tcx = ccx.tcx;\n+    let node_id = if let Some(id) = tcx.map.as_local_node_id(def_id) {\n+        id\n+    } else {\n+        return tcx.lookup_generics(def_id);\n+    };\n+    tcx.generics.memoize(def_id, || {\n+        use rustc::hir::map::*;\n+        use rustc::hir::*;\n+\n+        let mut opt_self = None;\n+        let mut base_def_id = None;\n+        let mut allow_defaults = false;\n+\n+        let no_generics = hir::Generics::empty();\n+        let (space, ast_generics) = match tcx.map.get(node_id) {\n+            NodeImplItem(&ImplItem { node: ImplItemKind::Method(ref sig, _), .. }) |\n+            NodeTraitItem(&TraitItem { node: MethodTraitItem(ref sig, _), .. }) => {\n+                let parent_id = tcx.map.get_parent(node_id);\n+                base_def_id = Some(tcx.map.local_def_id(parent_id));\n+                (FnSpace, &sig.generics)\n             }\n-            Some(hir_map::NodeForeignItem(foreign_item)) => {\n-                let abi = ccx.tcx.map.get_foreign_abi(node_id);\n-                type_scheme_of_foreign_item(ccx, &foreign_item, abi)\n+\n+            NodeImplItem(_) |\n+            NodeTraitItem(_) => {\n+                let parent_id = tcx.map.get_parent(node_id);\n+                base_def_id = Some(tcx.map.local_def_id(parent_id));\n+                (FnSpace, &no_generics)\n             }\n-            x => {\n-                bug!(\"unexpected sort of node in get_item_type_scheme(): {:?}\",\n-                     x);\n+\n+            NodeItem(item) => {\n+                match item.node {\n+                    ItemFn(_, _, _, _, ref generics, _) => (FnSpace, generics),\n+                    ItemImpl(_, _, ref generics, _, _, _) => (TypeSpace, generics),\n+                    ItemTy(_, ref generics) |\n+                    ItemEnum(_, ref generics) |\n+                    ItemStruct(_, ref generics) => {\n+                        allow_defaults = true;\n+                        (TypeSpace, generics)\n+                    }\n+                    ItemTrait(_, ref generics, _, _) => {\n+                        // Add in the self type parameter.\n+                        //\n+                        // Something of a hack: use the node id for the trait, also as\n+                        // the node id for the Self type parameter.\n+                        let param_id = item.id;\n+\n+                        let parent = ccx.tcx.map.get_parent(param_id);\n+\n+                        let def = ty::TypeParameterDef {\n+                            space: SelfSpace,\n+                            index: 0,\n+                            name: keywords::SelfType.name(),\n+                            def_id: tcx.map.local_def_id(param_id),\n+                            default_def_id: tcx.map.local_def_id(parent),\n+                            default: None,\n+                            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+                        };\n+                        tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n+                        opt_self = Some(def);\n+\n+                        allow_defaults = true;\n+                        (TypeSpace, generics)\n+                    }\n+                    _ => (TypeSpace, &no_generics)\n+                }\n+            }\n+\n+            NodeForeignItem(item) => {\n+                match item.node {\n+                    ForeignItemStatic(..) => (TypeSpace, &no_generics),\n+                    ForeignItemFn(_, ref generics) => (FnSpace, generics)\n+                }\n             }\n+\n+            _ => (TypeSpace, &no_generics)\n+        };\n+\n+        let empty_generics = ty::Generics::empty();\n+        let base_generics = base_def_id.map_or(&empty_generics, |def_id| {\n+            generics_of_def_id(ccx, def_id)\n+        });\n+\n+        let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n+        let regions = early_lifetimes.iter().enumerate().map(|(i, l)| {\n+            ty::RegionParameterDef {\n+                name: l.lifetime.name,\n+                space: space,\n+                index: i as u32,\n+                def_id: tcx.map.local_def_id(l.lifetime.id),\n+                bounds: l.bounds.iter().map(|l| {\n+                    ast_region_to_region(tcx, l)\n+                }).collect()\n+            }\n+        }).collect();\n+\n+        // Now create the real type parameters.\n+        let types = ast_generics.ty_params.iter().enumerate().map(|(i, _)| {\n+            get_or_create_type_parameter_def(ccx, ast_generics, space, i as u32, allow_defaults)\n+        }).collect();\n+\n+        let has_self = base_generics.has_self || opt_self.is_some();\n+        let (regions, types) = match space {\n+            SelfSpace => bug!(),\n+            TypeSpace => {\n+                assert_eq!(base_generics.regions.as_full_slice().len(), 0);\n+                assert_eq!(base_generics.types.as_full_slice().len(), 0);\n+                (VecPerParamSpace::new(vec![], regions, vec![]),\n+                 VecPerParamSpace::new(opt_self.into_iter().collect(), types, vec![]))\n+            }\n+            FnSpace => {\n+                assert_eq!(base_generics.regions.len(FnSpace), 0);\n+                assert_eq!(base_generics.types.len(FnSpace), 0);\n+                (VecPerParamSpace::new(base_generics.regions.get_slice(SelfSpace).to_vec(),\n+                                       base_generics.regions.get_slice(TypeSpace).to_vec(),\n+                                       regions),\n+                 VecPerParamSpace::new(base_generics.types.get_slice(SelfSpace).to_vec(),\n+                                       base_generics.types.get_slice(TypeSpace).to_vec(),\n+                                       types))\n+            }\n+        };\n+\n+        // Debugging aid.\n+        if tcx.has_attr(def_id, \"rustc_object_lifetime_default\") {\n+            let object_lifetime_default_reprs: String =\n+                types.as_full_slice().iter().map(|t| {\n+                    match t.object_lifetime_default {\n+                        ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n+                        d => format!(\"{:?}\", d),\n+                    }\n+                }).collect::<Vec<String>>().join(\",\");\n+            tcx.sess.span_err(tcx.map.span(node_id), &object_lifetime_default_reprs);\n         }\n-    } else {\n-        ccx.tcx.lookup_item_type(def_id)\n-    }\n+\n+        tcx.alloc_generics(ty::Generics {\n+            regions: regions,\n+            types: types,\n+            has_self: has_self\n+        })\n+    })\n }\n \n-fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                item: &hir::Item)\n-                                -> ty::TypeScheme<'tcx>\n-{\n-    let item_def_id = ccx.tcx.map.local_def_id(item.id);\n-    ccx.tcx.tcache.memoize(item_def_id, || {\n-        // NB. Since the `memoized` function enters a new task, and we\n-        // are giving this task access to the item `item`, we must\n-        // register a read.\n-        assert!(!ccx.tcx.map.is_inlined_def_id(item_def_id));\n-        ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-        compute_type_scheme_of_item(ccx, item)\n+fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                            def_id: DefId)\n+                            -> Ty<'tcx> {\n+    let node_id = if let Some(id) = ccx.tcx.map.as_local_node_id(def_id) {\n+        id\n+    } else {\n+        return ccx.tcx.lookup_item_type(def_id).ty;\n+    };\n+    ccx.tcx.tcache.memoize(def_id, || {\n+        use rustc::hir::map::*;\n+        use rustc::hir::*;\n+\n+        let ty = match ccx.tcx.map.get(node_id) {\n+            NodeItem(item) => {\n+                match item.node {\n+                    ItemStatic(ref t, _, _) | ItemConst(ref t, _) => {\n+                        ccx.icx(&()).to_ty(&ExplicitRscope, &t)\n+                    }\n+                    ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n+                        let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n+                                                          Some(AnonTypeScope::new(def_id)));\n+                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        ccx.tcx.mk_fn_def(def_id, substs, tofd)\n+                    }\n+                    ItemTy(ref t, ref generics) => {\n+                        ccx.icx(generics).to_ty(&ExplicitRscope, &t)\n+                    }\n+                    ItemEnum(ref ei, ref generics) => {\n+                        let def = convert_enum_def(ccx, item, ei);\n+                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        ccx.tcx.mk_enum(def, substs)\n+                    }\n+                    ItemStruct(ref si, ref generics) => {\n+                        let def = convert_struct_def(ccx, item, si);\n+                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        ccx.tcx.mk_struct(def, substs)\n+                    }\n+                    ItemDefaultImpl(..) |\n+                    ItemTrait(..) |\n+                    ItemImpl(..) |\n+                    ItemMod(..) |\n+                    ItemForeignMod(..) |\n+                    ItemExternCrate(..) |\n+                    ItemUse(..) => {\n+                        span_bug!(\n+                            item.span,\n+                            \"compute_type_of_item: unexpected item type: {:?}\",\n+                            item.node);\n+                    }\n+                }\n+            }\n+            NodeForeignItem(foreign_item) => {\n+                let abi = ccx.tcx.map.get_foreign_abi(node_id);\n+\n+                match foreign_item.node {\n+                    ForeignItemFn(ref fn_decl, ref generics) => {\n+                        compute_type_of_foreign_fn_decl(\n+                            ccx, ccx.tcx.map.local_def_id(foreign_item.id),\n+                            fn_decl, generics, abi)\n+                    }\n+                    ForeignItemStatic(ref t, _) => {\n+                        ccx.icx(&()).to_ty(&ExplicitRscope, t)\n+                    }\n+                }\n+            }\n+            x => {\n+                bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n+            }\n+        };\n+\n+        write_ty_to_tcx(ccx, node_id, ty);\n+        ty\n     })\n }\n \n-fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                        it: &hir::Item)\n-                                        -> ty::TypeScheme<'tcx>\n-{\n-    let tcx = ccx.tcx;\n-    match it.node {\n-        hir::ItemStatic(ref t, _, _) | hir::ItemConst(ref t, _) => {\n-            let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &t);\n-            ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n-        }\n-        hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n-            let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n-            let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n-                                              Some(AnonTypeScope::new(&ty_generics)));\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let substs = mk_item_substs(tcx, &ty_generics);\n-            let ty = tcx.mk_fn_def(def_id, substs, tofd);\n-            ty::TypeScheme { ty: ty, generics: ty_generics }\n-        }\n-        hir::ItemTy(ref t, ref generics) => {\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n-            let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &t);\n-            ty::TypeScheme { ty: ty, generics: ty_generics }\n-        }\n-        hir::ItemEnum(ref ei, ref generics) => {\n-            let def = convert_enum_def(ccx, it, ei);\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(tcx, &ty_generics);\n-            let t = tcx.mk_enum(def, substs);\n-            ty::TypeScheme { ty: t, generics: ty_generics }\n-        }\n-        hir::ItemStruct(ref si, ref generics) => {\n-            let def = convert_struct_def(ccx, it, si);\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(tcx, &ty_generics);\n-            let t = tcx.mk_struct(def, substs);\n-            ty::TypeScheme { ty: t, generics: ty_generics }\n-        }\n-        hir::ItemDefaultImpl(..) |\n-        hir::ItemTrait(..) |\n-        hir::ItemImpl(..) |\n-        hir::ItemMod(..) |\n-        hir::ItemForeignMod(..) |\n-        hir::ItemExternCrate(..) |\n-        hir::ItemUse(..) => {\n-            span_bug!(\n-                it.span,\n-                \"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                it.node);\n+fn type_scheme_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                   def_id: DefId)\n+                                   -> ty::TypeScheme<'tcx> {\n+    if def_id.is_local() {\n+        ty::TypeScheme {\n+            generics: generics_of_def_id(ccx, def_id),\n+            ty: type_of_def_id(ccx, def_id)\n         }\n+    } else {\n+        ccx.tcx.lookup_item_type(def_id)\n     }\n }\n \n-fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item)\n-                                -> (ty::TypeScheme<'tcx>, ty::GenericPredicates<'tcx>)\n-{\n-    let tcx = ccx.tcx;\n-\n-    let tag = type_scheme_of_item(ccx, it);\n-    let scheme = TypeScheme { generics: tag.generics, ty: tag.ty };\n+                                -> ty::GenericPredicates<'tcx> {\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n     let predicates = match it.node {\n         hir::ItemStatic(..) | hir::ItemConst(..) => {\n             ty::GenericPredicates::empty()\n         }\n         hir::ItemFn(_, _, _, _, ref ast_generics, _) => {\n             ty_generic_predicates_for_fn(ccx, ast_generics, &ty::GenericPredicates::empty())\n         }\n-        hir::ItemTy(_, ref generics) => {\n-            ty_generic_predicates_for_type_or_impl(ccx, generics)\n-        }\n-        hir::ItemEnum(_, ref generics) => {\n-            ty_generic_predicates_for_type_or_impl(ccx, generics)\n-        }\n+        hir::ItemTy(_, ref generics) |\n+        hir::ItemEnum(_, ref generics) |\n         hir::ItemStruct(_, ref generics) => {\n             ty_generic_predicates_for_type_or_impl(ccx, generics)\n         }\n@@ -1534,68 +1635,16 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         hir::ItemForeignMod(..) => {\n             span_bug!(\n                 it.span,\n-                \"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                \"predicates_of_item: unexpected item type: {:?}\",\n                 it.node);\n         }\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                             predicates.clone());\n+    let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id,\n+                                                                 predicates.clone());\n     assert!(prev_predicates.is_none());\n \n-    // Debugging aid.\n-    if tcx.has_attr(ccx.tcx.map.local_def_id(it.id), \"rustc_object_lifetime_default\") {\n-        let object_lifetime_default_reprs: String =\n-            scheme.generics.types.as_full_slice().iter()\n-                                 .map(|t| match t.object_lifetime_default {\n-                                     ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n-                                     d => format!(\"{:?}\", d),\n-                                 })\n-                                 .collect::<Vec<String>>()\n-                                 .join(\",\");\n-\n-        tcx.sess.span_err(it.span, &object_lifetime_default_reprs);\n-    }\n-\n-    return (scheme, predicates);\n-}\n-\n-fn type_scheme_of_foreign_item<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n-    item: &hir::ForeignItem,\n-    abi: abi::Abi)\n-    -> ty::TypeScheme<'tcx>\n-{\n-    let item_def_id = ccx.tcx.map.local_def_id(item.id);\n-    ccx.tcx.tcache.memoize(item_def_id, || {\n-        // NB. Since the `memoized` function enters a new task, and we\n-        // are giving this task access to the item `item`, we must\n-        // register a read.\n-        assert!(!ccx.tcx.map.is_inlined_def_id(item_def_id));\n-        ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-        compute_type_scheme_of_foreign_item(ccx, item, abi)\n-    })\n-}\n-\n-fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n-    it: &hir::ForeignItem,\n-    abi: abi::Abi)\n-    -> ty::TypeScheme<'tcx>\n-{\n-    match it.node {\n-        hir::ForeignItemFn(ref fn_decl, ref generics) => {\n-            compute_type_scheme_of_foreign_fn_decl(\n-                ccx, ccx.tcx.map.local_def_id(it.id),\n-                fn_decl, generics, abi)\n-        }\n-        hir::ForeignItemStatic(ref t, _) => {\n-            ty::TypeScheme {\n-                generics: ty::Generics::empty(),\n-                ty: AstConv::ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, t)\n-            }\n-        }\n-    }\n+    predicates\n }\n \n fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1605,11 +1654,8 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let tcx = ccx.tcx;\n-    let abi = tcx.map.get_foreign_abi(it.id);\n-\n-    let scheme = type_scheme_of_foreign_item(ccx, it, abi);\n-    write_ty_to_tcx(ccx, it.id, scheme.ty);\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n+    type_scheme_of_def_id(ccx, def_id);\n \n     let predicates = match it.node {\n         hir::ForeignItemFn(_, ref generics) => {\n@@ -1620,72 +1666,17 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                             predicates);\n+    let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n     assert!(prev_predicates.is_none());\n }\n \n-fn ty_generics_for_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, generics: &hir::Generics)\n-                                  -> ty::Generics<'tcx> {\n-    ty_generics(ccx, TypeSpace, generics, &ty::Generics::empty(), true)\n-}\n-\n-fn ty_generics_for_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, generics: &hir::Generics)\n-                                  -> ty::Generics<'tcx> {\n-    ty_generics(ccx, TypeSpace, generics, &ty::Generics::empty(), false)\n-}\n-\n fn ty_generic_predicates_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                                    generics: &hir::Generics)\n                                                    -> ty::GenericPredicates<'tcx>\n {\n     ty_generic_predicates(ccx, TypeSpace, generics, &ty::GenericPredicates::empty())\n }\n \n-fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                   trait_id: ast::NodeId,\n-                                   substs: &'tcx Substs<'tcx>,\n-                                   ast_generics: &hir::Generics)\n-                                   -> ty::Generics<'tcx>\n-{\n-    debug!(\"ty_generics_for_trait(trait_id={:?}, substs={:?})\",\n-           ccx.tcx.map.local_def_id(trait_id), substs);\n-\n-    let mut generics = ty_generics_for_type(ccx, ast_generics);\n-\n-    // Add in the self type parameter.\n-    //\n-    // Something of a hack: use the node id for the trait, also as\n-    // the node id for the Self type parameter.\n-    let param_id = trait_id;\n-\n-    let parent = ccx.tcx.map.get_parent(param_id);\n-\n-    let def = ty::TypeParameterDef {\n-        space: SelfSpace,\n-        index: 0,\n-        name: keywords::SelfType.name(),\n-        def_id: ccx.tcx.map.local_def_id(param_id),\n-        default_def_id: ccx.tcx.map.local_def_id(parent),\n-        default: None,\n-        object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n-    };\n-\n-    ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n-\n-    generics.types.push(SelfSpace, def);\n-\n-    return generics;\n-}\n-\n-fn ty_generics_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                               generics: &hir::Generics,\n-                               base_generics: &ty::Generics<'tcx>)\n-                               -> ty::Generics<'tcx>\n-{\n-    ty_generics(ccx, FnSpace, generics, base_generics, false)\n-}\n-\n fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                          generics: &hir::Generics,\n                                          base_predicates: &ty::GenericPredicates<'tcx>)\n@@ -1859,42 +1850,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     result\n }\n \n-fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                        space: ParamSpace,\n-                        ast_generics: &hir::Generics,\n-                        base_generics: &ty::Generics<'tcx>,\n-                        allow_defaults: bool)\n-                        -> ty::Generics<'tcx>\n-{\n-    let tcx = ccx.tcx;\n-    let mut result = base_generics.clone();\n-\n-    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n-    for (i, l) in early_lifetimes.iter().enumerate() {\n-        let bounds = l.bounds.iter()\n-                             .map(|l| ast_region_to_region(tcx, l))\n-                             .collect();\n-        let def = ty::RegionParameterDef { name: l.lifetime.name,\n-                                           space: space,\n-                                           index: i as u32,\n-                                           def_id: ccx.tcx.map.local_def_id(l.lifetime.id),\n-                                           bounds: bounds };\n-        result.regions.push(space, def);\n-    }\n-\n-    assert!(result.types.is_empty_in(space));\n-\n-    // Now create the real type parameters.\n-    for i in 0..ast_generics.ty_params.len() {\n-        let def =\n-            get_or_create_type_parameter_def(ccx, ast_generics, space, i as u32, allow_defaults);\n-        debug!(\"ty_generics: def for type param: {:?}, {:?}\", def, space);\n-        result.types.push(space, def);\n-    }\n-\n-    result\n-}\n-\n fn convert_default_type_parameter<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             path: &P<hir::Ty>,\n                                             space: ParamSpace,\n@@ -1969,6 +1924,9 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n     tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n+    debug!(\"get_or_create_type_parameter_def: def for type param: {:?}, {:?}\",\n+           def, space);\n+\n     def\n }\n \n@@ -2122,16 +2080,14 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n+fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n-    id: DefId,\n+    def_id: DefId,\n     decl: &hir::FnDecl,\n     ast_generics: &hir::Generics,\n     abi: abi::Abi)\n-    -> ty::TypeScheme<'tcx>\n+    -> Ty<'tcx>\n {\n-    let ty_generics = ty_generics_for_fn(ccx, ast_generics, &ty::Generics::empty());\n-\n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n@@ -2167,34 +2123,32 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = mk_item_substs(ccx.tcx, &ty_generics);\n-    let t_fn = ccx.tcx.mk_fn_def(id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n+    let id = ccx.tcx.map.as_local_node_id(def_id).unwrap();\n+    let substs = mk_item_substs(&ccx.icx(ast_generics), ccx.tcx.map.span(id), def_id);\n+    ccx.tcx.mk_fn_def(def_id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n         abi: abi,\n         unsafety: hir::Unsafety::Unsafe,\n         sig: ty::Binder(ty::FnSig {inputs: input_tys,\n                                     output: output,\n                                     variadic: decl.variadic}),\n-    }));\n-\n-    ty::TypeScheme {\n-        generics: ty_generics,\n-        ty: t_fn\n-    }\n+    }))\n }\n \n-pub fn mk_item_substs<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                      ty_generics: &ty::Generics)\n-                                      -> &'tcx Substs<'tcx>\n-{\n-    let types =\n-        ty_generics.types.map(\n-            |def| tcx.mk_param_from_def(def));\n-\n-    let regions =\n-        ty_generics.regions.map(\n-            |def| def.to_early_bound_region());\n+pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                        span: Span,\n+                                        def_id: DefId)\n+                                        -> &'tcx Substs<'tcx> {\n+    let tcx = astconv.tcx();\n+    // FIXME(eddyb) Do this request from Substs::for_item in librustc.\n+    if let Err(ErrorReported) = astconv.get_generics(span, def_id) {\n+        // No convenient way to recover from a cycle here. Just bail. Sorry!\n+        tcx.sess.abort_if_errors();\n+        bug!(\"ErrorReported returned, but no errors reports?\")\n+    }\n \n-    tcx.mk_substs(Substs::new(types, regions))\n+    Substs::for_item(tcx, def_id,\n+                     |def, _| def.to_early_bound_region(),\n+                     |def, _| tcx.mk_param_from_def(def))\n }\n \n /// Checks that all the type parameters on an impl"}, {"sha": "8a8232535c77592ae9936d6545899bc1e257ad58", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -231,7 +231,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n             let main_def_id = tcx.map.local_def_id(main_id);\n-            let substs = tcx.mk_substs(Substs::empty());\n+            let substs = Substs::empty(tcx);\n             let se_ty = tcx.mk_fn_def(main_def_id, substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n@@ -284,7 +284,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             }\n \n             let start_def_id = ccx.tcx.map.local_def_id(start_id);\n-            let substs = tcx.mk_substs(Substs::empty());\n+            let substs = Substs::empty(tcx);\n             let se_ty = tcx.mk_fn_def(start_def_id, substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,"}, {"sha": "9aca779dd89c4f7ee01758eee09ae012eefff077", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use rustc::ty::{self, TyCtxt};\n+use rustc::hir::def_id::DefId;\n+use rustc::ty;\n use rustc::ty::subst::Substs;\n \n+use astconv::AstConv;\n+\n use std::cell::Cell;\n use syntax_pos::Span;\n \n@@ -71,41 +73,42 @@ pub trait RegionScope {\n }\n \n #[derive(Copy, Clone)]\n-pub struct AnonTypeScope<'a> {\n-    generics: &'a ty::Generics<'a>\n+pub struct AnonTypeScope {\n+    enclosing_item: DefId\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> AnonTypeScope<'a> {\n-    pub fn new(generics: &'a ty::Generics<'a>) -> AnonTypeScope<'a> {\n+impl<'gcx: 'tcx, 'tcx> AnonTypeScope {\n+    pub fn new(enclosing_item: DefId) -> AnonTypeScope {\n         AnonTypeScope {\n-            generics: generics\n+            enclosing_item: enclosing_item\n         }\n     }\n \n-    pub fn fresh_substs(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n+    pub fn fresh_substs(&self, astconv: &AstConv<'gcx, 'tcx>, span: Span)\n+                        -> &'tcx Substs<'tcx> {\n         use collect::mk_item_substs;\n \n-        mk_item_substs(tcx, self.generics)\n+        mk_item_substs(astconv, span, self.enclosing_item)\n     }\n }\n \n /// A scope wrapper which optionally allows anonymized types.\n #[derive(Copy, Clone)]\n-pub struct MaybeWithAnonTypes<'a, R> {\n+pub struct MaybeWithAnonTypes<R> {\n     base_scope: R,\n-    anon_scope: Option<AnonTypeScope<'a>>\n+    anon_scope: Option<AnonTypeScope>\n }\n \n-impl<'a, R: RegionScope> MaybeWithAnonTypes<'a, R>  {\n-    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope<'a>>) -> Self {\n+impl<R: RegionScope> MaybeWithAnonTypes<R>  {\n+    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope>) -> Self {\n         MaybeWithAnonTypes {\n             base_scope: base_scope,\n             anon_scope: anon_scope\n         }\n     }\n }\n \n-impl<'a, R: RegionScope> RegionScope for MaybeWithAnonTypes<'a, R> {\n+impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         self.base_scope.object_lifetime_default(span)\n     }"}, {"sha": "8c9b4beb79d840f67a6f825397ffc9eefe4244f3", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -16,8 +16,7 @@\n use dep_graph::DepTrackingMapConfig;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n-use rustc::ty::subst;\n-use rustc::ty::subst::ParamSpace;\n+use rustc::ty::subst::{self, ParamSpace, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::ItemVariances;\n use rustc::hir::map as hir_map;\n@@ -370,8 +369,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_substs(\n                     generics,\n                     def.did,\n-                    item_type.generics.types.get_slice(subst::TypeSpace),\n-                    item_type.generics.regions.get_slice(subst::TypeSpace),\n+                    item_type.generics.types.as_full_slice(),\n+                    item_type.generics.regions.as_full_slice(),\n                     substs,\n                     variance);\n             }\n@@ -449,7 +448,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    def_id: DefId,\n                                    type_param_defs: &[ty::TypeParameterDef<'tcx>],\n                                    region_param_defs: &[ty::RegionParameterDef],\n-                                   substs: &subst::Substs<'tcx>,\n+                                   substs: &Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n                def_id,"}, {"sha": "22edf219dff75b33f6d4c175414ee4dc84d86323", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -16,6 +16,7 @@\n //! inferred is then written into the `variance_map` in the tcx.\n \n use rustc::ty;\n+use rustc::ty::subst;\n use std::rc::Rc;\n \n use super::constraints::*;\n@@ -108,21 +109,44 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         let num_inferred = self.terms_cx.num_inferred();\n         while index < num_inferred {\n             let item_id = inferred_infos[index].item_id;\n-            let mut item_variances = ty::ItemVariances::empty();\n+\n+            let (mut rs, mut rt, mut rf) = (vec![], vec![], vec![]);\n+            let (mut ts, mut tt, mut tf) = (vec![], vec![], vec![]);\n \n             while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n                 debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n                        index, info.index, info.kind, info.space, variance);\n                 match info.kind {\n-                    TypeParam => { item_variances.types.push(info.space, variance); }\n-                    RegionParam => { item_variances.regions.push(info.space, variance); }\n+                    TypeParam => {\n+                        let types = match info.space {\n+                            subst::SelfSpace => &mut ts,\n+                            subst::TypeSpace => &mut tt,\n+                            subst::FnSpace => &mut tf\n+                        };\n+                        assert_eq!(types.len(), info.index);\n+                        types.push(variance);\n+                    }\n+                    RegionParam => {\n+                        let regions = match info.space {\n+                            subst::SelfSpace => &mut rs,\n+                            subst::TypeSpace => &mut rt,\n+                            subst::FnSpace => &mut rf\n+                        };\n+                        assert_eq!(regions.len(), info.index);\n+                        regions.push(variance);\n+                    }\n                 }\n \n                 index += 1;\n             }\n \n+            let item_variances = ty::ItemVariances {\n+                regions: subst::VecPerParamSpace::new(rs, rt, rf),\n+                types: subst::VecPerParamSpace::new(ts, tt, tf)\n+            };\n+\n             debug!(\"item_id={} item_variances={:?}\",\n                     item_id,\n                     item_variances);"}, {"sha": "b4be201440ccf9c53a5f027ef827bda0368bcba0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -161,7 +161,7 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n     let def = tcx.lookup_trait_def(did);\n     let trait_items = tcx.trait_items(did).clean(cx);\n     let predicates = tcx.lookup_predicates(did);\n-    let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n+    let generics = (def.generics, &predicates, subst::TypeSpace).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     clean::Trait {\n@@ -189,7 +189,7 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n     let predicates = tcx.lookup_predicates(did);\n     clean::Function {\n         decl: decl,\n-        generics: (&t.generics, &predicates, subst::FnSpace).clean(cx),\n+        generics: (t.generics, &predicates, subst::FnSpace).clean(cx),\n         unsafety: style,\n         constness: constness,\n         abi: abi,\n@@ -209,7 +209,7 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             &[..] if variant.kind == ty::VariantKind::Tuple => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n-        generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n+        generics: (t.generics, &predicates, subst::TypeSpace).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n@@ -222,7 +222,7 @@ fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match t.ty.sty {\n         ty::TyEnum(edef, _) if !tcx.sess.cstore.is_typedef(did) => {\n             return clean::EnumItem(clean::Enum {\n-                generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n+                generics: (t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n                 variants: edef.variants.clean(cx),\n             })\n@@ -232,7 +232,7 @@ fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     clean::TypedefItem(clean::Typedef {\n         type_: t.ty.clean(cx),\n-        generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n+        generics: (t.generics, &predicates, subst::TypeSpace).clean(cx),\n     }, false)\n }\n \n@@ -389,15 +389,11 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             }\n             ty::TypeTraitItem(ref assoc_ty) => {\n                 let did = assoc_ty.def_id;\n-                let type_scheme = ty::TypeScheme {\n-                    ty: assoc_ty.ty.unwrap(),\n-                    generics: ty::Generics::empty()\n-                };\n                 // Not sure the choice of ParamSpace actually matters here,\n                 // because an associated type won't have generics on the LHS\n                 let typedef = clean::Typedef {\n-                    type_: type_scheme.ty.clean(cx),\n-                    generics: (&type_scheme.generics,\n+                    type_: assoc_ty.ty.unwrap().clean(cx),\n+                    generics: (&ty::Generics::empty(),\n                                &ty::GenericPredicates::empty(),\n                                subst::TypeSpace).clean(cx)\n                 };\n@@ -438,7 +434,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             provided_trait_methods: provided,\n             trait_: trait_,\n             for_: for_,\n-            generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),\n+            generics: (ty.generics, &predicates, subst::TypeSpace).clean(cx),\n             items: trait_items,\n             polarity: polarity.map(|p| { p.clean(cx) }),\n         }),"}, {"sha": "f8a3a0af69752c63ca5e17b312e2c31c98791b15", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4158673ad7150f4fa02fbea3654e8cf1628beb0b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4158673ad7150f4fa02fbea3654e8cf1628beb0b", "patch": "@@ -41,7 +41,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n-use rustc::ty::subst::{self, ParamSpace, VecPerParamSpace};\n+use rustc::ty::subst::{self, ParamSpace, Substs, VecPerParamSpace};\n use rustc::ty;\n use rustc::middle::stability;\n \n@@ -631,7 +631,7 @@ impl Clean<TyParamBound> for hir::TyParamBound {\n }\n \n fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n-                        bindings: Vec<TypeBinding>, substs: &subst::Substs) -> PathParameters {\n+                        bindings: Vec<TypeBinding>, substs: &Substs) -> PathParameters {\n     let lifetimes = substs.regions.get_slice(subst::TypeSpace)\n                     .iter()\n                     .filter_map(|v| v.clean(cx))\n@@ -676,7 +676,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>,\n-                 bindings: Vec<TypeBinding>, substs: &subst::Substs) -> Path {\n+                 bindings: Vec<TypeBinding>, substs: &Substs) -> Path {\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n@@ -692,20 +692,20 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n             Some(tcx) => tcx,\n             None => return RegionBound(Lifetime::statik())\n         };\n-        let empty = subst::Substs::empty();\n+        let empty = Substs::empty(tcx);\n         let (did, path) = match *self {\n             ty::BoundSend =>\n                 (tcx.lang_items.send_trait().unwrap(),\n-                 external_path(cx, \"Send\", None, vec![], &empty)),\n+                 external_path(cx, \"Send\", None, vec![], empty)),\n             ty::BoundSized =>\n                 (tcx.lang_items.sized_trait().unwrap(),\n-                 external_path(cx, \"Sized\", None, vec![], &empty)),\n+                 external_path(cx, \"Sized\", None, vec![], empty)),\n             ty::BoundCopy =>\n                 (tcx.lang_items.copy_trait().unwrap(),\n-                 external_path(cx, \"Copy\", None, vec![], &empty)),\n+                 external_path(cx, \"Copy\", None, vec![], empty)),\n             ty::BoundSync =>\n                 (tcx.lang_items.sync_trait().unwrap(),\n-                 external_path(cx, \"Sync\", None, vec![], &empty)),\n+                 external_path(cx, \"Sync\", None, vec![], empty)),\n         };\n         inline::record_extern_fqn(cx, did, TypeTrait);\n         TraitBound(PolyTrait {\n@@ -765,7 +765,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n+impl<'tcx> Clean<Option<Vec<TyParamBound>>> for Substs<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions.as_full_slice().iter().filter_map(|r| r.clean(cx))\n@@ -891,7 +891,7 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         WherePredicate::BoundPredicate {\n-            ty: self.trait_ref.substs.self_ty().clean(cx).unwrap(),\n+            ty: self.trait_ref.self_ty().clean(cx),\n             bounds: vec![self.trait_ref.clean(cx)]\n         }\n     }\n@@ -1353,7 +1353,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             predicates: self.predicates.predicates[method_start..].to_vec()\n         };\n \n-        let generics = (&self.generics, &method_predicates,\n+        let generics = (self.generics, &method_predicates,\n                         subst::FnSpace).clean(cx);\n         let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n         match self.explicit_self {\n@@ -2923,7 +2923,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n             // applied to this associated type in question.\n             let def = cx.tcx().lookup_trait_def(did);\n             let predicates = cx.tcx().lookup_predicates(did);\n-            let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n+            let generics = (def.generics, &predicates, subst::TypeSpace).clean(cx);\n             generics.where_predicates.iter().filter_map(|pred| {\n                 let (name, self_type, trait_, bounds) = match *pred {\n                     WherePredicate::BoundPredicate {"}]}