{"sha": "3ba4f6db04487929b2eecfc645fa9f4d8c54dfea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYTRmNmRiMDQ0ODc5MjliMmVlY2ZjNjQ1ZmE5ZjRkOGM1NGRmZWE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-17T13:16:41Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-17T13:16:41Z"}, "message": "remove code repetition and fix overflowing intrinsics", "tree": {"sha": "96b87462db8ffe8c4b1e9faa96ad6831885dbe8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96b87462db8ffe8c4b1e9faa96ad6831885dbe8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXY/g5AAoJEFbW7qD8Z6xGPQwP/17gOe6NJTMPDDPIvgFrUshC\n3vegisJg5A0jgv7mnA+xmNWV+947wvCo3+yHRixND4SR4aUDPhPoeZ3xDQ4BXBbB\nfWN2xqquO8XdXVJcDIWpvWybqyE2I7hsh1KlyNP4BKbxDoETpbEvrg5yelBxr166\nhzz7C549QBeB10xGAU9VwBBnc2koffpBBxEkrNgvj2AubZZ/dvDmnwJ3qccrhxu+\nVxzRJJPifXwu90ndeTiWCryPgg1oPph4l1gmThH2gqMLlWodPxqxw/EaYv41B8uW\nMj7j7zaWaaHJNlnDwZYLcfCpKOExwyc0J2ETxxHBMoenT4RY5z8hUME7/F9xOiFI\nb6KcgRh5SOMGDz4aGda6mhIopOPjYGK7vutQannOybLbfcLflqUs4Eclv4AZukLX\n8YG73Y5rNgEQhxuJ655LXMGpmFc0jh1QPvL4BV6PxnDImPno8Jg22t2W3zsGWol3\nNI2qcIeGBWvNvwGM4PTSK4grUIKzUIulb5Z/cxYs2MJ4hzPt4WdE7uOu35GIWHsg\nseDLCvk4F4NzOGTwBF5dB0RXiaZDbwy+t2xkgaidmwZePxf1iDvPp+PZxU73P/kz\nWi0BZQOCybWuPfH1TSkFOaqtxVc+E+04bK92yjAf9OrWoXfdYLvjXwQRht4dvdYC\nay4fLH0W7HgPJzqmy2xq\n=DwiG\n-----END PGP SIGNATURE-----", "payload": "tree 96b87462db8ffe8c4b1e9faa96ad6831885dbe8b\nparent 58b4fac1ceca3d75e59091b09e71a8914d6bd7e2\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1466169401 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1466169401 +0200\n\nremove code repetition and fix overflowing intrinsics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea", "html_url": "https://github.com/rust-lang/rust/commit/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b4fac1ceca3d75e59091b09e71a8914d6bd7e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b4fac1ceca3d75e59091b09e71a8914d6bd7e2", "html_url": "https://github.com/rust-lang/rust/commit/58b4fac1ceca3d75e59091b09e71a8914d6bd7e2"}], "stats": {"total": 215, "additions": 102, "deletions": 113}, "files": [{"sha": "be8648ee3028656cdaf9f441108c0f74e6a4d298", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=3ba4f6db04487929b2eecfc645fa9f4d8c54dfea", "patch": "@@ -515,9 +515,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let name = self.tcx.item_name(def_id).as_str();\n                 match fn_ty.sig.0.output {\n                     ty::FnConverging(ty) => {\n-                        let size = self.type_size(ty);\n+                        let layout = self.type_layout(ty);\n                         let ret = return_ptr.unwrap();\n-                        self.call_intrinsic(&name, substs, args, ret, size)\n+                        self.call_intrinsic(&name, substs, args, ret, layout)\n                     }\n                     ty::FnDiverging => unimplemented!(),\n                 }\n@@ -667,87 +667,126 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(if not_null { nndiscr } else { 1 - nndiscr })\n     }\n \n+    fn intrinsic_with_overflow(\n+        &mut self,\n+        op: mir::BinOp,\n+        left: &mir::Operand<'tcx>,\n+        right: &mir::Operand<'tcx>,\n+        dest: Pointer,\n+        dest_layout: &'tcx Layout,\n+    ) -> EvalResult<'tcx, ()> {\n+        use rustc::ty::layout::Layout::*;\n+        let tup_layout = match *dest_layout {\n+            Univariant { ref variant, .. } => variant,\n+            _ => panic!(\"checked bin op returns something other than a tuple\"),\n+        };\n+\n+        let overflowed = self.intrinsic_overflowing(op, left, right, dest)?;\n+        let offset = tup_layout.field_offset(1).bytes() as isize;\n+        self.memory.write_bool(dest.offset(offset), overflowed)\n+    }\n+\n+    fn math(\n+        &mut self,\n+        op: mir::BinOp,\n+        left: &mir::Operand<'tcx>,\n+        right: &mir::Operand<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n+        let left_ptr = self.eval_operand(left)?;\n+        let left_ty = self.operand_ty(left);\n+        let left_val = self.read_primval(left_ptr, left_ty)?;\n+\n+        let right_ptr = self.eval_operand(right)?;\n+        let right_ty = self.operand_ty(right);\n+        let right_val = self.read_primval(right_ptr, right_ty)?;\n+\n+        primval::binary_op(op, left_val, right_val)\n+    }\n+\n+    fn intrinsic_overflowing(\n+        &mut self,\n+        op: mir::BinOp,\n+        left: &mir::Operand<'tcx>,\n+        right: &mir::Operand<'tcx>,\n+        dest: Pointer,\n+    ) -> EvalResult<'tcx, bool> {\n+        match self.math(op, left, right) {\n+            Ok(val) => {\n+                self.memory.write_primval(dest, val)?;\n+                Ok(false)\n+            },\n+            Err(EvalError::Overflow(l, r, op, val)) => {\n+                debug!(\"operation overflowed: {:?} {} {:?} => {:?}\", l, op.to_hir_binop().as_str(), r, val);\n+                self.memory.write_primval(dest, val)?;\n+                Ok(true)\n+            },\n+            Err(other) => Err(other),\n+        }\n+    }\n+\n     fn call_intrinsic(\n         &mut self,\n         name: &str,\n         substs: &'tcx Substs<'tcx>,\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n-        dest_size: usize\n+        dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n-        let args = args_res?;\n+        let args_ptrs = args_res?;\n+\n+        let pointer_size = self.memory.pointer_size;\n \n         match name {\n-            // FIXME(solson): Handle different integer types correctly.\n-            \"add_with_overflow\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n-                let left = self.memory.read_int(args[0], size)?;\n-                let right = self.memory.read_int(args[1], size)?;\n-                let (n, overflowed) = unsafe {\n-                    ::std::intrinsics::add_with_overflow::<i64>(left, right)\n-                };\n-                self.memory.write_int(dest, n, size)?;\n-                self.memory.write_bool(dest.offset(size as isize), overflowed)?;\n-            }\n+            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n+            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n+            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n \n+            // FIXME: turn into an assertion to catch wrong `assume` that would cause UB in llvm\n             \"assume\" => {}\n \n             \"copy_nonoverlapping\" => {\n                 let elem_ty = *substs.types.get(subst::FnSpace, 0);\n                 let elem_size = self.type_size(elem_ty);\n-                let src = self.memory.read_ptr(args[0])?;\n-                let dest = self.memory.read_ptr(args[1])?;\n-                let count = self.memory.read_isize(args[2])?;\n+                let src = self.memory.read_ptr(args_ptrs[0])?;\n+                let dest = self.memory.read_ptr(args_ptrs[1])?;\n+                let count = self.memory.read_isize(args_ptrs[2])?;\n                 self.memory.copy(src, dest, count as usize * elem_size)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let adt_ptr = self.memory.read_ptr(args[0])?;\n+                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.memory.write_uint(dest, discr_val, dest_size)?;\n+                self.memory.write_uint(dest, discr_val, 8)?;\n             }\n \n             \"forget\" => {\n                 let arg_ty = *substs.types.get(subst::FnSpace, 0);\n                 let arg_size = self.type_size(arg_ty);\n-                self.memory.drop_fill(args[0], arg_size)?;\n+                self.memory.drop_fill(args_ptrs[0], arg_size)?;\n             }\n \n-            \"init\" => self.memory.write_repeat(dest, 0, dest_size)?,\n+            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n \n             \"min_align_of\" => {\n-                self.memory.write_int(dest, 1, dest_size)?;\n+                // FIXME: use correct value\n+                self.memory.write_int(dest, 1, pointer_size)?;\n             }\n \n             \"move_val_init\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let ptr = self.memory.read_ptr(args[0])?;\n-                self.move_(args[1], ptr, ty)?;\n-            }\n-\n-            // FIXME(solson): Handle different integer types correctly.\n-            \"mul_with_overflow\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n-                let left = self.memory.read_int(args[0], size)?;\n-                let right = self.memory.read_int(args[1], size)?;\n-                let (n, overflowed) = unsafe {\n-                    ::std::intrinsics::mul_with_overflow::<i64>(left, right)\n-                };\n-                self.memory.write_int(dest, n, size)?;\n-                self.memory.write_bool(dest.offset(size as isize), overflowed)?;\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(args_ptrs[1], ptr, ty)?;\n             }\n \n             \"offset\" => {\n                 let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n                 let pointee_size = self.type_size(pointee_ty) as isize;\n-                let ptr_arg = args[0];\n-                let offset = self.memory.read_isize(args[1])?;\n+                let ptr_arg = args_ptrs[0];\n+                let offset = self.memory.read_isize(args_ptrs[1])?;\n \n                 match self.memory.read_ptr(ptr_arg) {\n                     Ok(ptr) => {\n@@ -763,35 +802,35 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n \n-            // FIXME(solson): Handle different integer types correctly. Use primvals?\n             \"overflowing_sub\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n-                let left = self.memory.read_int(args[0], size)?;\n-                let right = self.memory.read_int(args[1], size)?;\n-                let n = left.wrapping_sub(right);\n-                self.memory.write_int(dest, n, size)?;\n+                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n+            }\n+            \"overflowing_mul\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n+            }\n+            \"overflowing_add\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n             }\n \n             \"size_of\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty) as u64;\n-                self.memory.write_uint(dest, size, dest_size)?;\n+                self.memory.write_uint(dest, size, pointer_size)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 if self.type_is_sized(ty) {\n                     let size = self.type_size(ty) as u64;\n-                    self.memory.write_uint(dest, size, dest_size)?;\n+                    self.memory.write_uint(dest, size, pointer_size)?;\n                 } else {\n                     match ty.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n                             let elem_ty = ty.sequence_element_type(self.tcx);\n                             let elem_size = self.type_size(elem_ty) as u64;\n                             let ptr_size = self.memory.pointer_size as isize;\n-                            let n = self.memory.read_usize(args[0].offset(ptr_size))?;\n-                            self.memory.write_uint(dest, n * elem_size, dest_size)?;\n+                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n+                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n                         }\n \n                         _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n@@ -801,9 +840,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"transmute\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                self.move_(args[0], dest, ty)?;\n+                self.move_(args_ptrs[0], dest, ty)?;\n             }\n-            \"uninit\" => self.memory.mark_definedness(dest, dest_size, false)?,\n+            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n \n             name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n         }\n@@ -908,50 +947,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n-                let left_ptr = self.eval_operand(left)?;\n-                let left_ty = self.operand_ty(left);\n-                let left_val = self.read_primval(left_ptr, left_ty)?;\n-\n-                let right_ptr = self.eval_operand(right)?;\n-                let right_ty = self.operand_ty(right);\n-                let right_val = self.read_primval(right_ptr, right_ty)?;\n-\n-                let val = primval::binary_op(bin_op, left_val, right_val)?;\n-                self.memory.write_primval(dest, val)?;\n+                let result = self.math(bin_op, left, right)?;\n+                self.memory.write_primval(dest, result)?;\n             }\n \n-            // FIXME(solson): Factor this out with BinaryOp.\n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n-                let left_ptr = self.eval_operand(left)?;\n-                let left_ty = self.operand_ty(left);\n-                let left_val = self.read_primval(left_ptr, left_ty)?;\n-\n-                let right_ptr = self.eval_operand(right)?;\n-                let right_ty = self.operand_ty(right);\n-                let right_val = self.read_primval(right_ptr, right_ty)?;\n-\n-                use rustc::ty::layout::Layout::*;\n-                let tup_layout = match *dest_layout {\n-                    Univariant { ref variant, .. } => variant,\n-                    _ => panic!(\"checked bin op returns something other than a tuple\"),\n-                };\n-\n-                match primval::binary_op(bin_op, left_val, right_val) {\n-                    Ok(val) => {\n-                        let offset = tup_layout.field_offset(0).bytes() as isize;\n-                        self.memory.write_primval(dest.offset(offset), val)?;\n-                        let offset = tup_layout.field_offset(1).bytes() as isize;\n-                        self.memory.write_bool(dest.offset(offset), false)?;\n-                    },\n-                    Err(EvalError::Overflow(l, r, op, val)) => {\n-                        debug!(\"mathematical operation overflowed: {:?} {} {:?} => {:?}\", l, op.to_hir_binop().as_str(), r, val);\n-                        let offset = tup_layout.field_offset(0).bytes() as isize;\n-                        self.memory.write_primval(dest.offset(offset), val)?;\n-                        let offset = tup_layout.field_offset(1).bytes() as isize;\n-                        self.memory.write_bool(dest.offset(offset), true)?;\n-                    },\n-                    Err(other) => return Err(other),\n-                }\n+                self.intrinsic_with_overflow(bin_op, left, right, dest, dest_layout)?;\n             }\n \n             UnaryOp(un_op, ref operand) => {"}, {"sha": "c983a3f71634549b3bb8a7ff66672bc55ea77c8e", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=3ba4f6db04487929b2eecfc645fa9f4d8c54dfea", "patch": "@@ -2,7 +2,6 @@\n     btree_range,\n     collections,\n     collections_bound,\n-    core_intrinsics,\n     filling_drop,\n     question_mark,\n     rustc_private,"}, {"sha": "b6c46ba4b00bc753ce0ab91e66c8acfa3c1fda2b", "filename": "tests/compiletest.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=3ba4f6db04487929b2eecfc645fa9f4d8c54dfea", "patch": "@@ -38,7 +38,6 @@ fn for_all_targets<F: FnMut(String)>(sysroot: &str, mut f: F) {\n \n #[test]\n fn compile_test() {\n-    let mut failed = false;\n     // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n     let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n@@ -69,19 +68,16 @@ fn compile_test() {\n             match cmd.output() {\n                 Ok(ref output) if output.status.success() => writeln!(stderr.lock(), \"ok\").unwrap(),\n                 Ok(output) => {\n-                    failed = true;\n                     writeln!(stderr.lock(), \"FAILED with exit code {}\", output.status.code().unwrap_or(0)).unwrap();\n                     writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n                     writeln!(stderr.lock(), \"stderr: \\n {}\", std::str::from_utf8(&output.stderr).unwrap()).unwrap();\n+                    panic!(\"some tests failed\");\n                 }\n                 Err(e) => {\n-                    failed = true;\n                     writeln!(stderr.lock(), \"FAILED: {}\", e).unwrap();\n+                    panic!(\"some tests failed\");\n                 },\n             }\n-            if failed {\n-                panic!(\"some tests failed\");\n-            }\n         }\n         let stderr = std::io::stderr();\n         writeln!(stderr.lock(), \"\").unwrap();"}, {"sha": "4f23b5ec9c3816647be90d643b7cac4b8cd90481", "filename": "tests/run-pass/ints.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/tests%2Frun-pass%2Fints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba4f6db04487929b2eecfc645fa9f4d8c54dfea/tests%2Frun-pass%2Fints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fints.rs?ref=3ba4f6db04487929b2eecfc645fa9f4d8c54dfea", "patch": "@@ -1,34 +1,25 @@\n-#![feature(custom_attribute)]\n-#![allow(dead_code, unused_attributes)]\n-\n-#[miri_run]\n fn ret() -> i64 {\n     1\n }\n \n-#[miri_run]\n fn neg() -> i64 {\n     -1\n }\n \n-#[miri_run]\n fn add() -> i64 {\n     1 + 2\n }\n \n-#[miri_run]\n fn indirect_add() -> i64 {\n     let x = 1;\n     let y = 2;\n     x + y\n }\n \n-#[miri_run]\n fn arith() -> i32 {\n     3*3 + 4*4\n }\n \n-#[miri_run]\n fn match_int() -> i16 {\n     let n = 2;\n     match n {\n@@ -40,7 +31,6 @@ fn match_int() -> i16 {\n     }\n }\n \n-#[miri_run]\n fn match_int_range() -> i64 {\n     let n = 42;\n     match n {\n@@ -53,7 +43,6 @@ fn match_int_range() -> i64 {\n     }\n }\n \n-#[miri_run]\n fn main() {\n     assert_eq!(ret(), 1);\n     assert_eq!(neg(), -1);\n@@ -62,4 +51,8 @@ fn main() {\n     assert_eq!(arith(), 5*5);\n     assert_eq!(match_int(), 20);\n     assert_eq!(match_int_range(), 4);\n+    assert_eq!(i64::min_value().overflowing_mul(-1), (i64::min_value(), true));\n+    assert_eq!(i32::min_value().overflowing_mul(-1), (i32::min_value(), true));\n+    assert_eq!(i16::min_value().overflowing_mul(-1), (i16::min_value(), true));\n+    assert_eq!(i8::min_value().overflowing_mul(-1), (i8::min_value(), true));\n }"}]}