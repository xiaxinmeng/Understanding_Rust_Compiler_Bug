{"sha": "9bb2a742564fc893f5b8e1e605c760798e102765", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYjJhNzQyNTY0ZmM4OTNmNWI4ZTFlNjA1Yzc2MDc5OGUxMDI3NjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-03T16:55:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-03T16:55:34Z"}, "message": "embed file_id into FileSymbol", "tree": {"sha": "04f1672848134a53f143bff86b9658d7751ca29a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04f1672848134a53f143bff86b9658d7751ca29a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bb2a742564fc893f5b8e1e605c760798e102765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb2a742564fc893f5b8e1e605c760798e102765", "html_url": "https://github.com/rust-lang/rust/commit/9bb2a742564fc893f5b8e1e605c760798e102765", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bb2a742564fc893f5b8e1e605c760798e102765/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23d45177e25d6d30945d859a29d516d4058f518f", "url": "https://api.github.com/repos/rust-lang/rust/commits/23d45177e25d6d30945d859a29d516d4058f518f", "html_url": "https://github.com/rust-lang/rust/commit/23d45177e25d6d30945d859a29d516d4058f518f"}], "stats": {"total": 69, "additions": 34, "deletions": 35}, "files": [{"sha": "eae73c2c4907e59e2cc8b243b5ee6cea94449594", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9bb2a742564fc893f5b8e1e605c760798e102765/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb2a742564fc893f5b8e1e605c760798e102765/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=9bb2a742564fc893f5b8e1e605c760798e102765", "patch": "@@ -165,9 +165,11 @@ impl db::RootDatabase {\n                 };\n             }\n             // If that fails try the index based approach.\n-            for (file_id, symbol) in self.index_resolve(name_ref)? {\n-                rr.add_resolution(file_id, symbol);\n-            }\n+            rr.resolves_to.extend(\n+                self.index_resolve(name_ref)?\n+                    .into_iter()\n+                    .map(NavigationTarget::from_symbol),\n+            );\n             return Ok(Some(rr));\n         }\n         if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n@@ -352,13 +354,15 @@ impl db::RootDatabase {\n \n         // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n         let file_symbols = self.index_resolve(name_ref)?;\n-        for (fn_file_id, fs) in file_symbols {\n-            if fs.ptr.kind() == FN_DEF {\n-                let fn_file = self.source_file(fn_file_id);\n-                let fn_def = fs.ptr.resolve(&fn_file);\n+        for symbol in file_symbols {\n+            if symbol.ptr.kind() == FN_DEF {\n+                let fn_file = self.source_file(symbol.file_id);\n+                let fn_def = symbol.ptr.resolve(&fn_file);\n                 let fn_def = ast::FnDef::cast(fn_def.borrowed()).unwrap();\n                 let descr = ctry!(source_binder::function_from_source(\n-                    self, fn_file_id, fn_def\n+                    self,\n+                    symbol.file_id,\n+                    fn_def\n                 )?);\n                 if let Some(descriptor) = descr.signature_info(self) {\n                     // If we have a calling expression let's find which argument we are on\n@@ -438,7 +442,7 @@ impl db::RootDatabase {\n             .collect::<Vec<_>>();\n         Ok(res)\n     }\n-    fn index_resolve(&self, name_ref: ast::NameRef) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+    fn index_resolve(&self, name_ref: ast::NameRef) -> Cancelable<Vec<FileSymbol>> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());\n         query.exact();"}, {"sha": "ab935954c7974826b0adcd5fc2308a6e03bd9c73", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9bb2a742564fc893f5b8e1e605c760798e102765/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb2a742564fc893f5b8e1e605c760798e102765/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=9bb2a742564fc893f5b8e1e605c760798e102765", "patch": "@@ -237,11 +237,11 @@ pub struct NavigationTarget {\n }\n \n impl NavigationTarget {\n-    fn from_symbol(file_id: FileId, symbol: FileSymbol) -> NavigationTarget {\n+    fn from_symbol(symbol: FileSymbol) -> NavigationTarget {\n         NavigationTarget {\n+            file_id: symbol.file_id,\n             name: symbol.name.clone(),\n             kind: symbol.ptr.kind(),\n-            file_id,\n             range: symbol.ptr.range(),\n             ptr: Some(symbol.ptr.clone()),\n         }\n@@ -278,11 +278,6 @@ impl ReferenceResolution {\n             resolves_to: Vec::new(),\n         }\n     }\n-\n-    fn add_resolution(&mut self, file_id: FileId, symbol: FileSymbol) {\n-        self.resolves_to\n-            .push(NavigationTarget::from_symbol(file_id, symbol))\n-    }\n }\n \n /// `AnalysisHost` stores the current state of the world.\n@@ -380,7 +375,7 @@ impl Analysis {\n     pub fn symbol_search(&self, query: Query) -> Cancelable<Vec<NavigationTarget>> {\n         let res = symbol_index::world_symbols(&*self.db, query)?\n             .into_iter()\n-            .map(|(file_id, symbol)| NavigationTarget::from_symbol(file_id, symbol))\n+            .map(NavigationTarget::from_symbol)\n             .collect();\n         Ok(res)\n     }"}, {"sha": "b355b14ed3ece8a737a92324cf2b5cdf352dc85b", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9bb2a742564fc893f5b8e1e605c760798e102765/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb2a742564fc893f5b8e1e605c760798e102765/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=9bb2a742564fc893f5b8e1e605c760798e102765", "patch": "@@ -58,10 +58,7 @@ fn file_symbols(db: &impl SyntaxDatabase, file_id: FileId) -> Cancelable<Arc<Sym\n     Ok(Arc::new(SymbolIndex::for_file(file_id, syntax)))\n }\n \n-pub(crate) fn world_symbols(\n-    db: &RootDatabase,\n-    query: Query,\n-) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+pub(crate) fn world_symbols(db: &RootDatabase, query: Query) -> Cancelable<Vec<FileSymbol>> {\n     /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n     struct Snap(salsa::Snapshot<RootDatabase>);\n     impl Clone for Snap {\n@@ -95,7 +92,7 @@ pub(crate) fn world_symbols(\n \n #[derive(Default, Debug)]\n pub(crate) struct SymbolIndex {\n-    symbols: Vec<(FileId, FileSymbol)>,\n+    symbols: Vec<FileSymbol>,\n     map: fst::Map,\n }\n \n@@ -126,14 +123,18 @@ impl SymbolIndex {\n                 file.syntax()\n                     .descendants()\n                     .filter_map(to_symbol)\n-                    .map(move |symbol| (symbol.name.as_str().to_lowercase(), (file_id, symbol)))\n+                    .map(move |(name, ptr)| {\n+                        (\n+                            name.as_str().to_lowercase(),\n+                            FileSymbol { name, ptr, file_id },\n+                        )\n+                    })\n                     .collect::<Vec<_>>()\n             })\n             .collect::<Vec<_>>();\n         symbols.par_sort_by(|s1, s2| s1.0.cmp(&s2.0));\n         symbols.dedup_by(|s1, s2| s1.0 == s2.0);\n-        let (names, symbols): (Vec<String>, Vec<(FileId, FileSymbol)>) =\n-            symbols.into_iter().unzip();\n+        let (names, symbols): (Vec<String>, Vec<FileSymbol>) = symbols.into_iter().unzip();\n         let map = fst::Map::from_iter(names.into_iter().zip(0u64..)).unwrap();\n         SymbolIndex { symbols, map }\n     }\n@@ -144,7 +145,7 @@ impl SymbolIndex {\n }\n \n impl Query {\n-    pub(crate) fn search(self, indices: &[Arc<SymbolIndex>]) -> Vec<(FileId, FileSymbol)> {\n+    pub(crate) fn search(self, indices: &[Arc<SymbolIndex>]) -> Vec<FileSymbol> {\n         let mut op = fst::map::OpBuilder::new();\n         for file_symbols in indices.iter() {\n             let automaton = fst::automaton::Subsequence::new(&self.lowercased);\n@@ -160,14 +161,14 @@ impl Query {\n                 let file_symbols = &indices[indexed_value.index];\n                 let idx = indexed_value.value as usize;\n \n-                let (file_id, symbol) = &file_symbols.symbols[idx];\n+                let symbol = &file_symbols.symbols[idx];\n                 if self.only_types && !is_type(symbol.ptr.kind()) {\n                     continue;\n                 }\n                 if self.exact && symbol.name != self.query {\n                     continue;\n                 }\n-                res.push((*file_id, symbol.clone()));\n+                res.push(symbol.clone());\n             }\n         }\n         res\n@@ -185,17 +186,16 @@ fn is_type(kind: SyntaxKind) -> bool {\n /// possible.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub(crate) struct FileSymbol {\n+    pub(crate) file_id: FileId,\n     pub(crate) name: SmolStr,\n     pub(crate) ptr: LocalSyntaxPtr,\n }\n \n-fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n-    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<FileSymbol> {\n-        let name = node.name()?;\n-        Some(FileSymbol {\n-            name: name.text(),\n-            ptr: LocalSyntaxPtr::new(node.syntax()),\n-        })\n+fn to_symbol(node: SyntaxNodeRef) -> Option<(SmolStr, LocalSyntaxPtr)> {\n+    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<(SmolStr, LocalSyntaxPtr)> {\n+        let name = node.name()?.text();\n+        let ptr = LocalSyntaxPtr::new(node.syntax());\n+        Some((name, ptr))\n     }\n     visitor()\n         .visit(decl::<ast::FnDef>)"}]}