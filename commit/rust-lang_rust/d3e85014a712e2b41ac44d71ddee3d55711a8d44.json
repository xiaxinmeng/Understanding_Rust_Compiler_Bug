{"sha": "d3e85014a712e2b41ac44d71ddee3d55711a8d44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZTg1MDE0YTcxMmUyYjQxYWM0NGQ3MWRkZWUzZDU1NzExYThkNDQ=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-21T09:23:42Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-01T23:32:50Z"}, "message": "Process mentioned upvars for analysis first pass after ExprUseVisitor\n\n- This allows us add fake information after handling migrations if\n  needed.\n- Capture analysis also priortizes what we see earlier, which means\n  fake information should go in last.", "tree": {"sha": "994637af6dbb3a47ad12cb320ee918e8e7c5a499", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/994637af6dbb3a47ad12cb320ee918e8e7c5a499"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3e85014a712e2b41ac44d71ddee3d55711a8d44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e85014a712e2b41ac44d71ddee3d55711a8d44", "html_url": "https://github.com/rust-lang/rust/commit/d3e85014a712e2b41ac44d71ddee3d55711a8d44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3e85014a712e2b41ac44d71ddee3d55711a8d44/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf4bdd95c3843ef1922e62ef5ace146dae8f43a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4bdd95c3843ef1922e62ef5ace146dae8f43a7", "html_url": "https://github.com/rust-lang/rust/commit/bf4bdd95c3843ef1922e62ef5ace146dae8f43a7"}], "stats": {"total": 119, "additions": 68, "deletions": 51}, "files": [{"sha": "56b91ee4bcbd35ef9317a5076af7f6da51cef8c1", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 62, "deletions": 45, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d3e85014a712e2b41ac44d71ddee3d55711a8d44/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e85014a712e2b41ac44d71ddee3d55711a8d44/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=d3e85014a712e2b41ac44d71ddee3d55711a8d44", "patch": "@@ -40,7 +40,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n \n@@ -55,6 +55,11 @@ enum PlaceAncestryRelation {\n     Divergent,\n }\n \n+/// Intermediate format to store a captured `Place` and associated `ty::CaptureInfo`\n+/// during capture analysis. Information in this map feeds into the minimum capture\n+/// analysis pass.\n+type InferredCaptureInformation<'tcx> = FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n         InferBorrowKindVisitor { fcx: self }.visit_body(body);\n@@ -124,28 +129,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let local_def_id = closure_def_id.expect_local();\n \n-        let mut capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>> =\n-            Default::default();\n-        if !self.tcx.features().capture_disjoint_fields {\n-            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-                for (&var_hir_id, _) in upvars.iter() {\n-                    let place = self.place_for_root_variable(local_def_id, var_hir_id);\n-\n-                    debug!(\"seed place {:?}\", place);\n-\n-                    let upvar_id = ty::UpvarId::new(var_hir_id, local_def_id);\n-                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n-                    let info = ty::CaptureInfo {\n-                        capture_kind_expr_id: None,\n-                        path_expr_id: None,\n-                        capture_kind,\n-                    };\n-\n-                    capture_information.insert(place, info);\n-                }\n-            }\n-        }\n-\n         let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n         assert_eq!(body_owner_def_id.to_def_id(), closure_def_id);\n         let mut delegate = InferBorrowKind {\n@@ -155,7 +138,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             capture_clause,\n             current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n             current_origin: None,\n-            capture_information,\n+            capture_information: Default::default(),\n         };\n         euv::ExprUseVisitor::new(\n             &mut delegate,\n@@ -172,6 +155,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         self.log_capture_analysis_first_pass(closure_def_id, &delegate.capture_information, span);\n \n+        self.compute_min_captures(closure_def_id, delegate.capture_information);\n+\n+        // We now fake capture information for all variables that are mentioned within the closure\n+        // We do this after handling migrations so that min_captures computes before\n+        if !self.tcx.features().capture_disjoint_fields {\n+            let mut capture_information: InferredCaptureInformation<'tcx> = Default::default();\n+\n+            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+                for var_hir_id in upvars.keys() {\n+                    let place = self.place_for_root_variable(local_def_id, *var_hir_id);\n+\n+                    debug!(\"seed place {:?}\", place);\n+\n+                    let upvar_id = ty::UpvarId::new(*var_hir_id, local_def_id);\n+                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n+                    let fake_info = ty::CaptureInfo {\n+                        capture_kind_expr_id: None,\n+                        path_expr_id: None,\n+                        capture_kind,\n+                    };\n+\n+                    capture_information.insert(place, fake_info);\n+                }\n+            }\n+\n+            // This will update the min captures based on this new fake information.\n+            self.compute_min_captures(closure_def_id, capture_information);\n+        }\n+\n         if let Some(closure_substs) = infer_kind {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n@@ -197,7 +209,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.compute_min_captures(closure_def_id, delegate);\n         self.log_closure_min_capture_info(closure_def_id, span);\n \n         self.min_captures_to_closure_captures_bridge(closure_def_id);\n@@ -344,6 +355,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Places (and corresponding capture kind) that we need to keep track of to support all\n     /// the required captured paths.\n     ///\n+    ///\n+    /// Note: If this function is called multiple times for the same closure, it will update\n+    ///       the existing min_capture map that is stored in TypeckResults.\n+    ///\n     /// Eg:\n     /// ```rust,no_run\n     /// struct Point { x: i32, y: i32 }\n@@ -408,11 +423,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn compute_min_captures(\n         &self,\n         closure_def_id: DefId,\n-        inferred_info: InferBorrowKind<'_, 'tcx>,\n+        capture_information: InferredCaptureInformation<'tcx>,\n     ) {\n-        let mut root_var_min_capture_list: ty::RootVariableMinCaptureList<'_> = Default::default();\n+        if capture_information.is_empty() {\n+            return;\n+        }\n+\n+        let mut typeck_results = self.typeck_results.borrow_mut();\n \n-        for (place, capture_info) in inferred_info.capture_information.into_iter() {\n+        let mut root_var_min_capture_list =\n+            typeck_results.closure_min_captures.remove(&closure_def_id).unwrap_or_default();\n+\n+        for (place, capture_info) in capture_information.into_iter() {\n             let var_hir_id = match place.base {\n                 PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n@@ -422,7 +444,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n-                    let mutability = self.determine_capture_mutability(&place);\n+                    let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                     let min_cap_list =\n                         vec![ty::CapturedPlace { place, info: capture_info, mutability }];\n                     root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n@@ -487,21 +509,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Only need to insert when we don't have an ancestor in the existing min capture list\n             if !ancestor_found {\n-                let mutability = self.determine_capture_mutability(&place);\n+                let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let captured_place =\n                     ty::CapturedPlace { place, info: updated_capture_info, mutability };\n                 min_cap_list.push(captured_place);\n             }\n         }\n \n         debug!(\"For closure={:?}, min_captures={:#?}\", closure_def_id, root_var_min_capture_list);\n-\n-        if !root_var_min_capture_list.is_empty() {\n-            self.typeck_results\n-                .borrow_mut()\n-                .closure_min_captures\n-                .insert(closure_def_id, root_var_min_capture_list);\n-        }\n+        typeck_results.closure_min_captures.insert(closure_def_id, root_var_min_capture_list);\n     }\n \n     fn init_capture_kind(\n@@ -613,18 +629,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// A captured place is mutable if\n     /// 1. Projections don't include a Deref of an immut-borrow, **and**\n     /// 2. PlaceBase is mut or projections include a Deref of a mut-borrow.\n-    fn determine_capture_mutability(&self, place: &Place<'tcx>) -> hir::Mutability {\n+    fn determine_capture_mutability(\n+        &self,\n+        typeck_results: &'a TypeckResults<'tcx>,\n+        place: &Place<'tcx>,\n+    ) -> hir::Mutability {\n         let var_hir_id = match place.base {\n             PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n             _ => unreachable!(),\n         };\n \n-        let bm = *self\n-            .typeck_results\n-            .borrow()\n-            .pat_binding_modes()\n-            .get(var_hir_id)\n-            .expect(\"missing binding mode\");\n+        let bm = *typeck_results.pat_binding_modes().get(var_hir_id).expect(\"missing binding mode\");\n \n         let mut is_mutbl = match bm {\n             ty::BindByValue(mutability) => mutability,\n@@ -698,9 +713,11 @@ struct InferBorrowKind<'a, 'tcx> {\n     ///\n     /// For closure `fix_s`, (at a high level) the map contains\n     ///\n+    /// ```\n     /// Place { V1, [ProjectionKind::Field(Index=0, Variant=0)] } : CaptureKind { E1, ImmutableBorrow }\n     /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n-    capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n+    /// ```\n+    capture_information: InferredCaptureInformation<'tcx>,\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {"}, {"sha": "e1b446fc61f612215a85f95d1702a450a7356d00", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3e85014a712e2b41ac44d71ddee3d55711a8d44/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3e85014a712e2b41ac44d71ddee3d55711a8d44/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=d3e85014a712e2b41ac44d71ddee3d55711a8d44", "patch": "@@ -7,10 +7,10 @@ LL |             let mut closure1 = || p = &y;\n    = note: defining type: test::{closure#0}::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: external requirements\n   --> $DIR/escape-upvar-nested.rs:20:27\n@@ -25,10 +25,10 @@ LL | |         };\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: no external requirements\n   --> $DIR/escape-upvar-nested.rs:13:1"}, {"sha": "0ea1076c32ef4dd215be4056d3e9cefef645d3b5", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e85014a712e2b41ac44d71ddee3d55711a8d44/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3e85014a712e2b41ac44d71ddee3d55711a8d44/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=d3e85014a712e2b41ac44d71ddee3d55711a8d44", "patch": "@@ -7,10 +7,10 @@ LL |         let mut closure = || p = &y;\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: no external requirements\n   --> $DIR/escape-upvar-ref.rs:17:1"}]}