{"sha": "18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZDEyNGI5YjVkY2I5OTE1ZTVlMTQ4OWVlZDgxZWQ2YThiOTBjMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-01T13:01:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-01T13:01:39Z"}, "message": "auto merge of #8158 : bblum/rust/task-cleanup, r=brson\n\nr? @brson", "tree": {"sha": "08815543f7ba4e527622ab5c654f87b17d91c252", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08815543f7ba4e527622ab5c654f87b17d91c252"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "html_url": "https://github.com/rust-lang/rust/commit/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9824d90ffd7684eca7171c4e019fd85b9317904e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9824d90ffd7684eca7171c4e019fd85b9317904e", "html_url": "https://github.com/rust-lang/rust/commit/9824d90ffd7684eca7171c4e019fd85b9317904e"}, {"sha": "bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "html_url": "https://github.com/rust-lang/rust/commit/bc7cee7bbf816be7a712c06a93015dc3c6fd5611"}], "stats": {"total": 213, "additions": 139, "deletions": 74}, "files": [{"sha": "c2571f171a17257a09d0539875eb4aa3ac850edf", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -84,7 +84,7 @@ pub struct Death {\n     on_exit:         Option<~fn(bool)>,\n     // nesting level counter for task::unkillable calls (0 == killable).\n     unkillable:      int,\n-    // nesting level counter for task::atomically calls (0 == can yield).\n+    // nesting level counter for unstable::atomically calls (0 == can yield).\n     wont_sleep:      int,\n     // A \"spare\" handle to the kill flag inside the kill handle. Used during\n     // blocking/waking as an optimization to avoid two xadds on the refcount."}, {"sha": "8648832c591af0be357e009120ca4a32e380d797", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -316,12 +316,14 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n             // Just put an unpinned task onto one of the default schedulers.\n             let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, main);\n             main_task.death.on_exit = Some(on_exit);\n+            main_task.name = Some(~\"main\");\n             scheds[0].enqueue_task(main_task);\n         }\n         Some(ref mut main_sched) => {\n             let home = Sched(main_sched.make_handle());\n             let mut main_task = ~Task::new_root_homed(&mut scheds[0].stack_pool, home, main);\n             main_task.death.on_exit = Some(on_exit);\n+            main_task.name = Some(~\"main\");\n             main_sched.enqueue_task(main_task);\n         }\n     };"}, {"sha": "c1b799796d1587e067d9a3a2192141c6de02636e", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -40,7 +40,9 @@ pub struct Task {\n     taskgroup: Option<Taskgroup>,\n     death: Death,\n     destroyed: bool,\n-    coroutine: Option<~Coroutine>\n+    coroutine: Option<~Coroutine>,\n+    // FIXME(#6874/#7599) use StringRef to save on allocations\n+    name: Option<~str>,\n }\n \n pub struct Coroutine {\n@@ -90,7 +92,8 @@ impl Task {\n             taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n-            coroutine: Some(~Coroutine::new(stack_pool, start))\n+            coroutine: Some(~Coroutine::new(stack_pool, start)),\n+            name: None,\n         }\n     }\n \n@@ -109,7 +112,8 @@ impl Task {\n             // FIXME(#7544) make watching optional\n             death: self.death.new_child(),\n             destroyed: false,\n-            coroutine: Some(~Coroutine::new(stack_pool, start))\n+            coroutine: Some(~Coroutine::new(stack_pool, start)),\n+            name: None,\n         }\n     }\n "}, {"sha": "4ca5d82265fbf7e6911cc21412e7546eeb61d38e", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -137,12 +137,13 @@ impl FailWithCause for &'static str {\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    use cell::Cell;\n     use either::Left;\n+    use option::{Some, None};\n     use rt::{context, OldTaskContext, TaskContext};\n     use rt::task::Task;\n     use rt::local::Local;\n     use rt::logging::Logger;\n+    use str::Str;\n \n     let context = context();\n     match context {\n@@ -159,20 +160,26 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                 let msg = str::raw::from_c_str(msg);\n                 let file = str::raw::from_c_str(file);\n \n-                let outmsg = fmt!(\"task failed at '%s', %s:%i\",\n-                                  msg, file, line as int);\n-\n                 // XXX: Logging doesn't work correctly in non-task context because it\n                 // invokes the local heap\n                 if context == TaskContext {\n                     // XXX: Logging doesn't work here - the check to call the log\n                     // function never passes - so calling the log function directly.\n-                    let outmsg = Cell::new(outmsg);\n                     do Local::borrow::<Task, ()> |task| {\n-                        task.logger.log(Left(outmsg.take()));\n+                        let msg = match task.name {\n+                            Some(ref name) =>\n+                                fmt!(\"task '%s' failed at '%s', %s:%i\",\n+                                     name.as_slice(), msg, file, line as int),\n+                            None =>\n+                                fmt!(\"task <unnamed> failed at '%s', %s:%i\",\n+                                     msg, file, line as int)\n+                        };\n+\n+                        task.logger.log(Left(msg));\n                     }\n                 } else {\n-                    rterrln!(\"%s\", outmsg);\n+                    rterrln!(\"failed in non-task context at '%s', %s:%i\",\n+                             msg, file, line as int);\n                 }\n \n                 gc::cleanup_stack_for_failure();"}, {"sha": "aff4bc12039fcaa10d59cd14615ce5888c7c2163", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -120,6 +120,8 @@ pub struct SchedOpts {\n  *\n  * * notify_chan - Enable lifecycle notifications on the given channel\n  *\n+ * * name - A name for the task-to-be, for identification in failure messages.\n+ *\n  * * sched - Specify the configuration of a new scheduler to create the task\n  *           in\n  *\n@@ -139,6 +141,7 @@ pub struct TaskOpts {\n     watched: bool,\n     indestructible: bool,\n     notify_chan: Option<Chan<TaskResult>>,\n+    name: Option<~str>,\n     sched: SchedOpts\n }\n \n@@ -185,23 +188,23 @@ impl TaskBuilder {\n         self.consumed = true;\n         let gen_body = self.gen_body.take();\n         let notify_chan = self.opts.notify_chan.take();\n+        let name = self.opts.name.take();\n         TaskBuilder {\n             opts: TaskOpts {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n                 watched: self.opts.watched,\n                 indestructible: self.opts.indestructible,\n                 notify_chan: notify_chan,\n+                name: name,\n                 sched: self.opts.sched\n             },\n             gen_body: gen_body,\n             can_not_copy: None,\n             consumed: false\n         }\n     }\n-}\n \n-impl TaskBuilder {\n     /// Decouple the child task's failure from the parent's. If either fails,\n     /// the other will not be killed.\n     pub fn unlinked(&mut self) {\n@@ -281,6 +284,12 @@ impl TaskBuilder {\n         self.opts.notify_chan = Some(notify_pipe_ch);\n     }\n \n+    /// Name the task-to-be. Currently the name is used for identification\n+    /// only in failure messages.\n+    pub fn name(&mut self, name: ~str) {\n+        self.opts.name = Some(name);\n+    }\n+\n     /// Configure a custom scheduler mode for the task.\n     pub fn sched_mode(&mut self, mode: SchedMode) {\n         self.opts.sched.mode = mode;\n@@ -333,13 +342,15 @@ impl TaskBuilder {\n     pub fn spawn(&mut self, f: ~fn()) {\n         let gen_body = self.gen_body.take();\n         let notify_chan = self.opts.notify_chan.take();\n+        let name = self.opts.name.take();\n         let x = self.consume();\n         let opts = TaskOpts {\n             linked: x.opts.linked,\n             supervised: x.opts.supervised,\n             watched: x.opts.watched,\n             indestructible: x.opts.indestructible,\n             notify_chan: notify_chan,\n+            name: name,\n             sched: x.opts.sched\n         };\n         let f = match gen_body {\n@@ -408,6 +419,7 @@ pub fn default_task_opts() -> TaskOpts {\n         watched: true,\n         indestructible: false,\n         notify_chan: None,\n+        name: None,\n         sched: SchedOpts {\n             mode: DefaultScheduler,\n         }\n@@ -507,6 +519,21 @@ pub fn try<T:Send>(f: ~fn() -> T) -> Result<T,()> {\n \n /* Lifecycle functions */\n \n+/// Read the name of the current task.\n+pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n+    use rt::task::Task;\n+\n+    match context() {\n+        TaskContext => do Local::borrow::<Task, U> |task| {\n+            match task.name {\n+                Some(ref name) => blk(Some(name.as_slice())),\n+                None => blk(None)\n+            }\n+        },\n+        _ => fail!(\"no task name exists in %?\", context()),\n+    }\n+}\n+\n pub fn yield() {\n     //! Yield control to the task scheduler\n \n@@ -628,44 +655,6 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n     }\n }\n \n-/**\n- * A stronger version of unkillable that also inhibits scheduling operations.\n- * For use with exclusive Arcs, which use pthread mutexes directly.\n- */\n-pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    use rt::task::Task;\n-\n-    match context() {\n-        OldTaskContext => {\n-            let t = rt::rust_get_task();\n-            do (|| {\n-                rt::rust_task_inhibit_kill(t);\n-                rt::rust_task_inhibit_yield(t);\n-                f()\n-            }).finally {\n-                rt::rust_task_allow_yield(t);\n-                rt::rust_task_allow_kill(t);\n-            }\n-        }\n-        TaskContext => {\n-            let t = Local::unsafe_borrow::<Task>();\n-            do (|| {\n-                // It's important to inhibit kill after inhibiting yield, because\n-                // inhibit-kill might fail if we were already killed, and the\n-                // inhibit-yield must happen to match the finally's allow-yield.\n-                (*t).death.inhibit_yield();\n-                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n-                f()\n-            }).finally {\n-                (*t).death.allow_kill((*t).unwinder.unwinding);\n-                (*t).death.allow_yield();\n-            }\n-        }\n-        // FIXME(#3095): As in unkillable().\n-        _ => f()\n-    }\n-}\n-\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_cant_dup_task_builder() {\n     let mut builder = task();\n@@ -805,6 +794,34 @@ fn test_spawn_linked_sup_propagate_sibling() {\n     fail!();\n }\n \n+#[test]\n+fn test_unnamed_task() {\n+    use rt::test::run_in_newsched_task;\n+\n+    do run_in_newsched_task {\n+        do spawn {\n+            do with_task_name |name| {\n+                assert!(name.is_none());\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_named_task() {\n+    use rt::test::run_in_newsched_task;\n+\n+    do run_in_newsched_task {\n+        let mut t = task();\n+        t.name(~\"ada lovelace\");\n+        do t.spawn {\n+            do with_task_name |name| {\n+                assert!(name.get() == \"ada lovelace\");\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_run_basic() {\n     let (po, ch) = stream::<()>();\n@@ -1122,21 +1139,6 @@ fn test_unkillable_nested() {\n     po.recv();\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_atomically() {\n-    unsafe { do atomically { yield(); } }\n-}\n-\n-#[test]\n-fn test_atomically2() {\n-    unsafe { do atomically { } } yield(); // shouldn't fail\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_atomically_nested() {\n-    unsafe { do atomically { do atomically { } yield(); } }\n-}\n-\n #[test]\n fn test_child_doesnt_ref_parent() {\n     // If the child refcounts the parent task, this will stack overflow when"}, {"sha": "81db5e690a66f7ba494be8fac78b6759b44e47b6", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -725,6 +725,8 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n         task.death.on_exit = Some(on_exit);\n     }\n \n+    task.name = opts.name.take();\n+\n     rtdebug!(\"spawn about to take scheduler\");\n \n     let sched = Local::take::<Scheduler>();"}, {"sha": "ab44520454d62220a65915c1fec7f98d247c4245", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -105,7 +105,7 @@ mod dl {\n     use path;\n     use ptr;\n     use str;\n-    use task;\n+    use unstable::sync::atomically;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -120,7 +120,7 @@ mod dl {\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n         unsafe {\n-            do task::atomically {\n+            do atomically {\n                 let _old_error = dlerror();\n \n                 let result = f();\n@@ -164,7 +164,7 @@ mod dl {\n     use libc;\n     use path;\n     use ptr;\n-    use task;\n+    use unstable::sync::atomically;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -181,7 +181,7 @@ mod dl {\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n         unsafe {\n-            do task::atomically {\n+            do atomically {\n                 SetLastError(0);\n \n                 let result = f();"}, {"sha": "f721dd47a66a0f826027eb27fd3a7934c179d47e", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -85,15 +85,15 @@ fn test_run_in_bare_thread_exchange() {\n pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n     use os;\n     use os::change_dir;\n-    use task;\n+    use unstable::sync::atomically;\n     use unstable::finally::Finally;\n \n     unsafe {\n         // This is really sketchy. Using a pthread mutex so descheduling\n         // in the `action` callback can cause deadlock. Doing it in\n         // `task::atomically` to try to avoid that, but ... I don't know\n         // this is all bogus.\n-        return do task::atomically {\n+        return do atomically {\n             rust_take_change_dir_lock();\n \n             do (||{"}, {"sha": "e865d3a467dd4d4221dbe69e72c3749673387966", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d124b9b5dcb9915e5e1489eed81ed6a8b90c39/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=18d124b9b5dcb9915e5e1489eed81ed6a8b90c39", "patch": "@@ -16,7 +16,6 @@ use ptr;\n use option::*;\n use either::{Either, Left, Right};\n use task;\n-use task::atomically;\n use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,SeqCst};\n use unstable::finally::Finally;\n use ops::Drop;\n@@ -271,6 +270,48 @@ impl<T> Drop for UnsafeAtomicRcBox<T>{\n \n /****************************************************************************/\n \n+/**\n+ * Enables a runtime assertion that no operation in the argument closure shall\n+ * use scheduler operations (yield, recv, spawn, etc). This is for use with\n+ * pthread mutexes, which may block the entire scheduler thread, rather than\n+ * just one task, and is hence prone to deadlocks if mixed with yielding.\n+ *\n+ * NOTE: THIS DOES NOT PROVIDE LOCKING, or any sort of critical-section\n+ * synchronization whatsoever. It only makes sense to use for CPU-local issues.\n+ */\n+// FIXME(#8140) should not be pub\n+pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n+    use rt::task::Task;\n+    use task::rt;\n+    use rt::local::Local;\n+    use rt::{context, OldTaskContext, TaskContext};\n+\n+    match context() {\n+        OldTaskContext => {\n+            let t = rt::rust_get_task();\n+            do (|| {\n+                rt::rust_task_inhibit_kill(t);\n+                rt::rust_task_inhibit_yield(t);\n+                f()\n+            }).finally {\n+                rt::rust_task_allow_yield(t);\n+                rt::rust_task_allow_kill(t);\n+            }\n+        }\n+        TaskContext => {\n+            let t = Local::unsafe_borrow::<Task>();\n+            do (|| {\n+                (*t).death.inhibit_yield();\n+                f()\n+            }).finally {\n+                (*t).death.allow_yield();\n+            }\n+        }\n+        // FIXME(#3095): As in unkillable().\n+        _ => f()\n+    }\n+}\n+\n #[allow(non_camel_case_types)] // runtime type\n type rust_little_lock = *libc::c_void;\n \n@@ -395,11 +436,18 @@ mod tests {\n     use cell::Cell;\n     use comm;\n     use option::*;\n-    use super::{Exclusive, UnsafeAtomicRcBox};\n+    use super::{Exclusive, UnsafeAtomicRcBox, atomically};\n     use task;\n     use uint;\n     use util;\n \n+    #[test]\n+    fn test_atomically() {\n+        // NB. The whole runtime will abort on an 'atomic-sleep' violation,\n+        // so we can't really test for the converse behaviour.\n+        unsafe { do atomically { } } task::yield(); // oughtn't fail\n+    }\n+\n     #[test]\n     fn exclusive_new_arc() {\n         unsafe {"}]}