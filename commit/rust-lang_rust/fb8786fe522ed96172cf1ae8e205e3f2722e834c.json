{"sha": "fb8786fe522ed96172cf1ae8e205e3f2722e834c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiODc4NmZlNTIyZWQ5NjE3MmNmMWFlOGUyMDVlM2YyNzIyZTgzNGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-07T14:37:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-07T14:54:11Z"}, "message": "Refactor fn_ty, working towards #3320", "tree": {"sha": "7021370b9bb017b64ba4e9780f0570cd563db244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7021370b9bb017b64ba4e9780f0570cd563db244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb8786fe522ed96172cf1ae8e205e3f2722e834c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb8786fe522ed96172cf1ae8e205e3f2722e834c", "html_url": "https://github.com/rust-lang/rust/commit/fb8786fe522ed96172cf1ae8e205e3f2722e834c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb8786fe522ed96172cf1ae8e205e3f2722e834c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "699505899ece6339a892f252efb085fe301776b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/699505899ece6339a892f252efb085fe301776b6", "html_url": "https://github.com/rust-lang/rust/commit/699505899ece6339a892f252efb085fe301776b6"}], "stats": {"total": 1268, "additions": 699, "deletions": 569}, "files": [{"sha": "b738295d262b19c4d10cb2b21a6ab42e0553055a", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -585,7 +585,7 @@ fn get_enum_variants(intr: ident_interner, cdata: cmd, id: ast::node_id,\n         let mut arg_tys: ~[ty::t] = ~[];\n         match ty::get(ctor_ty).struct {\n           ty::ty_fn(f) => {\n-            for f.inputs.each |a| { vec::push(arg_tys, a.ty); }\n+            for f.sig.inputs.each |a| { vec::push(arg_tys, a.ty); }\n           }\n           _ => { /* Nullary enum variant. */ }\n         }"}, {"sha": "803c9967d0cf2581d029e9ef36d91ff0582e9d6a", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -750,7 +750,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx, ty_m.tps);\n                 encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n+                encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 ebml_w.end_tag();\n               }"}, {"sha": "8fe58a93824b1e9b2c4b2d8c2a986feff4e63913", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -9,6 +9,7 @@ use syntax::ast_util;\n use syntax::ast_util::respan;\n use middle::ty;\n use std::map::hashmap;\n+use ty::{FnTyBase, FnMeta, FnSig};\n \n export parse_ty_data, parse_def_id, parse_ident;\n export parse_bounds_data;\n@@ -274,7 +275,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         parse_ty_rust_fn(st, conv)\n       }\n       'X' => {\n-        return ty::mk_var(st.tcx, ty::ty_vid(parse_int(st) as uint));\n+        return ty::mk_var(st.tcx, ty::TyVid(parse_int(st) as uint));\n       }\n       'Y' => return ty::mk_type(st.tcx),\n       'C' => {\n@@ -372,7 +373,7 @@ fn parse_purity(c: char) -> purity {\n     }\n }\n \n-fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n+fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n     let proto = parse_proto(st);\n     let purity = parse_purity(next(st));\n     let bounds = parse_bounds(st, conv);\n@@ -392,8 +393,14 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     }\n     st.pos += 1u; // eat the ']'\n     let (ret_style, ret_ty) = parse_ret_ty(st, conv);\n-    return {purity: purity, proto: proto, bounds: bounds, inputs: inputs,\n-            output: ret_ty, ret_style: ret_style};\n+    return FnTyBase {\n+        meta: FnMeta {purity: purity,\n+                      proto: proto,\n+                      bounds: bounds,\n+                      ret_style: ret_style},\n+        sig: FnSig {inputs: inputs,\n+                    output: ret_ty}\n+    };\n }\n \n "}, {"sha": "622ba1a5cce2765568b244c096ce01adade3cb02", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -342,19 +342,19 @@ fn enc_purity(w: io::Writer, p: purity) {\n     }\n }\n \n-fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::fn_ty) {\n-    enc_proto(w, cx, ft.proto);\n-    enc_purity(w, ft.purity);\n-    enc_bounds(w, cx, ft.bounds);\n+fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n+    enc_proto(w, cx, ft.meta.proto);\n+    enc_purity(w, ft.meta.purity);\n+    enc_bounds(w, cx, ft.meta.bounds);\n     w.write_char('[');\n-    for ft.inputs.each |arg| {\n+    for ft.sig.inputs.each |arg| {\n         enc_mode(w, cx, arg.mode);\n         enc_ty(w, cx, arg.ty);\n     }\n     w.write_char(']');\n-    match ft.ret_style {\n+    match ft.meta.ret_style {\n       noreturn => w.write_char('!'),\n-      _ => enc_ty(w, cx, ft.output)\n+      _ => enc_ty(w, cx, ft.sig.output)\n     }\n }\n "}, {"sha": "a81620b20babd461f6e180d8bc33e41683748970", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -218,13 +218,13 @@ impl check_loan_ctxt {\n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n         match ty::get(callee_ty).struct {\n           ty::ty_fn(fn_ty) => {\n-            match fn_ty.purity {\n+            match fn_ty.meta.purity {\n               ast::pure_fn => return, // case (c) above\n               ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n                 self.report_purity_error(\n                     pc, callee_span,\n                     fmt!(\"access to %s function\",\n-                         pprust::purity_to_str(fn_ty.purity)));\n+                         pprust::purity_to_str(fn_ty.meta.purity)));\n               }\n             }\n           }"}, {"sha": "8c2776d3cebef43c80863a0b9160c83ece759018", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -659,7 +659,7 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n     match ty::get(fn_ty).struct {\n       ty::ty_fn(fn_ty) => {\n         let mut counter = 0;\n-        do vec::iter2(fn_ty.inputs, decl.inputs) |arg_ty, arg_ast| {\n+        do vec::iter2(fn_ty.sig.inputs, decl.inputs) |arg_ty, arg_ast| {\n             counter += 1;\n             debug!(\"arg %d, ty=%s, mode=%s\",\n                    counter,"}, {"sha": "acf51691a968cc1d45616610fdb4f9c69aa6998a", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -529,10 +529,10 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let ccx = cx.ccx();\n         let mut cx = cx;\n         match ty::get(fn_ty).struct {\n-          ty::ty_fn({inputs: args, _}) => {\n+          ty::ty_fn(ref fn_ty) => {\n             let mut j = 0u;\n             let v_id = variant.id;\n-            for vec::each(args) |a| {\n+            for vec::each(fn_ty.sig.inputs) |a| {\n                 let llfldp_a = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n                 let ty_subst = ty::subst_tps(ccx.tcx, tps, a.ty);\n                 cx = f(cx, llfldp_a, ty_subst);\n@@ -1984,7 +1984,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n     let main_takes_argv =\n         // invariant!\n         match ty::get(main_node_type).struct {\n-          ty::ty_fn({inputs, _}) => inputs.len() != 0u,\n+          ty::ty_fn(ref fn_ty) => fn_ty.sig.inputs.len() != 0u,\n           _ => ccx.sess.span_fatal(sp, ~\"main has a non-function type\")\n         };\n "}, {"sha": "57fcf66c701cf8d16f6a50bcac708e83293ab32e", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -425,17 +425,15 @@ fn make_fn_glue(\n         }\n     };\n \n-    return match ty::get(t).struct {\n-      ty::ty_fn({proto: ty::proto_bare, _}) |\n-      ty::ty_fn({proto: ty::proto_vstore(ty::vstore_slice(_)), _}) =>\n-        bcx,\n-      ty::ty_fn({proto: ty::proto_vstore(ty::vstore_uniq), _}) =>\n-        fn_env(ty::ck_uniq),\n-      ty::ty_fn({proto: ty::proto_vstore(ty::vstore_box), _}) =>\n-        fn_env(ty::ck_box),\n-      _ =>\n-        fail ~\"make_fn_glue invoked on non-function type\"\n-    };\n+    let proto = ty::ty_fn_proto(t);\n+    match proto {\n+        ty::proto_bare | ty::proto_vstore(ty::vstore_slice(_)) => bcx,\n+        ty::proto_vstore(ty::vstore_uniq) => fn_env(ty::ck_uniq),\n+        ty::proto_vstore(ty::vstore_box) => fn_env(ty::ck_box),\n+        ty::proto_vstore(ty::vstore_fixed(_)) => {\n+            cx.sess().bug(~\"Closure with fixed vstore\");\n+        }\n+    }\n }\n \n fn make_opaque_cbox_take_glue("}, {"sha": "118eff8c53bf3389a031d092198c317883037678", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -447,13 +447,14 @@ fn trans_rvalue_dps(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n         ast::expr_fn_block(decl, body, cap_clause) => {\n             let expr_ty = expr_ty(bcx, expr);\n             match ty::get(expr_ty).struct {\n-                ty::ty_fn({proto, _}) => {\n+                ty::ty_fn(ref fn_ty) => {\n                     debug!(\"translating fn_block %s with type %s\",\n                            expr_to_str(expr, tcx.sess.intr()),\n                            ty_to_str(tcx, expr_ty));\n-                    return closure::trans_expr_fn(bcx, proto, decl, body,\n-                                                  expr.id, cap_clause, None,\n-                                                  dest);\n+                    return closure::trans_expr_fn(\n+                        bcx, fn_ty.meta.proto, decl, body,\n+                        expr.id, cap_clause, None,\n+                        dest);\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n@@ -463,11 +464,11 @@ fn trans_rvalue_dps(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n         }\n         ast::expr_loop_body(blk) => {\n             match ty::get(expr_ty(bcx, expr)).struct {\n-                ty::ty_fn({proto, _}) => {\n+                ty::ty_fn(ref fn_ty) => {\n                     match blk.node {\n                         ast::expr_fn_block(decl, body, cap) => {\n                             return closure::trans_expr_fn(\n-                                bcx, proto, decl, body, blk.id,\n+                                bcx, fn_ty.meta.proto, decl, body, blk.id,\n                                 cap, Some(None), dest);\n                         }\n                         _ => {"}, {"sha": "bb5ea98e1b4932f1c6e9785e01400e14f0d8e8dd", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -20,6 +20,7 @@ use util::ppaux::ty_to_str;\n use datum::*;\n use callee::*;\n use expr::{Dest, Ignore};\n+use ty::{FnTyBase, FnMeta, FnSig};\n \n export link_name, trans_foreign_mod, register_foreign_fn, trans_foreign_fn,\n        trans_intrinsic;\n@@ -439,12 +440,12 @@ type c_stack_tys = {\n fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n                        id: ast::node_id) -> (~[TypeRef], TypeRef, ty::t) {\n     match ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n-      ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) => {\n-        let llargtys = type_of_explicit_args(ccx, arg_tys);\n-        let llretty = type_of::type_of(ccx, ret_ty);\n-        (llargtys, llretty, ret_ty)\n-      }\n-      _ => ccx.sess.bug(~\"c_arg_and_ret_lltys called on non-function type\")\n+        ty::ty_fn(ref fn_ty) => {\n+            let llargtys = type_of_explicit_args(ccx, fn_ty.sig.inputs);\n+            let llretty = type_of::type_of(ccx, fn_ty.sig.output);\n+            (llargtys, llretty, fn_ty.sig.output)\n+        }\n+        _ => ccx.sess.bug(~\"c_arg_and_ret_lltys called on non-function type\")\n     }\n }\n \n@@ -953,20 +954,19 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         ~\"frame_address\" => {\n             let frameaddress = ccx.intrinsics.get(~\"llvm.frameaddress\");\n             let frameaddress_val = Call(bcx, frameaddress, ~[C_i32(0i32)]);\n-            let fty = ty::mk_fn(bcx.tcx(), {\n-                purity: ast::impure_fn,\n-                proto:\n-                    ty::proto_vstore(ty::vstore_slice(\n-                        ty::re_bound(ty::br_anon(0)))),\n-                bounds: @~[],\n-                inputs: ~[{\n-                    mode: ast::expl(ast::by_val),\n-                    ty: ty::mk_imm_ptr(\n-                        bcx.tcx(),\n-                        ty::mk_mach_uint(bcx.tcx(), ast::ty_u8))\n-                }],\n-                output: ty::mk_nil(bcx.tcx()),\n-                ret_style: ast::return_val\n+            let star_u8 = ty::mk_imm_ptr(\n+                bcx.tcx(),\n+                ty::mk_mach_uint(bcx.tcx(), ast::ty_u8));\n+            let fty = ty::mk_fn(bcx.tcx(), FnTyBase {\n+                meta: FnMeta {purity: ast::impure_fn,\n+                              proto:\n+                                  ty::proto_vstore(ty::vstore_slice(\n+                                      ty::re_bound(ty::br_anon(0)))),\n+                              bounds: @~[],\n+                              ret_style: ast::return_val},\n+                sig: FnSig {inputs: ~[{mode: ast::expl(ast::by_val),\n+                                       ty: star_u8}],\n+                            output: ty::mk_nil(bcx.tcx())}\n             });\n             let datum = Datum {val: get_param(decl, first_real_arg),\n                                mode: ByRef, ty: fty, source: FromLvalue};"}, {"sha": "a0df372173d73852b220aee8ba9e19d036f5593d", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -10,6 +10,7 @@ use base::{trans_item, get_item_val, no_self, self_arg, trans_fn,\n use syntax::parse::token::special_idents;\n use type_of::type_of_fn_from_ty;\n use back::link::mangle_exported_name;\n+use middle::ty::{FnTyBase, FnMeta, FnSig};\n \n fn monomorphic_fn(ccx: @crate_ctxt,\n                   fn_id: ast::def_id,\n@@ -198,27 +199,36 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> Option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n     match ty::get(ty).struct {\n-      ty::ty_box(*) => {\n-        Some(ty::mk_opaque_box(tcx))\n-      }\n-      ty::ty_fn(ref fty) => {\n-        Some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n-                             proto: fty.proto,\n-                             bounds: @~[],\n-                             inputs: ~[],\n-                             output: ty::mk_nil(tcx),\n-                             ret_style: ast::return_val}))\n-      }\n-      ty::ty_trait(_, _, _) => {\n-        Some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n-                             proto: ty::proto_vstore(ty::vstore_box),\n-                             bounds: @~[],\n-                             inputs: ~[],\n-                             output: ty::mk_nil(tcx),\n-                             ret_style: ast::return_val}))\n-      }\n-      ty::ty_ptr(_) => Some(ty::mk_uint(tcx)),\n-      _ => None\n+        ty::ty_box(*) => {\n+            Some(ty::mk_opaque_box(tcx))\n+        }\n+        ty::ty_fn(ref fty) => {\n+            Some(ty::mk_fn(\n+                tcx,\n+                FnTyBase {meta: FnMeta {purity: ast::impure_fn,\n+                                        proto: fty.meta.proto,\n+                                        bounds: @~[],\n+                                        ret_style: ast::return_val},\n+                          sig: FnSig {inputs: ~[],\n+                                      output: ty::mk_nil(tcx)}}))\n+        }\n+        ty::ty_trait(_, _, _) => {\n+            let box_proto = ty::proto_vstore(ty::vstore_box);\n+            Some(ty::mk_fn(\n+                tcx,\n+                FnTyBase {meta: FnMeta {purity: ast::impure_fn,\n+                                        proto: box_proto,\n+                                        bounds: @~[],\n+                                        ret_style: ast::return_val},\n+                          sig: FnSig {inputs: ~[],\n+                                      output: ty::mk_nil(tcx)}}))\n+        }\n+        ty::ty_ptr(_) => {\n+            Some(ty::mk_uint(tcx))\n+        }\n+        _ => {\n+            None\n+        }\n     }\n }\n "}, {"sha": "c78e264a86fce2d119b8c67b128c5e48a9144b6f", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -178,31 +178,31 @@ impl reflector {\n \n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n           // numbers.\n-          ty::ty_fn(fty) => {\n-            let pureval = match fty.purity {\n+          ty::ty_fn(ref fty) => {\n+            let pureval = match fty.meta.purity {\n               ast::pure_fn => 0u,\n               ast::unsafe_fn => 1u,\n               ast::impure_fn => 2u,\n               ast::extern_fn => 3u\n             };\n-            let protoval = match fty.proto {\n+            let protoval = match fty.meta.proto {\n               ty::proto_bare => 0u,\n               ty::proto_vstore(ty::vstore_uniq) => 2u,\n               ty::proto_vstore(ty::vstore_box) => 3u,\n               ty::proto_vstore(ty::vstore_slice(_)) => 4u,\n               ty::proto_vstore(ty::vstore_fixed(_)) =>\n                 fail ~\"fixed unexpected\"\n             };\n-            let retval = match fty.ret_style {\n+            let retval = match fty.meta.ret_style {\n               ast::noreturn => 0u,\n               ast::return_val => 1u\n             };\n             let extra = ~[self.c_uint(pureval),\n-                         self.c_uint(protoval),\n-                         self.c_uint(vec::len(fty.inputs)),\n-                         self.c_uint(retval)];\n+                          self.c_uint(protoval),\n+                          self.c_uint(vec::len(fty.sig.inputs)),\n+                          self.c_uint(retval)];\n             self.visit(~\"enter_fn\", extra);\n-            for fty.inputs.eachi |i, arg| {\n+            for fty.sig.inputs.eachi |i, arg| {\n                 let modeval = match arg.mode {\n                   ast::infer(_) => 0u,\n                   ast::expl(e) => match e {\n@@ -220,7 +220,7 @@ impl reflector {\n             }\n             self.visit(~\"fn_output\",\n                        ~[self.c_uint(retval),\n-                         self.c_tydesc(fty.output)]);\n+                         self.c_tydesc(fty.sig.output)]);\n             self.visit(~\"leave_fn\", extra);\n           }\n "}, {"sha": "f93d9c0b5932aa340a0fd2841091a27cca60ac7c", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 144, "deletions": 141, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -213,158 +213,161 @@ fn add_substr(&dest: ~[u8], src: ~[u8]) {\n \n fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n     match ty::get(t).struct {\n-      ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n-      ty::ty_bot => ~[shape_u8],\n-      ty::ty_int(ast::ty_i) => ~[s_int(ccx.tcx)],\n-      ty::ty_float(ast::ty_f) => ~[s_float(ccx.tcx)],\n-      ty::ty_uint(ast::ty_u) | ty::ty_ptr(_) => ~[s_uint(ccx.tcx)],\n-      ty::ty_type => ~[s_tydesc(ccx.tcx)],\n-      ty::ty_int(ast::ty_i8) => ~[shape_i8],\n-      ty::ty_uint(ast::ty_u16) => ~[shape_u16],\n-      ty::ty_int(ast::ty_i16) => ~[shape_i16],\n-      ty::ty_uint(ast::ty_u32) => ~[shape_u32],\n-      ty::ty_int(ast::ty_i32) | ty::ty_int(ast::ty_char) => ~[shape_i32],\n-      ty::ty_uint(ast::ty_u64) => ~[shape_u64],\n-      ty::ty_int(ast::ty_i64) => ~[shape_i64],\n-      ty::ty_float(ast::ty_f32) => ~[shape_f32],\n-      ty::ty_float(ast::ty_f64) => ~[shape_f64],\n-      ty::ty_estr(ty::vstore_uniq) => {\n-        shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n-      }\n-      ty::ty_enum(did, substs) => {\n-        match enum_kind(ccx, did) {\n-          tk_unit => ~[s_variant_enum_t(ccx.tcx)],\n-          tk_enum => ~[s_variant_enum_t(ccx.tcx)],\n-          tk_newtype | tk_complex => {\n-            let mut s = ~[shape_enum], id;\n-            let nom_id = mk_nominal_id(ccx.tcx, did, None, substs.tps);\n-            match ccx.shape_cx.tag_id_to_index.find(nom_id) {\n-              None => {\n-                id = ccx.shape_cx.next_tag_id;\n-                ccx.shape_cx.tag_id_to_index.insert(nom_id, id);\n-                ccx.shape_cx.tag_order.push({did: did, substs: substs});\n-                ccx.shape_cx.next_tag_id += 1u16;\n-              }\n-              Some(existing_id) => id = existing_id,\n-            }\n-            add_u16(s, id as u16);\n+        ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n+        ty::ty_bot => ~[shape_u8],\n+        ty::ty_int(ast::ty_i) => ~[s_int(ccx.tcx)],\n+        ty::ty_float(ast::ty_f) => ~[s_float(ccx.tcx)],\n+        ty::ty_uint(ast::ty_u) | ty::ty_ptr(_) => ~[s_uint(ccx.tcx)],\n+        ty::ty_type => ~[s_tydesc(ccx.tcx)],\n+        ty::ty_int(ast::ty_i8) => ~[shape_i8],\n+        ty::ty_uint(ast::ty_u16) => ~[shape_u16],\n+        ty::ty_int(ast::ty_i16) => ~[shape_i16],\n+        ty::ty_uint(ast::ty_u32) => ~[shape_u32],\n+        ty::ty_int(ast::ty_i32) | ty::ty_int(ast::ty_char) => ~[shape_i32],\n+        ty::ty_uint(ast::ty_u64) => ~[shape_u64],\n+        ty::ty_int(ast::ty_i64) => ~[shape_i64],\n+        ty::ty_float(ast::ty_f32) => ~[shape_f32],\n+        ty::ty_float(ast::ty_f64) => ~[shape_f64],\n+        ty::ty_estr(ty::vstore_uniq) => {\n+            shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n+        }\n+        ty::ty_enum(did, substs) => {\n+            match enum_kind(ccx, did) {\n+                tk_unit => ~[s_variant_enum_t(ccx.tcx)],\n+                tk_enum => ~[s_variant_enum_t(ccx.tcx)],\n+                tk_newtype | tk_complex => {\n+                    let mut s = ~[shape_enum], id;\n+                    let nom_id = mk_nominal_id(ccx.tcx, did,\n+                                               None, substs.tps);\n+                    match ccx.shape_cx.tag_id_to_index.find(nom_id) {\n+                        None => {\n+                            id = ccx.shape_cx.next_tag_id;\n+                            ccx.shape_cx.tag_id_to_index.insert(nom_id, id);\n+                            ccx.shape_cx.tag_order.push({did: did,\n+                                                         substs: substs});\n+                            ccx.shape_cx.next_tag_id += 1u16;\n+                        }\n+                        Some(existing_id) => id = existing_id,\n+                    }\n+                    add_u16(s, id as u16);\n \n+                    s\n+                }\n+            }\n+        }\n+        ty::ty_estr(ty::vstore_box) |\n+        ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_box(_) | ty::ty_opaque_box => ~[shape_box],\n+        ty::ty_uniq(mt) => {\n+            let mut s = ~[shape_uniq];\n+            add_substr(s, shape_of(ccx, mt.ty));\n             s\n-          }\n         }\n-      }\n-      ty::ty_estr(ty::vstore_box) |\n-      ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_box(_) | ty::ty_opaque_box => ~[shape_box],\n-      ty::ty_uniq(mt) => {\n-        let mut s = ~[shape_uniq];\n-        add_substr(s, shape_of(ccx, mt.ty));\n-        s\n-      }\n-      ty::ty_unboxed_vec(mt) => {\n-        let mut s = ~[shape_unboxed_vec];\n-        add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-        add_substr(s, shape_of(ccx, mt.ty));\n-        s\n-      }\n-      ty::ty_evec(_, ty::vstore_uniq) => {\n-        shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n-      }\n+        ty::ty_unboxed_vec(mt) => {\n+            let mut s = ~[shape_unboxed_vec];\n+            add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n+            add_substr(s, shape_of(ccx, mt.ty));\n+            s\n+        }\n+        ty::ty_evec(_, ty::vstore_uniq) => {\n+            shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n+        }\n \n-      ty::ty_estr(ty::vstore_fixed(n)) => {\n-        let mut s = ~[shape_fixedvec];\n-        let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n-        assert (n + 1u) <= 0xffffu;\n-        add_u16(s, (n + 1u) as u16);\n-        add_bool(s, true);\n-        add_substr(s, shape_of(ccx, u8_t));\n-        s\n-      }\n+        ty::ty_estr(ty::vstore_fixed(n)) => {\n+            let mut s = ~[shape_fixedvec];\n+            let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n+            assert (n + 1u) <= 0xffffu;\n+            add_u16(s, (n + 1u) as u16);\n+            add_bool(s, true);\n+            add_substr(s, shape_of(ccx, u8_t));\n+            s\n+        }\n \n-      ty::ty_evec(mt, ty::vstore_fixed(n)) => {\n-        let mut s = ~[shape_fixedvec];\n-        assert n <= 0xffffu;\n-        add_u16(s, n as u16);\n-        add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-        add_substr(s, shape_of(ccx, mt.ty));\n-        s\n-      }\n+        ty::ty_evec(mt, ty::vstore_fixed(n)) => {\n+            let mut s = ~[shape_fixedvec];\n+            assert n <= 0xffffu;\n+            add_u16(s, n as u16);\n+            add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n+            add_substr(s, shape_of(ccx, mt.ty));\n+            s\n+        }\n \n-      ty::ty_estr(ty::vstore_slice(_)) => {\n-        let mut s = ~[shape_slice];\n-        let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n-        add_bool(s, true); // is_pod\n-        add_bool(s, true); // is_str\n-        add_substr(s, shape_of(ccx, u8_t));\n-        s\n-      }\n+        ty::ty_estr(ty::vstore_slice(_)) => {\n+            let mut s = ~[shape_slice];\n+            let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n+            add_bool(s, true); // is_pod\n+            add_bool(s, true); // is_str\n+            add_substr(s, shape_of(ccx, u8_t));\n+            s\n+        }\n \n-      ty::ty_evec(mt, ty::vstore_slice(_)) => {\n-        let mut s = ~[shape_slice];\n-        add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-        add_bool(s, false); // is_str\n-        add_substr(s, shape_of(ccx, mt.ty));\n-        s\n-      }\n+        ty::ty_evec(mt, ty::vstore_slice(_)) => {\n+            let mut s = ~[shape_slice];\n+            add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n+            add_bool(s, false); // is_str\n+            add_substr(s, shape_of(ccx, mt.ty));\n+            s\n+        }\n \n-      ty::ty_rec(fields) => {\n-        let mut s = ~[shape_struct], sub = ~[];\n-        for vec::each(fields) |f| {\n-            sub += shape_of(ccx, f.mt.ty);\n+        ty::ty_rec(fields) => {\n+            let mut s = ~[shape_struct], sub = ~[];\n+            for vec::each(fields) |f| {\n+                sub += shape_of(ccx, f.mt.ty);\n+            }\n+            add_substr(s, sub);\n+            s\n         }\n-        add_substr(s, sub);\n-        s\n-      }\n-      ty::ty_tup(elts) => {\n-        let mut s = ~[shape_struct], sub = ~[];\n-        for vec::each(elts) |elt| {\n-            sub += shape_of(ccx, elt);\n+        ty::ty_tup(elts) => {\n+            let mut s = ~[shape_struct], sub = ~[];\n+            for vec::each(elts) |elt| {\n+                sub += shape_of(ccx, elt);\n+            }\n+            add_substr(s, sub);\n+            s\n         }\n-        add_substr(s, sub);\n-        s\n-      }\n-      ty::ty_trait(_, _, _) => ~[shape_box_fn],\n-      ty::ty_class(did, ref substs) => {\n-        // same as records, unless there's a dtor\n-        let tps = substs.tps;\n-        let m_dtor_did = ty::ty_dtor(ccx.tcx, did);\n-        let mut s = if option::is_some(m_dtor_did) {\n-            ~[shape_res]\n-          }\n-        else { ~[shape_struct] }, sub = ~[];\n-        do option::iter(m_dtor_did) |dtor_did| {\n-          let ri = @{did: dtor_did, parent_id: Some(did), tps: tps};\n-          let id = ccx.shape_cx.resources.intern(ri);\n-          add_u16(s, id as u16);\n-        };\n-        for ty::class_items_as_mutable_fields(ccx.tcx, did, substs).each |f| {\n-           sub += shape_of(ccx, f.mt.ty);\n+        ty::ty_trait(_, _, _) => ~[shape_box_fn],\n+        ty::ty_class(did, ref substs) => {\n+            // same as records, unless there's a dtor\n+            let tps = substs.tps;\n+            let m_dtor_did = ty::ty_dtor(ccx.tcx, did);\n+            let mut s = if option::is_some(m_dtor_did) {\n+                ~[shape_res]\n+            }\n+            else { ~[shape_struct] }, sub = ~[];\n+            do option::iter(m_dtor_did) |dtor_did| {\n+                let ri = @{did: dtor_did, parent_id: Some(did), tps: tps};\n+                let id = ccx.shape_cx.resources.intern(ri);\n+                add_u16(s, id as u16);\n+            };\n+            for ty::class_items_as_mutable_fields(ccx.tcx, did,\n+                                                  substs).each |f| {\n+                sub += shape_of(ccx, f.mt.ty);\n+            }\n+            add_substr(s, sub);\n+            s\n+        }\n+        ty::ty_rptr(_, mt) => {\n+            let mut s = ~[shape_rptr];\n+            add_substr(s, shape_of(ccx, mt.ty));\n+            s\n+        }\n+        ty::ty_param(*) => {\n+            ccx.tcx.sess.bug(~\"non-monomorphized type parameter\");\n+        }\n+        ty::ty_fn(ref fn_ty) => {\n+            match fn_ty.meta.proto {\n+                ty::proto_vstore(ty::vstore_box) => ~[shape_box_fn],\n+                ty::proto_vstore(ty::vstore_uniq) => ~[shape_uniq_fn],\n+                ty::proto_vstore(ty::vstore_slice(_)) => ~[shape_stack_fn],\n+                ty::proto_bare => ~[shape_bare_fn],\n+                ty::proto_vstore(ty::vstore_fixed(_)) =>\n+                fail ~\"fixed vstore is impossible\",\n+            }\n+        }\n+        ty::ty_opaque_closure_ptr(_) => ~[shape_opaque_closure_ptr],\n+        ty::ty_infer(_) | ty::ty_self => {\n+            ccx.sess.bug(~\"shape_of: unexpected type struct found\")\n         }\n-        add_substr(s, sub);\n-        s\n-      }\n-      ty::ty_rptr(_, mt) => {\n-        let mut s = ~[shape_rptr];\n-        add_substr(s, shape_of(ccx, mt.ty));\n-        s\n-      }\n-      ty::ty_param(*) => {\n-        ccx.tcx.sess.bug(~\"non-monomorphized type parameter\");\n-      }\n-      ty::ty_fn({proto: ty::proto_vstore(ty::vstore_box), _}) =>\n-        ~[shape_box_fn],\n-      ty::ty_fn({proto: ty::proto_vstore(ty::vstore_uniq), _}) =>\n-        ~[shape_uniq_fn],\n-      ty::ty_fn({proto: ty::proto_vstore(ty::vstore_slice(_)), _}) =>\n-        ~[shape_stack_fn],\n-      ty::ty_fn({proto: ty::proto_vstore(ty::vstore_fixed(_)), _}) =>\n-        fail ~\"fixed vstore is impossible\",\n-      ty::ty_fn({proto: ty::proto_bare, _}) =>\n-        ~[shape_bare_fn],\n-      ty::ty_opaque_closure_ptr(_) =>\n-        ~[shape_opaque_closure_ptr],\n-      ty::ty_infer(_) | ty::ty_self =>\n-        ccx.sess.bug(~\"shape_of: unexpected type struct found\")\n     }\n }\n "}, {"sha": "4c6b936172f5e5366d37da0c3c382bf80d755efc", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -46,8 +46,8 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n \n     let cx = {ccx: ccx, uses: vec::to_mut(vec::from_elem(n_tps, 0u))};\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).struct {\n-      ty::ty_fn({inputs, _}) => {\n-        for vec::each(inputs) |arg| {\n+      ty::ty_fn(ref fn_ty) => {\n+        for vec::each(fn_ty.sig.inputs) |arg| {\n             if arg.mode == expl(by_val) { type_needs(cx, use_repr, arg.ty); }\n         }\n       }"}, {"sha": "f612ed40a9c5d2d01da7199da1ccb74da8d9386f", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -946,16 +946,14 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> ~[mode] {\n     let ty = ty::type_autoderef(fcx.ccx.tcx,\n                                 ty::node_id_to_type(fcx.ccx.tcx, callee));\n     match ty::get(ty).struct {\n-      ty::ty_fn({inputs: args, _}) {\n-        let mut modes = ~[];\n-        for args.each |arg| { vec::push(modes, arg.mode); }\n-        return modes;\n-      }\n-      _ {\n-        // Shouldn't happen; callee should be ty_fn.\n-        fcx.ccx.tcx.sess.bug(~\"non-fn callee type in callee_modes: \" +\n+        ty::ty_fn(ref fn_ty) {\n+            return fn_ty.sig.inputs.map(|input| input.mode);\n+        }\n+        _ {\n+            // Shouldn't happen; callee should be ty_fn.\n+            fcx.ccx.tcx.sess.bug(~\"non-fn callee type in callee_modes: \" +\n                                  util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n-      }\n+        }\n     }\n }\n "}, {"sha": "f95997c93e95bb9e8b62c488190c032f1e96a472", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 185, "deletions": 141, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -21,7 +21,7 @@ use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n use std::serialization::{serialize_Option,\n                             deserialize_Option};\n \n-export ty_vid, int_vid, region_vid, vid;\n+export TyVid, IntVid, FnVid, RegionVid, vid;\n export br_hashmap;\n export is_instantiable;\n export node_id_to_type;\n@@ -80,7 +80,7 @@ export ty_box, mk_box, mk_imm_box, type_is_box, type_is_boxed;\n export ty_opaque_closure_ptr, mk_opaque_closure_ptr;\n export ty_opaque_box, mk_opaque_box;\n export ty_float, mk_float, mk_mach_float, type_is_fp;\n-export ty_fn, fn_ty, mk_fn;\n+export ty_fn, FnTy, FnTyBase, FnMeta, FnSig, mk_fn;\n export ty_fn_proto, ty_fn_purity, ty_fn_ret, ty_fn_ret_style, tys_in_fn_ty;\n export ty_int, mk_int, mk_mach_int, mk_char;\n export mk_i8, mk_u8, mk_i16, mk_u16, mk_i32, mk_u32, mk_i64, mk_u64;\n@@ -119,7 +119,7 @@ export kind_noncopyable, kind_const;\n export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n export kind_is_safe_for_default_mode;\n export kind_is_owned;\n-export proto_kind, kind_lteq, type_kind;\n+export meta_kind, kind_lteq, type_kind;\n export operators;\n export type_err, terr_vstore_kind;\n export type_err_to_str, note_and_explain_type_err;\n@@ -203,7 +203,7 @@ type param_bounds = @~[param_bound];\n \n type method = {ident: ast::ident,\n                tps: @~[param_bounds],\n-               fty: fn_ty,\n+               fty: FnTy,\n                self_ty: ast::self_ty_,\n                vis: ast::visibility};\n \n@@ -392,20 +392,42 @@ impl fn_proto : cmp::Eq {\n     }\n }\n \n-/// Innards of a function type:\n-///\n-/// - `purity` is the function's effect (pure, impure, unsafe).\n-/// - `proto` is the protocol (fn@, fn~, etc).\n-/// - `bound` is the parameter bounds on the function's upvars.\n-/// - `inputs` is the list of arguments and their modes.\n-/// - `output` is the return type.\n-/// - `ret_style` indicates whether the function returns a value or fails.\n-type fn_ty = {purity: ast::purity,\n-              proto: fn_proto,\n-              bounds: @~[param_bound],\n-              inputs: ~[arg],\n-              output: t,\n-              ret_style: ret_style};\n+/**\n+ * Meta information about a closure.\n+ *\n+ * - `purity` is the function's effect (pure, impure, unsafe).\n+ * - `proto` is the protocol (fn@, fn~, etc).\n+ * - `bounds` is the parameter bounds on the function's upvars.\n+ * - `ret_style` indicates whether the function returns a value or fails. */\n+struct FnMeta {\n+    purity: ast::purity;\n+    proto: fn_proto;\n+    bounds: @~[param_bound];\n+    ret_style: ret_style;\n+}\n+\n+/**\n+ * Signature of a function type, which I have arbitrarily\n+ * decided to use to refer to the input/output types.\n+ *\n+ * - `inputs` is the list of arguments and their modes.\n+ * - `output` is the return type. */\n+struct FnSig {\n+    inputs: ~[arg];\n+    output: t;\n+}\n+\n+/**\n+ * Function type: combines the meta information and the\n+ * type signature.  This particular type is parameterized\n+ * by the meta information because, in some cases, the\n+ * meta information is inferred. */\n+struct FnTyBase<M: cmp::Eq> {\n+    meta: M;\n+    sig: FnSig;\n+}\n+\n+type FnTy = FnTyBase<FnMeta>;\n \n type param_ty = {idx: uint, def_id: def_id};\n \n@@ -440,7 +462,7 @@ enum region {\n     re_static,\n \n     /// A region variable.  Should not exist after typeck.\n-    re_var(region_vid)\n+    re_var(RegionVid)\n }\n \n enum bound_region {\n@@ -505,7 +527,7 @@ enum sty {\n     ty_ptr(mt),\n     ty_rptr(region, mt),\n     ty_rec(~[field]),\n-    ty_fn(fn_ty),\n+    ty_fn(FnTy),\n     ty_trait(def_id, substs, vstore),\n     ty_class(def_id, substs),\n     ty_tup(~[t]),\n@@ -567,31 +589,37 @@ enum param_bound {\n     bound_trait(t),\n }\n \n-enum ty_vid = uint;\n-enum int_vid = uint;\n-enum region_vid = uint;\n+enum TyVid = uint;\n+enum IntVid = uint;\n+enum FnVid = uint;\n+enum RegionVid = uint;\n \n enum InferTy {\n-    TyVar(ty_vid),\n-    IntVar(int_vid)\n+    TyVar(TyVid),\n+    IntVar(IntVid)\n }\n \n trait vid {\n     pure fn to_uint() -> uint;\n     pure fn to_str() -> ~str;\n }\n \n-impl ty_vid: vid {\n+impl TyVid: vid {\n     pure fn to_uint() -> uint { *self }\n     pure fn to_str() -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n-impl int_vid: vid {\n+impl IntVid: vid {\n     pure fn to_uint() -> uint { *self }\n     pure fn to_str() -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n-impl region_vid: vid {\n+impl FnVid: vid {\n+    pure fn to_uint() -> uint { *self }\n+    pure fn to_str() -> ~str { fmt!(\"<F%u>\", self.to_uint()) }\n+}\n+\n+impl RegionVid: vid {\n     pure fn to_uint() -> uint { *self }\n     pure fn to_str() -> ~str { fmt!(\"%?\", self) }\n }\n@@ -600,14 +628,14 @@ impl InferTy {\n     pure fn to_hash() -> uint {\n         match self {\n             TyVar(v) => v.to_uint() << 1,\n-            IntVar(v) => (v.to_uint() << 1) + 1\n+            IntVar(v) => (v.to_uint() << 1) + 1,\n         }\n     }\n \n     pure fn to_str() -> ~str {\n         match self {\n             TyVar(v) => v.to_str(),\n-            IntVar(v) => v.to_str()\n+            IntVar(v) => v.to_str(),\n         }\n     }\n }\n@@ -781,12 +809,12 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       ty_rec(flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n       ty_tup(ts) => for ts.each |tt| { flags |= get(tt).flags; },\n       ty_fn(ref f) => {\n-        match f.proto {\n+        match f.meta.proto {\n             ty::proto_vstore(vstore_slice(r)) => flags |= rflags(r),\n             ty::proto_bare | ty::proto_vstore(_) => {}\n         }\n-        for f.inputs.each |a| { flags |= get(a.ty).flags; }\n-        flags |= get(f.output).flags;\n+        for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n+        flags |= get(f.sig.output).flags;\n       }\n     }\n     let t = @{struct: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n@@ -883,13 +911,12 @@ fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec({ty: ty, mutbl: ast::m_imm}))\n }\n \n-\n fn mk_rec(cx: ctxt, fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n // take a copy because we want to own the various vectors inside\n-fn mk_fn(cx: ctxt, +fty: fn_ty) -> t { mk_t(cx, ty_fn(fty)) }\n+fn mk_fn(cx: ctxt, +fty: FnTy) -> t { mk_t(cx, ty_fn(fty)) }\n \n fn mk_trait(cx: ctxt, did: ast::def_id, +substs: substs, vstore: vstore)\n          -> t {\n@@ -902,9 +929,9 @@ fn mk_class(cx: ctxt, class_id: ast::def_id, +substs: substs) -> t {\n     mk_t(cx, ty_class(class_id, substs))\n }\n \n-fn mk_var(cx: ctxt, v: ty_vid) -> t { mk_infer(cx, TyVar(v)) }\n+fn mk_var(cx: ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n \n-fn mk_int_var(cx: ctxt, v: int_vid) -> t {\n+fn mk_int_var(cx: ctxt, v: IntVid) -> t {\n     mk_infer(cx, IntVar(v))\n }\n \n@@ -976,8 +1003,8 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       }\n       ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(tt, f); } }\n       ty_fn(ref ft) => {\n-        for ft.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n-        maybe_walk_ty(ft.output, f);\n+        for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n+        maybe_walk_ty(ft.sig.output, f);\n       }\n       ty_uniq(tm) => { maybe_walk_ty(tm.ty, f); }\n     }\n@@ -995,58 +1022,61 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n     }\n \n     match *sty {\n-      ty_box(tm) => {\n-        ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n-      }\n-      ty_uniq(tm) => {\n-        ty_uniq({ty: fldop(tm.ty), mutbl: tm.mutbl})\n-      }\n-      ty_ptr(tm) => {\n-        ty_ptr({ty: fldop(tm.ty), mutbl: tm.mutbl})\n-      }\n-      ty_unboxed_vec(tm) => {\n-        ty_unboxed_vec({ty: fldop(tm.ty), mutbl: tm.mutbl})\n-      }\n-      ty_evec(tm, vst) => {\n-        ty_evec({ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n-      }\n-      ty_enum(tid, ref substs) => {\n-        ty_enum(tid, fold_substs(substs, fldop))\n-      }\n-      ty_trait(did, ref substs, vst) => {\n-        ty_trait(did, fold_substs(substs, fldop), vst)\n-      }\n-      ty_rec(fields) => {\n-        let new_fields = do vec::map(fields) |fl| {\n-            let new_ty = fldop(fl.mt.ty);\n-            let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n-            {ident: fl.ident, mt: new_mt}\n-        };\n-        ty_rec(new_fields)\n-      }\n-      ty_tup(ts) => {\n-        let new_ts = vec::map(ts, |tt| fldop(tt));\n-        ty_tup(new_ts)\n-      }\n-      ty_fn(ref f) => {\n-        let new_args = vec::map(f.inputs, |a| {\n-            let new_ty = fldop(a.ty);\n-            {mode: a.mode, ty: new_ty}\n-        });\n-        let new_output = fldop(f.output);\n-        ty_fn({inputs: new_args, output: new_output,.. *f})\n-      }\n-      ty_rptr(r, tm) => {\n-        ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-      }\n-      ty_class(did, ref substs) => {\n-        ty_class(did, fold_substs(substs, fldop))\n-      }\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n-      ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self => {\n-        *sty\n-      }\n+        ty_box(tm) => {\n+            ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+        }\n+        ty_uniq(tm) => {\n+            ty_uniq({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+        }\n+        ty_ptr(tm) => {\n+            ty_ptr({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+        }\n+        ty_unboxed_vec(tm) => {\n+            ty_unboxed_vec({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+        }\n+        ty_evec(tm, vst) => {\n+            ty_evec({ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n+        }\n+        ty_enum(tid, ref substs) => {\n+            ty_enum(tid, fold_substs(substs, fldop))\n+        }\n+        ty_trait(did, ref substs, vst) => {\n+            ty_trait(did, fold_substs(substs, fldop), vst)\n+        }\n+        ty_rec(fields) => {\n+            let new_fields = do vec::map(fields) |fl| {\n+                let new_ty = fldop(fl.mt.ty);\n+                let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n+                {ident: fl.ident, mt: new_mt}\n+            };\n+            ty_rec(new_fields)\n+        }\n+        ty_tup(ts) => {\n+            let new_ts = vec::map(ts, |tt| fldop(tt));\n+            ty_tup(new_ts)\n+        }\n+        ty_fn(ref f) => {\n+            let new_args = f.sig.inputs.map(|a| {\n+                let new_ty = fldop(a.ty);\n+                {mode: a.mode, ty: new_ty}\n+            });\n+            let new_output = fldop(f.sig.output);\n+            ty_fn(FnTyBase {\n+                meta: f.meta,\n+                sig: FnSig {inputs: new_args, output: new_output}\n+            })\n+        }\n+        ty_rptr(r, tm) => {\n+            ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n+        }\n+        ty_class(did, ref substs) => {\n+            ty_class(did, fold_substs(substs, fldop))\n+        }\n+        ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+        ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n+        ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self => {\n+            *sty\n+        }\n     }\n }\n \n@@ -1113,26 +1143,25 @@ fn fold_regions_and_ty(\n       ty_trait(def_id, ref substs, vst) => {\n         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), vst)\n       }\n-      ty_fn(f) => {\n+      ty_fn(ref f) => {\n         let new_proto;\n-        match f.proto {\n+        match f.meta.proto {\n             proto_bare =>\n                 new_proto = proto_bare,\n             proto_vstore(vstore_slice(r)) =>\n                 new_proto = proto_vstore(vstore_slice(fldr(r))),\n             proto_vstore(old_vstore) =>\n                 new_proto = proto_vstore(old_vstore)\n         }\n-\n-        let new_args = vec::map(f.inputs, |a| {\n+        let new_args = vec::map(f.sig.inputs, |a| {\n             let new_ty = fldfnt(a.ty);\n             {mode: a.mode, ty: new_ty}\n         });\n-        let new_output = fldfnt(f.output);\n-        ty::mk_fn(cx, {\n-            inputs: new_args,\n-            output: new_output,\n-            proto: new_proto,.. f\n+        let new_output = fldfnt(f.sig.output);\n+        ty::mk_fn(cx, FnTyBase {\n+            meta: FnMeta {proto: new_proto, ..f.meta},\n+            sig: FnSig {inputs: new_args,\n+                        output: new_output}\n         })\n       }\n       ref sty => {\n@@ -1440,7 +1469,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         accum\n       }\n       ty_fn(ref fty) => {\n-        match fty.proto {\n+        match fty.meta.proto {\n           proto_bare | proto_vstore(vstore_slice(_)) => false,\n           _ => true\n         }\n@@ -1667,8 +1696,8 @@ pure fn kind_is_owned(k: kind) -> bool {\n     *k & KIND_MASK_OWNED == KIND_MASK_OWNED\n }\n \n-fn proto_kind(p: fn_proto) -> kind {\n-    match p {\n+fn meta_kind(p: FnMeta) -> kind {\n+    match p.proto { // XXX consider the kind bounds!\n       proto_vstore(vstore_slice(_)) =>\n         kind_noncopyable() | kind_(KIND_MASK_DEFAULT_MODE),\n       proto_vstore(vstore_box) =>\n@@ -1753,7 +1782,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n \n       // functions depend on the protocol\n-      ty_fn(ref f) => proto_kind(f.proto),\n+      ty_fn(ref f) => meta_kind(f.meta),\n \n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n@@ -2361,8 +2390,10 @@ pure fn hash_type_structure(st: &sty) -> uint {\n       }\n       ty_fn(ref f) => {\n         let mut h = 27u;\n-        for vec::each(f.inputs) |a| { h = hash_subty(h, a.ty); }\n-        hash_subty(h, f.output)\n+        for vec::each(f.sig.inputs) |a| {\n+            h = hash_subty(h, a.ty);\n+        }\n+        hash_subty(h, f.sig.output)\n       }\n       ty_self => 28u,\n       ty_infer(v) => hash_uint(29u, v.to_hash()),\n@@ -2415,35 +2446,35 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n // Type accessors for substructures of types\n fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).struct {\n-      ty_fn(ref f) => f.inputs,\n+      ty_fn(ref f) => f.sig.inputs,\n       _ => fail ~\"ty_fn_args() called on non-fn type\"\n     }\n }\n \n fn ty_fn_proto(fty: t) -> fn_proto {\n     match get(fty).struct {\n-      ty_fn(ref f) => f.proto,\n+      ty_fn(ref f) => f.meta.proto,\n       _ => fail ~\"ty_fn_proto() called on non-fn type\"\n     }\n }\n \n fn ty_fn_purity(fty: t) -> ast::purity {\n     match get(fty).struct {\n-      ty_fn(ref f) => f.purity,\n+      ty_fn(ref f) => f.meta.purity,\n       _ => fail ~\"ty_fn_purity() called on non-fn type\"\n     }\n }\n \n pure fn ty_fn_ret(fty: t) -> t {\n     match get(fty).struct {\n-      ty_fn(ref f) => f.output,\n+      ty_fn(ref f) => f.sig.output,\n       _ => fail ~\"ty_fn_ret() called on non-fn type\"\n     }\n }\n \n fn ty_fn_ret_style(fty: t) -> ast::ret_style {\n     match get(fty).struct {\n-      ty_fn(ref f) => f.ret_style,\n+      ty_fn(ref f) => f.meta.ret_style,\n       _ => fail ~\"ty_fn_ret_style() called on non-fn type\"\n     }\n }\n@@ -2463,8 +2494,8 @@ fn ty_region(ty: t) -> region {\n }\n \n // Returns a vec of all the input and output types of fty.\n-fn tys_in_fn_ty(fty: &fn_ty) -> ~[t] {\n-    vec::append_one(fty.inputs.map(|a| a.ty), fty.output)\n+fn tys_in_fn_ty(fty: &FnTy) -> ~[t] {\n+    vec::append_one(fty.sig.inputs.map(|a| a.ty), fty.sig.output)\n }\n \n // Just checks whether it's a fn that returns bool,\n@@ -2474,14 +2505,14 @@ fn is_pred_ty(fty: t) -> bool {\n }\n \n /*\n-fn ty_var_id(typ: t) -> ty_vid {\n+fn ty_var_id(typ: t) -> TyVid {\n     match get(typ).struct {\n       ty_infer(TyVar(vid)) => return vid,\n       _ => { error!(\"ty_var_id called on non-var ty\"); fail; }\n     }\n }\n \n-fn int_var_id(typ: t) -> int_vid {\n+fn int_var_id(typ: t) -> IntVid {\n     match get(typ).struct {\n       ty_infer(IntVar(vid)) => return vid,\n       _ => { error!(\"ty_var_integral_id called on ty other than \\\n@@ -2765,11 +2796,11 @@ fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     rslt\n }\n \n-fn occurs_check(tcx: ctxt, sp: span, vid: ty_vid, rt: t) {\n+fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n \n     // Returns a vec of all the type variables occurring in `ty`. It may\n     // contain duplicates.  (Integral type vars aren't counted.)\n-    fn vars_in_type(ty: t) -> ~[ty_vid] {\n+    fn vars_in_type(ty: t) -> ~[TyVid] {\n         let mut rslt = ~[];\n         do walk_ty(ty) |ty| {\n             match get(ty).struct {\n@@ -3561,20 +3592,16 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n             // This type has a region. Get rid of it\n             mk_rptr(cx, re_static, normalize_mt(cx, mt)),\n \n-        ty_fn({purity: purity,\n-               proto: proto_vstore(vstore),\n-               bounds: bounds,\n-               inputs: inputs,\n-               output: output,\n-               ret_style: ret_style}) =>\n-            mk_fn(cx, {\n-                purity: purity,\n-                proto: proto_vstore(normalize_vstore(vstore)),\n-                bounds: bounds,\n-                inputs: inputs,\n-                output: output,\n-                ret_style: ret_style\n-            }),\n+        ty_fn(ref fn_ty) => {\n+            let proto = match fn_ty.meta.proto {\n+                proto_bare => proto_bare,\n+                proto_vstore(vstore) => proto_vstore(normalize_vstore(vstore))\n+            };\n+            mk_fn(cx, FnTyBase {\n+                meta: FnMeta {proto: proto, ..fn_ty.meta},\n+                sig: fn_ty.sig\n+            })\n+        }\n \n         ty_enum(did, r) =>\n             match r.self_r {\n@@ -3708,31 +3735,48 @@ impl vstore : cmp::Eq {\n     }\n }\n \n-impl fn_ty : cmp::Eq {\n-    pure fn eq(&&other: fn_ty) -> bool {\n+impl FnMeta : cmp::Eq {\n+    pure fn eq(&&other: FnMeta) -> bool {\n         self.purity == other.purity &&\n         self.proto == other.proto &&\n         self.bounds == other.bounds &&\n-        self.inputs == other.inputs &&\n-        self.output == other.output &&\n         self.ret_style == other.ret_style\n     }\n }\n \n-impl ty_vid: cmp::Eq {\n-    pure fn eq(&&other: ty_vid) -> bool {\n+impl FnSig : cmp::Eq {\n+    pure fn eq(&&other: FnSig) -> bool {\n+        self.inputs == other.inputs &&\n+        self.output == other.output\n+    }\n+}\n+\n+impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n+    pure fn eq(&&other: FnTyBase<M>) -> bool {\n+        self.meta == other.meta && self.sig == other.sig\n+    }\n+}\n+\n+impl TyVid: cmp::Eq {\n+    pure fn eq(&&other: TyVid) -> bool {\n+        *self == *other\n+    }\n+}\n+\n+impl IntVid: cmp::Eq {\n+    pure fn eq(&&other: IntVid) -> bool {\n         *self == *other\n     }\n }\n \n-impl int_vid: cmp::Eq {\n-    pure fn eq(&&other: int_vid) -> bool {\n+impl FnVid: cmp::Eq {\n+    pure fn eq(&&other: FnVid) -> bool {\n         *self == *other\n     }\n }\n \n-impl region_vid: cmp::Eq {\n-    pure fn eq(&&other: region_vid) -> bool {\n+impl RegionVid: cmp::Eq {\n+    pure fn eq(&&other: RegionVid) -> bool {\n         *self == *other\n     }\n }"}, {"sha": "39d4a64f19f6c58d0cc9f0255325da17301d197c", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -255,38 +255,40 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).struct {\n-      ty::ty_fn({purity: ast::impure_fn, proto: ty::proto_bare,\n-                 inputs, output, ret_style: ast::return_val, _}) => {\n-        match tcx.items.find(main_id) {\n-         Some(ast_map::node_item(it,_)) => {\n-             match it.node {\n-               ast::item_fn(_,_,ps,_) if vec::is_not_empty(ps) => {\n-                  tcx.sess.span_err(main_span,\n-                    ~\"main function is not allowed to have type parameters\");\n-                  return;\n-               }\n-               _ => ()\n-             }\n-         }\n-         _ => ()\n-        }\n-        let mut ok = ty::type_is_nil(output);\n-        let num_args = vec::len(inputs);\n-        ok &= num_args == 0u || num_args == 1u &&\n-              arg_is_argv_ty(tcx, inputs[0]);\n-        if !ok {\n-                tcx.sess.span_err(main_span,\n-                   fmt!(\"Wrong type in main function: found `%s`, \\\n-                   expected `extern fn(~[str]) -> ()` \\\n-                   or `extern fn() -> ()`\",\n+        ty::ty_fn(fn_ty) => {\n+            match tcx.items.find(main_id) {\n+                Some(ast_map::node_item(it,_)) => {\n+                    match it.node {\n+                        ast::item_fn(_,_,ps,_) if vec::is_not_empty(ps) => {\n+                            tcx.sess.span_err(\n+                                main_span,\n+                                ~\"main function is not allowed \\\n+                                  to have type parameters\");\n+                            return;\n+                        }\n+                        _ => ()\n+                    }\n+                }\n+                _ => ()\n+            }\n+            let mut ok = ty::type_is_nil(fn_ty.sig.output);\n+            let num_args = vec::len(fn_ty.sig.inputs);\n+            ok &= num_args == 0u || num_args == 1u &&\n+                arg_is_argv_ty(tcx, fn_ty.sig.inputs[0]);\n+            if !ok {\n+                tcx.sess.span_err(\n+                    main_span,\n+                    fmt!(\"Wrong type in main function: found `%s`, \\\n+                          expected `extern fn(~[str]) -> ()` \\\n+                          or `extern fn() -> ()`\",\n                          ty_to_str(tcx, main_t)));\n-         }\n-      }\n-      _ => {\n-        tcx.sess.span_bug(main_span,\n-                          ~\"main has a non-function type: found `\" +\n+            }\n+        }\n+        _ => {\n+            tcx.sess.span_bug(main_span,\n+                              ~\"main has a non-function type: found `\" +\n                               ty_to_str(tcx, main_t) + ~\"`\");\n-      }\n+        }\n     }\n }\n "}, {"sha": "85bac78da973aeb2505cf6b2295ecbdae28de148", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -45,6 +45,7 @@\n use check::fn_ctxt;\n use rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n use rscope::{in_binding_rscope, region_scope, type_rscope};\n+use ty::{FnTyBase, FnMeta, FnSig};\n \n trait ast_conv {\n     fn tcx() -> ty::ctxt;\n@@ -471,7 +472,7 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n     bounds: @~[ty::param_bound],\n     decl: ast::fn_decl,\n     expected_tys: expected_tys,\n-    span: span) -> ty::fn_ty {\n+    span: span) -> ty::FnTy {\n \n     debug!(\"ty_of_fn_decl\");\n     do indent {\n@@ -497,8 +498,14 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n \n         let proto = ast_proto_to_proto(self, rscope, span, ast_proto);\n \n-        {purity: purity, proto: proto, bounds: bounds, inputs: input_tys,\n-         output: output_ty, ret_style: decl.cf}\n+        FnTyBase {\n+            meta: FnMeta {purity: purity,\n+                          proto: proto,\n+                          bounds: bounds,\n+                          ret_style: decl.cf},\n+            sig: FnSig {inputs: input_tys,\n+                        output: output_ty}\n+        }\n     }\n }\n "}, {"sha": "4ec13684f7e1332e86f0b2dae0e1a69e33357df6", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -68,7 +68,7 @@ type parameter).\n \n use astconv::{ast_conv, ast_path_to_ty, ast_ty_to_ty};\n use astconv::{ast_region_to_region};\n-use middle::ty::{ty_vid, vid};\n+use middle::ty::{TyVid, vid, FnTyBase, FnMeta, FnSig};\n use regionmanip::{replace_bound_regions_in_fn_ty};\n use rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n use rscope::{in_binding_rscope, region_scope, type_rscope,\n@@ -98,7 +98,7 @@ type self_info = {\n /// share the inherited fields.\n struct inherited {\n     infcx: infer::infer_ctxt;\n-    locals: hashmap<ast::node_id, ty_vid>;\n+    locals: hashmap<ast::node_id, TyVid>;\n     node_types: hashmap<ast::node_id, ty::t>;\n     node_type_substs: hashmap<ast::node_id, ty::substs>;\n     borrowings: hashmap<ast::node_id, ty::borrow>;\n@@ -211,7 +211,7 @@ fn check_bare_fn(ccx: @crate_ctxt,\n \n fn check_fn(ccx: @crate_ctxt,\n             self_info: Option<self_info>,\n-            fn_ty: &ty::fn_ty,\n+            fn_ty: &ty::FnTy,\n             decl: ast::fn_decl,\n             body: ast::blk,\n             indirect_ret: bool,\n@@ -231,8 +231,8 @@ fn check_fn(ccx: @crate_ctxt,\n                                        |br| ty::re_free(body.node.id, br))\n     };\n \n-    let arg_tys = fn_ty.inputs.map(|a| a.ty);\n-    let ret_ty = fn_ty.output;\n+    let arg_tys = fn_ty.sig.inputs.map(|a| a.ty);\n+    let ret_ty = fn_ty.sig.output;\n \n     debug!(\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n            arg_tys.map(|a| ty_to_str(tcx, a)),\n@@ -245,12 +245,12 @@ fn check_fn(ccx: @crate_ctxt,\n     let fcx: @fn_ctxt = {\n         let (purity, inherited) = match old_fcx {\n             None => {\n-                (fn_ty.purity,\n+                (fn_ty.meta.purity,\n                  blank_inherited(ccx))\n             }\n             Some(fcx) => {\n-                (ty::determine_inherited_purity(fcx.purity, fn_ty.purity,\n-                                                fn_ty.proto),\n+                (ty::determine_inherited_purity(fcx.purity, fn_ty.meta.purity,\n+                                                fn_ty.meta.proto),\n                  fcx.inh)\n             }\n         };\n@@ -943,9 +943,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Grab the argument types, supplying fresh type variables\n         // if the wrong number of arguments were supplied\n-        let expected_arg_count = vec::len(fn_ty.inputs);\n+        let expected_arg_count = vec::len(fn_ty.sig.inputs);\n         let arg_tys = if expected_arg_count == supplied_arg_count {\n-            fn_ty.inputs.map(|a| a.ty)\n+            fn_ty.sig.inputs.map(|a| a.ty)\n         } else {\n             fcx.ccx.tcx.sess.span_err(\n                 sp, fmt!(\"this function takes %u parameter%s but %u \\\n@@ -1031,9 +1031,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Pull the return type out of the type of the function.\n         match structure_of(fcx, sp, fty) {\n-          ty::ty_fn(f) => {\n-            bot |= (f.ret_style == ast::noreturn);\n-            fcx.write_ty(call_expr_id, f.output);\n+          ty::ty_fn(ref f) => {\n+            bot |= (f.meta.ret_style == ast::noreturn);\n+            fcx.write_ty(call_expr_id, f.sig.output);\n             return bot;\n           }\n           _ => fcx.ccx.tcx.sess.span_fatal(sp, ~\"calling non-function\")\n@@ -1242,10 +1242,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     replace_bound_regions_in_fn_ty(\n                         tcx, @Nil, None, fn_ty,\n                         |br| ty::re_bound(ty::br_cap_avoid(expr.id, @br)));\n-                (Some({inputs:fn_ty.inputs,\n-                       output:fn_ty.output}),\n-                 fn_ty.purity,\n-                 fn_ty.proto)\n+                (Some({inputs: fn_ty.sig.inputs,\n+                       output: fn_ty.sig.output}),\n+                 fn_ty.meta.purity,\n+                 fn_ty.meta.proto)\n               }\n               _ => {\n                 (None, ast::impure_fn, ty::proto_vstore(ty::vstore_box))\n@@ -1268,8 +1268,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Patch up the function declaration, if necessary.\n         match ast_proto_opt {\n           None => {\n-            fn_ty.purity = expected_purity;\n-            fn_ty.proto = expected_proto;\n+            fn_ty.meta.purity = expected_purity;\n+            fn_ty.meta.proto = expected_proto;\n           }\n           Some(_) => { }\n         }\n@@ -1643,16 +1643,20 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let inner_ty = match expected_sty {\n           Some(ty::ty_fn(fty)) => {\n             match fcx.mk_subty(false, expr.span,\n-                               fty.output, ty::mk_bool(tcx)) {\n+                               fty.sig.output, ty::mk_bool(tcx)) {\n               result::Ok(_) => (),\n               result::Err(_) => {\n                 tcx.sess.span_fatal(\n                     expr.span, fmt!(\"a `loop` function's last argument \\\n                                      should return `bool`, not `%s`\",\n-                                    fcx.infcx().ty_to_str(fty.output)));\n+                                    fcx.infcx().ty_to_str(fty.sig.output)));\n               }\n             }\n-            ty::mk_fn(tcx, {output: ty::mk_nil(tcx),.. fty})\n+            ty::mk_fn(tcx, FnTyBase {\n+                meta: fty.meta,\n+                sig: FnSig {output: ty::mk_nil(tcx),\n+                            ..fty.sig}\n+            })\n           }\n           _ => {\n             tcx.sess.span_fatal(expr.span, ~\"a `loop` function's last \\\n@@ -1675,8 +1679,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fcx, expr.span, fcx.node_ty(b.id));\n         match ty::get(block_ty).struct {\n           ty::ty_fn(fty) => {\n-            fcx.write_ty(expr.id, ty::mk_fn(tcx, {output: ty::mk_bool(tcx),\n-                                                  .. fty}));\n+            fcx.write_ty(expr.id, ty::mk_fn(tcx, FnTyBase {\n+                meta: fty.meta,\n+                sig: FnSig {output: ty::mk_bool(tcx),\n+                            ..fty.sig}\n+            }))\n           }\n           _ => fail ~\"expected fn type\"\n         }\n@@ -2306,7 +2313,7 @@ fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n                         ast_util::is_self)\n }\n \n-fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ty_vid {\n+fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> TyVid {\n     match fcx.inh.locals.find(id) {\n         Some(x) => x,\n         _ => {\n@@ -2571,20 +2578,18 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n                  arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n       }\n       ~\"frame_address\" => {\n-        let fty = ty::mk_fn(ccx.tcx, {\n-            purity: ast::impure_fn,\n-            proto:\n-                ty::proto_vstore(ty::vstore_slice(\n-                    ty::re_bound(ty::br_anon(0)))),\n-            bounds: @~[],\n-            inputs: ~[{\n-                mode: ast::expl(ast::by_val),\n-                ty: ty::mk_imm_ptr(\n-                    ccx.tcx,\n-                    ty::mk_mach_uint(ccx.tcx, ast::ty_u8))\n-            }],\n-            output: ty::mk_nil(ccx.tcx),\n-            ret_style: ast::return_val\n+        let fty = ty::mk_fn(ccx.tcx, FnTyBase {\n+            meta: FnMeta {purity: ast::impure_fn,\n+                          proto: ty::proto_vstore(ty::vstore_slice(\n+                              ty::re_bound(ty::br_anon(0)))),\n+                          bounds: @~[],\n+                          ret_style: ast::return_val},\n+            sig: FnSig {inputs: ~[{mode: ast::expl(ast::by_val),\n+                                   ty: ty::mk_imm_ptr(\n+                                       ccx.tcx,\n+                                       ty::mk_mach_uint(ccx.tcx, ast::ty_u8))\n+                                  }],\n+                        output: ty::mk_nil(ccx.tcx)}\n         });\n         (0u, ~[arg(ast::by_ref, fty)], ty::mk_nil(tcx))\n       }\n@@ -2597,11 +2602,14 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n         return;\n       }\n     };\n-    let fty = ty::mk_fn(tcx, {purity: ast::impure_fn,\n-                              proto: ty::proto_bare,\n-                              bounds: @~[],\n-                              inputs: inputs, output: output,\n-                              ret_style: ast::return_val});\n+    let fty = ty::mk_fn(tcx, FnTyBase {\n+        meta: FnMeta {purity: ast::impure_fn,\n+                      proto: ty::proto_bare,\n+                      bounds: @~[],\n+                      ret_style: ast::return_val},\n+        sig: FnSig {inputs: inputs,\n+                    output: output}\n+    });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = (*i_ty.bounds).len();\n     if i_n_tps != n_tps {"}, {"sha": "52e8578124d46812b382c6566ae48830586a62a0", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -2,7 +2,7 @@\n \n use coherence::get_base_type_def_id;\n use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{mk_box, mk_rptr, mk_uniq};\n+use middle::ty::{mk_box, mk_rptr, mk_uniq, FnTyBase, FnMeta, FnSig};\n use syntax::ast::{def_id,\n                      sty_static, sty_box, sty_by_ref, sty_region, sty_uniq};\n use syntax::ast::{sty_value, by_ref, by_copy};\n@@ -411,9 +411,12 @@ struct lookup {\n \n     fn ty_from_did(did: ast::def_id) -> ty::t {\n         match ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n-          ty::ty_fn(fty) => {\n-            ty::mk_fn(self.tcx(),\n-                      {proto: ty::proto_vstore(ty::vstore_box),.. fty})\n+            ty::ty_fn(ref fty) => {\n+                ty::mk_fn(self.tcx(), FnTyBase {\n+                    meta: FnMeta {proto: ty::proto_vstore(ty::vstore_box),\n+                                  ..fty.meta},\n+                    sig: fty.sig\n+                })\n           }\n           _ => fail ~\"ty_from_did: not function ty\"\n         }\n@@ -553,8 +556,11 @@ struct lookup {\n \n         // a bit hokey, but the method unbound has a bare protocol, whereas\n         // a.b has a protocol like fn@() (perhaps eventually fn&()):\n-        let fty = ty::mk_fn(tcx, {proto: ty::proto_vstore(ty::vstore_box),\n-                                  .. m.fty});\n+        let fty = ty::mk_fn(tcx, FnTyBase {\n+            meta: FnMeta {proto: ty::proto_vstore(ty::vstore_box),\n+                          ..m.fty.meta},\n+            sig: m.fty.sig\n+        });\n \n         self.candidates.push(\n             {self_ty: self.self_ty,"}, {"sha": "bdb5cc5749c55e69ea88bf4bee098baaaf059512", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -216,10 +216,13 @@ fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n           result::Err(_) => return,   // Typechecking will fail anyhow.\n           result::Ok(function_type) => {\n             match ty::get(function_type).struct {\n-              ty::ty_fn({\n-                proto: proto_vstore(vstore_slice(region)), _\n-              }) => {\n-                constrain_free_variables(rcx, region, e);\n+              ty::ty_fn(ref fn_ty) => {\n+                  match fn_ty.meta.proto {\n+                      proto_vstore(vstore_slice(region)) => {\n+                          constrain_free_variables(rcx, region, e);\n+                      }\n+                      _ => {}\n+                  }\n               }\n               _ => ()\n             }"}, {"sha": "d7cbaa055881c20e8e7df841c8ac7daf37dd8830", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -9,9 +9,9 @@ fn replace_bound_regions_in_fn_ty(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n     self_info: Option<self_info>,\n-    fn_ty: &ty::fn_ty,\n+    fn_ty: &ty::FnTy,\n     mapf: fn(ty::bound_region) -> ty::region) ->\n-    {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::fn_ty} {\n+    {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::FnTy} {\n \n     // Take self_info apart; the self_ty part is the only one we want\n     // to update here."}, {"sha": "3b25e41d313cea1402ccb61bc27755b1db44b250", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -23,6 +23,7 @@ are represented as `ty_param()` instances.\n use astconv::{ast_conv, ty_of_fn_decl, ty_of_arg, ast_ty_to_ty};\n use ast_util::trait_method_to_ty_method;\n use rscope::*;\n+use ty::{FnTyBase, FnMeta, FnSig};\n \n fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n \n@@ -127,14 +128,14 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                     let arg_ty = ccx.to_ty(rs, va.ty);\n                     {mode: ast::expl(ast::by_copy), ty: arg_ty}\n                 });\n-                result_ty = Some(ty::mk_fn(tcx,\n-                                           {purity: ast::pure_fn,\n-                                            proto: ty::proto_vstore\n-                                                (ty::vstore_box),\n-                                            bounds: @~[],\n-                                            inputs: args,\n-                                            output: enum_ty,\n-                                            ret_style: ast::return_val}));\n+                result_ty = Some(ty::mk_fn(tcx, FnTyBase {\n+                    meta: FnMeta {purity: ast::pure_fn,\n+                                  proto: ty::proto_vstore(ty::vstore_box),\n+                                  bounds: @~[],\n+                                  ret_style: ast::return_val},\n+                    sig: FnSig {inputs: args,\n+                                output: enum_ty}\n+                }));\n             }\n             ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) => {\n                 result_ty = Some(enum_ty);\n@@ -247,7 +248,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n                        trait_m: ty::method, trait_substs: ty::substs,\n                        self_ty: ty::t) {\n \n-    if impl_m.fty.purity != trait_m.fty.purity {\n+    if impl_m.fty.meta.purity != trait_m.fty.meta.purity {\n         tcx.sess.span_err(\n             sp, fmt!(\"method `%s`'s purity does \\\n                           not match the trait method's \\\n@@ -268,12 +269,12 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         return;\n     }\n \n-    if vec::len(impl_m.fty.inputs) != vec::len(trait_m.fty.inputs) {\n+    if vec::len(impl_m.fty.sig.inputs) != vec::len(trait_m.fty.sig.inputs) {\n         tcx.sess.span_err(sp,fmt!(\"method `%s` has %u parameters \\\n                                    but the trait has %u\",\n                                    tcx.sess.str_of(trait_m.ident),\n-                                   vec::len(impl_m.fty.inputs),\n-                                   vec::len(trait_m.fty.inputs)));\n+                                   vec::len(impl_m.fty.sig.inputs),\n+                                   vec::len(trait_m.fty.sig.inputs)));\n         return;\n     }\n \n@@ -488,13 +489,15 @@ fn convert_struct(ccx: @crate_ctxt,\n             {self_r: rscope::bound_self_region(rp),\n              self_ty: None,\n              tps: ty::ty_params_to_tys(tcx, tps)});\n-        let t_ctor = ty::mk_fn(\n-            tcx, {purity: ast::impure_fn,\n-                  proto: ty::proto_vstore(ty::vstore_slice(ty::re_static)),\n-                  bounds: @~[],\n-                  inputs: t_args,\n-                  output: t_res,\n-                  ret_style: ast::return_val});\n+        let proto = ty::proto_vstore(ty::vstore_slice(ty::re_static));\n+        let t_ctor = ty::mk_fn(tcx, FnTyBase {\n+            meta: FnMeta {purity: ast::impure_fn,\n+                          proto: proto,\n+                          bounds: @~[],\n+                          ret_style: ast::return_val},\n+            sig: FnSig {inputs: t_args,\n+                        output: t_res}\n+        });\n         write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n         tcx.tcache.insert(local_def(ctor.node.id),\n                           {bounds: tpt.bounds,\n@@ -755,12 +758,14 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, a, None) );\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n-    let t_fn = ty::mk_fn(ccx.tcx, {purity: purity,\n-                                   proto: ty::proto_bare,\n-                                   bounds: @~[],\n-                                   inputs: input_tys,\n-                                   output: output_ty,\n-                                   ret_style: ast::return_val});\n+    let t_fn = ty::mk_fn(ccx.tcx, FnTyBase {\n+        meta: FnMeta {purity: purity,\n+                      proto: ty::proto_bare,\n+                      bounds: @~[],\n+                      ret_style: ast::return_val},\n+        sig: FnSig {inputs: input_tys,\n+                    output: output_ty}\n+    });\n     let tpt = {bounds: bounds, region_param: None, ty: t_fn};\n     ccx.tcx.tcache.insert(def_id, tpt);\n     return tpt;"}, {"sha": "07752df7b451188cac3c35e17695ebdc44c38e55", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -250,7 +250,7 @@ use std::smallintmap;\n use std::smallintmap::smallintmap;\n use std::map::hashmap;\n use middle::ty;\n-use middle::ty::{ty_vid, int_vid, region_vid, vid,\n+use middle::ty::{TyVid, IntVid, RegionVid, vid,\n                  ty_int, ty_uint, get, terr_fn, TyVar, IntVar};\n use syntax::{ast, ast_util};\n use syntax::ast::{ret_style, purity};\n@@ -312,11 +312,11 @@ enum infer_ctxt = @{\n     // We instantiate vals_and_bindings with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    ty_var_bindings: vals_and_bindings<ty::ty_vid, bounds<ty::t>>,\n+    ty_var_bindings: vals_and_bindings<ty::TyVid, bounds<ty::t>>,\n \n     // The types that might instantiate an integral type variable are\n     // represented by an int_ty_set.\n-    int_var_bindings: vals_and_bindings<ty::int_vid, int_ty_set>,\n+    int_var_bindings: vals_and_bindings<ty::IntVid, int_ty_set>,\n \n     // For region variables.\n     region_vars: RegionVarBindings,\n@@ -328,11 +328,11 @@ enum infer_ctxt = @{\n };\n \n enum fixup_err {\n-    unresolved_int_ty(int_vid),\n-    unresolved_ty(ty_vid),\n-    cyclic_ty(ty_vid),\n-    unresolved_region(region_vid),\n-    region_var_bound_by_region_var(region_vid, region_vid)\n+    unresolved_int_ty(IntVid),\n+    unresolved_ty(TyVid),\n+    cyclic_ty(TyVid),\n+    unresolved_region(RegionVid),\n+    region_var_bound_by_region_var(RegionVid, RegionVid)\n }\n \n fn fixup_err_to_str(f: fixup_err) -> ~str {\n@@ -596,12 +596,12 @@ impl infer_ctxt {\n }\n \n impl infer_ctxt {\n-    fn next_ty_var_id() -> ty_vid {\n+    fn next_ty_var_id() -> TyVid {\n         let id = *self.ty_var_counter;\n         *self.ty_var_counter += 1u;\n         self.ty_var_bindings.vals.insert(id,\n                                          root({lb: None, ub: None}, 0u));\n-        return ty_vid(id);\n+        return TyVid(id);\n     }\n \n     fn next_ty_var() -> ty::t {\n@@ -612,13 +612,13 @@ impl infer_ctxt {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    fn next_int_var_id() -> int_vid {\n+    fn next_int_var_id() -> IntVid {\n         let id = *self.int_var_counter;\n         *self.int_var_counter += 1u;\n \n         self.int_var_bindings.vals.insert(id,\n                               root(int_ty_set_all(), 0u));\n-        return int_vid(id);\n+        return IntVid(id);\n     }\n \n     fn next_int_var() -> ty::t {"}, {"sha": "8199d7058ff681db9080258b55f8fdfe5980873e", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -45,6 +45,7 @@\n // now.\n \n use to_str::to_str;\n+use ty::{FnTyBase, FnMeta, FnSig};\n \n trait combine {\n     fn infcx() -> infer_ctxt;\n@@ -62,7 +63,9 @@ trait combine {\n     fn self_tys(a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>>;\n     fn substs(did: ast::def_id, as: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs>;\n-    fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty>;\n+    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy>;\n+    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n+    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta>;\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n@@ -302,37 +305,47 @@ fn super_vstores<C:combine>(\n     }\n }\n \n-fn super_fns<C:combine>(\n-    self: &C, a_f: &ty::fn_ty, b_f: &ty::fn_ty) -> cres<ty::fn_ty> {\n+fn super_fn_metas<C:combine>(\n+    self: &C, a_f: &ty::FnMeta, b_f: &ty::FnMeta) -> cres<ty::FnMeta>\n+{\n+    do self.protos(a_f.proto, b_f.proto).chain |p| {\n+        do self.ret_styles(a_f.ret_style, b_f.ret_style).chain |rs| {\n+            do self.purities(a_f.purity, b_f.purity).chain |purity| {\n+                Ok(FnMeta {purity: purity,\n+                           proto: p,\n+                           bounds: a_f.bounds, // XXX: This is wrong!\n+                           ret_style: rs})\n+            }\n+        }\n+    }\n+}\n \n+fn super_fn_sigs<C:combine>(\n+    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n+{\n     fn argvecs<C:combine>(self: &C, a_args: ~[ty::arg],\n                           b_args: ~[ty::arg]) -> cres<~[ty::arg]> {\n \n         if vec::same_length(a_args, b_args) {\n-            map_vec2(a_args, b_args, |a, b| self.args(a, b) )\n+            map_vec2(a_args, b_args, |a, b| self.args(a, b))\n         } else {\n             Err(ty::terr_arg_count)\n         }\n     }\n \n-    do self.protos(a_f.proto, b_f.proto).chain |p| {\n-        do self.ret_styles(a_f.ret_style, b_f.ret_style).chain |rs| {\n-            do argvecs(self, a_f.inputs, b_f.inputs).chain |inputs| {\n-                do self.tys(a_f.output, b_f.output).chain |output| {\n-                    do self.purities(a_f.purity, b_f.purity).chain |purity| {\n-                    // FIXME: uncomment if #2588 doesn't get accepted:\n-                    // self.infcx().constrvecs(a_f.constraints,\n-                    //                         b_f.constraints).then {||\n-                        Ok({purity: purity,\n-                            proto: p,\n-                            bounds: a_f.bounds, // XXX: This is wrong!\n-                            inputs: inputs,\n-                            output: output,\n-                            ret_style: rs})\n-                    // }\n-                    }\n-                }\n-            }\n+    do argvecs(self, a_f.inputs, b_f.inputs).chain |inputs| {\n+        do self.tys(a_f.output, b_f.output).chain |output| {\n+            Ok(FnSig {inputs: inputs, output: output})\n+        }\n+    }\n+}\n+\n+fn super_fns<C:combine>(\n+    self: &C, a_f: &ty::FnTy, b_f: &ty::FnTy) -> cres<ty::FnTy>\n+{\n+    do self.fn_metas(&a_f.meta, &b_f.meta).chain |m| {\n+        do self.fn_sigs(&a_f.sig, &b_f.sig).chain |s| {\n+            Ok(FnTyBase {meta: m, sig: s})\n         }\n     }\n }"}, {"sha": "b69d85d9fe46bffa2aa74a675928186c3d1d2bb7", "filename": "src/rustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -147,10 +147,18 @@ impl Glb: combine {\n         super_args(&self, a, b)\n     }\n \n-    fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty> {\n+    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n         super_fns(&self, a, b)\n     }\n \n+    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n+        super_fn_metas(&self, a, b)\n+    }\n+\n+    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+        super_fn_sigs(&self, a, b)\n+    }\n+\n     fn substs(did: ast::def_id,\n               as: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {"}, {"sha": "49b2e57e2aa547b9e3e28a3ed22581c6832b5a7c", "filename": "src/rustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -68,7 +68,7 @@ fn lattice_tys<L:lattice_ops combine>(\n }\n \n fn lattice_vars<L:lattice_ops combine>(\n-    self: &L, +a_t: ty::t, +a_vid: ty::ty_vid, +b_vid: ty::ty_vid,\n+    self: &L, +a_t: ty::t, +a_vid: ty::TyVid, +b_vid: ty::TyVid,\n     c_ts: fn(ty::t, ty::t) -> cres<ty::t>) -> cres<ty::t> {\n \n     // The comments in this function are written for LUB and types,\n@@ -112,7 +112,7 @@ fn lattice_vars<L:lattice_ops combine>(\n }\n \n fn lattice_var_and_t<L:lattice_ops combine>(\n-    self: &L, a_id: ty::ty_vid, b: ty::t,\n+    self: &L, a_id: ty::TyVid, b: ty::t,\n     c_ts: fn(ty::t, ty::t) -> cres<ty::t>) -> cres<ty::t> {\n \n     let vb = &self.infcx().ty_var_bindings;"}, {"sha": "0c2f9ca6b1323d8244a7523a1eec99b63b50d166", "filename": "src/rustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -126,10 +126,18 @@ impl Lub: combine {\n         super_args(&self, a, b)\n     }\n \n-    fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty> {\n+    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n         super_fns(&self, a, b)\n     }\n \n+    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n+        super_fn_metas(&self, a, b)\n+    }\n+\n+    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+        super_fn_sigs(&self, a, b)\n+    }\n+\n     fn substs(did: ast::def_id,\n               as: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {"}, {"sha": "b34ffef811ae6b014ede2453f30fc7dae283d247", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -312,7 +312,7 @@ use std::map::{hashmap, uint_hash};\n use std::cell::{Cell, empty_cell};\n use std::list::{List, Nil, Cons};\n \n-use ty::{region, region_vid, hash_region};\n+use ty::{region, RegionVid, hash_region};\n use region::is_subregion_of;\n use syntax::codemap;\n use to_str::to_str;\n@@ -324,9 +324,9 @@ export lub_regions;\n export glb_regions;\n \n enum Constraint {\n-    ConstrainVarSubVar(region_vid, region_vid),\n-    ConstrainRegSubVar(region, region_vid),\n-    ConstrainVarSubReg(region_vid, region)\n+    ConstrainVarSubVar(RegionVid, RegionVid),\n+    ConstrainRegSubVar(region, RegionVid),\n+    ConstrainVarSubReg(RegionVid, region)\n }\n \n impl Constraint: cmp::Eq {\n@@ -361,12 +361,12 @@ impl TwoRegions: cmp::Eq {\n \n enum UndoLogEntry {\n     Snapshot,\n-    AddVar(region_vid),\n+    AddVar(RegionVid),\n     AddConstraint(Constraint),\n     AddCombination(CombineMap, TwoRegions)\n }\n \n-type CombineMap = hashmap<TwoRegions, region_vid>;\n+type CombineMap = hashmap<TwoRegions, RegionVid>;\n \n struct RegionVarBindings {\n     tcx: ty::ctxt;\n@@ -470,10 +470,10 @@ impl RegionVarBindings {\n         self.var_spans.len()\n     }\n \n-    fn new_region_var(span: span) -> region_vid {\n+    fn new_region_var(span: span) -> RegionVid {\n         let id = self.num_vars();\n         self.var_spans.push(span);\n-        let vid = region_vid(id);\n+        let vid = RegionVid(id);\n         if self.in_snapshot() {\n             self.undo_log.push(AddVar(vid));\n         }\n@@ -568,7 +568,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn resolve_var(rid: region_vid) -> ty::region {\n+    fn resolve_var(rid: RegionVid) -> ty::region {\n         debug!(\"RegionVarBindings: resolve_var(%?)\", rid);\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n@@ -857,7 +857,7 @@ impl RegionVarBindings {\n         return graph;\n \n         fn insert_edge(graph: &mut Graph,\n-                       node_id: region_vid,\n+                       node_id: RegionVid,\n                        edge_dir: Direction,\n                        edge_idx: uint) {\n             let edge_dir = edge_dir as uint;\n@@ -893,7 +893,7 @@ impl RegionVarBindings {\n     }\n \n     fn expand_node(a_region: region,\n-                   b_vid: region_vid,\n+                   b_vid: RegionVid,\n                    b_node: &GraphNode) -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n                a_region, b_vid, b_node.value);\n@@ -950,7 +950,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn contract_node(a_vid: region_vid,\n+    fn contract_node(a_vid: RegionVid,\n                      a_node: &GraphNode,\n                      b_region: region) -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n@@ -980,7 +980,7 @@ impl RegionVarBindings {\n         };\n \n         fn check_node(self: &RegionVarBindings,\n-                      a_vid: region_vid,\n+                      a_vid: RegionVid,\n                       a_node: &GraphNode,\n                       a_region: region,\n                       b_region: region) -> bool {\n@@ -993,7 +993,7 @@ impl RegionVarBindings {\n         }\n \n         fn adjust_node(self: &RegionVarBindings,\n-                       a_vid: region_vid,\n+                       a_vid: RegionVid,\n                        a_node: &GraphNode,\n                        a_region: region,\n                        b_region: region) -> bool {\n@@ -1051,7 +1051,7 @@ impl RegionVarBindings {\n               }\n \n               ErrorValue => {\n-                let node_vid = region_vid(idx);\n+                let node_vid = RegionVid(idx);\n                 match node.classification {\n                   Expanding => {\n                     self.report_error_for_expanding_node(\n@@ -1078,7 +1078,7 @@ impl RegionVarBindings {\n \n     fn report_error_for_expanding_node(graph: &Graph,\n                                        dup_map: TwoRegionsMap,\n-                                       node_idx: region_vid) {\n+                                       node_idx: RegionVid) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let lower_bounds =\n@@ -1130,7 +1130,7 @@ impl RegionVarBindings {\n \n     fn report_error_for_contracting_node(graph: &Graph,\n                                          dup_map: TwoRegionsMap,\n-                                         node_idx: region_vid) {\n+                                         node_idx: RegionVid) {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n         let upper_bounds = self.collect_concrete_regions(graph, node_idx,\n@@ -1182,7 +1182,7 @@ impl RegionVarBindings {\n     }\n \n     fn collect_concrete_regions(graph: &Graph,\n-                                orig_node_idx: region_vid,\n+                                orig_node_idx: RegionVid,\n                                 dir: Direction) -> ~[SpannedRegion] {\n         let set = uint_hash();\n         let mut stack = ~[orig_node_idx];\n@@ -1224,7 +1224,7 @@ impl RegionVarBindings {\n     }\n \n     fn each_edge(graph: &Graph,\n-                 node_idx: region_vid,\n+                 node_idx: RegionVid,\n                  dir: Direction,\n                  op: fn(edge: &GraphEdge) -> bool) {\n         let mut edge_idx = graph.nodes[*node_idx].head_edge[dir as uint];"}, {"sha": "e77b5a52aafd77bf893c83050955051567c955cc", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -55,7 +55,7 @@ type resolve_state_ = {\n     infcx: infer_ctxt,\n     modes: uint,\n     mut err: Option<fixup_err>,\n-    mut v_seen: ~[ty_vid]\n+    mut v_seen: ~[TyVid]\n };\n \n enum resolve_state {\n@@ -153,14 +153,14 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_region_var(rid: region_vid) -> ty::region {\n+    fn resolve_region_var(rid: RegionVid) -> ty::region {\n         if !self.should(resolve_rvar) {\n             return ty::re_var(rid)\n         }\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    fn assert_not_rvar(rid: region_vid, r: ty::region) {\n+    fn assert_not_rvar(rid: RegionVid, r: ty::region) {\n         match r {\n           ty::re_var(rid2) => {\n             self.err = Some(region_var_bound_by_region_var(rid, rid2));\n@@ -169,7 +169,7 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_ty_var(vid: ty_vid) -> ty::t {\n+    fn resolve_ty_var(vid: TyVid) -> ty::t {\n         if vec::contains(self.v_seen, vid) {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n@@ -202,7 +202,7 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_int_var(vid: int_vid) -> ty::t {\n+    fn resolve_int_var(vid: IntVid) -> ty::t {\n         if !self.should(resolve_ivar) {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }"}, {"sha": "8c83f03838abefae7b8feac835df94147935f46d", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -124,7 +124,7 @@ impl Sub: combine {\n         }\n     }\n \n-    fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty> {\n+    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n         // that function subtyping works correctly with respect to regions\n@@ -171,6 +171,14 @@ impl Sub: combine {\n         super_flds(&self, a, b)\n     }\n \n+    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n+        super_fn_metas(&self, a, b)\n+    }\n+\n+    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+        super_fn_sigs(&self, a, b)\n+    }\n+\n     fn vstores(vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n         super_vstores(&self, vk, a, b)"}, {"sha": "65cbcdcb40a244745066ae14fac77682d007d27d", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -113,7 +113,7 @@ fn merge_bnds<C: combine>(\n \n fn set_var_to_merged_bounds<C: combine>(\n     self: &C,\n-    v_id: ty::ty_vid,\n+    v_id: ty::TyVid,\n     a: bounds<ty::t>,\n     b: bounds<ty::t>,\n     rank: uint) -> ures {\n@@ -175,8 +175,8 @@ fn set_var_to_merged_bounds<C: combine>(\n /// subtle and tricky process, as described in detail at the top\n /// of infer.rs\n fn var_sub_var<C: combine>(self: &C,\n-                           a_id: ty::ty_vid,\n-                           b_id: ty::ty_vid) -> ures {\n+                           a_id: ty::TyVid,\n+                           b_id: ty::TyVid) -> ures {\n     let vb = &self.infcx().ty_var_bindings;\n \n     // Need to make sub_id a subtype of sup_id.\n@@ -241,7 +241,7 @@ fn var_sub_var<C: combine>(self: &C,\n }\n \n /// make variable a subtype of T\n-fn var_sub_t<C: combine>(self: &C, a_id: ty::ty_vid, b: ty::t) -> ures {\n+fn var_sub_t<C: combine>(self: &C, a_id: ty::TyVid, b: ty::t) -> ures {\n \n     let vb = &self.infcx().ty_var_bindings;\n     let nde_a = self.infcx().get(vb, a_id);\n@@ -257,7 +257,7 @@ fn var_sub_t<C: combine>(self: &C, a_id: ty::ty_vid, b: ty::t) -> ures {\n }\n \n /// make T a subtype of variable\n-fn t_sub_var<C: combine>(self: &C, a: ty::t, b_id: ty::ty_vid) -> ures {\n+fn t_sub_var<C: combine>(self: &C, a: ty::t, b_id: ty::TyVid) -> ures {\n \n     let vb = &self.infcx().ty_var_bindings;\n     let a_bounds = {lb: Some(a), ub: None};\n@@ -294,7 +294,7 @@ fn bnds<C: combine>(\n // Integral variables\n \n impl infer_ctxt {\n-    fn int_vars(a_id: ty::int_vid, b_id: ty::int_vid) -> ures {\n+    fn int_vars(a_id: ty::IntVid, b_id: ty::IntVid) -> ures {\n         let vb = &self.int_var_bindings;\n \n         let nde_a = self.get(vb, a_id);\n@@ -340,7 +340,7 @@ impl infer_ctxt {\n         uok()\n     }\n \n-    fn int_var_sub_t(a_id: ty::int_vid, b: ty::t) -> ures {\n+    fn int_var_sub_t(a_id: ty::IntVid, b: ty::t) -> ures {\n         assert ty::type_is_integral(b);\n \n         let vb = &self.int_var_bindings;\n@@ -358,7 +358,7 @@ impl infer_ctxt {\n         uok()\n     }\n \n-    fn t_sub_int_var(a: ty::t, b_id: ty::int_vid) -> ures {\n+    fn t_sub_int_var(a: ty::t, b_id: ty::IntVid) -> ures {\n         assert ty::type_is_integral(a);\n         let vb = &self.int_var_bindings;\n "}, {"sha": "f78495ef198c2f223e740e013f2b92468cccf4fe", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8786fe522ed96172cf1ae8e205e3f2722e834c/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=fb8786fe522ed96172cf1ae8e205e3f2722e834c", "patch": "@@ -283,8 +283,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n     fn method_to_str(cx: ctxt, m: method) -> ~str {\n         return fn_to_str(\n-            cx, m.fty.purity, m.fty.proto, Some(m.ident), m.fty.inputs,\n-            m.fty.output, m.fty.ret_style) + ~\";\";\n+            cx, m.fty.meta.purity, m.fty.meta.proto, Some(m.ident),\n+            m.fty.sig.inputs, m.fty.sig.output,\n+            m.fty.meta.ret_style) + ~\";\";\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n         return cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n@@ -331,9 +332,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         for elems.each |elem| { vec::push(strs, ty_to_str(cx, elem)); }\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n       }\n-      ty_fn(f) => {\n-        fn_to_str(cx, f.purity, f.proto, None, f.inputs,\n-                  f.output, f.ret_style)\n+      ty_fn(ref f) => {\n+        fn_to_str(cx, f.meta.purity, f.meta.proto, None, f.sig.inputs,\n+                  f.sig.output, f.meta.ret_style)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_param({idx: id, _}) => {"}]}