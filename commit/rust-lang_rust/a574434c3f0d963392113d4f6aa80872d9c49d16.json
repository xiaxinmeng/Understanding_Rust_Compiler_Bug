{"sha": "a574434c3f0d963392113d4f6aa80872d9c49d16", "node_id": "C_kwDOAAsO6NoAKGE1NzQ0MzRjM2YwZDk2MzM5MjExM2Q0ZjZhYTgwODcyZDljNDlkMTY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-20T12:47:06Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-20T12:47:06Z"}, "message": "Simplify NameClass::classify", "tree": {"sha": "f95013fe6e5b4307283ab49a3ecc8a023e99b151", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f95013fe6e5b4307283ab49a3ecc8a023e99b151"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a574434c3f0d963392113d4f6aa80872d9c49d16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a574434c3f0d963392113d4f6aa80872d9c49d16", "html_url": "https://github.com/rust-lang/rust/commit/a574434c3f0d963392113d4f6aa80872d9c49d16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a574434c3f0d963392113d4f6aa80872d9c49d16/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a87708aee788de10352603baff82f6d2192fad", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a87708aee788de10352603baff82f6d2192fad", "html_url": "https://github.com/rust-lang/rust/commit/37a87708aee788de10352603baff82f6d2192fad"}], "stats": {"total": 214, "additions": 100, "deletions": 114}, "files": [{"sha": "a299aa449888ff0c981f2719e07bad760496032f", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a574434c3f0d963392113d4f6aa80872d9c49d16/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a574434c3f0d963392113d4f6aa80872d9c49d16/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=a574434c3f0d963392113d4f6aa80872d9c49d16", "patch": "@@ -1130,6 +1130,7 @@ to_def_impls![\n     (crate::TypeParam, ast::TypeParam, type_param_to_def),\n     (crate::LifetimeParam, ast::LifetimeParam, lifetime_param_to_def),\n     (crate::ConstParam, ast::ConstParam, const_param_to_def),\n+    (crate::GenericParam, ast::GenericParam, generic_param_to_def),\n     (crate::MacroDef, ast::Macro, macro_to_def),\n     (crate::Local, ast::IdentPat, bind_pat_to_def),\n     (crate::Local, ast::SelfParam, self_param_to_def),"}, {"sha": "9b8e5635923bccecb1c424c97e0482534214a6d0", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a574434c3f0d963392113d4f6aa80872d9c49d16/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a574434c3f0d963392113d4f6aa80872d9c49d16/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=a574434c3f0d963392113d4f6aa80872d9c49d16", "patch": "@@ -92,8 +92,8 @@ use hir_def::{\n     expr::{LabelId, PatId},\n     keys::{self, Key},\n     AdtId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FieldId, FunctionId,\n-    GenericDefId, ImplId, LifetimeParamId, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId, VariantId,\n+    GenericDefId, GenericParamId, ImplId, LifetimeParamId, ModuleId, StaticId, StructId, TraitId,\n+    TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::AsName, AstId, HirFileId, MacroCallId, MacroDefId, MacroDefKind};\n use rustc_hash::FxHashMap;\n@@ -299,6 +299,23 @@ impl SourceToDefCtx<'_, '_> {\n         dyn_map[keys::CONST_PARAM].get(&src).copied()\n     }\n \n+    pub(super) fn generic_param_to_def(\n+        &mut self,\n+        InFile { file_id, value }: InFile<ast::GenericParam>,\n+    ) -> Option<GenericParamId> {\n+        match value {\n+            ast::GenericParam::ConstParam(it) => {\n+                self.const_param_to_def(InFile::new(file_id, it)).map(GenericParamId::ConstParamId)\n+            }\n+            ast::GenericParam::LifetimeParam(it) => self\n+                .lifetime_param_to_def(InFile::new(file_id, it))\n+                .map(GenericParamId::LifetimeParamId),\n+            ast::GenericParam::TypeParam(it) => {\n+                self.type_param_to_def(InFile::new(file_id, it)).map(GenericParamId::TypeParamId)\n+            }\n+        }\n+    }\n+\n     pub(super) fn macro_to_def(&mut self, src: InFile<ast::Macro>) -> Option<MacroDefId> {\n         let makro = self.dyn_map(src.as_ref()).and_then(|it| it[keys::MACRO].get(&src).copied());\n         if let res @ Some(_) = makro {"}, {"sha": "b5a13cea91728d162862284b22893b83edf88031", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 80, "deletions": 112, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/a574434c3f0d963392113d4f6aa80872d9c49d16/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a574434c3f0d963392113d4f6aa80872d9c49d16/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=a574434c3f0d963392113d4f6aa80872d9c49d16", "patch": "@@ -224,125 +224,93 @@ impl NameClass {\n \n         let parent = name.syntax().parent()?;\n \n-        if let Some(bind_pat) = ast::IdentPat::cast(parent.clone()) {\n-            if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n+        let def = if let Some(item) = ast::Item::cast(parent.clone()) {\n+            match item {\n+                ast::Item::MacroRules(it) => {\n+                    Definition::Macro(sema.to_def(&ast::Macro::MacroRules(it))?)\n+                }\n+                ast::Item::MacroDef(it) => {\n+                    Definition::Macro(sema.to_def(&ast::Macro::MacroDef(it))?)\n+                }\n+                ast::Item::Const(it) => Definition::Const(sema.to_def(&it)?),\n+                ast::Item::Fn(it) => Definition::Function(sema.to_def(&it)?),\n+                ast::Item::Module(it) => Definition::Module(sema.to_def(&it)?),\n+                ast::Item::Static(it) => Definition::Static(sema.to_def(&it)?),\n+                ast::Item::Trait(it) => Definition::Trait(sema.to_def(&it)?),\n+                ast::Item::TypeAlias(it) => Definition::TypeAlias(sema.to_def(&it)?),\n+                ast::Item::Enum(it) => Definition::Adt(hir::Adt::Enum(sema.to_def(&it)?)),\n+                ast::Item::Struct(it) => Definition::Adt(hir::Adt::Struct(sema.to_def(&it)?)),\n+                ast::Item::Union(it) => Definition::Adt(hir::Adt::Union(sema.to_def(&it)?)),\n+                _ => return None,\n+            }\n+        } else if let Some(it) = ast::IdentPat::cast(parent.clone()) {\n+            if let Some(def) = sema.resolve_bind_pat_to_const(&it) {\n                 return Some(NameClass::ConstReference(Definition::from(def)));\n             }\n-        }\n \n-        match_ast! {\n-            match parent {\n-                ast::Rename(it) => {\n-                    if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n-                        let path = use_tree.path()?;\n-                        let path_segment = path.segment()?;\n-                        let name_ref = path_segment.name_ref()?;\n-                        let name_ref = if name_ref.self_token().is_some() {\n-                             use_tree\n-                                .syntax()\n-                                .parent()\n-                                .as_ref()\n-                                // Skip over UseTreeList\n-                                .and_then(|it| {\n-                                    let use_tree = it.parent().and_then(ast::UseTree::cast)?;\n-                                    let path = use_tree.path()?;\n-                                    let path_segment = path.segment()?;\n-                                    path_segment.name_ref()\n-                                }).unwrap_or(name_ref)\n-                        } else {\n-                            name_ref\n-                        };\n-                        let name_ref_class = NameRefClass::classify(sema, &name_ref)?;\n-\n-                        Some(NameClass::Definition(match name_ref_class {\n-                            NameRefClass::Definition(def) => def,\n-                            NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n-                                Definition::Field(field_ref)\n-                            }\n-                        }))\n-                    } else {\n-                        let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n-                        let krate = sema.resolve_extern_crate(&extern_crate)?;\n-                        let root_module = krate.root_module(sema.db);\n-                        Some(NameClass::Definition(Definition::Module(root_module)))\n+            let local = sema.to_def(&it)?;\n+            let pat_parent = it.syntax().parent();\n+            if let Some(record_pat_field) = pat_parent.and_then(ast::RecordPatField::cast) {\n+                if record_pat_field.name_ref().is_none() {\n+                    if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                        return Some(NameClass::PatFieldShorthand {\n+                            local_def: local,\n+                            field_ref: field,\n+                        });\n                     }\n-                },\n-                ast::IdentPat(it) => {\n-                    let local = sema.to_def(&it)?;\n+                }\n+            }\n \n-                    if let Some(record_pat_field) = it.syntax().parent().and_then(ast::RecordPatField::cast) {\n-                        if record_pat_field.name_ref().is_none() {\n-                            if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n-                                return Some(NameClass::PatFieldShorthand { local_def: local, field_ref: field });\n-                            }\n-                        }\n-                    }\n+            Definition::Local(local)\n+        } else if let Some(it) = ast::Rename::cast(parent.clone()) {\n+            if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n+                let path = use_tree.path()?;\n+                let path_segment = path.segment()?;\n+                let name_ref = path_segment.name_ref()?;\n+                let name_ref = if name_ref.self_token().is_some() {\n+                    use_tree\n+                        .syntax()\n+                        .parent()\n+                        .as_ref()\n+                        // Skip over UseTreeList\n+                        .and_then(|it| {\n+                            let use_tree = it.parent().and_then(ast::UseTree::cast)?;\n+                            let path = use_tree.path()?;\n+                            let path_segment = path.segment()?;\n+                            path_segment.name_ref()\n+                        })\n+                        .unwrap_or(name_ref)\n+                } else {\n+                    name_ref\n+                };\n+                let name_ref_class = NameRefClass::classify(sema, &name_ref)?;\n \n-                    Some(NameClass::Definition(Definition::Local(local)))\n-                },\n-                ast::SelfParam(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Local(def)))\n-                },\n-                ast::RecordField(it) => {\n-                    let field: hir::Field = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Field(field)))\n-                },\n-                ast::Module(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Module(def)))\n-                },\n-                ast::Struct(it) => {\n-                    let def: hir::Struct = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Adt(def.into())))\n-                },\n-                ast::Union(it) => {\n-                    let def: hir::Union = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Adt(def.into())))\n-                },\n-                ast::Enum(it) => {\n-                    let def: hir::Enum = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Adt(def.into())))\n-                },\n-                ast::Trait(it) => {\n-                    let def: hir::Trait = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Trait(def)))\n-                },\n-                ast::Static(it) => {\n-                    let def: hir::Static = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Static(def)))\n-                },\n-                ast::Variant(it) => {\n-                    let def: hir::Variant = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Variant(def)))\n-                },\n-                ast::Fn(it) => {\n-                    let def: hir::Function = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Function(def)))\n-                },\n-                ast::Const(it) => {\n-                    let def: hir::Const = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Const(def)))\n-                },\n-                ast::TypeAlias(it) => {\n-                    let def: hir::TypeAlias = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::TypeAlias(def)))\n-                },\n-                ast::Macro(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Macro(def)))\n-                },\n-                ast::TypeParam(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::GenericParam(def.into())))\n-                },\n-                ast::ConstParam(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::GenericParam(def.into())))\n-                },\n-                _ => None,\n+                match name_ref_class {\n+                    NameRefClass::Definition(def) => def,\n+                    NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n+                        Definition::Field(field_ref)\n+                    }\n+                }\n+            } else {\n+                let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n+                let krate = sema.resolve_extern_crate(&extern_crate)?;\n+                let root_module = krate.root_module(sema.db);\n+                Definition::Module(root_module)\n             }\n-        }\n+        } else {\n+            match_ast! {\n+                match parent {\n+                    ast::SelfParam(it) => Definition::Local(sema.to_def(&it)?),\n+                    ast::RecordField(it) => Definition::Field(sema.to_def(&it)?),\n+                    ast::Variant(it) => Definition::Variant(sema.to_def(&it)?),\n+                    ast::TypeParam(it) => Definition::GenericParam(sema.to_def(&it)?.into()),\n+                    ast::ConstParam(it) => Definition::GenericParam(sema.to_def(&it)?.into()),\n+                    _ => return None,\n+                }\n+            }\n+        };\n+\n+        Some(NameClass::Definition(def))\n     }\n \n     pub fn classify_lifetime("}]}