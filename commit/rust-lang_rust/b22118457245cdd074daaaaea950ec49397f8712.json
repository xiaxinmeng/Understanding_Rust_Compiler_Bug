{"sha": "b22118457245cdd074daaaaea950ec49397f8712", "node_id": "C_kwDOAAsO6NoAKGIyMjExODQ1NzI0NWNkZDA3NGRhYWFhZWE5NTBlYzQ5Mzk3Zjg3MTI", "commit": {"author": {"name": "Jacob Kiesel", "email": "kieseljake@live.com", "date": "2022-09-16T02:50:28Z"}, "committer": {"name": "Jacob Kiesel", "email": "kieseljake@gmail.com", "date": "2022-10-01T19:58:41Z"}, "message": "Implement manual_clamp lint", "tree": {"sha": "f89893cc5d5ed6da23eed321116308c321fae611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f89893cc5d5ed6da23eed321116308c321fae611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b22118457245cdd074daaaaea950ec49397f8712", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b22118457245cdd074daaaaea950ec49397f8712", "html_url": "https://github.com/rust-lang/rust/commit/b22118457245cdd074daaaaea950ec49397f8712", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b22118457245cdd074daaaaea950ec49397f8712/comments", "author": {"login": "Xaeroxe", "id": 6182002, "node_id": "MDQ6VXNlcjYxODIwMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/6182002?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xaeroxe", "html_url": "https://github.com/Xaeroxe", "followers_url": "https://api.github.com/users/Xaeroxe/followers", "following_url": "https://api.github.com/users/Xaeroxe/following{/other_user}", "gists_url": "https://api.github.com/users/Xaeroxe/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xaeroxe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xaeroxe/subscriptions", "organizations_url": "https://api.github.com/users/Xaeroxe/orgs", "repos_url": "https://api.github.com/users/Xaeroxe/repos", "events_url": "https://api.github.com/users/Xaeroxe/events{/privacy}", "received_events_url": "https://api.github.com/users/Xaeroxe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xaeroxe", "id": 6182002, "node_id": "MDQ6VXNlcjYxODIwMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/6182002?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xaeroxe", "html_url": "https://github.com/Xaeroxe", "followers_url": "https://api.github.com/users/Xaeroxe/followers", "following_url": "https://api.github.com/users/Xaeroxe/following{/other_user}", "gists_url": "https://api.github.com/users/Xaeroxe/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xaeroxe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xaeroxe/subscriptions", "organizations_url": "https://api.github.com/users/Xaeroxe/orgs", "repos_url": "https://api.github.com/users/Xaeroxe/repos", "events_url": "https://api.github.com/users/Xaeroxe/events{/privacy}", "received_events_url": "https://api.github.com/users/Xaeroxe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "url": "https://api.github.com/repos/rust-lang/rust/commits/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "html_url": "https://github.com/rust-lang/rust/commit/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4"}], "stats": {"total": 1498, "additions": 1479, "deletions": 19}, "files": [{"sha": "9f12a67359624a6e74e7da9ab3df48503067661c", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -3985,6 +3985,7 @@ Released 2018-09-13\n [`manual_assert`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_assert\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_bits`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits\n+[`manual_clamp`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map"}, {"sha": "9ad2a88eb26ca95a986d87d47b0c19bcb5a17a4e", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -125,6 +125,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(main_recursion::MAIN_RECURSION),\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n     LintId::of(manual_bits::MANUAL_BITS),\n+    LintId::of(manual_clamp::MANUAL_CLAMP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n     LintId::of(manual_retain::MANUAL_RETAIN),"}, {"sha": "a58d066fa6b6737bd58e69b9bf7294513490cf60", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -22,6 +22,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(loops::MANUAL_FLATTEN),\n     LintId::of(loops::SINGLE_ELEMENT_LOOP),\n     LintId::of(loops::WHILE_LET_LOOP),\n+    LintId::of(manual_clamp::MANUAL_CLAMP),\n     LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),"}, {"sha": "f3ddac49ace1bc45a4150cf5539854c040176238", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -245,6 +245,7 @@ store.register_lints(&[\n     manual_assert::MANUAL_ASSERT,\n     manual_async_fn::MANUAL_ASYNC_FN,\n     manual_bits::MANUAL_BITS,\n+    manual_clamp::MANUAL_CLAMP,\n     manual_instant_elapsed::MANUAL_INSTANT_ELAPSED,\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n     manual_rem_euclid::MANUAL_REM_EUCLID,"}, {"sha": "4da3c9ece6654dd8ab751b1fb8cd1f8081e6d83e", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -268,6 +268,7 @@ mod main_recursion;\n mod manual_assert;\n mod manual_async_fn;\n mod manual_bits;\n+mod manual_clamp;\n mod manual_instant_elapsed;\n mod manual_non_exhaustive;\n mod manual_rem_euclid;\n@@ -899,6 +900,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::<std_instead_of_core::StdReexports>::default());\n     store.register_late_pass(|_| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n     store.register_late_pass(|_| Box::new(partialeq_to_none::PartialeqToNone));\n+    store.register_late_pass(move |_| Box::new(manual_clamp::ManualClamp::new(msrv)));\n     store.register_late_pass(|_| Box::new(manual_string_new::ManualStringNew));\n     store.register_late_pass(|_| Box::new(unused_peekable::UnusedPeekable));\n     store.register_early_pass(|| Box::new(multi_assignments::MultiAssignments));"}, {"sha": "ac5c24ee604bd8425705f08d41fa0f90d25bd0be", "filename": "clippy_lints/src/manual_clamp.rs", "status": "added", "additions": 715, "deletions": 0, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_clamp.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -0,0 +1,715 @@\n+use itertools::Itertools;\n+use rustc_errors::Diagnostic;\n+use rustc_hir::{\n+    def::Res, Arm, BinOpKind, Block, Expr, ExprKind, Guard, HirId, PatKind, PathSegment, PrimTy, QPath, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{symbol::sym, Span};\n+use std::ops::Deref;\n+\n+use clippy_utils::{\n+    diagnostics::{span_lint_and_then, span_lint_hir_and_then},\n+    eq_expr_value, get_trait_def_id,\n+    higher::If,\n+    is_diag_trait_item, is_trait_method, meets_msrv, msrvs, path_res, path_to_local_id, paths, peel_blocks,\n+    peel_blocks_with_stmt,\n+    sugg::Sugg,\n+    ty::implements_trait,\n+    visitors::is_const_evaluatable,\n+    MaybePath,\n+};\n+use rustc_errors::Applicability;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Identifies good opportunities for a clamp function from std or core, and suggests using it.\n+    ///\n+    /// ### Why is this bad?\n+    /// clamp is much shorter, easier to read, and doesn't use any control flow.\n+    ///\n+    /// ### Known issue(s)\n+    /// If the clamped variable is NaN this suggestion will cause the code to propagate NaN\n+    /// rather than returning either `max` or `min`.\n+    ///\n+    /// `clamp` functions will panic if `max < min`, `max.is_nan()`, or `min.is_nan()`.\n+    /// Some may consider panicking in these situations to be desirable, but it also may\n+    /// introduce panicking where there wasn't any before.\n+    ///\n+    /// ### Examples\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// if input > max {\n+    ///     max\n+    /// } else if input < min {\n+    ///     min\n+    /// } else {\n+    ///     input\n+    /// }\n+    /// # ;\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// input.max(min).min(max)\n+    /// # ;\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// match input {\n+    ///     x if x > max => max,\n+    ///     x if x < min => min,\n+    ///     x => x,\n+    /// }\n+    /// # ;\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// let mut x = input;\n+    /// if x < min { x = min; }\n+    /// if x > max { x = max; }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let (input, min, max) = (0, -2, 1);\n+    /// input.clamp(min, max)\n+    /// # ;\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub MANUAL_CLAMP,\n+    complexity,\n+    \"using a clamp pattern instead of the clamp function\"\n+}\n+impl_lint_pass!(ManualClamp => [MANUAL_CLAMP]);\n+\n+pub struct ManualClamp {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualClamp {\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ClampSuggestion<'tcx> {\n+    params: InputMinMax<'tcx>,\n+    span: Span,\n+    make_assignment: Option<&'tcx Expr<'tcx>>,\n+    hir_with_ignore_attr: Option<HirId>,\n+}\n+\n+#[derive(Debug)]\n+struct InputMinMax<'tcx> {\n+    input: &'tcx Expr<'tcx>,\n+    min: &'tcx Expr<'tcx>,\n+    max: &'tcx Expr<'tcx>,\n+    is_float: bool,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualClamp {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if !meets_msrv(self.msrv, msrvs::CLAMP) {\n+            return;\n+        }\n+        if !expr.span.from_expansion() {\n+            let suggestion = is_if_elseif_else_pattern(cx, expr)\n+                .or_else(|| is_max_min_pattern(cx, expr))\n+                .or_else(|| is_call_max_min_pattern(cx, expr))\n+                .or_else(|| is_match_pattern(cx, expr))\n+                .or_else(|| is_if_elseif_pattern(cx, expr));\n+            if let Some(suggestion) = suggestion {\n+                emit_suggestion(cx, &suggestion);\n+            }\n+        }\n+    }\n+\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) {\n+        if !meets_msrv(self.msrv, msrvs::CLAMP) {\n+            return;\n+        }\n+        for suggestion in is_two_if_pattern(cx, block) {\n+            emit_suggestion(cx, &suggestion);\n+        }\n+    }\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn emit_suggestion<'tcx>(cx: &LateContext<'tcx>, suggestion: &ClampSuggestion<'tcx>) {\n+    let ClampSuggestion {\n+        params: InputMinMax {\n+            input,\n+            min,\n+            max,\n+            is_float,\n+        },\n+        span,\n+        make_assignment,\n+        hir_with_ignore_attr,\n+    } = suggestion;\n+    let input = Sugg::hir(cx, input, \"..\").maybe_par();\n+    let min = Sugg::hir(cx, min, \"..\");\n+    let max = Sugg::hir(cx, max, \"..\");\n+    let semicolon = if make_assignment.is_some() { \";\" } else { \"\" };\n+    let assignment = if let Some(assignment) = make_assignment {\n+        let assignment = Sugg::hir(cx, assignment, \"..\");\n+        format!(\"{assignment} = \")\n+    } else {\n+        String::new()\n+    };\n+    let suggestion = format!(\"{assignment}{input}.clamp({min}, {max}){semicolon}\");\n+    let msg = \"clamp-like pattern without using clamp function\";\n+    let lint_builder = |d: &mut Diagnostic| {\n+        d.span_suggestion(*span, \"replace with clamp\", suggestion, Applicability::MaybeIncorrect);\n+        if *is_float {\n+            d.note(\"clamp will panic if max < min, min.is_nan(), or max.is_nan()\")\n+                .note(\"clamp returns NaN if the input is NaN\");\n+        } else {\n+            d.note(\"clamp will panic if max < min\");\n+        }\n+    };\n+    if let Some(hir_id) = hir_with_ignore_attr {\n+        span_lint_hir_and_then(cx, MANUAL_CLAMP, *hir_id, *span, msg, lint_builder);\n+    } else {\n+        span_lint_and_then(cx, MANUAL_CLAMP, *span, msg, lint_builder);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+enum TypeClampability {\n+    Float,\n+    Ord,\n+}\n+\n+impl TypeClampability {\n+    fn is_clampable<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<TypeClampability> {\n+        if ty.is_floating_point() {\n+            Some(TypeClampability::Float)\n+        } else if get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n+            Some(TypeClampability::Ord)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn is_float(self) -> bool {\n+        matches!(self, TypeClampability::Float)\n+    }\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min, max) = (0, -3, 12);\n+///\n+/// if input < min {\n+///     min\n+/// } else if input > max {\n+///     max\n+/// } else {\n+///     input\n+/// }\n+/// # ;\n+/// ```\n+fn is_if_elseif_else_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    if let Some(If {\n+        cond,\n+        then,\n+        r#else: Some(else_if),\n+    }) = If::hir(expr)\n+    && let Some(If {\n+        cond: else_if_cond,\n+        then: else_if_then,\n+        r#else: Some(else_body),\n+    }) = If::hir(peel_blocks(else_if))\n+    {\n+        let params = is_clamp_meta_pattern(\n+            cx,\n+            &BinaryOp::new(peel_blocks(cond))?,\n+            &BinaryOp::new(peel_blocks(else_if_cond))?,\n+            peel_blocks(then),\n+            peel_blocks(else_if_then),\n+            None,\n+        )?;\n+        // Contents of the else should be the resolved input.\n+        if !eq_expr_value(cx, params.input, peel_blocks(else_body)) {\n+            return None;\n+        }\n+        Some(ClampSuggestion {\n+            params,\n+            span: expr.span,\n+            make_assignment: None,\n+            hir_with_ignore_attr: None,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min_value, max_value) = (0, -3, 12);\n+///\n+/// input.max(min_value).min(max_value)\n+/// # ;\n+/// ```\n+fn is_max_min_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    if let ExprKind::MethodCall(seg_second, receiver, [arg_second], _) = &expr.kind\n+        && (cx.typeck_results().expr_ty_adjusted(receiver).is_floating_point() || is_trait_method(cx, expr, sym::Ord))\n+        && let ExprKind::MethodCall(seg_first, input, [arg_first], _) = &receiver.kind\n+        && (cx.typeck_results().expr_ty_adjusted(input).is_floating_point() || is_trait_method(cx, receiver, sym::Ord))\n+    {\n+        let is_float = cx.typeck_results().expr_ty_adjusted(input).is_floating_point();\n+        let (min, max) = match (seg_first.ident.as_str(), seg_second.ident.as_str()) {\n+            (\"min\", \"max\") => (arg_second, arg_first),\n+            (\"max\", \"min\") => (arg_first, arg_second),\n+            _ => return None,\n+        };\n+        Some(ClampSuggestion {\n+            params: InputMinMax { input, min, max, is_float },\n+            span: expr.span,\n+            make_assignment: None,\n+            hir_with_ignore_attr: None,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min_value, max_value) = (0, -3, 12);\n+/// # use std::cmp::{max, min};\n+/// min(max(input, min_value), max_value)\n+/// # ;\n+/// ```\n+fn is_call_max_min_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    fn segment<'tcx>(cx: &LateContext<'_>, func: &Expr<'tcx>) -> Option<FunctionType<'tcx>> {\n+        match func.kind {\n+            ExprKind::Path(QPath::Resolved(None, path)) => {\n+                let id = path.res.opt_def_id()?;\n+                match cx.tcx.get_diagnostic_name(id) {\n+                    Some(sym::cmp_min) => Some(FunctionType::CmpMin),\n+                    Some(sym::cmp_max) => Some(FunctionType::CmpMax),\n+                    _ if is_diag_trait_item(cx, id, sym::Ord) => {\n+                        Some(FunctionType::OrdOrFloat(path.segments.last().expect(\"infallible\")))\n+                    },\n+                    _ => None,\n+                }\n+            },\n+            ExprKind::Path(QPath::TypeRelative(ty, seg)) => {\n+                matches!(path_res(cx, ty), Res::PrimTy(PrimTy::Float(_))).then(|| FunctionType::OrdOrFloat(seg))\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    enum FunctionType<'tcx> {\n+        CmpMin,\n+        CmpMax,\n+        OrdOrFloat(&'tcx PathSegment<'tcx>),\n+    }\n+\n+    fn check<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        outer_fn: &'tcx Expr<'tcx>,\n+        inner_call: &'tcx Expr<'tcx>,\n+        outer_arg: &'tcx Expr<'tcx>,\n+        span: Span,\n+    ) -> Option<ClampSuggestion<'tcx>> {\n+        if let ExprKind::Call(inner_fn, &[ref first, ref second]) = &inner_call.kind\n+            && let Some(inner_seg) = segment(cx, inner_fn)\n+            && let Some(outer_seg) = segment(cx, outer_fn)\n+        {\n+            let (input, inner_arg) = match (is_const_evaluatable(cx, first), is_const_evaluatable(cx, second)) {\n+                (true, false) => (second, first),\n+                (false, true) => (first, second),\n+                _ => return None,\n+            };\n+            let is_float = cx.typeck_results().expr_ty_adjusted(input).is_floating_point();\n+            let (min, max) = match (inner_seg, outer_seg) {\n+                (FunctionType::CmpMin, FunctionType::CmpMax) => (outer_arg, inner_arg),\n+                (FunctionType::CmpMax, FunctionType::CmpMin) => (inner_arg, outer_arg),\n+                (FunctionType::OrdOrFloat(first_segment), FunctionType::OrdOrFloat(second_segment)) => {\n+                    match (first_segment.ident.as_str(), second_segment.ident.as_str()) {\n+                        (\"min\", \"max\") => (outer_arg, inner_arg),\n+                        (\"max\", \"min\") => (inner_arg, outer_arg),\n+                        _ => return None,\n+                    }\n+                }\n+                _ => return None,\n+            };\n+            Some(ClampSuggestion {\n+                params: InputMinMax { input, min, max, is_float },\n+                span,\n+                make_assignment: None,\n+                hir_with_ignore_attr: None,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    if let ExprKind::Call(outer_fn, [first, second]) = &expr.kind {\n+        check(cx, outer_fn, first, second, expr.span).or_else(|| check(cx, outer_fn, second, first, expr.span))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min, max) = (0, -3, 12);\n+///\n+/// match input {\n+///     input if input > max => max,\n+///     input if input < min => min,\n+///     input => input,\n+/// }\n+/// # ;\n+/// ```\n+fn is_match_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    if let ExprKind::Match(value, &[ref first_arm, ref second_arm, ref last_arm], rustc_hir::MatchSource::Normal) =\n+        &expr.kind\n+    {\n+        // Find possible min/max branches\n+        let minmax_values = |a: &'tcx Arm<'tcx>| {\n+            if let PatKind::Binding(_, var_hir_id, _, None) = &a.pat.kind\n+            && let Some(Guard::If(e)) = a.guard {\n+                Some((e, var_hir_id, a.body))\n+            } else {\n+                None\n+            }\n+        };\n+        let (first, first_hir_id, first_expr) = minmax_values(first_arm)?;\n+        let (second, second_hir_id, second_expr) = minmax_values(second_arm)?;\n+        let first = BinaryOp::new(first)?;\n+        let second = BinaryOp::new(second)?;\n+        if let PatKind::Binding(_, binding, _, None) = &last_arm.pat.kind\n+            && path_to_local_id(peel_blocks_with_stmt(last_arm.body), *binding)\n+            && last_arm.guard.is_none()\n+        {\n+            // Proceed as normal\n+        } else {\n+            return None;\n+        }\n+        if let Some(params) = is_clamp_meta_pattern(\n+            cx,\n+            &first,\n+            &second,\n+            first_expr,\n+            second_expr,\n+            Some((*first_hir_id, *second_hir_id)),\n+        ) {\n+            return Some(ClampSuggestion {\n+                params: InputMinMax {\n+                    input: value,\n+                    min: params.min,\n+                    max: params.max,\n+                    is_float: params.is_float,\n+                },\n+                span: expr.span,\n+                make_assignment: None,\n+                hir_with_ignore_attr: None,\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (input, min, max) = (0, -3, 12);\n+///\n+/// let mut x = input;\n+/// if x < min { x = min; }\n+/// if x > max { x = max; }\n+/// ```\n+fn is_two_if_pattern<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) -> Vec<ClampSuggestion<'tcx>> {\n+    block_stmt_with_last(block)\n+        .tuple_windows()\n+        .filter_map(|(maybe_set_first, maybe_set_second)| {\n+            if let StmtKind::Expr(first_expr) = *maybe_set_first\n+                && let StmtKind::Expr(second_expr) = *maybe_set_second\n+                && let Some(If { cond: first_cond, then: first_then, r#else: None }) = If::hir(first_expr)\n+                && let Some(If { cond: second_cond, then: second_then, r#else: None }) = If::hir(second_expr)\n+                && let ExprKind::Assign(\n+                    maybe_input_first_path,\n+                    maybe_min_max_first,\n+                    _\n+                ) = peel_blocks_with_stmt(first_then).kind\n+                && let ExprKind::Assign(\n+                    maybe_input_second_path,\n+                    maybe_min_max_second,\n+                    _\n+                ) = peel_blocks_with_stmt(second_then).kind\n+                && eq_expr_value(cx, maybe_input_first_path, maybe_input_second_path)\n+                && let Some(first_bin) = BinaryOp::new(first_cond)\n+                && let Some(second_bin) = BinaryOp::new(second_cond)\n+                && let Some(input_min_max) = is_clamp_meta_pattern(\n+                    cx,\n+                    &first_bin,\n+                    &second_bin,\n+                    maybe_min_max_first,\n+                    maybe_min_max_second,\n+                    None\n+                )\n+            {\n+                Some(ClampSuggestion {\n+                    params: InputMinMax {\n+                        input: maybe_input_first_path,\n+                        min: input_min_max.min,\n+                        max: input_min_max.max,\n+                        is_float: input_min_max.is_float,\n+                    },\n+                    span: first_expr.span.to(second_expr.span),\n+                    make_assignment: Some(maybe_input_first_path),\n+                    hir_with_ignore_attr: Some(first_expr.hir_id()),\n+                })\n+            } else {\n+                None\n+            }\n+        })\n+        .collect()\n+}\n+\n+/// Targets patterns like\n+///\n+/// ```\n+/// # let (mut input, min, max) = (0, -3, 12);\n+///\n+/// if input < min {\n+///     input = min;\n+/// } else if input > max {\n+///     input = max;\n+/// }\n+/// ```\n+fn is_if_elseif_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n+    if let Some(If {\n+        cond,\n+        then,\n+        r#else: Some(else_if),\n+    }) = If::hir(expr)\n+        && let Some(If {\n+            cond: else_if_cond,\n+            then: else_if_then,\n+            r#else: None,\n+        }) = If::hir(peel_blocks(else_if))\n+        && let ExprKind::Assign(\n+            maybe_input_first_path,\n+            maybe_min_max_first,\n+            _\n+        ) = peel_blocks_with_stmt(then).kind\n+        && let ExprKind::Assign(\n+            maybe_input_second_path,\n+            maybe_min_max_second,\n+            _\n+        ) = peel_blocks_with_stmt(else_if_then).kind\n+    {\n+        let params = is_clamp_meta_pattern(\n+            cx,\n+            &BinaryOp::new(peel_blocks(cond))?,\n+            &BinaryOp::new(peel_blocks(else_if_cond))?,\n+            peel_blocks(maybe_min_max_first),\n+            peel_blocks(maybe_min_max_second),\n+            None,\n+        )?;\n+        if !eq_expr_value(cx, maybe_input_first_path, maybe_input_second_path) {\n+            return None;\n+        }\n+        Some(ClampSuggestion {\n+            params,\n+            span: expr.span,\n+            make_assignment: Some(maybe_input_first_path),\n+            hir_with_ignore_attr: None,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+/// `ExprKind::Binary` but more narrowly typed\n+#[derive(Debug, Clone, Copy)]\n+struct BinaryOp<'tcx> {\n+    op: BinOpKind,\n+    left: &'tcx Expr<'tcx>,\n+    right: &'tcx Expr<'tcx>,\n+}\n+\n+impl<'tcx> BinaryOp<'tcx> {\n+    fn new(e: &'tcx Expr<'tcx>) -> Option<BinaryOp<'tcx>> {\n+        match &e.kind {\n+            ExprKind::Binary(op, left, right) => Some(BinaryOp {\n+                op: op.node,\n+                left,\n+                right,\n+            }),\n+            _ => None,\n+        }\n+    }\n+\n+    fn flip(&self) -> Self {\n+        Self {\n+            op: match self.op {\n+                BinOpKind::Le => BinOpKind::Ge,\n+                BinOpKind::Lt => BinOpKind::Gt,\n+                BinOpKind::Ge => BinOpKind::Le,\n+                BinOpKind::Gt => BinOpKind::Lt,\n+                other => other,\n+            },\n+            left: self.right,\n+            right: self.left,\n+        }\n+    }\n+}\n+\n+/// The clamp meta pattern is a pattern shared between many (but not all) patterns.\n+/// In summary, this pattern consists of two if statements that meet many criteria,\n+/// - binary operators that are one of [`>`, `<`, `>=`, `<=`].\n+/// - Both binary statements must have a shared argument\n+///     - Which can appear on the left or right side of either statement\n+///     - The binary operators must define a finite range for the shared argument. To put this in\n+///       the terms of Rust `std` library, the following ranges are acceptable\n+///         - `Range`\n+///         - `RangeInclusive`\n+///       And all other range types are not accepted. For the purposes of `clamp` it's irrelevant\n+///       whether the range is inclusive or not, the output is the same.\n+/// - The result of each if statement must be equal to the argument unique to that if statement. The\n+///   result can not be the shared argument in either case.\n+fn is_clamp_meta_pattern<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    first_bin: &BinaryOp<'tcx>,\n+    second_bin: &BinaryOp<'tcx>,\n+    first_expr: &'tcx Expr<'tcx>,\n+    second_expr: &'tcx Expr<'tcx>,\n+    // This parameters is exclusively for the match pattern.\n+    // It exists because the variable bindings used in that pattern\n+    // refer to the variable bound in the match arm, not the variable\n+    // bound outside of it. Fortunately due to context we know this has to\n+    // be the input variable, not the min or max.\n+    input_hir_ids: Option<(HirId, HirId)>,\n+) -> Option<InputMinMax<'tcx>> {\n+    fn check<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        first_bin: &BinaryOp<'tcx>,\n+        second_bin: &BinaryOp<'tcx>,\n+        first_expr: &'tcx Expr<'tcx>,\n+        second_expr: &'tcx Expr<'tcx>,\n+        input_hir_ids: Option<(HirId, HirId)>,\n+        is_float: bool,\n+    ) -> Option<InputMinMax<'tcx>> {\n+        match (&first_bin.op, &second_bin.op) {\n+            (BinOpKind::Ge | BinOpKind::Gt, BinOpKind::Le | BinOpKind::Lt) => {\n+                let (min, max) = (second_expr, first_expr);\n+                let refers_to_input = match input_hir_ids {\n+                    Some((first_hir_id, second_hir_id)) => {\n+                        path_to_local_id(peel_blocks(first_bin.left), first_hir_id)\n+                            && path_to_local_id(peel_blocks(second_bin.left), second_hir_id)\n+                    },\n+                    None => eq_expr_value(cx, first_bin.left, second_bin.left),\n+                };\n+                (refers_to_input\n+                    && eq_expr_value(cx, first_bin.right, first_expr)\n+                    && eq_expr_value(cx, second_bin.right, second_expr))\n+                .then_some(InputMinMax {\n+                    input: first_bin.left,\n+                    min,\n+                    max,\n+                    is_float,\n+                })\n+            },\n+            _ => None,\n+        }\n+    }\n+    // First filter out any expressions with side effects\n+    let exprs = [\n+        first_bin.left,\n+        first_bin.right,\n+        second_bin.left,\n+        second_bin.right,\n+        first_expr,\n+        second_expr,\n+    ];\n+    let clampability = TypeClampability::is_clampable(cx, cx.typeck_results().expr_ty(first_expr))?;\n+    let is_float = clampability.is_float();\n+    if exprs.iter().any(|e| peel_blocks(e).can_have_side_effects()) {\n+        return None;\n+    }\n+    if !(is_ord_op(first_bin.op) && is_ord_op(second_bin.op)) {\n+        return None;\n+    }\n+    let cases = [\n+        (*first_bin, *second_bin),\n+        (first_bin.flip(), second_bin.flip()),\n+        (first_bin.flip(), *second_bin),\n+        (*first_bin, second_bin.flip()),\n+    ];\n+\n+    cases.into_iter().find_map(|(first, second)| {\n+        check(cx, &first, &second, first_expr, second_expr, input_hir_ids, is_float).or_else(|| {\n+            check(\n+                cx,\n+                &second,\n+                &first,\n+                second_expr,\n+                first_expr,\n+                input_hir_ids.map(|(l, r)| (r, l)),\n+                is_float,\n+            )\n+        })\n+    })\n+}\n+\n+fn block_stmt_with_last<'tcx>(block: &'tcx Block<'tcx>) -> impl Iterator<Item = MaybeBorrowedStmtKind<'tcx>> {\n+    block\n+        .stmts\n+        .iter()\n+        .map(|s| MaybeBorrowedStmtKind::Borrowed(&s.kind))\n+        .chain(\n+            block\n+                .expr\n+                .as_ref()\n+                .map(|e| MaybeBorrowedStmtKind::Owned(StmtKind::Expr(e))),\n+        )\n+}\n+\n+fn is_ord_op(op: BinOpKind) -> bool {\n+    matches!(op, BinOpKind::Ge | BinOpKind::Gt | BinOpKind::Le | BinOpKind::Lt)\n+}\n+\n+/// Really similar to Cow, but doesn't have a `Clone` requirement.\n+#[derive(Debug)]\n+enum MaybeBorrowedStmtKind<'a> {\n+    Borrowed(&'a StmtKind<'a>),\n+    Owned(StmtKind<'a>),\n+}\n+\n+impl<'a> Clone for MaybeBorrowedStmtKind<'a> {\n+    fn clone(&self) -> Self {\n+        match self {\n+            Self::Borrowed(t) => Self::Borrowed(t),\n+            Self::Owned(StmtKind::Expr(e)) => Self::Owned(StmtKind::Expr(e)),\n+            Self::Owned(_) => unreachable!(\"Owned should only ever contain a StmtKind::Expr.\"),\n+        }\n+    }\n+}\n+\n+impl<'a> Deref for MaybeBorrowedStmtKind<'a> {\n+    type Target = StmtKind<'a>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        match self {\n+            Self::Borrowed(t) => t,\n+            Self::Owned(t) => t,\n+        }\n+    }\n+}"}, {"sha": "2b336e87ef76ebbcb348612bfe019fa055b5694c", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -213,7 +213,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),"}, {"sha": "8b843732a236b1eb326ac672e0bfa1d2873169db", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -17,7 +17,7 @@ msrv_aliases! {\n     1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN, ARRAY_INTO_ITERATOR }\n     1,52,0 { STR_SPLIT_ONCE, REM_EUCLID_CONST }\n     1,51,0 { BORROW_AS_PTR, UNSIGNED_ABS }\n-    1,50,0 { BOOL_THEN }\n+    1,50,0 { BOOL_THEN, CLAMP }\n     1,47,0 { TAU }\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }"}, {"sha": "39540e4b0489253bb7d4abcf7529cf6b4ba13054", "filename": "src/docs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/src%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/src%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -255,6 +255,7 @@ docs! {\n     \"manual_assert\",\n     \"manual_async_fn\",\n     \"manual_bits\",\n+    \"manual_clamp\",\n     \"manual_filter_map\",\n     \"manual_find\",\n     \"manual_find_map\","}, {"sha": "8993f6683adfe4941b54680be0d4972170b2db28", "filename": "src/docs/manual_clamp.txt", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/src%2Fdocs%2Fmanual_clamp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/src%2Fdocs%2Fmanual_clamp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_clamp.txt?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -0,0 +1,46 @@\n+### What it does\n+Identifies good opportunities for a clamp function from std or core, and suggests using it.\n+\n+### Why is this bad?\n+clamp is much shorter, easier to read, and doesn't use any control flow.\n+\n+### Known issue(s)\n+If the clamped variable is NaN this suggestion will cause the code to propagate NaN\n+rather than returning either `max` or `min`.\n+\n+`clamp` functions will panic if `max < min`, `max.is_nan()`, or `min.is_nan()`.\n+Some may consider panicking in these situations to be desirable, but it also may\n+introduce panicking where there wasn't any before.\n+\n+### Examples\n+```\n+if input > max {\n+    max\n+} else if input < min {\n+    min\n+} else {\n+    input\n+}\n+```\n+\n+```\n+input.max(min).min(max)\n+```\n+\n+```\n+match input {\n+    x if x > max => max,\n+    x if x < min => min,\n+    x => x,\n+}\n+```\n+\n+```\n+let mut x = input;\n+if x < min { x = min; }\n+if x > max { x = max; }\n+```\n+Use instead:\n+```\n+input.clamp(min, max)\n+```\n\\ No newline at end of file"}, {"sha": "54fd888af99fa9ccf7a2d26a3c1a21af7c050196", "filename": "tests/ui/manual_clamp.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmanual_clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmanual_clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_clamp.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -0,0 +1,304 @@\n+#![warn(clippy::manual_clamp)]\n+#![allow(\n+    unused,\n+    dead_code,\n+    clippy::unnecessary_operation,\n+    clippy::no_effect,\n+    clippy::if_same_then_else\n+)]\n+\n+use std::cmp::{max as cmp_max, min as cmp_min};\n+\n+const CONST_MAX: i32 = 10;\n+const CONST_MIN: i32 = 4;\n+\n+const CONST_F64_MAX: f64 = 10.0;\n+const CONST_F64_MIN: f64 = 4.0;\n+\n+fn main() {\n+    let (input, min, max) = (0, -2, 3);\n+    // Lint\n+    let x0 = if max < input {\n+        max\n+    } else if min > input {\n+        min\n+    } else {\n+        input\n+    };\n+\n+    let x1 = if input > max {\n+        max\n+    } else if input < min {\n+        min\n+    } else {\n+        input\n+    };\n+\n+    let x2 = if input < min {\n+        min\n+    } else if input > max {\n+        max\n+    } else {\n+        input\n+    };\n+\n+    let x3 = if min > input {\n+        min\n+    } else if max < input {\n+        max\n+    } else {\n+        input\n+    };\n+\n+    let x4 = input.max(min).min(max);\n+\n+    let x5 = input.min(max).max(min);\n+\n+    let x6 = match input {\n+        x if x > max => max,\n+        x if x < min => min,\n+        x => x,\n+    };\n+\n+    let x7 = match input {\n+        x if x < min => min,\n+        x if x > max => max,\n+        x => x,\n+    };\n+\n+    let x8 = match input {\n+        x if max < x => max,\n+        x if min > x => min,\n+        x => x,\n+    };\n+\n+    let mut x9 = input;\n+    if x9 < min {\n+        x9 = min;\n+    }\n+    if x9 > max {\n+        x9 = max;\n+    }\n+\n+    let x10 = match input {\n+        x if min > x => min,\n+        x if max < x => max,\n+        x => x,\n+    };\n+\n+    let mut x11 = input;\n+    let _ = 1;\n+    if x11 > max {\n+        x11 = max;\n+    }\n+    if x11 < min {\n+        x11 = min;\n+    }\n+\n+    let mut x12 = input;\n+    if min > x12 {\n+        x12 = min;\n+    }\n+    if max < x12 {\n+        x12 = max;\n+    }\n+\n+    let mut x13 = input;\n+    if max < x13 {\n+        x13 = max;\n+    }\n+    if min > x13 {\n+        x13 = min;\n+    }\n+\n+    let x14 = if input > CONST_MAX {\n+        CONST_MAX\n+    } else if input < CONST_MIN {\n+        CONST_MIN\n+    } else {\n+        input\n+    };\n+    {\n+        let (input, min, max) = (0.0f64, -2.0, 3.0);\n+        let x15 = if input > max {\n+            max\n+        } else if input < min {\n+            min\n+        } else {\n+            input\n+        };\n+    }\n+    {\n+        let input: i32 = cmp_min_max(1);\n+        // These can only be detected if exactly one of the arguments to the inner function is const.\n+        let x16 = cmp_max(cmp_min(input, CONST_MAX), CONST_MIN);\n+        let x17 = cmp_min(cmp_max(input, CONST_MIN), CONST_MAX);\n+        let x18 = cmp_max(CONST_MIN, cmp_min(input, CONST_MAX));\n+        let x19 = cmp_min(CONST_MAX, cmp_max(input, CONST_MIN));\n+        let x20 = cmp_max(cmp_min(CONST_MAX, input), CONST_MIN);\n+        let x21 = cmp_min(cmp_max(CONST_MIN, input), CONST_MAX);\n+        let x22 = cmp_max(CONST_MIN, cmp_min(CONST_MAX, input));\n+        let x23 = cmp_min(CONST_MAX, cmp_max(CONST_MIN, input));\n+        let input: f64 = cmp_min_max(1) as f64;\n+        let x24 = f64::max(f64::min(input, CONST_F64_MAX), CONST_F64_MIN);\n+        let x25 = f64::min(f64::max(input, CONST_F64_MIN), CONST_F64_MAX);\n+        let x26 = f64::max(CONST_F64_MIN, f64::min(input, CONST_F64_MAX));\n+        let x27 = f64::min(CONST_F64_MAX, f64::max(input, CONST_F64_MIN));\n+        let x28 = f64::max(f64::min(CONST_F64_MAX, input), CONST_F64_MIN);\n+        let x29 = f64::min(f64::max(CONST_F64_MIN, input), CONST_F64_MAX);\n+        let x30 = f64::max(CONST_F64_MIN, f64::min(CONST_F64_MAX, input));\n+        let x31 = f64::min(CONST_F64_MAX, f64::max(CONST_F64_MIN, input));\n+    }\n+    let mut x32 = input;\n+    if x32 < min {\n+        x32 = min;\n+    } else if x32 > max {\n+        x32 = max;\n+    }\n+\n+    // It's important this be the last set of statements\n+    let mut x33 = input;\n+    if max < x33 {\n+        x33 = max;\n+    }\n+    if min > x33 {\n+        x33 = min;\n+    }\n+}\n+\n+// This code intentionally nonsense.\n+fn no_lint() {\n+    let (input, min, max) = (0, -2, 3);\n+    let x0 = if max < input {\n+        max\n+    } else if min > input {\n+        max\n+    } else {\n+        min\n+    };\n+\n+    let x1 = if input > max {\n+        max\n+    } else if input > min {\n+        min\n+    } else {\n+        max\n+    };\n+\n+    let x2 = if max < min {\n+        min\n+    } else if input > max {\n+        input\n+    } else {\n+        input\n+    };\n+\n+    let x3 = if min > input {\n+        input\n+    } else if max < input {\n+        max\n+    } else {\n+        max\n+    };\n+\n+    let x6 = match input {\n+        x if x < max => x,\n+        x if x < min => x,\n+        x => x,\n+    };\n+\n+    let x7 = match input {\n+        x if x < min => max,\n+        x if x > max => min,\n+        x => x,\n+    };\n+\n+    let x8 = match input {\n+        x if max > x => max,\n+        x if min > x => min,\n+        x => x,\n+    };\n+\n+    let mut x9 = input;\n+    if x9 > min {\n+        x9 = min;\n+    }\n+    if x9 > max {\n+        x9 = max;\n+    }\n+\n+    let x10 = match input {\n+        x if min > x => min,\n+        x if max < x => max,\n+        x => min,\n+    };\n+\n+    let mut x11 = input;\n+    if x11 > max {\n+        x11 = min;\n+    }\n+    if x11 < min {\n+        x11 = max;\n+    }\n+\n+    let mut x12 = input;\n+    if min > x12 {\n+        x12 = max * 3;\n+    }\n+    if max < x12 {\n+        x12 = min;\n+    }\n+\n+    let mut x13 = input;\n+    if max < x13 {\n+        let x13 = max;\n+    }\n+    if min > x13 {\n+        x13 = min;\n+    }\n+    let mut x14 = input;\n+    if x14 < min {\n+        x14 = 3;\n+    } else if x14 > max {\n+        x14 = max;\n+    }\n+    {\n+        let input: i32 = cmp_min_max(1);\n+        // These can only be detected if exactly one of the arguments to the inner function is const.\n+        let x16 = cmp_max(cmp_max(input, CONST_MAX), CONST_MIN);\n+        let x17 = cmp_min(cmp_min(input, CONST_MIN), CONST_MAX);\n+        let x18 = cmp_max(CONST_MIN, cmp_max(input, CONST_MAX));\n+        let x19 = cmp_min(CONST_MAX, cmp_min(input, CONST_MIN));\n+        let x20 = cmp_max(cmp_max(CONST_MAX, input), CONST_MIN);\n+        let x21 = cmp_min(cmp_min(CONST_MIN, input), CONST_MAX);\n+        let x22 = cmp_max(CONST_MIN, cmp_max(CONST_MAX, input));\n+        let x23 = cmp_min(CONST_MAX, cmp_min(CONST_MIN, input));\n+        let input: f64 = cmp_min_max(1) as f64;\n+        let x24 = f64::max(f64::max(input, CONST_F64_MAX), CONST_F64_MIN);\n+        let x25 = f64::min(f64::min(input, CONST_F64_MIN), CONST_F64_MAX);\n+        let x26 = f64::max(CONST_F64_MIN, f64::max(input, CONST_F64_MAX));\n+        let x27 = f64::min(CONST_F64_MAX, f64::min(input, CONST_F64_MIN));\n+        let x28 = f64::max(f64::max(CONST_F64_MAX, input), CONST_F64_MIN);\n+        let x29 = f64::min(f64::min(CONST_F64_MIN, input), CONST_F64_MAX);\n+        let x30 = f64::max(CONST_F64_MIN, f64::max(CONST_F64_MAX, input));\n+        let x31 = f64::min(CONST_F64_MAX, f64::min(CONST_F64_MIN, input));\n+        let x32 = f64::min(CONST_F64_MAX, f64::min(CONST_F64_MIN, CONST_F64_MAX));\n+    }\n+}\n+\n+fn dont_tell_me_what_to_do() {\n+    let (input, min, max) = (0, -2, 3);\n+    let mut x_never = input;\n+    #[allow(clippy::manual_clamp)]\n+    if x_never < min {\n+        x_never = min;\n+    }\n+    if x_never > max {\n+        x_never = max;\n+    }\n+}\n+\n+/// Just to ensure this isn't const evaled\n+fn cmp_min_max(input: i32) -> i32 {\n+    input * 3\n+}"}, {"sha": "25650483595dd1859256833accc9eef269697fa9", "filename": "tests/ui/manual_clamp.stderr", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmanual_clamp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmanual_clamp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_clamp.stderr?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -0,0 +1,375 @@\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:76:5\n+   |\n+LL | /     if x9 < min {\n+LL | |         x9 = min;\n+LL | |     }\n+LL | |     if x9 > max {\n+LL | |         x9 = max;\n+LL | |     }\n+   | |_____^ help: replace with clamp: `x9 = x9.clamp(min, max);`\n+   |\n+   = note: `-D clippy::manual-clamp` implied by `-D warnings`\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:91:5\n+   |\n+LL | /     if x11 > max {\n+LL | |         x11 = max;\n+LL | |     }\n+LL | |     if x11 < min {\n+LL | |         x11 = min;\n+LL | |     }\n+   | |_____^ help: replace with clamp: `x11 = x11.clamp(min, max);`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:99:5\n+   |\n+LL | /     if min > x12 {\n+LL | |         x12 = min;\n+LL | |     }\n+LL | |     if max < x12 {\n+LL | |         x12 = max;\n+LL | |     }\n+   | |_____^ help: replace with clamp: `x12 = x12.clamp(min, max);`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:107:5\n+   |\n+LL | /     if max < x13 {\n+LL | |         x13 = max;\n+LL | |     }\n+LL | |     if min > x13 {\n+LL | |         x13 = min;\n+LL | |     }\n+   | |_____^ help: replace with clamp: `x13 = x13.clamp(min, max);`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:161:5\n+   |\n+LL | /     if max < x33 {\n+LL | |         x33 = max;\n+LL | |     }\n+LL | |     if min > x33 {\n+LL | |         x33 = min;\n+LL | |     }\n+   | |_____^ help: replace with clamp: `x33 = x33.clamp(min, max);`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:21:14\n+   |\n+LL |       let x0 = if max < input {\n+   |  ______________^\n+LL | |         max\n+LL | |     } else if min > input {\n+LL | |         min\n+LL | |     } else {\n+LL | |         input\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:29:14\n+   |\n+LL |       let x1 = if input > max {\n+   |  ______________^\n+LL | |         max\n+LL | |     } else if input < min {\n+LL | |         min\n+LL | |     } else {\n+LL | |         input\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:37:14\n+   |\n+LL |       let x2 = if input < min {\n+   |  ______________^\n+LL | |         min\n+LL | |     } else if input > max {\n+LL | |         max\n+LL | |     } else {\n+LL | |         input\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:45:14\n+   |\n+LL |       let x3 = if min > input {\n+   |  ______________^\n+LL | |         min\n+LL | |     } else if max < input {\n+LL | |         max\n+LL | |     } else {\n+LL | |         input\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:53:14\n+   |\n+LL |     let x4 = input.max(min).min(max);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:55:14\n+   |\n+LL |     let x5 = input.min(max).max(min);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:57:14\n+   |\n+LL |       let x6 = match input {\n+   |  ______________^\n+LL | |         x if x > max => max,\n+LL | |         x if x < min => min,\n+LL | |         x => x,\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:63:14\n+   |\n+LL |       let x7 = match input {\n+   |  ______________^\n+LL | |         x if x < min => min,\n+LL | |         x if x > max => max,\n+LL | |         x => x,\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:69:14\n+   |\n+LL |       let x8 = match input {\n+   |  ______________^\n+LL | |         x if max < x => max,\n+LL | |         x if min > x => min,\n+LL | |         x => x,\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:83:15\n+   |\n+LL |       let x10 = match input {\n+   |  _______________^\n+LL | |         x if min > x => min,\n+LL | |         x if max < x => max,\n+LL | |         x => x,\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:114:15\n+   |\n+LL |       let x14 = if input > CONST_MAX {\n+   |  _______________^\n+LL | |         CONST_MAX\n+LL | |     } else if input < CONST_MIN {\n+LL | |         CONST_MIN\n+LL | |     } else {\n+LL | |         input\n+LL | |     };\n+   | |_____^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:123:19\n+   |\n+LL |           let x15 = if input > max {\n+   |  ___________________^\n+LL | |             max\n+LL | |         } else if input < min {\n+LL | |             min\n+LL | |         } else {\n+LL | |             input\n+LL | |         };\n+   | |_________^ help: replace with clamp: `input.clamp(min, max)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:134:19\n+   |\n+LL |         let x16 = cmp_max(cmp_min(input, CONST_MAX), CONST_MIN);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:135:19\n+   |\n+LL |         let x17 = cmp_min(cmp_max(input, CONST_MIN), CONST_MAX);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:136:19\n+   |\n+LL |         let x18 = cmp_max(CONST_MIN, cmp_min(input, CONST_MAX));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:137:19\n+   |\n+LL |         let x19 = cmp_min(CONST_MAX, cmp_max(input, CONST_MIN));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:138:19\n+   |\n+LL |         let x20 = cmp_max(cmp_min(CONST_MAX, input), CONST_MIN);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:139:19\n+   |\n+LL |         let x21 = cmp_min(cmp_max(CONST_MIN, input), CONST_MAX);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:140:19\n+   |\n+LL |         let x22 = cmp_max(CONST_MIN, cmp_min(CONST_MAX, input));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:141:19\n+   |\n+LL |         let x23 = cmp_min(CONST_MAX, cmp_max(CONST_MIN, input));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_MIN, CONST_MAX)`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:143:19\n+   |\n+LL |         let x24 = f64::max(f64::min(input, CONST_F64_MAX), CONST_F64_MIN);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_F64_MIN, CONST_F64_MAX)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:144:19\n+   |\n+LL |         let x25 = f64::min(f64::max(input, CONST_F64_MIN), CONST_F64_MAX);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_F64_MIN, CONST_F64_MAX)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:145:19\n+   |\n+LL |         let x26 = f64::max(CONST_F64_MIN, f64::min(input, CONST_F64_MAX));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_F64_MIN, CONST_F64_MAX)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:146:19\n+   |\n+LL |         let x27 = f64::min(CONST_F64_MAX, f64::max(input, CONST_F64_MIN));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_F64_MIN, CONST_F64_MAX)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:147:19\n+   |\n+LL |         let x28 = f64::max(f64::min(CONST_F64_MAX, input), CONST_F64_MIN);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_F64_MIN, CONST_F64_MAX)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:148:19\n+   |\n+LL |         let x29 = f64::min(f64::max(CONST_F64_MIN, input), CONST_F64_MAX);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_F64_MIN, CONST_F64_MAX)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:149:19\n+   |\n+LL |         let x30 = f64::max(CONST_F64_MIN, f64::min(CONST_F64_MAX, input));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_F64_MIN, CONST_F64_MAX)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:150:19\n+   |\n+LL |         let x31 = f64::min(CONST_F64_MAX, f64::max(CONST_F64_MIN, input));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with clamp: `input.clamp(CONST_F64_MIN, CONST_F64_MAX)`\n+   |\n+   = note: clamp will panic if max < min, min.is_nan(), or max.is_nan()\n+   = note: clamp returns NaN if the input is NaN\n+\n+error: clamp-like pattern without using clamp function\n+  --> $DIR/manual_clamp.rs:153:5\n+   |\n+LL | /     if x32 < min {\n+LL | |         x32 = min;\n+LL | |     } else if x32 > max {\n+LL | |         x32 = max;\n+LL | |     }\n+   | |_____^ help: replace with clamp: `x32 = x32.clamp(min, max);`\n+   |\n+   = note: clamp will panic if max < min\n+\n+error: aborting due to 34 previous errors\n+"}, {"sha": "24e52afd69170635206fd8547f596a59aa93eab3", "filename": "tests/ui/min_max.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmin_max.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmin_max.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_max.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::all)]\n+#![allow(clippy::manual_clamp)]\n \n use std::cmp::max as my_max;\n use std::cmp::min as my_min;"}, {"sha": "069d9068657eb68d36dfc35fe2ffab57a8e9a119", "filename": "tests/ui/min_max.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmin_max.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmin_max.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_max.stderr?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -1,79 +1,79 @@\n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:23:5\n+  --> $DIR/min_max.rs:24:5\n    |\n LL |     min(1, max(3, x));\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::min-max` implied by `-D warnings`\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:24:5\n+  --> $DIR/min_max.rs:25:5\n    |\n LL |     min(max(3, x), 1);\n    |     ^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:25:5\n+  --> $DIR/min_max.rs:26:5\n    |\n LL |     max(min(x, 1), 3);\n    |     ^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:26:5\n+  --> $DIR/min_max.rs:27:5\n    |\n LL |     max(3, min(x, 1));\n    |     ^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:28:5\n+  --> $DIR/min_max.rs:29:5\n    |\n LL |     my_max(3, my_min(x, 1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:38:5\n+  --> $DIR/min_max.rs:39:5\n    |\n LL |     min(\"Apple\", max(\"Zoo\", s));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:39:5\n+  --> $DIR/min_max.rs:40:5\n    |\n LL |     max(min(s, \"Apple\"), \"Zoo\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:44:5\n+  --> $DIR/min_max.rs:45:5\n    |\n LL |     x.min(1).max(3);\n    |     ^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:45:5\n+  --> $DIR/min_max.rs:46:5\n    |\n LL |     x.max(3).min(1);\n    |     ^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:46:5\n+  --> $DIR/min_max.rs:47:5\n    |\n LL |     f.max(3f32).min(1f32);\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:52:5\n+  --> $DIR/min_max.rs:53:5\n    |\n LL |     max(x.min(1), 3);\n    |     ^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:55:5\n+  --> $DIR/min_max.rs:56:5\n    |\n LL |     s.max(\"Zoo\").min(\"Apple\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:56:5\n+  --> $DIR/min_max.rs:57:5\n    |\n LL |     s.min(\"Apple\").max(\"Zoo\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c4c6391bb4c1dfebd2dd9d738614c3ea633f6801", "filename": "tests/ui/min_rust_version_attr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmin_rust_version_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmin_rust_version_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_rust_version_attr.rs?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -160,6 +160,17 @@ fn manual_rem_euclid() {\n     let _: i32 = ((x % 4) + 4) % 4;\n }\n \n+fn manual_clamp() {\n+    let (input, min, max) = (0, -1, 2);\n+    let _ = if input < min {\n+        min\n+    } else if input > max {\n+        max\n+    } else {\n+        input\n+    };\n+}\n+\n fn main() {\n     filter_map_next();\n     checked_conversion();\n@@ -180,6 +191,7 @@ fn main() {\n     err_expect();\n     cast_abs_to_unsigned();\n     manual_rem_euclid();\n+    manual_clamp();\n }\n \n mod just_under_msrv {"}, {"sha": "faabb0e4386dd36595c725980c0e9adefcc5180e", "filename": "tests/ui/min_rust_version_attr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmin_rust_version_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b22118457245cdd074daaaaea950ec49397f8712/tests%2Fui%2Fmin_rust_version_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_rust_version_attr.stderr?ref=b22118457245cdd074daaaaea950ec49397f8712", "patch": "@@ -1,12 +1,12 @@\n error: stripping a prefix manually\n-  --> $DIR/min_rust_version_attr.rs:204:24\n+  --> $DIR/min_rust_version_attr.rs:216:24\n    |\n LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n    |                        ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::manual-strip` implied by `-D warnings`\n note: the prefix was tested here\n-  --> $DIR/min_rust_version_attr.rs:203:9\n+  --> $DIR/min_rust_version_attr.rs:215:9\n    |\n LL |         if s.starts_with(\"hello, \") {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,13 +17,13 @@ LL ~             assert_eq!(<stripped>.to_uppercase(), \"WORLD!\");\n    |\n \n error: stripping a prefix manually\n-  --> $DIR/min_rust_version_attr.rs:216:24\n+  --> $DIR/min_rust_version_attr.rs:228:24\n    |\n LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n    |                        ^^^^^^^^^^^^^^^^^^^^\n    |\n note: the prefix was tested here\n-  --> $DIR/min_rust_version_attr.rs:215:9\n+  --> $DIR/min_rust_version_attr.rs:227:9\n    |\n LL |         if s.starts_with(\"hello, \") {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}]}