{"sha": "bd2b210c59eb9e7e245060f08826351d355ce634", "node_id": "C_kwDOAAsO6NoAKGJkMmIyMTBjNTllYjllN2UyNDUwNjBmMDg4MjYzNTFkMzU1Y2U2MzQ", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-03T17:27:13Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-13T15:46:05Z"}, "message": "Remove CheckConstTraitVisitor\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "e08f5fe7d875c72ca509d3082e0f349399ec7365", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e08f5fe7d875c72ca509d3082e0f349399ec7365"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd2b210c59eb9e7e245060f08826351d355ce634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd2b210c59eb9e7e245060f08826351d355ce634", "html_url": "https://github.com/rust-lang/rust/commit/bd2b210c59eb9e7e245060f08826351d355ce634", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd2b210c59eb9e7e245060f08826351d355ce634/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "html_url": "https://github.com/rust-lang/rust/commit/a7d6408b05912396618dfdcc9cc713d3ace2aa9a"}], "stats": {"total": 122, "additions": 54, "deletions": 68}, "files": [{"sha": "e0922d41937b3ac84e16d7cf24fd572f8e72045c", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 54, "deletions": 68, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b210c59eb9e7e245060f08826351d355ce634/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b210c59eb9e7e245060f08826351d355ce634/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=bd2b210c59eb9e7e245060f08826351d355ce634", "patch": "@@ -10,6 +10,7 @@\n use rustc_attr as attr;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::hir::nested_filter;\n@@ -58,88 +59,73 @@ impl NonConstExpr {\n fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let mut vis = CheckConstVisitor::new(tcx);\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut vis.as_deep_visitor());\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckConstTraitVisitor::new(tcx));\n+    for id in tcx.hir_module_items(module_def_id).items() {\n+        check_item(tcx, id);\n+    }\n }\n \n pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_const_bodies, ..*providers };\n }\n \n-struct CheckConstTraitVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n+fn check_item<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n+    let _: Option<_> = try {\n+        if !matches!(tcx.hir().def_kind(id.def_id), DefKind::Impl) {\n+            None?\n+        }\n \n-impl<'tcx> CheckConstTraitVisitor<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        CheckConstTraitVisitor { tcx }\n-    }\n-}\n+        let item = tcx.hir().item(id);\n+        if let hir::ItemKind::Impl(ref imp) = item.kind && let hir::Constness::Const = imp.constness {\n+            let trait_def_id = imp.of_trait.as_ref()?.trait_def_id()?;\n+            let ancestors = tcx\n+                .trait_def(trait_def_id)\n+                .ancestors(tcx, item.def_id.to_def_id())\n+                .ok()?;\n+            let mut to_implement = Vec::new();\n \n-impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<'tcx> {\n-    /// check for const trait impls, and errors if the impl uses provided/default functions\n-    /// of the trait being implemented; as those provided functions can be non-const.\n-    fn visit_item<'hir>(&mut self, item: &'hir hir::Item<'hir>) {\n-        let _: Option<_> = try {\n-            if let hir::ItemKind::Impl(ref imp) = item.kind && let hir::Constness::Const = imp.constness {\n-                    let trait_def_id = imp.of_trait.as_ref()?.trait_def_id()?;\n-                    let ancestors = self\n-                        .tcx\n-                        .trait_def(trait_def_id)\n-                        .ancestors(self.tcx, item.def_id.to_def_id())\n-                        .ok()?;\n-                    let mut to_implement = Vec::new();\n-\n-                    for trait_item in self.tcx.associated_items(trait_def_id).in_definition_order()\n+            for trait_item in tcx.associated_items(trait_def_id).in_definition_order()\n+            {\n+                if let ty::AssocItem {\n+                    kind: ty::AssocKind::Fn,\n+                    defaultness,\n+                    def_id: trait_item_id,\n+                    ..\n+                } = *trait_item\n+                {\n+                    // we can ignore functions that do not have default bodies:\n+                    // if those are unimplemented it will be caught by typeck.\n+                    if !defaultness.has_value()\n+                        || tcx\n+                        .has_attr(trait_item_id, sym::default_method_body_is_const)\n                     {\n-                        if let ty::AssocItem {\n-                            kind: ty::AssocKind::Fn,\n-                            defaultness,\n-                            def_id: trait_item_id,\n-                            ..\n-                        } = *trait_item\n-                        {\n-                            // we can ignore functions that do not have default bodies:\n-                            // if those are unimplemented it will be caught by typeck.\n-                            if !defaultness.has_value()\n-                                || self\n-                                    .tcx\n-                                    .has_attr(trait_item_id, sym::default_method_body_is_const)\n-                            {\n-                                continue;\n-                            }\n-\n-                            let is_implemented = ancestors\n-                                .leaf_def(self.tcx, trait_item_id)\n-                                .map(|node_item| !node_item.defining_node.is_from_trait())\n-                                .unwrap_or(false);\n-\n-                            if !is_implemented {\n-                                to_implement.push(self.tcx.item_name(trait_item_id).to_string());\n-                            }\n-                        }\n+                        continue;\n                     }\n \n-                    // all nonconst trait functions (not marked with #[default_method_body_is_const])\n-                    // must be implemented\n-                    if !to_implement.is_empty() {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                item.span,\n-                                \"const trait implementations may not use non-const default functions\",\n-                            )\n-                            .note(&format!(\"`{}` not implemented\", to_implement.join(\"`, `\")))\n-                            .emit();\n+                    let is_implemented = ancestors\n+                        .leaf_def(tcx, trait_item_id)\n+                        .map(|node_item| !node_item.defining_node.is_from_trait())\n+                        .unwrap_or(false);\n+\n+                    if !is_implemented {\n+                        to_implement.push(tcx.item_name(trait_item_id).to_string());\n                     }\n+                }\n             }\n-        };\n-    }\n \n-    fn visit_trait_item<'hir>(&mut self, _: &'hir hir::TraitItem<'hir>) {}\n-\n-    fn visit_impl_item<'hir>(&mut self, _: &'hir hir::ImplItem<'hir>) {}\n-\n-    fn visit_foreign_item<'hir>(&mut self, _: &'hir hir::ForeignItem<'hir>) {}\n+            // all nonconst trait functions (not marked with #[default_method_body_is_const])\n+            // must be implemented\n+            if !to_implement.is_empty() {\n+                tcx\n+                    .sess\n+                    .struct_span_err(\n+                        item.span,\n+                        \"const trait implementations may not use non-const default functions\",\n+                    )\n+                    .note(&format!(\"`{}` not implemented\", to_implement.join(\"`, `\")))\n+                    .emit();\n+            }\n+        }\n+    };\n }\n \n #[derive(Copy, Clone)]"}]}