{"sha": "64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MjA2YjQ0Yjk5MjVhOGViNWQ5ZTI2MTRjNWU2MTc1YTFiNTUzM2E=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-01T17:41:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-15T21:49:21Z"}, "message": "move region constraints into inference context", "tree": {"sha": "c31cd26d65bc3ed40c971dbea13fd480d556c288", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c31cd26d65bc3ed40c971dbea13fd480d556c288"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "html_url": "https://github.com/rust-lang/rust/commit/64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4afe423fbfeae115e8ff2fb9e9aa99e00cf90095", "url": "https://api.github.com/repos/rust-lang/rust/commits/4afe423fbfeae115e8ff2fb9e9aa99e00cf90095", "html_url": "https://github.com/rust-lang/rust/commit/4afe423fbfeae115e8ff2fb9e9aa99e00cf90095"}], "stats": {"total": 196, "additions": 97, "deletions": 99}, "files": [{"sha": "3010123f49566f25da105822ebb92dc6c68d6b15", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "patch": "@@ -36,7 +36,7 @@ use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n-use util::nodemap::FxHashMap;\n+use util::nodemap::{NodeMap, FxHashMap};\n use arena::DroplessArena;\n \n use self::combine::CombineFields;\n@@ -135,6 +135,32 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n+\n+    // A set of constraints that regionck must validate. Each\n+    // constraint has the form `T:'a`, meaning \"some type `T` must\n+    // outlive the lifetime 'a\". These constraints derive from\n+    // instantiated type parameters. So if you had a struct defined\n+    // like\n+    //\n+    //     struct Foo<T:'static> { ... }\n+    //\n+    // then in some expression `let x = Foo { ... }` it will\n+    // instantiate the type parameter `T` with a fresh type `$0`. At\n+    // the same time, it will record a region obligation of\n+    // `$0:'static`. This will get checked later by regionck. (We\n+    // can't generally check these things right away because we have\n+    // to wait until types are resolved.)\n+    //\n+    // These are stored in a map keyed to the id of the innermost\n+    // enclosing fn body / static initializer expression. This is\n+    // because the location where the obligation was incurred can be\n+    // relevant with respect to which sublifetime assumptions are in\n+    // place. The reason that we store under the fn-id, and not\n+    // something more fine-grained, is so that it is easier for\n+    // regionck to be sure that it has found *all* the region\n+    // obligations (otherwise, it's easy to fail to walk to a\n+    // particular node-id).\n+    region_obligations: RefCell<NodeMap<Vec<RegionObligation<'tcx>>>>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -317,6 +343,14 @@ pub enum FixupError {\n     UnresolvedTy(TyVid)\n }\n \n+/// See the `region_obligations` field for more information.\n+#[derive(Clone)]\n+pub struct RegionObligation<'tcx> {\n+    pub sub_region: ty::Region<'tcx>,\n+    pub sup_type: Ty<'tcx>,\n+    pub cause: ObligationCause<'tcx>,\n+}\n+\n impl fmt::Display for FixupError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::FixupError::*;\n@@ -386,6 +420,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),\n+            region_obligations: RefCell::new(NodeMap()),\n         }))\n     }\n }\n@@ -953,6 +988,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    /// Registers that the given region obligation must be resolved\n+    /// from within the scope of `body_id`. These regions are enqueued\n+    /// and later processed by regionck, when full type information is\n+    /// available (see `region_obligations` field for more\n+    /// information).\n+    pub fn register_region_obligation(&self,\n+                                      body_id: ast::NodeId,\n+                                      obligation: RegionObligation<'tcx>)\n+    {\n+        self.region_obligations.borrow_mut().entry(body_id)\n+                                            .or_insert(vec![])\n+                                            .push(obligation);\n+    }\n+\n+    /// Get the region obligations that must be proven (during\n+    /// `regionck`) for the given `body_id` (removing them from the\n+    /// map as a side-effect).\n+    pub fn take_region_obligations(&self,\n+                                   body_id: ast::NodeId)\n+                                   -> Vec<RegionObligation<'tcx>>\n+    {\n+        match self.region_obligations.borrow_mut().remove(&body_id) {\n+            None => vec![],\n+            Some(vec) => vec,\n+        }\n+    }\n+\n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n@@ -1073,6 +1135,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                              region_context: DefId,\n                                              region_map: &region::ScopeTree,\n                                              free_regions: &FreeRegionMap<'tcx>) {\n+        // TODO assert!(self.region_obligations.borrow().is_empty(),\n+        // TODO         \"region_obligations not empty: {:#?}\",\n+        // TODO         self.region_obligations.borrow());\n+\n         let region_rels = RegionRelations::new(self.tcx,\n                                                region_context,\n                                                region_map,\n@@ -1533,3 +1599,12 @@ impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n         self.cause.visit_with(visitor) || self.values.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+               self.sub_region,\n+               self.sup_type)\n+    }\n+}\n+"}, {"sha": "6767fbae3d8b5b77aa29ffeb2003e547e651ca2a", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 18, "deletions": 83, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::{InferCtxt, InferOk};\n+use infer::{RegionObligation, InferCtxt, InferOk};\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n-use syntax::ast;\n-use util::nodemap::NodeMap;\n use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n@@ -48,39 +46,6 @@ pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n-\n-    // A set of constraints that regionck must validate. Each\n-    // constraint has the form `T:'a`, meaning \"some type `T` must\n-    // outlive the lifetime 'a\". These constraints derive from\n-    // instantiated type parameters. So if you had a struct defined\n-    // like\n-    //\n-    //     struct Foo<T:'static> { ... }\n-    //\n-    // then in some expression `let x = Foo { ... }` it will\n-    // instantiate the type parameter `T` with a fresh type `$0`. At\n-    // the same time, it will record a region obligation of\n-    // `$0:'static`. This will get checked later by regionck. (We\n-    // can't generally check these things right away because we have\n-    // to wait until types are resolved.)\n-    //\n-    // These are stored in a map keyed to the id of the innermost\n-    // enclosing fn body / static initializer expression. This is\n-    // because the location where the obligation was incurred can be\n-    // relevant with respect to which sublifetime assumptions are in\n-    // place. The reason that we store under the fn-id, and not\n-    // something more fine-grained, is so that it is easier for\n-    // regionck to be sure that it has found *all* the region\n-    // obligations (otherwise, it's easy to fail to walk to a\n-    // particular node-id).\n-    region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n-}\n-\n-#[derive(Clone)]\n-pub struct RegionObligation<'tcx> {\n-    pub sub_region: ty::Region<'tcx>,\n-    pub sup_type: Ty<'tcx>,\n-    pub cause: ObligationCause<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n@@ -94,7 +59,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n-            region_obligations: NodeMap(),\n         }\n     }\n \n@@ -184,17 +148,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-\n-    pub fn region_obligations(&self,\n-                              body_id: ast::NodeId)\n-                              -> &[RegionObligation<'tcx>]\n-    {\n-        match self.region_obligations.get(&body_id) {\n-            None => Default::default(),\n-            Some(vec) => vec,\n-        }\n-    }\n-\n     pub fn select_all_or_error(&mut self,\n                                infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n                                -> Result<(),Vec<FulfillmentError<'tcx>>>\n@@ -237,10 +190,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select: starting another iteration\");\n \n             // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n-                selcx,\n-                region_obligations: &mut self.region_obligations,\n-            });\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor { selcx });\n             debug!(\"select: outcome={:?}\", outcome);\n \n             // FIXME: if we kept the original cache key, we could mark projection\n@@ -269,7 +219,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n-    region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n }\n \n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n@@ -280,9 +229,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                           obligation: &mut Self::Obligation)\n                           -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n     {\n-        process_predicate(self.selcx,\n-                          obligation,\n-                          self.region_obligations)\n+        process_predicate(self.selcx, obligation)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n                 stalled_on: vec![]\n@@ -321,8 +268,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n /// - `Err` if the predicate does not hold\n fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+    pending_obligation: &mut PendingPredicateObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n {\n@@ -444,18 +390,26 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n                             let r_static = selcx.tcx().types.re_static;\n-                            register_region_obligation(t_a, r_static,\n-                                                       obligation.cause.clone(),\n-                                                       region_obligations);\n+                            selcx.infcx().register_region_obligation(\n+                                obligation.cause.body_id,\n+                                RegionObligation {\n+                                    sup_type: t_a,\n+                                    sub_region: r_static,\n+                                    cause: obligation.cause.clone(),\n+                                });\n                             Ok(Some(vec![]))\n                         }\n                     }\n                 }\n                 // If there aren't, register the obligation.\n                 Some(ty::OutlivesPredicate(t_a, r_b)) => {\n-                    register_region_obligation(t_a, r_b,\n-                                               obligation.cause.clone(),\n-                                               region_obligations);\n+                    selcx.infcx().register_region_obligation(\n+                        obligation.cause.body_id,\n+                        RegionObligation {\n+                            sup_type: t_a,\n+                            sub_region: r_b,\n+                            cause: obligation.cause.clone()\n+                        });\n                     Ok(Some(vec![]))\n                 }\n             }\n@@ -558,25 +512,6 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n     }\n }\n \n-\n-fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n-                                    r_b: ty::Region<'tcx>,\n-                                    cause: ObligationCause<'tcx>,\n-                                    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n-{\n-    let region_obligation = RegionObligation { sup_type: t_a,\n-                                               sub_region: r_b,\n-                                               cause: cause };\n-\n-    debug!(\"register_region_obligation({:?}, cause={:?})\",\n-           region_obligation, region_obligation.cause);\n-\n-    region_obligations.entry(region_obligation.cause.body_id)\n-                      .or_insert(vec![])\n-                      .push(region_obligation);\n-\n-}\n-\n fn to_fulfillment_error<'tcx>(\n     error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>)\n     -> FulfillmentError<'tcx>"}, {"sha": "69a57ac0b553c5ce589a4562dff1fffc2cedf8fd", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "patch": "@@ -30,7 +30,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n-pub use self::fulfill::{FulfillmentContext, RegionObligation};\n+pub use self::fulfill::FulfillmentContext;\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};"}, {"sha": "56c2a38501ef5a7341c1b7193bfca913124cb9f8", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "patch": "@@ -26,13 +26,6 @@ impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::RegionObligation<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-               self.sub_region,\n-               self.sup_type)\n-    }\n-}\n impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Obligation(predicate={:?},depth={})\","}, {"sha": "b1ac3abe23024058bcf68b88257e342cffa2766b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64206b44b9925a8eb5d9e2614c5e6175a1b5533a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=64206b44b9925a8eb5d9e2614c5e6175a1b5533a", "patch": "@@ -360,11 +360,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // Make a copy of the region obligations vec because we'll need\n         // to be able to borrow the fulfillment-cx below when projecting.\n-        let region_obligations =\n-            self.fulfillment_cx\n-                .borrow()\n-                .region_obligations(node_id)\n-                .to_vec();\n+        let region_obligations = self.infcx.take_region_obligations(node_id);\n \n         for r_o in &region_obligations {\n             debug!(\"visit_region_obligations: r_o={:?} cause={:?}\",\n@@ -375,8 +371,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Processing the region obligations should not cause the list to grow further:\n-        assert_eq!(region_obligations.len(),\n-                   self.fulfillment_cx.borrow().region_obligations(node_id).len());\n+        assert!(self.infcx.take_region_obligations(node_id).is_empty());\n     }\n \n     fn code_to_origin(&self,"}]}