{"sha": "59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZGQwN2FlMmJiYzhkNmM0NmJkYjVmM2Q1YjkzYTY3Mjk4NDgzMTE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-12T20:39:49Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-15T17:40:18Z"}, "message": "resolve: Eliminate `InvocationData`\n\nIt was very similar to `ParentScope` and mostly could be replaced by it.", "tree": {"sha": "4ff4555f9bd1782872295b7350fa39e278bf26b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ff4555f9bd1782872295b7350fa39e278bf26b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "html_url": "https://github.com/rust-lang/rust/commit/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a1557c28501d256f3a21099d17a73e1d2c36aa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1557c28501d256f3a21099d17a73e1d2c36aa0", "html_url": "https://github.com/rust-lang/rust/commit/1a1557c28501d256f3a21099d17a73e1d2c36aa0"}], "stats": {"total": 144, "additions": 53, "deletions": 91}, "files": [{"sha": "51a0a745688511cbeaabf67861e51587d08d2000", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "patch": "@@ -3,7 +3,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use crate::macros::{InvocationData, LegacyBinding, LegacyScope};\n+use crate::macros::{LegacyBinding, LegacyScope};\n use crate::resolve_imports::ImportDirective;\n use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n@@ -1063,20 +1063,17 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: ast::NodeId) -> &'a InvocationData<'a> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        let parent_scope = self.parent_scope.clone();\n+        parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n \n-        let invocation_data = self.r.arenas.alloc_invocation_data(InvocationData {\n-            module: self.parent_scope.module,\n-            parent_legacy_scope: self.parent_scope.legacy,\n-            output_legacy_scope: Cell::new(None),\n-        });\n-        let old_invocation_data = self.r.invocations.insert(invoc_id, invocation_data);\n-        assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n+        let old_parent_scope =\n+            self.r.invocation_parent_scopes.insert(invoc_id, parent_scope.clone());\n+        assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        invocation_data\n+        LegacyScope::Invocation(invoc_id)\n     }\n \n     fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n@@ -1177,7 +1174,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(item.id));\n+                self.parent_scope.legacy = self.visit_invoc(item.id);\n                 return\n             }\n             ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n@@ -1196,7 +1193,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n+            self.parent_scope.legacy = self.visit_invoc(stmt.id);\n         } else {\n             visit::walk_stmt(self, stmt);\n         }"}, {"sha": "85f8d07bf9bd5c3733b51ad1cb82347519191a77", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "patch": "@@ -54,7 +54,7 @@ use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use late::{PathSource, Rib, RibKind::*};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, LegacyScope};\n+use macros::{LegacyBinding, LegacyScope};\n \n type Res = def::Res<NodeId>;\n \n@@ -911,9 +911,12 @@ pub struct Resolver<'a> {\n     /// FIXME: Find a way for `PartialEq` and `Eq` to emulate `#[structural_match]`\n     /// by marking the produced impls rather than the original items.\n     special_derives: FxHashMap<ExpnId, SpecialDerives>,\n-\n-    /// Maps the `ExpnId` of an expansion to its containing module or block.\n-    invocations: FxHashMap<ExpnId, &'a InvocationData<'a>>,\n+    /// Parent scopes in which the macros were invoked.\n+    /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n+    invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n+    /// Legacy scopes *produced* by expanding the macro invocations,\n+    /// include all the `macro_rules` items and other invocations generated by them.\n+    output_legacy_scopes: FxHashMap<ExpnId, LegacyScope<'a>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n@@ -936,7 +939,6 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n-    invocation_data: arena::TypedArena<InvocationData<'a>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n }\n \n@@ -961,10 +963,6 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n-    fn alloc_invocation_data(&'a self, expansion_data: InvocationData<'a>)\n-                             -> &'a InvocationData<'a> {\n-        self.invocation_data.alloc(expansion_data)\n-    }\n     fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n         self.legacy_bindings.alloc(binding)\n     }\n@@ -1078,9 +1076,8 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let mut invocations = FxHashMap::default();\n-        invocations.insert(ExpnId::root(),\n-                           arenas.alloc_invocation_data(InvocationData::default(graph_root)));\n+        let mut invocation_parent_scopes = FxHashMap::default();\n+        invocation_parent_scopes.insert(ExpnId::root(), ParentScope::default(graph_root));\n \n         let mut macro_defs = FxHashMap::default();\n         macro_defs.insert(ExpnId::root(), root_def_id);\n@@ -1152,7 +1149,8 @@ impl<'a> Resolver<'a> {\n             dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n-            invocations,\n+            invocation_parent_scopes,\n+            output_legacy_scopes: Default::default(),\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n@@ -1370,8 +1368,9 @@ impl<'a> Resolver<'a> {\n                     LegacyScope::Binding(binding) => Scope::MacroRules(\n                         binding.parent_legacy_scope\n                     ),\n-                    LegacyScope::Invocation(invoc) => Scope::MacroRules(\n-                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n+                    LegacyScope::Invocation(invoc_id) => Scope::MacroRules(\n+                        self.output_legacy_scopes.get(&invoc_id).cloned()\n+                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].legacy)\n                     ),\n                     LegacyScope::Empty => Scope::Module(module),\n                 }"}, {"sha": "e64ca61b7efdc5c10e1b2a76e8334bcc44044053", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 29, "deletions": 63, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=59dd07ae2bbc8d6c46bdb5f3d5b93a6729848311", "patch": "@@ -1,6 +1,6 @@\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n-use crate::{Module, ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n+use crate::{ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n use crate::build_reduced_graph::BuildReducedGraphVisitor;\n@@ -22,36 +22,11 @@ use syntax::feature_gate::GateIssue;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::cell::Cell;\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n type Res = def::Res<ast::NodeId>;\n \n-// FIXME: Merge this with `ParentScope`.\n-#[derive(Clone, Debug)]\n-pub struct InvocationData<'a> {\n-    /// The module in which the macro was invoked.\n-    crate module: Module<'a>,\n-    /// The legacy scope in which the macro was invoked.\n-    /// The invocation path is resolved in this scope.\n-    crate parent_legacy_scope: LegacyScope<'a>,\n-    /// The legacy scope *produced* by expanding this macro invocation,\n-    /// includes all the macro_rules items, other invocations, etc generated by it.\n-    /// `None` if the macro is not expanded yet.\n-    crate output_legacy_scope: Cell<Option<LegacyScope<'a>>>,\n-}\n-\n-impl<'a> InvocationData<'a> {\n-    pub fn default(module: Module<'a>) -> Self {\n-        InvocationData {\n-            module,\n-            parent_legacy_scope: LegacyScope::Empty,\n-            output_legacy_scope: Cell::new(None),\n-        }\n-    }\n-}\n-\n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n #[derive(Debug)]\n@@ -75,7 +50,7 @@ pub enum LegacyScope<'a> {\n     Binding(&'a LegacyBinding<'a>),\n     /// The scope introduced by a macro invocation that can potentially\n     /// create a `macro_rules!` macro definition.\n-    Invocation(&'a InvocationData<'a>),\n+    Invocation(ExpnId),\n }\n \n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n@@ -124,9 +99,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n         )));\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n-        let invocation_data = self.arenas.alloc_invocation_data(InvocationData::default(module));\n+        self.invocation_parent_scopes.insert(expn_id, ParentScope::default(module));\n         self.definitions.set_invocation_parent(expn_id, module.def_id().unwrap().index);\n-        self.invocations.insert(expn_id, invocation_data);\n         expn_id\n     }\n \n@@ -140,29 +114,29 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]) {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expn_id));\n-\n-        let invocation = self.invocations[&expn_id];\n-        invocation.module.unresolved_invocations.borrow_mut().remove(&expn_id);\n-        invocation.module.unresolved_invocations.borrow_mut().extend(derives);\n-        let parent_def = self.definitions.invocation_parent(expn_id);\n+    fn visit_ast_fragment_with_placeholders(\n+        &mut self, expansion: ExpnId, fragment: &AstFragment, derives: &[ExpnId]\n+    ) {\n+        // Fill in some data for derives if the fragment is from a derive container.\n+        let parent_scope = self.invocation_parent_scopes[&expansion].clone();\n+        let parent_def = self.definitions.invocation_parent(expansion);\n+        self.invocation_parent_scopes.extend(\n+            derives.iter().map(|&derive| (derive, parent_scope.clone()))\n+        );\n         for &derive_invoc_id in derives {\n             self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n         }\n-        self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n-        let mut visitor = BuildReducedGraphVisitor {\n-            r: self,\n-            parent_scope: ParentScope {\n-                module: invocation.module,\n-                expansion: expn_id,\n-                legacy: invocation.parent_legacy_scope,\n-                derives: Vec::new(),\n-            },\n-        };\n+        parent_scope.module.unresolved_invocations.borrow_mut().remove(&expansion);\n+        parent_scope.module.unresolved_invocations.borrow_mut().extend(derives);\n+\n+        // Integrate the new AST fragment into all the definition and module structures.\n+        // We are inside the `expansion` new, but other parent scope components are still the same.\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expansion));\n+        let parent_scope = ParentScope { expansion, ..parent_scope };\n+        let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n-        invocation.output_legacy_scope.set(Some(visitor.parent_scope.legacy));\n+        let output_legacy_scope = visitor.parent_scope.legacy;\n+        self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -178,7 +152,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n-        let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n+        let parent_scope = &self.invocation_parent_scopes[&invoc_id].clone();\n+        let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n                 (&attr.path, MacroKind::Attr, derives.clone(), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n@@ -192,7 +167,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 // will automatically knows about itself.\n                 let mut result = Ok(None);\n                 if derives.len() > 1 {\n-                    let parent_scope = &self.invoc_parent_scope(invoc_id, Vec::new());\n                     for path in derives {\n                         match self.resolve_macro_path(path, Some(MacroKind::Derive),\n                                                       parent_scope, true, force) {\n@@ -209,7 +183,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         };\n \n-        let parent_scope = &self.invoc_parent_scope(invoc_id, derives_in_scope);\n+        // Derives are not included when `invocations` are collected, so we have to add them here.\n+        let parent_scope = &ParentScope { derives, ..parent_scope.clone() };\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n@@ -247,16 +222,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    fn invoc_parent_scope(&self, invoc_id: ExpnId, derives: Vec<ast::Path>) -> ParentScope<'a> {\n-        let invoc = self.invocations[&invoc_id];\n-        ParentScope {\n-            module: invoc.module,\n-            expansion: invoc_id.parent(),\n-            legacy: invoc.parent_legacy_scope,\n-            derives,\n-        }\n-    }\n-\n     /// Resolve macro path with error reporting and recovery.\n     fn smart_resolve_macro_path(\n         &mut self,\n@@ -466,8 +431,9 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n                         Ok((legacy_binding.binding, Flags::MACRO_RULES)),\n-                    LegacyScope::Invocation(invoc) if invoc.output_legacy_scope.get().is_none() =>\n-                        Err(Determinacy::Undetermined),\n+                    LegacyScope::Invocation(invoc_id)\n+                        if !this.output_legacy_scopes.contains_key(&invoc_id) =>\n+                            Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n                 Scope::CrateRoot => {"}]}