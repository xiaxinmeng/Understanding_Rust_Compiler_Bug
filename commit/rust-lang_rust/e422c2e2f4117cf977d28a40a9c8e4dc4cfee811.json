{"sha": "e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MjJjMmUyZjQxMTdjZjk3N2QyOGE0MGE5YzhlNGRjNGNmZWU4MTE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-27T12:19:19Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-27T12:19:19Z"}, "message": "Merge #325\n\n325: implement translate_offset_with_edit r=matklad a=vemoo\n\n- Implement `translate_offset_with_edit` to resolve #105 \r\n- Add proptest impls for text, offsets and edits and use them in tests for `translate_offset_with_edit` and `LineIndex`\r\n- Added benchmark for `translate_offset_with_edit`\n\nCo-authored-by: Bernardo <berublan@gmail.com>", "tree": {"sha": "9ea1dc365e420c286834b40923deb95a0ca291b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ea1dc365e420c286834b40923deb95a0ca291b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "html_url": "https://github.com/rust-lang/rust/commit/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "55ab0c602e391537f5e1a84a617fdd817e6a4200", "url": "https://api.github.com/repos/rust-lang/rust/commits/55ab0c602e391537f5e1a84a617fdd817e6a4200", "html_url": "https://github.com/rust-lang/rust/commit/55ab0c602e391537f5e1a84a617fdd817e6a4200"}, {"sha": "1cda43aafd623b400f5916b1d3727b56c136081b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cda43aafd623b400f5916b1d3727b56c136081b", "html_url": "https://github.com/rust-lang/rust/commit/1cda43aafd623b400f5916b1d3727b56c136081b"}], "stats": {"total": 868, "additions": 718, "deletions": 150}, "files": [{"sha": "0d417c02400db976d454800f5ff1e390f4654709", "filename": "Cargo.lock", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -73,6 +73,19 @@ dependencies = [\n  \"safemem 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"bit-set\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bit-vec 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"bit-vec\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.0.4\"\n@@ -302,6 +315,11 @@ dependencies = [\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"fnv\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"fst\"\n version = \"0.3.3\"\n@@ -625,6 +643,28 @@ dependencies = [\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"proptest\"\n+version = \"0.8.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rusty-fork 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"quick-error\"\n+version = \"1.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"quote\"\n version = \"0.6.10\"\n@@ -684,6 +724,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proptest 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -764,6 +805,7 @@ dependencies = [\n name = \"ra_text_edit\"\n version = \"0.1.0\"\n dependencies = [\n+ \"proptest 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -984,6 +1026,17 @@ dependencies = [\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rusty-fork\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"wait-timeout 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ryu\"\n version = \"0.2.7\"\n@@ -1413,6 +1466,14 @@ name = \"void\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"wait-timeout\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"walkdir\"\n version = \"2.2.7\"\n@@ -1460,6 +1521,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum backtrace 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b5b493b66e03090ebc4343eb02f94ff944e0cbc9ac6571491d170ba026741eb5\"\n \"checksum backtrace-sys 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fcce89e5ad5c8949caa9434501f7b55415b3e7ad5270cb88c75a8d35e8f1279\"\n \"checksum base64 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"489d6c0ed21b11d038c31b6ceccca973e65d73ba3bd8ecb9a2babf5546164643\"\n+\"checksum bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6f1efcc46c18245a69c38fcc5cc650f16d3a59d034f3106e9ed63748f695730a\"\n+\"checksum bit-vec 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4440d5cb623bb7390ae27fec0bb6c61111969860f8e3ae198bfa0663645e67cf\"\n \"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12\"\n \"checksum block-buffer 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a076c298b9ecdb530ed9d967e74a6027d6a7478924520acddcddc24c1c8ab3ab\"\n \"checksum byte-tools 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n@@ -1488,6 +1551,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"64c2d913fe8ed3b6c6518eedf4538255b989945c14c2a7d5cbff62a5e2120596\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \"checksum flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4dda06444ccc8b0a6da19d939989b4a4e83f328710ada449eedaed48c8b903cd\"\n+\"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n \"checksum fst 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db72126ca7dff566cdbbdd54af44668c544897d9d3862b198141f176f1238bdf\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n \"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n@@ -1528,6 +1592,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum pest_generator 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ebee4e9680be4fd162e6f3394ae4192a6b60b1e4d17d845e631f0c68d1a3386\"\n \"checksum pest_meta 2.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f6d5f6f0e6082578c86af197d780dc38328e3f768cec06aac9bc46d714e8221\"\n \"checksum proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77619697826f31a02ae974457af0b29b723e5619e113e9397b8b82c6bd253f09\"\n+\"checksum proptest 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"926d0604475349f463fe44130aae73f2294b5309ab2ca0310b998bd334ef191f\"\n+\"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"53fa22a1994bd0f9372d7a816207d8a2677ad0325b073f5c5332760f0fb62b5c\"\n \"checksum rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8356f47b32624fef5b3301c1be97e5944ecdd595409cc5da11d05f211db6cfbd\"\n \"checksum rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e464cd887e869cddcae8792a4ee31d23c7edd516700695608f5b98c67ee0131c\"\n@@ -1552,6 +1618,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-demangle 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"01b90379b8664dd83460d59bdc5dd1fd3172b8913788db483ed1325171eab2f7\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n+\"checksum rusty-fork 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9591f190d2852720b679c21f66ad929f9f1d7bb09d1193c26167586029d8489c\"\n \"checksum ryu 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb9e9b8cde282a9fe6a42dd4681319bfb63f121b8a8ee9439c6f4107e58a46f7\"\n \"checksum safemem 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8dca453248a96cb0749e36ccdfe2b0b4e54a61bfef89fb97ec621eb8e0a93dd9\"\n \"checksum salsa 0.8.0 (git+https://github.com/matklad/salsa?branch=no-upgrade)\" = \"<none>\"\n@@ -1603,6 +1670,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n \"checksum version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n+\"checksum wait-timeout 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b9f3bf741a801531993db6478b95682117471f76916f5e690dd8d45395b09349\"\n \"checksum walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d9d7ed3431229a144296213105a390676cc49c9b6a72bd19f3176c98e129fa1\"\n \"checksum winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92c1eb33641e276cfa214a0522acad57be5c56b10cb348b3c5117db75f3ac4b0\"\n \"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\""}, {"sha": "f39fe4af66c79eaf304886ccfe95725de6ac6f3d", "filename": "crates/ra_editor/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_editor%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_editor%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2FCargo.toml?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -16,3 +16,4 @@ ra_text_edit = { path = \"../ra_text_edit\" }\n \n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }\n+proptest = \"0.8.7\""}, {"sha": "d9b89155b66279b71932c26b49d73aee7d009434", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -2,6 +2,7 @@ mod code_actions;\n mod extend_selection;\n mod folding_ranges;\n mod line_index;\n+mod line_index_utils;\n mod symbols;\n #[cfg(test)]\n mod test_utils;\n@@ -12,6 +13,7 @@ pub use self::{\n     extend_selection::extend_selection,\n     folding_ranges::{folding_ranges, Fold, FoldKind},\n     line_index::{LineCol, LineIndex},\n+    line_index_utils::translate_offset_with_edit,\n     symbols::{file_structure, file_symbols, FileSymbol, StructureNode},\n     typing::{join_lines, on_enter, on_eq_typed},\n };"}, {"sha": "898fee7e00ea815549b6855a6c75df9ed9e17b8f", "filename": "crates/ra_editor/src/line_index.rs", "status": "modified", "additions": 179, "deletions": 104, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index.rs?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -4,8 +4,8 @@ use superslice::Ext;\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n-    newlines: Vec<TextUnit>,\n-    utf16_lines: FxHashMap<u32, Vec<Utf16Char>>,\n+    pub(crate) newlines: Vec<TextUnit>,\n+    pub(crate) utf16_lines: FxHashMap<u32, Vec<Utf16Char>>,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -15,9 +15,9 @@ pub struct LineCol {\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-struct Utf16Char {\n-    start: TextUnit,\n-    end: TextUnit,\n+pub(crate) struct Utf16Char {\n+    pub(crate) start: TextUnit,\n+    pub(crate) end: TextUnit,\n }\n \n impl Utf16Char {\n@@ -62,6 +62,12 @@ impl LineIndex {\n \n             curr_col += char_len;\n         }\n+\n+        // Save any utf-16 characters seen in the last line\n+        if utf16_chars.len() > 0 {\n+            utf16_lines.insert(line, utf16_chars);\n+        }\n+\n         LineIndex {\n             newlines,\n             utf16_lines,\n@@ -122,111 +128,179 @@ impl LineIndex {\n     }\n }\n \n-#[test]\n-fn test_line_index() {\n-    let text = \"hello\\nworld\";\n-    let index = LineIndex::new(text);\n-    assert_eq!(\n-        index.line_col(0.into()),\n-        LineCol {\n-            line: 0,\n-            col_utf16: 0\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(1.into()),\n-        LineCol {\n-            line: 0,\n-            col_utf16: 1\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(5.into()),\n-        LineCol {\n-            line: 0,\n-            col_utf16: 5\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(6.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 0\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(7.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 1\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(8.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 2\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(10.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 4\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(11.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 5\n+#[cfg(test)]\n+/// Simple reference implementation to use in proptests\n+pub fn to_line_col(text: &str, offset: TextUnit) -> LineCol {\n+    let mut res = LineCol {\n+        line: 0,\n+        col_utf16: 0,\n+    };\n+    for (i, c) in text.char_indices() {\n+        if i + c.len_utf8() > offset.to_usize() {\n+            // if it's an invalid offset, inside a multibyte char\n+            // return as if it was at the start of the char\n+            break;\n         }\n-    );\n-    assert_eq!(\n-        index.line_col(12.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 6\n+        if c == '\\n' {\n+            res.line += 1;\n+            res.col_utf16 = 0;\n+        } else {\n+            res.col_utf16 += 1;\n         }\n-    );\n+    }\n+    res\n+}\n \n-    let text = \"\\nhello\\nworld\";\n-    let index = LineIndex::new(text);\n-    assert_eq!(\n-        index.line_col(0.into()),\n-        LineCol {\n+#[cfg(test)]\n+mod test_line_index {\n+    use super::*;\n+    use proptest::{prelude::*, proptest, proptest_helper};\n+    use ra_text_edit::test_utils::{arb_text, arb_offset};\n+\n+    #[test]\n+    fn test_line_index() {\n+        let text = \"hello\\nworld\";\n+        let index = LineIndex::new(text);\n+        assert_eq!(\n+            index.line_col(0.into()),\n+            LineCol {\n+                line: 0,\n+                col_utf16: 0\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(1.into()),\n+            LineCol {\n+                line: 0,\n+                col_utf16: 1\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(5.into()),\n+            LineCol {\n+                line: 0,\n+                col_utf16: 5\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(6.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 0\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(7.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 1\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(8.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 2\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(10.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 4\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(11.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 5\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(12.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 6\n+            }\n+        );\n+\n+        let text = \"\\nhello\\nworld\";\n+        let index = LineIndex::new(text);\n+        assert_eq!(\n+            index.line_col(0.into()),\n+            LineCol {\n+                line: 0,\n+                col_utf16: 0\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(1.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 0\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(2.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 1\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(6.into()),\n+            LineCol {\n+                line: 1,\n+                col_utf16: 5\n+            }\n+        );\n+        assert_eq!(\n+            index.line_col(7.into()),\n+            LineCol {\n+                line: 2,\n+                col_utf16: 0\n+            }\n+        );\n+    }\n+\n+    fn arb_text_with_offset() -> BoxedStrategy<(TextUnit, String)> {\n+        arb_text()\n+            .prop_flat_map(|text| (arb_offset(&text), Just(text)))\n+            .boxed()\n+    }\n+\n+    fn to_line_col(text: &str, offset: TextUnit) -> LineCol {\n+        let mut res = LineCol {\n             line: 0,\n-            col_utf16: 0\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(1.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 0\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(2.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 1\n-        }\n-    );\n-    assert_eq!(\n-        index.line_col(6.into()),\n-        LineCol {\n-            line: 1,\n-            col_utf16: 5\n+            col_utf16: 0,\n+        };\n+        for (i, c) in text.char_indices() {\n+            if i + c.len_utf8() > offset.to_usize() {\n+                // if it's an invalid offset, inside a multibyte char\n+                // return as if it was at the start of the char\n+                break;\n+            }\n+            if c == '\\n' {\n+                res.line += 1;\n+                res.col_utf16 = 0;\n+            } else {\n+                res.col_utf16 += 1;\n+            }\n         }\n-    );\n-    assert_eq!(\n-        index.line_col(7.into()),\n-        LineCol {\n-            line: 2,\n-            col_utf16: 0\n+        res\n+    }\n+\n+    proptest! {\n+        #[test]\n+        fn test_line_index_proptest((offset, text) in arb_text_with_offset()) {\n+            let expected = to_line_col(&text, offset);\n+            let line_index = LineIndex::new(&text);\n+            let actual = line_index.line_col(offset);\n+\n+            assert_eq!(actual, expected);\n         }\n-    );\n+    }\n }\n \n #[cfg(test)]\n@@ -321,4 +395,5 @@ const C: char = \\\"\u30e1 \u30e1\\\";\n \n         assert_eq!(col_index.utf16_to_utf8_col(2, 15), TextUnit::from_usize(15));\n     }\n+\n }"}, {"sha": "ec3269bbbab83dae7e3c2acbc8f30303c5d87a4b", "filename": "crates/ra_editor/src/line_index_utils.rs", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -0,0 +1,363 @@\n+use ra_text_edit::{AtomTextEdit, TextEdit};\n+use ra_syntax::{TextUnit, TextRange};\n+use crate::{LineIndex, LineCol, line_index::Utf16Char};\n+\n+#[derive(Debug, Clone)]\n+enum Step {\n+    Newline(TextUnit),\n+    Utf16Char(TextRange),\n+}\n+\n+#[derive(Debug)]\n+struct LineIndexStepIter<'a> {\n+    line_index: &'a LineIndex,\n+    next_newline_idx: usize,\n+    utf16_chars: Option<(TextUnit, std::slice::Iter<'a, Utf16Char>)>,\n+}\n+\n+impl<'a> LineIndexStepIter<'a> {\n+    fn from(line_index: &LineIndex) -> LineIndexStepIter {\n+        let mut x = LineIndexStepIter {\n+            line_index,\n+            next_newline_idx: 0,\n+            utf16_chars: None,\n+        };\n+        // skip first newline since it's not real\n+        x.next();\n+        x\n+    }\n+}\n+\n+impl<'a> Iterator for LineIndexStepIter<'a> {\n+    type Item = Step;\n+    fn next(&mut self) -> Option<Step> {\n+        self.utf16_chars\n+            .as_mut()\n+            .and_then(|(newline, x)| {\n+                let x = x.next()?;\n+                Some(Step::Utf16Char(TextRange::from_to(\n+                    *newline + x.start,\n+                    *newline + x.end,\n+                )))\n+            })\n+            .or_else(|| {\n+                let next_newline = *self.line_index.newlines.get(self.next_newline_idx)?;\n+                self.utf16_chars = self\n+                    .line_index\n+                    .utf16_lines\n+                    .get(&(self.next_newline_idx as u32))\n+                    .map(|x| (next_newline, x.iter()));\n+                self.next_newline_idx += 1;\n+                Some(Step::Newline(next_newline))\n+            })\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct OffsetStepIter<'a> {\n+    text: &'a str,\n+    offset: TextUnit,\n+}\n+\n+impl<'a> Iterator for OffsetStepIter<'a> {\n+    type Item = Step;\n+    fn next(&mut self) -> Option<Step> {\n+        let (next, next_offset) = self\n+            .text\n+            .char_indices()\n+            .filter_map(|(i, c)| {\n+                if c == '\\n' {\n+                    let next_offset = self.offset + TextUnit::from_usize(i + 1);\n+                    let next = Step::Newline(next_offset);\n+                    Some((next, next_offset))\n+                } else {\n+                    let char_len = TextUnit::of_char(c);\n+                    if char_len.to_usize() > 1 {\n+                        let start = self.offset + TextUnit::from_usize(i);\n+                        let end = start + char_len;\n+                        let next = Step::Utf16Char(TextRange::from_to(start, end));\n+                        let next_offset = end;\n+                        Some((next, next_offset))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            })\n+            .next()?;\n+        let next_idx = (next_offset - self.offset).to_usize();\n+        self.text = &self.text[next_idx..];\n+        self.offset = next_offset;\n+        Some(next)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum NextSteps<'a> {\n+    Use,\n+    ReplaceMany(OffsetStepIter<'a>),\n+    AddMany(OffsetStepIter<'a>),\n+}\n+\n+#[derive(Debug)]\n+struct TranslatedEdit<'a> {\n+    delete: TextRange,\n+    insert: &'a str,\n+    diff: i64,\n+}\n+\n+struct Edits<'a> {\n+    edits: &'a [AtomTextEdit],\n+    current: Option<TranslatedEdit<'a>>,\n+    acc_diff: i64,\n+}\n+\n+impl<'a> Edits<'a> {\n+    fn from_text_edit(text_edit: &'a TextEdit) -> Edits<'a> {\n+        let mut x = Edits {\n+            edits: text_edit.as_atoms(),\n+            current: None,\n+            acc_diff: 0,\n+        };\n+        x.advance_edit();\n+        x\n+    }\n+    fn advance_edit(&mut self) {\n+        self.acc_diff += self.current.as_ref().map_or(0, |x| x.diff);\n+        match self.edits.split_first() {\n+            Some((next, rest)) => {\n+                let delete = self.translate_range(next.delete);\n+                let diff = next.insert.len() as i64 - next.delete.len().to_usize() as i64;\n+                self.current = Some(TranslatedEdit {\n+                    delete,\n+                    insert: &next.insert,\n+                    diff,\n+                });\n+                self.edits = rest;\n+            }\n+            None => {\n+                self.current = None;\n+            }\n+        }\n+    }\n+\n+    fn next_inserted_steps(&mut self) -> Option<OffsetStepIter<'a>> {\n+        let cur = self.current.as_ref()?;\n+        let res = Some(OffsetStepIter {\n+            offset: cur.delete.start(),\n+            text: &cur.insert,\n+        });\n+        self.advance_edit();\n+        res\n+    }\n+\n+    fn next_steps(&mut self, step: &Step) -> NextSteps {\n+        let step_pos = match step {\n+            &Step::Newline(n) => n,\n+            &Step::Utf16Char(r) => r.end(),\n+        };\n+        let res = match &mut self.current {\n+            Some(edit) => {\n+                if step_pos <= edit.delete.start() {\n+                    NextSteps::Use\n+                } else if step_pos <= edit.delete.end() {\n+                    let iter = OffsetStepIter {\n+                        offset: edit.delete.start(),\n+                        text: &edit.insert,\n+                    };\n+                    // empty slice to avoid returning steps again\n+                    edit.insert = &edit.insert[edit.insert.len()..];\n+                    NextSteps::ReplaceMany(iter)\n+                } else {\n+                    let iter = OffsetStepIter {\n+                        offset: edit.delete.start(),\n+                        text: &edit.insert,\n+                    };\n+                    // empty slice to avoid returning steps again\n+                    edit.insert = &edit.insert[edit.insert.len()..];\n+                    self.advance_edit();\n+                    NextSteps::AddMany(iter)\n+                }\n+            }\n+            None => NextSteps::Use,\n+        };\n+        res\n+    }\n+\n+    fn translate_range(&self, range: TextRange) -> TextRange {\n+        if self.acc_diff == 0 {\n+            range\n+        } else {\n+            let start = self.translate(range.start());\n+            let end = self.translate(range.end());\n+            TextRange::from_to(start, end)\n+        }\n+    }\n+\n+    fn translate(&self, x: TextUnit) -> TextUnit {\n+        if self.acc_diff == 0 {\n+            x\n+        } else {\n+            TextUnit::from((x.to_usize() as i64 + self.acc_diff) as u32)\n+        }\n+    }\n+\n+    fn translate_step(&self, x: &Step) -> Step {\n+        if self.acc_diff == 0 {\n+            x.clone()\n+        } else {\n+            match x {\n+                &Step::Newline(n) => Step::Newline(self.translate(n)),\n+                &Step::Utf16Char(r) => Step::Utf16Char(self.translate_range(r)),\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct RunningLineCol {\n+    line: u32,\n+    last_newline: TextUnit,\n+    col_adjust: TextUnit,\n+}\n+\n+impl RunningLineCol {\n+    fn new() -> RunningLineCol {\n+        RunningLineCol {\n+            line: 0,\n+            last_newline: TextUnit::from(0),\n+            col_adjust: TextUnit::from(0),\n+        }\n+    }\n+\n+    fn to_line_col(&self, offset: TextUnit) -> LineCol {\n+        LineCol {\n+            line: self.line,\n+            col_utf16: ((offset - self.last_newline) - self.col_adjust).into(),\n+        }\n+    }\n+\n+    fn add_line(&mut self, newline: TextUnit) {\n+        self.line += 1;\n+        self.last_newline = newline;\n+        self.col_adjust = TextUnit::from(0);\n+    }\n+\n+    fn adjust_col(&mut self, range: &TextRange) {\n+        self.col_adjust += range.len() - TextUnit::from(1);\n+    }\n+}\n+\n+pub fn translate_offset_with_edit(\n+    line_index: &LineIndex,\n+    offset: TextUnit,\n+    text_edit: &TextEdit,\n+) -> LineCol {\n+    let mut state = Edits::from_text_edit(&text_edit);\n+\n+    let mut res = RunningLineCol::new();\n+\n+    macro_rules! test_step {\n+        ($x:ident) => {\n+            match &$x {\n+                Step::Newline(n) => {\n+                    if offset < *n {\n+                        return res.to_line_col(offset);\n+                    } else {\n+                        res.add_line(*n);\n+                    }\n+                }\n+                Step::Utf16Char(x) => {\n+                    if offset < x.end() {\n+                        // if the offset is inside a multibyte char it's invalid\n+                        // clamp it to the start of the char\n+                        let clamp = offset.min(x.start());\n+                        return res.to_line_col(clamp);\n+                    } else {\n+                        res.adjust_col(x);\n+                    }\n+                }\n+            }\n+        };\n+    }\n+\n+    for orig_step in LineIndexStepIter::from(line_index) {\n+        loop {\n+            let translated_step = state.translate_step(&orig_step);\n+            match state.next_steps(&translated_step) {\n+                NextSteps::Use => {\n+                    test_step!(translated_step);\n+                    break;\n+                }\n+                NextSteps::ReplaceMany(ns) => {\n+                    for n in ns {\n+                        test_step!(n);\n+                    }\n+                    break;\n+                }\n+                NextSteps::AddMany(ns) => {\n+                    for n in ns {\n+                        test_step!(n);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    loop {\n+        match state.next_inserted_steps() {\n+            None => break,\n+            Some(ns) => {\n+                for n in ns {\n+                    test_step!(n);\n+                }\n+            }\n+        }\n+    }\n+\n+    res.to_line_col(offset)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use proptest::{prelude::*, proptest, proptest_helper};\n+    use crate::line_index;\n+    use ra_text_edit::test_utils::{arb_offset, arb_text_with_edit};\n+    use ra_text_edit::TextEdit;\n+\n+    #[derive(Debug)]\n+    struct ArbTextWithEditAndOffset {\n+        text: String,\n+        edit: TextEdit,\n+        edited_text: String,\n+        offset: TextUnit,\n+    }\n+\n+    fn arb_text_with_edit_and_offset() -> BoxedStrategy<ArbTextWithEditAndOffset> {\n+        arb_text_with_edit()\n+            .prop_flat_map(|x| {\n+                let edited_text = x.edit.apply(&x.text);\n+                let arb_offset = arb_offset(&edited_text);\n+                (Just(x), Just(edited_text), arb_offset).prop_map(|(x, edited_text, offset)| {\n+                    ArbTextWithEditAndOffset {\n+                        text: x.text,\n+                        edit: x.edit,\n+                        edited_text,\n+                        offset,\n+                    }\n+                })\n+            })\n+            .boxed()\n+    }\n+\n+    proptest! {\n+        #[test]\n+        fn test_translate_offset_with_edit(x in arb_text_with_edit_and_offset()) {\n+            let expected = line_index::to_line_col(&x.edited_text, x.offset);\n+            let line_index = LineIndex::new(&x.text);\n+            let actual = translate_offset_with_edit(&line_index, x.offset, &x.edit);\n+\n+            assert_eq!(actual, expected);\n+        }\n+    }\n+}"}, {"sha": "d3670104e4571ec09a31f31b2c4b0fe05e9c078e", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 7, "deletions": 40, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -3,7 +3,7 @@ use languageserver_types::{\n     TextDocumentItem, TextDocumentPositionParams, Url, VersionedTextDocumentIdentifier, InsertTextFormat,\n };\n use ra_analysis::{FileId, FileSystemEdit, SourceChange, SourceFileEdit, FilePosition, CompletionItem, CompletionItemKind, InsertText};\n-use ra_editor::{LineCol, LineIndex};\n+use ra_editor::{LineCol, LineIndex, translate_offset_with_edit};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n \n@@ -238,13 +238,15 @@ impl TryConvWith for SourceChange {\n             None => None,\n             Some(pos) => {\n                 let line_index = world.analysis().file_line_index(pos.file_id);\n-                let edits = self\n+                let edit = self\n                     .source_file_edits\n                     .iter()\n                     .find(|it| it.file_id == pos.file_id)\n-                    .map(|it| it.edit.as_atoms())\n-                    .unwrap_or(&[]);\n-                let line_col = translate_offset_with_edit(&*line_index, pos.offset, edits);\n+                    .map(|it| &it.edit);\n+                let line_col = match edit {\n+                    Some(edit) => translate_offset_with_edit(&*line_index, pos.offset, edit),\n+                    None => line_index.line_col(pos.offset),\n+                };\n                 let position =\n                     Position::new(u64::from(line_col.line), u64::from(line_col.col_utf16));\n                 Some(TextDocumentPositionParams {\n@@ -264,41 +266,6 @@ impl TryConvWith for SourceChange {\n     }\n }\n \n-// HACK: we should translate offset to line/column using linde_index *with edits applied*.\n-// A naive version of this function would be to apply `edits` to the original text,\n-// construct a new line index and use that, but it would be slow.\n-//\n-// Writing fast & correct version is issue #105, let's use a quick hack in the meantime\n-fn translate_offset_with_edit(\n-    pre_edit_index: &LineIndex,\n-    offset: TextUnit,\n-    edits: &[AtomTextEdit],\n-) -> LineCol {\n-    let fallback = pre_edit_index.line_col(offset);\n-    let edit = match edits.first() {\n-        None => return fallback,\n-        Some(edit) => edit,\n-    };\n-    let end_offset = edit.delete.start() + TextUnit::of_str(&edit.insert);\n-    if !(edit.delete.start() <= offset && offset <= end_offset) {\n-        return fallback;\n-    }\n-    let rel_offset = offset - edit.delete.start();\n-    let in_edit_line_col = LineIndex::new(&edit.insert).line_col(rel_offset);\n-    let edit_line_col = pre_edit_index.line_col(edit.delete.start());\n-    if in_edit_line_col.line == 0 {\n-        LineCol {\n-            line: edit_line_col.line,\n-            col_utf16: edit_line_col.col_utf16 + in_edit_line_col.col_utf16,\n-        }\n-    } else {\n-        LineCol {\n-            line: edit_line_col.line + in_edit_line_col.line,\n-            col_utf16: in_edit_line_col.col_utf16,\n-        }\n-    }\n-}\n-\n impl TryConvWith for SourceFileEdit {\n     type Ctx = ServerWorld;\n     type Output = TextDocumentEdit;"}, {"sha": "e0db49688e18faaa8bd87dd98448f48644b40e9f", "filename": "crates/ra_text_edit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_text_edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_text_edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2FCargo.toml?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -7,6 +7,7 @@ publish = false\n \n [dependencies]\n text_unit = \"0.1.5\"\n+proptest = \"0.8.7\"\n \n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }"}, {"sha": "8acf10448494cbb66a6efe946e2c553790b047eb", "filename": "crates/ra_text_edit/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Flib.rs?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -1,12 +1,15 @@\n mod text_edit;\n pub mod text_utils;\n+pub mod test_utils;\n \n pub use crate::text_edit::{TextEdit, TextEditBuilder};\n \n use text_unit::{TextRange, TextUnit};\n \n+/// Must not overlap with other `AtomTextEdit`s\n #[derive(Debug, Clone)]\n pub struct AtomTextEdit {\n+    /// Refers to offsets in the original text\n     pub delete: TextRange,\n     pub insert: String,\n }"}, {"sha": "745f21c931802eb1e87186b7fcfd5b30b3dc9e1a", "filename": "crates/ra_text_edit/src/test_utils.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_text_edit%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_text_edit%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftest_utils.rs?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -0,0 +1,85 @@\n+use proptest::prelude::*;\n+use text_unit::{TextUnit, TextRange};\n+use crate::{AtomTextEdit, TextEdit};\n+\n+pub fn arb_text() -> proptest::string::RegexGeneratorStrategy<String> {\n+    // generate multiple newlines\n+    proptest::string::string_regex(\"(.*\\n?)*\").unwrap()\n+}\n+\n+fn text_offsets(text: &str) -> Vec<TextUnit> {\n+    text.char_indices()\n+        .map(|(i, _)| TextUnit::from_usize(i))\n+        .collect()\n+}\n+\n+pub fn arb_offset(text: &str) -> BoxedStrategy<TextUnit> {\n+    let offsets = text_offsets(text);\n+    // this is necessary to avoid \"Uniform::new called with `low >= high`\" panic\n+    if offsets.is_empty() {\n+        Just(TextUnit::from(0)).boxed()\n+    } else {\n+        prop::sample::select(offsets).boxed()\n+    }\n+}\n+\n+pub fn arb_text_edit(text: &str) -> BoxedStrategy<TextEdit> {\n+    if text.is_empty() {\n+        // only valid edits\n+        return Just(vec![])\n+            .boxed()\n+            .prop_union(\n+                arb_text()\n+                    .prop_map(|text| vec![AtomTextEdit::insert(TextUnit::from(0), text)])\n+                    .boxed(),\n+            )\n+            .prop_map(TextEdit::from_atoms)\n+            .boxed();\n+    }\n+\n+    let offsets = text_offsets(text);\n+    let max_cuts = 7.min(offsets.len());\n+\n+    proptest::sample::subsequence(offsets, 0..max_cuts)\n+        .prop_flat_map(|cuts| {\n+            let strategies: Vec<_> = cuts\n+                .chunks(2)\n+                .map(|chunk| match chunk {\n+                    &[from, to] => {\n+                        let range = TextRange::from_to(from, to);\n+                        Just(AtomTextEdit::delete(range))\n+                            .boxed()\n+                            .prop_union(\n+                                arb_text()\n+                                    .prop_map(move |text| AtomTextEdit::replace(range, text))\n+                                    .boxed(),\n+                            )\n+                            .boxed()\n+                    }\n+                    &[x] => arb_text()\n+                        .prop_map(move |text| AtomTextEdit::insert(x, text))\n+                        .boxed(),\n+                    _ => unreachable!(),\n+                })\n+                .collect();\n+            strategies\n+        })\n+        .prop_map(TextEdit::from_atoms)\n+        .boxed()\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct ArbTextWithEdit {\n+    pub text: String,\n+    pub edit: TextEdit,\n+}\n+\n+pub fn arb_text_with_edit() -> BoxedStrategy<ArbTextWithEdit> {\n+    let text = arb_text();\n+    text.prop_flat_map(|s| {\n+        let edit = arb_text_edit(&s);\n+        (Just(s), edit)\n+    })\n+    .prop_map(|(text, edit)| ArbTextWithEdit { text, edit })\n+    .boxed()\n+}"}, {"sha": "0881f3e1cea06aecc445d6b26d6f92c231e3e455", "filename": "crates/ra_text_edit/src/text_edit.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e422c2e2f4117cf977d28a40a9c8e4dc4cfee811/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs?ref=e422c2e2f4117cf977d28a40a9c8e4dc4cfee811", "patch": "@@ -26,12 +26,7 @@ impl TextEditBuilder {\n         self.atoms.push(AtomTextEdit::insert(offset, text))\n     }\n     pub fn finish(self) -> TextEdit {\n-        let mut atoms = self.atoms;\n-        atoms.sort_by_key(|a| (a.delete.start(), a.delete.end()));\n-        for (a1, a2) in atoms.iter().zip(atoms.iter().skip(1)) {\n-            assert!(a1.delete.end() <= a2.delete.start())\n-        }\n-        TextEdit { atoms }\n+        TextEdit::from_atoms(self.atoms)\n     }\n     pub fn invalidates_offset(&self, offset: TextUnit) -> bool {\n         self.atoms\n@@ -41,6 +36,14 @@ impl TextEditBuilder {\n }\n \n impl TextEdit {\n+    pub(crate) fn from_atoms(mut atoms: Vec<AtomTextEdit>) -> TextEdit {\n+        atoms.sort_by_key(|a| (a.delete.start(), a.delete.end()));\n+        for (a1, a2) in atoms.iter().zip(atoms.iter().skip(1)) {\n+            assert!(a1.delete.end() <= a2.delete.start())\n+        }\n+        TextEdit { atoms }\n+    }\n+\n     pub fn as_atoms(&self) -> &[AtomTextEdit] {\n         &self.atoms\n     }"}]}