{"sha": "43ae4b3301cc0605839778ecf59effb32b752e33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYWU0YjMzMDFjYzA2MDU4Mzk3NzhlY2Y1OWVmZmIzMmI3NTJlMzM=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-07T02:34:37Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:51Z"}, "message": "Fallout from new thread API", "tree": {"sha": "aa111f5adc1eaa1e996847e1437d1b1b40821ce0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa111f5adc1eaa1e996847e1437d1b1b40821ce0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43ae4b3301cc0605839778ecf59effb32b752e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43ae4b3301cc0605839778ecf59effb32b752e33", "html_url": "https://github.com/rust-lang/rust/commit/43ae4b3301cc0605839778ecf59effb32b752e33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43ae4b3301cc0605839778ecf59effb32b752e33/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14c1a103bc3f78721df1dc860a75a477c8275e3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c1a103bc3f78721df1dc860a75a477c8275e3a", "html_url": "https://github.com/rust-lang/rust/commit/14c1a103bc3f78721df1dc860a75a477c8275e3a"}], "stats": {"total": 758, "additions": 321, "deletions": 437}, "files": [{"sha": "1b9d98823b036d9d0b3e43819416aa1475b33005", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -32,7 +32,7 @@ use std::io;\n use std::os;\n use std::str;\n use std::string::String;\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n use test::MetricMap;\n \n@@ -445,9 +445,9 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = task::try(move || {\n+                let result = Thread::with_join(move || {\n                     tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n-                });\n+                }).join();\n                 if result.is_err() {\n                     continue;\n                 }"}, {"sha": "4753ba7fe47033653babb1d9ef4dc78132a29ab4", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -347,16 +347,16 @@ result with an `int` field (representing a successful result) or an `Err` result\n (representing termination with an error).\n \n ```{rust}\n-# use std::task;\n+# use std::thread::Thread;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n-let result: Result<int, Box<std::any::Any + Send>> = task::try(move || {\n+let result: Result<int, Box<std::any::Any + Send>> = Thread::with_join(move || {\n     if some_condition() {\n         calculate_result()\n     } else {\n         panic!(\"oops!\");\n     }\n-});\n+}).join();\n assert!(result.is_err());\n ```\n "}, {"sha": "4bf356fb552e1fa4f2562e073300dc62affa786d", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -92,7 +92,7 @@ impl<'a, T, Sized? B> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n \n /// Trait for moving into a `Cow`\n pub trait IntoCow<'a, T, Sized? B> {\n-    /// Moves `self` into `Cow`\n+    /// Moves `serlf` into `Cow`\n     fn into_cow(self) -> Cow<'a, T, B>;\n }\n "}, {"sha": "ba5157932b61bbf1ad9937150c08ad631813b4bd", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -55,7 +55,7 @@ use rustc::DIAGNOSTICS;\n use std::any::AnyRefExt;\n use std::io;\n use std::os;\n-use std::task::TaskBuilder;\n+use std::thread;\n \n use rustc::session::early_error;\n \n@@ -475,18 +475,22 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     static STACK_SIZE: uint = 32000000; // 32MB\n \n     let (tx, rx) = channel();\n-    let w = io::ChanWriter::new(tx);\n+    let mut w = Some(io::ChanWriter::new(tx)); // option dance\n     let mut r = io::ChanReader::new(rx);\n \n-    let mut task = TaskBuilder::new().named(\"rustc\").stderr(box w);\n+    let mut cfg = thread::cfg().name(\"rustc\".to_string());\n \n     // FIXME: Hacks on hacks. If the env is trying to override the stack size\n     // then *don't* set it explicitly.\n     if os::getenv(\"RUST_MIN_STACK\").is_none() {\n-        task = task.stack_size(STACK_SIZE);\n+        cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    match task.try(f) {\n+    let f = proc() {\n+        std::io::stdio::set_stderr(box w.take().unwrap());\n+        f()\n+    };\n+    match cfg.with_join(f).join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n             // Task panicked without emitting a fatal diagnostic\n@@ -540,4 +544,3 @@ pub fn main() {\n     let result = run(args);\n     std::os::set_exit_status(result);\n }\n-"}, {"sha": "8ec010a85538a917065795e7af2c2395b92ee913", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -30,7 +30,7 @@ use std::ptr;\n use std::str;\n use std::mem;\n use std::sync::{Arc, Mutex};\n-use std::task::TaskBuilder;\n+use std::thread;\n use libc::{c_uint, c_int, c_void};\n \n #[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n@@ -896,7 +896,11 @@ fn run_work_multithreaded(sess: &Session,\n         let diag_emitter = diag_emitter.clone();\n         let remark = sess.opts.cg.remark.clone();\n \n-        let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(move |:| {\n+        let (tx, rx) = channel();\n+        let mut tx = Some(tx);\n+        futures.push(rx);\n+\n+        thread::cfg().name(format!(\"codegen-{}\", i)).spawn(move |:| {\n             let diag_handler = mk_handler(box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n@@ -921,13 +925,14 @@ fn run_work_multithreaded(sess: &Session,\n                     None => break,\n                 }\n             }\n+\n+            tx.take().unwrap().send(());\n         });\n-        futures.push(future);\n     }\n \n     let mut panicked = false;\n-    for future in futures.into_iter() {\n-        match future.into_inner() {\n+    for rx in futures.into_iter() {\n+        match rx.recv_opt() {\n             Ok(()) => {},\n             Err(_) => {\n                 panicked = true;"}, {"sha": "9e06b4e88f5865e45690426234e9b75577418ade", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -342,10 +342,11 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n-    let (mut krate, analysis) = std::task::try(move |:| {\n+\n+    let (mut krate, analysis) = std::thread::Thread::with_join(move |:| {\n         let cr = cr;\n         core::run_core(libs, cfgs, externs, &cr, triple)\n-    }).map_err(|_| \"rustc failed\").unwrap();\n+    }).join().map_err(|_| \"rustc failed\").unwrap();\n     info!(\"finished with rustc\");\n     let mut analysis = Some(analysis);\n     ANALYSISKEY.with(|s| {"}, {"sha": "d004f030f36af0f531f5a2f112de79132ceab8ca", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -16,6 +16,7 @@ use std::os;\n use std::str;\n use std::string::String;\n use std::thunk::Thunk;\n+use std::thread::Thread;\n \n use std::collections::{HashSet, HashMap};\n use testing;\n@@ -143,7 +144,7 @@ fn runtest(test: &str, cratename: &str, libs: Vec<Path>, externs: core::Externs,\n     let w1 = io::ChanWriter::new(tx);\n     let w2 = w1.clone();\n     let old = io::stdio::set_stderr(box w1);\n-    spawn(move |:| {\n+    Thread::spawn(move |:| {\n         let mut p = io::ChanReader::new(rx);\n         let mut err = match old {\n             Some(old) => {"}, {"sha": "6bfb219d9c44e4b009581aa9196acdc6d3fdfeb6", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -536,7 +536,7 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n mod tests {\n     use prelude::*;\n     use ptr;\n-    use task;\n+    use thread::Thread;\n     use libc;\n \n     use super::*;\n@@ -637,7 +637,7 @@ mod tests {\n \n     #[test]\n     fn test_to_c_str_fail() {\n-        assert!(task::try(move|| { \"he\\x00llo\".to_c_str() }).is_err());\n+        assert!(Thread::with_join(move|| { \"he\\x00llo\".to_c_str() }).join().is_err());\n     }\n \n     #[test]"}, {"sha": "bb09726575638a7892875fa32a94835c0baad34a", "filename": "src/libstd/comm/blocking.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fblocking.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -32,7 +32,7 @@ pub struct WaitToken {\n     no_send: NoSend,\n }\n \n-fn token() -> (WaitToken, SignalToken) {\n+pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: Thread::current(),\n         woken: INIT_ATOMIC_BOOL,\n@@ -48,7 +48,7 @@ fn token() -> (WaitToken, SignalToken) {\n }\n \n impl SignalToken {\n-    fn signal(&self) -> bool {\n+    pub fn signal(&self) -> bool {\n         let wake = !self.inner.woken.compare_and_swap(false, true, Ordering::SeqCst);\n         if wake {\n             self.inner.thread.unpark();\n@@ -73,7 +73,7 @@ impl SignalToken {\n }\n \n impl WaitToken {\n-    fn wait(self) {\n+    pub fn wait(self) {\n         while !self.inner.woken.load(Ordering::SeqCst) {\n             Thread::park()\n         }"}, {"sha": "236a055b91ea731678b17904f540a9e4daa564f2", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 31, "deletions": 90, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -317,8 +317,10 @@ use core::kinds::marker;\n use core::mem;\n use core::cell::UnsafeCell;\n \n-pub use comm::select::{Select, Handle};\n-use comm::select::StartResult::*;\n+pub use self::select::{Select, Handle};\n+use self::select::StartResult;\n+use self::select::StartResult::*;\n+use self::blocking::SignalToken;\n \n macro_rules! test {\n     { fn $name:ident() $b:block $(#[$a:meta])*} => (\n@@ -330,7 +332,7 @@ macro_rules! test {\n \n             use comm::*;\n             use super::*;\n-            use task;\n+            use thread::Thread;\n \n             $(#[$a])* #[test] fn f() { $b }\n         }\n@@ -593,12 +595,12 @@ impl<T: Send> Sender<T> {\n                                 (a, ret)\n                             }\n                             oneshot::UpDisconnected => (a, Err(t)),\n-                            oneshot::UpWoke(task) => {\n-                                // This send cannot panic because the task is\n+                            oneshot::UpWoke(token) => {\n+                                // This send cannot panic because the thread is\n                                 // asleep (we're looking at it), so the receiver\n                                 // can't go away.\n                                 (*a.get()).send(t).ok().unwrap();\n-                                task.wake().map(|t| t.reawaken());\n+                                token.signal();\n                                 (a, Ok(()))\n                             }\n                         }\n@@ -937,7 +939,7 @@ impl<T: Send> select::Packet for Receiver<T> {\n         }\n     }\n \n-    fn start_selection(&self, mut token: SignalToken) -> bool {\n+    fn start_selection(&self, mut token: SignalToken) -> StartResult {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => {\n@@ -1240,11 +1242,11 @@ mod test {\n \n     test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = task::try(move|| {\n+        let res = Thread::with_join(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n             rx.recv();\n-        });\n+        }).join();\n         // What is our res?\n         assert!(res.is_err());\n     } }\n@@ -1312,9 +1314,9 @@ mod test {\n         spawn(move|| {\n             drop(tx);\n         });\n-        let res = task::try(move|| {\n+        let res = Thread::with_join(move|| {\n             assert!(rx.recv() == box 10);\n-        });\n+        }).join();\n         assert!(res.is_err());\n     } }\n \n@@ -1334,19 +1336,19 @@ mod test {\n             spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = task::try(move|| {\n+            let _ = Thread::with_join(move|| {\n                 tx.send(1);\n-            });\n+            }).join();\n         }\n     } }\n \n     test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            spawn(move|| {\n-                let res = task::try(move|| {\n+            spawn(proc() {\n+                let res = Thread::with_join(move|| {\n                     rx.recv();\n-                });\n+                }).join();\n                 assert!(res.is_err());\n             });\n             spawn(move|| {\n@@ -1495,7 +1497,7 @@ mod test {\n             tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n-        for _ in range(0u, 5000) { task::deschedule(); }\n+        for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1504,45 +1506,7 @@ mod test {\n \n         // wait for the child task to exit before we exit\n         rx2.recv();\n-    } }\n-\n-    test! { fn sends_off_the_runtime() {\n-        use rt::thread::Thread;\n-\n-        let (tx, rx) = channel();\n-        let t = Thread::start(move|| {\n-            for _ in range(0u, 1000) {\n-                tx.send(());\n-            }\n-        });\n-        for _ in range(0u, 1000) {\n-            rx.recv();\n-        }\n-        t.join();\n-    } }\n-\n-    test! { fn try_recvs_off_the_runtime() {\n-        use rt::thread::Thread;\n-\n-        let (tx, rx) = channel();\n-        let (cdone, pdone) = channel();\n-        let t = Thread::start(move|| {\n-            let mut hits = 0u;\n-            while hits < 10 {\n-                match rx.try_recv() {\n-                    Ok(()) => { hits += 1; }\n-                    Err(Empty) => { Thread::yield_now(); }\n-                    Err(Disconnected) => return,\n-                }\n-            }\n-            cdone.send(());\n-        });\n-        for _ in range(0u, 10) {\n-            tx.send(());\n-        }\n-        t.join();\n-        pdone.recv();\n-    } }\n+    })\n }\n \n #[cfg(test)]\n@@ -1700,11 +1664,11 @@ mod sync_tests {\n \n     test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = task::try(move|| {\n+        let res = Thread::with_join(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n             rx.recv();\n-        });\n+        }).join();\n         // What is our res?\n         assert!(res.is_err());\n     } }\n@@ -1777,9 +1741,9 @@ mod sync_tests {\n         spawn(move|| {\n             drop(tx);\n         });\n-        let res = task::try(move|| {\n+        let res = Thread::with_join(move|| {\n             assert!(rx.recv() == box 10);\n-        });\n+        }).join();\n         assert!(res.is_err());\n     } }\n \n@@ -1799,19 +1763,19 @@ mod sync_tests {\n             spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = task::try(move|| {\n+            let _ = Thread::with_join(move || {\n                 tx.send(1);\n-            });\n+            }).join();\n         }\n     } }\n \n     test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            spawn(move|| {\n-                let res = task::try(move|| {\n+            spawn(proc() {\n+                let res = Thread::with_join(move|| {\n                     rx.recv();\n-                });\n+                }).join();\n                 assert!(res.is_err());\n             });\n             spawn(move|| {\n@@ -1960,7 +1924,7 @@ mod sync_tests {\n             tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n-        for _ in range(0u, 5000) { task::deschedule(); }\n+        for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1971,29 +1935,6 @@ mod sync_tests {\n         rx2.recv();\n     } }\n \n-    test! { fn try_recvs_off_the_runtime() {\n-        use rt::thread::Thread;\n-\n-        let (tx, rx) = sync_channel::<()>(0);\n-        let (cdone, pdone) = channel();\n-        let t = Thread::start(move|| {\n-            let mut hits = 0u;\n-            while hits < 10 {\n-                match rx.try_recv() {\n-                    Ok(()) => { hits += 1; }\n-                    Err(Empty) => { Thread::yield_now(); }\n-                    Err(Disconnected) => return,\n-                }\n-            }\n-            cdone.send(());\n-        });\n-        for _ in range(0u, 10) {\n-            tx.send(());\n-        }\n-        t.join();\n-        pdone.recv();\n-    } }\n-\n     test! { fn send_opt1() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| { rx.recv(); });\n@@ -2052,7 +1993,7 @@ mod sync_tests {\n     test! { fn try_send4() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n-            for _ in range(0u, 1000) { task::deschedule(); }\n+            for _ in range(0u, 1000) { Thread::yield_now(); }\n             assert_eq!(tx.try_send(1), Ok(()));\n         });\n         assert_eq!(rx.recv(), 1);"}, {"sha": "9c5a6518845300413c32ffb6fd2517c9856fd010", "filename": "src/libstd/comm/oneshot.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Foneshot.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -39,9 +39,8 @@ use self::MyUpgrade::*;\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n use comm::Receiver;\n-use comm::blocking::{mod, WaitToken, SignalToken};\n+use comm::blocking::{mod, SignalToken};\n use core::mem;\n use sync::atomic;\n \n@@ -143,7 +142,7 @@ impl<T: Send> Packet<T> {\n         // Attempt to not block the task (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(atomic::SeqCst) == EMPTY {\n-            let (wait_token, signal_token) = blocking::token();\n+            let (wait_token, signal_token) = blocking::tokens();\n             let ptr = unsafe { signal_token.cast_to_uint() };\n \n             // race with senders to enter the blocking state\n@@ -332,7 +331,7 @@ impl<T: Send> Packet<T> {\n \n             // If we've got a blocked task, then use an atomic to gain ownership\n             // of it (may fail)\n-            BLOCKED => self.state.compare_and_swap(BLOCKED, EMPTY, atomic::SeqCst)\n+            ptr => self.state.compare_and_swap(ptr, EMPTY, atomic::SeqCst)\n         };\n \n         // Now that we've got ownership of our state, figure out what to do"}, {"sha": "690b5861c2239d94b4db607c2b6f7b196e057b6b", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -54,7 +54,6 @@\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n use core::cell::Cell;\n use core::kinds::marker;\n use core::mem;\n@@ -63,8 +62,6 @@ use core::uint;\n use comm::Receiver;\n use comm::blocking::{mod, SignalToken};\n \n-use self::StartResult::*;\n-\n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n pub struct Select {\n@@ -190,8 +187,8 @@ impl Select {\n             let (wait_token, signal_token) = blocking::tokens();\n             for (i, handle) in self.iter().enumerate() {\n                 match (*handle).packet.start_selection(signal_token.clone()) {\n-                    Installed => {}\n-                    Abort => {\n+                    StartResult::Installed => {}\n+                    StartResult::Abort => {\n                         // Go back and abort the already-begun selections\n                         for handle in self.iter().take(i) {\n                             (*handle).packet.abort_selection();\n@@ -417,10 +414,10 @@ mod test {\n         let (tx3, rx3) = channel::<int>();\n \n         spawn(move|| {\n-            for _ in range(0u, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { Thread::yield_now(); }\n             tx1.send(1);\n             rx3.recv();\n-            for _ in range(0u, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { Thread::yield_now(); }\n         });\n \n         select! {\n@@ -440,7 +437,7 @@ mod test {\n         let (tx3, rx3) = channel::<()>();\n \n         spawn(move|| {\n-            for _ in range(0u, 20) { task::deschedule(); }\n+            for _ in range(0u, 20) { Thread::yield_now(); }\n             tx1.send(1);\n             tx2.send(2);\n             rx3.recv();\n@@ -541,7 +538,7 @@ mod test {\n             tx3.send(());\n         });\n \n-        for _ in range(0u, 1000) { task::deschedule(); }\n+        for _ in range(0u, 1000) { Thread::yield_now(); }\n         drop(tx1.clone());\n         tx2.send(());\n         rx3.recv();\n@@ -644,7 +641,7 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0u, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { Thread::yield_now() }\n         tx1.send(());\n         rx2.recv();\n     } }\n@@ -663,7 +660,7 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0u, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { Thread::yield_now() }\n         tx1.send(());\n         rx2.recv();\n     } }\n@@ -681,7 +678,7 @@ mod test {\n             tx2.send(());\n         });\n \n-        for _ in range(0u, 100) { task::deschedule() }\n+        for _ in range(0u, 100) { Thread::yield_now() }\n         tx1.send(());\n         rx2.recv();\n     } }\n@@ -697,7 +694,7 @@ mod test {\n     test! { fn sync2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n-            for _ in range(0u, 100) { task::deschedule() }\n+            for _ in range(0u, 100) { Thread::yield_now() }\n             tx.send(1);\n         });\n         select! {"}, {"sha": "1022694e634f607a64418f79f62f93ad61dd2dce", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -22,7 +22,6 @@ pub use self::Failure::*;\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n \n@@ -31,6 +30,7 @@ use comm::mpsc_queue as mpsc;\n use comm::blocking::{mod, SignalToken};\n use comm::select::StartResult;\n use comm::select::StartResult::*;\n+use thread::Thread;\n \n const DISCONNECTED: int = int::MIN;\n const FUDGE: int = 1024;"}, {"sha": "b68f626060eda78ee106a8b46017ee99f58eb8f5", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -24,15 +24,14 @@ use self::Message::*;\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n use thread::Thread;\n \n use sync::atomic;\n use comm::spsc_queue as spsc;\n use comm::Receiver;\n-use comm::blocking::{mod, WaitToken, SignalToken};\n+use comm::blocking::{mod, SignalToken};\n \n const DISCONNECTED: int = int::MIN;\n #[cfg(test)]\n@@ -147,7 +146,7 @@ impl<T: Send> Packet<T> {\n         let ptr = self.to_wake.load(atomic::SeqCst);\n         self.to_wake.store(0, atomic::SeqCst);\n         assert!(ptr != 0);\n-        unsafe { SignaToken::cast_from_uint(ptr) }\n+        unsafe { SignalToken::cast_from_uint(ptr) }\n     }\n \n     // Decrements the count on the channel for a sleeper, returning the sleeper"}, {"sha": "b24c6d21fba6dc2d3b190ed4c1de5b71c051c271", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -38,10 +38,8 @@ use core::prelude::*;\n pub use self::Failure::*;\n use self::Blocker::*;\n \n-use alloc::boxed::Box;\n use vec::Vec;\n use core::mem;\n-use core::cell::UnsafeCell;\n \n use sync::{atomic, Mutex, MutexGuard};\n use comm::blocking::{mod, WaitToken, SignalToken};\n@@ -105,10 +103,10 @@ pub enum Failure {\n \n /// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n /// in the meantime. This re-locks the mutex upon returning.\n-fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n-                   guard: MutexGuard<'b, State<T>>,\n-                   f: fn(BlockedTask) -> Blocker)\n-                   -> MutexGuard<'a, State<T>>\n+fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,\n+                         mut guard: MutexGuard<'b, State<T>>,\n+                         f: fn(SignalToken) -> Blocker)\n+                         -> MutexGuard<'a, State<T>>\n {\n     let me: Box<Task> = Local::take();\n     me.deschedule(1, |task| {\n@@ -170,7 +168,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n-        let guard = self.acquire_send_slot();\n+        let mut guard = self.acquire_send_slot();\n         if guard.disconnected { return Err(t) }\n         guard.buf.enqueue(t);\n \n@@ -183,7 +181,7 @@ impl<T: Send> Packet<T> {\n                 let mut canceled = false;\n                 assert!(guard.canceled.is_none());\n                 guard.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n-                let guard = wait(&self.lock, guard, BlockedSender);\n+                let mut guard = wait(&self.lock, guard, BlockedSender);\n                 if canceled {Err(guard.buf.dequeue())} else {Ok(())}\n             }\n \n@@ -198,7 +196,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n-        let guard = self.lock.lock();\n+        let mut guard = self.lock.lock();\n         if guard.disconnected {\n             Err(super::RecvDisconnected(t))\n         } else if guard.buf.size() == guard.buf.cap() {\n@@ -235,34 +233,34 @@ impl<T: Send> Packet<T> {\n     // When reading this, remember that there can only ever be one receiver at\n     // time.\n     pub fn recv(&self) -> Result<T, ()> {\n-        let guard = self.lock.lock();\n+        let mut guard = self.lock.lock();\n \n         // Wait for the buffer to have something in it. No need for a while loop\n         // because we're the only receiver.\n         let mut waited = false;\n         if !guard.disconnected && guard.buf.size() == 0 {\n-            wait(&mut guard.blocker, BlockedReceiver, &self.lock);\n+            guard = wait(&self.lock, guard, BlockedReceiver);\n             waited = true;\n         }\n         if guard.disconnected && guard.buf.size() == 0 { return Err(()) }\n \n         // Pick up the data, wake up our neighbors, and carry on\n         assert!(guard.buf.size() > 0);\n         let ret = guard.buf.dequeue();\n-        self.wakeup_senders(waited, guard, state);\n+        self.wakeup_senders(waited, guard);\n         return Ok(ret);\n     }\n \n     pub fn try_recv(&self) -> Result<T, Failure> {\n-        let guard = self.lock();\n+        let mut guard = self.lock.lock();\n \n         // Easy cases first\n         if guard.disconnected { return Err(Disconnected) }\n         if guard.buf.size() == 0 { return Err(Empty) }\n \n         // Be sure to wake up neighbors\n         let ret = Ok(guard.buf.dequeue());\n-        self.wakeup_senders(false, guard, state);\n+        self.wakeup_senders(false, guard);\n \n         return ret;\n     }\n@@ -272,7 +270,7 @@ impl<T: Send> Packet<T> {\n     // * `waited` - flag if the receiver blocked to receive some data, or if it\n     //              just picked up some data on the way out\n     // * `guard` - the lock guard that is held over this channel's lock\n-    fn wakeup_senders(&self, waited: bool, guard: MutexGuard<State<T>>) {\n+    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<State<T>>) {\n         let pending_sender1: Option<SignalToken> = guard.queue.dequeue();\n \n         // If this is a no-buffer channel (cap == 0), then if we didn't wait we\n@@ -311,7 +309,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         // Not much to do other than wake up a receiver if one's there\n-        let guard = self.lock();\n+        let mut guard = self.lock.lock();\n         if guard.disconnected { return }\n         guard.disconnected = true;\n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n@@ -322,7 +320,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn drop_port(&self) {\n-        let guard = self.lock();\n+        let mut guard = self.lock.lock();\n \n         if guard.disconnected { return }\n         guard.disconnected = true;\n@@ -368,14 +366,14 @@ impl<T: Send> Packet<T> {\n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n     pub fn can_recv(&self) -> bool {\n-        let guard = self.lock();\n+        let guard = self.lock.lock();\n         guard.disconnected || guard.buf.size() > 0\n     }\n \n     // Attempts to start selection on this port. This can either succeed or fail\n     // because there is data waiting.\n     pub fn start_selection(&self, token: SignalToken) -> StartResult {\n-        let guard = self.lock();\n+        let mut guard = self.lock.lock();\n         if guard.disconnected || guard.buf.size() > 0 {\n             Abort\n         } else {\n@@ -393,7 +391,7 @@ impl<T: Send> Packet<T> {\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&self) -> bool {\n-        let guard = self.lock();\n+        let mut guard = self.lock.lock();\n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => true,\n             BlockedSender(token) => {\n@@ -409,7 +407,7 @@ impl<T: Send> Packet<T> {\n impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.channels.load(atomic::SeqCst), 0);\n-        let guard = self.lock();\n+        let mut guard = self.lock.lock();\n         assert!(guard.queue.dequeue().is_none());\n         assert!(guard.canceled.is_none());\n     }"}, {"sha": "3934b0cf45f0cc1b1e15f921a512da87360b3129", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -21,10 +21,10 @@ use option::Option::{Some, None};\n use result::Result::Ok;\n use rt::backtrace;\n use rt::util::{Stderr, Stdio};\n-use rt::local::Local;\n-use rt::task::Task;\n use str::Str;\n use string::String;\n+use thread::Thread;\n+use sys_common::thread_info;\n \n // Defined in this module instead of io::stdio so that the unwinding\n thread_local! {\n@@ -52,63 +52,35 @@ pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) {\n         }\n     };\n     let mut err = Stderr;\n-\n-    // It is assumed that all reasonable rust code will have a local task at\n-    // all times. This means that this `exists` will return true almost all of\n-    // the time. There are border cases, however, when the runtime has\n-    // *almost* set up the local task, but hasn't quite gotten there yet. In\n-    // order to get some better diagnostics, we print on panic and\n-    // immediately abort the whole process if there is no local task\n-    // available.\n-    if !Local::exists(None::<Task>) {\n-        let _ = writeln!(&mut err, \"panicked at '{}', {}:{}\", msg, file, line);\n-        if backtrace::log_enabled() {\n-            let _ = backtrace::write(&mut err);\n-        } else {\n-            let _ = writeln!(&mut err, \"run with `RUST_BACKTRACE=1` to \\\n-                                        see a backtrace\");\n-        }\n-        return\n-    }\n-\n-    // Peel the name out of local task so we can print it. We've got to be sure\n-    // that the local task is in TLS while we're printing as I/O may occur.\n-    let (name, unwinding) = {\n-        let mut t = Local::borrow(None::<Task>);\n-        (t.name.take(), t.unwinder.unwinding())\n-    };\n-    {\n-        let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-        let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n-        match prev {\n-            Some(mut stderr) => {\n-                // FIXME: what to do when the task printing panics?\n-                let _ = writeln!(stderr,\n-                                 \"task '{}' panicked at '{}', {}:{}\\n\",\n-                                 n, msg, file, line);\n-                if backtrace::log_enabled() {\n-                    let _ = backtrace::write(&mut *stderr);\n-                }\n-                let mut s = Some(stderr);\n-                LOCAL_STDERR.with(|slot| {\n-                    *slot.borrow_mut() = s.take();\n-                });\n+    let thread = Thread::current();\n+    let name = thread.name().unwrap_or(\"<unnamed>\");\n+    let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n+    match prev {\n+        Some(mut stderr) => {\n+            // FIXME: what to do when the thread printing panics?\n+            let _ = writeln!(stderr,\n+                             \"thread '{}' panicked at '{}', {}:{}\\n\",\n+                             name, msg, file, line);\n+            if backtrace::log_enabled() {\n+                let _ = backtrace::write(&mut *stderr);\n             }\n-            None => {\n-                let _ = writeln!(&mut err, \"task '{}' panicked at '{}', {}:{}\",\n-                                 n, msg, file, line);\n-                if backtrace::log_enabled() {\n-                    let _ = backtrace::write(&mut err);\n-                }\n+            let mut s = Some(stderr);\n+            LOCAL_STDERR.with(|slot| {\n+                *slot.borrow_mut() = s.take();\n+            });\n+        }\n+        None => {\n+            let _ = writeln!(&mut err, \"thread '{}' panicked at '{}', {}:{}\",\n+                             name, msg, file, line);\n+            if backtrace::log_enabled() {\n+                let _ = backtrace::write(&mut err);\n             }\n         }\n+    }\n \n-        // If this is a double panic, make sure that we printed a backtrace\n-        // for this panic.\n-        if unwinding && !backtrace::log_enabled() {\n-            let _ = backtrace::write(&mut err);\n-        }\n+    // If this is a double panic, make sure that we printed a backtrace\n+    // for this panic.\n+    if thread_info::panicking() && !backtrace::log_enabled() {\n+        let _ = backtrace::write(&mut err);\n     }\n-    Local::borrow(None::<Task>).name = name;\n }"}, {"sha": "d2a9861737d1284260820807ddd85c0cf76ce46c", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -156,12 +156,12 @@ mod test {\n     use prelude::*;\n     use super::*;\n     use io;\n-    use task;\n+    use thread::Thread;\n \n     #[test]\n     fn test_rx_reader() {\n         let (tx, rx) = channel();\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n           tx.send(vec![1u8, 2u8]);\n           tx.send(vec![]);\n           tx.send(vec![3u8, 4u8]);\n@@ -203,7 +203,7 @@ mod test {\n     #[test]\n     fn test_rx_buffer() {\n         let (tx, rx) = channel();\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n           tx.send(b\"he\".to_vec());\n           tx.send(b\"llo wo\".to_vec());\n           tx.send(b\"\".to_vec());\n@@ -229,7 +229,11 @@ mod test {\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n+<<<<<<< HEAD\n         let got = match task::try(move|| { rx.recv() }) {\n+=======\n+        let got = match Thread::with_join(proc() { rx.recv() }).join() {\n+>>>>>>> Fallout from new thread API\n             Ok(got) => got,\n             Err(_) => panic!(),\n         };"}, {"sha": "01eb33b44f92faf4f850a83ef16e5369a4f25c43", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -549,7 +549,7 @@ mod tests {\n                 Err(ref e) if e.kind == TimedOut => {}\n                 Err(e) => panic!(\"error: {}\", e),\n             }\n-            ::task::deschedule();\n+            ::thread::Thread::yield_now();\n             if i == 1000 { panic!(\"should have a pending connection\") }\n         }\n         drop(l);"}, {"sha": "0e9a93e42758c7556e15057257d879aeb795a0f6", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -1155,7 +1155,7 @@ mod test {\n                     Err(ref e) if e.kind == TimedOut => {}\n                     Err(e) => panic!(\"error: {}\", e),\n                 }\n-                ::task::deschedule();\n+                ::thread::Thread::yield_now();\n                 if i == 1000 { panic!(\"should have a pending connection\") }\n             }\n         }\n@@ -1378,7 +1378,7 @@ mod test {\n \n         // Try to ensure that the reading clone is indeed reading\n         for _ in range(0i, 50) {\n-            ::task::deschedule();\n+            ::thread::Thread::yield_now();\n         }\n \n         // clone the handle again while it's reading, then let it finish the"}, {"sha": "d9acb94714b248893a2094851df34428079ce83f", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -30,6 +30,7 @@ use hash::Hash;\n use std::hash::sip::SipState;\n use io::pipe::{PipeStream, PipePair};\n use path::BytesContainer;\n+use thread::Thread;\n \n use sys;\n use sys::fs::FileDesc;\n@@ -693,10 +694,12 @@ impl Process {\n         fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n             match stream {\n-                Some(stream) => spawn(move |:| {\n-                    let mut stream = stream;\n-                    tx.send(stream.read_to_end())\n-                }),\n+                Some(stream) => {\n+                    Thread::spawn(move |:| {\n+                        let mut stream = stream;\n+                        tx.send(stream.read_to_end())\n+                    });\n+                }\n                 None => tx.send(Ok(Vec::new()))\n             }\n             rx"}, {"sha": "32ba6278a8909c68834ecf3f52b86b75eab2fd53", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -41,9 +41,6 @@ use option::Option;\n use option::Option::{Some, None};\n use ops::{Deref, DerefMut, FnOnce};\n use result::Result::{Ok, Err};\n-use rt;\n-use rt::local::Local;\n-use rt::task::Task;\n use slice::SliceExt;\n use str::StrPrelude;\n use string::String;\n@@ -328,25 +325,17 @@ pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n //          // io1 aliases io2\n //      })\n //  })\n-fn with_task_stdout<F>(f: F) where\n-    F: FnOnce(&mut Writer) -> IoResult<()>,\n-{\n-    let result = if Local::exists(None::<Task>) {\n-        let mut my_stdout = LOCAL_STDOUT.with(|slot| {\n-            slot.borrow_mut().take()\n-        }).unwrap_or_else(|| {\n-            box stdout() as Box<Writer + Send>\n-        });\n-        let result = f(&mut *my_stdout);\n-        let mut var = Some(my_stdout);\n-        LOCAL_STDOUT.with(|slot| {\n-            *slot.borrow_mut() = var.take();\n-        });\n-        result\n-    } else {\n-        let mut io = rt::util::Stdout;\n-        f(&mut io as &mut Writer)\n-    };\n+fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) {\n+    let mut my_stdout = LOCAL_STDOUT.with(|slot| {\n+        slot.borrow_mut().take()\n+    }).unwrap_or_else(|| {\n+        box stdout() as Box<Writer + Send>\n+    });\n+    let result = f(&mut *my_stdout);\n+    let mut var = Some(my_stdout);\n+    LOCAL_STDOUT.with(|slot| {\n+        *slot.borrow_mut() = var.take();\n+    });\n     match result {\n         Ok(()) => {}\n         Err(e) => panic!(\"failed printing to stdout: {}\", e),"}, {"sha": "7219fef3732ea14c0b643df1822b6e0508788cbf", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -229,6 +229,8 @@ pub mod hash;\n \n /* Threads and communication */\n \n+pub mod task;\n+#[allow(missing_docs)]\n pub mod thread;\n pub mod sync;\n pub mod comm;"}, {"sha": "0ff41586e72017c02368d8ad36b46543eb6c61d8", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -49,7 +49,7 @@ use ptr::RawPtr;\n use ptr;\n use result::Result;\n use result::Result::{Err, Ok};\n-use slice::{AsSlice, SliceExt, PartialEqSliceExt};\n+use slice::{AsSlice, SliceExt};\n use slice::CloneSliceExt;\n use str::{Str, StrPrelude, StrAllocating};\n use string::{String, ToString};"}, {"sha": "5ab8eb6b9422d2d679b3f654fe4a72163e0a1b07", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -514,20 +514,20 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use task;\n-        let result = task::try(move|| {\n+        use thread::Thread;\n+        let result = Thread::with_join(move|| {\n             Path::new(b\"foo/bar\\0\")\n-        });\n+        }).join();\n         assert!(result.is_err());\n \n-        let result = task::try(move|| {\n+        let result = Thread::with_join(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n-        });\n+        }).join();\n         assert!(result.is_err());\n \n-        let result = task::try(move|| {\n+        let result = Thread::with_join(move|| {\n             Path::new(\"test\").push(b\"f\\0o\");\n-        });\n+        }).join();\n         assert!(result.is_err());\n     }\n "}, {"sha": "171707c10c5da0b8627968571a837665a450ecb1", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -1298,20 +1298,20 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use task;\n-        let result = task::try(move|| {\n+        use thread::Thread;\n+        let result = Thread::with_join(move|| {\n             Path::new(b\"foo/bar\\0\")\n-        });\n+        }).join();\n         assert!(result.is_err());\n \n-        let result = task::try(move|| {\n+        let result = Thread::with_join(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n-        });\n+        }).join();\n         assert!(result.is_err());\n \n-        let result = task::try(move|| {\n+        let result = Thread::with_join(move|| {\n             Path::new(\"test\").push(b\"f\\0o\");\n-        });\n+        }).join();\n         assert!(result.is_err());\n     }\n "}, {"sha": "d2ae66d657809af15c6129a4edcb7449848126d7", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -340,7 +340,7 @@ mod test {\n \n     use super::OsRng;\n     use rand::Rng;\n-    use task;\n+    use thread::Thread;\n \n     #[test]\n     fn test_os_rng() {\n@@ -360,25 +360,26 @@ mod test {\n         for _ in range(0u, 20) {\n             let (tx, rx) = channel();\n             txs.push(tx);\n-            task::spawn(move|| {\n+\n+            Thread::spawn(move|| {\n                 // wait until all the tasks are ready to go.\n                 rx.recv();\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n                 let mut r = OsRng::new().unwrap();\n-                task::deschedule();\n+                Thread::yield_now();\n                 let mut v = [0u8, .. 1000];\n \n                 for _ in range(0u, 100) {\n                     r.next_u32();\n-                    task::deschedule();\n+                    Thread::yield_now();\n                     r.next_u64();\n-                    task::deschedule();\n+                    Thread::yield_now();\n                     r.fill_bytes(&mut v);\n-                    task::deschedule();\n+                    Thread::yield_now();\n                 }\n-            })\n+            });\n         }\n \n         // start all the tasks"}, {"sha": "1b97a01146c4310bf7e6a4d6ac2c8771d9e3e4d5", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -14,7 +14,6 @@\n \n use core::prelude::*;\n \n-use libc;\n use boxed::Box;\n use vec::Vec;\n use sync::{Mutex, atomic, Once, ONCE_INIT};\n@@ -25,31 +24,30 @@ type Queue = Mutex<Vec<Thunk>>;\n \n static INIT: Once = ONCE_INIT;\n static QUEUE: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n-static RUNNING: atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n \n fn init() {\n     let state: Box<Queue> = box Mutex::new(Vec::new());\n     unsafe {\n         QUEUE.store(mem::transmute(state), atomic::SeqCst);\n-        libc::atexit(run);\n+\n+        // FIXME: switch this to use atexit as below. Currently this\n+        // segfaults (the queue's memory is mysteriously gone), so\n+        // instead the cleanup is tied to the `std::rt` entry point.\n+        //\n+        // ::libc::atexit(cleanup);\n     }\n }\n \n-// Note: this is private and so can only be called via atexit above,\n-// which guarantees initialization.\n-extern fn run() {\n-    let cur = unsafe {\n-        rtassert!(!RUNNING.load(atomic::SeqCst));\n+pub fn cleanup() {\n+    unsafe {\n         let queue = QUEUE.swap(0, atomic::SeqCst);\n-        rtassert!(queue != 0);\n-\n-        let queue: Box<Queue> = mem::transmute(queue);\n-        let v = mem::replace(&mut *queue.lock(), Vec::new());\n-        v\n-    };\n-\n-    for to_run in cur.into_iter() {\n-        to_run.invoke(());\n+        if queue != 0 {\n+            let queue: Box<Queue> = mem::transmute(queue);\n+            let v = mem::replace(&mut *queue.lock(), Vec::new());\n+            for to_run in v.into_iter() {\n+                to_run.invoke();\n+            }\n+        }\n     }\n }\n \n@@ -60,7 +58,6 @@ pub fn push(f: Thunk) {\n         // all with respect to `run`, meaning that this could theoretically be a\n         // use-after-free. There's not much we can do to protect against that,\n         // however. Let's just assume a well-behaved runtime and go from there!\n-        rtassert!(!RUNNING.load(atomic::SeqCst));\n         let queue = QUEUE.load(atomic::SeqCst);\n         rtassert!(queue != 0);\n         (*(queue as *const Queue)).lock().push(f);"}, {"sha": "4a692bccf9eea61ab5170ff99f883403e4c3b33d", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -12,12 +12,8 @@\n \n #![allow(non_camel_case_types)]\n \n-use io::{IoResult, Writer};\n-use iter::{Iterator, IteratorExt};\n use option::Option::{Some, None};\n use os;\n-use result::Result::{Ok, Err};\n-use str::{StrPrelude, from_str};\n use sync::atomic;\n \n pub use sys::backtrace::write;"}, {"sha": "022e73121d7f402b910d39081984d322364d62ba", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -48,14 +48,14 @@\n \n #![allow(dead_code)]\n \n-use borrow::IntoCow;\n use failure;\n use os;\n use thunk::Thunk;\n use kinds::Send;\n use thread::Thread;\n+use sys;\n use sys_common;\n-use sys_common::thread::{mod, NewThread};\n+use sys_common::thread_info::{mod, NewThread};\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n@@ -87,10 +87,9 @@ pub const DEFAULT_ERROR_CODE: int = 101;\n /// Initializes global state, including frobbing\n /// the crate's logging flags, registering GC\n /// metadata, and storing the process arguments.\n+// FIXME: this should be unsafe\n #[allow(experimental)]\n pub fn init(argc: int, argv: *const *const u8) {\n-    // FIXME: Derefing these pointers is not safe.\n-    // Need to propagate the unsafety to `start`.\n     unsafe {\n         args::init(argc, argv);\n         thread::init();\n@@ -122,8 +121,6 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     use prelude::*;\n     use rt;\n-    use rt::task::Task;\n-    use str;\n \n     let something_around_the_top_of_the_stack = 1;\n     let addr = &something_around_the_top_of_the_stack as *const int;\n@@ -153,18 +150,19 @@ pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     init(argc, argv);\n     let mut exit_code = None;\n \n-    let thread: std::Thread = NewThread::new(Some(\"<main>\".into_string()));\n+    let thread: Thread = NewThread::new(Some(\"<main>\".into_string()));\n     thread_info::set((my_stack_bottom, my_stack_top),\n                      unsafe { sys::thread::guard::main() },\n                      thread);\n-    unwind::try(|| {\n-        unsafe {\n+    let mut main_opt = Some(main); // option dance\n+    unsafe {\n+        let _ = unwind::try(|| {\n             sys_common::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n-        }\n-        (main.take().unwrap()).invoke(());\n-        exit_code = Some(os::get_exit_status());\n-    });\n-    unsafe { cleanup(); }\n+            (main_opt.take().unwrap()).invoke();\n+            exit_code = Some(os::get_exit_status());\n+        });\n+        cleanup();\n+    }\n     // If the exit code wasn't set, then the task block must have panicked.\n     return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);\n }\n@@ -197,14 +195,6 @@ pub fn at_exit(f: proc():Send) {\n /// undefined behavior.\n pub unsafe fn cleanup() {\n     args::cleanup();\n-    thread::cleanup();\n-}\n-\n-// FIXME: these probably shouldn't be public...\n-#[doc(hidden)]\n-pub mod shouldnt_be_public {\n-    #[cfg(not(test))]\n-    pub use super::local_ptr::native::maybe_tls_key;\n-    #[cfg(all(not(windows), not(target_os = \"android\"), not(target_os = \"ios\")))]\n-    pub use super::local_ptr::compiled::RT_TLS_PTR;\n+    sys::stack_overflow::cleanup();\n+    at_exit_imp::cleanup();\n }"}, {"sha": "f9f76e35bd4a0a3b4d834da468823b5eb65ffcaf", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -565,7 +565,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n \n     // Now that we've run all the necessary unwind callbacks, we actually\n     // perform the unwinding.\n-    if thread_info::unwinding() {\n+    if thread_info::panicking() {\n         // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming"}, {"sha": "86dbb6066f30e1097da87f678c3ba893b1e6c6e2", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -196,8 +196,7 @@ memory and partly incapable of presentation to others.\",\n }\n \n pub unsafe fn report_overflow() {\n-    use rt::task::Task;\n-    use rt::local::Local;\n+    use thread::Thread;\n \n     // See the message below for why this is not emitted to the\n     // ^ Where did the message below go?\n@@ -206,11 +205,6 @@ pub unsafe fn report_overflow() {\n     // call would happen to initialized it (calling out to libuv),\n     // and the FFI call needs 2MB of stack when we just ran out.\n \n-    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-\n-    let name = task.and_then(|task| {\n-        (*task).name.as_ref().map(|n| n.as_slice())\n-    });\n-\n-    rterrln!(\"\\ntask '{}' has overflowed its stack\", name.unwrap_or(\"<unknown>\"));\n+    rterrln!(\"\\nthread '{}' has overflowed its stack\",\n+             Thread::current().name().unwrap_or(\"<unknown>\"));\n }"}, {"sha": "16f2cff599879d4dbff179648cd8d0088c97007b", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -29,8 +29,8 @@ use core::mem::replace;\n \n use self::FutureState::*;\n use comm::{Receiver, channel};\n-use task::spawn;\n use thunk::{Thunk};\n+use thread::Thread;\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n@@ -139,7 +139,7 @@ impl<A:Send> Future<A> {\n \n         let (tx, rx) = channel();\n \n-        spawn(move |:| {\n+        Thread::spawn(move |:| {\n             // Don't panic if the other end has hung up\n             let _ = tx.send_opt(blk());\n         });"}, {"sha": "fc73e2957a55f4d96750fcd6924a2be4002eba98", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -274,7 +274,7 @@ impl Drop for StaticMutexGuard {\n mod test {\n     use prelude::*;\n \n-    use task;\n+    use thread::Thread;\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n \n     #[test]\n@@ -386,10 +386,10 @@ mod test {\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::with_join(move|| {\n             let lock = arc2.lock();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.lock();\n         assert_eq!(*lock, 1);\n     }\n@@ -414,7 +414,7 @@ mod test {\n     fn test_mutex_arc_access_in_unwind() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| -> () {\n+        let _ = Thread::with_join::<()>(move|| -> () {\n             struct Unwinder {\n                 i: Arc<Mutex<int>>,\n             }\n@@ -425,7 +425,7 @@ mod test {\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n-        });\n+        }).join();\n         let lock = arc.lock();\n         assert_eq!(*lock, 2);\n     }"}, {"sha": "a43f822e351db7c85299139080933b51f60423e2", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -121,7 +121,7 @@ impl Once {\n mod test {\n     use prelude::*;\n \n-    use task;\n+    use thread::Thread;\n     use super::{ONCE_INIT, Once};\n \n     #[test]\n@@ -143,7 +143,7 @@ mod test {\n         for _ in range(0u, 10) {\n             let tx = tx.clone();\n             spawn(move|| {\n-                for _ in range(0u, 4) { task::deschedule() }\n+                for _ in range(0u, 4) { Thread::yield_now() }\n                 unsafe {\n                     O.doit(|| {\n                         assert!(!run);"}, {"sha": "ad08e9873faad1ef0393bd3969c6de682e8b6306", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -8,21 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::Option::None;\n-use rustrt::task::Task;\n-use rustrt::local::Local;\n+use thread::Thread;\n \n pub struct Flag { pub failed: bool }\n \n impl Flag {\n     pub fn borrow(&mut self) -> Guard {\n-        Guard { flag: &mut self.failed, failing: failing() }\n+        Guard { flag: &mut self.failed, panicking: Thread::panicking() }\n     }\n }\n \n pub struct Guard<'a> {\n     flag: &'a mut bool,\n-    failing: bool,\n+    panicking: bool,\n }\n \n impl<'a> Guard<'a> {\n@@ -33,16 +31,8 @@ impl<'a> Guard<'a> {\n     }\n \n     pub fn done(&mut self) {\n-        if !self.failing && failing() {\n+        if !self.panicking && Thread::panicking() {\n             *self.flag = true;\n         }\n     }\n }\n-\n-fn failing() -> bool {\n-    if Local::exists(None::<Task>) {\n-        Local::borrow(None::<Task>).unwinder.unwinding()\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "1f1e9eea1d63535fa9349a05cbf9e3b267411a8b", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -356,7 +356,7 @@ mod tests {\n     use prelude::*;\n \n     use rand::{mod, Rng};\n-    use task;\n+    use thread::Thread;\n     use sync::{Arc, RWLock, StaticRWLock, RWLOCK_INIT};\n \n     #[test]\n@@ -409,10 +409,10 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::with_join(move|| {\n             let lock = arc2.write();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.read();\n         assert_eq!(*lock, 1);\n     }\n@@ -422,10 +422,10 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::with_join(move|| {\n             let lock = arc2.write();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.write();\n         assert_eq!(*lock, 1);\n     }\n@@ -434,21 +434,21 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::with_join(move|| {\n             let lock = arc2.read();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.read();\n         assert_eq!(*lock, 1);\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(move|| {\n+        let _ = Thread::with_join(move|| {\n             let lock = arc2.read();\n             assert_eq!(*lock, 2);\n-        });\n+        }).join();\n         let lock = arc.write();\n         assert_eq!(*lock, 1);\n     }\n@@ -459,12 +459,12 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut lock = arc2.write();\n             for _ in range(0u, 10) {\n                 let tmp = *lock;\n                 *lock = -1;\n-                task::deschedule();\n+                Thread::yield_now();\n                 *lock = tmp + 1;\n             }\n             tx.send(());\n@@ -474,15 +474,15 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in range(0u, 5) {\n             let arc3 = arc.clone();\n-            children.push(task::try_future(move|| {\n+            children.push(Thread::with_join(move|| {\n                 let lock = arc3.read();\n                 assert!(*lock >= 0);\n             }));\n         }\n \n         // Wait for children to pass their asserts\n-        for r in children.iter_mut() {\n-            assert!(r.get_ref().is_ok());\n+        for r in children.into_iter() {\n+            assert!(r.join().is_ok());\n         }\n \n         // Wait for writer to finish\n@@ -495,7 +495,11 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n+<<<<<<< HEAD\n         let _ = task::try(move|| -> () {\n+=======\n+        let _ = Thread::with_join::<()>(proc() {\n+>>>>>>> Fallout from new thread API\n             struct Unwinder {\n                 i: Arc<RWLock<int>>,\n             }\n@@ -507,7 +511,7 @@ mod tests {\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n-        });\n+        }).join();\n         let lock = arc.read();\n         assert_eq!(*lock, 2);\n     }"}, {"sha": "5e7944d5fe507741a66aa2a2134406fd4841e669", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -12,7 +12,7 @@\n \n use core::prelude::*;\n \n-use task::{spawn};\n+use thread::Thread;\n use comm::{channel, Sender, Receiver};\n use sync::{Arc, Mutex};\n use thunk::Thunk;\n@@ -105,7 +105,7 @@ impl TaskPool {\n }\n \n fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n-    spawn(move |:| {\n+    Thread::spawn(move |:| {\n         // Will spawn a new task on panic unless it is cancelled.\n         let sentinel = Sentinel::new(&jobs);\n \n@@ -126,7 +126,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n         }\n \n         sentinel.cancel();\n-    })\n+    });\n }\n \n #[cfg(test)]\n@@ -206,4 +206,3 @@ mod test {\n         waiter.wait();\n     }\n }\n-"}, {"sha": "38dc516bf3d8108fb6222351d39cc118648ead1d", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use io::{IoResult, Writer};\n-use iter::Iterator;\n+use iter::{Iterator, IteratorExt};\n use option::{Some, None};\n use result::{Ok, Err};\n use str::{StrPrelude, from_str};"}, {"sha": "8aa09d9bd30201c62b228a0170208c6522c07d68", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -28,7 +28,7 @@ use sync::{StaticMutex, StaticCondvar};\n use rt;\n use sys::helper_signal;\n \n-use task;\n+use thread::Thread;\n \n /// A structure for management of a helper thread.\n ///\n@@ -82,7 +82,11 @@ impl<M: Send> Helper<M> {\n                 *self.signal.get() = send as uint;\n \n                 let t = f();\n+<<<<<<< HEAD\n                 task::spawn(move |:| {\n+=======\n+                Thread::spawn(proc() {\n+>>>>>>> Fallout from new thread API\n                     helper(receive, rx, t);\n                     let _g = self.lock.lock();\n                     *self.shutdown.get() = true;"}, {"sha": "dc0ad08cdbef637100a7f8477897af5643ddcedf", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -27,6 +27,7 @@ pub mod net;\n pub mod rwlock;\n pub mod stack;\n pub mod thread;\n+pub mod thread_info;\n pub mod thread_local;\n \n // common error constructors"}, {"sha": "0612448cfa01ae43a276c0b1bef56411045b639e", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -33,11 +33,11 @@ impl ThreadInfo {\n                 *c.borrow_mut() = Some(ThreadInfo {\n                     stack_bounds: (0, 0),\n                     stack_guard: 0,\n-                    unwinder: false,\n-                    thread: Thread::new(None),\n+                    unwinding: false,\n+                    thread: NewThread::new(None),\n                 })\n             }\n-            f(c.borrow_mut().as_ref().unwrap())\n+            f(c.borrow_mut().as_mut().unwrap())\n         })\n     }\n }\n@@ -47,28 +47,25 @@ pub fn current_thread() -> Thread {\n }\n \n pub fn panicking() -> bool {\n-    ThreadInfo::with(|info| info.unwinder.unwinding())\n+    ThreadInfo::with(|info| info.unwinding)\n }\n \n pub fn stack_guard() -> uint {\n     ThreadInfo::with(|info| info.stack_guard)\n }\n \n-pub fn unwinding() -> bool {\n-    ThreadInfo::with(|info| info.unwinder.unwinding)\n-}\n-\n pub fn set_unwinding(unwinding: bool) {\n     ThreadInfo::with(|info| info.unwinding = unwinding)\n }\n \n pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n+    let mut thread_opt = Some(thread); // option dance\n     THREAD_INFO.with(|c| *c.borrow_mut() = Some(ThreadInfo{\n         stack_bounds: stack_bounds,\n         stack_guard: stack_guard,\n         unwinding: false,\n-        thread: thread,\n+        thread: thread_opt.take().unwrap(),\n     }));\n }\n "}, {"sha": "fe7a7d8d0371688540bd19b327340f7a5b268afe", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -58,7 +58,6 @@\n \n use prelude::*;\n \n-use rt;\n use sync::atomic::{mod, AtomicUint};\n use sync::{Mutex, Once, ONCE_INIT};\n "}, {"sha": "5256e2cc809e4a51ce9020da2b129323f9f2cd46", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -141,7 +141,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n \n     struct Context<'a> {\n         idx: int,\n-        writer: &'a mut Writer+'a,\n+        writer: &'a mut (Writer+'a),\n         last_error: Option<IoError>,\n     }\n "}, {"sha": "340f95142419c043936b30e2569b6b57e710061a", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -45,8 +45,6 @@ mod imp {\n     use self::signal::{siginfo, sigaction, SIGBUS, SIG_DFL,\n                        SA_SIGINFO, SA_ONSTACK, sigaltstack,\n                        SIGSTKSZ};\n-    use rt::local::Local;\n-    use rt::task::Task;\n     use libc;\n     use libc::funcs::posix88::mman::{mmap, munmap};\n     use libc::consts::os::posix88::{SIGSEGV,\n@@ -56,20 +54,12 @@ mod imp {\n                                     MAP_ANON,\n                                     MAP_FAILED};\n \n+    use sys_common::thread_info;\n+\n \n     // This is initialized in init() and only read from after\n     static mut PAGE_SIZE: uint = 0;\n \n-    // get_task_info is called from an exception / signal handler.\n-    // It returns the guard page of the current task or 0 if that\n-    // guard page doesn't exist. None is returned if there's currently\n-    // no local task.\n-    unsafe fn get_task_guard_page() -> Option<uint> {\n-        let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-        task.map(|task| (&*task).stack_guard().unwrap_or(0))\n-    }\n-\n-\n     #[no_stack_check]\n     unsafe extern fn signal_handler(signum: libc::c_int,\n                                      info: *mut siginfo,\n@@ -89,20 +79,16 @@ mod imp {\n         // We're calling into functions with stack checks\n         stack::record_sp_limit(0);\n \n-        match get_task_guard_page() {\n-            Some(guard) => {\n-                let addr = (*info).si_addr as uint;\n+        let guard = thread_info::stack_guard();\n+        let addr = (*info).si_addr as uint;\n \n-                if guard == 0 || addr < guard - PAGE_SIZE || addr >= guard {\n-                    term(signum);\n-                }\n+        if guard == 0 || addr < guard - PAGE_SIZE || addr >= guard {\n+            term(signum);\n+        }\n \n-                report_overflow();\n+        report_overflow();\n \n-                intrinsics::abort()\n-            }\n-            None => term(signum)\n-        }\n+        intrinsics::abort()\n     }\n \n     static mut MAIN_ALTSTACK: *mut libc::c_void = 0 as *mut libc::c_void;"}, {"sha": "63b5b6f58637851eb78955fca417a7a2aeef1182", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rt::local::Local;\n-use rt::task::Task;\n use rt::util::report_overflow;\n use core::prelude::*;\n use ptr;\n use mem;\n use libc;\n use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n-use sys_common::stack;\n+use sys_common::{stack, thread_info};\n \n pub struct Handler {\n     _data: *mut libc::c_void\n@@ -37,8 +35,7 @@ impl Drop for Handler {\n // guard page doesn't exist. None is returned if there's currently\n // no local task.\n unsafe fn get_task_guard_page() -> Option<uint> {\n-    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-    task.map(|task| (&*task).stack_guard().unwrap_or(0))\n+    thread_info::stack_guard()\n }\n \n // This is initialized in init() and only read from after"}, {"sha": "13395fc9c7637d5e6c9421f4eea7df1bcc9047cf", "filename": "src/libstd/task.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -12,8 +12,11 @@\n \n #![deprecated = \"use std::thread instead\"]\n \n+use any::Any;\n+use boxed::Box;\n use thread;\n use kinds::Send;\n+use result::Result;\n \n /// Deprecate: use `std::thread::Cfg` instead.\n #[deprecated = \"use std::thread::Cfg instead\"]\n@@ -24,3 +27,15 @@ pub type TaskBuilder = thread::Cfg;\n pub fn spawn(f: proc(): Send) {\n     thread::Thread::spawn(f);\n }\n+\n+/// Deprecated: use `std::thread::Thread::with_join instead`.\n+#[deprecated = \"use std::thread::Thread::with_join instead\"]\n+pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n+    thread::Thread::with_join(f).join()\n+}\n+\n+/// Deprecated: use `std::thread::Thread::yield_now instead`.\n+#[deprecated = \"use std::thread::Thread::yield_now instead\"]\n+pub fn deschedule() {\n+    thread::Thread::yield_now()\n+}"}, {"sha": "f179219884f8becc14ad04f3cf8bb3897728182a", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -231,7 +231,7 @@ impl Cfg {\n             }\n             thread_info::set(\n                 (my_stack_bottom, my_stack_top),\n-                thread::current_guard_page(),\n+                unsafe { imp::guard::current() },\n                 their_thread\n             );\n \n@@ -261,7 +261,7 @@ impl Cfg {\n                 }\n             }\n         };\n-        (unsafe { imp::create(stack, box main) }, my_thread)\n+        (unsafe { imp::create(stack_size, box main) }, my_thread)\n     }\n \n     /// Spawn a detached thread, and return a handle to it.\n@@ -278,19 +278,20 @@ impl Cfg {\n         // We need the address of the packet to fill in to be stable so when\n         // `main` fills it in it's still valid, so allocate an extra box to do\n         // so.\n-        let my_packet = box Err(box 0); // sentinel value\n+        let any: Box<Any+Send> = box 0u8; // sentinel value\n+        let my_packet = box Err(any);\n         let their_packet: *mut Result<T> = unsafe {\n             *mem::transmute::<&Box<Result<T>>, *const *mut Result<T>>(&my_packet)\n         };\n \n         let (native, thread) = self.core_spawn(f, proc(result) {\n-            *their_packet = result;\n+            unsafe { *their_packet = result; }\n         });\n \n         JoinGuard {\n             native: native,\n             joined: false,\n-            packet: my_packet,\n+            packet: Some(my_packet),\n             thread: thread,\n         }\n     }\n@@ -336,7 +337,7 @@ impl Thread {\n \n     /// Gets a handle to the thread that invokes it.\n     pub fn current() -> Thread {\n-        ThreadInfo::current_thread()\n+        thread_info::current_thread()\n     }\n \n     /// Cooperatively give up a timeslice to the OS scheduler.\n@@ -346,7 +347,7 @@ impl Thread {\n \n     /// Determines whether the current thread is panicking.\n     pub fn panicking() -> bool {\n-        ThreadInfo::panicking()\n+        thread_info::panicking()\n     }\n \n     // http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n@@ -355,9 +356,9 @@ impl Thread {\n     /// See the module doc for more detail.\n     pub fn park() {\n         let thread = Thread::current();\n-        let guard = thread.inner.lock.lock();\n+        let mut guard = thread.inner.lock.lock();\n         while !*guard {\n-            thread.inner.cvar.wait(guard);\n+            thread.inner.cvar.wait(&guard);\n         }\n         *guard = false;\n     }\n@@ -366,7 +367,7 @@ impl Thread {\n     ///\n     /// See the module doc for more detail.\n     pub fn unpark(&self) {\n-        let guard = self.inner.lock();\n+        let mut guard = self.inner.lock.lock();\n         if !*guard {\n             *guard = true;\n             self.inner.cvar.notify_one();\n@@ -375,7 +376,7 @@ impl Thread {\n \n     /// Get the thread's name.\n     pub fn name(&self) -> Option<&str> {\n-        self.inner.name.as_ref()\n+        self.inner.name.as_ref().map(|s| s.as_slice())\n     }\n }\n \n@@ -387,15 +388,15 @@ impl thread_info::NewThread for Thread {\n /// Indicates the manner in which a thread exited.\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n-pub type Result<T> = result::Result<T, Box<Any + Send>>;\n+pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n \n #[must_use]\n /// An RAII guard that will block until thread termination when dropped.\n pub struct JoinGuard<T> {\n     native: imp::rust_thread,\n     thread: Thread,\n     joined: bool,\n-    packet: Box<Result<T>>,\n+    packet: Option<Box<Result<T>>>,\n }\n \n impl<T: Send> JoinGuard<T> {"}, {"sha": "e2cedae1be6374e0d9a09eb1b85d7f2f488f9fb7", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -446,7 +446,7 @@ mod tests {\n     use prelude::*;\n \n     use cell::UnsafeCell;\n-    use rt::thread::Thread;\n+    use thread::Thread;\n \n     struct Foo(Sender<()>);\n \n@@ -534,7 +534,7 @@ mod tests {\n             }\n         }\n \n-        Thread::start(move|| {\n+        Thread::with_join(move|| {\n             drop(S1);\n         }).join();\n     }\n@@ -552,7 +552,7 @@ mod tests {\n             }\n         }\n \n-        Thread::start(move|| unsafe {\n+        Thread::with_join(move|| unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n         }).join();\n     }"}, {"sha": "044a4a173c69204207c08a6eba521f6f3ccbcbb9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -69,7 +69,7 @@ use std::num::{Float, FloatMath, Int};\n use std::os;\n use std::str::FromStr;\n use std::string::String;\n-use std::task::TaskBuilder;\n+use std::thread::{mod, Thread};\n use std::time::Duration;\n use std::thunk::{Thunk, Invoke};\n \n@@ -1121,28 +1121,27 @@ pub fn run_test(opts: &TestOpts,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n                       testfn: Thunk) {\n-        spawn(move || {\n+        Thread::spawn(move || {\n             let (tx, rx) = channel();\n             let mut reader = ChanReader::new(rx);\n             let stdout = ChanWriter::new(tx.clone());\n             let stderr = ChanWriter::new(tx);\n-            let mut task = TaskBuilder::new().named(match desc.name {\n+            let mut cfg = thread::cfg().name(match desc.name {\n                 DynTestName(ref name) => name.clone().to_string(),\n                 StaticTestName(name) => name.to_string(),\n             });\n             if nocapture {\n                 drop((stdout, stderr));\n             } else {\n-                task = task.stdout(box stdout as Box<Writer + Send>);\n-                task = task.stderr(box stderr as Box<Writer + Send>);\n+                cfg = cfg.stdout(box stdout as Box<Writer + Send>);\n+                cfg = cfg.stderr(box stderr as Box<Writer + Send>);\n             }\n-            let result_future = task.try_future(move || testfn.invoke(()));\n \n+            let result_guard = cfg.with_join(testfn);\n             let stdout = reader.read_to_end().unwrap().into_iter().collect();\n-            let task_result = result_future.into_inner();\n-            let test_result = calc_result(&desc, task_result);\n+            let test_result = calc_result(&desc, result_guard.join());\n             monitor_ch.send((desc.clone(), test_result, stdout));\n-        })\n+        });\n     }\n \n     match testfn {"}, {"sha": "b5acb55d4a1714e0ae70d29742e3343977616a99", "filename": "src/test/run-pass/cleanup-rvalue-temp-during-incomplete-alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -24,7 +24,7 @@\n // It's unclear how likely such a bug is to recur, but it seems like a\n // scenario worth testing.\n \n-use std::task;\n+use std::thread::Thread;\n \n enum Conzabble {\n     Bickwick(Foo)\n@@ -45,5 +45,5 @@ pub fn fails() {\n }\n \n pub fn main() {\n-    task::try(fails);\n+    Thread::with_join(fails).join();\n }"}, {"sha": "8b54de6b80553ac966559ffc13e4ffc71e45c374", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae4b3301cc0605839778ecf59effb32b752e33/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=43ae4b3301cc0605839778ecf59effb32b752e33", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use std::io::{ChanReader, ChanWriter};\n-use std::task::TaskBuilder;\n+use std::thread;\n \n fn main() {\n     let (tx, rx) = channel();\n     let mut reader = ChanReader::new(rx);\n     let stderr = ChanWriter::new(tx);\n \n-    let res = TaskBuilder::new().stderr(box stderr as Box<Writer + Send>).try(move|| -> () {\n+    let res = thread::cfg().stderr(box stderr as Box<Writer + Send>).with_join(move|| -> () {\n         panic!(\"Hello, world!\")\n-    });\n+    }).join();\n     assert!(res.is_err());\n \n     let output = reader.read_to_string().unwrap();"}]}