{"sha": "272f6dfd9eceb171b23200601201f3df95aa66c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MmY2ZGZkOWVjZWIxNzFiMjMyMDA2MDEyMDFmM2RmOTVhYTY2Yzk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-16T13:31:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-16T13:31:34Z"}, "message": "Micro-optimize type hints to avoid allocations", "tree": {"sha": "dfb27036b4cbb872b62b764d4c60c3aee60b1b6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfb27036b4cbb872b62b764d4c60c3aee60b1b6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/272f6dfd9eceb171b23200601201f3df95aa66c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/272f6dfd9eceb171b23200601201f3df95aa66c9", "html_url": "https://github.com/rust-lang/rust/commit/272f6dfd9eceb171b23200601201f3df95aa66c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/272f6dfd9eceb171b23200601201f3df95aa66c9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd96d0b258437cbfcaba5d0a6a79813eaa5f29fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd96d0b258437cbfcaba5d0a6a79813eaa5f29fe", "html_url": "https://github.com/rust-lang/rust/commit/bd96d0b258437cbfcaba5d0a6a79813eaa5f29fe"}], "stats": {"total": 77, "additions": 38, "deletions": 39}, "files": [{"sha": "1b631c7cd88a13d1b0e18024bae85c92af302bd6", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/272f6dfd9eceb171b23200601201f3df95aa66c9/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272f6dfd9eceb171b23200601201f3df95aa66c9/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=272f6dfd9eceb171b23200601201f3df95aa66c9", "patch": "@@ -30,19 +30,20 @@ pub(crate) fn inlay_hints(\n     max_inlay_hint_length: Option<usize>,\n ) -> Vec<InlayHint> {\n     let mut sb = SourceBinder::new(db);\n-    file.syntax()\n-        .descendants()\n-        .flat_map(|node| get_inlay_hints(&mut sb, file_id, &node, max_inlay_hint_length))\n-        .flatten()\n-        .collect()\n+    let mut res = Vec::new();\n+    for node in file.syntax().descendants() {\n+        get_inlay_hints(&mut res, &mut sb, file_id, &node, max_inlay_hint_length);\n+    }\n+    res\n }\n \n fn get_inlay_hints(\n+    acc: &mut Vec<InlayHint>,\n     sb: &mut SourceBinder<RootDatabase>,\n     file_id: FileId,\n     node: &SyntaxNode,\n     max_inlay_hint_length: Option<usize>,\n-) -> Option<Vec<InlayHint>> {\n+) -> Option<()> {\n     let _p = profile(\"get_inlay_hints\");\n     let db = sb.db;\n     let analyzer = Lazy::new(move || sb.analyze(hir::InFile::new(file_id.into(), node), None));\n@@ -53,62 +54,58 @@ fn get_inlay_hints(\n                     return None;\n                 }\n                 let pat = it.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, false, max_inlay_hint_length))\n+                get_pat_type_hints(acc, db, &analyzer, pat, false, max_inlay_hint_length);\n             },\n             ast::LambdaExpr(it) => {\n                 it.param_list().map(|param_list| {\n                     param_list\n                         .params()\n                         .filter(|closure_param| closure_param.ascribed_type().is_none())\n                         .filter_map(|closure_param| closure_param.pat())\n-                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, false, max_inlay_hint_length))\n-                        .flatten()\n-                        .collect()\n-                })\n+                        .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, false, max_inlay_hint_length))\n+                });\n             },\n             ast::ForExpr(it) => {\n                 let pat = it.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, false, max_inlay_hint_length))\n+                get_pat_type_hints(acc, db, &analyzer, pat, false, max_inlay_hint_length);\n             },\n             ast::IfExpr(it) => {\n                 let pat = it.condition()?.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, true, max_inlay_hint_length))\n+                get_pat_type_hints(acc, db, &analyzer, pat, true, max_inlay_hint_length);\n             },\n             ast::WhileExpr(it) => {\n                 let pat = it.condition()?.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, true, max_inlay_hint_length))\n+                get_pat_type_hints(acc, db, &analyzer, pat, true, max_inlay_hint_length);\n             },\n             ast::MatchArmList(it) => {\n-                Some(\n-                    it\n-                        .arms()\n-                        .map(|match_arm| match_arm.pats())\n-                        .flatten()\n-                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, true, max_inlay_hint_length))\n-                        .flatten()\n-                        .collect(),\n-                )\n+                it.arms()\n+                    .map(|match_arm| match_arm.pats())\n+                    .flatten()\n+                    .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, true, max_inlay_hint_length));\n             },\n             ast::CallExpr(it) => {\n-                get_param_name_hints(db, &analyzer, ast::Expr::from(it))\n+                get_param_name_hints(acc, db, &analyzer, ast::Expr::from(it));\n             },\n             ast::MethodCallExpr(it) => {\n-                get_param_name_hints(db, &analyzer, ast::Expr::from(it))\n+                get_param_name_hints(acc, db, &analyzer, ast::Expr::from(it));\n             },\n-            _ => None,\n+            _ => (),\n         }\n-    }\n+    };\n+    Some(())\n }\n+\n fn get_param_name_hints(\n+    acc: &mut Vec<InlayHint>,\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n     expr: ast::Expr,\n-) -> Option<Vec<InlayHint>> {\n+) -> Option<()> {\n     let args = match &expr {\n-        ast::Expr::CallExpr(expr) => Some(expr.arg_list()?.args()),\n-        ast::Expr::MethodCallExpr(expr) => Some(expr.arg_list()?.args()),\n-        _ => None,\n-    }?;\n+        ast::Expr::CallExpr(expr) => expr.arg_list()?.args(),\n+        ast::Expr::MethodCallExpr(expr) => expr.arg_list()?.args(),\n+        _ => return None,\n+    };\n \n     let mut parameters = get_fn_signature(db, analyzer, &expr)?.parameter_names.into_iter();\n \n@@ -129,10 +126,10 @@ fn get_param_name_hints(\n             range,\n             kind: InlayKind::ParameterHint,\n             label: param_name.into(),\n-        })\n-        .collect();\n+        });\n \n-    Some(hints)\n+    acc.extend(hints);\n+    Some(())\n }\n \n fn get_fn_signature(\n@@ -164,15 +161,16 @@ fn get_fn_signature(\n }\n \n fn get_pat_type_hints(\n+    acc: &mut Vec<InlayHint>,\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n     root_pat: ast::Pat,\n     skip_root_pat_hint: bool,\n     max_inlay_hint_length: Option<usize>,\n-) -> Vec<InlayHint> {\n+) {\n     let original_pat = &root_pat.clone();\n \n-    get_leaf_pats(root_pat)\n+    let hints = get_leaf_pats(root_pat)\n         .into_iter()\n         .filter(|pat| !skip_root_pat_hint || pat != original_pat)\n         .filter_map(|pat| {\n@@ -186,8 +184,9 @@ fn get_pat_type_hints(\n             range,\n             kind: InlayKind::TypeHint,\n             label: pat_type.display_truncated(db, max_inlay_hint_length).to_string().into(),\n-        })\n-        .collect()\n+        });\n+\n+    acc.extend(hints);\n }\n \n fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {"}]}