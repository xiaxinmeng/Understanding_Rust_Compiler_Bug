{"sha": "ec7b753ea91d8a5640388ea74fd231f91394ee9d", "node_id": "C_kwDOAAsO6NoAKGVjN2I3NTNlYTkxZDhhNTY0MDM4OGVhNzRmZDIzMWY5MTM5NGVlOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-03T07:53:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-03T07:53:10Z"}, "message": "Auto merge of #85321 - cjgillot:mir-cycle, r=bjorn3\n\nUse DefPathHash instead of HirId to break inlining cycles.\n\nThe `DefPathHash` is stable across incremental compilation sessions, so provides a total order on `LocalDefId`. Using it instead of `HirId` ensures the MIR inliner has the same behaviour for incremental and non-incremental compilation.\n\nA downside is that the cycle tie break is not as predictable is with `HirId`.", "tree": {"sha": "f8623ef2d0b8ffe7471986f94057c91d25d8ffb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8623ef2d0b8ffe7471986f94057c91d25d8ffb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec7b753ea91d8a5640388ea74fd231f91394ee9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7b753ea91d8a5640388ea74fd231f91394ee9d", "html_url": "https://github.com/rust-lang/rust/commit/ec7b753ea91d8a5640388ea74fd231f91394ee9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec7b753ea91d8a5640388ea74fd231f91394ee9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "133859d680ffe31072b80f518377fa0c487359d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/133859d680ffe31072b80f518377fa0c487359d9", "html_url": "https://github.com/rust-lang/rust/commit/133859d680ffe31072b80f518377fa0c487359d9"}, {"sha": "297dde9b1ad0c28922fac5046f77c2629cebf662", "url": "https://api.github.com/repos/rust-lang/rust/commits/297dde9b1ad0c28922fac5046f77c2629cebf662", "html_url": "https://github.com/rust-lang/rust/commit/297dde9b1ad0c28922fac5046f77c2629cebf662"}], "stats": {"total": 29, "additions": 12, "deletions": 17}, "files": [{"sha": "2f0673b9a76b2d78a1bb247d7b0f566ea41ff97e", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ec7b753ea91d8a5640388ea74fd231f91394ee9d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7b753ea91d8a5640388ea74fd231f91394ee9d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=ec7b753ea91d8a5640388ea74fd231f91394ee9d", "patch": "@@ -1,7 +1,6 @@\n //! Inlining pass for MIR functions\n \n use rustc_attr::InlineAttr;\n-use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -88,7 +87,6 @@ fn inline<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) -> bool {\n         tcx,\n         param_env,\n         codegen_fn_attrs: tcx.codegen_fn_attrs(def_id),\n-        hir_id,\n         history: Vec::new(),\n         changed: false,\n     };\n@@ -102,8 +100,6 @@ struct Inliner<'tcx> {\n     param_env: ParamEnv<'tcx>,\n     /// Caller codegen attributes.\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n-    /// Caller HirID.\n-    hir_id: hir::HirId,\n     /// Stack of inlined Instances.\n     history: Vec<ty::Instance<'tcx>>,\n     /// Indicates that the caller body has been modified.\n@@ -179,7 +175,9 @@ impl<'tcx> Inliner<'tcx> {\n         caller_body: &Body<'tcx>,\n         callee: &Instance<'tcx>,\n     ) -> Result<(), &'static str> {\n-        if callee.def_id() == caller_body.source.def_id() {\n+        let caller_def_id = caller_body.source.def_id();\n+        let callee_def_id = callee.def_id();\n+        if callee_def_id == caller_def_id {\n             return Err(\"self-recursion\");\n         }\n \n@@ -188,7 +186,7 @@ impl<'tcx> Inliner<'tcx> {\n                 // If there is no MIR available (either because it was not in metadata or\n                 // because it has no MIR because it's an extern function), then the inliner\n                 // won't cause cycles on this.\n-                if !self.tcx.is_mir_available(callee.def_id()) {\n+                if !self.tcx.is_mir_available(callee_def_id) {\n                     return Err(\"item MIR unavailable\");\n                 }\n             }\n@@ -208,29 +206,26 @@ impl<'tcx> Inliner<'tcx> {\n             | InstanceDef::CloneShim(..) => return Ok(()),\n         }\n \n-        if self.tcx.is_constructor(callee.def_id()) {\n+        if self.tcx.is_constructor(callee_def_id) {\n             trace!(\"constructors always have MIR\");\n             // Constructor functions cannot cause a query cycle.\n             return Ok(());\n         }\n \n-        if let Some(callee_def_id) = callee.def_id().as_local() {\n-            let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n+        if callee_def_id.is_local() {\n             // Avoid a cycle here by only using `instance_mir` only if we have\n-            // a lower `HirId` than the callee. This ensures that the callee will\n-            // not inline us. This trick only works without incremental compilation.\n-            // So don't do it if that is enabled.\n-            if !self.tcx.dep_graph.is_fully_enabled() && self.hir_id.index() < callee_hir_id.index()\n+            // a lower `DefPathHash` than the callee. This ensures that the callee will\n+            // not inline us. This trick even works with incremental compilation,\n+            // since `DefPathHash` is stable.\n+            if self.tcx.def_path_hash(caller_def_id).local_hash()\n+                < self.tcx.def_path_hash(callee_def_id).local_hash()\n             {\n                 return Ok(());\n             }\n \n             // If we know for sure that the function we're calling will itself try to\n             // call us, then we avoid inlining that function.\n-            if self\n-                .tcx\n-                .mir_callgraph_reachable((*callee, caller_body.source.def_id().expect_local()))\n-            {\n+            if self.tcx.mir_callgraph_reachable((*callee, caller_def_id.expect_local())) {\n                 return Err(\"caller might be reachable from callee (query cycle avoidance)\");\n             }\n "}]}