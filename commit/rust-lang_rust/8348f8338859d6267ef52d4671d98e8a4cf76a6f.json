{"sha": "8348f8338859d6267ef52d4671d98e8a4cf76a6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNDhmODMzODg1OWQ2MjY3ZWY1MmQ0NjcxZDk4ZThhNGNmNzZhNmY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-24T17:25:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-24T17:25:43Z"}, "message": "Rollup merge of #57606 - oli-obk:shrink, r=RalfJung\n\nGet rid of the fake stack frame for reading from constants\n\nr? @RalfJung\n\nfixes the ice in https://github.com/rust-lang/rust/issues/53708 but still keeps around the wrong \"non-exhaustive match\" error\n\ncc @varkor", "tree": {"sha": "574e6aefcb53ce36c09113f32437c1df83ead679", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/574e6aefcb53ce36c09113f32437c1df83ead679"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8348f8338859d6267ef52d4671d98e8a4cf76a6f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcSfUXCRBK7hj4Ov3rIwAAdHIIAHkpPaM1HnmwUAO15/uCQwTv\nTMlqgNjA69mTTKkmTM1r9VZKEBPxWJuLIumEZ8wLvlXYmh3wBG4+B+AAsKrSy/7i\nfeUtFOmjsIxi8oflYF9awvye6Iq/dglhmiWNaBFnEsRMZ16iNTqqT0XAyVwgP48W\n3xzgIQ7ARZCqzAbxr81IHgj3t8XQ0nLu/b+Ok5QsP6xKIO+3pvPXRT4xP7rjUqR0\n8JuxZ6Joa7OIHv3ZND0FCJcpqsdfZFSyaxPszbDyxQSjchziTD8v1mA/wKVmvdzG\n6t3xyfOZie9k5KJuLVFu95LIhNWS45SztOWEqDTHTdIq6FITtLnHJcj2Dh6nJaU=\n=gbI7\n-----END PGP SIGNATURE-----\n", "payload": "tree 574e6aefcb53ce36c09113f32437c1df83ead679\nparent d130e41423771a592300e7b08d981c58e6eacbc0\nparent d4ee556126edb0d22b8774a4d85a842c443adf60\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1548350743 +0100\ncommitter GitHub <noreply@github.com> 1548350743 +0100\n\nRollup merge of #57606 - oli-obk:shrink, r=RalfJung\n\nGet rid of the fake stack frame for reading from constants\n\nr? @RalfJung\n\nfixes the ice in https://github.com/rust-lang/rust/issues/53708 but still keeps around the wrong \"non-exhaustive match\" error\n\ncc @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8348f8338859d6267ef52d4671d98e8a4cf76a6f", "html_url": "https://github.com/rust-lang/rust/commit/8348f8338859d6267ef52d4671d98e8a4cf76a6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8348f8338859d6267ef52d4671d98e8a4cf76a6f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d130e41423771a592300e7b08d981c58e6eacbc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d130e41423771a592300e7b08d981c58e6eacbc0", "html_url": "https://github.com/rust-lang/rust/commit/d130e41423771a592300e7b08d981c58e6eacbc0"}, {"sha": "d4ee556126edb0d22b8774a4d85a842c443adf60", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ee556126edb0d22b8774a4d85a842c443adf60", "html_url": "https://github.com/rust-lang/rust/commit/d4ee556126edb0d22b8774a4d85a842c443adf60"}], "stats": {"total": 196, "additions": 93, "deletions": 103}, "files": [{"sha": "56d4342e6e1618094c8f74575996db1f38002339", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -59,7 +59,6 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let field = const_field(\n                         bx.tcx(),\n                         ty::ParamEnv::reveal_all(),\n-                        self.instance,\n                         None,\n                         mir::Field::new(field as usize),\n                         c,"}, {"sha": "45c6c1b42496a052038d0758575bb509b2365c5c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 13, "deletions": 67, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -10,11 +10,10 @@ use rustc::hir::{self, def_id::DefId};\n use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, Instance, query::TyCtxtAt};\n+use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n-use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::ErrorReported;\n \n@@ -35,72 +34,20 @@ const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n /// Should be a power of two for performance reasons.\n const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n \n-/// Warning: do not use this function if you expect to start interpreting the given `Mir`.\n-/// The `EvalContext` is only meant to be used to query values from constants and statics.\n-///\n-/// This function is used during const propagation. We cannot use `mk_eval_cx`, because copy\n-/// propagation happens *during* the computation of the MIR of the current function. So if we\n-/// tried to call the `optimized_mir` query, we'd get a cycle error because we are (transitively)\n-/// inside the `optimized_mir` query of the `Instance` given.\n-///\n-/// Since we are looking at the MIR of the function in an abstract manner, we don't have a\n-/// `ParamEnv` available to us. This function creates a `ParamEnv` for the given instance.\n-pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n-    mir: &'mir mir::Mir<'tcx>,\n-    span: Span,\n-) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n-    debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n-    let param_env = tcx.param_env(instance.def_id());\n-    mk_eval_cx_inner(tcx, instance, mir, span, param_env)\n-}\n-\n-/// This is just a helper function to reduce code duplication between `mk_borrowck_eval_cx` and\n-/// `mk_eval_cx`. Do not call this function directly.\n-fn mk_eval_cx_inner<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n-    mir: &'mir mir::Mir<'tcx>,\n-    span: Span,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n-    // Insert a stack frame so any queries have the correct substs.\n-    // We also avoid all the extra work performed by push_stack_frame,\n-    // like initializing local variables\n-    ecx.stack.push(interpret::Frame {\n-        block: mir::START_BLOCK,\n-        locals: IndexVec::new(),\n-        local_layouts: IndexVec::new(),\n-        instance,\n-        span,\n-        mir,\n-        return_place: None,\n-        return_to_block: StackPopCleanup::Goto(None), // never pop\n-        stmt: 0,\n-        extra: (),\n-    });\n-    Ok(ecx)\n-}\n-\n-/// Warning: do not use this function if you expect to start interpreting the given `Mir`.\n /// The `EvalContext` is only meant to be used to do field and index projections into constants for\n /// `simd_shuffle` and const patterns in match arms.\n ///\n /// The function containing the `match` that is currently being analyzed may have generic bounds\n /// that inform us about the generic bounds of the constant. E.g. using an associated constant\n /// of a function's generic parameter will require knowledge about the bounds on the generic\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-fn mk_eval_cx<'a, 'tcx>(\n+pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n+    span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'tcx, 'tcx>> {\n-    debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n-    let span = tcx.def_span(instance.def_id());\n-    let mir = tcx.optimized_mir(instance.def.def_id());\n-    mk_eval_cx_inner(tcx, instance, mir, span, param_env)\n+) -> CompileTimeEvalContext<'a, 'mir, 'tcx> {\n+    debug!(\"mk_eval_cx: {:?}\", param_env);\n+    EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n }\n \n pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n@@ -109,7 +56,8 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n-    let mut ecx = mk_borrowck_eval_cx(tcx, cid.instance, mir, DUMMY_SP).unwrap();\n+    let span = tcx.def_span(cid.instance.def_id());\n+    let mut ecx = mk_eval_cx(tcx, span, param_env);\n     eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n }\n \n@@ -530,13 +478,12 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    instance: ty::Instance<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n     value: ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    trace!(\"const_field: {:?}, {:?}, {:?}\", instance, field, value);\n-    let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    trace!(\"const_field: {:?}, {:?}\", field, value);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let result = (|| {\n         // get the operand again\n         let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(value), value.ty)?;\n@@ -561,11 +508,10 @@ pub fn const_field<'a, 'tcx>(\n pub fn const_variant_index<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    instance: ty::Instance<'tcx>,\n     val: ty::Const<'tcx>,\n ) -> EvalResult<'tcx, VariantIdx> {\n-    trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n-    let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    trace!(\"const_variant_index: {:?}\", val);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(val), val.ty)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n@@ -585,7 +531,7 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     let cid = key.value;\n-    let ecx = mk_eval_cx(tcx, cid.instance, key.param_env).unwrap();\n+    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env);\n     let val = (|| {\n         let op = ecx.raw_const_to_mplace(constant)?.into();\n         // FIXME: Once the visitor infrastructure landed, change validation to"}, {"sha": "9cc5c93de41d8e3f9c4f1091ccdfed769a6a6b5c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -427,13 +427,24 @@ pub enum Constructor<'tcx> {\n }\n \n impl<'tcx> Constructor<'tcx> {\n-    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n+    fn variant_index_for_adt<'a>(\n+        &self,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        adt: &'tcx ty::AdtDef,\n+    ) -> VariantIdx {\n         match self {\n             &Variant(vid) => adt.variant_index_with_id(vid),\n             &Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n+            &ConstantValue(c) => {\n+                ::const_eval::const_variant_index(\n+                    cx.tcx,\n+                    cx.param_env,\n+                    c,\n+                ).unwrap()\n+            },\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }\n@@ -567,7 +578,7 @@ impl<'tcx> Witness<'tcx> {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n-                                variant_index: ctor.variant_index_for_adt(adt),\n+                                variant_index: ctor.variant_index_for_adt(cx, adt),\n                                 subpatterns: pats\n                             }\n                         } else {\n@@ -1329,7 +1340,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n+fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty: Ty<'tcx>) -> u64 {\n     debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::Tuple(ref fs) => fs.len() as u64,\n@@ -1340,7 +1351,7 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n         },\n         ty::Ref(..) => 1,\n         ty::Adt(adt, _) => {\n-            adt.variants[ctor.variant_index_for_adt(adt)].fields.len() as u64\n+            adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.len() as u64\n         }\n         _ => 0\n     }\n@@ -1351,7 +1362,7 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n ///\n /// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n-                                             ctor: &Constructor,\n+                                             ctor: &Constructor<'tcx>,\n                                              ty: Ty<'tcx>) -> Vec<Ty<'tcx>>\n {\n     debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n@@ -1368,7 +1379,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                 // Use T as the sub pattern type of Box<T>.\n                 vec![substs.type_at(0)]\n             } else {\n-                adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n+                adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.iter().map(|field| {\n                     let is_visible = adt.is_enum()\n                         || field.vis.is_accessible_from(cx.module, cx.tcx);\n                     if is_visible {"}, {"sha": "cdaffe5d45673adc747c08d93a069b1f17a03dc2", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -885,7 +885,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n             let val = const_field(\n-                self.tcx, self.param_env, instance,\n+                self.tcx, self.param_env,\n                 variant_opt, field, cv,\n             ).expect(\"field access failed\");\n             self.const_to_pat(instance, val, id, span)\n@@ -928,7 +928,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             },\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let variant_index = const_variant_index(\n-                    self.tcx, self.param_env, instance, cv\n+                    self.tcx, self.param_env, cv\n                 ).expect(\"const_variant_index failed\");\n                 let subpatterns = adt_subpatterns(\n                     adt_def.variants[variant_index].fields.len(),"}, {"sha": "c3b71be8354daabcb1c6c1b6c0ce952876f740cd", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -109,11 +109,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::Closure(def_id, substs) => {\n-                        let substs = self.tcx.subst_and_normalize_erasing_regions(\n-                            self.substs(),\n-                            ty::ParamEnv::reveal_all(),\n-                            &substs,\n-                        );\n+                        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n                         let instance = ty::Instance::resolve_closure(\n                             *self.tcx,\n                             def_id,"}, {"sha": "132b753eb9a62dc92595556e7d95224b0ed9663e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -216,11 +216,21 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         self.frame().mir\n     }\n \n-    pub fn substs(&self) -> &'tcx Substs<'tcx> {\n-        if let Some(frame) = self.stack.last() {\n-            frame.instance.substs\n-        } else {\n-            Substs::empty()\n+    pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n+        &self,\n+        substs: T,\n+    ) -> EvalResult<'tcx, T> {\n+        match self.stack.last() {\n+            Some(frame) => Ok(self.tcx.subst_and_normalize_erasing_regions(\n+                frame.instance.substs,\n+                self.param_env,\n+                &substs,\n+            )),\n+            None => if substs.needs_subst() {\n+                err!(TooGeneric).into()\n+            } else {\n+                Ok(substs)\n+            },\n         }\n     }\n \n@@ -230,13 +240,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         substs: &'tcx Substs<'tcx>\n     ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n-        trace!(\"substs: {:#?}\", self.substs());\n         trace!(\"param_env: {:#?}\", self.param_env);\n-        let substs = self.tcx.subst_and_normalize_erasing_regions(\n-            self.substs(),\n-            self.param_env,\n-            &substs,\n-        );\n+        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n+        trace!(\"substs: {:#?}\", substs);\n         ty::Instance::resolve(\n             *self.tcx,\n             self.param_env,\n@@ -276,7 +282,21 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         }\n     }\n \n-    pub fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    pub(super) fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+        &self,\n+        t: T,\n+    ) -> EvalResult<'tcx, T> {\n+        match self.stack.last() {\n+            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)),\n+            None => if t.needs_subst() {\n+                err!(TooGeneric).into()\n+            } else {\n+                Ok(t)\n+            },\n+        }\n+    }\n+\n+    fn monomorphize_with_substs<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n         &self,\n         t: T,\n         substs: &'tcx Substs<'tcx>\n@@ -295,7 +315,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         let cell = &frame.local_layouts[local];\n         if cell.get().is_none() {\n             let local_ty = frame.mir.local_decls[local].ty;\n-            let local_ty = self.monomorphize(local_ty, frame.instance.substs);\n+            let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n             let layout = self.layout_of(local_ty)?;\n             cell.set(Some(layout));\n         }"}, {"sha": "8741571342f83aff5e01e3700d028791d9d92a4e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -508,7 +508,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             Constant(ref constant) => {\n                 let layout = from_known_layout(layout, || {\n-                    let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx), self.substs());\n+                    let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx))?;\n                     self.layout_of(ty)\n                 })?;\n                 let op = self.const_value_to_op(*constant.literal)?;"}, {"sha": "f3a948a6ca3e70dbff560c86e5fa5db5f5a6a19f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -9,6 +9,7 @@ use rustc::hir;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n+use rustc::ty::TypeFoldable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n@@ -583,8 +584,8 @@ where\n             }\n \n             Static(ref static_) => {\n-                let ty = self.monomorphize(static_.ty, self.substs());\n-                let layout = self.layout_of(ty)?;\n+                assert!(!static_.ty.needs_subst());\n+                let layout = self.layout_of(static_.ty)?;\n                 let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n                 let cid = GlobalId {\n                     instance,"}, {"sha": "25f3e4c1f771d80879409f9c6c0e9fe939659c0e", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.monomorphize(ty, self.substs());\n+                let ty = self.monomorphize(ty)?;\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n@@ -260,7 +260,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n-                debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest.layout.ty);\n+                debug_assert_eq!(self.monomorphize(cast_ty)?, dest.layout.ty);\n                 let src = self.eval_operand(operand, None)?;\n                 self.cast(src, kind, dest)?;\n             }"}, {"sha": "dc556a15cd8550fe0891bba8995997519f50d915", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::layout::{\n \n use interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n use const_eval::{\n-    CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_borrowck_eval_cx,\n+    CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n     lazy_const_to_op,\n };\n use transform::{MirPass, MirSource};\n@@ -110,9 +110,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source: MirSource,\n     ) -> ConstPropagator<'a, 'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id);\n-        let substs = Substs::identity_for_item(tcx, source.def_id);\n-        let instance = Instance::new(source.def_id, substs);\n-        let ecx = mk_borrowck_eval_cx(tcx, instance, mir, DUMMY_SP).unwrap();\n+        let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id), param_env);\n         ConstPropagator {\n             ecx,\n             mir,"}, {"sha": "53c5782a4c70e53d8b0c3854c8be8476126f0f27", "filename": "src/test/ui/consts/match_ice.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -0,0 +1,10 @@\n+// https://github.com/rust-lang/rust/issues/53708\n+\n+struct S;\n+\n+fn main() {\n+    const C: &S = &S;\n+    match C { //~ ERROR non-exhaustive\n+        C => {} // this is a common bug around constants and references in patterns\n+    }\n+}"}, {"sha": "e6e04e2c4627687d8388b124e7df0bdf431533da", "filename": "src/test/ui/consts/match_ice.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8348f8338859d6267ef52d4671d98e8a4cf76a6f/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr?ref=8348f8338859d6267ef52d4671d98e8a4cf76a6f", "patch": "@@ -0,0 +1,9 @@\n+error[E0004]: non-exhaustive patterns: `&S` not covered\n+  --> $DIR/match_ice.rs:7:11\n+   |\n+LL |     match C { //~ ERROR non-exhaustive\n+   |           ^ pattern `&S` not covered\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}]}