{"sha": "3d278e91882b2a15a06242f1c0846986f259a3b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMjc4ZTkxODgyYjJhMTVhMDYyNDJmMWMwODQ2OTg2ZjI1OWEzYjc=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-03T15:18:31Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-03T15:20:17Z"}, "message": "Document `AllocMap`", "tree": {"sha": "e07fbbf86812cbe3a6dddc35873f525693949ea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e07fbbf86812cbe3a6dddc35873f525693949ea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d278e91882b2a15a06242f1c0846986f259a3b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d278e91882b2a15a06242f1c0846986f259a3b7", "html_url": "https://github.com/rust-lang/rust/commit/3d278e91882b2a15a06242f1c0846986f259a3b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d278e91882b2a15a06242f1c0846986f259a3b7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6b3eb05415cbe57fbd4ddc22d054e7c94a00a84", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6b3eb05415cbe57fbd4ddc22d054e7c94a00a84", "html_url": "https://github.com/rust-lang/rust/commit/f6b3eb05415cbe57fbd4ddc22d054e7c94a00a84"}], "stats": {"total": 22, "additions": 20, "deletions": 2}, "files": [{"sha": "783bb6f521e6957880662501b2f910f627e8c90d", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d278e91882b2a15a06242f1c0846986f259a3b7/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d278e91882b2a15a06242f1c0846986f259a3b7/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=3d278e91882b2a15a06242f1c0846986f259a3b7", "patch": "@@ -322,8 +322,11 @@ impl<'tcx> AllocMap<'tcx> {\n         }\n     }\n \n-    /// obtains a new allocation ID that can be referenced but does not\n+    /// Obtains a new allocation ID that can be referenced but does not\n     /// yet have an allocation backing it.\n+    ///\n+    /// Make sure to call `set_id_memory` or `set_id_same_memory` before returning such an\n+    /// `AllocId` from a query.\n     pub fn reserve(\n         &mut self,\n     ) -> AllocId {\n@@ -357,35 +360,50 @@ impl<'tcx> AllocMap<'tcx> {\n         id\n     }\n \n+    /// Returns `None` in case the `AllocId` is dangling.\n+    /// This function exists to allow const eval to detect the difference between evaluation-\n+    /// local dangling pointers and allocations in constants/statics.\n     pub fn get(&self, id: AllocId) -> Option<AllocType<'tcx>> {\n         self.id_to_type.get(&id).cloned()\n     }\n \n+    /// Panics if the `AllocId` does not refer to an `Allocation`\n     pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n         match self.get(id) {\n             Some(AllocType::Memory(mem)) => mem,\n             _ => bug!(\"expected allocation id {} to point to memory\", id),\n         }\n     }\n \n+    /// Generate an `AllocId` for a static or return a cached one in case this function has been\n+    /// called on the same static before.\n     pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n         self.intern(AllocType::Static(static_id))\n     }\n \n+    /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n+    /// `Allocation` with a different `AllocId`.\n+    // FIXME: is this really necessary? Can we ensure `FOO` and `BAR` being different after codegen\n+    // in `static FOO: u32 = 42; static BAR: u32 = 42;` even if they reuse the same allocation\n+    // inside rustc?\n     pub fn allocate(&mut self, mem: &'tcx Allocation) -> AllocId {\n         let id = self.reserve();\n         self.set_id_memory(id, mem);\n         id\n     }\n \n+    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n+    /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n         if let Some(old) = self.id_to_type.insert(id, AllocType::Memory(mem)) {\n             bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n+    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n+    /// twice for the same `(AllocId, Allocation)` pair.\n     pub fn set_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-       self.id_to_type.insert_same(id, AllocType::Memory(mem));\n+        self.id_to_type.insert_same(id, AllocType::Memory(mem));\n     }\n }\n "}]}