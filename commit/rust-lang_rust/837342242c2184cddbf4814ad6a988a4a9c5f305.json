{"sha": "837342242c2184cddbf4814ad6a988a4a9c5f305", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNzM0MjI0MmMyMTg0Y2RkYmY0ODE0YWQ2YTk4OGE0YTljNWYzMDU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-16T22:54:10Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-16T23:39:49Z"}, "message": "Make fewer typechecker errors immediately fatal.", "tree": {"sha": "4d0ed6924f285a91d09f76b9650af5cdedb5c0ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d0ed6924f285a91d09f76b9650af5cdedb5c0ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/837342242c2184cddbf4814ad6a988a4a9c5f305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/837342242c2184cddbf4814ad6a988a4a9c5f305", "html_url": "https://github.com/rust-lang/rust/commit/837342242c2184cddbf4814ad6a988a4a9c5f305", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/837342242c2184cddbf4814ad6a988a4a9c5f305/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70b009178cf050d5bb78655ee46dfd8271f9eb79", "url": "https://api.github.com/repos/rust-lang/rust/commits/70b009178cf050d5bb78655ee46dfd8271f9eb79", "html_url": "https://github.com/rust-lang/rust/commit/70b009178cf050d5bb78655ee46dfd8271f9eb79"}], "stats": {"total": 50, "additions": 25, "deletions": 25}, "files": [{"sha": "32a834b560357f0ad34c1bf9b845ac9c961d8325", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/837342242c2184cddbf4814ad6a988a4a9c5f305/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837342242c2184cddbf4814ad6a988a4a9c5f305/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=837342242c2184cddbf4814ad6a988a4a9c5f305", "patch": "@@ -598,9 +598,9 @@ mod collect {\n         if ty::type_has_dynamic_size(cx.tcx, tt) {\n             alt ty_mode {\n               mo_val. {\n-                cx.tcx.sess.span_fatal(a.ty.span,\n-                                       \"Dynamically sized arguments \\\n-                                          must be passed by alias\");\n+                cx.tcx.sess.span_err(a.ty.span,\n+                                     \"Dynamically sized arguments \\\n+                                      must be passed by alias\");\n               }\n               _ { }\n             }\n@@ -1776,7 +1776,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             let errmsg =\n                 \"binary operation \" + binopstr +\n                     \" cannot be applied to type `\" + t_str + \"`\";\n-            fcx.ccx.tcx.sess.span_fatal(span, errmsg);\n+            fcx.ccx.tcx.sess.span_err(span, errmsg);\n         }\n     }\n \n@@ -1845,18 +1845,18 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           ast::not. {\n             if !type_is_integral(fcx, oper.span, oper_t) &&\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n-                tcx.sess.span_fatal(expr.span,\n-                                    #fmt(\"mismatched types: expected bool \\\n-                                          or integer but found %s\",\n-                                         ty_to_str(tcx, oper_t)));\n+                tcx.sess.span_err(expr.span,\n+                                  #fmt(\"mismatched types: expected bool \\\n+                                        or integer but found %s\",\n+                                       ty_to_str(tcx, oper_t)));\n             }\n           }\n           ast::neg. {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(tcx, oper_t) ||\n                  ty::type_is_fp(tcx, oper_t)) {\n-                tcx.sess.span_fatal(expr.span, \"applying unary minus to \\\n-                    non-numeric type \" + ty_to_str(tcx, oper_t));\n+                tcx.sess.span_err(expr.span, \"applying unary minus to \\\n+                   non-numeric type \" + ty_to_str(tcx, oper_t));\n             }\n           }\n         }\n@@ -1898,8 +1898,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           none. {\n             let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n-                tcx.sess.span_fatal(expr.span,\n-                                    \"ret; in function returning non-nil\");\n+                tcx.sess.span_err(expr.span,\n+                                  \"ret; in function returning non-nil\");\n             }\n           }\n           some(e) {\n@@ -1911,14 +1911,14 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       ast::expr_put(expr_opt) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n         if (fcx.proto != ast::proto_iter) {\n-            tcx.sess.span_fatal(expr.span, \"put in non-iterator\");\n+            tcx.sess.span_err(expr.span, \"put in non-iterator\");\n         }\n         alt expr_opt {\n           none. {\n             let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n-                tcx.sess.span_fatal(expr.span,\n-                                    \"put; in iterator yielding non-nil\");\n+                tcx.sess.span_err(expr.span,\n+                                  \"put; in iterator yielding non-nil\");\n             }\n           }\n           some(e) {\n@@ -2172,10 +2172,10 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n \n         if !(type_is_scalar(fcx, expr.span, expr_ty(tcx, e)) &&\n                  type_is_scalar(fcx, expr.span, t_1)) {\n-            tcx.sess.span_fatal(expr.span,\n-                                \"non-scalar cast: \" +\n-                                ty_to_str(tcx, expr_ty(tcx, e))\n-                                + \" as \" + ty_to_str(tcx, t_1));\n+            tcx.sess.span_err(expr.span,\n+                              \"non-scalar cast: \" +\n+                              ty_to_str(tcx, expr_ty(tcx, e))\n+                              + \" as \" + ty_to_str(tcx, t_1));\n         }\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n@@ -2293,10 +2293,10 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         bot |= check_expr(fcx, idx);\n         let idx_t = expr_ty(tcx, idx);\n         if !type_is_integral(fcx, idx.span, idx_t) {\n-            tcx.sess.span_fatal(idx.span,\n-                                \"mismatched types: expected \\\n-                                 integer but found \"\n-                                + ty_to_str(tcx, idx_t));\n+            tcx.sess.span_err(idx.span,\n+                              \"mismatched types: expected \\\n+                               integer but found \"\n+                              + ty_to_str(tcx, idx_t));\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n@@ -2600,8 +2600,8 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n         // This just checks that the declared type is bool, and trusts\n         // that that's the actual return type.\n         if !ty::type_is_bool(ccx.tcx, fcx.ret_ty) {\n-            ccx.tcx.sess.span_fatal(body.span,\n-                                    \"Non-boolean return type in pred\");\n+            ccx.tcx.sess.span_err(body.span,\n+                                  \"Non-boolean return type in pred\");\n         }\n       }\n       _ { }"}]}