{"sha": "ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYzFmOGQ1ZThmM2VkMTc1MWM3ODNlODc1YmEzMThlNTc3Y2ZiNTY=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-15T12:57:15Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T06:14:26Z"}, "message": "Implement BigInt and BigUint.", "tree": {"sha": "1fa4ca41409a32e23e78a4950e86a77222696ba4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fa4ca41409a32e23e78a4950e86a77222696ba4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "html_url": "https://github.com/rust-lang/rust/commit/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bf87bbf66227c132283ae59720f919601de9a56", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bf87bbf66227c132283ae59720f919601de9a56", "html_url": "https://github.com/rust-lang/rust/commit/9bf87bbf66227c132283ae59720f919601de9a56"}], "stats": {"total": 1505, "additions": 1505, "deletions": 0}, "files": [{"sha": "b66b7c61900a6493a8a94e2e0d3bb60af9bab9e3", "filename": "src/libstd/bigint.rs", "status": "added", "additions": 663, "deletions": 0, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "patch": "@@ -0,0 +1,663 @@\n+/*!\n+\n+A Big signed integer.\n+\n+A BigInt is a combination of BigUint and Sign.\n+*/\n+\n+use core::cmp::{Eq, Ord};\n+\n+use biguint::{BigDigit, BigUint};\n+\n+/// A Sign is a BigInt's composing element.\n+pub enum Sign { Minus, Zero, Plus }\n+\n+impl Sign : Eq {\n+    pure fn eq(&self, other: &Sign) -> bool { self.cmp(other) == 0 }\n+    pure fn ne(&self, other: &Sign) -> bool { self.cmp(other) != 0 }\n+}\n+\n+impl Sign : Ord {\n+    pure fn lt(&self, other: &Sign) -> bool { self.cmp(other) <  0 }\n+    pure fn le(&self, other: &Sign) -> bool { self.cmp(other) <= 0 }\n+    pure fn ge(&self, other: &Sign) -> bool { self.cmp(other) >= 0 }\n+    pure fn gt(&self, other: &Sign) -> bool { self.cmp(other) >  0 }\n+}\n+\n+pub impl Sign {\n+    /// Compare two Sign.\n+    pure fn cmp(other: &Sign) -> int {\n+        match (self, *other) {\n+          (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) =>  0,\n+          (Minus, Zero)  | (Minus, Plus) | (Zero, Plus) => -1,\n+          _                                             =>  1\n+        }\n+    }\n+\n+    /// Negate Sign value.\n+    pure fn neg() -> Sign {\n+        match(self) {\n+          Minus => Plus,\n+          Zero  => Zero,\n+          Plus  => Minus\n+        }\n+    }\n+}\n+\n+/// A big signed integer type.\n+pub struct BigInt {\n+    priv sign: Sign,\n+    priv data: BigUint\n+}\n+\n+impl BigInt : Eq {\n+    pure fn eq(&self, other: &BigInt) -> bool { self.cmp(other) == 0 }\n+    pure fn ne(&self, other: &BigInt) -> bool { self.cmp(other) != 0 }\n+}\n+\n+impl BigInt : Ord {\n+    pure fn lt(&self, other: &BigInt) -> bool { self.cmp(other) <  0 }\n+    pure fn le(&self, other: &BigInt) -> bool { self.cmp(other) <= 0 }\n+    pure fn ge(&self, other: &BigInt) -> bool { self.cmp(other) >= 0 }\n+    pure fn gt(&self, other: &BigInt) -> bool { self.cmp(other) >  0 }\n+}\n+\n+impl BigInt : ToStr {\n+    pure fn to_str() -> ~str { self.to_str_radix(10) }\n+}\n+\n+impl BigInt : from_str::FromStr {\n+    static pure fn from_str(s: &str) -> Option<BigInt> {\n+        BigInt::from_str_radix(s, 10)\n+    }\n+}\n+\n+impl BigInt : Shl<uint, BigInt> {\n+    pure fn shl(&self, rhs: &uint) -> BigInt {\n+        BigInt::from_biguint(self.sign, self.data << *rhs)\n+    }\n+}\n+\n+impl BigInt : Shr<uint, BigInt> {\n+    pure fn shr(&self, rhs: &uint) -> BigInt {\n+        BigInt::from_biguint(self.sign, self.data >> *rhs)\n+    }\n+}\n+\n+impl BigInt : Num {\n+    pure fn add(&self, other: &BigInt) -> BigInt {\n+        match (self.sign, other.sign) {\n+            (Zero, _)      => *other,\n+            (_,    Zero)   => *self,\n+            (Plus, Plus)   => BigInt::from_biguint(Plus,\n+                                                   self.data + other.data),\n+            (Plus, Minus)  => self - (-*other),\n+            (Minus, Plus)  => other - (-*self),\n+            (Minus, Minus) => -((-self) + (-*other))\n+        }\n+    }\n+    pure fn sub(&self, other: &BigInt) -> BigInt {\n+        match (self.sign, other.sign) {\n+            (Zero, _)    => -other,\n+            (_,    Zero) => *self,\n+            (Plus, Plus) => match self.data.cmp(&other.data) {\n+                s if s < 0 =>\n+                    BigInt::from_biguint(Minus, other.data - self.data),\n+                s if s > 0 =>\n+                    BigInt::from_biguint(Plus, self.data - other.data),\n+                _ =>\n+                    BigInt::zero()\n+            },\n+            (Plus, Minus) => self + (-*other),\n+            (Minus, Plus) => -((-self) + *other),\n+            (Minus, Minus) => (-other) - (-*self)\n+        }\n+    }\n+    pure fn mul(&self, other: &BigInt) -> BigInt {\n+        match (self.sign, other.sign) {\n+            (Zero, _)     | (_,     Zero)  => BigInt::zero(),\n+            (Plus, Plus)  | (Minus, Minus) => {\n+                BigInt::from_biguint(Plus, self.data * other.data)\n+            },\n+            (Plus, Minus) | (Minus, Plus) => {\n+                BigInt::from_biguint(Minus, self.data * other.data)\n+            }\n+        }\n+    }\n+    pure fn div(&self, other: &BigInt) -> BigInt {\n+        self.divmod(other).first()\n+    }\n+    pure fn modulo(&self, other: &BigInt) -> BigInt {\n+        self.divmod(other).second()\n+    }\n+    pure fn neg(&self) -> BigInt {\n+        BigInt::from_biguint(self.sign.neg(), self.data)\n+    }\n+\n+    pure fn to_int(&self) -> int {\n+        match self.sign {\n+            Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n+            Zero  => 0,\n+            Minus => uint::min((-self).to_uint(),\n+                               (int::max_value as uint) + 1) as int\n+        }\n+    }\n+\n+    static pure fn from_int(n: int) -> BigInt {\n+        if n > 0 {\n+           return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n+        }\n+        if n < 0 {\n+            return BigInt::from_biguint(\n+                Minus, BigUint::from_uint(uint::max_value - (n as uint) + 1)\n+            );\n+        }\n+        return BigInt::zero();\n+    }\n+}\n+\n+pub impl BigInt {\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n+        if sign == Zero || data.is_zero() {\n+            return BigInt { sign: Zero, data: BigUint::zero() };\n+        }\n+        return BigInt { sign: sign, data: data };\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_uint(n: uint) -> BigInt {\n+        if n == 0 { return BigInt::zero(); }\n+        return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n+        BigInt::from_biguint(sign, BigUint::from_slice(slice))\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_at_vec(sign: Sign, at_vec: @[BigDigit])\n+        -> BigInt {\n+        BigInt::from_biguint(sign, BigUint::from_at_vec(at_vec))\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_str_radix(s: &str, radix: uint)\n+        -> Option<BigInt> {\n+        BigInt::parse_bytes(str::to_bytes(s), radix)\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+        -> Option<BigInt> {\n+        if buf.is_empty() { return None; }\n+        let mut sign  = Plus;\n+        let mut start = 0;\n+        if buf[0] == ('-' as u8) {\n+            sign  = Minus;\n+            start = 1;\n+        }\n+        return BigUint::parse_bytes(vec::view(buf, start, buf.len()), radix)\n+            .map(|bu| BigInt::from_biguint(sign, *bu));\n+    }\n+\n+    static pub pure fn zero() -> BigInt {\n+        BigInt::from_biguint(Zero, BigUint::zero())\n+    }\n+    static pub pure fn one() -> BigInt {\n+        BigInt::from_biguint(Plus, BigUint::one())\n+    }\n+\n+    pure fn abs() -> BigInt { BigInt::from_biguint(Plus, self.data) }\n+\n+    pure fn cmp(other: &BigInt) -> int {\n+        let ss = self.sign, os = other.sign;\n+        if ss < os { return -1; }\n+        if ss > os { return  1; }\n+\n+        assert ss == os;\n+        match ss {\n+            Zero  => 0,\n+            Plus  => self.data.cmp(&other.data),\n+            Minus => self.data.cmp(&other.data).neg(),\n+        }\n+    }\n+\n+    pure fn divmod(other: &BigInt) -> (BigInt, BigInt) {\n+        // m.sign == other.sign\n+        let (d_ui, m_ui) = self.data.divmod(&other.data);\n+        let d = BigInt::from_biguint(Plus, d_ui),\n+            m = BigInt::from_biguint(Plus, m_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail,\n+            (Plus, Plus)  | (Zero, Plus)  => (d, m),\n+            (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n+                (-d, BigInt::zero())\n+            } else {\n+                (-d - BigInt::one(), m + *other)\n+            },\n+            (Minus, Plus) => if m.is_zero() {\n+                (-d, BigInt::zero())\n+            } else {\n+                (-d - BigInt::one(), other - m)\n+            },\n+            (Minus, Minus) => (d, -m)\n+        }\n+    }\n+\n+    pure fn quot(other: &BigInt) -> BigInt { self.quotrem(other).first() }\n+    pure fn rem(other: &BigInt) -> BigInt { self.quotrem(other).second() }\n+\n+    pure fn quotrem(other: &BigInt) -> (BigInt, BigInt) {\n+        // r.sign == self.sign\n+        let (q_ui, r_ui) = self.data.quotrem(&other.data);\n+        let q = BigInt::from_biguint(Plus, q_ui);\n+        let r = BigInt::from_biguint(Plus, r_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail,\n+            (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n+            (Plus, Minus) | (Zero, Minus) => (-q,  r),\n+            (Minus, Plus)                 => (-q, -r),\n+            (Minus, Minus)                => ( q, -r)\n+        }\n+    }\n+\n+    pure fn is_zero() -> bool { self.sign == Zero }\n+    pure fn is_not_zero() -> bool { self.sign != Zero }\n+    pure fn is_positive() -> bool { self.sign == Plus }\n+    pure fn is_negative() -> bool { self.sign == Minus }\n+    pure fn is_nonpositive() -> bool { self.sign != Plus }\n+    pure fn is_nonnegative() -> bool { self.sign != Minus }\n+\n+    pure fn to_uint() -> uint {\n+        match self.sign {\n+            Plus  => self.data.to_uint(),\n+            Zero  => 0,\n+            Minus => 0\n+        }\n+    }\n+\n+    pure fn to_str_radix(radix: uint) -> ~str {\n+        match self.sign {\n+            Plus  => self.data.to_str_radix(radix),\n+            Zero  => ~\"0\",\n+            Minus => ~\"-\" + self.data.to_str_radix(radix)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_from_biguint() {\n+        assert BigInt::from_biguint(Plus, BigUint::from_uint(1)) ==\n+            BigInt { sign: Plus, data: BigUint::from_uint(1) };\n+        assert BigInt::from_biguint(Plus, BigUint::zero()) ==\n+            BigInt { sign: Zero, data: BigUint::zero() };\n+        assert BigInt::from_biguint(Minus, BigUint::from_uint(1)) ==\n+            BigInt { sign: Minus, data: BigUint::from_uint(1) };\n+        assert BigInt::from_biguint(Zero, BigUint::from_uint(1)) ==\n+            BigInt { sign: Zero, data: BigUint::zero() };\n+    }\n+\n+    #[test]\n+    fn test_cmp() {\n+        let uints = [ &[2], &[1, 1], &[2, 1], &[1, 1, 1] ]\n+            .map(|data| BigUint::from_slice(*data));\n+        let nums: ~[BigInt]\n+            = vec::reversed(uints).map(|bu| BigInt::from_biguint(Minus, *bu))\n+            + [ BigInt::zero() ]\n+            + uints.map(|bu| BigInt::from_biguint(Plus, *bu));\n+\n+        for nums.eachi |i, ni| {\n+            for vec::view(nums, i, nums.len()).eachi |j0, nj| {\n+                let j = i + j0;\n+                if i == j {\n+                    assert ni.cmp(nj) == 0;\n+                    assert nj.cmp(ni) == 0;\n+                    assert ni == nj;\n+                    assert !(ni != nj);\n+                    assert ni <= nj;\n+                    assert ni >= nj;\n+                    assert !(ni < nj);\n+                    assert !(ni > nj);\n+                } else {\n+                    assert ni.cmp(nj) < 0;\n+                    assert nj.cmp(ni) > 0;\n+\n+                    assert !(ni == nj);\n+                    assert ni != nj;\n+\n+                    assert ni <= nj;\n+                    assert !(ni >= nj);\n+                    assert ni < nj;\n+                    assert !(ni > nj);\n+\n+                    assert !(nj <= ni);\n+                    assert nj >= ni;\n+                    assert !(nj < ni);\n+                    assert nj > ni;\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_convert_int() {\n+        fn check_conv(b: BigInt, i: int) {\n+            assert b == num::from_int(i);\n+            assert b.to_int() == i;\n+        }\n+\n+        check_conv(BigInt::zero(), 0);\n+        check_conv(BigInt::one(), 1);\n+        check_conv(\n+            BigInt::from_biguint(\n+                Plus, BigUint::from_uint(int::max_value as uint)),\n+            int::max_value);\n+\n+        assert BigInt::from_biguint(\n+            Plus, BigUint::from_uint(int::max_value as uint + 1)\n+        ).to_int() == int::max_value;\n+        assert BigInt::from_biguint(\n+            Plus, BigUint::from_at_vec(@[1, 2, 3])\n+        ).to_int() == int::max_value;\n+\n+        check_conv(\n+            BigInt::from_biguint(\n+                Minus, BigUint::from_uint(-int::min_value as uint)),\n+            int::min_value);\n+        assert BigInt::from_biguint(\n+            Minus, BigUint::from_uint(-int::min_value as uint + 1)\n+        ).to_int() == int::min_value;\n+        assert BigInt::from_biguint(\n+            Minus, BigUint::from_at_vec(@[1, 2, 3])\n+        ).to_int() == int::min_value;\n+    }\n+\n+    #[test]\n+    fn test_convert_uint() {\n+        fn check_conv(b: BigInt, u: uint) {\n+            assert b == BigInt::from_uint(u);\n+            assert b.to_uint() == u;\n+        }\n+\n+        check_conv(BigInt::zero(), 0);\n+        check_conv(BigInt::one(), 1);\n+\n+        check_conv(\n+            BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n+            uint::max_value);\n+        assert BigInt::from_biguint(\n+            Plus, BigUint::from_at_vec(@[1, 2, 3])\n+        ).to_uint() == uint::max_value;\n+\n+        assert BigInt::from_biguint(\n+            Minus, BigUint::from_uint(uint::max_value)\n+        ).to_uint() == 0;\n+        assert BigInt::from_biguint(\n+            Minus, BigUint::from_at_vec(@[1, 2, 3])\n+        ).to_uint() == 0;\n+    }\n+\n+    const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],          &[],       &[]),\n+        (&[],          &[ 1],     &[ 1]),\n+        (&[ 1],        &[ 1],     &[ 2]),\n+        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n+        (&[ 1],        &[-1],     &[ 0,  1]),\n+        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n+        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n+        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n+        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n+    ];\n+\n+    #[test]\n+    fn test_add() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert a + b == c;\n+            assert b + a == c;\n+            assert c + (-a) == b;\n+            assert c + (-b) == a;\n+            assert a + (-c) == (-b);\n+            assert b + (-c) == (-a);\n+            assert (-a) + (-b) == (-c);\n+            assert a + (-a) == BigInt::zero();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sub() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert c - a == b;\n+            assert c - b == a;\n+            assert (-b) - a == (-c);\n+            assert (-a) - b == (-c);\n+            assert b - (-a) == c;\n+            assert a - (-b) == c;\n+            assert (-c) - (-a) == (-b);\n+            assert a - a == BigInt::zero();\n+        }\n+    }\n+\n+    const mul_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],               &[],               &[]),\n+        (&[],               &[ 1],             &[]),\n+        (&[ 2],             &[],               &[]),\n+        (&[ 1],             &[ 1],             &[1]),\n+        (&[ 2],             &[ 3],             &[ 6]),\n+        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n+        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n+        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n+        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n+        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n+        (&[-1],             &[-1],             &[ 1, -2]),\n+        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n+        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n+        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n+        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n+        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n+        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n+        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n+        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n+        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n+        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n+    ];\n+\n+    const divmod_quadruples: &[(&[BigDigit], &[BigDigit],\n+                                &[BigDigit], &[BigDigit])]\n+        = &[\n+            (&[ 1],        &[ 2], &[],               &[1]),\n+            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n+            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n+            (&[ 0,  1],    &[-1], &[1],              &[1]),\n+            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n+        ];\n+\n+    #[test]\n+    fn test_mul() {\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert a * b == c;\n+            assert b * a == c;\n+\n+            assert (-a) * b == -c;\n+            assert (-b) * a == -c;\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+            let d = BigInt::from_slice(Plus, dVec);\n+\n+            assert a == b * c + d;\n+            assert a == c * b + d;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_divmod() {\n+        fn check_divmod_sub(a: BigInt, b: BigInt) {\n+            let (d, m) = a.divmod(&b);\n+            if m.is_not_zero() {\n+                assert m.sign == b.sign;\n+            }\n+            assert m.abs() <= b.abs();\n+            assert a == b * d + m;\n+        }\n+        fn check_divmod(a: BigInt, b: BigInt, c: BigInt, d: BigInt) {\n+            check_divmod_sub(a, b);\n+            check_divmod_sub(a, -b);\n+            check_divmod_sub(-a, b);\n+            check_divmod_sub(-a, -b);\n+\n+            if d.is_zero() {\n+                assert a.divmod(&b)     == (c, BigInt::zero());\n+                assert (-a).divmod(&b)  == (-c, BigInt::zero());\n+                assert (a).divmod(&-b)  == (-c, BigInt::zero());\n+                assert (-a).divmod(&-b) == (c, BigInt::zero());\n+            } else {\n+                // a == bc + d\n+                assert a.divmod(&b) == (c, d);\n+                // a == (-b)(-c - 1) + (d - b)\n+                assert a.divmod(&-b) == (-c - BigInt::one(), d - b);\n+                // (-a) == b (-c - 1) + (b - d)\n+                assert (-a).divmod(&b) == (-c - BigInt::one(), b - d);\n+                // (-a) == (-b)(c) - d\n+                assert (-a).divmod(&-b) == (c, -d);\n+            }\n+        }\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            if a.is_not_zero() { check_divmod(c, a, b, BigInt::zero()); }\n+            if b.is_not_zero() { check_divmod(c, b, a, BigInt::zero()); }\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+            let d = BigInt::from_slice(Plus, dVec);\n+\n+            if b.is_not_zero() {\n+                check_divmod(a, b, c, d);\n+            }\n+        }\n+    }\n+\n+\n+    #[test]\n+    fn test_quotrem() {\n+        fn check_quotrem_sub(a: BigInt, b: BigInt) {\n+            let (q, r) = a.quotrem(&b);\n+            if r.is_not_zero() {\n+                assert r.sign == a.sign;\n+            }\n+            assert r.abs() <= b.abs();\n+            assert a == b * q + r;\n+        }\n+        fn check_quotrem(a: BigInt, b: BigInt, c: BigInt, d: BigInt) {\n+            check_quotrem_sub(a, b);\n+            check_quotrem_sub(a, -b);\n+            check_quotrem_sub(-a, b);\n+            check_quotrem_sub(-a, -b);\n+\n+            if d.is_zero() {\n+                assert a.quotrem(&b)     == (c, BigInt::zero());\n+                assert (-a).quotrem(&b)  == (-c, BigInt::zero());\n+                assert (a).quotrem(&-b)  == (-c, BigInt::zero());\n+                assert (-a).quotrem(&-b) == (c, BigInt::zero());\n+            } else {\n+                // a == bc + d\n+                assert a.quotrem(&b) == (c, d);\n+                // a == (-b)(-c) + d\n+                assert a.quotrem(&-b) == (-c, d);\n+                // (-a) == b (-c) + (-d)\n+                assert (-a).quotrem(&b) == (-c, -d);\n+                // (-a) == (-b)(c) - d\n+                assert (-a).quotrem(&-b) == (c, -d);\n+            }\n+        }\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            if a.is_not_zero() { check_quotrem(c, a, b, BigInt::zero()); }\n+            if b.is_not_zero() { check_quotrem(c, b, a, BigInt::zero()); }\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+            let d = BigInt::from_slice(Plus, dVec);\n+\n+            if b.is_not_zero() {\n+                check_quotrem(a, b, c, d);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_str_radix() {\n+        assert BigInt::from_biguint(Plus, BigUint::from_uint(10))\n+            .to_str_radix(10) == ~\"10\";\n+        assert BigInt::one().to_str_radix(10) == ~\"1\";\n+        assert BigInt::zero().to_str_radix(10) == ~\"0\";\n+        assert (-BigInt::one()).to_str_radix(10) == ~\"-1\";\n+        assert BigInt::from_biguint(Minus, BigUint::from_uint(10))\n+            .to_str_radix(10) == ~\"-10\";\n+    }\n+\n+\n+    #[test]\n+    fn test_from_str_radix() {\n+        assert BigInt::from_biguint(Plus, BigUint::from_uint(10)) ==\n+            BigInt::from_str_radix(~\"10\", 10).get();\n+        assert BigInt::one()== BigInt::from_str_radix(~\"1\", 10).get();\n+        assert BigInt::zero() == BigInt::from_str_radix(~\"0\", 10).get();\n+        assert (-BigInt::one()) == BigInt::from_str_radix(~\"-1\", 10).get();\n+        assert BigInt::from_biguint(Minus, BigUint::from_uint(10)) ==\n+            BigInt::from_str_radix(~\"-10\", 10).get();\n+\n+        assert BigInt::from_str_radix(~\"Z\", 10) == None;\n+        assert BigInt::from_str_radix(~\"_\", 2) == None;\n+        assert BigInt::from_str_radix(~\"-1\", 10) ==\n+            Some(BigInt::from_biguint(Minus, BigUint::one()));\n+    }\n+\n+    #[test]\n+    fn test_neg() {\n+        assert -BigInt::from_at_vec(Plus,  @[1, 1, 1]) ==\n+            BigInt::from_at_vec(Minus, @[1, 1, 1]);\n+        assert -BigInt::from_at_vec(Minus, @[1, 1, 1]) ==\n+            BigInt::from_at_vec(Plus,  @[1, 1, 1]);\n+        assert -BigInt::zero() == BigInt::zero();\n+    }\n+}\n+"}, {"sha": "63cedbc1369d02cff7b09c3f3689f98ac874451f", "filename": "src/libstd/biguint.rs", "status": "added", "additions": 840, "deletions": 0, "changes": 840, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/src%2Flibstd%2Fbiguint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/src%2Flibstd%2Fbiguint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbiguint.rs?ref=ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "patch": "@@ -0,0 +1,840 @@\n+/*!\n+\n+A Big unsigned integer.\n+\n+A BigUint is represented as an array of BigDigits.\n+*/\n+\n+use core::cmp::{Eq, Ord};\n+\n+/**\n+A BigDigit is a BigUint's composing element.\n+\n+A BigDigit is half the size of machine word size.\n+*/\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"arm\")]\n+pub type BigDigit = u16;\n+\n+/**\n+A BigDigit is a BigUint's composing element.\n+\n+A BigDigit is half the size of machine word size.\n+*/\n+#[cfg(target_arch = \"x86_64\")]\n+pub type BigDigit = u32;\n+\n+pub mod BigDigit {\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    pub const bits: uint = 16;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub const bits: uint = 32;\n+\n+    pub const base: uint = 1 << bits;\n+    priv const hi_mask: uint = (-1 as uint) << bits;\n+    priv const lo_mask: uint = (-1 as uint) >> bits;\n+\n+    priv pure fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    priv pure fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n+\n+    /// Split one machine sized unsigned integer into two BigDigits.\n+    pub pure fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n+        (get_hi(n), get_lo(n))\n+    }\n+\n+    /// Join two BigDigits into one machine sized unsigned integer\n+    pub pure fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n+        (lo as uint) | ((hi as uint) << bits)\n+    }\n+}\n+\n+/**\n+A big unsigned integer type.\n+\n+A BigUint-typed value BigUint { data: @[a, b, c] } represents a number\n+(a + b * BigDigit::base + c * BigDigit::base^2).\n+*/\n+pub struct BigUint {\n+    priv data: @[BigDigit]\n+}\n+\n+impl BigUint : Eq {\n+    pure fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n+    pure fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n+}\n+\n+impl BigUint : Ord {\n+    pure fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n+    pure fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n+    pure fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n+    pure fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n+}\n+\n+impl BigUint : ToStr {\n+    pure fn to_str() -> ~str { self.to_str_radix(10) }\n+}\n+\n+impl BigUint : from_str::FromStr {\n+    static pure fn from_str(s: &str) -> Option<BigUint> {\n+        BigUint::from_str_radix(s, 10)\n+    }\n+}\n+\n+impl BigUint : Shl<uint, BigUint> {\n+    pure fn shl(&self, rhs: &uint) -> BigUint {\n+        let n_unit = *rhs / BigDigit::bits;\n+        let n_bits = *rhs % BigDigit::bits;\n+        return self.shl_unit(n_unit).shl_bits(n_bits);\n+    }\n+}\n+\n+impl BigUint : Shr<uint, BigUint> {\n+    pure fn shr(&self, rhs: &uint) -> BigUint {\n+        let n_unit = *rhs / BigDigit::bits;\n+        let n_bits = *rhs % BigDigit::bits;\n+        return self.shr_unit(n_unit).shr_bits(n_bits);\n+    }\n+}\n+\n+impl BigUint : Num {\n+    pure fn add(&self, other: &BigUint) -> BigUint {\n+        let new_len = uint::max(self.data.len(), other.data.len());\n+\n+        let mut carry = 0;\n+        let sum = do at_vec::from_fn(new_len) |i| {\n+            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n+            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n+            let (hi, lo) = BigDigit::from_uint(\n+                (ai as uint) + (bi as uint) + (carry as uint)\n+            );\n+            carry = hi;\n+            lo\n+        };\n+        if carry == 0 { return BigUint::from_at_vec(sum) };\n+        return BigUint::from_at_vec(sum + [carry]);\n+    }\n+\n+    pure fn sub(&self, other: &BigUint) -> BigUint {\n+        let new_len = uint::max(self.data.len(), other.data.len());\n+\n+        let mut borrow = 0;\n+        let diff = do at_vec::from_fn(new_len) |i| {\n+            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n+            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n+            let (hi, lo) = BigDigit::from_uint(\n+                (BigDigit::base) +\n+                (ai as uint) - (bi as uint) - (borrow as uint)\n+            );\n+            /*\n+            hi * (base) + lo == 1*(base) + ai - bi - borrow\n+            => ai - bi - borrow < 0 <=> hi == 0\n+            */\n+            borrow = if hi == 0 { 1 } else { 0 };\n+            lo\n+        };\n+\n+        assert borrow == 0;     // <=> assert (self >= other);\n+        return BigUint::from_at_vec(diff);\n+    }\n+\n+    pure fn mul(&self, other: &BigUint) -> BigUint {\n+        if self.is_zero() || other.is_zero() { return BigUint::zero(); }\n+\n+        let s_len = self.data.len(), o_len = other.data.len();\n+        if s_len == 1 { return mul_digit(other, self.data[0]);  }\n+        if o_len == 1 { return mul_digit(self,  other.data[0]); }\n+\n+        // Using Karatsuba multiplication\n+        // (a1 * base + a0) * (b1 * base + b0)\n+        // = a1*b1 * base^2 +\n+        //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n+        //   a0*b0\n+        let half_len = uint::max(s_len, o_len) / 2;\n+        let (sHi, sLo) = cut_at(self,  half_len);\n+        let (oHi, oLo) = cut_at(other, half_len);\n+\n+        let ll = sLo * oLo;\n+        let hh = sHi * oHi;\n+        let mm =  match (sub_sign(sHi, sLo), sub_sign(oHi, oLo)) {\n+            ((s1, n1), (s2, n2)) if s1 * s2 < 0 => hh + ll + (n1 * n2),\n+            ((s1, n1), (s2, n2)) if s1 * s2 > 0 => hh + ll - (n1 * n2),\n+            _   => hh + ll,\n+        };\n+\n+        return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n+\n+        pure fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n+            if n == 0 { return BigUint::zero(); }\n+            if n == 1 { return *a; }\n+\n+            let mut carry = 0;\n+            let prod = do at_vec::map(a.data) |ai| {\n+                let (hi, lo) = BigDigit::from_uint(\n+                    (*ai as uint) * (n as uint) + (carry as uint)\n+                );\n+                carry = hi;\n+                lo\n+            };\n+            if carry == 0 { return BigUint::from_at_vec(prod) };\n+            return BigUint::from_at_vec(prod + [carry]);\n+        }\n+\n+        pure fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n+            let mid = uint::min(a.data.len(), n);\n+            return (BigUint::from_slice(vec::view(a.data, mid, a.data.len())),\n+                    BigUint::from_slice(vec::view(a.data, 0, mid)));\n+        }\n+\n+        pure fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n+            match a.cmp(&b) {\n+                s if s < 0 => (s, b - a),\n+                s if s > 0 => (s, a - b),\n+                _          => (0, BigUint::zero())\n+            }\n+        }\n+    }\n+\n+    pure fn div(&self, other: &BigUint) -> BigUint{\n+        self.divmod(other).first()\n+    }\n+    pure fn modulo(&self, other: &BigUint) -> BigUint {\n+        self.divmod(other).second()\n+    }\n+\n+    pure fn neg(&self) -> BigUint { fail }\n+\n+    pure fn to_int(&self) -> int {\n+        uint::min(self.to_uint(), int::max_value as uint) as int\n+    }\n+\n+    static pure fn from_int(n: int) -> BigUint {\n+        if (n < 0) { BigUint::zero() } else { BigUint::from_uint(n as uint) }\n+    }\n+}\n+\n+pub impl BigUint {\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_uint(n: uint) -> BigUint {\n+        match BigDigit::from_uint(n) {\n+            (0,  0)  => BigUint::zero(),\n+            (0,  n0) => BigUint::from_at_vec(@[n0]),\n+            (n1, n0) => BigUint::from_at_vec(@[n0, n1])\n+        }\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_slice(slice: &[BigDigit]) -> BigUint {\n+        // omit trailing zeros\n+        let new_len = slice.rposition(|n| *n != 0)\n+            .map_default(0, |p| *p + 1);\n+\n+        return BigUint { data: at_vec::from_fn(new_len, |i| slice[i]) };\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_at_vec(at_vec: @[BigDigit]) -> BigUint {\n+        // omit trailing zeros\n+        let new_len = at_vec.rposition(|n| *n != 0)\n+            .map_default(0, |p| *p + 1);\n+\n+        if new_len == at_vec.len() { return BigUint { data: at_vec }; }\n+        return BigUint { data: at_vec::from_fn(new_len, |i| at_vec[i]) };\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_str_radix(s: &str, radix: uint)\n+        -> Option<BigUint> {\n+        BigUint::parse_bytes(str::to_bytes(s), radix)\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+        -> Option<BigUint> {\n+        let (base, unit_len) = get_radix_base(radix);\n+        let base_num: BigUint = BigUint::from_uint(base);\n+\n+        let mut end             = buf.len();\n+        let mut n: BigUint      = BigUint::zero();\n+        let mut power: BigUint  = BigUint::one();\n+        loop {\n+            let start = uint::max(end, unit_len) - unit_len;\n+            match uint::parse_bytes(vec::view(buf, start, end), radix) {\n+                Some(d) => n += BigUint::from_uint(d) * power,\n+                None    => return None\n+            }\n+            if end <= unit_len {\n+                return Some(n);\n+            }\n+            end -= unit_len;\n+            power *= base_num;\n+        }\n+    }\n+\n+    static pub pure fn zero() -> BigUint { BigUint::from_at_vec(@[]) }\n+    static pub pure fn one() -> BigUint { BigUint::from_at_vec(@[1]) }\n+\n+    pure fn abs() -> BigUint { self }\n+\n+    /// Compare two BigUint value.\n+    pure fn cmp(other: &BigUint) -> int {\n+        let s_len = self.data.len(), o_len = other.data.len();\n+        if s_len < o_len { return -1; }\n+        if s_len > o_len { return  1;  }\n+\n+        for vec::rev_eachi(self.data) |i, elm| {\n+            match (*elm, other.data[i]) {\n+                (l, r) if l < r => return -1,\n+                (l, r) if l > r => return  1,\n+                _               => loop\n+            };\n+        }\n+        return 0;\n+    }\n+\n+    pure fn divmod(other: &BigUint) -> (BigUint, BigUint) {\n+        if other.is_zero() { fail }\n+        if self.is_zero() { return (BigUint::zero(), BigUint::zero()); }\n+        if *other == BigUint::one() { return (self, BigUint::zero()); }\n+\n+        match self.cmp(other) {\n+            s if s < 0 => return (BigUint::zero(), self),\n+            0          => return (BigUint::one(), BigUint::zero()),\n+            _          => {} // Do nothing\n+        }\n+\n+        let mut shift = 0;\n+        let mut n = other.data.last();\n+        while n < (1 << BigDigit::bits - 2) {\n+            n <<= 1;\n+            shift += 1;\n+        }\n+        assert shift < BigDigit::bits;\n+        let (d, m) = divmod_inner(self << shift, other << shift);\n+        return (d, m >> shift);\n+\n+\n+        pure fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+            let mut r = a;\n+            let mut d = BigUint::zero();\n+            let mut n = 1;\n+            while r >= b {\n+                let mut (d0, d_unit, b_unit) = div_estimate(r, b, n);\n+                let mut prod = b * d0;\n+                while prod > r {\n+                    d0   -= d_unit;\n+                    prod -= b_unit;\n+                }\n+                if d0.is_zero() {\n+                    n = 2;\n+                    loop;\n+                }\n+                n = 1;\n+                d += d0;\n+                r -= prod;\n+            }\n+            return (d, r);\n+        }\n+\n+        pure fn div_estimate(a: BigUint, b: BigUint, n: uint)\n+            -> (BigUint, BigUint, BigUint) {\n+            if a.data.len() < n {\n+                return (BigUint::zero(), BigUint::zero(), a);\n+            }\n+\n+            let an = vec::view(a.data, a.data.len() - n, a.data.len());\n+            let bn = b.data.last();\n+            let mut d = ~[];\n+            let mut carry = 0;\n+            for vec::rev_each(an) |elt| {\n+                let ai = BigDigit::to_uint(carry, *elt);\n+                let di = ai / (bn as uint);\n+                assert di < BigDigit::base;\n+                carry = (ai % (bn as uint)) as BigDigit;\n+                d = ~[di as BigDigit] + d;\n+            }\n+\n+            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n+            return (BigUint::from_slice(d).shl_unit(shift),\n+                    BigUint::one().shl_unit(shift),\n+                    b.shl_unit(shift));\n+        }\n+    }\n+\n+    pure fn quot(other: &BigUint) -> BigUint { self.quotrem(other).first() }\n+    pure fn rem(other: &BigUint) -> BigUint { self.quotrem(other).second() }\n+    pure fn quotrem(other: &BigUint) -> (BigUint, BigUint) {\n+        self.divmod(other)\n+    }\n+\n+    pure fn is_zero() -> bool { self.data.is_empty() }\n+    pure fn is_not_zero() -> bool { self.data.is_not_empty() }\n+    pure fn is_positive() -> bool { self.is_not_zero() }\n+    pure fn is_negative() -> bool { false }\n+    pure fn is_nonpositive() -> bool { self.is_zero() }\n+    pure fn is_nonnegative() -> bool { true }\n+\n+    pure fn to_uint() -> uint {\n+        match self.data.len() {\n+            0 => 0,\n+            1 => self.data[0] as uint,\n+            2 => BigDigit::to_uint(self.data[1], self.data[0]),\n+            _ => uint::max_value\n+        }\n+    }\n+\n+    pure fn to_str_radix(radix: uint) -> ~str {\n+        assert 1 < radix && radix <= 16;\n+\n+        pure fn convert_base(n: BigUint, base: uint) -> @[BigDigit] {\n+            if base == BigDigit::base { return n.data; }\n+            let divider    = BigUint::from_uint(base);\n+            let mut result = @[];\n+            let mut r      = n;\n+            while r > divider {\n+                let (d, r0) = r.divmod(&divider);\n+                result += [r0.to_uint() as BigDigit];\n+                r = d;\n+            }\n+            if r.is_not_zero() {\n+                result += [r.to_uint() as BigDigit];\n+            }\n+            return result;\n+        }\n+\n+        pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n+            if v.is_empty() { return ~\"0\" }\n+            str::trim_left_chars(str::concat(vec::reversed(v).map(|n| {\n+                let s = uint::to_str(*n as uint, radix);\n+                str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n+            })), ['0'])\n+        }\n+\n+        let (base, max_len) = get_radix_base(radix);\n+        return fill_concat(convert_base(self, base), radix, max_len);\n+    }\n+\n+    priv pure fn shl_unit(n_unit: uint) -> BigUint {\n+        if n_unit == 0 || self.is_zero() { return self; }\n+\n+        return BigUint::from_at_vec(at_vec::from_elem(n_unit, 0) + self.data);\n+    }\n+\n+    priv pure fn shl_bits(n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.is_zero() { return self; }\n+\n+        let mut carry = 0;\n+        let shifted = do at_vec::map(self.data) |elem| {\n+            let (hi, lo) = BigDigit::from_uint(\n+                (*elem as uint) << n_bits | (carry as uint)\n+            );\n+            carry = hi;\n+            lo\n+        };\n+        if carry == 0 { return BigUint::from_at_vec(shifted); }\n+        return BigUint::from_at_vec(shifted + [carry]);\n+    }\n+\n+    priv pure fn shr_unit(n_unit: uint) -> BigUint {\n+        if n_unit == 0 { return self; }\n+        if self.data.len() < n_unit { return BigUint::zero(); }\n+        return BigUint::from_slice(\n+            vec::view(self.data, n_unit, self.data.len())\n+        );\n+    }\n+\n+    priv pure fn shr_bits(n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.data.is_empty() { return self; }\n+\n+        let mut borrow = 0;\n+        let mut shifted = @[];\n+        for vec::rev_each(self.data) |elem| {\n+            // internal compiler error: no enclosing scope with id 10671\n+            // shifted = @[(*elem >> n_bits) | borrow] + shifted;\n+            shifted = at_vec::append(@[(*elem >> n_bits) | borrow], shifted);\n+            borrow = *elem << (uint::bits - n_bits);\n+        }\n+        return BigUint::from_at_vec(shifted);\n+    }\n+}\n+\n+priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n+    assert 1 < radix && radix <= 16;\n+    match radix {\n+        2  => (4294967296, 32),\n+        3  => (3486784401, 20),\n+        4  => (4294967296, 16),\n+        5  => (1220703125, 13),\n+        6  => (2176782336, 12),\n+        7  => (1977326743, 11),\n+        8  => (1073741824, 10),\n+        9  => (3486784401, 10),\n+        10 => (1000000000, 9),\n+        11 => (2357947691, 9),\n+        12 => (429981696,  8),\n+        13 => (815730721,  8),\n+        14 => (1475789056, 8),\n+        15 => (2562890625, 8),\n+        16 => (4294967296, 8),\n+        _  => fail\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_from_slice() {\n+        let pairs = [\n+            (&[1],                &[1]),\n+            (&[0, 0],             &[]),\n+            (&[1, 2, 0, 0],       &[1, 2]),\n+            (&[0, 0, 1, 2, 0, 0], &[0, 0, 1, 2]),\n+            (&[-1],               &[-1])\n+        ];\n+        for pairs.each |p| {\n+            assert p.second() == BigUint::from_slice(p.first()).data;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_cmp() {\n+        let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n+            .map(|v| BigUint::from_slice(*v));\n+        for data.eachi |i, ni| {\n+            for vec::view(data, i, data.len()).eachi |j0, nj| {\n+                let j = j0 + i;\n+                if i == j {\n+                    assert ni.cmp(nj) == 0;\n+                    assert nj.cmp(ni) == 0;\n+                    assert ni == nj;\n+                    assert !(ni != nj);\n+                    assert ni <= nj;\n+                    assert ni >= nj;\n+                    assert !(ni < nj);\n+                    assert !(ni > nj);\n+                } else {\n+                    assert ni.cmp(nj) < 0;\n+                    assert nj.cmp(ni) > 0;\n+\n+                    assert !(ni == nj);\n+                    assert ni != nj;\n+\n+                    assert ni <= nj;\n+                    assert !(ni >= nj);\n+                    assert ni < nj;\n+                    assert !(ni > nj);\n+\n+                    assert !(nj <= ni);\n+                    assert nj >= ni;\n+                    assert !(nj < ni);\n+                    assert nj > ni;\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_shl() {\n+        assert BigUint::from_at_vec(@[]) << 3 == BigUint::from_at_vec(@[]);\n+        assert BigUint::from_at_vec(@[1, 1, 1]) << 3 ==\n+            BigUint::from_at_vec(@[1 << 3, 1 << 3, 1 << 3]);\n+\n+        assert BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]) << 2 ==\n+            BigUint::from_at_vec(@[0, 1]);\n+        assert BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]) << 3 ==\n+            BigUint::from_at_vec(@[0, 2]);\n+        assert (BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)])\n+                << (3 + BigDigit::bits)) ==\n+            BigUint::from_at_vec(@[0, 0, 2]);\n+\n+        assert BigUint::from_at_vec(\n+            @[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]\n+        ) << 4 == BigUint::from_at_vec(\n+            @[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]\n+        );\n+        assert BigUint::from_at_vec(\n+            @[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]\n+        ) << 16 == BigUint::from_at_vec(\n+                @[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]\n+            );\n+    }\n+\n+    #[test]\n+    fn test_shr() {\n+        assert BigUint::from_at_vec(@[]) >> 3 == BigUint::from_at_vec(@[]);\n+        assert BigUint::from_at_vec(@[1, 1, 1]) >> 3 == BigUint::from_at_vec(\n+            @[1 << (BigDigit::bits - 3), 1 << (BigDigit::bits - 3)]\n+        );\n+\n+        assert BigUint::from_at_vec(@[1 << 2]) >> 2 ==\n+            BigUint::from_at_vec(@[1]);\n+        assert BigUint::from_at_vec(@[1, 2]) >> 3 ==\n+            BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]);\n+        assert BigUint::from_at_vec(@[1, 1, 2]) >> (3 + BigDigit::bits) ==\n+            BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]);\n+\n+        assert BigUint::from_at_vec(\n+            @[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]\n+        ) >> 4 == BigUint::from_at_vec(\n+            @[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]\n+        );\n+\n+        assert BigUint::from_at_vec(\n+            @[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]\n+        ) >> 16 == BigUint::from_at_vec(\n+            @[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_convert_int() {\n+        fn check_conv(b: BigUint, i: int) {\n+            assert b == num::from_int(i);\n+            assert b.to_int() == i;\n+        }\n+\n+        check_conv(BigUint::zero(), 0);\n+        check_conv(BigUint::from_at_vec(@[1]), 1);\n+\n+        check_conv(BigUint::from_at_vec(@[-1]),\n+                   (uint::max_value >> BigDigit::bits) as int);\n+        check_conv(BigUint::from_at_vec(@[ 0,  1]),\n+                   ((uint::max_value >> BigDigit::bits) + 1) as int);\n+        check_conv(BigUint::from_at_vec(@[-1, -1 >> 1]),\n+                   int::max_value);\n+\n+        assert BigUint::from_at_vec(@[0, -1]).to_int() == int::max_value;\n+        assert BigUint::from_at_vec(@[0, 0, 1]).to_int() == int::max_value;\n+        assert BigUint::from_at_vec(@[0, 0, -1]).to_int() == int::max_value;\n+    }\n+\n+    #[test]\n+    fn test_convert_uint() {\n+        fn check_conv(b: BigUint, u: uint) {\n+            assert b == BigUint::from_uint(u);\n+            assert b.to_uint() == u;\n+        }\n+\n+        check_conv(BigUint::zero(), 0);\n+        check_conv(BigUint::from_at_vec(@[ 1]), 1);\n+        check_conv(BigUint::from_at_vec(@[-1]),\n+                   uint::max_value >> BigDigit::bits);\n+        check_conv(BigUint::from_at_vec(@[ 0,  1]),\n+                   (uint::max_value >> BigDigit::bits) + 1);\n+        check_conv(BigUint::from_at_vec(@[ 0, -1]),\n+                   uint::max_value << BigDigit::bits);\n+        check_conv(BigUint::from_at_vec(@[-1, -1]),\n+                   uint::max_value);\n+\n+        assert BigUint::from_at_vec(@[0, 0, 1]).to_uint()  == uint::max_value;\n+        assert BigUint::from_at_vec(@[0, 0, -1]).to_uint() == uint::max_value;\n+    }\n+\n+    const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],          &[],       &[]),\n+        (&[],          &[ 1],     &[ 1]),\n+        (&[ 1],        &[ 1],     &[ 2]),\n+        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n+        (&[ 1],        &[-1],     &[ 0,  1]),\n+        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n+        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n+        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n+        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n+    ];\n+\n+    #[test]\n+    fn test_add() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert a + b == c;\n+            assert b + a == c;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sub() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert c - a == b;\n+            assert c - b == a;\n+        }\n+    }\n+\n+    const mul_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],               &[],               &[]),\n+        (&[],               &[ 1],             &[]),\n+        (&[ 2],             &[],               &[]),\n+        (&[ 1],             &[ 1],             &[1]),\n+        (&[ 2],             &[ 3],             &[ 6]),\n+        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n+        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n+        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n+        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n+        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n+        (&[-1],             &[-1],             &[ 1, -2]),\n+        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n+        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n+        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n+        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n+        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n+        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n+        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n+        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n+        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n+        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n+    ];\n+\n+    const divmod_quadruples: &[(&[BigDigit], &[BigDigit],\n+                                &[BigDigit], &[BigDigit])]\n+        = &[\n+            (&[ 1],        &[ 2], &[],               &[1]),\n+            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n+            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n+            (&[ 0,  1],    &[-1], &[1],              &[1]),\n+            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n+        ];\n+\n+    #[test]\n+    fn test_mul() {\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert a * b == c;\n+            assert b * a == c;\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+            let d = BigUint::from_slice(dVec);\n+\n+            assert a == b * c + d;\n+            assert a == c * b + d;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_divmod() {\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            if a.is_not_zero() {\n+                assert c.divmod(&a) == (b, BigUint::zero());\n+            }\n+            if b.is_not_zero() {\n+                assert c.divmod(&b) == (a, BigUint::zero());\n+            }\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+            let d = BigUint::from_slice(dVec);\n+\n+            if b.is_not_zero() { assert a.divmod(&b) == (c, d); }\n+        }\n+    }\n+\n+    fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n+        ~[( BigUint::zero(), ~[\n+            (2, ~\"0\"), (3, ~\"0\")\n+        ]), ( BigUint::from_slice([ 0xff ]), ~[\n+            (2,  ~\"11111111\"),\n+            (3,  ~\"100110\"),\n+            (4,  ~\"3333\"),\n+            (5,  ~\"2010\"),\n+            (6,  ~\"1103\"),\n+            (7,  ~\"513\"),\n+            (8,  ~\"377\"),\n+            (9,  ~\"313\"),\n+            (10, ~\"255\"),\n+            (11, ~\"212\"),\n+            (12, ~\"193\"),\n+            (13, ~\"168\"),\n+            (14, ~\"143\"),\n+            (15, ~\"120\"),\n+            (16, ~\"ff\")\n+        ]), ( BigUint::from_slice([ 0xfff ]), ~[\n+            (2,  ~\"111111111111\"),\n+            (4,  ~\"333333\"),\n+            (16, ~\"fff\")\n+        ]), ( BigUint::from_slice([ 1, 2 ]), ~[\n+            (2,  ~\"10\" + str::from_chars(vec::from_elem(31, '0')) + \"1\"),\n+            (4,  ~\"2\"  + str::from_chars(vec::from_elem(15, '0')) + \"1\"),\n+            (10, ~\"8589934593\"),\n+            (16, ~\"2\"  + str::from_chars(vec::from_elem(7, '0')) + \"1\")\n+        ]), (BigUint::from_slice([ 1, 2, 3 ]), ~[\n+            (2,  ~\"11\" + str::from_chars(vec::from_elem(30, '0')) + \"10\" +\n+             str::from_chars(vec::from_elem(31, '0')) + \"1\"),\n+            (4,  ~\"3\"  + str::from_chars(vec::from_elem(15, '0')) + \"2\"  +\n+             str::from_chars(vec::from_elem(15, '0')) + \"1\"),\n+            (10, ~\"55340232229718589441\"),\n+            (16, ~\"3\"  + str::from_chars(vec::from_elem(7, '0')) + \"2\"  +\n+             str::from_chars(vec::from_elem(7, '0')) + \"1\")\n+        ])]\n+    }\n+\n+    #[test]\n+    fn test_to_str_radix() {\n+        for to_str_pairs().each |num_pair| {\n+            let &(n, rs) = num_pair;\n+            for rs.each |str_pair| {\n+                let &(radix, str) = str_pair;\n+                assert n.to_str_radix(radix) == str;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix() {\n+        for to_str_pairs().each |num_pair| {\n+            let &(n, rs) = num_pair;\n+            for rs.each |str_pair| {\n+                let &(radix, str) = str_pair;\n+                assert Some(n) == BigUint::from_str_radix(str, radix);\n+            }\n+        }\n+\n+        assert BigUint::from_str_radix(~\"Z\", 10) == None;\n+        assert BigUint::from_str_radix(~\"_\", 2) == None;\n+        assert BigUint::from_str_radix(~\"-1\", 10) == None;\n+    }\n+\n+    #[test]\n+    fn test_factor() {\n+        fn factor(n: uint) -> BigUint {\n+            let mut f= BigUint::one();\n+            for uint::range(2, n + 1) |i| {\n+                f *= BigUint::from_uint(i);\n+            }\n+            return f;\n+        }\n+\n+        assert factor(3) == BigUint::from_str_radix(~\"6\", 10).get();\n+        assert factor(10) == BigUint::from_str_radix(~\"3628800\", 10).get();\n+        assert factor(20) == BigUint::from_str_radix(\n+            ~\"2432902008176640000\", 10).get();\n+        assert factor(30) == BigUint::from_str_radix(\n+            ~\"265252859812191058636308480000000\", 10).get();\n+    }\n+}"}, {"sha": "4820068098f114994a40677dfafa9ab854c7aa4d", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "patch": "@@ -98,6 +98,8 @@ pub mod cmp;\n pub mod base64;\n pub mod rl;\n pub mod workcache;\n+pub mod bigint;\n+pub mod biguint;\n \n #[cfg(unicode)]\n mod unicode;"}]}