{"sha": "e921b32be35f3166757c5a7b93a21e2339769023", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MjFiMzJiZTM1ZjMxNjY3NTdjNWE3YjkzYTIxZTIzMzk3NjkwMjM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-21T20:24:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-24T09:34:21Z"}, "message": "put empty generic lists behind a pointer\n\nThis reduces the size of hir::Expr from 128 to 88 bytes (!) and shaves\n200MB out of #36799.", "tree": {"sha": "2b7f2ffbcff8287d34b9da9a895b523f1b94e1e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b7f2ffbcff8287d34b9da9a895b523f1b94e1e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e921b32be35f3166757c5a7b93a21e2339769023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e921b32be35f3166757c5a7b93a21e2339769023", "html_url": "https://github.com/rust-lang/rust/commit/e921b32be35f3166757c5a7b93a21e2339769023", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e921b32be35f3166757c5a7b93a21e2339769023/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acb73dbe8b311eb2ffa640ac3e01795d84159df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/acb73dbe8b311eb2ffa640ac3e01795d84159df4", "html_url": "https://github.com/rust-lang/rust/commit/acb73dbe8b311eb2ffa640ac3e01795d84159df4"}], "stats": {"total": 299, "additions": 187, "deletions": 112}, "files": [{"sha": "1755b3bca0572198806b82422b46a0a73fdf508b", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -627,7 +627,9 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n     visitor.visit_name(path_span, segment.name);\n-    visitor.visit_path_parameters(path_span, &segment.parameters);\n+    if let Some(ref parameters) = segment.parameters {\n+        visitor.visit_path_parameters(path_span, parameters);\n+    }\n }\n \n pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,"}, {"sha": "95b8e49d60c6a8f6a36b23e425ea1c5f2820d0bd", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -690,10 +690,9 @@ impl<'a> LoweringContext<'a> {\n             TyKind::ImplicitSelf => {\n                 hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n                     def: self.expect_full_def(t.id),\n-                    segments: hir_vec![hir::PathSegment {\n-                        name: keywords::SelfType.name(),\n-                        parameters: hir::PathParameters::none()\n-                    }],\n+                    segments: hir_vec![\n+                        hir::PathSegment::from_name(keywords::SelfType.name())\n+                    ],\n                     span: t.span,\n                 })))\n             }\n@@ -914,12 +913,8 @@ impl<'a> LoweringContext<'a> {\n             segments: segments.map(|segment| {\n                 self.lower_path_segment(p.span, segment, param_mode, 0,\n                                         ParenthesizedGenericArgs::Err)\n-            }).chain(name.map(|name| {\n-                hir::PathSegment {\n-                    name,\n-                    parameters: hir::PathParameters::none()\n-                }\n-            })).collect(),\n+            }).chain(name.map(|name| hir::PathSegment::from_name(name)))\n+              .collect(),\n             span: p.span,\n         }\n     }\n@@ -940,7 +935,7 @@ impl<'a> LoweringContext<'a> {\n                           expected_lifetimes: usize,\n                           parenthesized_generic_args: ParenthesizedGenericArgs)\n                           -> hir::PathSegment {\n-        let mut parameters = if let Some(ref parameters) = segment.parameters {\n+        let (mut parameters, infer_types) = if let Some(ref parameters) = segment.parameters {\n             let msg = \"parenthesized parameters may only be used with a trait\";\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n@@ -951,12 +946,12 @@ impl<'a> LoweringContext<'a> {\n                     ParenthesizedGenericArgs::Warn => {\n                         self.sess.buffer_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                                               CRATE_NODE_ID, data.span, msg.into());\n-                        hir::PathParameters::none()\n+                        (hir::PathParameters::none(), true)\n                     }\n                     ParenthesizedGenericArgs::Err => {\n                         struct_span_err!(self.sess, data.span, E0214, \"{}\", msg)\n                             .span_label(data.span, \"only traits may use parentheses\").emit();\n-                        hir::PathParameters::none()\n+                        (hir::PathParameters::none(), true)\n                     }\n                 }\n             }\n@@ -970,40 +965,39 @@ impl<'a> LoweringContext<'a> {\n             }).collect();\n         }\n \n-        hir::PathSegment {\n-            name: self.lower_ident(segment.identifier),\n+        hir::PathSegment::new(\n+            self.lower_ident(segment.identifier),\n             parameters,\n-        }\n+            infer_types\n+        )\n     }\n \n     fn lower_angle_bracketed_parameter_data(&mut self,\n                                             data: &AngleBracketedParameterData,\n                                             param_mode: ParamMode)\n-                                            -> hir::PathParameters {\n+                                            -> (hir::PathParameters, bool) {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings, .. } = data;\n-        hir::PathParameters {\n+        (hir::PathParameters {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n-            infer_types: types.is_empty() && param_mode == ParamMode::Optional,\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n             parenthesized: false,\n-        }\n+        }, types.is_empty() && param_mode == ParamMode::Optional)\n     }\n \n     fn lower_parenthesized_parameter_data(&mut self,\n                                           data: &ParenthesizedParameterData)\n-                                          -> hir::PathParameters {\n+                                          -> (hir::PathParameters, bool) {\n         let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n         let inputs = inputs.iter().map(|ty| self.lower_ty(ty)).collect();\n         let mk_tup = |this: &mut Self, tys, span| {\n             let LoweredNodeId { node_id, hir_id } = this.next_id();\n             P(hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span })\n         };\n \n-        hir::PathParameters {\n+        (hir::PathParameters {\n             lifetimes: hir::HirVec::new(),\n             types: hir_vec![mk_tup(self, inputs, span)],\n-            infer_types: false,\n             bindings: hir_vec![hir::TypeBinding {\n                 id: self.next_id().node_id,\n                 name: Symbol::intern(FN_OUTPUT_NAME),\n@@ -1012,7 +1006,7 @@ impl<'a> LoweringContext<'a> {\n                 span: output.as_ref().map_or(span, |ty| ty.span),\n             }],\n             parenthesized: true,\n-        }\n+        }, false)\n     }\n \n     fn lower_local(&mut self, l: &Local) -> P<hir::Local> {"}, {"sha": "bff71155440a38000415393a676ddb6d67c3593c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -236,17 +236,49 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub parameters: PathParameters,\n+    pub parameters: Option<P<PathParameters>>,\n+\n+    /// Whether to infer remaining type parameters, if any.\n+    /// This only applies to expression and pattern paths, and\n+    /// out of those only the segments with no type parameters\n+    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n+    pub infer_types: bool,\n }\n \n impl PathSegment {\n     /// Convert an identifier to the corresponding segment.\n     pub fn from_name(name: Name) -> PathSegment {\n         PathSegment {\n             name,\n-            parameters: PathParameters::none()\n+            infer_types: true,\n+            parameters: None\n+        }\n+    }\n+\n+    pub fn new(name: Name, parameters: PathParameters, infer_types: bool) -> Self {\n+        PathSegment {\n+            name,\n+            infer_types,\n+            parameters: if parameters.is_empty() {\n+                None\n+            } else {\n+                Some(P(parameters))\n+            }\n         }\n     }\n+\n+    // FIXME: hack required because you can't create a static\n+    // PathParameters, so you can't just return a &PathParameters.\n+    pub fn with_parameters<F, R>(&self, f: F) -> R\n+        where F: FnOnce(&PathParameters) -> R\n+    {\n+        let dummy = PathParameters::none();\n+        f(if let Some(ref params) = self.parameters {\n+            &params\n+        } else {\n+            &dummy\n+        })\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -255,11 +287,6 @@ pub struct PathParameters {\n     pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: HirVec<P<Ty>>,\n-    /// Whether to infer remaining type parameters, if any.\n-    /// This only applies to expression and pattern paths, and\n-    /// out of those only the segments with no type parameters\n-    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n-    pub infer_types: bool,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n@@ -274,12 +301,16 @@ impl PathParameters {\n         Self {\n             lifetimes: HirVec::new(),\n             types: HirVec::new(),\n-            infer_types: true,\n             bindings: HirVec::new(),\n             parenthesized: false,\n         }\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.lifetimes.is_empty() && self.types.is_empty() &&\n+            self.bindings.is_empty() && !self.parenthesized\n+    }\n+\n     pub fn inputs(&self) -> &[P<Ty>] {\n         if self.parenthesized {\n             if let Some(ref ty) = self.types.get(0) {"}, {"sha": "5daffe667fde5c51cae388b2a6afbd164f060b46", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -1213,11 +1213,17 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n-        if !segment.parameters.lifetimes.is_empty() ||\n-                !segment.parameters.types.is_empty() ||\n-                !segment.parameters.bindings.is_empty() {\n-            self.print_path_parameters(&segment.parameters, true)?;\n-        }\n+\n+        segment.with_parameters(|parameters| {\n+            if !parameters.lifetimes.is_empty() ||\n+                !parameters.types.is_empty() ||\n+                !parameters.bindings.is_empty()\n+            {\n+                self.print_path_parameters(&parameters, segment.infer_types, true)\n+            } else {\n+                Ok(())\n+            }\n+        })?;\n         self.print_call_post(base_args)\n     }\n \n@@ -1564,8 +1570,12 @@ impl<'a> State<'a> {\n             }\n             if segment.name != keywords::CrateRoot.name() &&\n                segment.name != keywords::DollarCrate.name() {\n-                self.print_name(segment.name)?;\n-                self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+               self.print_name(segment.name)?;\n+               segment.with_parameters(|parameters| {\n+                   self.print_path_parameters(parameters,\n+                                              segment.infer_types,\n+                                              colons_before_params)\n+               })?;\n             }\n         }\n \n@@ -1593,29 +1603,42 @@ impl<'a> State<'a> {\n                     if segment.name != keywords::CrateRoot.name() &&\n                        segment.name != keywords::DollarCrate.name() {\n                         self.print_name(segment.name)?;\n-                        self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                        segment.with_parameters(|parameters| {\n+                            self.print_path_parameters(parameters,\n+                                                       segment.infer_types,\n+                                                       colons_before_params)\n+                        })?;\n                     }\n                 }\n \n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_name(item_segment.name)?;\n-                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+                item_segment.with_parameters(|parameters| {\n+                    self.print_path_parameters(parameters,\n+                                               item_segment.infer_types,\n+                                               colons_before_params)\n+                })\n             }\n             hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n                 self.s.word(\"<\")?;\n                 self.print_type(qself)?;\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 self.print_name(item_segment.name)?;\n-                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+                item_segment.with_parameters(|parameters| {\n+                    self.print_path_parameters(parameters,\n+                                               item_segment.infer_types,\n+                                               colons_before_params)\n+                })\n             }\n         }\n     }\n \n     fn print_path_parameters(&mut self,\n                              parameters: &hir::PathParameters,\n+                             infer_types: bool,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n         if parameters.parenthesized {\n@@ -1652,7 +1675,7 @@ impl<'a> State<'a> {\n \n             // FIXME(eddyb) This would leak into error messages, e.g.:\n             // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n-            if parameters.infer_types && false {\n+            if infer_types && false {\n                 start_or_comma(self)?;\n                 self.s.word(\"..\")?;\n             }"}, {"sha": "96d5940caf6a4d9da50e1436f47f9c7584d8ba33", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -150,13 +150,13 @@ impl_stable_hash_for!(struct hir::Path {\n \n impl_stable_hash_for!(struct hir::PathSegment {\n     name,\n+    infer_types,\n     parameters\n });\n \n impl_stable_hash_for!(struct hir::PathParameters {\n     lifetimes,\n     types,\n-    infer_types,\n     bindings,\n     parenthesized\n });"}, {"sha": "d0c5460fa9714e3c446c1ac378fc00c8630209d1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -445,7 +445,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n-            self.visit_segment_parameters(path.def, depth, &segment.parameters);\n+            if let Some(ref parameters) = segment.parameters {\n+                self.visit_segment_parameters(path.def, depth, parameters);\n+            }\n         }\n     }\n "}, {"sha": "54fd070e93cbcbb4943952386b405461bc83f606", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -157,11 +157,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n     {\n+\n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_path(span,\n-                                            def_id,\n-                                            &item_segment.parameters,\n-                                            None);\n+            item_segment.with_parameters(|parameters| {\n+                self.create_substs_for_ast_path(\n+                    span,\n+                    def_id,\n+                    parameters,\n+                    item_segment.infer_types,\n+                    None)\n+            });\n \n         assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n \n@@ -177,6 +182,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         span: Span,\n         def_id: DefId,\n         parameters: &hir::PathParameters,\n+        infer_types: bool,\n         self_ty: Option<Ty<'tcx>>)\n         -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n@@ -204,7 +210,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Check the number of type parameters supplied by the user.\n         let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n-        if !parameters.infer_types || num_types_provided > ty_param_defs.len() {\n+        if !infer_types || num_types_provided > ty_param_defs.len() {\n             check_type_argument_count(tcx, span, num_types_provided, ty_param_defs);\n         }\n \n@@ -240,7 +246,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             if i < num_types_provided {\n                 // A provided type parameter.\n                 self.ast_ty_to_ty(&parameters.types[i])\n-            } else if parameters.infer_types {\n+            } else if infer_types {\n                 // No type parameters were provided, we can infer all.\n                 let ty_var = if !default_needs_object_self(def) {\n                     self.ty_infer_for_def(def, substs, span)\n@@ -390,7 +396,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n         if !self.tcx().sess.features.borrow().unboxed_closures &&\n-           trait_segment.parameters.parenthesized != trait_def.paren_sugar {\n+           trait_segment.with_parameters(|p| p.parenthesized) != trait_def.paren_sugar {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let msg = if trait_def.paren_sugar {\n                 \"the precise format of `Fn`-family traits' type parameters is subject to change. \\\n@@ -402,10 +408,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                              span, GateIssue::Language, msg);\n         }\n \n-        self.create_substs_for_ast_path(span,\n-                                        trait_def_id,\n-                                        &trait_segment.parameters,\n-                                        Some(self_ty))\n+        trait_segment.with_parameters(|parameters| {\n+            self.create_substs_for_ast_path(span,\n+                                            trait_def_id,\n+                                            parameters,\n+                                            trait_segment.infer_types,\n+                                            Some(self_ty))\n+        })\n     }\n \n     fn trait_defines_associated_type_named(&self,\n@@ -876,25 +885,27 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n-            for typ in &segment.parameters.types {\n-                struct_span_err!(self.tcx().sess, typ.span, E0109,\n-                                 \"type parameters are not allowed on this type\")\n-                    .span_label(typ.span, \"type parameter not allowed\")\n-                    .emit();\n-                break;\n-            }\n-            for lifetime in &segment.parameters.lifetimes {\n-                struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n-                                 \"lifetime parameters are not allowed on this type\")\n-                    .span_label(lifetime.span,\n-                                \"lifetime parameter not allowed on this type\")\n-                    .emit();\n-                break;\n-            }\n-            for binding in &segment.parameters.bindings {\n-                self.prohibit_projection(binding.span);\n-                break;\n-            }\n+            segment.with_parameters(|parameters| {\n+                for typ in &parameters.types {\n+                    struct_span_err!(self.tcx().sess, typ.span, E0109,\n+                                     \"type parameters are not allowed on this type\")\n+                        .span_label(typ.span, \"type parameter not allowed\")\n+                        .emit();\n+                    break;\n+                }\n+                for lifetime in &parameters.lifetimes {\n+                    struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n+                                     \"lifetime parameters are not allowed on this type\")\n+                        .span_label(lifetime.span,\n+                                    \"lifetime parameter not allowed on this type\")\n+                        .emit();\n+                    break;\n+                }\n+                for binding in &parameters.bindings {\n+                    self.prohibit_projection(binding.span);\n+                    break;\n+                }\n+            })\n         }\n     }\n \n@@ -978,12 +989,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::Err => {\n                 for segment in &path.segments {\n-                    for ty in &segment.parameters.types {\n-                        self.ast_ty_to_ty(ty);\n-                    }\n-                    for binding in &segment.parameters.bindings {\n-                        self.ast_ty_to_ty(&binding.ty);\n-                    }\n+                    segment.with_parameters(|parameters| {\n+                        for ty in &parameters.types {\n+                            self.ast_ty_to_ty(ty);\n+                        }\n+                        for binding in &parameters.bindings {\n+                            self.ast_ty_to_ty(&binding.ty);\n+                        }\n+                    });\n                 }\n                 self.set_tainted_by_errors();\n                 return self.tcx().types.err;\n@@ -1314,15 +1327,16 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 if Some(trait_did) == tcx.lang_items().send_trait() ||\n                     Some(trait_did) == tcx.lang_items().sync_trait() {\n                     let segments = &bound.trait_ref.path.segments;\n-                    let parameters = &segments[segments.len() - 1].parameters;\n-                    if !parameters.types.is_empty() {\n-                        check_type_argument_count(tcx, bound.trait_ref.path.span,\n-                                                  parameters.types.len(), &[]);\n-                    }\n-                    if !parameters.lifetimes.is_empty() {\n-                        report_lifetime_number_error(tcx, bound.trait_ref.path.span,\n-                                                     parameters.lifetimes.len(), 0);\n-                    }\n+                    segments[segments.len() - 1].with_parameters(|parameters| {\n+                        if !parameters.types.is_empty() {\n+                            check_type_argument_count(tcx, bound.trait_ref.path.span,\n+                                                      parameters.types.len(), &[]);\n+                        }\n+                        if !parameters.lifetimes.is_empty() {\n+                            report_lifetime_number_error(tcx, bound.trait_ref.path.span,\n+                                                         parameters.lifetimes.len(), 0);\n+                        }\n+                    });\n                     true\n                 } else {\n                     false"}, {"sha": "a9830dd5ddece3db97fb08d32a5a8687cfb87266", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             if i < parent_substs.len() {\n                 parent_substs.region_at(i)\n             } else if let Some(lifetime)\n-                    = provided.lifetimes.get(i - parent_substs.len()) {\n+                    = provided.as_ref().and_then(|p| p.lifetimes.get(i - parent_substs.len())) {\n                 AstConv::ast_region_to_region(self.fcx, lifetime, Some(def))\n             } else {\n                 self.region_var_for_def(self.span, def)\n@@ -310,7 +310,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             if i < parent_substs.len() {\n                 parent_substs.type_at(i)\n             } else if let Some(ast_ty)\n-                    = provided.types.get(i - parent_substs.len() - method_generics.regions.len()) {\n+                = provided.as_ref().and_then(|p| {\n+                    p.types.get(i - parent_substs.len() - method_generics.regions.len())\n+                })\n+            {\n                 self.to_ty(ast_ty)\n             } else {\n                 self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "38558f50f6e16fa2f1d93916f95289ffbb66f589", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -4668,7 +4668,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let lifetimes = segment.map_or(&[][..], |(s, _)| &s.parameters.lifetimes[..]);\n+            let lifetimes = segment.map_or(&[][..], |(s, _)| {\n+                s.parameters.as_ref().map_or(&[][..], |p| &p.lifetimes[..])\n+            });\n \n             if let Some(lifetime) = lifetimes.get(i) {\n                 AstConv::ast_region_to_region(self, lifetime, Some(def))\n@@ -4692,7 +4694,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 fn_segment\n             };\n             let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n-                (&s.parameters.types[..], s.parameters.infer_types)\n+                (s.parameters.as_ref().map_or(&[][..], |p| &p.types[..]), s.infer_types)\n             });\n \n             // Skip over the lifetimes in the same segment.\n@@ -4769,8 +4771,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   is_method_call: bool) {\n         let (lifetimes, types, infer_types, bindings) = segment.map_or(\n             (&[][..], &[][..], true, &[][..]),\n-            |(s, _)| (&s.parameters.lifetimes[..], &s.parameters.types[..],\n-                      s.parameters.infer_types, &s.parameters.bindings[..]));\n+            |(s, _)| s.parameters.as_ref().map_or(\n+                (&[][..], &[][..], s.infer_types, &[][..]),\n+                |p| (&p.lifetimes[..], &p.types[..],\n+                     s.infer_types, &p.bindings[..])));\n         let infer_lifetimes = lifetimes.len() == 0;\n \n         let count_lifetime_params = |n| {"}, {"sha": "c9afa3646b2da0ff260fafb2cc7bd84d22d5357f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921b32be35f3166757c5a7b93a21e2339769023/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e921b32be35f3166757c5a7b93a21e2339769023", "patch": "@@ -1852,25 +1852,27 @@ impl Clean<Type> for hir::Ty {\n                 };\n \n                 if let Some(&hir::ItemTy(ref ty, ref generics)) = alias {\n-                    let provided_params = &path.segments.last().unwrap().parameters;\n+                    let provided_params = &path.segments.last().unwrap();\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n-                    for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                        let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n-                        if let Some(ty) = provided_params.types.get(i).cloned() {\n-                            ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n-                        } else if let Some(default) = ty_param.default.clone() {\n-                            ty_substs.insert(ty_param_def, default.unwrap().clean(cx));\n+                    provided_params.with_parameters(|provided_params| {\n+                        for (i, ty_param) in generics.ty_params.iter().enumerate() {\n+                            let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n+                            if let Some(ty) = provided_params.types.get(i).cloned() {\n+                                ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n+                            } else if let Some(default) = ty_param.default.clone() {\n+                                ty_substs.insert(ty_param_def, default.unwrap().clean(cx));\n+                            }\n                         }\n-                    }\n-                    for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n-                        if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n-                            if !lt.is_elided() {\n-                                let lt_def_id = cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n-                                lt_substs.insert(lt_def_id, lt.clean(cx));\n+                        for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n+                            if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n+                                if !lt.is_elided() {\n+                                    let lt_def_id = cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n+                                    lt_substs.insert(lt_def_id, lt.clean(cx));\n+                                }\n                             }\n                         }\n-                    }\n+                    });\n                     return cx.enter_alias(ty_substs, lt_substs, || ty.clean(cx));\n                 }\n                 resolve_type(cx, path.clean(cx), self.id)\n@@ -2419,7 +2421,7 @@ impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n             name: self.name.clean(cx),\n-            params: self.parameters.clean(cx)\n+            params: self.with_parameters(|parameters| parameters.clean(cx))\n         }\n     }\n }"}]}