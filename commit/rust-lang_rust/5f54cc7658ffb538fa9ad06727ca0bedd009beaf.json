{"sha": "5f54cc7658ffb538fa9ad06727ca0bedd009beaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNTRjYzc2NThmZmI1MzhmYTlhZDA2NzI3Y2EwYmVkZDAwOWJlYWY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-06-20T13:15:28Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-06-20T13:15:28Z"}, "message": "Implement checked_mul\n\nFixes #6", "tree": {"sha": "62ee568f397706d0032ad5cda53abcb6c766235a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62ee568f397706d0032ad5cda53abcb6c766235a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f54cc7658ffb538fa9ad06727ca0bedd009beaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f54cc7658ffb538fa9ad06727ca0bedd009beaf", "html_url": "https://github.com/rust-lang/rust/commit/5f54cc7658ffb538fa9ad06727ca0bedd009beaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "177348fbb49631c9ea6ec974c709e9a6530820aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/177348fbb49631c9ea6ec974c709e9a6530820aa", "html_url": "https://github.com/rust-lang/rust/commit/177348fbb49631c9ea6ec974c709e9a6530820aa"}], "stats": {"total": 111, "additions": 60, "deletions": 51}, "files": [{"sha": "1146f7e415edfa7e857491d3f1bf55632f41808f", "filename": "Readme.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=5f54cc7658ffb538fa9ad06727ca0bedd009beaf", "patch": "@@ -67,6 +67,6 @@ function jit_calc() {\n ## Not yet supported\n \n * Good non-rust abi support ([several problems](https://github.com/bjorn3/rustc_codegen_cranelift/issues/10))\n-* Checked binops ([some missing instructions in cranelift](https://github.com/bytecodealliance/wasmtime/issues/1044))\n+    * Proc macros\n * Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041), not coming soon)\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)"}, {"sha": "ebac391f1e590c634d1c323b3a3589440a2be85c", "filename": "example/std_example.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=5f54cc7658ffb538fa9ad06727ca0bedd009beaf", "patch": "@@ -87,6 +87,8 @@ fn main() {\n         panic!();\n     }\n \n+    test_checked_mul();\n+\n     let _a = 1u32 << 2u8;\n \n     let empty: [i32; 0] = [];\n@@ -258,6 +260,27 @@ unsafe fn test_mm_extract_epi8() {\n     assert_eq!(r2, 3);\n }\n \n+fn test_checked_mul() {\n+    let u: Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n+    assert_eq!(u, None);\n+\n+    assert_eq!(1u8.checked_mul(255u8), Some(255u8));\n+    assert_eq!(255u8.checked_mul(255u8), None);\n+    assert_eq!(1i8.checked_mul(127i8), Some(127i8));\n+    assert_eq!(127i8.checked_mul(127i8), None);\n+    assert_eq!((-1i8).checked_mul(-127i8), Some(127i8));\n+    assert_eq!(1i8.checked_mul(-128i8), Some(-128i8));\n+    assert_eq!((-128i8).checked_mul(-128i8), None);\n+\n+    assert_eq!(1u64.checked_mul(u64::max_value()), Some(u64::max_value()));\n+    assert_eq!(u64::max_value().checked_mul(u64::max_value()), None);\n+    assert_eq!(1i64.checked_mul(i64::max_value()), Some(i64::max_value()));\n+    assert_eq!(i64::max_value().checked_mul(i64::max_value()), None);\n+    assert_eq!((-1i64).checked_mul(i64::min_value() + 1), Some(i64::max_value()));\n+    assert_eq!(1i64.checked_mul(i64::min_value()), Some(i64::min_value()));\n+    assert_eq!(i64::min_value().checked_mul(i64::min_value()), None);\n+}\n+\n #[derive(PartialEq)]\n enum LoopState {\n     Continue(()),"}, {"sha": "bb3a03338f2dae25261a08f397cbe298e2e76911", "filename": "patches/0023-core-Ignore-failing-tests.patch", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/patches%2F0023-core-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/patches%2F0023-core-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0023-core-Ignore-failing-tests.patch?ref=5f54cc7658ffb538fa9ad06727ca0bedd009beaf", "patch": "@@ -30,38 +30,10 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn empty_array_is_always_default() {\n-diff --git a/src/libcore/tests/iter.rs b/src/libcore/tests/iter.rs\n-index c9096b7..be37fcd 100644\n---- a/src/libcore/tests/iter.rs\n-+++ b/src/libcore/tests/iter.rs\n-@@ -342,6 +342,7 @@ fn test_iterator_step_by_nth() {\n- }\n- \n- #[test]\n-+#[ignore] // checked_mul impl not yet checking for overflow\n- fn test_iterator_step_by_nth_overflow() {\n-     #[cfg(target_pointer_width = \"8\")]\n-     type Bigger = u16;\n-@@ -2305,6 +2308,7 @@ fn test_repeat_with_take_collect() {\n- }\n- \n- #[test]\n-+#[ignore] // checked_mul impl not yet checking for overflow\n- fn test_successors() {\n-     let mut powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n-     assert_eq!(powers_of_10.by_ref().collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n diff --git a/src/libcore/tests/num/mod.rs b/src/libcore/tests/num/mod.rs\n index a17c094..5bb11d2 100644\n --- a/src/libcore/tests/num/mod.rs\n +++ b/src/libcore/tests/num/mod.rs\n-@@ -63,6 +63,7 @@ pub fn test_num<T>(ten: T, two: T) where\n- }\n- \n- #[test]\n-+#[ignore] // checked_mul impl not yet checking for overflow\n- fn from_str_issue7588() {\n-     let u: Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n-     assert_eq!(u, None);\n @@ -640,6 +639,7 @@ macro_rules! test_float {\n          mod $modname {\n              // FIXME(nagisa): these tests should test for sign of -0.0\n@@ -78,17 +50,5 @@ index a17c094..5bb11d2 100644\n              fn max() {\n                  assert_eq!((0.0 as $fty).max(0.0), 0.0);\n                  assert_eq!((-0.0 as $fty).max(-0.0), -0.0);\n-diff --git a/src/libcore/tests/time.rs b/src/libcore/tests/time.rs\n-index fac70c4..9107a02 100644\n---- a/src/libcore/tests/time.rs\n-+++ b/src/libcore/tests/time.rs\n-@@ -127,6 +127,7 @@ fn mul() {\n- }\n- \n- #[test]\n-+#[ignore] // checked_mul impl not yet checking for overflow\n- fn checked_mul() {\n-     assert_eq!(Duration::new(0, 1).checked_mul(2), Some(Duration::new(0, 2)));\n-     assert_eq!(Duration::new(1, 1).checked_mul(3), Some(Duration::new(3, 3)));\n -- \n 2.21.0 (Apple Git-122)"}, {"sha": "5cf281cba6f77ef6220ebd937647c00daa5b46fb", "filename": "src/num.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f54cc7658ffb538fa9ad06727ca0bedd009beaf/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=5f54cc7658ffb538fa9ad06727ca0bedd009beaf", "patch": "@@ -245,16 +245,42 @@ pub(crate) fn trans_checked_int_binop<'tcx>(\n             (val, has_overflow)\n         }\n         BinOp::Mul => {\n-            let val = fx.bcx.ins().imul(lhs, rhs);\n-            /*let val_hi = if !signed {\n-                fx.bcx.ins().umulhi(lhs, rhs)\n-            } else {\n-                fx.bcx.ins().smulhi(lhs, rhs)\n-            };\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);*/\n-            // TODO: check for overflow\n-            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n-            (val, has_overflow)\n+            let ty = fx.bcx.func.dfg.value_type(lhs);\n+            match ty {\n+                types::I8 | types::I16 | types::I32 if !signed => {\n+                    let lhs = fx.bcx.ins().uextend(ty.double_width().unwrap(), lhs);\n+                    let rhs = fx.bcx.ins().uextend(ty.double_width().unwrap(), rhs);\n+                    let val = fx.bcx.ins().imul(lhs, rhs);\n+                    let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, val, (1 << ty.bits()) - 1);\n+                    let val = fx.bcx.ins().ireduce(ty, val);\n+                    (val, has_overflow)\n+                }\n+                types::I8 | types::I16 | types::I32 if signed => {\n+                    let lhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), lhs);\n+                    let rhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), rhs);\n+                    let val = fx.bcx.ins().imul(lhs, rhs);\n+                    let has_underflow = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n+                    let has_overflow = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThan, val, (1 << (ty.bits() - 1)) - 1);\n+                    let val = fx.bcx.ins().ireduce(ty, val);\n+                    (val, fx.bcx.ins().bor(has_underflow, has_overflow))\n+                }\n+                types::I64 => {\n+                    //let val = fx.easy_call(\"__mulodi4\", &[lhs, rhs, overflow_ptr], types::I64);\n+                    let val = fx.bcx.ins().imul(lhs, rhs);\n+                    let has_overflow = if !signed {\n+                        let val_hi = fx.bcx.ins().umulhi(lhs, rhs);\n+                        fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0)\n+                    } else {\n+                        let val_hi = fx.bcx.ins().smulhi(lhs, rhs);\n+                        let not_all_zero = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);\n+                        let not_all_ones = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, u64::try_from((1u128 << ty.bits()) - 1).unwrap() as i64);\n+                        fx.bcx.ins().band(not_all_zero, not_all_ones)\n+                    };\n+                    (val, has_overflow)\n+                }\n+                types::I128 => unreachable!(\"i128 should have been handled by codegen_i128::maybe_codegen\"),\n+                _ => unreachable!(\"invalid non-integer type {}\", ty),\n+            }\n         }\n         BinOp::Shl => {\n             let val = fx.bcx.ins().ishl(lhs, rhs);"}]}