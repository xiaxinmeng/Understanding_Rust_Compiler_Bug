{"sha": "2dbd34ffe814e92294992470ac74c57e33372407", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYmQzNGZmZTgxNGU5MjI5NDk5MjQ3MGFjNzRjNTdlMzMzNzI0MDc=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:05Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:05Z"}, "message": "literal representation restructure 2\n\nConsolidate warning handling using \"poor man's try\".", "tree": {"sha": "dd2ed782376c01f2afcc7089afc78be0a14a4d9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd2ed782376c01f2afcc7089afc78be0a14a4d9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dbd34ffe814e92294992470ac74c57e33372407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dbd34ffe814e92294992470ac74c57e33372407", "html_url": "https://github.com/rust-lang/rust/commit/2dbd34ffe814e92294992470ac74c57e33372407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dbd34ffe814e92294992470ac74c57e33372407/comments", "author": null, "committer": null, "parents": [{"sha": "8f5b4f3f5ca62ddb79a0337035919ef488acc9d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5b4f3f5ca62ddb79a0337035919ef488acc9d4", "html_url": "https://github.com/rust-lang/rust/commit/8f5b4f3f5ca62ddb79a0337035919ef488acc9d4"}], "stats": {"total": 88, "additions": 42, "deletions": 46}, "files": [{"sha": "6ea962f0ac365965029a11446c3773b6f3f1cd18", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2dbd34ffe814e92294992470ac74c57e33372407/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dbd34ffe814e92294992470ac74c57e33372407/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=2dbd34ffe814e92294992470ac74c57e33372407", "patch": "@@ -365,54 +365,50 @@ impl LiteralDigitGrouping {\n             if char::is_digit(firstch, 10);\n             then {\n \n+                let digit_info = match lit.kind {\n+                        LitKind::Int(..) => DigitInfo::new(&src, false),\n+                        LitKind::Float(..) => DigitInfo::new(&src, true),\n+                        _ => return,\n+                };\n \n-        match lit.kind {\n-            LitKind::Int(..) => {\n-                // Lint integral literals.\n-                let digit_info = DigitInfo::new(&src, false);\n-                let _ = Self::do_lint(digit_info.digits, digit_info.suffix, in_macro).map_err(|warning_type| {\n+                let result = (|| {\n+                    match lit.kind {\n+                        LitKind::Int(..) => {\n+                            Self::do_lint(digit_info.digits, digit_info.suffix, in_macro)?;\n+                        },\n+                        LitKind::Float(..) => {\n+                            // Separate digits into integral and fractional parts.\n+                            let parts: Vec<&str> = digit_info\n+                                .digits\n+                                .split_terminator('.')\n+                                .collect();\n+\n+                            // Lint integral and fractional parts separately, and then check consistency of digit\n+                            // groups if both pass.\n+                            let integral_group_size = Self::do_lint(parts[0], digit_info.suffix, in_macro)?;\n+                            if parts.len() > 1 {\n+                                // Lint the fractional part of literal just like integral part, but reversed.\n+                                let fractional_part = &parts[1].chars().rev().collect::<String>();\n+                                let fractional_group_size = Self::do_lint(fractional_part, None, in_macro)?;\n+                                let consistent = Self::parts_consistent(integral_group_size,\n+                                                                        fractional_group_size,\n+                                                                        parts[0].len(),\n+                                                                        parts[1].len());\n+                                if !consistent {\n+                                    return Err(WarningType::InconsistentDigitGrouping);\n+                                };\n+                            };\n+                        },\n+                        _ => (),\n+                    }\n+\n+                    Ok(())\n+                })();\n+\n+\n+                if let Err(warning_type) = result {\n                     warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n-                });\n-            },\n-            LitKind::Float(..) => {\n-                // Lint floating-point literals.\n-                let digit_info = DigitInfo::new(&src, true);\n-                // Separate digits into integral and fractional parts.\n-                let parts: Vec<&str> = digit_info\n-                    .digits\n-                    .split_terminator('.')\n-                    .collect();\n-\n-                // Lint integral and fractional parts separately, and then check consistency of digit\n-                // groups if both pass.\n-                let _ = Self::do_lint(parts[0], digit_info.suffix, in_macro)\n-                    .map(|integral_group_size| {\n-                        if parts.len() > 1 {\n-                            // Lint the fractional part of literal just like integral part, but reversed.\n-                            let fractional_part = &parts[1].chars().rev().collect::<String>();\n-                            let _ = Self::do_lint(fractional_part, None, in_macro)\n-                                .map(|fractional_group_size| {\n-                                    let consistent = Self::parts_consistent(integral_group_size,\n-                                                                            fractional_group_size,\n-                                                                            parts[0].len(),\n-                                                                            parts[1].len());\n-                                        if !consistent {\n-                                            WarningType::InconsistentDigitGrouping.display(\n-                                                &digit_info.grouping_hint(),\n-                                                cx,\n-                                                lit.span,\n-                                            );\n-                                        }\n-                                })\n-                            .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),\n-                            cx,\n-                            lit.span));\n-                        }\n-                    })\n-                .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, lit.span));\n-            },\n-            _ => (),\n-        }\n+                }\n             }\n         }\n     }"}]}