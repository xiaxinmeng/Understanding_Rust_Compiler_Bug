{"sha": "655634e6ab00707ef98034dcfb32000cbfa7a01c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NTYzNGU2YWIwMDcwN2VmOTgwMzRkY2ZiMzIwMDBjYmZhN2EwMWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-01T20:56:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-01T20:56:20Z"}, "message": "rollup merge of #23949: aturon/stab-timeout\n\nThis commit renames and stabilizes:\n\n* `Condvar::wait_timeout_ms` (renamed from `wait_timeout`)\n* `thread::park_timeout_ms` (renamed from `park_timeout`)\n* `thread::sleep_ms` (renamed from `sleep`)\n\nIn each case, the timeout is taken as a `u32` number of milliseconds,\nrather than a `Duration`.\n\nThese functions are likely to be deprecated once a stable form of\n`Duration` is available, but there is little cost to having these named\nvariants around, and it's crucial functionality for 1.0.\n\n[breaking-change]\n\nr? @alexcrichton\n\ncc @sfackler @carllerche", "tree": {"sha": "7222d7fe7e9a1be7f04eabaa557e21bb370c2978", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7222d7fe7e9a1be7f04eabaa557e21bb370c2978"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/655634e6ab00707ef98034dcfb32000cbfa7a01c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/655634e6ab00707ef98034dcfb32000cbfa7a01c", "html_url": "https://github.com/rust-lang/rust/commit/655634e6ab00707ef98034dcfb32000cbfa7a01c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/655634e6ab00707ef98034dcfb32000cbfa7a01c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb252a8878882013aa5d5a3bb2af93d6cb51a85f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb252a8878882013aa5d5a3bb2af93d6cb51a85f", "html_url": "https://github.com/rust-lang/rust/commit/bb252a8878882013aa5d5a3bb2af93d6cb51a85f"}, {"sha": "371277fb0d210152eb8c79e30bd7f7749c5af63c", "url": "https://api.github.com/repos/rust-lang/rust/commits/371277fb0d210152eb8c79e30bd7f7749c5af63c", "html_url": "https://github.com/rust-lang/rust/commit/371277fb0d210152eb8c79e30bd7f7749c5af63c"}], "stats": {"total": 82, "additions": 54, "deletions": 28}, "files": [{"sha": "a7d8b287a64c031567a8605f50c69fb8ef6dc9a8", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/655634e6ab00707ef98034dcfb32000cbfa7a01c/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655634e6ab00707ef98034dcfb32000cbfa7a01c/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=655634e6ab00707ef98034dcfb32000cbfa7a01c", "patch": "@@ -140,33 +140,43 @@ impl Condvar {\n     /// Wait on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n-    /// The semantics of this function are equivalent to `wait()` except that\n-    /// the thread will be blocked for roughly no longer than `dur`. This method\n-    /// should not be used for precise timing due to anomalies such as\n-    /// preemption or platform differences that may not cause the maximum amount\n-    /// of time waited to be precisely `dur`.\n+    /// The semantics of this function are equivalent to `wait()`\n+    /// except that the thread will be blocked for roughly no longer\n+    /// than `ms` milliseconds. This method should not be used for\n+    /// precise timing due to anomalies such as preemption or platform\n+    /// differences that may not cause the maximum amount of time\n+    /// waited to be precisely `ms`.\n     ///\n-    /// If the wait timed out, then `false` will be returned. Otherwise if a\n-    /// notification was received then `true` will be returned.\n+    /// The returned boolean is `false` only if the timeout is known\n+    /// to have elapsed.\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n-                           -> LockResult<(MutexGuard<'a, T>, bool)> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn wait_timeout_ms<'a, T>(&self, guard: MutexGuard<'a, T>, ms: u32)\n+                                  -> LockResult<(MutexGuard<'a, T>, bool)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait_timeout(guard, dur)\n+            me.inner.wait_timeout_ms(guard, ms)\n         }\n     }\n \n+    /// Deprecated: use `wait_timeout_ms` instead.\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use wait_timeout_ms instead\")]\n+    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n+                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+        self.wait_timeout_ms(guard, dur.num_milliseconds() as u32)\n+    }\n+\n     /// Wait on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n     /// The semantics of this function are equivalent to `wait_timeout` except\n     /// that the implementation will repeatedly wait while the duration has not\n     /// passed and the provided function returns `false`.\n-    #[unstable(feature = \"std_misc\")]\n+    #[unstable(feature = \"wait_timeout_with\",\n+               reason = \"unsure if this API is broadly needed or what form it should take\")]\n     pub fn wait_timeout_with<'a, T, F>(&self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n@@ -235,12 +245,12 @@ impl StaticCondvar {\n     /// See `Condvar::wait_timeout`.\n     #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Condvar in the future\")]\n-    pub fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+    pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)\n+                                  -> LockResult<(MutexGuard<'a, T>, bool)> {\n         let (poisoned, success) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n             self.verify(lock);\n-            let success = self.inner.wait_timeout(lock, dur);\n+            let success = self.inner.wait_timeout(lock, Duration::milliseconds(ms as i64));\n             (mutex::guard_poison(&guard).get(), success)\n         };\n         if poisoned {\n@@ -275,7 +285,8 @@ impl StaticCondvar {\n             let now = SteadyTime::now();\n             let consumed = &now - &start;\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n-            let (new_guard_result, no_timeout) = match self.wait_timeout(guard, dur - consumed) {\n+            let res = self.wait_timeout_ms(guard, (dur - consumed).num_milliseconds() as u32);\n+            let (new_guard_result, no_timeout) = match res {\n                 Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n                 Err(err) => {\n                     let (new_guard, no_timeout) = err.into_inner();\n@@ -350,6 +361,7 @@ mod tests {\n     use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n     use thread;\n     use time::Duration;\n+    use u32;\n \n     #[test]\n     fn smoke() {\n@@ -418,19 +430,19 @@ mod tests {\n     }\n \n     #[test]\n-    fn wait_timeout() {\n+    fn wait_timeout_ms() {\n         static C: StaticCondvar = CONDVAR_INIT;\n         static M: StaticMutex = MUTEX_INIT;\n \n         let g = M.lock().unwrap();\n-        let (g, _no_timeout) = C.wait_timeout(g, Duration::nanoseconds(1000)).unwrap();\n+        let (g, _no_timeout) = C.wait_timeout_ms(g, 1).unwrap();\n         // spurious wakeups mean this isn't necessarily true\n         // assert!(!no_timeout);\n         let _t = thread::spawn(move || {\n             let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n-        let (g, no_timeout) = C.wait_timeout(g, Duration::days(1)).unwrap();\n+        let (g, no_timeout) = C.wait_timeout_ms(g, u32::MAX).unwrap();\n         assert!(no_timeout);\n         drop(g);\n         unsafe { C.destroy(); M.destroy(); }"}, {"sha": "5fe6e80d6e93a0c851b2c857e9d220b6f6c14051", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/655634e6ab00707ef98034dcfb32000cbfa7a01c/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655634e6ab00707ef98034dcfb32000cbfa7a01c/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=655634e6ab00707ef98034dcfb32000cbfa7a01c", "patch": "@@ -469,9 +469,16 @@ pub fn catch_panic<F, R>(f: F) -> Result<R>\n /// specifics or platform-dependent functionality. Note that on unix platforms\n /// this function will not return early due to a signal being received or a\n /// spurious wakeup.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn sleep_ms(ms: u32) {\n+    imp::sleep(Duration::milliseconds(ms as i64))\n+}\n+\n+/// Deprecated: use `sleep_ms` instead.\n #[unstable(feature = \"thread_sleep\",\n            reason = \"recently added, needs an RFC, and `Duration` itself is \\\n                      unstable\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use sleep_ms instead\")]\n pub fn sleep(dur: Duration) {\n     imp::sleep(dur)\n }\n@@ -505,17 +512,24 @@ pub fn park() {\n /// amount of time waited to be precisely *duration* long.\n ///\n /// See the module doc for more detail.\n-#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n-pub fn park_timeout(duration: Duration) {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn park_timeout_ms(ms: u32) {\n     let thread = current();\n     let mut guard = thread.inner.lock.lock().unwrap();\n     if !*guard {\n-        let (g, _) = thread.inner.cvar.wait_timeout(guard, duration).unwrap();\n+        let (g, _) = thread.inner.cvar.wait_timeout_ms(guard, ms).unwrap();\n         guard = g;\n     }\n     *guard = false;\n }\n \n+/// Deprecated: use `park_timeout_ms`\n+#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use park_timeout_ms instead\")]\n+pub fn park_timeout(duration: Duration) {\n+    park_timeout_ms(duration.num_milliseconds() as u32)\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Thread\n ////////////////////////////////////////////////////////////////////////////////\n@@ -720,6 +734,7 @@ mod test {\n     use thread;\n     use thunk::Thunk;\n     use time::Duration;\n+    use u32;\n \n     // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n     // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n@@ -940,14 +955,14 @@ mod test {\n     fn test_park_timeout_unpark_before() {\n         for _ in 0..10 {\n             thread::current().unpark();\n-            thread::park_timeout(Duration::seconds(10_000_000));\n+            thread::park_timeout_ms(u32::MAX);\n         }\n     }\n \n     #[test]\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n-            thread::park_timeout(Duration::milliseconds(10));\n+            thread::park_timeout_ms(10);\n         }\n     }\n \n@@ -963,14 +978,13 @@ mod test {\n                 th.unpark();\n             });\n \n-            thread::park_timeout(Duration::seconds(10_000_000));\n+            thread::park_timeout_ms(u32::MAX);\n         }\n     }\n \n     #[test]\n-    fn sleep_smoke() {\n-        thread::sleep(Duration::milliseconds(2));\n-        thread::sleep(Duration::milliseconds(-2));\n+    fn sleep_ms_smoke() {\n+        thread::sleep_ms(2);\n     }\n \n     // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due"}]}