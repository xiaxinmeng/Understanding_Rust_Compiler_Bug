{"sha": "5f0e494d9d7c7c4c866414abd7701d22902415b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMGU0OTRkOWQ3YzdjNGM4NjY0MTRhYmQ3NzAxZDIyOTAyNDE1YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-17T14:43:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-17T14:43:06Z"}, "message": "auto merge of #7174 : SiegeLord/rust/remove_trim, r=brson\n\nThis change prevents the indentation in code blocks inside the /// doc comments\r\nfrom being eaten. The indentation that is the same across the consecutive doc\r\ncomments is removed by the uindent_pass in librustdoc.\r\n\r\nThe bug can be seen, e.g., here: http://static.rust-lang.org/doc/std/iterator.html#example-12\r\n\r\nI also altered how the block comments are treated, for consistency. There isn't much testing done on the documentation output (I added a few tests of my own for the modified function), so I don't know if anything relied on the previous behavior. I checked a number of documentation files and observed either no change in output or changes that consistent of the above bug being fixed.", "tree": {"sha": "72fc98d63291327369b79ba4c097ed4eed0871f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72fc98d63291327369b79ba4c097ed4eed0871f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f0e494d9d7c7c4c866414abd7701d22902415b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f0e494d9d7c7c4c866414abd7701d22902415b6", "html_url": "https://github.com/rust-lang/rust/commit/5f0e494d9d7c7c4c866414abd7701d22902415b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f0e494d9d7c7c4c866414abd7701d22902415b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fbd5383f96cf0d79279e7ce903d3634ebe450d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fbd5383f96cf0d79279e7ce903d3634ebe450d9", "html_url": "https://github.com/rust-lang/rust/commit/6fbd5383f96cf0d79279e7ce903d3634ebe450d9"}, {"sha": "6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d", "html_url": "https://github.com/rust-lang/rust/commit/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d"}], "stats": {"total": 92, "additions": 67, "deletions": 25}, "files": [{"sha": "1abdae113c597bb751e95e2df1dd5488191f0dd3", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f0e494d9d7c7c4c866414abd7701d22902415b6/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f0e494d9d7c7c4c866414abd7701d22902415b6/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=5f0e494d9d7c7c4c866414abd7701d22902415b6", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -152,6 +152,6 @@ mod test {\n     fn should_concatenate_multiple_doc_comments() {\n         let source = @\"/// foo\\n/// bar\";\n         let desc = parse_desc(parse_attributes(source));\n-        assert!(desc == Some(~\"foo\\nbar\"));\n+        assert!(desc == Some(~\" foo\\n bar\"));\n     }\n }"}, {"sha": "472f807cd8b682a6b8f0241a73d07039d23f4358", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5f0e494d9d7c7c4c866414abd7701d22902415b6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f0e494d9d7c7c4c866414abd7701d22902415b6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=5f0e494d9d7c7c4c866414abd7701d22902415b6", "patch": "@@ -69,50 +69,59 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         return lines.slice(i, j).to_owned();\n     }\n \n-    // drop leftmost columns that contain only values in chars\n-    fn block_trim(lines: ~[~str], chars: ~str, max: Option<uint>) -> ~[~str] {\n-\n-        let mut i = max.get_or_default(uint::max_value);\n-        for lines.each |line| {\n-            if line.trim().is_empty() {\n-                loop;\n-            }\n+    /// remove a \"[ \\t]*\\*\" block from each line, if possible\n+    fn horizontal_trim(lines: ~[~str]) -> ~[~str] {\n+        let mut i = uint::max_value;\n+        let mut can_trim = true;\n+        let mut first = true;\n+        for lines.iter().advance |line| {\n             for line.iter().enumerate().advance |(j, c)| {\n-                if j >= i {\n+                if j > i || !\"* \\t\".contains_char(c) {\n+                    can_trim = false;\n                     break;\n                 }\n-                if !chars.contains_char(c) {\n-                    i = j;\n+                if c == '*' {\n+                    if first {\n+                        i = j;\n+                        first = false;\n+                    } else if i != j {\n+                        can_trim = false;\n+                    }\n                     break;\n                 }\n             }\n+            if i > line.len() {\n+                can_trim = false;\n+            }\n+            if !can_trim {\n+                break;\n+            }\n         }\n \n-        return do lines.map |line| {\n-            let chars = line.iter().collect::<~[char]>();\n-            if i > chars.len() {\n-                ~\"\"\n-            } else {\n-                str::from_chars(chars.slice(i, chars.len()))\n+        if can_trim {\n+            do lines.map |line| {\n+                line.slice(i + 1, line.len()).to_owned()\n             }\n-        };\n+        } else {\n+            lines\n+        }\n     }\n \n     if comment.starts_with(\"//\") {\n         // FIXME #5475:\n-        // return comment.slice(3u, comment.len()).trim().to_owned();\n-        let r = comment.slice(3u, comment.len()); return r.trim().to_owned();\n+        // return comment.slice(3u, comment.len()).to_owned();\n+        let r = comment.slice(3u, comment.len()); return r.to_owned();\n     }\n \n     if comment.starts_with(\"/*\") {\n         let lines = comment.slice(3u, comment.len() - 2u)\n             .any_line_iter()\n             .transform(|s| s.to_owned())\n             .collect::<~[~str]>();\n+\n         let lines = vertical_trim(lines);\n-        let lines = block_trim(lines, ~\"\\t \", None);\n-        let lines = block_trim(lines, ~\"*\", Some(1u));\n-        let lines = block_trim(lines, ~\"\\t \", None);\n+        let lines = horizontal_trim(lines);\n+\n         return lines.connect(\"\\n\");\n     }\n \n@@ -370,3 +379,36 @@ pub fn gather_comments_and_literals(span_diagnostic:\n \n     (comments, literals)\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test] fn test_block_doc_comment_1() {\n+        let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n+        let correct_stripped = \" Test \\n*  Test\\n   Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_block_doc_comment_2() {\n+        let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n+        let correct_stripped = \" Test\\n  Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_block_doc_comment_3() {\n+        let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n+        let correct_stripped = \" let a: *int;\\n *a = 5;\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_line_doc_comment() {\n+        let comment = \"/// Test\";\n+        let correct_stripped = \" Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+}"}]}