{"sha": "b74208bc12390b168e4a342de27d806639d89ffe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NDIwOGJjMTIzOTBiMTY4ZTRhMzQyZGUyN2Q4MDY2MzlkODlmZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-10T03:02:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-10T03:02:02Z"}, "message": "auto merge of #17669 : nikomatsakis/rust/multidispatch, r=pcwalton\n\nImplement multidispatch and conditional dispatch. Because we do not attempt to preserve crate concatenation, this is a backwards compatible change. This is not yet fully integrated into method dispatch, so \"UFCS\"-style wrappers must be used to take advantage of the new features (see the run-pass tests).\r\n\r\ncc #17307 (multidispatch)\r\ncc #5527 (trait reform -- conditional dispatch)\r\n\r\nBecause we no longer preserve crate concatenability, this deviates slightly from what was specified in the RFC. The motivation for this change is described in [this blog post](http://smallcultfollowing.com/babysteps/blog/2014/09/30/multi-and-conditional-dispatch-in-traits/). I will post an amendment to the RFC in due course but do not anticipate great controversy on this point -- particularly as the RFCs more important features (e.g., conditional dispatch) just don't work without the change.", "tree": {"sha": "c76e2b602d7fbc51d40b027eab2b37b901476e9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c76e2b602d7fbc51d40b027eab2b37b901476e9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b74208bc12390b168e4a342de27d806639d89ffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b74208bc12390b168e4a342de27d806639d89ffe", "html_url": "https://github.com/rust-lang/rust/commit/b74208bc12390b168e4a342de27d806639d89ffe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b74208bc12390b168e4a342de27d806639d89ffe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "html_url": "https://github.com/rust-lang/rust/commit/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d"}, {"sha": "7a07f2a78092b3381d44a86330eb2de364aafb95", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a07f2a78092b3381d44a86330eb2de364aafb95", "html_url": "https://github.com/rust-lang/rust/commit/7a07f2a78092b3381d44a86330eb2de364aafb95"}], "stats": {"total": 2372, "additions": 1602, "deletions": 770}, "files": [{"sha": "e05a3237b264b7992d30e469b28b5f1ae6d4d02d", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -417,6 +417,10 @@ impl<T> VecPerParamSpace<T> {\n         self.content.iter()\n     }\n \n+    pub fn as_slice(&self) -> &[T] {\n+        self.content.as_slice()\n+    }\n+\n     pub fn all_vecs(&self, pred: |&[T]| -> bool) -> bool {\n         let spaces = [TypeSpace, SelfSpace, FnSpace];\n         spaces.iter().all(|&space| { pred(self.get_slice(space)) })"}, {"sha": "6dc7fbf5d7cd8c3bd416fc7e7d3e5d37e5c053e7", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -10,9 +10,8 @@\n \n /*! See `doc.rs` for high-level documentation */\n \n-use super::{EvaluatedToMatch, EvaluatedToAmbiguity, EvaluatedToUnmatch};\n-use super::{evaluate_impl};\n-use super::ObligationCause;\n+use super::SelectionContext;\n+use super::Obligation;\n use super::util;\n \n use middle::subst;\n@@ -28,22 +27,26 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n                         impl2_def_id: ast::DefId)\n                         -> bool\n {\n+    debug!(\"impl_can_satisfy(\\\n+           impl1_def_id={}, \\\n+           impl2_def_id={})\",\n+           impl1_def_id.repr(infcx.tcx),\n+           impl2_def_id.repr(infcx.tcx));\n+\n     // `impl1` provides an implementation of `Foo<X,Y> for Z`.\n     let impl1_substs =\n         util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n-    let impl1_self_ty =\n+    let impl1_trait_ref =\n         ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()\n-            .self_ty()\n             .subst(infcx.tcx, &impl1_substs);\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n-    match evaluate_impl(infcx, &param_env, infcx.tcx, ObligationCause::dummy(),\n-                        impl2_def_id, impl1_self_ty) {\n-        EvaluatedToMatch | EvaluatedToAmbiguity => true,\n-        EvaluatedToUnmatch => false,\n-    }\n+    let mut selcx = SelectionContext::new(infcx, &param_env, infcx.tcx);\n+    let obligation = Obligation::misc(DUMMY_SP, impl1_trait_ref);\n+    debug!(\"impl_can_satisfy obligation={}\", obligation.repr(infcx.tcx));\n+    selcx.evaluate_impl(impl2_def_id, &obligation)\n }\n \n pub fn impl_is_local(tcx: &ty::ctxt,"}, {"sha": "742c4cb5de031417f579de6fd462d2fe6b3c8d1c", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 87, "deletions": 80, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -57,7 +57,8 @@ Trait resolution consists of three major parts:\n   resolved by employing an impl which matches the self type, or by\n   using a parameter bound. In the case of an impl, Selecting one\n   obligation can create *nested obligations* because of where clauses\n-  on the impl itself.\n+  on the impl itself. It may also require evaluating those nested\n+  obligations to resolve ambiguities.\n \n - FULFILLMENT: The fulfillment code is what tracks that obligations\n   are completely fulfilled. Basically it is a worklist of obligations\n@@ -100,80 +101,88 @@ candidate that is definitively applicable. In some cases, we may not\n know whether an impl/where-clause applies or not -- this occurs when\n the obligation contains unbound inference variables.\n \n-One important point is that candidate assembly considers *only the\n-input types* of the obligation when deciding whether an impl applies\n-or not. Consider the following example:\n-\n-    trait Convert<T> { // T is output, Self is input\n-        fn convert(&self) -> T;\n-    }\n-\n-    impl Convert<uint> for int { ... }\n-\n-Now assume we have an obligation `int : Convert<char>`. During\n-candidate assembly, the impl above would be considered a definitively\n-applicable candidate, because it has the same self type (`int`). The\n-fact that the output type parameter `T` is `uint` on the impl and\n-`char` in the obligation is not considered.\n-\n-#### Skolemization\n-\n-We (at least currently) wish to guarantee \"crate concatenability\" --\n-which basically means that you could take two crates, concatenate\n-them textually, and the combined crate would continue to compile. The\n-only real way that this relates to trait matching is with\n-inference. We have to be careful not to influence unbound type\n-variables during the selection process, basically.\n-\n-Here is an example:\n-\n-    trait Foo { fn method() { ... }}\n-    impl Foo for int { ... }\n-\n-    fn something() {\n-        let mut x = None; // `x` has type `Option<?>`\n-        loop {\n-            match x {\n-                Some(ref y) => { // `y` has type ?\n-                    y.method();  // (*)\n-                    ...\n-        }}}\n-    }\n-\n-The question is, can we resolve the call to `y.method()`? We don't yet\n-know what type `y` has. However, there is only one impl in scope, and\n-it is for `int`, so perhaps we could deduce that `y` *must* have type\n-`int` (and hence the type of `x` is `Option<int>`)? This is actually\n-sound reasoning: `int` is the only type in scope that could possibly\n-make this program type check. However, this deduction is a bit\n-\"unstable\", though, because if we concatenated with another crate that\n-defined a newtype and implemented `Foo` for this newtype, then the\n-inference would fail, because there would be two potential impls, not\n-one.\n-\n-It is unclear how important this property is. It might be nice to drop it.\n-But for the time being we maintain it.\n-\n-The way we do this is by *skolemizing* the obligation self type during\n-the selection process -- skolemizing means, basically, replacing all\n-unbound type variables with a new \"skolemized\" type. Each skolemized\n-type is basically considered \"as if\" it were some fresh type that is\n-distinct from all other types. The skolemization process also replaces\n-lifetimes with `'static`, see the section on lifetimes below for an\n-explanation.\n-\n-In the example above, this means that when matching `y.method()` we\n-would convert the type of `y` from a type variable `?` to a skolemized\n-type `X`. Then, since `X` cannot unify with `int`, the match would\n-fail.  Special code exists to check that the match failed because a\n-skolemized type could not be unified with another kind of type -- this is\n-not considered a definitive failure, but rather an ambiguous result,\n-since if the type variable were later to be unified with int, then this\n-obligation could be resolved then.\n-\n-*Note:* Currently, method matching does not use the trait resolution\n-code, so if you in fact type in the example above, it may\n-compile. Hopefully this will be fixed in later patches.\n+The basic idea for candidate assembly is to do a first pass in which\n+we identify all possible candidates. During this pass, all that we do\n+is try and unify the type parameters. (In particular, we ignore any\n+nested where clauses.) Presuming that this unification succeeds, the\n+impl is added as a candidate.\n+\n+Once this first pass is done, we can examine the set of candidates. If\n+it is a singleton set, then we are done: this is the only impl in\n+scope that could possibly apply. Otherwise, we can winnow down the set\n+of candidates by using where clauses and other conditions. If this\n+reduced set yields a single, unambiguous entry, we're good to go,\n+otherwise the result is considered ambiguous.\n+\n+#### The basic process: Inferring based on the impls we see\n+\n+This process is easier if we work through some examples. Consider\n+the following trait:\n+\n+```\n+trait Convert<Target> {\n+    fn convert(&self) -> Target;\n+}\n+```\n+\n+This trait just has one method. It's about as simple as it gets. It\n+converts from the (implicit) `Self` type to the `Target` type. If we\n+wanted to permit conversion between `int` and `uint`, we might\n+implement `Convert` like so:\n+\n+```rust\n+impl Convert<uint> for int { ... } // int -> uint\n+impl Convert<int> for uint { ... } // uint -> uint\n+```\n+\n+Now imagine there is some code like the following:\n+\n+```rust\n+let x: int = ...;\n+let y = x.convert();\n+```\n+\n+The call to convert will generate a trait reference `Convert<$Y> for\n+int`, where `$Y` is the type variable representing the type of\n+`y`. When we match this against the two impls we can see, we will find\n+that only one remains: `Convert<uint> for int`. Therefore, we can\n+select this impl, which will cause the type of `$Y` to be unified to\n+`uint`. (Note that while assembling candidates, we do the initial\n+unifications in a transaction, so that they don't affect one another.)\n+\n+There are tests to this effect in src/test/run-pass:\n+\n+   traits-multidispatch-infer-convert-source-and-target.rs\n+   traits-multidispatch-infer-convert-target.rs\n+\n+#### Winnowing: Resolving ambiguities\n+\n+But what happens if there are multiple impls where all the types\n+unify? Consider this example:\n+\n+```rust\n+trait Get {\n+    fn get(&self) -> Self;\n+}\n+\n+impl<T:Copy> Get for T {\n+    fn get(&self) -> T { *self }\n+}\n+\n+impl<T:Get> Get for Box<T> {\n+    fn get(&self) -> Box<T> { box get_it(&**self) }\n+}\n+```\n+\n+What happens when we invoke `get_it(&box 1_u16)`, for example? In this\n+case, the `Self` type is `Box<u16>` -- that unifies with both impls,\n+because the first applies to all types, and the second to all\n+boxes. In the olden days we'd have called this ambiguous. But what we\n+do now is do a second *winnowing* pass that considers where clauses\n+and attempts to remove candidates -- in this case, the first impl only\n+applies if `Box<u16> : Copy`, which doesn't hold. After winnowing,\n+then, we are left with just one candidate, so we can proceed. There is\n+a test of this in `src/test/run-pass/traits-conditional-dispatch.rs`.\n \n #### Matching\n \n@@ -187,11 +196,9 @@ consider some of the nested obligations, in the case of an impl.\n Because of how that lifetime inference works, it is not possible to\n give back immediate feedback as to whether a unification or subtype\n relationship between lifetimes holds or not. Therefore, lifetime\n-matching is *not* considered during selection. This is achieved by\n-having the skolemization process just replace *ALL* lifetimes with\n-`'static`. Later, during confirmation, the non-skolemized self-type\n-will be unified with the type from the impl (or whatever). This may\n-yield lifetime constraints that will later be found to be in error (in\n+matching is *not* considered during selection. This is reflected in\n+the fact that subregion assignment is infallible. This may yield\n+lifetime constraints that will later be found to be in error (in\n contrast, the non-lifetime-constraints have already been checked\n during selection and can never cause an error, though naturally they\n may lead to other errors downstream)."}, {"sha": "fb2674212455770832fe032f3290f695ed809f02", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -17,6 +17,7 @@ use middle::subst;\n use middle::ty;\n use middle::typeck::infer::InferCtxt;\n use std::rc::Rc;\n+use std::slice::Items;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -123,13 +124,6 @@ pub enum FulfillmentErrorCode {\n  */\n pub type SelectionResult<T> = Result<Option<T>, SelectionError>;\n \n-#[deriving(PartialEq,Eq,Show)]\n-pub enum EvaluationResult {\n-    EvaluatedToMatch,\n-    EvaluatedToAmbiguity,\n-    EvaluatedToUnmatch\n-}\n-\n /**\n  * Given the successful resolution of an obligation, the `Vtable`\n  * indicates where the vtable comes from. Note that while we call this\n@@ -186,7 +180,7 @@ pub enum Vtable<N> {\n     VtableParam(VtableParamData),\n \n     /// Successful resolution for a builtin trait.\n-    VtableBuiltin,\n+    VtableBuiltin(VtableBuiltinData<N>),\n }\n \n /**\n@@ -208,12 +202,17 @@ pub struct VtableImplData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n+#[deriving(Show,Clone)]\n+pub struct VtableBuiltinData<N> {\n+    pub nested: subst::VecPerParamSpace<N>\n+}\n+\n /**\n  * A vtable provided as a parameter by the caller. For example, in a\n  * function like `fn foo<T:Eq>(...)`, if the `eq()` method is invoked\n  * on an instance of `T`, the vtable would be of type `VtableParam`.\n  */\n-#[deriving(Clone)]\n+#[deriving(PartialEq,Eq,Clone)]\n pub struct VtableParamData {\n     // In the above example, this would `Eq`\n     pub bound: Rc<ty::TraitRef>,\n@@ -223,7 +222,7 @@ pub fn evaluate_obligation<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                     param_env: &ty::ParameterEnvironment,\n                                     obligation: &Obligation,\n                                     typer: &Typer<'tcx>)\n-                                    -> EvaluationResult\n+                                    -> bool\n {\n     /*!\n      * Attempts to resolve the obligation given. Returns `None` if\n@@ -235,29 +234,6 @@ pub fn evaluate_obligation<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     selcx.evaluate_obligation(obligation)\n }\n \n-pub fn evaluate_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                              param_env: &ty::ParameterEnvironment,\n-                              typer: &Typer<'tcx>,\n-                              cause: ObligationCause,\n-                              impl_def_id: ast::DefId,\n-                              self_ty: ty::t)\n-                              -> EvaluationResult\n-{\n-    /*!\n-     * Tests whether the impl `impl_def_id` can be applied to the self\n-     * type `self_ty`. This is similar to \"selection\", but simpler:\n-     *\n-     * - It does not take a full trait-ref as input, so it skips over\n-     *   the \"confirmation\" step which would reconcile output type\n-     *   parameters.\n-     * - It returns an `EvaluationResult`, which is a tri-value return\n-     *   (yes/no/unknown).\n-     */\n-\n-    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n-    selcx.evaluate_impl(impl_def_id, cause, self_ty)\n-}\n-\n pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                      param_env: &ty::ParameterEnvironment,\n                                      typer: &Typer<'tcx>,\n@@ -372,12 +348,21 @@ impl ObligationCause {\n }\n \n impl<N> Vtable<N> {\n+    pub fn iter_nested(&self) -> Items<N> {\n+        match *self {\n+            VtableImpl(ref i) => i.iter_nested(),\n+            VtableUnboxedClosure(_) => (&[]).iter(),\n+            VtableParam(_) => (&[]).iter(),\n+            VtableBuiltin(ref i) => i.iter_nested(),\n+        }\n+    }\n+\n     pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<M> {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableUnboxedClosure(d) => VtableUnboxedClosure(d),\n             VtableParam(ref p) => VtableParam((*p).clone()),\n-            VtableBuiltin => VtableBuiltin,\n+            VtableBuiltin(ref i) => VtableBuiltin(i.map_nested(op)),\n         }\n     }\n \n@@ -386,12 +371,16 @@ impl<N> Vtable<N> {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableUnboxedClosure(d) => VtableUnboxedClosure(d),\n             VtableParam(p) => VtableParam(p),\n-            VtableBuiltin => VtableBuiltin,\n+            VtableBuiltin(i) => VtableBuiltin(i.map_move_nested(op)),\n         }\n     }\n }\n \n impl<N> VtableImplData<N> {\n+    pub fn iter_nested(&self) -> Items<N> {\n+        self.nested.iter()\n+    }\n+\n     pub fn map_nested<M>(&self,\n                          op: |&N| -> M)\n                          -> VtableImplData<M>\n@@ -413,11 +402,23 @@ impl<N> VtableImplData<N> {\n     }\n }\n \n-impl EvaluationResult {\n-    pub fn potentially_applicable(&self) -> bool {\n-        match *self {\n-            EvaluatedToMatch | EvaluatedToAmbiguity => true,\n-            EvaluatedToUnmatch => false\n+impl<N> VtableBuiltinData<N> {\n+    pub fn iter_nested(&self) -> Items<N> {\n+        self.nested.iter()\n+    }\n+\n+    pub fn map_nested<M>(&self,\n+                         op: |&N| -> M)\n+                         -> VtableBuiltinData<M>\n+    {\n+        VtableBuiltinData {\n+            nested: self.nested.map(op)\n+        }\n+    }\n+\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableBuiltinData<M> {\n+        VtableBuiltinData {\n+            nested: self.nested.map_move(op)\n         }\n     }\n }\n@@ -428,4 +429,12 @@ impl FulfillmentError {\n     {\n         FulfillmentError { obligation: obligation, code: code }\n     }\n+\n+    pub fn is_overflow(&self) -> bool {\n+        match self.code {\n+            CodeAmbiguity => false,\n+            CodeSelectionError(Overflow) => true,\n+            CodeSelectionError(_) => false,\n+        }\n+    }\n }"}, {"sha": "305528a9af8fa95806eec0ab2e5eaee27607a4a3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 652, "deletions": 528, "changes": 1180, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -9,60 +9,58 @@\n // except according to those terms.\n \n /*! See `doc.rs` for high-level documentation */\n+#![allow(dead_code)] // FIXME -- just temporarily\n \n+use super::{ErrorReported};\n use super::{Obligation, ObligationCause};\n-use super::{EvaluationResult, EvaluatedToMatch,\n-            EvaluatedToAmbiguity, EvaluatedToUnmatch};\n use super::{SelectionError, Unimplemented, Overflow,\n             OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure};\n-use super::{VtableImplData, VtableParamData};\n+use super::{VtableImplData, VtableParamData, VtableBuiltinData};\n use super::{util};\n \n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::ty;\n-use middle::ty_fold::TypeFoldable;\n use middle::typeck::check::regionmanip;\n use middle::typeck::infer;\n use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n+use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n use std::collections::hashmap::HashMap;\n use std::rc::Rc;\n+use std::result;\n use syntax::ast;\n use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     param_env: &'cx ty::ParameterEnvironment,\n     typer: &'cx Typer<'tcx>+'cx,\n+\n+    /// Skolemizer used specifically for skolemizing entries on the\n+    /// obligation stack. This ensures that all entries on the stack\n+    /// at one time will have the same set of skolemized entries,\n+    /// which is important for checking for trait bounds that\n+    /// recursively require themselves.\n     skolemizer: TypeSkolemizer<'cx, 'tcx>,\n }\n \n // A stack that walks back up the stack frame.\n struct ObligationStack<'prev> {\n     obligation: &'prev Obligation,\n-    skol_obligation_self_ty: ty::t,\n-    previous: Option<&'prev ObligationStack<'prev>>\n-}\n \n-pub struct SelectionCache {\n-    hashmap: RefCell<HashMap<CacheKey, SelectionResult<Candidate>>>,\n-}\n+    /// Trait ref from `obligation` but skolemized with the\n+    /// selection-context's skolemizer. Used to check for recursion.\n+    skol_trait_ref: Rc<ty::TraitRef>,\n \n-#[deriving(Hash,Eq,PartialEq)]\n-struct CacheKey {\n-    trait_def_id: ast::DefId,\n-    skol_obligation_self_ty: ty::t,\n+    previous: Option<&'prev ObligationStack<'prev>>\n }\n \n-#[deriving(PartialEq,Eq)]\n-enum MatchResult<T> {\n-    Matched(T),\n-    AmbiguousMatch,\n-    NoMatch\n+pub struct SelectionCache {\n+    hashmap: RefCell<HashMap<Rc<ty::TraitRef>, SelectionResult<Candidate>>>,\n }\n \n /**\n@@ -91,21 +89,31 @@ enum MatchResult<T> {\n  * clauses can give additional information (like, the types of output\n  * parameters) that would have to be inferred from the impl.\n  */\n-#[deriving(Clone)]\n+#[deriving(PartialEq,Eq,Show,Clone)]\n enum Candidate {\n-    MatchedBuiltinCandidate,\n-    AmbiguousBuiltinCandidate,\n-    MatchedParamCandidate(VtableParamData),\n-    AmbiguousParamCandidate,\n-    Impl(ImplCandidate),\n-    MatchedUnboxedClosureCandidate(/* closure */ ast::DefId),\n+    BuiltinCandidate(ty::BuiltinBound),\n+    ParamCandidate(VtableParamData),\n+    ImplCandidate(ast::DefId),\n+    UnboxedClosureCandidate(/* closure */ ast::DefId),\n     ErrorCandidate,\n }\n \n-#[deriving(Clone)]\n-enum ImplCandidate {\n-    MatchedImplCandidate(ast::DefId),\n-    AmbiguousImplCandidate(ast::DefId),\n+struct CandidateSet {\n+    vec: Vec<Candidate>,\n+    ambiguous: bool\n+}\n+\n+enum BuiltinBoundConditions {\n+    If(Vec<ty::t>),\n+    ParameterBuiltin,\n+    AmbiguousBuiltin\n+}\n+\n+#[deriving(Show)]\n+enum EvaluationResult {\n+    EvaluatedToOk,\n+    EvaluatedToErr,\n+    EvaluatedToAmbig,\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n@@ -150,10 +158,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"select({})\", obligation.repr(self.tcx()));\n \n-        let stack = self.new_stack(obligation);\n+        let stack = self.push_stack(None, obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n             None => Ok(None),\n-            Some(candidate) => self.confirm_candidate(obligation, candidate),\n+            Some(candidate) => Ok(Some(try!(self.confirm_candidate(obligation, candidate)))),\n         }\n     }\n \n@@ -167,22 +175,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                impl_def_id.repr(self.tcx()),\n                obligation_self_ty.repr(self.tcx()));\n \n-        match self.candidate_from_impl(impl_def_id,\n+        match self.match_inherent_impl(impl_def_id,\n                                        obligation_cause,\n                                        obligation_self_ty) {\n-            Some(MatchedImplCandidate(impl_def_id)) => {\n-                let vtable_impl =\n-                    try!(self.confirm_inherent_impl_candidate(\n-                        impl_def_id,\n-                        obligation_cause,\n-                        obligation_self_ty,\n-                        0));\n+            Ok(substs) => {\n+                let vtable_impl = self.vtable_impl(impl_def_id, substs, obligation_cause, 0);\n                 Ok(Some(vtable_impl))\n             }\n-            Some(AmbiguousImplCandidate(_)) => {\n-                Ok(None)\n-            }\n-            None => {\n+            Err(()) => {\n                 Err(Unimplemented)\n             }\n         }\n@@ -194,10 +194,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // Tests whether an obligation can be selected or whether an impl can be\n     // applied to particular types. It skips the \"confirmation\" step and\n     // hence completely ignores output type parameters.\n+    //\n+    // The result is \"true\" if the obliation *may* hold and \"false\" if\n+    // we can be sure it does not.\n \n     pub fn evaluate_obligation(&mut self,\n                                obligation: &Obligation)\n-                               -> EvaluationResult\n+                               -> bool\n     {\n         /*!\n          * Evaluates whether the obligation `obligation` can be\n@@ -207,12 +210,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n \n-        let stack = self.new_stack(obligation);\n-        match self.candidate_from_obligation(&stack) {\n-            Ok(Some(c)) => c.to_evaluation_result(),\n-            Ok(None) => EvaluatedToAmbiguity,\n-            Err(_) => EvaluatedToUnmatch,\n-        }\n+        let stack = self.push_stack(None, obligation);\n+        self.evaluate_stack(&stack).may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively(&mut self,\n@@ -228,22 +227,46 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 bound,\n                 previous_stack.obligation.recursion_depth + 1,\n                 ty);\n-        let obligation = match obligation {\n-            Ok(ob) => ob,\n-            _ => return EvaluatedToMatch\n-        };\n \n-        self.evaluate_obligation_recursively(previous_stack, &obligation)\n+        match obligation {\n+            Ok(obligation) => {\n+                self.evaluate_obligation_recursively(Some(previous_stack), &obligation)\n+            }\n+            Err(ErrorReported) => {\n+                EvaluatedToOk\n+            }\n+        }\n     }\n \n     fn evaluate_obligation_recursively(&mut self,\n-                                       previous_stack: &ObligationStack,\n+                                       previous_stack: Option<&ObligationStack>,\n                                        obligation: &Obligation)\n                                        -> EvaluationResult\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n                obligation.repr(self.tcx()));\n \n+        let stack = self.push_stack(previous_stack.map(|x| x), obligation);\n+        let result = self.evaluate_stack(&stack);\n+        debug!(\"result: {}\", result);\n+        result\n+    }\n+\n+    fn evaluate_stack(&mut self,\n+                      stack: &ObligationStack)\n+                      -> EvaluationResult\n+    {\n+        // Whenever any of the types are unbound, there can always be\n+        // an impl.  Even if there are no impls in this crate, perhaps\n+        // the type would be unified with something from another crate\n+        // that does provide an impl.\n+        let input_types = &stack.skol_trait_ref.substs.types;\n+        if input_types.iter().any(|&t| ty::type_is_skolemized(t)) {\n+            debug!(\"evaluate_stack({}) --> unbound argument, must be ambiguous\",\n+                   stack.skol_trait_ref.repr(self.tcx()));\n+            return EvaluatedToAmbig;\n+        }\n+\n         // If there is any previous entry on the stack that precisely\n         // matches this obligation, then we can assume that the\n         // obligation is satisfied for now (still all other conditions\n@@ -256,47 +279,56 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // `Option<Box<List<T>>>` is `Send`, and in turn\n         // `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n         // `Send`.\n+        //\n+        // Note that we do this comparison using the `skol_trait_ref`\n+        // fields. Because these have all been skolemized using\n+        // `self.skolemizer`, we can be sure that (a) this will not\n+        // affect the inferencer state and (b) that if we see two\n+        // skolemized types with the same index, they refer to the\n+        // same unbound type variable.\n         if\n-            previous_stack.iter()\n-            .filter(|e| e.obligation.trait_ref.def_id == obligation.trait_ref.def_id)\n-            .find(|e| self.match_self_types(obligation.cause,\n-                                            e.skol_obligation_self_ty,\n-                                            obligation.self_ty()) == Matched(()))\n-            .is_some()\n+            stack.iter()\n+            .skip(1) // skip top-most frame\n+            .any(|prev| stack.skol_trait_ref == prev.skol_trait_ref)\n         {\n-            return EvaluatedToMatch;\n+            debug!(\"evaluate_stack({}) --> recursive\",\n+                   stack.skol_trait_ref.repr(self.tcx()));\n+            return EvaluatedToOk;\n         }\n \n-        let stack = self.push_stack(previous_stack, obligation);\n-        match self.candidate_from_obligation(&stack) {\n-            Ok(Some(c)) => c.to_evaluation_result(),\n-            Ok(None) => EvaluatedToAmbiguity,\n-            Err(_) => EvaluatedToUnmatch,\n+        match self.candidate_from_obligation(stack) {\n+            Ok(Some(c)) => self.winnow_candidate(stack, &c),\n+            Ok(None) => EvaluatedToAmbig,\n+            Err(_) => EvaluatedToErr,\n         }\n     }\n \n     pub fn evaluate_impl(&mut self,\n                          impl_def_id: ast::DefId,\n-                         obligation_cause: ObligationCause,\n-                         obligation_self_ty: ty::t)\n-                         -> EvaluationResult\n+                         obligation: &Obligation)\n+                         -> bool\n     {\n         /*!\n          * Evaluates whether the impl with id `impl_def_id` could be\n          * applied to the self type `obligation_self_ty`. This can be\n          * used either for trait or inherent impls.\n          */\n \n-        debug!(\"evaluate_impl(impl_def_id={}, obligation_self_ty={})\",\n+        debug!(\"evaluate_impl(impl_def_id={}, obligation={})\",\n                impl_def_id.repr(self.tcx()),\n-               obligation_self_ty.repr(self.tcx()));\n+               obligation.repr(self.tcx()));\n \n-        match self.candidate_from_impl(impl_def_id,\n-                                       obligation_cause,\n-                                       obligation_self_ty) {\n-            Some(c) => c.to_evaluation_result(),\n-            None => EvaluatedToUnmatch,\n-        }\n+        self.infcx.probe(|| {\n+            match self.match_impl(impl_def_id, obligation) {\n+                Ok(substs) => {\n+                    let vtable_impl = self.vtable_impl(impl_def_id, substs, obligation.cause, 0);\n+                    self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n+                }\n+                Err(()) => {\n+                    false\n+                }\n+            }\n+        })\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -310,80 +342,158 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  stack: &ObligationStack)\n                                  -> SelectionResult<Candidate>\n     {\n-        debug!(\"candidate_from_obligation({})\",\n+        // Watch out for overflow. This intentionally bypasses (and does\n+        // not update) the cache.\n+        let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n+        if stack.obligation.recursion_depth >= recursion_limit {\n+            debug!(\"{} --> overflow (limit={})\",\n+                   stack.obligation.repr(self.tcx()),\n+                   recursion_limit);\n+            return Err(Overflow)\n+        }\n+\n+        // Check the cache. Note that we skolemize the trait-ref\n+        // separately rather than using `stack.skol_trait_ref` -- this\n+        // is because we want the unbound variables to be replaced\n+        // with fresh skolemized types starting from index 0.\n+        let cache_skol_trait_ref =\n+            self.infcx.skolemize(stack.obligation.trait_ref.clone());\n+        debug!(\"candidate_from_obligation(cache_skol_trait_ref={}, obligation={})\",\n+               cache_skol_trait_ref.repr(self.tcx()),\n                stack.repr(self.tcx()));\n \n-        // First, check the cache.\n-        match self.check_candidate_cache(stack.obligation, stack.skol_obligation_self_ty) {\n+        match self.check_candidate_cache(cache_skol_trait_ref.clone()) {\n             Some(c) => {\n-                debug!(\"check_candidate_cache(obligation={}, skol_obligation_self_ty={}, \\\n-                       candidate={})\",\n-                       stack.obligation.trait_ref.def_id,\n-                       stack.skol_obligation_self_ty.repr(self.tcx()),\n+                debug!(\"CACHE HIT: cache_skol_trait_ref={}, candidate={}\",\n+                       cache_skol_trait_ref.repr(self.tcx()),\n                        c.repr(self.tcx()));\n                 return c;\n             }\n             None => { }\n         }\n \n         // If no match, compute result and insert into cache.\n-        let result = self.pick_candidate(stack);\n-        self.insert_candidate_cache(stack.obligation,\n-                                    stack.skol_obligation_self_ty,\n-                                    result.clone());\n-        result\n+        let candidate = self.candidate_from_obligation_no_cache(stack);\n+        debug!(\"CACHE MISS: cache_skol_trait_ref={}, candidate={}\",\n+               cache_skol_trait_ref.repr(self.tcx()), candidate.repr(self.tcx()));\n+        self.insert_candidate_cache(cache_skol_trait_ref, candidate.clone());\n+        candidate\n     }\n \n-    fn pick_candidate(&mut self,\n-                      stack: &ObligationStack)\n-                      -> SelectionResult<Candidate>\n+    fn candidate_from_obligation_no_cache(&mut self,\n+                                          stack: &ObligationStack)\n+                                          -> SelectionResult<Candidate>\n     {\n-        if ty::type_is_error(stack.skol_obligation_self_ty) {\n+        if ty::type_is_error(stack.obligation.self_ty()) {\n             return Ok(Some(ErrorCandidate));\n         }\n \n-        let mut candidates = try!(self.assemble_candidates(stack));\n+        let candidate_set = try!(self.assemble_candidates(stack));\n+\n+        if candidate_set.ambiguous {\n+            debug!(\"candidate set contains ambig\");\n+            return Ok(None);\n+        }\n+\n+        let mut candidates = candidate_set.vec;\n \n         debug!(\"assembled {} candidates for {}\",\n                candidates.len(), stack.repr(self.tcx()));\n \n-        // Examine candidates to determine outcome. Ideally we will\n-        // have exactly one candidate that is definitively applicable.\n+        // At this point, we know that each of the entries in the\n+        // candidate set is *individually* applicable. Now we have to\n+        // figure out if they contain mutual incompatibilities. This\n+        // frequently arises if we have an unconstrained input type --\n+        // for example, we are looking for $0:Eq where $0 is some\n+        // unconstrained type variable. In that case, we'll get a\n+        // candidate which assumes $0 == int, one that assumes $0 ==\n+        // uint, etc. This spells an ambiguity.\n+\n+        // If there is more than one candidate, first winnow them down\n+        // by considering extra conditions (nested obligations and so\n+        // forth). We don't winnow if there is exactly one\n+        // candidate. This is a relatively minor distinction but it\n+        // can lead to better inference and error-reporting. An\n+        // example would be if there was an impl:\n+        //\n+        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n+        //\n+        // and we were to see some code `foo.push_clone()` where `boo`\n+        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n+        // we were to winnow, we'd wind up with zero candidates.\n+        // Instead, we select the right impl now but report `Bar does\n+        // not implement Clone`.\n+        if candidates.len() > 1 {\n+            candidates.retain(|c| self.winnow_candidate(stack, c).may_apply())\n+        }\n+\n+        // If there are STILL multiple candidate, we can further reduce\n+        // the list by dropping duplicates.\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            while i < candidates.len() {\n+                let is_dup =\n+                    range(0, candidates.len())\n+                    .filter(|&j| i != j)\n+                    .any(|j| self.candidate_should_be_dropped_in_favor_of(stack,\n+                                                                          &candidates[i],\n+                                                                          &candidates[j]));\n+                if is_dup {\n+                    debug!(\"Dropping candidate #{}/#{}: {}\",\n+                           i, candidates.len(), candidates[i].repr(self.tcx()));\n+                    candidates.swap_remove(i);\n+                } else {\n+                    debug!(\"Retaining candidate #{}/#{}\",\n+                           i, candidates.len());\n+                    i += 1;\n+                }\n+            }\n+        }\n+\n+        // If there are *STILL* multiple candidates, give up and\n+        // report ambiguiuty.\n+        if candidates.len() > 1 {\n+            debug!(\"multiple matches, ambig\");\n+            return Ok(None);\n+        }\n \n+        // If there are *NO* candidates, that might mean either that\n+        // there is no impl or just that we can't know anything for\n+        // sure.\n         if candidates.len() == 0 {\n             // Annoying edge case: if there are no impls, then there\n             // is no way that this trait reference is implemented,\n             // *unless* it contains unbound variables. In that case,\n             // it is possible that one of those unbound variables will\n             // be bound to a new type from some other crate which will\n             // also contain impls.\n-            return if !self.contains_skolemized_types(stack.skol_obligation_self_ty) {\n+            let skol_obligation_self_ty = self.infcx.skolemize(stack.obligation.self_ty());\n+            return if !self.contains_skolemized_types(skol_obligation_self_ty) {\n                 debug!(\"0 matches, unimpl\");\n                 Err(Unimplemented)\n             } else {\n                 debug!(\"0 matches, ambig\");\n                 Ok(None)\n-            }\n-        } else if candidates.len() > 1 {\n-            // Ambiguity. Possibly we should report back more\n-            // information on the potential candidates so we can give\n-            // a better error message.\n-            debug!(\"multiple matches, ambig\");\n-            Ok(None)\n-        } else {\n-            let candidate = candidates.pop().unwrap();\n-            Ok(Some(candidate))\n+            };\n         }\n+\n+        // Just one candidate left.\n+        let candidate = candidates.pop().unwrap();\n+        Ok(Some(candidate))\n     }\n \n     fn pick_candidate_cache(&self,\n-                            _obligation: &Obligation,\n-                            skol_obligation_self_ty: ty::t)\n+                            cache_skol_trait_ref: &Rc<ty::TraitRef>)\n                             -> &SelectionCache\n     {\n+        // If the trait refers to any parameters in scope, then use\n+        // the cache of the param-environment. This is because the\n+        // result will depend on the where clauses that are in\n+        // scope. Otherwise, use the generic tcx cache, since the\n+        // result holds across all environments.\n         if\n-            ty::type_has_self(skol_obligation_self_ty) ||\n-            ty::type_has_params(skol_obligation_self_ty)\n+            cache_skol_trait_ref.substs.types.iter().any(\n+                |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             &self.param_env.selection_cache\n         } else {\n@@ -392,95 +502,59 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             obligation: &Obligation,\n-                             skol_obligation_self_ty: ty::t)\n+                             cache_skol_trait_ref: Rc<ty::TraitRef>)\n                              -> Option<SelectionResult<Candidate>>\n     {\n-        let cache = self.pick_candidate_cache(obligation, skol_obligation_self_ty);\n-        let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n-                                      skol_obligation_self_ty);\n+        let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n         let hashmap = cache.hashmap.borrow();\n-        hashmap.find(&cache_key).map(|c| (*c).clone())\n+        hashmap.find(&cache_skol_trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              obligation: &Obligation,\n-                              skol_obligation_self_ty: ty::t,\n+                              cache_skol_trait_ref: Rc<ty::TraitRef>,\n                               candidate: SelectionResult<Candidate>)\n     {\n-        debug!(\"insert_candidate_cache(obligation={}, skol_obligation_self_ty={}, candidate={})\",\n-               obligation.trait_ref.def_id,\n-               skol_obligation_self_ty.repr(self.tcx()),\n-               candidate.repr(self.tcx()));\n-\n-        let cache = self.pick_candidate_cache(obligation, skol_obligation_self_ty);\n-        let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n-                                      skol_obligation_self_ty);\n+        let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n         let mut hashmap = cache.hashmap.borrow_mut();\n-        hashmap.insert(cache_key, candidate);\n+        hashmap.insert(cache_skol_trait_ref, candidate);\n     }\n \n     fn assemble_candidates(&mut self,\n                            stack: &ObligationStack)\n-                           -> Result<Vec<Candidate>, SelectionError>\n+                           -> Result<CandidateSet, SelectionError>\n     {\n         // Check for overflow.\n \n-        let ObligationStack { obligation, skol_obligation_self_ty, .. } = *stack;\n+        let ObligationStack { obligation, .. } = *stack;\n \n-        let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n-        if obligation.recursion_depth >= recursion_limit {\n-            debug!(\"{} --> overflow\", stack.obligation.repr(self.tcx()));\n-            return Err(Overflow);\n-        }\n-\n-        let mut candidates = Vec::new();\n+        let mut candidates = CandidateSet {\n+            vec: Vec::new(),\n+            ambiguous: false\n+        };\n \n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n-        // Where clauses have highest precedence.\n-        try!(self.assemble_candidates_from_caller_bounds(\n-            obligation,\n-            skol_obligation_self_ty,\n-            &mut candidates));\n-\n-        // In the special case of builtin bounds, consider the \"compiler-supplied\" impls.\n-        if candidates.len() == 0 {\n-            match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n-                Some(bound) => {\n-                    try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n-                }\n-\n-                None => { }\n+        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+            Some(bound) => {\n+                try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n             }\n-        }\n-\n-        // In the special case of fn traits and synthesized unboxed\n-        // closure types, consider the compiler-supplied impls. Note\n-        // that this is exclusive with the builtin bound case above.\n-        if candidates.len() == 0 {\n-            try!(self.assemble_unboxed_candidates(\n-                obligation,\n-                skol_obligation_self_ty,\n-                &mut candidates));\n-        }\n \n-        // Finally, consider the actual impls found in the program.\n-        if candidates.len() == 0 {\n-            try!(self.assemble_candidates_from_impls(\n-                obligation,\n-                skol_obligation_self_ty,\n-                &mut candidates));\n+            None => {\n+                // For the time being, we ignore user-defined impls for builtin-bounds.\n+                // (And unboxed candidates only apply to the Fn/FnMut/etc traits.)\n+                try!(self.assemble_unboxed_candidates(obligation, &mut candidates));\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n+            }\n         }\n \n+        try!(self.assemble_candidates_from_caller_bounds(obligation, &mut candidates));\n         Ok(candidates)\n     }\n \n     fn assemble_candidates_from_caller_bounds(&mut self,\n                                               obligation: &Obligation,\n-                                              skol_obligation_self_ty: ty::t,\n-                                              candidates: &mut Vec<Candidate>)\n+                                              candidates: &mut CandidateSet)\n                                               -> Result<(),SelectionError>\n     {\n         /*!\n@@ -491,68 +565,63 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n          * Never affects inference environment.\n          */\n \n-        debug!(\"assemble_candidates_from_caller_bounds({}, {})\",\n-               obligation.repr(self.tcx()),\n-               skol_obligation_self_ty.repr(self.tcx()));\n-\n-        for caller_obligation in self.param_env.caller_obligations.iter() {\n-            // Skip over obligations that don't apply to\n-            // `self_ty`.\n-            let caller_bound = &caller_obligation.trait_ref;\n-            let caller_self_ty = caller_bound.substs.self_ty().unwrap();\n-            debug!(\"caller_obligation={}, caller_self_ty={}\",\n-                   caller_obligation.repr(self.tcx()),\n-                   self.infcx.ty_to_string(caller_self_ty));\n-            match self.match_self_types(obligation.cause,\n-                                        caller_self_ty,\n-                                        skol_obligation_self_ty) {\n-                AmbiguousMatch => {\n-                    debug!(\"-> AmbiguousMatch\");\n-                    candidates.push(AmbiguousParamCandidate);\n-                    return Ok(());\n-                }\n-                NoMatch => {\n-                    debug!(\"-> NoMatch\");\n-                    continue;\n-                }\n-                Matched(()) => { }\n-            }\n+        debug!(\"assemble_candidates_from_caller_bounds({})\",\n+               obligation.repr(self.tcx()));\n \n-            // Search through the trait (and its supertraits) to\n-            // see if it matches the def-id we are looking for.\n-            let caller_bound = (*caller_bound).clone();\n-            for bound in util::transitive_bounds(self.tcx(), &[caller_bound]) {\n-                debug!(\"-> check bound={}\", bound.repr(self.tcx()));\n-                if bound.def_id == obligation.trait_ref.def_id {\n-                    // If so, we're done!\n-                    debug!(\"-> MatchedParamCandidate({})\", bound.repr(self.tcx()));\n-                    let vtable_param = VtableParamData { bound: bound };\n-                    candidates.push(MatchedParamCandidate(vtable_param));\n-                    return Ok(());\n-                }\n-            }\n-        }\n+        let caller_trait_refs: Vec<Rc<ty::TraitRef>> =\n+            self.param_env.caller_obligations.iter()\n+            .map(|o| o.trait_ref.clone())\n+            .collect();\n+\n+        let all_bounds =\n+            util::transitive_bounds(\n+                self.tcx(), caller_trait_refs.as_slice());\n+\n+        let matching_bounds =\n+            all_bounds.filter(\n+                |bound| self.infcx.probe(\n+                    || self.match_trait_refs(obligation,\n+                                             (*bound).clone())).is_ok());\n+\n+        let param_candidates =\n+            matching_bounds.map(\n+                |bound| ParamCandidate(VtableParamData { bound: bound }));\n+\n+        candidates.vec.extend(param_candidates);\n \n         Ok(())\n     }\n \n     fn assemble_unboxed_candidates(&mut self,\n                                    obligation: &Obligation,\n-                                   skol_obligation_self_ty: ty::t,\n-                                   candidates: &mut Vec<Candidate>)\n+                                   candidates: &mut CandidateSet)\n                                    -> Result<(),SelectionError>\n     {\n         /*!\n          * Check for the artificial impl that the compiler will create\n          * for an obligation like `X : FnMut<..>` where `X` is an\n          * unboxed closure type.\n+         *\n+         * Note: the type parameters on an unboxed closure candidate\n+         * are modeled as *output* type parameters and hence do not\n+         * affect whether this trait is a match or not. They will be\n+         * unified during the confirmation step.\n          */\n \n-        let closure_def_id = match ty::get(skol_obligation_self_ty).sty {\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let closure_def_id = match ty::get(self_ty).sty {\n             ty::ty_unboxed_closure(id, _) => id,\n+            ty::ty_infer(ty::TyVar(_)) => {\n+                candidates.ambiguous = true;\n+                return Ok(());\n+            }\n             _ => { return Ok(()); }\n         };\n \n+        debug!(\"assemble_unboxed_candidates: self_ty={} obligation={}\",\n+               self_ty.repr(self.tcx()),\n+               obligation.repr(self.tcx()));\n+\n         let tcx = self.tcx();\n         let fn_traits = [\n             (ty::FnUnboxedClosureKind, tcx.lang_items.fn_trait()),\n@@ -584,16 +653,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 continue;\n             }\n \n-            candidates.push(MatchedUnboxedClosureCandidate(closure_def_id));\n+            candidates.vec.push(UnboxedClosureCandidate(closure_def_id));\n         }\n \n         Ok(())\n     }\n \n     fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &Obligation,\n-                                      skol_obligation_self_ty: ty::t,\n-                                      candidates: &mut Vec<Candidate>)\n+                                      candidates: &mut CandidateSet)\n                                       -> Result<(), SelectionError>\n     {\n         /*!\n@@ -603,39 +671,106 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let all_impls = self.all_impls(obligation.trait_ref.def_id);\n         for &impl_def_id in all_impls.iter() {\n             self.infcx.probe(|| {\n-                match self.candidate_from_impl(impl_def_id,\n-                                               obligation.cause,\n-                                               skol_obligation_self_ty) {\n-                    Some(c) => {\n-                        candidates.push(Impl(c));\n+                match self.match_impl(impl_def_id, obligation) {\n+                    Ok(_) => {\n+                        candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n-\n-                    None => { }\n+                    Err(()) => { }\n                 }\n             });\n         }\n         Ok(())\n     }\n \n-    fn candidate_from_impl(&mut self,\n-                           impl_def_id: ast::DefId,\n-                           obligation_cause: ObligationCause,\n-                           skol_obligation_self_ty: ty::t)\n-                           -> Option<ImplCandidate>\n+    ///////////////////////////////////////////////////////////////////////////\n+    // WINNOW\n+    //\n+    // Winnowing is the process of attempting to resolve ambiguity by\n+    // probing further. During the winnowing process, we unify all\n+    // type variables (ignoring skolemization) and then we also\n+    // attempt to evaluate recursive bounds to see if they are\n+    // satisfied.\n+\n+    fn winnow_candidate(&mut self,\n+                        stack: &ObligationStack,\n+                        candidate: &Candidate)\n+                        -> EvaluationResult\n     {\n-        match self.match_impl_self_types(impl_def_id,\n-                                         obligation_cause,\n-                                         skol_obligation_self_ty) {\n-            Matched(_) => {\n-                Some(MatchedImplCandidate(impl_def_id))\n+        /*!\n+         * Further evaluate `candidate` to decide whether all type parameters match\n+         * and whether nested obligations are met. Returns true if `candidate` remains\n+         * viable after this further scrutiny.\n+         */\n+\n+        debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n+        self.infcx.probe(|| {\n+            let candidate = (*candidate).clone();\n+            match self.confirm_candidate(stack.obligation, candidate) {\n+                Ok(selection) => self.winnow_selection(Some(stack), selection),\n+                Err(_) => EvaluatedToErr,\n             }\n+        })\n+    }\n \n-            AmbiguousMatch => {\n-                Some(AmbiguousImplCandidate(impl_def_id))\n+    fn winnow_selection(&mut self,\n+                        stack: Option<&ObligationStack>,\n+                        selection: Selection)\n+                        -> EvaluationResult\n+    {\n+        let mut result = EvaluatedToOk;\n+        for obligation in selection.iter_nested() {\n+            match self.evaluate_obligation_recursively(stack, obligation) {\n+                EvaluatedToErr => { return EvaluatedToErr; }\n+                EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n+                EvaluatedToOk => { }\n             }\n+        }\n+        result\n+    }\n \n-            NoMatch => {\n-                None\n+    fn candidate_should_be_dropped_in_favor_of(&mut self,\n+                                               stack: &ObligationStack,\n+                                               candidate_i: &Candidate,\n+                                               candidate_j: &Candidate)\n+                                               -> bool\n+    {\n+        /*!\n+         * Returns true if `candidate_i` should be dropped in favor of `candidate_j`.\n+         * This is generally true if either:\n+         * - candidate i and candidate j are equivalent; or,\n+         * - candidate i is a where clause bound and candidate j is a concrete impl,\n+         *   and the concrete impl is applicable to the types in the where clause bound.\n+         *\n+         * The last case basically occurs with blanket impls like\n+         * `impl<T> Foo for T`.  In that case, a bound like `T:Foo` is\n+         * kind of an \"false\" ambiguity -- both are applicable to any\n+         * type, but in fact coherence requires that the bound will\n+         * always be resolved to the impl anyway.\n+         */\n+\n+        match (candidate_i, candidate_j) {\n+            (&ParamCandidate(ref vt), &ImplCandidate(impl_def_id)) => {\n+                debug!(\"Considering whether to drop param {} in favor of impl {}\",\n+                       candidate_i.repr(self.tcx()),\n+                       candidate_j.repr(self.tcx()));\n+\n+                self.infcx.probe(|| {\n+                    let impl_substs =\n+                        self.rematch_impl(impl_def_id, stack.obligation);\n+                    let impl_trait_ref =\n+                        ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n+                    let impl_trait_ref =\n+                        impl_trait_ref.subst(self.tcx(), &impl_substs);\n+                    let origin =\n+                        infer::RelateOutputImplTypes(stack.obligation.cause.span);\n+                    self.infcx\n+                        .sub_trait_refs(false, origin,\n+                                        impl_trait_ref, vt.bound.clone())\n+                        .is_ok()\n+                })\n+            }\n+            _ => {\n+                *candidate_i == *candidate_j\n             }\n         }\n     }\n@@ -652,80 +787,68 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn assemble_builtin_bound_candidates(&mut self,\n                                          bound: ty::BuiltinBound,\n                                          stack: &ObligationStack,\n-                                         candidates: &mut Vec<Candidate>)\n+                                         candidates: &mut CandidateSet)\n                                          -> Result<(),SelectionError>\n     {\n-        // Copy -- owned, dtor, managed, marker, &mut -- only INTERIOR?\n-        // Sized -- str, [T], Trait -- but only INTERIOR\n-        // Send -- managed data, nonsend annot, borrowed data -- REACHABILITY\n-        // Sync -- non-sync marker trait -- REACHABILITY\n-\n-        // Ideally, we'd only have to examine the immediate fields.\n-        // But think this through carefully I guess.\n-\n-        enum WhenOk<'a> {\n-            Always,\n-            Unknown,\n-            Never,\n-            If(ty::t),\n-            IfAll(&'a [ty::t]),\n-            IfTrue(bool)\n-        }\n-\n-        let ok = |this: &mut SelectionContext, w: WhenOk| {\n-            let r = match w {\n-                Always => EvaluatedToMatch,\n-                Unknown => EvaluatedToAmbiguity,\n-                Never => EvaluatedToUnmatch,\n-                IfTrue(true) => EvaluatedToMatch,\n-                IfTrue(false) => EvaluatedToUnmatch,\n-                If(ty) => this.evaluate_builtin_bound_recursively(bound, stack, ty),\n-                IfAll(tys) => {\n-                    let mut result = EvaluatedToMatch;\n-                    for &ty in tys.iter() {\n-                        match this.evaluate_builtin_bound_recursively(bound, stack, ty) {\n-                            EvaluatedToMatch => { }\n-                            EvaluatedToAmbiguity => {\n-                                result = EvaluatedToAmbiguity;\n-                            }\n-                            EvaluatedToUnmatch => {\n-                                result = EvaluatedToUnmatch;\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    result\n+        // FIXME -- To be more like a normal impl, we should just\n+        // ignore the nested cases here, and instead generate nested\n+        // obligations in `confirm_candidate`. However, this doesn't\n+        // work because we require handling the recursive cases to\n+        // avoid infinite cycles (that is, with recursive types,\n+        // sometimes `Foo : Copy` only holds if `Foo : Copy`).\n+\n+        match self.builtin_bound(bound, stack.obligation.self_ty()) {\n+            Ok(If(nested)) => {\n+                debug!(\"builtin_bound: bound={} nested={}\",\n+                       bound.repr(self.tcx()),\n+                       nested.repr(self.tcx()));\n+                let data = self.vtable_builtin_data(stack.obligation, bound, nested);\n+                match self.winnow_selection(Some(stack), VtableBuiltin(data)) {\n+                    EvaluatedToOk => { Ok(candidates.vec.push(BuiltinCandidate(bound))) }\n+                    EvaluatedToAmbig => { Ok(candidates.ambiguous = true) }\n+                    EvaluatedToErr => { Err(Unimplemented) }\n                 }\n-            };\n-\n-            match r {\n-                EvaluatedToMatch => Ok(candidates.push(MatchedBuiltinCandidate)),\n-                EvaluatedToAmbiguity => Ok(candidates.push(AmbiguousBuiltinCandidate)),\n-                EvaluatedToUnmatch => Err(Unimplemented)\n             }\n-        };\n+            Ok(ParameterBuiltin) => { Ok(()) }\n+            Ok(AmbiguousBuiltin) => { Ok(candidates.ambiguous = true) }\n+            Err(e) => { Err(e) }\n+        }\n+    }\n \n-        return match ty::get(stack.skol_obligation_self_ty).sty {\n-            ty::ty_uint(_) | ty::ty_int(_) | ty::ty_infer(ty::SkolemizedIntTy(_)) |\n-            ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_float(_) |\n-            ty::ty_bare_fn(_) | ty::ty_char => {\n+    fn builtin_bound(&mut self,\n+                     bound: ty::BuiltinBound,\n+                     self_ty: ty::t)\n+                     -> Result<BuiltinBoundConditions,SelectionError>\n+    {\n+        let self_ty = self.infcx.shallow_resolve(self_ty);\n+        return match ty::get(self_ty).sty {\n+            ty::ty_infer(ty::IntVar(_)) |\n+            ty::ty_infer(ty::FloatVar(_)) |\n+            ty::ty_uint(_) |\n+            ty::ty_int(_) |\n+            ty::ty_nil |\n+            ty::ty_bot |\n+            ty::ty_bool |\n+            ty::ty_float(_) |\n+            ty::ty_bare_fn(_) |\n+            ty::ty_char => {\n                 // safe for everything\n-                ok(self, Always)\n+                Ok(If(Vec::new()))\n             }\n \n             ty::ty_uniq(referent_ty) => {  // Box<T>\n                 match bound {\n                     ty::BoundCopy => {\n-                        ok(self, Never)\n+                        Err(Unimplemented)\n                     }\n \n                     ty::BoundSized => {\n-                        ok(self, Always)\n+                        Ok(If(Vec::new()))\n                     }\n \n                     ty::BoundSync |\n                     ty::BoundSend => {\n-                        ok(self, If(referent_ty))\n+                        Ok(If(vec![referent_ty]))\n                     }\n                 }\n             }\n@@ -734,12 +857,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match bound {\n                     ty::BoundCopy |\n                     ty::BoundSized => {\n-                        ok(self, Always)\n+                        Ok(If(Vec::new()))\n                     }\n \n                     ty::BoundSync |\n                     ty::BoundSend => {\n-                        ok(self, If(referent_ty))\n+                        Ok(If(vec![referent_ty]))\n                     }\n                 }\n             }\n@@ -750,36 +873,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         // proc: Equivalent to `Box<FnOnce>`\n                         match bound {\n                             ty::BoundCopy => {\n-                                ok(self, Never)\n+                                Err(Unimplemented)\n                             }\n \n                             ty::BoundSized => {\n-                                ok(self, Always)\n+                                Ok(If(Vec::new()))\n                             }\n \n                             ty::BoundSync |\n                             ty::BoundSend => {\n-                                ok(self, IfTrue(c.bounds.builtin_bounds.contains_elem(bound)))\n+                                if c.bounds.builtin_bounds.contains_elem(bound) {\n+                                    Ok(If(Vec::new()))\n+                                } else {\n+                                    Err(Unimplemented)\n+                                }\n                             }\n                         }\n                     }\n                     ty::RegionTraitStore(_, mutbl) => {\n                         // ||: Equivalent to `&FnMut` or `&mut FnMut` or something like that.\n                         match bound {\n                             ty::BoundCopy => {\n-                                ok(self, match mutbl {\n-                                    ast::MutMutable => Never,  // &mut T is affine\n-                                    ast::MutImmutable => Always,  // &T is copyable\n-                                })\n+                                match mutbl {\n+                                    ast::MutMutable => Err(Unimplemented),  // &mut T is affine\n+                                    ast::MutImmutable => Ok(If(Vec::new())),  // &T is copyable\n+                                }\n                             }\n \n                             ty::BoundSized => {\n-                                ok(self, Always)\n+                                Ok(If(Vec::new()))\n                             }\n \n                             ty::BoundSync |\n                             ty::BoundSend => {\n-                                ok(self, IfTrue(c.bounds.builtin_bounds.contains_elem(bound)))\n+                                if c.bounds.builtin_bounds.contains_elem(bound) {\n+                                    Ok(If(Vec::new()))\n+                                } else {\n+                                    Err(Unimplemented)\n+                                }\n                             }\n                         }\n                     }\n@@ -789,10 +920,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n                 match bound {\n                     ty::BoundSized => {\n-                        ok(self, Never)\n+                        Err(Unimplemented)\n                     }\n                     ty::BoundCopy | ty::BoundSync | ty::BoundSend => {\n-                        ok(self, IfTrue(bounds.builtin_bounds.contains_elem(bound)))\n+                        if bounds.builtin_bounds.contains_elem(bound) {\n+                            Ok(If(Vec::new()))\n+                        } else {\n+                            Err(Unimplemented)\n+                        }\n                     }\n                 }\n             }\n@@ -801,14 +936,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // &mut T or &T\n                 match bound {\n                     ty::BoundCopy => {\n-                        ok(self, match mutbl {\n-                            ast::MutMutable => Never,  // &mut T is affine and hence never `Copy`\n-                            ast::MutImmutable => Always,  // &T is copyable\n-                        })\n+                        match mutbl {\n+                            // &mut T is affine and hence never `Copy`\n+                            ast::MutMutable => Err(Unimplemented),\n+\n+                            // &T is always copyable\n+                            ast::MutImmutable => Ok(If(Vec::new())),\n+                        }\n                     }\n \n                     ty::BoundSized => {\n-                        ok(self, Always)\n+                        Ok(If(Vec::new()))\n                     }\n \n                     ty::BoundSync |\n@@ -829,7 +967,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         // we haven't finished running inference -- in\n                         // other words, there's a kind of\n                         // chicken-and-egg problem.\n-                        ok(self, If(referent_ty))\n+                        Ok(If(vec![referent_ty]))\n                     }\n                 }\n             }\n@@ -839,18 +977,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match bound {\n                     ty::BoundCopy => {\n                         match *len {\n-                            Some(_) => ok(self, If(element_ty)), // [T, ..n] is copy iff T is copy\n-                            None => ok(self, Never), // [T] is unsized and hence affine\n+                            Some(_) => Ok(If(vec![element_ty])), // [T, ..n] is copy iff T is copy\n+                            None => Err(Unimplemented), // [T] is unsized and hence affine\n                         }\n                     }\n \n                     ty::BoundSized => {\n-                        ok(self, IfTrue(len.is_some()))\n+                        if len.is_some() {\n+                            Ok(If(Vec::new()))\n+                        } else {\n+                            Err(Unimplemented)\n+                        }\n                     }\n \n                     ty::BoundSync |\n                     ty::BoundSend => {\n-                        ok(self, If(element_ty))\n+                        Ok(If(vec![element_ty]))\n                     }\n                 }\n             }\n@@ -860,19 +1002,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match bound {\n                     ty::BoundSync |\n                     ty::BoundSend => {\n-                        ok(self, Always)\n+                        Ok(If(Vec::new()))\n                     }\n \n                     ty::BoundCopy |\n                     ty::BoundSized => {\n-                        ok(self, Never)\n+                        Err(Unimplemented)\n                     }\n                 }\n             }\n \n             ty::ty_tup(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                ok(self, IfAll(tys.as_slice()))\n+                Ok(If(tys.to_owned()))\n             }\n \n             ty::ty_unboxed_closure(def_id, _) => {\n@@ -885,18 +1027,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // captures are by value. Really what we ought to do\n                 // is reserve judgement and then intertwine this\n                 // analysis with closure inference.\n-                //\n-                // FIXME -- this is wrong with respect to\n-                // skolemization. We want to skolemize the types of\n-                // the variables, but to do THAT we need the ability\n-                // to \"start\" the skolemization numbering from a\n-                // higher point. Perhaps this just means creating a\n-                // single skolemizer and then using it again here?\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n                 match self.tcx().freevars.borrow().find(&def_id.node) {\n                     None => {\n                         // No upvars.\n-                        ok(self, Always)\n+                        Ok(If(Vec::new()))\n                     }\n \n                     Some(freevars) => {\n@@ -905,12 +1040,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             .iter()\n                             .map(|freevar| {\n                                 let freevar_def_id = freevar.def.def_id();\n-                                let freevar_ty = self.typer.node_ty(freevar_def_id.node)\n-                                    .unwrap_or(ty::mk_err());\n-                                freevar_ty.fold_with(&mut self.skolemizer)\n+                                self.typer.node_ty(freevar_def_id.node)\n+                                    .unwrap_or(ty::mk_err())\n                             })\n                             .collect();\n-                        ok(self, IfAll(tys.as_slice()))\n+                        Ok(If(tys))\n                     }\n                 }\n             }\n@@ -921,7 +1055,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .iter()\n                     .map(|f| f.mt.ty)\n                     .collect();\n-                nominal(self, bound, def_id, types, ok)\n+                nominal(self, bound, def_id, types)\n             }\n \n             ty::ty_enum(def_id, ref substs) => {\n@@ -931,44 +1065,43 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .flat_map(|variant| variant.args.iter())\n                     .map(|&ty| ty)\n                     .collect();\n-                nominal(self, bound, def_id, types, ok)\n+                nominal(self, bound, def_id, types)\n             }\n \n             ty::ty_param(_) => {\n                 // Note: A type parameter is only considered to meet a\n                 // particular bound if there is a where clause telling\n                 // us that it does, and that case is handled by\n                 // `assemble_candidates_from_caller_bounds()`.\n-                ok(self, Never)\n+                Ok(ParameterBuiltin)\n             }\n \n-            ty::ty_infer(ty::SkolemizedTy(_)) => {\n-                // Skolemized types represent unbound type\n-                // variables. They might or might not have applicable\n-                // impls and so forth, depending on what those type\n-                // variables wind up being bound to.\n-                ok(self, Unknown)\n+            ty::ty_infer(ty::TyVar(_)) => {\n+                // Unbound type variable. Might or might not have\n+                // applicable impls and so forth, depending on what\n+                // those type variables wind up being bound to.\n+                Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_open(_) |\n-            ty::ty_infer(ty::TyVar(_)) |\n-            ty::ty_infer(ty::IntVar(_)) |\n-            ty::ty_infer(ty::FloatVar(_)) |\n             ty::ty_err => {\n-                self.tcx().sess.span_bug(\n-                    stack.obligation.cause.span,\n+                Ok(If(Vec::new()))\n+            }\n+\n+            ty::ty_open(_) |\n+            ty::ty_infer(ty::SkolemizedTy(_)) |\n+            ty::ty_infer(ty::SkolemizedIntTy(_)) => {\n+                self.tcx().sess.bug(\n                     format!(\n-                        \"asked to compute contents of unexpected type: {}\",\n-                        stack.skol_obligation_self_ty.repr(self.tcx())).as_slice());\n+                        \"asked to assemble builtin bounds of unexpected type: {}\",\n+                        self_ty.repr(self.tcx())).as_slice());\n             }\n         };\n \n         fn nominal(this: &mut SelectionContext,\n                    bound: ty::BuiltinBound,\n                    def_id: ast::DefId,\n-                   types: Vec<ty::t>,\n-                   ok: |&mut SelectionContext, WhenOk| -> Result<(),SelectionError>)\n-                   -> Result<(),SelectionError>\n+                   types: Vec<ty::t>)\n+                   -> Result<BuiltinBoundConditions,SelectionError>\n         {\n             // First check for markers and other nonsense.\n             let tcx = this.tcx();\n@@ -978,7 +1111,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Some(def_id) == tcx.lang_items.no_send_bound() ||\n                         Some(def_id) == tcx.lang_items.managed_bound()\n                     {\n-                        return ok(this, Never);\n+                        return Err(Unimplemented);\n                     }\n                 }\n \n@@ -988,7 +1121,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Some(def_id) == tcx.lang_items.managed_bound() ||\n                         ty::has_dtor(tcx, def_id)\n                     {\n-                        return ok(this, Never);\n+                        return Err(Unimplemented);\n                     }\n                 }\n \n@@ -997,21 +1130,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Some(def_id) == tcx.lang_items.no_sync_bound() ||\n                         Some(def_id) == tcx.lang_items.managed_bound()\n                     {\n-                        return ok(this, Never);\n+                        return Err(Unimplemented);\n                     } else if\n                         Some(def_id) == tcx.lang_items.unsafe_type()\n                     {\n                         // FIXME(#13231) -- we currently consider `UnsafeCell<T>`\n                         // to always be sync. This is allow for types like `Queue`\n                         // and `Mutex`, where `Queue<T> : Sync` is `T : Send`.\n-                        return ok(this, Always);\n+                        return Ok(If(Vec::new()));\n                     }\n                 }\n \n                 ty::BoundSized => { }\n             }\n \n-            ok(this, IfAll(types.as_slice()))\n+            Ok(If(types))\n         }\n     }\n \n@@ -1025,38 +1158,33 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_candidate(&mut self,\n                          obligation: &Obligation,\n                          candidate: Candidate)\n-                         -> SelectionResult<Selection>\n+                         -> Result<Selection,SelectionError>\n     {\n         debug!(\"confirm_candidate({}, {})\",\n                obligation.repr(self.tcx()),\n                candidate.repr(self.tcx()));\n \n         match candidate {\n-            AmbiguousBuiltinCandidate |\n-            AmbiguousParamCandidate |\n-            Impl(AmbiguousImplCandidate(_)) => {\n-                Ok(None)\n-            }\n-\n-            ErrorCandidate |\n-            MatchedBuiltinCandidate => {\n-                Ok(Some(VtableBuiltin))\n+            // FIXME -- see assemble_builtin_bound_candidates()\n+            BuiltinCandidate(_) |\n+            ErrorCandidate => {\n+                Ok(VtableBuiltin(VtableBuiltinData { nested: VecPerParamSpace::empty() }))\n             }\n \n-            MatchedParamCandidate(param) => {\n-                Ok(Some(VtableParam(\n-                    try!(self.confirm_param_candidate(obligation, param)))))\n+            ParamCandidate(param) => {\n+                Ok(VtableParam(\n+                    try!(self.confirm_param_candidate(obligation, param))))\n             }\n \n-            Impl(MatchedImplCandidate(impl_def_id)) => {\n-                let vtable_impl = try!(self.confirm_impl_candidate(obligation,\n-                                                                   impl_def_id));\n-                Ok(Some(VtableImpl(vtable_impl)))\n+            ImplCandidate(impl_def_id) => {\n+                let vtable_impl =\n+                    try!(self.confirm_impl_candidate(obligation, impl_def_id));\n+                Ok(VtableImpl(vtable_impl))\n             }\n \n-            MatchedUnboxedClosureCandidate(closure_def_id) => {\n+            UnboxedClosureCandidate(closure_def_id) => {\n                 try!(self.confirm_unboxed_closure_candidate(obligation, closure_def_id));\n-                Ok(Some(VtableUnboxedClosure(closure_def_id)))\n+                Ok(VtableUnboxedClosure(closure_def_id))\n             }\n         }\n     }\n@@ -1076,6 +1204,52 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(param)\n     }\n \n+    fn confirm_builtin_candidate(&mut self,\n+                                 obligation: &Obligation,\n+                                 bound: ty::BuiltinBound)\n+                                 -> Result<VtableBuiltinData<Obligation>,SelectionError>\n+    {\n+        debug!(\"confirm_builtin_candidate({})\",\n+               obligation.repr(self.tcx()));\n+\n+        match try!(self.builtin_bound(bound, obligation.self_ty())) {\n+            If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n+            AmbiguousBuiltin |\n+            ParameterBuiltin => {\n+                self.tcx().sess.span_bug(\n+                    obligation.cause.span,\n+                    format!(\"builtin bound for {} was ambig\",\n+                            obligation.repr(self.tcx())).as_slice());\n+            }\n+        }\n+    }\n+\n+    fn vtable_builtin_data(&mut self,\n+                           obligation: &Obligation,\n+                           bound: ty::BuiltinBound,\n+                           nested: Vec<ty::t>)\n+                           -> VtableBuiltinData<Obligation>\n+    {\n+        let obligations =\n+            result::collect(\n+                nested\n+                    .iter()\n+                    .map(|&t| {\n+                        util::obligation_for_builtin_bound(\n+                            self.tcx(),\n+                            obligation.cause,\n+                            bound,\n+                            obligation.recursion_depth + 1,\n+                            t)\n+                    }));\n+        let obligations = match obligations {\n+            Ok(o) => o,\n+            Err(ErrorReported) => Vec::new()\n+        };\n+        let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n+        VtableBuiltinData { nested: obligations }\n+    }\n+\n     fn confirm_impl_candidate(&mut self,\n                               obligation: &Obligation,\n                               impl_def_id: ast::DefId)\n@@ -1085,55 +1259,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()),\n                impl_def_id.repr(self.tcx()));\n \n-        // For a non-inhernet impl, we begin the same way as an\n-        // inherent impl, by matching the self-type and assembling\n-        // list of nested obligations.\n-        let vtable_impl =\n-            try!(self.confirm_inherent_impl_candidate(\n-                impl_def_id,\n-                obligation.cause,\n-                obligation.trait_ref.self_ty(),\n-                obligation.recursion_depth));\n-\n-        // But then we must also match the output types.\n-        let () = try!(self.confirm_impl_vtable(impl_def_id,\n-                                               obligation.cause,\n-                                               obligation.trait_ref.clone(),\n-                                               &vtable_impl.substs));\n-        Ok(vtable_impl)\n+        // First, create the substitutions by matching the impl again,\n+        // this time not in a probe.\n+        let substs = self.rematch_impl(impl_def_id, obligation);\n+        Ok(self.vtable_impl(impl_def_id, substs, obligation.cause, obligation.recursion_depth + 1))\n     }\n \n-    fn confirm_inherent_impl_candidate(&mut self,\n-                                       impl_def_id: ast::DefId,\n-                                       obligation_cause: ObligationCause,\n-                                       obligation_self_ty: ty::t,\n-                                       obligation_recursion_depth: uint)\n-                                       -> Result<VtableImplData<Obligation>,\n-                                                 SelectionError>\n+    fn vtable_impl(&mut self,\n+                   impl_def_id: ast::DefId,\n+                   substs: Substs,\n+                   cause: ObligationCause,\n+                   recursion_depth: uint)\n+                   -> VtableImplData<Obligation>\n     {\n-        let substs = match self.match_impl_self_types(impl_def_id,\n-                                                      obligation_cause,\n-                                                      obligation_self_ty) {\n-            Matched(substs) => substs,\n-            AmbiguousMatch | NoMatch => {\n-                self.tcx().sess.bug(\n-                    format!(\"Impl {} was matchable against {} but now is not\",\n-                            impl_def_id.repr(self.tcx()),\n-                            obligation_self_ty.repr(self.tcx()))\n-                        .as_slice());\n-            }\n-        };\n-\n         let impl_obligations =\n-            self.impl_obligations(obligation_cause,\n-                                  obligation_recursion_depth,\n+            self.impl_obligations(cause,\n+                                  recursion_depth,\n                                   impl_def_id,\n                                   &substs);\n-        let vtable_impl = VtableImplData { impl_def_id: impl_def_id,\n-                                       substs: substs,\n-                                       nested: impl_obligations };\n-\n-        Ok(vtable_impl)\n+        VtableImplData { impl_def_id: impl_def_id,\n+                         substs: substs,\n+                         nested: impl_obligations }\n     }\n \n     fn confirm_unboxed_closure_candidate(&mut self,\n@@ -1189,11 +1335,65 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // run inside of a `probe()` so that their side-effects are\n     // contained.\n \n-    fn match_impl_self_types(&mut self,\n-                             impl_def_id: ast::DefId,\n-                             obligation_cause: ObligationCause,\n-                             obligation_self_ty: ty::t)\n-                             -> MatchResult<Substs>\n+    fn rematch_impl(&mut self,\n+                    impl_def_id: ast::DefId,\n+                    obligation: &Obligation)\n+                    -> Substs\n+    {\n+        match self.match_impl(impl_def_id, obligation) {\n+            Ok(substs) => {\n+                substs\n+            }\n+            Err(()) => {\n+                self.tcx().sess.bug(\n+                    format!(\"Impl {} was matchable against {} but now is not\",\n+                            impl_def_id.repr(self.tcx()),\n+                            obligation.repr(self.tcx()))\n+                        .as_slice());\n+            }\n+        }\n+    }\n+\n+    fn match_impl(&mut self,\n+                  impl_def_id: ast::DefId,\n+                  obligation: &Obligation)\n+                  -> Result<Substs, ()>\n+    {\n+        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n+                                                      obligation.cause.span,\n+                                                      impl_def_id);\n+\n+        let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n+                                                impl_def_id).unwrap();\n+        let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n+                                                  &impl_substs);\n+\n+        match self.match_trait_refs(obligation, impl_trait_ref) {\n+            Ok(()) => Ok(impl_substs),\n+            Err(()) => Err(())\n+        }\n+    }\n+\n+    fn match_trait_refs(&mut self,\n+                        obligation: &Obligation,\n+                        trait_ref: Rc<ty::TraitRef>)\n+                        -> Result<(),()>\n+    {\n+        let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+        match self.infcx.sub_trait_refs(false,\n+                                        origin,\n+                                        trait_ref,\n+                                        obligation.trait_ref.clone()) {\n+            Ok(()) => Ok(()),\n+            Err(_) => Err(()),\n+        }\n+    }\n+\n+    fn match_inherent_impl(&mut self,\n+                           impl_def_id: ast::DefId,\n+                           obligation_cause: ObligationCause,\n+                           obligation_self_ty: ty::t)\n+                           -> Result<Substs,()>\n     {\n         /*!\n          * Determines whether the self type declared against\n@@ -1226,17 +1426,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_self_types(obligation_cause,\n                                     impl_self_ty,\n                                     obligation_self_ty) {\n-            Matched(()) => {\n+            Ok(()) => {\n                 debug!(\"Matched impl_substs={}\", impl_substs.repr(self.tcx()));\n-                Matched(impl_substs)\n+                Ok(impl_substs)\n             }\n-            AmbiguousMatch => {\n-                debug!(\"AmbiguousMatch\");\n-                AmbiguousMatch\n-            }\n-            NoMatch => {\n+            Err(()) => {\n                 debug!(\"NoMatch\");\n-                NoMatch\n+                Err(())\n             }\n         }\n     }\n@@ -1249,7 +1445,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                         // The self type the obligation is for:\n                         required_self_ty: ty::t)\n-                        -> MatchResult<()>\n+                        -> Result<(),()>\n     {\n         // FIXME(#5781) -- equating the types is stronger than\n         // necessary. Should consider variance of trait w/r/t Self.\n@@ -1259,21 +1455,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                   origin,\n                                   provided_self_ty,\n                                   required_self_ty) {\n-            Ok(()) => Matched(()),\n-            Err(ty::terr_sorts(ty::expected_found{expected: t1, found: t2})) => {\n-                // This error occurs when there is an unresolved type\n-                // variable in the `required_self_ty` that was forced\n-                // to unify with a non-type-variable. That basically\n-                // means we don't know enough to say with certainty\n-                // whether there is a match or not -- it depends on\n-                // how that type variable is ultimately resolved.\n-                if ty::type_is_skolemized(t1) || ty::type_is_skolemized(t2) {\n-                    AmbiguousMatch\n-                } else {\n-                    NoMatch\n-                }\n-            }\n-            Err(_) => NoMatch,\n+            Ok(()) => Ok(()),\n+            Err(_) => Err(()),\n         }\n     }\n \n@@ -1363,29 +1546,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n-    fn new_stack<'o>(&mut self, obligation: &'o Obligation) -> ObligationStack<'o> {\n-        let skol_obligation_self_ty =\n-            obligation.self_ty().fold_with(&mut self.skolemizer);\n-\n-        ObligationStack {\n-            obligation: obligation,\n-            skol_obligation_self_ty: skol_obligation_self_ty,\n-            previous: None\n-        }\n-    }\n-\n-    fn push_stack<'o>(&self,\n-                      previous_stack: &'o ObligationStack<'o>,\n-                      obligation: &'o Obligation)\n-                      -> ObligationStack<'o>\n+    fn push_stack<'o,'s:'o>(&mut self,\n+                            previous_stack: Option<&'s ObligationStack<'s>>,\n+                            obligation: &'o Obligation)\n+                            -> ObligationStack<'o>\n     {\n-        // No need to skolemize obligation.self_ty, because we\n-        // guarantee the self-type for all recursive obligations are\n-        // already skolemized.\n+        let skol_trait_ref = obligation.trait_ref.fold_with(&mut self.skolemizer);\n+\n         ObligationStack {\n             obligation: obligation,\n-            skol_obligation_self_ty: obligation.self_ty(),\n-            previous: Some(previous_stack)\n+            skol_trait_ref: skol_trait_ref,\n+            previous: previous_stack.map(|p| p), // FIXME variance\n         }\n     }\n \n@@ -1436,57 +1607,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n }\n \n-impl Candidate {\n-    fn to_evaluation_result(&self) -> EvaluationResult {\n-        match *self {\n-            Impl(ref i) => i.to_evaluation_result(),\n-\n-            ErrorCandidate |\n-            MatchedUnboxedClosureCandidate(..) |\n-            MatchedBuiltinCandidate |\n-            MatchedParamCandidate(..) => {\n-                EvaluatedToMatch\n-            }\n-\n-            AmbiguousBuiltinCandidate |\n-            AmbiguousParamCandidate => {\n-                EvaluatedToAmbiguity\n-            }\n-        }\n-    }\n-}\n-\n-impl ImplCandidate {\n-    fn to_evaluation_result(&self) -> EvaluationResult {\n-        match *self {\n-            MatchedImplCandidate(..) => EvaluatedToMatch,\n-            AmbiguousImplCandidate(..) => EvaluatedToAmbiguity\n-        }\n-    }\n-}\n-\n impl Repr for Candidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n-            MatchedBuiltinCandidate => format!(\"MatchedBuiltinCandidate\"),\n-            AmbiguousBuiltinCandidate => format!(\"AmbiguousBuiltinCandidate\"),\n-            MatchedUnboxedClosureCandidate(c) => format!(\"MatchedUnboxedClosureCandidate({})\", c),\n-            MatchedParamCandidate(ref r) => format!(\"MatchedParamCandidate({})\",\n-                                                    r.repr(tcx)),\n-            AmbiguousParamCandidate => format!(\"AmbiguousParamCandidate\"),\n-            Impl(ref i) => i.repr(tcx)\n-        }\n-    }\n-}\n-\n-impl Repr for ImplCandidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        match *self {\n-            MatchedImplCandidate(ref d) => format!(\"MatchedImplCandidate({})\",\n-                                                   d.repr(tcx)),\n-            AmbiguousImplCandidate(ref d) => format!(\"AmbiguousImplCandidate({})\",\n-                                                     d.repr(tcx)),\n+            BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n+            UnboxedClosureCandidate(c) => format!(\"MatchedUnboxedClosureCandidate({})\", c),\n+            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n+            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n         }\n     }\n }\n@@ -1521,20 +1649,16 @@ impl<'o> Iterator<&'o ObligationStack<'o>> for Option<&'o ObligationStack<'o>> {\n \n impl<'o> Repr for ObligationStack<'o> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"ObligationStack({}, {})\",\n-                self.obligation.repr(tcx),\n-                self.skol_obligation_self_ty.repr(tcx))\n+        format!(\"ObligationStack({})\",\n+                self.obligation.repr(tcx))\n     }\n }\n \n-impl CacheKey {\n-    pub fn new(trait_def_id: ast::DefId,\n-               skol_obligation_self_ty: ty::t)\n-               -> CacheKey\n-    {\n-        CacheKey {\n-            trait_def_id: trait_def_id,\n-            skol_obligation_self_ty: skol_obligation_self_ty\n+impl EvaluationResult {\n+    fn may_apply(&self) -> bool {\n+        match *self {\n+            EvaluatedToOk | EvaluatedToAmbig => true,\n+            EvaluatedToErr => false,\n         }\n     }\n }"}, {"sha": "31266ff199fa8c2112bb3eab9dd0fda00ce09242", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -319,8 +319,8 @@ impl<N:Repr> Repr for super::Vtable<N> {\n             super::VtableParam(ref v) =>\n                 format!(\"VtableParam({})\", v.repr(tcx)),\n \n-            super::VtableBuiltin =>\n-                format!(\"Builtin\"),\n+            super::VtableBuiltin(ref d) =>\n+                d.repr(tcx)\n         }\n     }\n }\n@@ -334,6 +334,13 @@ impl<N:Repr> Repr for super::VtableImplData<N> {\n     }\n }\n \n+impl<N:Repr> Repr for super::VtableBuiltinData<N> {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"VtableBuiltin(nested={})\",\n+                self.nested.repr(tcx))\n+    }\n+}\n+\n impl Repr for super::VtableParamData {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"VtableParam(bound={})\",\n@@ -344,12 +351,12 @@ impl Repr for super::VtableParamData {\n impl Repr for super::SelectionError {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n-            super::Unimplemented =>\n-                format!(\"Unimplemented\"),\n-\n             super::Overflow =>\n                 format!(\"Overflow\"),\n \n+            super::Unimplemented =>\n+                format!(\"Unimplemented\"),\n+\n             super::OutputTypeParameterMismatch(ref t, ref e) =>\n                 format!(\"OutputTypeParameterMismatch({}, {})\",\n                         t.repr(tcx),"}, {"sha": "9c1fcaa9ce8231d3d9fc6a576f29024009b94389", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -800,10 +800,18 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     let selection = match selcx.select(&obligation) {\n         Ok(Some(selection)) => selection,\n         Ok(None) => {\n-            tcx.sess.span_bug(\n+            // Ambiguity can happen when monomorphizing during trans\n+            // expands to some humongo type that never occurred\n+            // statically -- this humongo type can then overflow,\n+            // leading to an ambiguous result. So report this as an\n+            // overflow bug, since I believe this is the only case\n+            // where ambiguity can result.\n+            debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n+                    presuming due to overflow\",\n+                   trait_ref.repr(tcx));\n+            ccx.sess().span_fatal(\n                 span,\n-                format!(\"Encountered ambiguity selecting `{}` during trans\",\n-                        trait_ref.repr(tcx)).as_slice())\n+                \"reached the recursion limit during monomorphization\");\n         }\n         Err(e) => {\n             tcx.sess.span_bug(\n@@ -826,12 +834,19 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     });\n     match fulfill_cx.select_all_or_error(&infcx, &param_env, tcx) {\n         Ok(()) => { }\n-        Err(e) => {\n-            tcx.sess.span_bug(\n-                span,\n-                format!(\"Encountered errors `{}` fulfilling `{}` during trans\",\n-                        e.repr(tcx),\n-                        trait_ref.repr(tcx)).as_slice());\n+        Err(errors) => {\n+            if errors.iter().all(|e| e.is_overflow()) {\n+                // See Ok(None) case above.\n+                ccx.sess().span_fatal(\n+                    span,\n+                    \"reached the recursion limit during monomorphization\");\n+            } else {\n+                tcx.sess.span_bug(\n+                    span,\n+                    format!(\"Encountered errors `{}` fulfilling `{}` during trans\",\n+                            errors.repr(tcx),\n+                            trait_ref.repr(tcx)).as_slice());\n+            }\n         }\n     }\n "}, {"sha": "43c989982996fc2296ca5ae8889ff37b32bc8e6c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -247,7 +247,7 @@ static FLAGS_NONE: c_uint = 0;\n //  Public Interface of debuginfo module\n //=-----------------------------------------------------------------------------\n \n-#[deriving(Copy, Show, Hash, Eq, PartialEq, Clone)]\n+#[deriving(Show, Hash, Eq, PartialEq, Clone)]\n struct UniqueTypeId(ast::Name);\n \n // The TypeMap is where the CrateDebugContext holds the type metadata nodes"}, {"sha": "eb53fe2d67314f086c5739b85d8ea057f0388b53", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -561,7 +561,7 @@ pub fn get_vtable(bcx: Block,\n                                         DUMMY_SP,\n                                         trait_ref.clone());\n         match vtable {\n-            traits::VtableBuiltin => {\n+            traits::VtableBuiltin(_) => {\n                 Vec::new().into_iter()\n             }\n             traits::VtableImpl("}, {"sha": "e94764b0d0032b00178b489c800a0a09a89e6048", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -390,13 +390,21 @@ impl<N:TypeFoldable> TypeFoldable for traits::VtableImplData<N> {\n     }\n }\n \n+impl<N:TypeFoldable> TypeFoldable for traits::VtableBuiltinData<N> {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n+        traits::VtableBuiltinData {\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n     fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<N> {\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n             traits::VtableUnboxedClosure(d) => traits::VtableUnboxedClosure(d),\n             traits::VtableParam(ref p) => traits::VtableParam(p.fold_with(folder)),\n-            traits::VtableBuiltin => traits::VtableBuiltin,\n+            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n         }\n     }\n }"}, {"sha": "546ad86bc36750fbb9302523f90fd264a387dee4", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -10,8 +10,7 @@\n \n use middle::subst::{SelfSpace};\n use middle::traits;\n-use middle::traits::{SelectionError, Overflow,\n-                     OutputTypeParameterMismatch, Unimplemented};\n+use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n use middle::traits::{Obligation, obligation_for_builtin_bound};\n use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n use middle::traits::{ObligationCause};\n@@ -233,6 +232,16 @@ pub fn report_selection_error(fcx: &FnCtxt,\n                               error: &SelectionError)\n {\n     match *error {\n+        Overflow => {\n+            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+            fcx.tcx().sess.span_err(\n+                obligation.cause.span,\n+                format!(\n+                    \"overflow evaluating the trait `{}` for the type `{}`\",\n+                    trait_ref.user_string(fcx.tcx()),\n+                    self_ty.user_string(fcx.tcx())).as_slice());\n+            note_obligation_cause(fcx, obligation);\n+        }\n         Unimplemented => {\n             let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n             if !ty::type_is_error(self_ty) {\n@@ -245,9 +254,6 @@ pub fn report_selection_error(fcx: &FnCtxt,\n                 note_obligation_cause(fcx, obligation);\n             }\n         }\n-        Overflow => {\n-            report_overflow(fcx, obligation);\n-        }\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref e) => {\n             let expected_trait_ref =\n                 fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n@@ -269,21 +275,6 @@ pub fn report_selection_error(fcx: &FnCtxt,\n     }\n }\n \n-pub fn report_overflow(fcx: &FnCtxt, obligation: &Obligation) {\n-    let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n-    if ty::type_is_error(self_ty) {\n-        fcx.tcx().sess.span_err(\n-            obligation.cause.span,\n-            format!(\n-                \"could not locate an impl of the trait `{}` for \\\n-                 the type `{}` due to overflow; possible cyclic \\\n-                 dependency between impls\",\n-                trait_ref.user_string(fcx.tcx()),\n-                self_ty.user_string(fcx.tcx())).as_slice());\n-        note_obligation_cause(fcx, obligation);\n-    }\n-}\n-\n pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n@@ -294,8 +285,9 @@ pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n            trait_ref.repr(fcx.tcx()),\n            self_ty.repr(fcx.tcx()),\n            obligation.repr(fcx.tcx()));\n-    if ty::type_is_error(self_ty) {\n-    } else if ty::type_needs_infer(self_ty) {\n+    let all_types = &trait_ref.substs.types;\n+    if all_types.iter().any(|&t| ty::type_is_error(t)) {\n+    } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n         // This is kind of a hack: it frequently happens that some earlier\n         // error prevents types from being fully inferred, and then we get\n         // a bunch of uninteresting errors saying something like \"<generic\n@@ -321,7 +313,7 @@ pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n                     self_ty.user_string(fcx.tcx())).as_slice());\n             note_obligation_cause(fcx, obligation);\n         }\n-    } else if fcx.tcx().sess.err_count() == 0 {\n+    } else if !fcx.tcx().sess.has_errors() {\n          // Ambiguity. Coherence should have reported an error.\n         fcx.tcx().sess.span_bug(\n             obligation.cause.span,"}, {"sha": "ccfa31df8264674ec182c60cc272079fd8b4c00f", "filename": "src/librustc/middle/typeck/coherence/overlap.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -35,8 +35,16 @@ struct OverlapChecker<'cx, 'tcx:'cx> {\n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     fn check_for_overlapping_impls(&self) {\n         debug!(\"check_for_overlapping_impls\");\n-        let trait_impls = self.tcx.trait_impls.borrow();\n-        for trait_def_id in trait_impls.keys() {\n+\n+        // Collect this into a vector to avoid holding the\n+        // refcell-lock during the\n+        // check_for_overlapping_impls_of_trait() check, since that\n+        // check can populate this table further with impls from other\n+        // crates.\n+        let trait_def_ids: Vec<ast::DefId> =\n+            self.tcx.trait_impls.borrow().keys().map(|&d| d).collect();\n+\n+        for trait_def_id in trait_def_ids.iter() {\n             self.check_for_overlapping_impls_of_trait(*trait_def_id);\n         }\n     }"}, {"sha": "2e4987c76d4d771d0f16af2a277987163f7c6deb", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 61, "deletions": 28, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -27,18 +27,8 @@ use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty;\n use middle::ty_fold;\n-use middle::ty_fold::TypeFolder;\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n-use middle::typeck::infer::coercion::Coerce;\n-use middle::typeck::infer::combine::{Combine, CombineFields};\n-use middle::typeck::infer::region_inference::{RegionVarBindings,\n-                                              RegionSnapshot};\n-use middle::typeck::infer::resolve::{resolver};\n-use middle::typeck::infer::equate::Equate;\n-use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::unify::{UnificationTable};\n-use middle::typeck::infer::error_reporting::ErrorReporting;\n use std::cell::{RefCell};\n use std::collections::HashMap;\n use std::rc::Rc;\n@@ -48,6 +38,16 @@ use syntax::codemap::Span;\n use util::common::indent;\n use util::ppaux::{bound_region_to_string, ty_to_string, trait_ref_to_string, Repr};\n \n+use self::coercion::Coerce;\n+use self::combine::{Combine, CombineFields};\n+use self::region_inference::{RegionVarBindings, RegionSnapshot};\n+use self::resolve::{resolver};\n+use self::equate::Equate;\n+use self::sub::Sub;\n+use self::lub::Lub;\n+use self::unify::{UnificationTable, InferCtxtMethodsForSimplyUnifiableTypes};\n+use self::error_reporting::ErrorReporting;\n+\n pub mod coercion;\n pub mod combine;\n pub mod doc;\n@@ -503,6 +503,10 @@ pub struct CombinedSnapshot {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn skolemize<T:TypeFoldable>(&self, t: T) -> T {\n+        t.fold_with(&mut self.skolemizer())\n+    }\n+\n     pub fn skolemizer<'a>(&'a self) -> TypeSkolemizer<'a, 'tcx> {\n         skolemize::TypeSkolemizer::new(self)\n     }\n@@ -630,11 +634,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      -> ures\n     {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n-        let trace = TypeTrace {\n-            origin: origin,\n-            values: Types(expected_found(a_is_expected, a, b))\n-        };\n-        self.sub(a_is_expected, trace).tys(a, b).to_ures()\n+        self.commit_if_ok(|| {\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: Types(expected_found(a_is_expected, a, b))\n+            };\n+            self.sub(a_is_expected, trace).tys(a, b).to_ures()\n+        })\n     }\n \n     pub fn eq_types(&self,\n@@ -644,11 +650,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     b: ty::t)\n                     -> ures\n     {\n-        let trace = TypeTrace {\n-            origin: origin,\n-            values: Types(expected_found(a_is_expected, a, b))\n-        };\n-        self.equate(a_is_expected, trace).tys(a, b).to_ures()\n+        self.commit_if_ok(|| {\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: Types(expected_found(a_is_expected, a, b))\n+            };\n+            self.equate(a_is_expected, trace).tys(a, b).to_ures()\n+        })\n     }\n \n     pub fn sub_trait_refs(&self,\n@@ -661,13 +669,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"sub_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n                b.repr(self.tcx));\n-        let trace = TypeTrace {\n-            origin: origin,\n-            values: TraitRefs(expected_found(a_is_expected,\n-                                             a.clone(), b.clone()))\n-        };\n-        let suber = self.sub(a_is_expected, trace);\n-        suber.trait_refs(&*a, &*b).to_ures()\n+        self.commit_if_ok(|| {\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: TraitRefs(expected_found(a_is_expected,\n+                                                 a.clone(), b.clone()))\n+            };\n+            self.sub(a_is_expected, trace).trait_refs(&*a, &*b).to_ures()\n+        })\n     }\n }\n \n@@ -789,6 +798,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn shallow_resolve(&self, typ: ty::t) -> ty::t {\n+        match ty::get(typ).sty {\n+            ty::ty_infer(ty::TyVar(v)) => {\n+                self.type_variables.borrow()\n+                    .probe(v)\n+                    .unwrap_or(typ)\n+            }\n+\n+            ty::ty_infer(ty::IntVar(v)) => {\n+                self.probe_var(v)\n+                    .unwrap_or(typ)\n+            }\n+\n+            ty::ty_infer(ty::FloatVar(v)) => {\n+                self.probe_var(v)\n+                    .unwrap_or(typ)\n+            }\n+\n+            _ => {\n+                typ\n+            }\n+        }\n+    }\n+\n     pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n         match resolve_type(self,\n                            None,"}, {"sha": "1b3290c8b5af8f5c3172cfdfe4e63aee4256d6cd", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -12,17 +12,18 @@\n  * Skolemization is the process of replacing unknown variables with\n  * fresh types. The idea is that the type, after skolemization,\n  * contains no inference variables but instead contains either a value\n- * for each variable (if the variable had already fresh \"arbitrary\"\n- * types wherever a variable would have been.\n+ * for each variable or fresh \"arbitrary\" types wherever a variable\n+ * would have been.\n  *\n- * Skolemization is used wherever we want to test what the type\n- * inferencer knows \"so far\". The primary place it is used right now\n- * is in the trait matching algorithm, which needs to be able to test\n- * whether an `impl` self type matches some other type X -- *without*\n- * affecting `X`. That means if that if the type `X` is in fact an\n- * unbound type variable, we want the match to be regarded as\n- * ambiguous, because depending on what type that type variable is\n- * ultimately assigned, the match may or may not succeed.\n+ * Skolemization is used primarily to get a good type for inserting\n+ * into a cache. The result summarizes what the type inferencer knows\n+ * \"so far\". The primary place it is used right now is in the trait\n+ * matching algorithm, which needs to be able to cache whether an\n+ * `impl` self type matches some other type X -- *without* affecting\n+ * `X`. That means if that if the type `X` is in fact an unbound type\n+ * variable, we want the match to be regarded as ambiguous, because\n+ * depending on what type that type variable is ultimately assigned,\n+ * the match may or may not succeed.\n  *\n  * Note that you should be careful not to allow the output of\n  * skolemization to leak to the user in error messages or in any other\n@@ -43,39 +44,45 @@ use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n+use std::collections::hashmap;\n \n use super::InferCtxt;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n-use super::unify::SimplyUnifiable;\n-use super::unify::UnifyKey;\n \n pub struct TypeSkolemizer<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    skolemization_count: uint\n+    skolemization_count: uint,\n+    skolemization_map: hashmap::HashMap<ty::InferTy, ty::t>,\n }\n \n impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n     pub fn new<'tcx>(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n-        TypeSkolemizer { infcx: infcx, skolemization_count: 0 }\n-    }\n-\n-    fn probe_ty(&mut self, v: ty::TyVid) -> ty::t {\n-        self.skolemize_if_none(self.infcx.type_variables.borrow().probe(v), ty::SkolemizedTy)\n+        TypeSkolemizer {\n+            infcx: infcx,\n+            skolemization_count: 0,\n+            skolemization_map: hashmap::HashMap::new(),\n+        }\n     }\n \n-    fn probe_unifiable<V:SimplyUnifiable,K:UnifyKey<Option<V>>>(&mut self, k: K) -> ty::t {\n-        self.skolemize_if_none(self.infcx.probe_var(k), ty::SkolemizedIntTy)\n-    }\n+    fn skolemize(&mut self,\n+                 opt_ty: Option<ty::t>,\n+                 key: ty::InferTy,\n+                 skolemizer: |uint| -> ty::InferTy)\n+                 -> ty::t\n+    {\n+        match opt_ty {\n+            Some(ty) => { return ty.fold_with(self); }\n+            None => { }\n+        }\n \n-    fn skolemize_if_none(&mut self, o: Option<ty::t>,\n-                         skolemizer: |uint| -> ty::InferTy)\n-                         -> ty::t {\n-        match o {\n-            Some(t) => t.fold_with(self),\n-            None => {\n+        match self.skolemization_map.entry(key) {\n+            hashmap::Occupied(entry) => *entry.get(),\n+            hashmap::Vacant(entry) => {\n                 let index = self.skolemization_count;\n                 self.skolemization_count += 1;\n-                ty::mk_infer(self.tcx(), skolemizer(index))\n+                let t = ty::mk_infer(self.infcx.tcx, skolemizer(index));\n+                entry.set(t);\n+                t\n             }\n         }\n     }\n@@ -108,15 +115,21 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         match ty::get(t).sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n-                self.probe_ty(v)\n+                self.skolemize(self.infcx.type_variables.borrow().probe(v),\n+                               ty::TyVar(v),\n+                               ty::SkolemizedTy)\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.probe_unifiable(v)\n+                self.skolemize(self.infcx.probe_var(v),\n+                               ty::IntVar(v),\n+                               ty::SkolemizedIntTy)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.probe_unifiable(v)\n+                self.skolemize(self.infcx.probe_var(v),\n+                               ty::FloatVar(v),\n+                               ty::SkolemizedIntTy)\n             }\n \n             ty::ty_infer(ty::SkolemizedTy(c)) |"}, {"sha": "4902766534a139d620203e6cc065ef9f08fa365f", "filename": "src/test/auxiliary/go_trait.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fauxiliary%2Fgo_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fauxiliary%2Fgo_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fgo_trait.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Common code used for tests that model the Fn/FnMut/FnOnce hierarchy.\n+\n+pub trait Go {\n+    fn go(&self, arg: int);\n+}\n+\n+pub fn go<G:Go>(this: &G, arg: int) {\n+    this.go(arg)\n+}\n+\n+pub trait GoMut {\n+    fn go_mut(&mut self, arg: int);\n+}\n+\n+pub fn go_mut<G:GoMut>(this: &mut G, arg: int) {\n+    this.go_mut(arg)\n+}\n+\n+pub trait GoOnce {\n+    fn go_once(self, arg: int);\n+}\n+\n+pub fn go_once<G:GoOnce>(this: G, arg: int) {\n+    this.go_once(arg)\n+}\n+\n+impl<G> GoMut for G\n+    where G : Go\n+{\n+    fn go_mut(&mut self, arg: int) {\n+        go(&*self, arg)\n+    }\n+}\n+\n+impl<G> GoOnce for G\n+    where G : GoMut\n+{\n+    fn go_once(mut self, arg: int) {\n+        go_mut(&mut self, arg)\n+    }\n+}"}, {"sha": "2e163bc11a80469beb2f560d9cde8ff4552547e1", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific-cross-crate.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-cross-crate.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:go_trait.rs\n+\n+extern crate go_trait;\n+\n+use go_trait::{Go,GoMut};\n+use std::fmt::Show;\n+use std::default::Default;\n+\n+struct MyThingy;\n+\n+impl Go for MyThingy {\n+    fn go(&self, arg: int) { }\n+}\n+\n+impl GoMut for MyThingy { //~ ERROR conflicting implementations\n+    fn go_mut(&mut self, arg: int) { }\n+}\n+\n+fn main() { }"}, {"sha": "578de06b74780da03fd72c4cda87673aab1a1012", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific-multidispatch.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+use std::default::Default;\n+\n+// Test that a blank impl for all T conflicts with an impl for some\n+// specific T, even when there are multiple type parameters involved.\n+\n+trait MyTrait<T> {\n+    fn get(&self) -> T;\n+}\n+\n+impl<T> MyTrait<T> for T { //~ ERROR E0119\n+    fn get(&self) -> T {\n+        fail!()\n+    }\n+}\n+\n+#[deriving(Clone)]\n+struct MyType {\n+    dummy: uint\n+}\n+\n+impl MyTrait<MyType> for MyType {\n+    fn get(&self) -> uint { (*self).clone() }\n+}\n+\n+fn main() { }"}, {"sha": "9db322a5517fb40e001422ed80b824ccef4cb4a4", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific-trait.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-trait.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a blank impl for all T:PartialEq conflicts with an impl for some\n+// specific T when T:PartialEq.\n+\n+trait OtherTrait {\n+    fn noop(&self);\n+}\n+\n+trait MyTrait {\n+    fn get(&self) -> uint;\n+}\n+\n+impl<T:OtherTrait> MyTrait for T { //~ ERROR E0119\n+    fn get(&self) -> uint { 0 }\n+}\n+\n+struct MyType {\n+    dummy: uint\n+}\n+\n+impl MyTrait for MyType {\n+    fn get(&self) -> uint { self.dummy }\n+}\n+\n+impl OtherTrait for MyType {\n+    fn noop(&self) { }\n+}\n+\n+fn main() { }"}, {"sha": "936025385bb5e514fd1348ec6cbe3a5bf45b6598", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+use std::default::Default;\n+\n+// Test that a blank impl for all T conflicts with an impl for some\n+// specific T.\n+\n+trait MyTrait {\n+    fn get(&self) -> uint;\n+}\n+\n+impl<T> MyTrait for T { //~ ERROR E0119\n+    fn get(&self) -> uint { 0 }\n+}\n+\n+struct MyType {\n+    dummy: uint\n+}\n+\n+impl MyTrait for MyType {\n+    fn get(&self) -> uint { self.dummy }\n+}\n+\n+fn main() { }"}, {"sha": "99446be43acaa7930caf30614581a0ce0d7f6328", "filename": "src/test/compile-fail/coherence-cross-crate-conflict.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "previous_filename": "src/test/compile-fail/conflicting-implementations-aux.rs"}, {"sha": "279de3d02559af722214b2e371302f397e2e8f5e", "filename": "src/test/compile-fail/coherence-multidispatch-tuple", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-multidispatch-tuple", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-multidispatch-tuple", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-multidispatch-tuple?ref=b74208bc12390b168e4a342de27d806639d89ffe"}, {"sha": "92fa725cb1e169460e9f9e90c6728756bd686881", "filename": "src/test/compile-fail/coherence-tuple-conflict.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+use std::default::Default;\n+\n+// Test that a blank impl for all T conflicts with an impl for some\n+// specific T.\n+\n+trait MyTrait {\n+    fn get(&self) -> uint;\n+}\n+\n+impl<T> MyTrait for (T,T) { //~ ERROR E0119\n+    fn get(&self) -> uint { 0 }\n+}\n+\n+impl<A,B> MyTrait for (A,B) {\n+    fn get(&self) -> uint { self.dummy }\n+}\n+\n+fn main() { }"}, {"sha": "d6a2fb75fa210d9a8c897659f12e811b5ce31130", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -20,9 +20,8 @@ impl<T:Dot> Dot for Cons<T> {\n   }\n }\n fn test<T:Dot> (n:int, i:int, first:T, second:T) ->int {\n-    //~^ ERROR: reached the recursion limit during monomorphization\n-  match n {\n-    0 => {first.dot(second)}\n+  match n {    0 => {first.dot(second)}\n+      //~^ ERROR: reached the recursion limit during monomorphization\n       // Error message should be here. It should be a type error\n       // to instantiate `test` at a type other than T. (See #4287)\n     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}"}, {"sha": "fcfd079997734abe0a5ad7383854a55369fb214c", "filename": "src/test/compile-fail/trait-coercion-generic-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -25,6 +25,6 @@ impl Trait<&'static str> for Struct {\n \n fn main() {\n     let s: Box<Trait<int>> = box Struct { person: \"Fred\" };\n-    //~^ ERROR type mismatch\n+    //~^ ERROR the trait `Trait<int>` is not implemented for the type `Struct`\n     s.f(1);\n }"}, {"sha": "f5ce904a4bb5cd4833ec706830fc369cd193f2e9", "filename": "src/test/compile-fail/traits-multidispatch-bad.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we detect an illegal combination of types.\n+\n+trait Convert<Target> {\n+    fn convert(&self) -> Target;\n+}\n+\n+impl Convert<uint> for int {\n+    fn convert(&self) -> uint {\n+        *self as uint\n+    }\n+}\n+\n+fn test<T,U>(_: T, _: U)\n+where T : Convert<U>\n+{\n+}\n+\n+fn a() {\n+    test(22i, 44i); //~ ERROR not implemented\n+}\n+\n+fn main() {}"}, {"sha": "9ceae41d1a4659088fb8ae241c0440c4075d012f", "filename": "src/test/compile-fail/traits-multidispatch-convert-ambig-dest.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we get an error in a multidisptach scenario where the\n+// set of impls is ambiguous.\n+\n+trait Convert<Target> {\n+    fn convert(&self) -> Target;\n+}\n+\n+impl Convert<i8> for i32 {\n+    fn convert(&self) -> i8 {\n+        *self as i8\n+    }\n+}\n+\n+impl Convert<i16> for i32 {\n+    fn convert(&self) -> i16 {\n+        *self as i16\n+    }\n+}\n+\n+fn test<T,U>(_: T, _: U)\n+where T : Convert<U>\n+{\n+}\n+\n+fn a() {\n+    test(22_i32, 44); //~ ERROR unable to infer\n+}\n+\n+fn main() {}"}, {"sha": "d1bbda932cb734e47e28cff29e7e49777e5a1858", "filename": "src/test/compile-fail/type-params-in-different-spaces-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -15,12 +15,12 @@ trait Tr<T> {\n // these compile as if Self: Tr<U>, even tho only Self: Tr<Self or T>\n trait A:    Tr<Self> {\n     fn test<U>(u: U) -> Self {\n-        Tr::op(u)   //~ ERROR type mismatch\n+        Tr::op(u)   //~ ERROR not implemented\n     }\n }\n trait B<T>: Tr<T> {\n     fn test<U>(u: U) -> Self {\n-        Tr::op(u)   //~ ERROR type mismatch\n+        Tr::op(u)   //~ ERROR not implemented\n     }\n }\n "}, {"sha": "04a69bbf3a2bc1b1748db4324e605c193f1804f4", "filename": "src/test/run-pass/coherence-multidispatch-tuple.rs", "status": "renamed", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Fcoherence-multidispatch-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Fcoherence-multidispatch-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-multidispatch-tuple.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,15 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {\n-}\n+use std::fmt::Show;\n+use std::default::Default;\n \n-impl Foo for int { //~ ERROR conflicting implementations\n+// Test that an impl for homogeneous pairs does not conflict with a\n+// heterogeneous pair.\n \n+trait MyTrait {\n+    fn get(&self) -> uint;\n }\n \n-impl<A> Foo for A { //~ NOTE conflicting implementation here\n+impl<T> MyTrait for (T,T) {\n+    fn get(&self) -> uint { 0 }\n+}\n \n+impl MyTrait for (uint,int) {\n+    fn get(&self) -> uint { 0 }\n }\n \n fn main() {", "previous_filename": "src/test/compile-fail/conflicting-implementations.rs"}, {"sha": "faec0c502808c97028a086c128aeb60e3e2e0ec8", "filename": "src/test/run-pass/coherence-where-clause.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Fcoherence-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Fcoherence-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-where-clause.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+use std::default::Default;\n+\n+trait MyTrait {\n+    fn get(&self) -> Self;\n+}\n+\n+impl<T> MyTrait for T\n+    where T : Default\n+{\n+    fn get(&self) -> T {\n+        Default::default()\n+    }\n+}\n+\n+#[deriving(Clone,Show,PartialEq)]\n+struct MyType {\n+    dummy: uint\n+}\n+\n+impl MyTrait for MyType {\n+    fn get(&self) -> MyType { (*self).clone() }\n+}\n+\n+fn test_eq<M>(m: M, n: M)\n+where M : MyTrait + Show + PartialEq\n+{\n+    assert_eq!(m.get(), n);\n+}\n+\n+pub fn main() {\n+    test_eq(0u, 0u);\n+\n+    let value = MyType { dummy: 256 + 22 };\n+    test_eq(value, value);\n+}"}, {"sha": "76c87f5d4c59f4763fec8d1d5d7c52a3d21f3e8d", "filename": "src/test/run-pass/multidispatch1.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Fmultidispatch1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Fmultidispatch1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultidispatch1.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+\n+trait MyTrait<T> {\n+    fn get(&self) -> T;\n+}\n+\n+struct MyType {\n+    dummy: uint\n+}\n+\n+impl MyTrait<uint> for MyType {\n+    fn get(&self) -> uint { self.dummy }\n+}\n+\n+impl MyTrait<u8> for MyType {\n+    fn get(&self) -> u8 { self.dummy as u8 }\n+}\n+\n+fn test_eq<T,M>(m: M, v: T)\n+where T : Eq + Show,\n+      M : MyTrait<T>\n+{\n+    assert_eq!(m.get(), v);\n+}\n+\n+pub fn main() {\n+    let value = MyType { dummy: 256 + 22 };\n+    test_eq::<uint, _>(value, value.dummy);\n+    test_eq::<u8, _>(value, value.dummy as u8);\n+}"}, {"sha": "13131be93c892b61ed5ab6ae77314358d89af884", "filename": "src/test/run-pass/multidispatch2.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Fmultidispatch2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Fmultidispatch2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultidispatch2.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+use std::default::Default;\n+\n+trait MyTrait<T> {\n+    fn get(&self) -> T;\n+}\n+\n+impl<T> MyTrait<T> for T\n+    where T : Default\n+{\n+    fn get(&self) -> T {\n+        Default::default()\n+    }\n+}\n+\n+struct MyType {\n+    dummy: uint\n+}\n+\n+impl MyTrait<uint> for MyType {\n+    fn get(&self) -> uint { self.dummy }\n+}\n+\n+fn test_eq<T,M>(m: M, v: T)\n+where T : Eq + Show,\n+      M : MyTrait<T>\n+{\n+    assert_eq!(m.get(), v);\n+}\n+\n+pub fn main() {\n+    test_eq(22u, 0u);\n+\n+    let value = MyType { dummy: 256 + 22 };\n+    test_eq(value, value.dummy);\n+}"}, {"sha": "a94f73c2b6da7c3b9efc6db8d8ac715e3d239603", "filename": "src/test/run-pass/traits-conditional-dispatch.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to resolve conditional dispatch.  Here, the\n+// blanket impl for T:Copy coexists with an impl for Box<T>, because\n+// Box does not impl Copy.\n+\n+trait Get {\n+    fn get(&self) -> Self;\n+}\n+\n+impl<T:Copy> Get for T {\n+    fn get(&self) -> T { *self }\n+}\n+\n+impl<T:Get> Get for Box<T> {\n+    fn get(&self) -> Box<T> { box get_it(&**self) }\n+}\n+\n+fn get_it<T:Get>(t: &T) -> T {\n+    (*t).get()\n+}\n+\n+fn main() {\n+    assert_eq!(get_it(&1_u32), 1_u32);\n+    assert_eq!(get_it(&1_u16), 1_u16);\n+    assert_eq!(get_it(&Some(1_u16)), Some(1_u16));\n+    assert_eq!(get_it(&box 1i), box 1i);\n+}"}, {"sha": "92ba5aad05958f7f142c11027d5bb63f92f76ac6", "filename": "src/test/run-pass/traits-conditional-model-fn.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Ftraits-conditional-model-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Ftraits-conditional-model-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-conditional-model-fn.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A model for how the `Fn` traits could work. You can implement at\n+// most one of `Go`, `GoMut`, or `GoOnce`, and then the others follow\n+// automatically.\n+\n+// aux-build:go_trait.rs\n+\n+extern crate go_trait;\n+\n+use go_trait::{Go, GoMut, GoOnce, go, go_mut, go_once};\n+\n+use std::rc::Rc;\n+use std::cell::Cell;\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct SomeGoableThing {\n+    counter: Rc<Cell<int>>\n+}\n+\n+impl Go for SomeGoableThing {\n+    fn go(&self, arg: int) {\n+        self.counter.set(self.counter.get() + arg);\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct SomeGoOnceableThing {\n+    counter: Rc<Cell<int>>\n+}\n+\n+impl GoOnce for SomeGoOnceableThing {\n+    fn go_once(self, arg: int) {\n+        self.counter.set(self.counter.get() + arg);\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+fn main() {\n+    let counter = Rc::new(Cell::new(0));\n+    let mut x = SomeGoableThing { counter: counter.clone() };\n+\n+    go(&x, 10);\n+    assert_eq!(counter.get(), 10);\n+\n+    go_mut(&mut x, 100);\n+    assert_eq!(counter.get(), 110);\n+\n+    go_once(x, 1_000);\n+    assert_eq!(counter.get(), 1_110);\n+\n+    let x = SomeGoOnceableThing { counter: counter.clone() };\n+\n+    go_once(x, 10_000);\n+    assert_eq!(counter.get(), 11_110);\n+}"}, {"sha": "c10029791df52d68fa27faaabfb1ad8cf52c6eeb", "filename": "src/test/run-pass/traits-multidispatch-infer-convert-source-and-target.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Ftraits-multidispatch-infer-convert-source-and-target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Ftraits-multidispatch-infer-convert-source-and-target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-multidispatch-infer-convert-source-and-target.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that if there is one impl we can infer everything.\n+\n+use std::mem;\n+\n+trait Convert<Target> {\n+    fn convert(&self) -> Target;\n+}\n+\n+impl Convert<u32> for i16 {\n+    fn convert(&self) -> u32 {\n+        *self as u32\n+    }\n+}\n+\n+fn test<T,U>(_: T, _: U, t_size: uint, u_size: uint)\n+where T : Convert<U>\n+{\n+    assert_eq!(mem::size_of::<T>(), t_size);\n+    assert_eq!(mem::size_of::<U>(), u_size);\n+}\n+\n+fn main() {\n+    // T = i16, U = u32\n+    test(22, 44,  2, 4);\n+}"}, {"sha": "54515f3b0d7d832b0e8494a2f9b0d9cb1ddcdd9b", "filename": "src/test/run-pass/traits-multidispatch-infer-convert-target.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Ftraits-multidispatch-infer-convert-target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74208bc12390b168e4a342de27d806639d89ffe/src%2Ftest%2Frun-pass%2Ftraits-multidispatch-infer-convert-target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-multidispatch-infer-convert-target.rs?ref=b74208bc12390b168e4a342de27d806639d89ffe", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can infer the Target based on the Self or vice versa.\n+\n+use std::mem;\n+\n+trait Convert<Target> {\n+    fn convert(&self) -> Target;\n+}\n+\n+impl Convert<u32> for i16 {\n+    fn convert(&self) -> u32 {\n+        *self as u32\n+    }\n+}\n+\n+impl Convert<i16> for u32 {\n+    fn convert(&self) -> i16 {\n+        *self as i16\n+    }\n+}\n+\n+fn test<T,U>(_: T, _: U, t_size: uint, u_size: uint)\n+where T : Convert<U>\n+{\n+    assert_eq!(mem::size_of::<T>(), t_size);\n+    assert_eq!(mem::size_of::<U>(), u_size);\n+}\n+\n+fn main() {\n+    // T = i16, U = u32\n+    test(22_i16, 44,  2, 4);\n+    test(22, 44_u32, 2, 4);\n+\n+    // T = u32, U = i16\n+    test(22_u32, 44, 4, 2);\n+    test(22, 44_i16, 4, 2);\n+}"}]}