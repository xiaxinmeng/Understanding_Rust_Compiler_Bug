{"sha": "f45b570e08f0f4146e16e426842210f395e8284a", "node_id": "C_kwDOAAsO6NoAKGY0NWI1NzBlMDhmMGY0MTQ2ZTE2ZTQyNjg0MjIxMGYzOTVlODI4NGE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-21T15:36:26Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-21T15:36:26Z"}, "message": "Add 'src/tools/miri/' from commit '75dd959a3a40eb5b4574f8d2e23aa6efbeb33573'\n\ngit-subtree-dir: src/tools/miri\ngit-subtree-mainline: 3f3167fb59341ac3240ca1774f48e8c053219131\ngit-subtree-split: 75dd959a3a40eb5b4574f8d2e23aa6efbeb33573", "tree": {"sha": "f49f598509fda5b0bdbb7b9c0d97f0f2503ffe18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f49f598509fda5b0bdbb7b9c0d97f0f2503ffe18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f45b570e08f0f4146e16e426842210f395e8284a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f45b570e08f0f4146e16e426842210f395e8284a", "html_url": "https://github.com/rust-lang/rust/commit/f45b570e08f0f4146e16e426842210f395e8284a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f45b570e08f0f4146e16e426842210f395e8284a/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f3167fb59341ac3240ca1774f48e8c053219131", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f3167fb59341ac3240ca1774f48e8c053219131", "html_url": "https://github.com/rust-lang/rust/commit/3f3167fb59341ac3240ca1774f48e8c053219131"}, {"sha": "75dd959a3a40eb5b4574f8d2e23aa6efbeb33573", "url": "https://api.github.com/repos/rust-lang/rust/commits/75dd959a3a40eb5b4574f8d2e23aa6efbeb33573", "html_url": "https://github.com/rust-lang/rust/commit/75dd959a3a40eb5b4574f8d2e23aa6efbeb33573"}], "stats": {"total": 54796, "additions": 54796, "deletions": 0}, "files": [{"sha": "3c1f41bdcca6c6fd7ef721d7821433059962ee4b", "filename": "src/tools/miri/.editorconfig", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.editorconfig?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,25 @@\n+# EditorConfig helps developers define and maintain consistent\n+# coding styles between different editors and IDEs\n+# editorconfig.org\n+\n+root = true\n+\n+\n+[*]\n+end_of_line = lf\n+charset = utf-8\n+trim_trailing_whitespace = true\n+insert_final_newline = true\n+indent_style = space\n+indent_size = 4\n+\n+[*.rs]\n+indent_style = space\n+indent_size = 4\n+\n+[*.toml]\n+indent_style = space\n+indent_size = 4\n+\n+[*.md]\n+trim_trailing_whitespace = false"}, {"sha": "2742e4d1d5b9b48c41bf002b898878be0e354e28", "filename": "src/tools/miri/.gitattributes", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.gitattributes?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,6 @@\n+* text=auto eol=lf\n+\n+# Older git versions try to fix line endings on images, this prevents it.\n+*.png binary\n+*.jpg binary\n+*.ico binary"}, {"sha": "80d150e1df15de4869a7456d346d7b3c487da60c", "filename": "src/tools/miri/.github/workflows/ci.yml", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,156 @@\n+name: CI\n+\n+on:\n+  push:\n+    # Run in PRs and for bors, but not on master.\n+    branches:\n+      - 'auto'\n+      - 'try'\n+  pull_request:\n+    branches:\n+      - 'master'\n+  schedule:\n+    - cron: '5 15 * * *' # At 15:05 UTC every day.\n+\n+jobs:\n+  build:\n+    runs-on: ${{ matrix.os }}\n+    env:\n+      RUST_BACKTRACE: 1\n+      HOST_TARGET: ${{ matrix.host_target }}\n+    strategy:\n+      matrix:\n+        build: [linux64, macos, win32]\n+        include:\n+          - build: linux64\n+            os: ubuntu-latest\n+            host_target: x86_64-unknown-linux-gnu\n+          - build: macos\n+            os: macos-latest\n+            host_target: x86_64-apple-darwin\n+          - build: win32\n+            os: windows-latest\n+            host_target: i686-pc-windows-msvc\n+    steps:\n+      - uses: actions/checkout@v3\n+\n+      - name: Set the tag GC interval to 1 on linux\n+        if: runner.os == 'Linux'\n+        run: echo \"MIRIFLAGS=-Zmiri-tag-gc=1\" >> $GITHUB_ENV\n+\n+      # We install gnu-tar because BSD tar is buggy on macOS builders of GHA.\n+      # See <https://github.com/actions/cache/issues/403>.\n+      - name: Install GNU tar\n+        if: runner.os == 'macOS'\n+        run: |\n+          brew install gnu-tar\n+          echo \"/usr/local/opt/gnu-tar/libexec/gnubin\" >> $GITHUB_PATH\n+\n+      # Cache the global cargo directory, but NOT the local `target` directory which\n+      # we cannot reuse anyway when the nightly changes (and it grows quite large\n+      # over time).\n+      - name: Add cache for cargo\n+        id: cache\n+        uses: actions/cache@v3\n+        with:\n+          path: |\n+            # Taken from <https://doc.rust-lang.org/nightly/cargo/guide/cargo-home.html#caching-the-cargo-home-in-ci>.\n+            ~/.cargo/bin\n+            ~/.cargo/registry/index\n+            ~/.cargo/registry/cache\n+            ~/.cargo/git/db\n+            # contains package information of crates installed via `cargo install`.\n+            ~/.cargo/.crates.toml\n+            ~/.cargo/.crates2.json\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock', 'cargo-miri/src/version.rs') }}\n+          restore-keys: ${{ runner.os }}-cargo\n+\n+      - name: Install rustup-toolchain-install-master and xargo\n+        if: ${{ steps.cache.outputs.cache-hit == 'false' }}\n+        shell: bash\n+        run: |\n+          cargo install rustup-toolchain-install-master\n+          cargo install xargo\n+\n+      - name: Install \"master\" toolchain\n+        shell: bash\n+        run: |\n+          if [[ ${{ github.event_name }} == 'schedule' ]]; then\n+            ./rustup-toolchain HEAD --host ${{ matrix.host_target }}\n+          else\n+            ./rustup-toolchain \"\" --host ${{ matrix.host_target }}\n+          fi\n+\n+      - name: Show Rust version\n+        run: |\n+          rustup show\n+          rustc -Vv\n+          cargo -V\n+\n+      - name: Test\n+        run: bash ./ci.sh\n+\n+  style:\n+    name: style checks\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v3\n+      - name: Install required toolchain\n+        # We need a toolchain that can actually build Miri, just a nightly won't do.\n+        run: |\n+          cargo install rustup-toolchain-install-master # TODO: cache this?\n+          ./rustup-toolchain \"\" -c clippy\n+      - name: rustfmt\n+        run: ./miri fmt --check\n+      - name: clippy\n+        run: ./miri clippy -- -D warnings\n+      - name: rustdoc\n+        run: RUSTDOCFLAGS=\"-Dwarnings\" cargo doc --document-private-items\n+\n+  # These jobs doesn't actually test anything, but they're only used to tell\n+  # bors the build completed, as there is no practical way to detect when a\n+  # workflow is successful listening to webhooks only.\n+  #\n+  # ALL THE PREVIOUS JOBS NEED TO BE ADDED TO THE `needs` SECTION OF THIS JOB!\n+  # (`fmt` is deliberately not listed, we want bors to ignore it.)\n+  end-success:\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+    needs: [build, style]\n+    if: github.event.pusher.name == 'bors' && success()\n+    steps:\n+      - name: mark the job as a success\n+        run: exit 0\n+  end-failure:\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+    needs: [build, style]\n+    if: github.event.pusher.name == 'bors' && (failure() || cancelled())\n+    steps:\n+      - name: mark the job as a failure\n+        run: exit 1\n+\n+  # Send a Zulip notification when a cron job fails\n+  cron-fail-notify:\n+    name: cronjob failure notification\n+    runs-on: ubuntu-latest\n+    needs: [build, style]\n+    if: github.event_name == 'schedule' && (failure() || cancelled())\n+    steps:\n+      - name: Install zulip-send\n+        run: pip3 install zulip\n+      - name: Send Zulip notification\n+        shell: bash\n+        env:\n+          ZULIP_BOT_EMAIL: ${{ secrets.ZULIP_BOT_EMAIL }}\n+          ZULIP_API_TOKEN: ${{ secrets.ZULIP_API_TOKEN }}\n+        run: |\n+          ~/.local/bin/zulip-send --stream miri --subject \"Cron Job Failure (miri, $(date -u +%Y-%m))\" \\\n+            --message 'Dear @*T-miri*,\n+\n+          It would appear that the Miri cron job build failed. Would you mind investigating this issue?\n+\n+          Thanks in advance!\n+          Sincerely,\n+          The Miri Cronjobs Bot' \\\n+            --user $ZULIP_BOT_EMAIL --api-key $ZULIP_API_TOKEN --site https://rust-lang.zulipchat.com"}, {"sha": "924a93e807fe3cb4f738a209a9a714738e39cedf", "filename": "src/tools/miri/.gitignore", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.gitignore?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,13 @@\n+target\n+/doc\n+tex/*/out\n+*.dot\n+*.out\n+*.rs.bk\n+.vscode\n+*.mm_profdata\n+perf.data\n+perf.data.old\n+flamegraph.svg\n+tests/extern-so/libtestlib.so\n+.auto-*"}, {"sha": "36bd991740a827a649685e75dba0d3fb67dcfca2", "filename": "src/tools/miri/.gitpod.yml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.gitpod.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2F.gitpod.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.gitpod.yml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,9 @@\n+image: ubuntu:latest\n+\n+tasks:\n+  - before: echo \"...\"\n+    init: |\n+      cargo install rustup-toolchain-install-master\n+      ./rustup-toolchain\n+      ./miri build\n+    command: echo \"Run tests with ./miri test\"\n\\ No newline at end of file"}, {"sha": "8d965ae8fcb8da693c9337c04b847216b721db00", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,277 @@\n+# Contribution Guide\n+\n+If you want to hack on Miri yourself, great!  Here are some resources you might\n+find useful.\n+\n+## Getting started\n+\n+Check out the issues on this GitHub repository for some ideas. In particular,\n+look for the green `E-*` labels which mark issues that should be rather\n+well-suited for onboarding. For more ideas or help with hacking on Miri, you can\n+contact us (`oli-obk` and `RalfJ`) on the [Rust Zulip].\n+\n+[Rust Zulip]: https://rust-lang.zulipchat.com\n+\n+## Preparing the build environment\n+\n+Miri heavily relies on internal and unstable rustc interfaces to execute MIR,\n+which means it is important that you install a version of rustc that Miri\n+actually works with.\n+\n+The `rust-version` file contains the commit hash of rustc that Miri is currently\n+tested against. Other versions will likely not work. After installing\n+[`rustup-toolchain-install-master`], you can run the following command to\n+install that exact version of rustc as a toolchain:\n+```\n+./rustup-toolchain\n+```\n+This will set up a rustup toolchain called `miri` and set it as an override for\n+the current directory.\n+\n+You can also create a `.auto-everything` file (contents don't matter, can be empty), which\n+will cause any `./miri` command to automatically call `rustup-toolchain`, `clippy` and `rustfmt`\n+for you. If you don't want all of these to happen, you can add individual `.auto-toolchain`,\n+`.auto-clippy` and `.auto-fmt` files respectively.\n+\n+[`rustup-toolchain-install-master`]: https://github.com/kennytm/rustup-toolchain-install-master\n+\n+## Building and testing Miri\n+\n+Invoking Miri requires getting a bunch of flags right and setting up a custom\n+sysroot with xargo. The `miri` script takes care of that for you. With the\n+build environment prepared, compiling Miri is just one command away:\n+\n+```\n+./miri build\n+```\n+\n+Run `./miri` without arguments to see the other commands our build tool\n+supports.\n+\n+### Testing the Miri driver\n+\n+The Miri driver compiled from `src/bin/miri.rs` is the \"heart\" of Miri: it is\n+basically a version of `rustc` that, instead of compiling your code, runs it.\n+It accepts all the same flags as `rustc` (though the ones only affecting code\n+generation and linking obviously will have no effect) [and more][miri-flags].\n+\n+[miri-flags]: README.md#miri--z-flags-and-environment-variables\n+\n+For example, you can (cross-)run the driver on a particular file by doing\n+\n+```sh\n+./miri run tests/pass/format.rs\n+./miri run tests/pass/hello.rs --target i686-unknown-linux-gnu\n+```\n+\n+and you can (cross-)run the entire test suite using:\n+\n+```\n+./miri test\n+MIRI_TEST_TARGET=i686-unknown-linux-gnu ./miri test\n+```\n+\n+If your target doesn't support libstd, you can run miri with\n+\n+```\n+MIRI_NO_STD=1 MIRI_TEST_TARGET=thumbv7em-none-eabihf ./miri test tests/fail/alloc/no_global_allocator.rs\n+MIRI_NO_STD=1 ./miri run tests/pass/no_std.rs --target thumbv7em-none-eabihf\n+```\n+\n+to avoid attempting (and failing) to build libstd. Note that almost no tests will pass\n+this way, but you can run individual tests.\n+\n+`./miri test FILTER` only runs those tests that contain `FILTER` in their\n+filename (including the base directory, e.g. `./miri test fail` will run all\n+compile-fail tests).\n+\n+You can get a trace of which MIR statements are being executed by setting the\n+`MIRI_LOG` environment variable.  For example:\n+\n+```sh\n+MIRI_LOG=info ./miri run tests/pass/vec.rs\n+```\n+\n+Setting `MIRI_LOG` like this will configure logging for Miri itself as well as\n+the `rustc_middle::mir::interpret` and `rustc_mir::interpret` modules in rustc. You\n+can also do more targeted configuration, e.g. the following helps debug the\n+stacked borrows implementation:\n+\n+```sh\n+MIRI_LOG=rustc_mir::interpret=info,miri::stacked_borrows ./miri run tests/pass/vec.rs\n+```\n+\n+In addition, you can set `MIRI_BACKTRACE=1` to get a backtrace of where an\n+evaluation error was originally raised.\n+\n+#### UI testing\n+\n+We use ui-testing in Miri, meaning we generate `.stderr` and `.stdout` files for the output\n+produced by Miri. You can use `./miri bless` to automatically (re)generate these files when\n+you add new tests or change how Miri presents certain output.\n+\n+Note that when you also use `MIRIFLAGS` to change optimizations and similar, the ui output\n+will change in unexpected ways. In order to still be able\n+to run the other checks while ignoring the ui output, use `MIRI_SKIP_UI_CHECKS=1 ./miri test`.\n+\n+For more info on how to configure ui tests see [the documentation on the ui test crate][ui_test]\n+\n+[ui_test]: ui_test/README.md\n+\n+### Testing `cargo miri`\n+\n+Working with the driver directly gives you full control, but you also lose all\n+the convenience provided by cargo. Once your test case depends on a crate, it\n+is probably easier to test it with the cargo wrapper. You can install your\n+development version of Miri using\n+\n+```\n+./miri install\n+```\n+\n+and then you can use it as if it was installed by `rustup`.  Make sure you use\n+the same toolchain when calling `cargo miri` that you used when installing Miri!\n+Usually this means you have to write `cargo +miri miri ...` to select the `miri`\n+toolchain that was installed by `./rustup-toolchain`.\n+\n+There's a test for the cargo wrapper in the `test-cargo-miri` directory; run\n+`./run-test.py` in there to execute it. Like `./miri test`, this respects the\n+`MIRI_TEST_TARGET` environment variable to execute the test for another target.\n+\n+### Using a modified standard library\n+\n+Miri re-builds the standard library into a custom sysroot, so it is fairly easy\n+to test Miri against a modified standard library -- you do not even have to\n+build Miri yourself, the Miri shipped by `rustup` will work. All you have to do\n+is set the `MIRI_LIB_SRC` environment variable to the `library` folder of a\n+`rust-lang/rust` repository checkout. Note that changing files in that directory\n+does not automatically trigger a re-build of the standard library; you have to\n+clear the Miri build cache manually (on Linux, `rm -rf ~/.cache/miri`;\n+and on Windows, `rmdir /S \"%LOCALAPPDATA%\\rust-lang\\miri\\cache\"`).\n+\n+### Benchmarking\n+\n+Miri comes with a few benchmarks; you can run `./miri bench` to run them with the locally built\n+Miri. Note: this will run `./miri install` as a side-effect. Also requires `hyperfine` to be\n+installed (`cargo install hyperfine`).\n+\n+## Configuring `rust-analyzer`\n+\n+To configure `rust-analyzer` and VS Code for working on Miri, save the following\n+to `.vscode/settings.json` in your local Miri clone:\n+\n+```json\n+{\n+    \"rust-analyzer.rustc.source\": \"discover\",\n+    \"rust-analyzer.linkedProjects\": [\n+        \"./Cargo.toml\",\n+        \"./cargo-miri/Cargo.toml\"\n+    ],\n+    \"rust-analyzer.checkOnSave.overrideCommand\": [\n+        \"env\",\n+        \"MIRI_AUTO_OPS=no\",\n+        \"./miri\",\n+        \"cargo\",\n+        \"clippy\", // make this `check` when working with a locally built rustc\n+        \"--message-format=json\"\n+    ],\n+    // Contrary to what the name suggests, this also affects proc macros.\n+    \"rust-analyzer.cargo.buildScripts.overrideCommand\": [\n+        \"env\",\n+        \"MIRI_AUTO_OPS=no\",\n+        \"./miri\",\n+        \"cargo\",\n+        \"check\",\n+        \"--message-format=json\",\n+    ],\n+}\n+```\n+\n+> #### Note\n+>\n+> If you are [building Miri with a locally built rustc][], set\n+> `rust-analyzer.rustcSource` to the relative path from your Miri clone to the\n+> root `Cargo.toml` of the locally built rustc. For example, the path might look\n+> like `../rust/Cargo.toml`.\n+\n+See the rustc-dev-guide's docs on [\"Configuring `rust-analyzer` for `rustc`\"][rdg-r-a]\n+for more information about configuring VS Code and `rust-analyzer`.\n+\n+[rdg-r-a]: https://rustc-dev-guide.rust-lang.org/building/suggested.html#configuring-rust-analyzer-for-rustc\n+\n+## Advanced topic: other build environments\n+\n+We described above the simplest way to get a working build environment for Miri,\n+which is to use the version of rustc indicated by `rustc-version`. But\n+sometimes, that is not enough.\n+\n+### Updating `rustc-version`\n+\n+The `rustc-version` file is regularly updated to keep Miri close to the latest\n+version of rustc. Usually, new contributors do not have to worry about this. But\n+sometimes a newer rustc is needed for a patch, and sometimes Miri needs fixing\n+for changes in rustc. In both cases, `rustc-version` needs updating.\n+\n+To update the `rustc-version` file and install the latest rustc, you can run:\n+```\n+./rustup-toolchain HEAD\n+```\n+\n+Now edit Miri until `./miri test` passes, and submit a PR. Generally, it is\n+preferred to separate updating `rustc-version` and doing what it takes to get\n+Miri working again, from implementing new features that rely on the updated\n+rustc. This avoids blocking all Miri development on landing a big PR.\n+\n+### Building Miri with a locally built rustc\n+\n+[building Miri with a locally built rustc]: #building-miri-with-a-locally-built-rustc\n+\n+A big part of the Miri driver lives in rustc, so working on Miri will sometimes\n+require using a locally built rustc. The bug you want to fix may actually be on\n+the rustc side, or you just need to get more detailed trace of the execution\n+than what is possible with release builds -- in both cases, you should develop\n+Miri against a rustc you compiled yourself, with debug assertions (and hence\n+tracing) enabled.\n+\n+The setup for a local rustc works as follows:\n+```sh\n+# Clone the rust-lang/rust repo.\n+git clone https://github.com/rust-lang/rust rustc\n+cd rustc\n+# Create a config.toml with defaults for working on Miri.\n+./x.py setup compiler\n+ # Now edit `config.toml` and under `[rust]` set `debug-assertions = true`.\n+\n+# Build a stage 2 rustc, and build the rustc libraries with that rustc.\n+# This step can take 30 minutes or more.\n+./x.py build --stage 2 compiler/rustc\n+# If you change something, you can get a faster rebuild by doing\n+./x.py build --keep-stage 0 --stage 2 compiler/rustc\n+# You may have to change the architecture in the next command\n+rustup toolchain link stage2 build/x86_64-unknown-linux-gnu/stage2\n+# Now cd to your Miri directory, then configure rustup\n+rustup override set stage2\n+```\n+\n+Note: When you are working with a locally built rustc or any other toolchain that\n+is not the same as the one in `rust-version`, you should not have `.auto-everything` or\n+`.auto-toolchain` as that will keep resetting your toolchain.\n+\n+```\n+rm -f .auto-everything .auto-toolchain\n+```\n+\n+Important: You need to delete the Miri cache when you change the stdlib; otherwise the\n+old, chached version will be used. On Linux, the cache is located at `~/.cache/miri`,\n+and on Windows, it is located at `%LOCALAPPDATA%\\rust-lang\\miri\\cache`; the exact\n+location is printed after the library build: \"A libstd for Miri is now available in ...\".\n+\n+Note: `./x.py --stage 2 compiler/rustc` currently errors with `thread 'main'\n+panicked at 'fs::read(stamp) failed with No such file or directory (os error 2)`,\n+you can simply ignore that error; Miri will build anyway.\n+\n+For more information about building and configuring a local compiler,\n+see <https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html>.\n+\n+With this, you should now have a working development setup! See\n+[above](#building-and-testing-miri) for how to proceed working on Miri."}, {"sha": "9df35ec0deb2e3c2a02819bcbb679d76f79bb0a8", "filename": "src/tools/miri/Cargo.lock", "status": "added", "additions": 813, "deletions": 0, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,813 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"addr2line\"\n+version = \"0.17.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n+dependencies = [\n+ \"gimli\",\n+]\n+\n+[[package]]\n+name = \"adler\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n+\n+[[package]]\n+name = \"aho-corasick\"\n+version = \"0.7.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e37cfd5e7657ada45f742d6e99ca5788580b5c529dc78faf11ece6dc702656f\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"atty\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"autocfg\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n+\n+[[package]]\n+name = \"backtrace\"\n+version = \"0.3.65\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"11a17d453482a265fd5f8479f2a3f405566e6ca627837aaddb85af8b1ab8ef61\"\n+dependencies = [\n+ \"addr2line\",\n+ \"cc\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"miniz_oxide\",\n+ \"object\",\n+ \"rustc-demangle\",\n+]\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"1.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n+\n+[[package]]\n+name = \"camino\"\n+version = \"1.0.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"869119e97797867fd90f5e22af7d0bd274bd4635ebb9eb68c04f3f513ae6c412\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"cargo-platform\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cbdb825da8a5df079a43676dbe042702f1707b1109f713a01420fbb4cc71fa27\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.15.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3abb7553d5b9b8421c6de7cb02606ff15e0c6eea7d8eadd75ef013fd636bec36\"\n+dependencies = [\n+ \"camino\",\n+ \"cargo-platform\",\n+ \"semver\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.73\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+\n+[[package]]\n+name = \"color-eyre\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8ebf286c900a6d5867aeff75cfee3192857bb7f24b547d4f0df2ed6baa812c90\"\n+dependencies = [\n+ \"backtrace\",\n+ \"color-spantrace\",\n+ \"eyre\",\n+ \"indenter\",\n+ \"once_cell\",\n+ \"owo-colors\",\n+ \"tracing-error\",\n+]\n+\n+[[package]]\n+name = \"color-spantrace\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1ba75b3d9449ecdccb27ecbc479fdc0b87fa2dd43d2f8298f9bf0e59aacc8dce\"\n+dependencies = [\n+ \"once_cell\",\n+ \"owo-colors\",\n+ \"tracing-core\",\n+ \"tracing-error\",\n+]\n+\n+[[package]]\n+name = \"colored\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b3616f750b84d8f0de8a58bda93e08e2a81ad3f523089b05f1dffecab48c6cbd\"\n+dependencies = [\n+ \"atty\",\n+ \"lazy_static\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"crossbeam\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ae5588f6b3c3cb05239e90bd110f257254aecd01e4635400391aeae07497845\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-channel\",\n+ \"crossbeam-deque\",\n+ \"crossbeam-epoch\",\n+ \"crossbeam-queue\",\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-channel\"\n+version = \"0.5.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5aaa7bd5fb665c6864b5f963dd9097905c54125909c7aa94c9e18507cdbe6c53\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-deque\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6455c0ca19f0d2fbf751b908d5c55c1f5cbc65e03c4225427254b46890bdde1e\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-epoch\",\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-epoch\"\n+version = \"0.9.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1145cf131a2c6ba0615079ab6a638f7e1973ac9c2634fcbeaaad6114246efe8c\"\n+dependencies = [\n+ \"autocfg\",\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+ \"lazy_static\",\n+ \"memoffset\",\n+ \"scopeguard\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-queue\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1f25d8400f4a7a5778f0e4e52384a48cbd9b5c495d110786187fc750075277a2\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0bf124c720b7686e3c2663cf54062ab0f68a88af2fb6a030e87e30bf721fcb38\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"diff\"\n+version = \"0.1.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8\"\n+\n+[[package]]\n+name = \"env_logger\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0b2cf0344971ee6c64c31be0d530793fba457d322dfec2810c453d0ef228f9c3\"\n+dependencies = [\n+ \"atty\",\n+ \"humantime\",\n+ \"log\",\n+ \"regex\",\n+ \"termcolor\",\n+]\n+\n+[[package]]\n+name = \"eyre\"\n+version = \"0.6.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4c2b6b5a29c02cdc822728b7d7b8ae1bab3e3b05d44522770ddd49722eeac7eb\"\n+dependencies = [\n+ \"indenter\",\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n+[[package]]\n+name = \"gimli\"\n+version = \"0.26.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.1.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"humantime\"\n+version = \"2.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n+\n+[[package]]\n+name = \"indenter\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce23b50ad8242c51a442f3ff322d56b02f08852c77e4c0b4d3fd684abc89c683\"\n+\n+[[package]]\n+name = \"instant\"\n+version = \"0.1.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+\n+[[package]]\n+name = \"lazy_static\"\n+version = \"1.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.112\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n+\n+[[package]]\n+name = \"libffi\"\n+version = \"3.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e454b3efb16fba3b17810ae5e41df02b649e564ab3c5a34b3b93ed07ad287e6\"\n+dependencies = [\n+ \"libc\",\n+ \"libffi-sys\",\n+]\n+\n+[[package]]\n+name = \"libffi-sys\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ab4106b7f09d7b87d021334d5618fac1dfcfb824d4c5fe111ff0074dfd242e15\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n+[[package]]\n+name = \"libloading\"\n+version = \"0.7.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"lock_api\"\n+version = \"0.4.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712a4d093c9976e24e7dbca41db895dabcbac38eb5f4045393d17a95bdfb1109\"\n+dependencies = [\n+ \"scopeguard\",\n+]\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.4.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"measureme\"\n+version = \"10.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cbdc226fa10994e8f66a4d2f6f000148bc563a1c671b6dcd2135737018033d8a\"\n+dependencies = [\n+ \"log\",\n+ \"memmap2\",\n+ \"parking_lot\",\n+ \"perf-event-open-sys\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+]\n+\n+[[package]]\n+name = \"memchr\"\n+version = \"2.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n+\n+[[package]]\n+name = \"memmap2\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"723e3ebdcdc5c023db1df315364573789f8857c11b631a2fdfad7c00f5c046b4\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"memoffset\"\n+version = \"0.6.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n+dependencies = [\n+ \"autocfg\",\n+]\n+\n+[[package]]\n+name = \"miniz_oxide\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n+dependencies = [\n+ \"adler\",\n+]\n+\n+[[package]]\n+name = \"miri\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"colored\",\n+ \"env_logger\",\n+ \"getrandom\",\n+ \"lazy_static\",\n+ \"libc\",\n+ \"libffi\",\n+ \"libloading\",\n+ \"log\",\n+ \"measureme\",\n+ \"rand\",\n+ \"regex\",\n+ \"rustc-workspace-hack\",\n+ \"shell-escape\",\n+ \"smallvec\",\n+ \"ui_test\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.28.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"once_cell\"\n+version = \"1.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n+\n+[[package]]\n+name = \"owo-colors\"\n+version = \"3.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"decf7381921fea4dcb2549c5667eda59b3ec297ab7e2b5fc33eac69d2e7da87b\"\n+\n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.11.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99\"\n+dependencies = [\n+ \"instant\",\n+ \"lock_api\",\n+ \"parking_lot_core\",\n+]\n+\n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.8.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d76e8e1493bcac0d2766c42737f34458f1c8c50c0d23bcb24ea953affb273216\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"instant\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"perf-event-open-sys\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce9bedf5da2c234fdf2391ede2b90fabf585355f33100689bc364a3ea558561a\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"pin-project-lite\"\n+version = \"0.2.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116\"\n+\n+[[package]]\n+name = \"ppv-lite86\"\n+version = \"0.2.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ed0cfbc8191465bed66e1718596ee0b0b35d5ee1f41c5df2189d0fe8bde535ba\"\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.39\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c54b25569025b7fc9651de43004ae593a75ad88543b17178aa5e1b9c4f15f56f\"\n+dependencies = [\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a1feb54ed693b93a84e14094943b84b7c4eae204c512b7ccb95ab0c66d278ad1\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n+[[package]]\n+name = \"rand\"\n+version = \"0.8.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n+dependencies = [\n+ \"libc\",\n+ \"rand_chacha\",\n+ \"rand_core\",\n+ \"rand_hc\",\n+]\n+\n+[[package]]\n+name = \"rand_chacha\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\n+dependencies = [\n+ \"ppv-lite86\",\n+ \"rand_core\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.6.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d34f1408f55294453790c48b2f1ebbb1c5b4b7563eb1f418bcfcfdbb06ebb4e7\"\n+dependencies = [\n+ \"getrandom\",\n+]\n+\n+[[package]]\n+name = \"rand_hc\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d51e9f596de227fda2ea6c84607f5558e196eeaf43c986b724ba4fb8fdf497e7\"\n+dependencies = [\n+ \"rand_core\",\n+]\n+\n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.2.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8383f39639269cde97d255a32bdb68c047337295414940c68bdd30c2e13203ff\"\n+dependencies = [\n+ \"bitflags\",\n+]\n+\n+[[package]]\n+name = \"regex\"\n+version = \"1.5.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1a11647b6b25ff05a515cb92c365cec08801e83423a235b51e231e1808747286\"\n+dependencies = [\n+ \"aho-corasick\",\n+ \"memchr\",\n+ \"regex-syntax\",\n+]\n+\n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.6.25\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f497285884f3fcff424ffc933e56d7cbca511def0c9831a7f9b5f6153e3cc89b\"\n+\n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342\"\n+\n+[[package]]\n+name = \"rustc-hash\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n+\n+[[package]]\n+name = \"rustc-workspace-hack\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fc71d2faa173b74b232dedc235e3ee1696581bb132fc116fa3626d6151a1a8fb\"\n+\n+[[package]]\n+name = \"rustc_version\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366\"\n+dependencies = [\n+ \"semver\",\n+]\n+\n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f3f6f92acf49d1b98f7a81226834412ada05458b7364277387724a237f062695\"\n+\n+[[package]]\n+name = \"scopeguard\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n+\n+[[package]]\n+name = \"semver\"\n+version = \"1.0.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8cb243bdfdb5936c8dc3c45762a19d12ab4550cdc753bc247637d4ec35a040fd\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61ea8d54c77f8315140a05f4c7237403bf38b72704d031543aa1d16abbf517d1\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.81\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9b7ce2b32a1aed03c558dc61a5cd328f15aff2dbc17daad8fb8af04d2100e15c\"\n+dependencies = [\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"sharded-slab\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"900fba806f70c630b0a382d0d825e17a0f19fcd059a2ade1ff237bcddf446b31\"\n+dependencies = [\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"shell-escape\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"45bb67a18fa91266cc7807181f62f9178a6873bfad7dc788c42e6430db40184f\"\n+\n+[[package]]\n+name = \"smallvec\"\n+version = \"1.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1ecab6c735a6bb4139c0caafd0cc3635748bbb3acf4550e8138122099251f309\"\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.95\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fbaf6116ab8924f39d52792136fb74fd60a80194cf1b1c6ffa6453eef1c3f942\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"termcolor\"\n+version = \"1.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2dfed899f0eb03f32ee8c6a0aabdb8a7949659e3466561fc0adf54e26d88c5f4\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"thread_local\"\n+version = \"1.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5516c27b78311c50bf42c071425c560ac799b11c30b31f87e3081965fe5e0180\"\n+dependencies = [\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"tracing\"\n+version = \"0.1.35\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a400e31aa60b9d44a52a8ee0343b5b18566b03a8321e0d321f695cf56e940160\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"pin-project-lite\",\n+ \"tracing-core\",\n+]\n+\n+[[package]]\n+name = \"tracing-core\"\n+version = \"0.1.28\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7b7358be39f2f274f322d2aaed611acc57f382e8eb1e5b48cb9ae30933495ce7\"\n+dependencies = [\n+ \"once_cell\",\n+ \"valuable\",\n+]\n+\n+[[package]]\n+name = \"tracing-error\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d686ec1c0f384b1277f097b2f279a2ecc11afe8c133c1aabf036a27cb4cd206e\"\n+dependencies = [\n+ \"tracing\",\n+ \"tracing-subscriber\",\n+]\n+\n+[[package]]\n+name = \"tracing-subscriber\"\n+version = \"0.3.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3a713421342a5a666b7577783721d3117f1b69a393df803ee17bb73b1e122a59\"\n+dependencies = [\n+ \"sharded-slab\",\n+ \"thread_local\",\n+ \"tracing-core\",\n+]\n+\n+[[package]]\n+name = \"ui_test\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7d1f546a5883ae78da735bba529ec1116661e2f73582f23920d994dc97da3a22\"\n+dependencies = [\n+ \"cargo_metadata\",\n+ \"color-eyre\",\n+ \"colored\",\n+ \"crossbeam\",\n+ \"diff\",\n+ \"lazy_static\",\n+ \"regex\",\n+ \"rustc_version\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"unicode-ident\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d22af068fba1eb5edcb4aea19d382b2a3deb4c8f9d475c589b6ada9e0fd493ee\"\n+\n+[[package]]\n+name = \"valuable\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d\"\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.10.2+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-util\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\""}, {"sha": "0c547d585d198eec1c01f787f290dfd29a307114", "filename": "src/tools/miri/Cargo.toml", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,61 @@\n+[package]\n+authors = [\"Miri Team\"]\n+description = \"An experimental interpreter for Rust MIR (core driver).\"\n+license = \"MIT OR Apache-2.0\"\n+name = \"miri\"\n+repository = \"https://github.com/rust-lang/miri\"\n+version = \"0.1.0\"\n+default-run = \"miri\"\n+edition = \"2021\"\n+\n+[lib]\n+test = true # we have unit tests\n+doctest = false # but no doc tests\n+\n+[[bin]]\n+name = \"miri\"\n+test = false # we have no unit tests\n+doctest = false # and no doc tests\n+\n+[dependencies]\n+getrandom = { version = \"0.2\", features = [\"std\"] }\n+env_logger = \"0.9\"\n+log = \"0.4\"\n+shell-escape = \"0.1.4\"\n+rand = \"0.8\"\n+smallvec = \"1.7\"\n+\n+# A noop dependency that changes in the Rust repository, it's a bit of a hack.\n+# See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n+# for more information.\n+rustc-workspace-hack = \"1.0.0\"\n+measureme = \"10.0.0\"\n+\n+[target.\"cfg(unix)\".dependencies]\n+libc = \"0.2\"\n+libffi = \"3.0.0\"\n+libloading = \"0.7\"\n+\n+[dev-dependencies]\n+colored = \"2\"\n+ui_test = \"0.3.1\"\n+# Features chosen to match those required by env_logger, to avoid rebuilds\n+regex = { version = \"1.5.5\", default-features = false, features = [\"perf\", \"std\"] }\n+lazy_static = \"1.4.0\"\n+\n+[package.metadata.rust-analyzer]\n+# This crate uses #[feature(rustc_private)].\n+# See https://github.com/rust-analyzer/rust-analyzer/pull/7891\n+rustc_private = true\n+\n+[[test]]\n+name = \"compiletest\"\n+harness = false\n+\n+[features]\n+default = [\"stack-cache\"]\n+stack-cache = []\n+\n+# Be aware that this file is inside a workspace when used via the\n+# submodule in the rustc repo. That means there are many cargo features\n+# we cannot use, such as profiles."}, {"sha": "1b5ec8b78e237b5c3b3d812a7c0a6589d0f7161d", "filename": "src/tools/miri/LICENSE-APACHE", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FLICENSE-APACHE?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,176 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS"}, {"sha": "31aa79387f27e730e33d871925e152e35e428031", "filename": "src/tools/miri/LICENSE-MIT", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FLICENSE-MIT?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,23 @@\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "1f4c52d5b85075dc6b7c780c8089129c0275833b", "filename": "src/tools/miri/README.md", "status": "added", "additions": 639, "deletions": 0, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,639 @@\n+# Miri\n+\n+[![Actions build status][actions-badge]][actions-url]\n+\n+[actions-badge]: https://github.com/rust-lang/miri/workflows/CI/badge.svg?branch=master\n+[actions-url]: https://github.com/rust-lang/miri/actions\n+\n+An experimental interpreter for [Rust][rust]'s\n+[mid-level intermediate representation][mir] (MIR). It can run binaries and\n+test suites of cargo projects and detect certain classes of\n+[undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html),\n+for example:\n+\n+* Out-of-bounds memory accesses and use-after-free\n+* Invalid use of uninitialized data\n+* Violation of intrinsic preconditions (an [`unreachable_unchecked`] being\n+  reached, calling [`copy_nonoverlapping`] with overlapping ranges, ...)\n+* Not sufficiently aligned memory accesses and references\n+* Violation of *some* basic type invariants (a `bool` that is not 0 or 1, for example,\n+  or an invalid enum discriminant)\n+* **Experimental**: Violations of the [Stacked Borrows] rules governing aliasing\n+  for reference types\n+* **Experimental**: Data races\n+\n+On top of that, Miri will also tell you about memory leaks: when there is memory\n+still allocated at the end of the execution, and that memory is not reachable\n+from a global `static`, Miri will raise an error.\n+\n+Miri supports almost all Rust language features; in particular, unwinding and\n+concurrency are properly supported (including some experimental emulation of\n+weak memory effects, i.e., reads can return outdated values).\n+\n+You can use Miri to emulate programs on other targets, e.g. to ensure that\n+byte-level data manipulation works correctly both on little-endian and\n+big-endian systems. See\n+[cross-interpretation](#cross-interpretation-running-for-different-targets)\n+below.\n+\n+Miri has already discovered some [real-world bugs](#bugs-found-by-miri). If you\n+found a bug with Miri, we'd appreciate if you tell us and we'll add it to the\n+list!\n+\n+By default, Miri ensures a fully deterministic execution and isolates the\n+program from the host system. Some APIs that would usually access the host, such\n+as gathering entropy for random number generators, environment variables, and\n+clocks, are replaced by deterministic \"fake\" implementations. Set\n+`MIRIFLAGS=\"-Zmiri-disable-isolation\"` to access the real system APIs instead.\n+(In particular, the \"fake\" system RNG APIs make Miri **not suited for\n+cryptographic use**! Do not generate keys using Miri.)\n+\n+All that said, be aware that Miri will **not catch all cases of undefined\n+behavior** in your program, and cannot run all programs:\n+\n+* There are still plenty of open questions around the basic invariants for some\n+  types and when these invariants even have to hold. Miri tries to avoid false\n+  positives here, so if your program runs fine in Miri right now that is by no\n+  means a guarantee that it is UB-free when these questions get answered.\n+\n+    In particular, Miri does currently not check that references point to valid data.\n+* If the program relies on unspecified details of how data is laid out, it will\n+  still run fine in Miri -- but might break (including causing UB) on different\n+  compiler versions or different platforms.\n+* Program execution is non-deterministic when it depends, for example, on where\n+  exactly in memory allocations end up, or on the exact interleaving of\n+  concurrent threads. Miri tests one of many possible executions of your\n+  program. You can alleviate this to some extent by running Miri with different\n+  values for `-Zmiri-seed`, but that will still by far not explore all possible\n+  executions.\n+* Miri runs the program as a platform-independent interpreter, so the program\n+  has no access to most platform-specific APIs or FFI. A few APIs have been\n+  implemented (such as printing to stdout, accessing environment variables, and\n+  basic file system access) but most have not: for example, Miri currently does\n+  not support networking. System API support varies between targets; if you run\n+  on Windows it is a good idea to use `--target x86_64-unknown-linux-gnu` to get\n+  better support.\n+* Weak memory emulation may [produce weak behaviours](https://github.com/rust-lang/miri/issues/2301)\n+  unobservable by compiled programs running on real hardware when `SeqCst` fences are used, and it\n+  cannot produce all behaviors possibly observable on real hardware.\n+\n+[rust]: https://www.rust-lang.org/\n+[mir]: https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md\n+[`unreachable_unchecked`]: https://doc.rust-lang.org/stable/std/hint/fn.unreachable_unchecked.html\n+[`copy_nonoverlapping`]: https://doc.rust-lang.org/stable/std/ptr/fn.copy_nonoverlapping.html\n+[Stacked Borrows]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\n+\n+\n+## Using Miri\n+\n+Install Miri on Rust nightly via `rustup`:\n+\n+```sh\n+rustup +nightly component add miri\n+```\n+\n+If `rustup` says the `miri` component is unavailable, that's because not all\n+nightly releases come with all tools. Check out\n+[this website](https://rust-lang.github.io/rustup-components-history) to\n+determine a nightly version that comes with Miri and install that using `rustup\n+toolchain install nightly-YYYY-MM-DD`. Either way, all of the following commands\n+assume the right toolchain is pinned via `rustup override set nightly` or\n+`rustup override set nightly-YYYY-MM-DD`. (Alternatively, use `cargo\n++nightly`/`cargo +nightly-YYYY-MM-DD` for each of the following commands.)\n+\n+Now you can run your project in Miri:\n+\n+1. Run `cargo clean` to eliminate any cached dependencies. Miri needs your\n+   dependencies to be compiled the right way, that would not happen if they have\n+   previously already been compiled.\n+2. To run all tests in your project through Miri, use `cargo miri test`.\n+3. If you have a binary project, you can run it through Miri using `cargo miri run`.\n+\n+The first time you run Miri, it will perform some extra setup and install some\n+dependencies. It will ask you for confirmation before installing anything.\n+\n+`cargo miri run/test` supports the exact same flags as `cargo run/test`. For\n+example, `cargo miri test filter` only runs the tests containing `filter` in\n+their name.\n+\n+You can pass arguments to Miri via `MIRIFLAGS`. For example,\n+`MIRIFLAGS=\"-Zmiri-disable-stacked-borrows\" cargo miri run` runs the program\n+without checking the aliasing of references.\n+\n+When compiling code via `cargo miri`, the `cfg(miri)` config flag is set for code\n+that will be interpret under Miri. You can use this to ignore test cases that fail\n+under Miri because they do things Miri does not support:\n+\n+```rust\n+#[test]\n+#[cfg_attr(miri, ignore)]\n+fn does_not_work_on_miri() {\n+    tokio::run(futures::future::ok::<_, ()>(()));\n+}\n+```\n+\n+There is no way to list all the infinite things Miri cannot do, but the\n+interpreter will explicitly tell you when it finds something unsupported:\n+\n+```\n+error: unsupported operation: can't call foreign function: bind\n+    ...\n+    = help: this is likely not a bug in the program; it indicates that the program \\\n+            performed an operation that the interpreter does not support\n+```\n+\n+### Cross-interpretation: running for different targets\n+\n+Miri can not only run a binary or test suite for your host target, it can also\n+perform cross-interpretation for arbitrary foreign targets: `cargo miri run\n+--target x86_64-unknown-linux-gnu` will run your program as if it was a Linux\n+program, no matter your host OS. This is particularly useful if you are using\n+Windows, as the Linux target is much better supported than Windows targets.\n+\n+You can also use this to test platforms with different properties than your host\n+platform. For example `cargo miri test --target mips64-unknown-linux-gnuabi64`\n+will run your test suite on a big-endian target, which is useful for testing\n+endian-sensitive code.\n+\n+### Running Miri on CI\n+\n+To run Miri on CI, make sure that you handle the case where the latest nightly\n+does not ship the Miri component because it currently does not build. `rustup\n+toolchain install --component` knows how to handle this situation, so the\n+following snippet should always work:\n+\n+```sh\n+rustup toolchain install nightly --component miri\n+rustup override set nightly\n+\n+cargo miri test\n+```\n+\n+Here is an example job for GitHub Actions:\n+\n+```yaml\n+  miri:\n+    name: \"Miri\"\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v3\n+      - name: Install Miri\n+        run: |\n+          rustup toolchain install nightly --component miri\n+          rustup override set nightly\n+          cargo miri setup\n+      - name: Test with Miri\n+        run: cargo miri test\n+```\n+\n+The explicit `cargo miri setup` helps to keep the output of the actual test step\n+clean.\n+\n+### Testing for alignment issues\n+\n+Miri can sometimes miss misaligned accesses since allocations can \"happen to be\"\n+aligned just right. You can use `-Zmiri-symbolic-alignment-check` to definitely\n+catch all such issues, but that flag will also cause false positives when code\n+does manual pointer arithmetic to account for alignment. Another alternative is\n+to call Miri with various values for `-Zmiri-seed`; that will alter the\n+randomness that is used to determine allocation base addresses. The following\n+snippet calls Miri in a loop with different values for the seed:\n+\n+```\n+for SEED in $({ echo obase=16; seq 0 255; } | bc); do\n+  echo \"Trying seed: $SEED\"\n+  MIRIFLAGS=-Zmiri-seed=$SEED cargo miri test || { echo \"Failing seed: $SEED\"; break; };\n+done\n+```\n+\n+### Supported targets\n+\n+Miri does not support all targets supported by Rust. The good news, however, is\n+that no matter your host OS/platform, it is easy to run code for *any* target\n+using `--target`!\n+\n+The following targets are tested on CI and thus should always work (to the\n+degree documented below):\n+\n+- The best-supported target is `x86_64-unknown-linux-gnu`. Miri releases are\n+  blocked on things working with this target. Most other Linux targets should\n+  also work well; we do run the test suite on `i686-unknown-linux-gnu` as a\n+  32bit target and `mips64-unknown-linux-gnuabi64` as a big-endian target.\n+- `x86_64-apple-darwin` should work basically as well as Linux. We also test\n+  `aarch64-apple-darwin`. However, we might ship Miri with a nightly even when\n+  some features on these targets regress.\n+- `x86_64-pc-windows-msvc` works, but supports fewer features than the Linux and\n+  Apple targets. For example, file system access and concurrency are not\n+  supported on Windows. We also test `i686-pc-windows-msvc`, with the same\n+  reduced feature set. We might ship Miri with a nightly even when some features\n+  on these targets regress.\n+\n+### Common Problems\n+\n+When using the above instructions, you may encounter a number of confusing compiler\n+errors.\n+\n+#### \"note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\"\n+\n+You may see this when trying to get Miri to display a backtrace. By default, Miri\n+doesn't expose any environment to the program, so running\n+`RUST_BACKTRACE=1 cargo miri test` will not do what you expect.\n+\n+To get a backtrace, you need to disable isolation\n+[using `-Zmiri-disable-isolation`][miri-flags]:\n+\n+```sh\n+RUST_BACKTRACE=1 MIRIFLAGS=\"-Zmiri-disable-isolation\" cargo miri test\n+```\n+\n+#### \"found possibly newer version of crate `std` which `<dependency>` depends on\"\n+\n+Your build directory may contain artifacts from an earlier build that have/have\n+not been built for Miri. Run `cargo clean` before switching from non-Miri to\n+Miri builds and vice-versa.\n+\n+#### \"found crate `std` compiled by an incompatible version of rustc\"\n+\n+You may be running `cargo miri` with a different compiler version than the one\n+used to build the custom libstd that Miri uses, and Miri failed to detect that.\n+Try deleting `~/.cache/miri`.\n+\n+#### \"no mir for `std::rt::lang_start_internal`\"\n+\n+This means the sysroot you are using was not compiled with Miri in mind.  This\n+should never happen when you use `cargo miri` because that takes care of setting\n+up the sysroot.  If you are using `miri` (the Miri driver) directly, see the\n+[contributors' guide](CONTRIBUTING.md) for how to use `./miri` to best do that.\n+\n+\n+## Miri `-Z` flags and environment variables\n+[miri-flags]: #miri--z-flags-and-environment-variables\n+\n+Miri adds its own set of `-Z` flags, which are usually set via the `MIRIFLAGS`\n+environment variable. We first document the most relevant and most commonly used flags:\n+\n+* `-Zmiri-compare-exchange-weak-failure-rate=<rate>` changes the failure rate of\n+  `compare_exchange_weak` operations. The default is `0.8` (so 4 out of 5 weak ops will fail).\n+  You can change it to any value between `0.0` and `1.0`, where `1.0` means it\n+  will always fail and `0.0` means it will never fail. Note than setting it to\n+  `1.0` will likely cause hangs, since it means programs using\n+  `compare_exchange_weak` cannot make progress.\n+* `-Zmiri-disable-isolation` disables host isolation.  As a consequence,\n+  the program has access to host resources such as environment variables, file\n+  systems, and randomness.\n+* `-Zmiri-isolation-error=<action>` configures Miri's response to operations\n+  requiring host access while isolation is enabled. `abort`, `hide`, `warn`,\n+  and `warn-nobacktrace` are the supported actions. The default is to `abort`,\n+  which halts the machine. Some (but not all) operations also support continuing\n+  execution with a \"permission denied\" error being returned to the program.\n+  `warn` prints a full backtrace when that happens; `warn-nobacktrace` is less\n+  verbose. `hide` hides the warning entirely.\n+* `-Zmiri-env-forward=<var>` forwards the `var` environment variable to the interpreted program. Can\n+  be used multiple times to forward several variables. Execution will still be deterministic if the\n+  value of forwarded variables stays the same. Has no effect if `-Zmiri-disable-isolation` is set.\n+* `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n+  remaining threads to exist when the main thread exits.\n+* `-Zmiri-permissive-provenance` disables the warning for integer-to-pointer casts and\n+  [`ptr::from_exposed_addr`](https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html).\n+  This will necessarily miss some bugs as those operations are not efficiently and accurately\n+  implementable in a sanitizer, but it will only miss bugs that concern memory/pointers which is\n+  subject to these operations.\n+* `-Zmiri-preemption-rate` configures the probability that at the end of a basic block, the active\n+  thread will be preempted. The default is `0.01` (i.e., 1%). Setting this to `0` disables\n+  preemption.\n+* `-Zmiri-report-progress` makes Miri print the current stacktrace every now and then, so you can\n+  tell what it is doing when a program just keeps running. You can customize how frequently the\n+  report is printed via `-Zmiri-report-progress=<blocks>`, which prints the report every N basic\n+  blocks.\n+* `-Zmiri-seed=<hex>` configures the seed of the RNG that Miri uses to resolve non-determinism. This\n+  RNG is used to pick base addresses for allocations, to determine preemption and failure of\n+  `compare_exchange_weak`, and to control store buffering for weak memory emulation. When isolation\n+  is enabled (the default), this is also used to emulate system entropy. The default seed is 0. You\n+  can increase test coverage by running Miri multiple times with different seeds.\n+* `-Zmiri-strict-provenance` enables [strict\n+  provenance](https://github.com/rust-lang/rust/issues/95228) checking in Miri. This means that\n+  casting an integer to a pointer yields a result with 'invalid' provenance, i.e., with provenance\n+  that cannot be used for any memory access.\n+* `-Zmiri-symbolic-alignment-check` makes the alignment check more strict.  By default, alignment is\n+  checked by casting the pointer to an integer, and making sure that is a multiple of the alignment.\n+  This can lead to cases where a program passes the alignment check by pure chance, because things\n+  \"happened to be\" sufficiently aligned -- there is no UB in this execution but there would be UB in\n+  others.  To avoid such cases, the symbolic alignment check only takes into account the requested\n+  alignment of the relevant allocation, and the offset into that allocation.  This avoids missing\n+  such bugs, but it also incurs some false positives when the code does manual integer arithmetic to\n+  ensure alignment.  (The standard library `align_to` method works fine in both modes; under\n+  symbolic alignment it only fills the middle slice when the allocation guarantees sufficient\n+  alignment.)\n+* `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n+  is to search for and remove unreachable tags once every `10,000` basic blocks. Setting this to\n+  `0` disables the garbage collector, which causes some programs to have explosive memory usage\n+  and/or super-linear runtime.\n+\n+The remaining flags are for advanced use only, and more likely to change or be removed.\n+Some of these are **unsound**, which means they can lead\n+to Miri failing to detect cases of undefined behavior in a program.\n+\n+* `-Zmiri-disable-abi-check` disables checking [function ABI]. Using this flag\n+  is **unsound**.\n+* `-Zmiri-disable-alignment-check` disables checking pointer alignment, so you\n+  can focus on other failures, but it means Miri can miss bugs in your program.\n+  Using this flag is **unsound**.\n+* `-Zmiri-disable-data-race-detector` disables checking for data races.  Using\n+  this flag is **unsound**. This implies `-Zmiri-disable-weak-memory-emulation`.\n+* `-Zmiri-disable-stacked-borrows` disables checking the experimental\n+  [Stacked Borrows] aliasing rules.  This can make Miri run faster, but it also\n+  means no aliasing violations will be detected.  Using this flag is **unsound**\n+  (but the affected soundness rules are experimental).\n+* `-Zmiri-disable-validation` disables enforcing validity invariants, which are\n+  enforced by default.  This is mostly useful to focus on other failures (such\n+  as out-of-bounds accesses) first.  Setting this flag means Miri can miss bugs\n+  in your program.  However, this can also help to make Miri run faster.  Using\n+  this flag is **unsound**.\n+* `-Zmiri-disable-weak-memory-emulation` disables the emulation of some C++11 weak\n+  memory effects.\n+* `-Zmiri-extern-so-file=<path to a shared object file>` is an experimental flag for providing support\n+  for FFI calls. Functions not provided by that file are still executed via the usual Miri shims.\n+  **WARNING**: If an invalid/incorrect `.so` file is specified, this can cause undefined behaviour in Miri itself!\n+  And of course, Miri cannot do any checks on the actions taken by the external code.\n+  Note that Miri has its own handling of file descriptors, so if you want to replace *some* functions\n+  working on file descriptors, you will have to replace *all* of them, or the two kinds of\n+  file descriptors will be mixed up.\n+  This is **work in progress**; currently, only integer arguments and return values are\n+  supported (and no, pointer/integer casts to work around this limitation will not work;\n+  they will fail horribly). It also only works on unix hosts for now.\n+  Follow [the discussion on supporting other types](https://github.com/rust-lang/miri/issues/2365). \n+* `-Zmiri-measureme=<name>` enables `measureme` profiling for the interpreted program.\n+   This can be used to find which parts of your program are executing slowly under Miri.\n+   The profile is written out to a file with the prefix `<name>`, and can be processed\n+   using the tools in the repository https://github.com/rust-lang/measureme.\n+* `-Zmiri-mute-stdout-stderr` silently ignores all writes to stdout and stderr,\n+  but reports to the program that it did actually write. This is useful when you\n+  are not interested in the actual program's output, but only want to see Miri's\n+  errors and warnings.\n+* `-Zmiri-panic-on-unsupported` will makes some forms of unsupported functionality,\n+  such as FFI and unsupported syscalls, panic within the context of the emulated\n+  application instead of raising an error within the context of Miri (and halting\n+  execution). Note that code might not expect these operations to ever panic, so\n+  this flag can lead to strange (mis)behavior.\n+* `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into fields.\n+  This means that references in fields of structs/enums/tuples/arrays/... are retagged,\n+  and in particular, they are protected when passed as function arguments.\n+* `-Zmiri-track-alloc-id=<id1>,<id2>,...` shows a backtrace when the given allocations are\n+  being allocated or freed.  This helps in debugging memory leaks and\n+  use after free bugs. Specifying this argument multiple times does not overwrite the previous\n+  values, instead it appends its values to the list. Listing an id multiple times has no effect.\n+* `-Zmiri-track-call-id=<id1>,<id2>,...` shows a backtrace when the given call ids are\n+  assigned to a stack frame.  This helps in debugging UB related to Stacked\n+  Borrows \"protectors\". Specifying this argument multiple times does not overwrite the previous\n+  values, instead it appends its values to the list. Listing an id multiple times has no effect.\n+* `-Zmiri-track-pointer-tag=<tag1>,<tag2>,...` shows a backtrace when a given pointer tag\n+  is created and when (if ever) it is popped from a borrow stack (which is where the tag becomes invalid \n+  and any future use of it will error).  This helps you in finding out why UB is\n+  happening and where in your code would be a good place to look for it.\n+  Specifying this argument multiple times does not overwrite the previous\n+  values, instead it appends its values to the list. Listing a tag multiple times has no effect.\n+* `-Zmiri-track-weak-memory-loads` shows a backtrace when weak memory emulation returns an outdated\n+  value from a load. This can help diagnose problems that disappear under\n+  `-Zmiri-disable-weak-memory-emulation`.\n+\n+[function ABI]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n+\n+Some native rustc `-Z` flags are also very relevant for Miri:\n+\n+* `-Zmir-opt-level` controls how many MIR optimizations are performed.  Miri\n+  overrides the default to be `0`; be advised that using any higher level can\n+  make Miri miss bugs in your program because they got optimized away.\n+* `-Zalways-encode-mir` makes rustc dump MIR even for completely monomorphic\n+  functions.  This is needed so that Miri can execute such functions, so Miri\n+  sets this flag per default.\n+* `-Zmir-emit-retag` controls whether `Retag` statements are emitted. Miri\n+  enables this per default because it is needed for [Stacked Borrows].\n+\n+Moreover, Miri recognizes some environment variables:\n+\n+* `MIRI_AUTO_OPS` indicates whether the automatic execution of rustfmt, clippy and rustup-toolchain\n+  should be skipped. If it is set to any value, they are skipped. This is used for avoiding\n+  infinite recursion in `./miri` and to allow automated IDE actions to avoid the auto ops.\n+* `MIRI_LOG`, `MIRI_BACKTRACE` control logging and backtrace printing during\n+  Miri executions, also [see \"Testing the Miri driver\" in `CONTRIBUTING.md`][testing-miri].\n+* `MIRIFLAGS` (recognized by `cargo miri` and the test suite) defines extra\n+  flags to be passed to Miri.\n+* `MIRI_LIB_SRC` defines the directory where Miri expects the sources of the\n+  standard library that it will build and use for interpretation. This directory\n+  must point to the `library` subdirectory of a `rust-lang/rust` repository\n+  checkout. Note that changing files in that directory does not automatically\n+  trigger a re-build of the standard library; you have to clear the Miri build\n+  cache manually (on Linux, `rm -rf ~/.cache/miri`).\n+* `MIRI_SYSROOT` (recognized by `cargo miri` and the Miri driver) indicates the sysroot to use. When\n+  using `cargo miri`, only set this if you do not want to use the automatically created sysroot. For\n+  directly invoking the Miri driver, this variable (or a `--sysroot` flag) is mandatory.\n+* `MIRI_TEST_TARGET` (recognized by the test suite and the `./miri` script) indicates which target\n+  architecture to test against.  `miri` and `cargo miri` accept the `--target` flag for the same\n+  purpose.\n+* `MIRI_NO_STD` (recognized by `cargo miri` and the test suite) makes sure that the target's\n+  sysroot is built without libstd. This allows testing and running no_std programs.\n+* `MIRI_BLESS` (recognized by the test suite) overwrite all `stderr` and `stdout` files\n+  instead of checking whether the output matches.\n+* `MIRI_SKIP_UI_CHECKS` (recognized by the test suite) don't check whether the\n+  `stderr` or `stdout` files match the actual output. Useful for the rustc test suite\n+  which has subtle differences that we don't care about.\n+\n+The following environment variables are *internal* and must not be used by\n+anyone but Miri itself. They are used to communicate between different Miri\n+binaries, and as such worth documenting:\n+\n+* `MIRI_BE_RUSTC` can be set to `host` or `target`. It tells the Miri driver to\n+  actually not interpret the code but compile it like rustc would. With `target`, Miri sets\n+  some compiler flags to prepare the code for interpretation; with `host`, this is not done.\n+  This environment variable is useful to be sure that the compiled `rlib`s are compatible\n+  with Miri.\n+* `MIRI_CALLED_FROM_XARGO` is set during the Miri-induced `xargo` sysroot build,\n+  which will re-invoke `cargo-miri` as the `rustc` to use for this build.\n+* `MIRI_CALLED_FROM_RUSTDOC` when set to any value tells `cargo-miri` that it is\n+  running as a child process of `rustdoc`, which invokes it twice for each doc-test\n+  and requires special treatment, most notably a check-only build before interpretation.\n+  This is set by `cargo-miri` itself when running as a `rustdoc`-wrapper.\n+* `MIRI_CWD` when set to any value tells the Miri driver to change to the given\n+  directory after loading all the source files, but before commencing\n+  interpretation. This is useful if the interpreted program wants a different\n+  working directory at run-time than at build-time.\n+* `MIRI_LOCAL_CRATES` is set by `cargo-miri` to tell the Miri driver which\n+  crates should be given special treatment in diagnostics, in addition to the\n+  crate currently being compiled.\n+* `MIRI_VERBOSE` when set to any value tells the various `cargo-miri` phases to\n+  perform verbose logging.\n+* `MIRI_HOST_SYSROOT` is set by bootstrap to tell `cargo-miri` which sysroot to use for *host*\n+  operations.\n+\n+[testing-miri]: CONTRIBUTING.md#testing-the-miri-driver\n+\n+## Miri `extern` functions\n+\n+Miri provides some `extern` functions that programs can import to access\n+Miri-specific functionality:\n+\n+```rust\n+#[cfg(miri)]\n+extern \"Rust\" {\n+    /// Miri-provided extern function to mark the block `ptr` points to as a \"root\"\n+    /// for some static memory. This memory and everything reachable by it is not\n+    /// considered leaking even if it still exists when the program terminates.\n+    ///\n+    /// `ptr` has to point to the beginning of an allocated block.\n+    fn miri_static_root(ptr: *const u8);\n+\n+    // Miri-provided extern function to get the amount of frames in the current backtrace.\n+    // The `flags` argument must be `0`.\n+    fn miri_backtrace_size(flags: u64) -> usize;\n+\n+    /// Miri-provided extern function to obtain a backtrace of the current call stack.\n+    /// This writes a slice of pointers into `buf` - each pointer is an opaque value\n+    /// that is only useful when passed to `miri_resolve_frame`.\n+    /// `buf` must have `miri_backtrace_size(0) * pointer_size` bytes of space.\n+    /// The `flags` argument must be `1`.\n+    fn miri_get_backtrace(flags: u64, buf: *mut *mut ());\n+\n+    /// Miri-provided extern function to resolve a frame pointer obtained\n+    /// from `miri_get_backtrace`. The `flags` argument must be `1`,\n+    /// and `MiriFrame` should be declared as follows:\n+    ///\n+    /// ```rust\n+    /// #[repr(C)]\n+    /// struct MiriFrame {\n+    ///     // The size of the name of the function being executed, encoded in UTF-8\n+    ///     name_len: usize,\n+    ///     // The size of filename of the function being executed, encoded in UTF-8\n+    ///     filename_len: usize,\n+    ///     // The line number currently being executed in `filename`, starting from '1'.\n+    ///     lineno: u32,\n+    ///     // The column number currently being executed in `filename`, starting from '1'.\n+    ///     colno: u32,\n+    ///     // The function pointer to the function currently being executed.\n+    ///     // This can be compared against function pointers obtained by\n+    ///     // casting a function (e.g. `my_fn as *mut ()`)\n+    ///     fn_ptr: *mut ()\n+    /// }\n+    /// ```\n+    ///\n+    /// The fields must be declared in exactly the same order as they appear in `MiriFrame` above.\n+    /// This function can be called on any thread (not just the one which obtained `frame`).\n+    fn miri_resolve_frame(frame: *mut (), flags: u64) -> MiriFrame;\n+\n+    /// Miri-provided extern function to get the name and filename of the frame provided by `miri_resolve_frame`.\n+    /// `name_buf` and `filename_buf` should be allocated with the `name_len` and `filename_len` fields of `MiriFrame`.\n+    /// The flags argument must be `0`.\n+    fn miri_resolve_frame_names(ptr: *mut (), flags: u64, name_buf: *mut u8, filename_buf: *mut u8);\n+\n+    /// Miri-provided extern function to begin unwinding with the given payload.\n+    ///\n+    /// This is internal and unstable and should not be used; we give it here\n+    /// just to be complete.\n+    fn miri_start_panic(payload: *mut u8) -> !;\n+}\n+```\n+\n+## Contributing and getting help\n+\n+If you want to contribute to Miri, great!  Please check out our\n+[contribution guide](CONTRIBUTING.md).\n+\n+For help with running Miri, you can open an issue here on\n+GitHub or use the [Miri stream on the Rust Zulip][zulip].\n+\n+[zulip]: https://rust-lang.zulipchat.com/#narrow/stream/269128-miri\n+\n+## History\n+\n+This project began as part of an undergraduate research course in 2015 by\n+@solson at the [University of Saskatchewan][usask].  There are [slides] and a\n+[report] available from that project.  In 2016, @oli-obk joined to prepare Miri\n+for eventually being used as const evaluator in the Rust compiler itself\n+(basically, for `const` and `static` stuff), replacing the old evaluator that\n+worked directly on the AST.  In 2017, @RalfJung did an internship with Mozilla\n+and began developing Miri towards a tool for detecting undefined behavior, and\n+also using Miri as a way to explore the consequences of various possible\n+definitions for undefined behavior in Rust.  @oli-obk's move of the Miri engine\n+into the compiler finally came to completion in early 2018.  Meanwhile, later\n+that year, @RalfJung did a second internship, developing Miri further with\n+support for checking basic type invariants and verifying that references are\n+used according to their aliasing restrictions.\n+\n+[usask]: https://www.usask.ca/\n+[slides]: https://solson.me/miri-slides.pdf\n+[report]: https://solson.me/miri-report.pdf\n+\n+## Bugs found by Miri\n+\n+Miri has already found a number of bugs in the Rust standard library and beyond, which we collect here.\n+\n+Definite bugs found:\n+\n+* [`Debug for vec_deque::Iter` accessing uninitialized memory](https://github.com/rust-lang/rust/issues/53566)\n+* [`Vec::into_iter` doing an unaligned ZST read](https://github.com/rust-lang/rust/pull/53804)\n+* [`From<&[T]> for Rc` creating a not sufficiently aligned reference](https://github.com/rust-lang/rust/issues/54908)\n+* [`BTreeMap` creating a shared reference pointing to a too small allocation](https://github.com/rust-lang/rust/issues/54957)\n+* [`Vec::append` creating a dangling reference](https://github.com/rust-lang/rust/pull/61082)\n+* [Futures turning a shared reference into a mutable one](https://github.com/rust-lang/rust/pull/56319)\n+* [`str` turning a shared reference into a mutable one](https://github.com/rust-lang/rust/pull/58200)\n+* [`rand` performing unaligned reads](https://github.com/rust-random/rand/issues/779)\n+* [The Unix allocator calling `posix_memalign` in an invalid way](https://github.com/rust-lang/rust/issues/62251)\n+* [`getrandom` calling the `getrandom` syscall in an invalid way](https://github.com/rust-random/getrandom/pull/73)\n+* [`Vec`](https://github.com/rust-lang/rust/issues/69770) and [`BTreeMap`](https://github.com/rust-lang/rust/issues/69769) leaking memory under some (panicky) conditions\n+* [`beef` leaking memory](https://github.com/maciejhirsz/beef/issues/12)\n+* [`EbrCell` using uninitialized memory incorrectly](https://github.com/Firstyear/concread/commit/b15be53b6ec076acb295a5c0483cdb4bf9be838f#diff-6282b2fc8e98bd089a1f0c86f648157cR229)\n+* [TiKV performing an unaligned pointer access](https://github.com/tikv/tikv/issues/7613)\n+* [`servo_arc` creating a dangling shared reference](https://github.com/servo/servo/issues/26357)\n+* [TiKV constructing out-of-bounds pointers (and overlapping mutable references)](https://github.com/tikv/tikv/pull/7751)\n+* [`encoding_rs` doing out-of-bounds pointer arithmetic](https://github.com/hsivonen/encoding_rs/pull/53)\n+* [TiKV using `Vec::from_raw_parts` incorrectly](https://github.com/tikv/agatedb/pull/24)\n+* Incorrect doctests for [`AtomicPtr`](https://github.com/rust-lang/rust/pull/84052) and [`Box::from_raw_in`](https://github.com/rust-lang/rust/pull/84053)\n+* [Insufficient alignment in `ThinVec`](https://github.com/Gankra/thin-vec/pull/27)\n+* [`crossbeam-epoch` calling `assume_init` on a partly-initialized `MaybeUninit`](https://github.com/crossbeam-rs/crossbeam/pull/779)\n+* [`integer-encoding` dereferencing a misaligned pointer](https://github.com/dermesser/integer-encoding-rs/pull/23)\n+* [`rkyv` constructing a `Box<[u8]>` from an overaligned allocation](https://github.com/rkyv/rkyv/commit/a9417193a34757e12e24263178be8b2eebb72456)\n+* [Data race in `thread::scope`](https://github.com/rust-lang/rust/issues/98498)\n+* [`regex` incorrectly handling unaligned `Vec<u8>` buffers](https://www.reddit.com/r/rust/comments/vq3mmu/comment/ienc7t0?context=3)\n+* [Incorrect use of `compare_exchange_weak` in `once_cell`](https://github.com/matklad/once_cell/issues/186)\n+\n+Violations of [Stacked Borrows] found that are likely bugs (but Stacked Borrows is currently just an experiment):\n+\n+* [`VecDeque::drain` creating overlapping mutable references](https://github.com/rust-lang/rust/pull/56161)\n+* Various `BTreeMap` problems\n+    * [`BTreeMap` iterators creating mutable references that overlap with shared references](https://github.com/rust-lang/rust/pull/58431)\n+    * [`BTreeMap::iter_mut` creating overlapping mutable references](https://github.com/rust-lang/rust/issues/73915)\n+    * [`BTreeMap` node insertion using raw pointers outside their valid memory area](https://github.com/rust-lang/rust/issues/78477)\n+* [`LinkedList` cursor insertion creating overlapping mutable references](https://github.com/rust-lang/rust/pull/60072)\n+* [`Vec::push` invalidating existing references into the vector](https://github.com/rust-lang/rust/issues/60847)\n+* [`align_to_mut` violating uniqueness of mutable references](https://github.com/rust-lang/rust/issues/68549)\n+* [`sized-chunks` creating aliasing mutable references](https://github.com/bodil/sized-chunks/issues/8)\n+* [`String::push_str` invalidating existing references into the string](https://github.com/rust-lang/rust/issues/70301)\n+* [`ryu` using raw pointers outside their valid memory area](https://github.com/dtolnay/ryu/issues/24)\n+* [ink! creating overlapping mutable references](https://github.com/rust-lang/miri/issues/1364)\n+* [TiKV creating overlapping mutable reference and raw pointer](https://github.com/tikv/tikv/pull/7709)\n+* [Windows `Env` iterator using a raw pointer outside its valid memory area](https://github.com/rust-lang/rust/pull/70479)\n+* [`VecDeque::iter_mut` creating overlapping mutable references](https://github.com/rust-lang/rust/issues/74029)\n+* [Various standard library aliasing issues involving raw pointers](https://github.com/rust-lang/rust/pull/78602)\n+* [`<[T]>::copy_within` using a loan after invalidating it](https://github.com/rust-lang/rust/pull/85610)\n+\n+## Scientific papers employing Miri\n+\n+* [Stacked Borrows: An Aliasing Model for Rust](https://plv.mpi-sws.org/rustbelt/stacked-borrows/)\n+* [Using Lightweight Formal Methods to Validate a Key-Value Storage Node in Amazon S3](https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3)\n+* [SyRust: Automatic Testing of Rust Libraries with Semantic-Aware Program Synthesis](https://dl.acm.org/doi/10.1145/3453483.3454084)\n+\n+## License\n+\n+Licensed under either of\n+\n+  * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or\n+    http://www.apache.org/licenses/LICENSE-2.0)\n+  * MIT license ([LICENSE-MIT](LICENSE-MIT) or\n+    http://opensource.org/licenses/MIT)\n+\n+at your option.\n+\n+### Contribution\n+\n+Unless you explicitly state otherwise, any contribution intentionally submitted\n+for inclusion in the work by you shall be dual licensed as above, without any\n+additional terms or conditions."}, {"sha": "375b129a7e59b6fabd15b9bab4ed325d88cc433b", "filename": "src/tools/miri/bench-cargo-miri/backtraces/Cargo.lock", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,94 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"addr2line\"\n+version = \"0.17.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n+dependencies = [\n+ \"gimli\",\n+]\n+\n+[[package]]\n+name = \"adler\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n+\n+[[package]]\n+name = \"backtrace\"\n+version = \"0.3.65\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"11a17d453482a265fd5f8479f2a3f405566e6ca627837aaddb85af8b1ab8ef61\"\n+dependencies = [\n+ \"addr2line\",\n+ \"cc\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"miniz_oxide\",\n+ \"object\",\n+ \"rustc-demangle\",\n+]\n+\n+[[package]]\n+name = \"backtraces\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"backtrace\",\n+]\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.73\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+\n+[[package]]\n+name = \"gimli\"\n+version = \"0.26.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.126\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+\n+[[package]]\n+name = \"memchr\"\n+version = \"2.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n+\n+[[package]]\n+name = \"miniz_oxide\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n+dependencies = [\n+ \"adler\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.28.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342\""}, {"sha": "1ba96b19395d29227afbafb420ea0dd6b160eb6c", "filename": "src/tools/miri/bench-cargo-miri/backtraces/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"backtraces\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+backtrace = \"0.3.65\""}, {"sha": "eba51c60dbc5b3e678ee64f214ce2fce27a71622", "filename": "src/tools/miri/bench-cargo-miri/backtraces/src/main.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fbacktraces%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,29 @@\n+//! Extracted from the backtrace crate's test test_frame_conversion\n+\n+use backtrace::{Backtrace, BacktraceFrame};\n+use std::fmt::Write;\n+\n+fn main() {\n+    let mut frames = vec![];\n+    backtrace::trace(|frame| {\n+        let converted = BacktraceFrame::from(frame.clone());\n+        frames.push(converted);\n+        true\n+    });\n+\n+    let mut manual = Backtrace::from(frames);\n+    manual.resolve();\n+    let frames = manual.frames();\n+\n+    let mut output = String::new();\n+    for frame in frames {\n+        // Originally these were println! but we'd prefer our benchmarks to not emit a lot of\n+        // output to stdout/stderr. Unfortunately writeln! to a String is faster, but we still\n+        // manage to exercise interesting code paths in Miri.\n+        writeln!(output, \"{:?}\", frame.ip()).unwrap();\n+        writeln!(output, \"{:?}\", frame.symbol_address()).unwrap();\n+        writeln!(output, \"{:?}\", frame.module_base_address()).unwrap();\n+        writeln!(output, \"{:?}\", frame.symbols()).unwrap();\n+    }\n+    drop(output);\n+}"}, {"sha": "d2b1aa341bbb6ea1adcbcd4b64a432c021a9e04e", "filename": "src/tools/miri/bench-cargo-miri/mse/Cargo.lock", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,7 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"mse\"\n+version = \"0.1.0\""}, {"sha": "7b4c2dc758faa5dae1cd623c9b5f2ce9bde259a5", "filename": "src/tools/miri/bench-cargo-miri/mse/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"mse\"\n+version = \"0.1.0\"\n+authors = [\"Ralf Jung <post@ralfj.de>\"]\n+edition = \"2018\"\n+\n+[dependencies]"}, {"sha": "c09dc2484d380f65d573905afc41d35cee618abe", "filename": "src/tools/miri/bench-cargo-miri/mse/src/main.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fmse%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,32 @@\n+#[rustfmt::skip] // no need to wrap these arrays onto hundreds of lines\n+static EXPECTED: &[u8] = &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 1, 0, 255, 255, 1, 0, 255, 255, 1, 0, 255, 255, 1, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 254, 255, 0, 0, 254, 255, 0, 0, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 255, 255, 1, 0, 255, 255, 1, 0, 0, 0, 1, 0, 255, 255, 2, 0, 255, 255, 2, 0, 255, 255, 2, 0, 255, 255, 2, 0, 255, 255, 2, 0, 255, 255, 1, 0, 255, 255, 1, 0, 255, 255, 0, 0, 254, 255, 0, 0, 254, 255, 0, 0, 254, 255, 255, 255, 254, 255, 254, 255, 254, 255, 253, 255, 253, 255, 253, 255, 253, 255, 252, 255, 254, 255, 251, 255, 254, 255, 251, 255, 254, 255, 252, 255, 255, 255, 252, 255, 0, 0, 252, 255, 0, 0, 252, 255, 1, 0, 252, 255, 1, 0, 252, 255, 2, 0, 252, 255, 2, 0, 252, 255, 2, 0, 252, 255, 2, 0, 252, 255, 2, 0, 253, 255, 1, 0, 252, 255, 0, 0, 252, 255, 255, 255, 251, 255, 0, 0, 251, 255, 0, 0, 251, 255, 0, 0, 252, 255, 2, 0, 252, 255, 3, 0, 252, 255, 4, 0, 253, 255, 5, 0, 254, 255, 5, 0, 253, 255, 6, 0, 253, 255, 6, 0, 253, 255, 5, 0, 253, 255, 5, 0, 254, 255, 4, 0, 254, 255, 3, 0, 251, 255, 0, 0, 250, 255, 255, 255, 253, 255, 254, 255, 252, 255, 252, 255, 247, 255, 251, 255, 247, 255, 252, 255, 252, 255, 254, 255, 252, 255, 254, 255, 252, 255, 255, 255, 254, 255, 1, 0, 1, 0, 1, 0, 4, 0, 2, 0, 8, 0, 2, 0, 12, 0, 1, 0, 13, 0, 0, 0, 12, 0, 0, 0, 11, 0, 255, 255, 8, 0, 254, 255, 7, 0, 0, 0, 7, 0, 253, 255, 11, 0, 248, 255, 15, 0, 247, 255, 17, 0, 250, 255, 17, 0, 251, 255, 13, 0, 253, 255, 7, 0, 255, 255, 3, 0, 255, 255, 254, 255, 255, 255, 252, 255, 255, 255, 252, 255, 254, 255, 250, 255, 255, 255, 242, 255, 254, 255, 239, 255, 252, 255, 248, 255, 255, 255, 249, 255, 5, 0, 239, 255, 7, 0, 238, 255, 10, 0, 249, 255, 18, 0, 254, 255, 25, 0, 253, 255, 27, 0, 0, 0, 31, 0, 4, 0, 34, 0, 4, 0, 34, 0, 8, 0, 36, 0, 8, 0, 37, 0, 2, 0, 36, 0, 4, 0, 34, 0, 8, 0, 28, 0, 3, 0, 15, 0, 255, 255, 11, 0, 0, 0, 12, 0, 251, 255, 8, 0, 252, 255, 10, 0, 0, 0, 23, 0, 252, 255, 31, 0, 248, 255, 30, 0, 254, 255, 30, 0, 255, 255, 26, 0, 250, 255, 22, 0, 250, 255, 20, 0, 244, 255, 15, 0, 237, 255, 10, 0, 246, 255, 13, 0, 242, 255, 6, 0, 213, 255, 243, 255, 213, 255, 240, 255, 247, 255, 244, 255, 246, 255, 227, 255, 214, 255, 216, 255, 219, 255, 228, 255, 251, 255, 235, 255, 1, 0, 232, 255, 248, 255, 236, 255, 4, 0, 238, 255, 26, 0, 232, 255, 44, 0, 230, 255, 66, 0, 226, 255, 86, 0, 219, 255, 88, 0, 215, 255, 72, 0, 210, 255, 50, 0, 225, 255, 28, 0, 23, 0, 14, 0, 64, 0, 16, 0, 51, 0, 26, 0, 32, 0, 34, 0, 39, 0, 42, 0, 48, 0, 35, 0, 58, 0, 255, 255, 72, 0, 220, 255, 69, 0, 197, 255, 58, 0, 158, 255, 54, 0, 132, 255, 36, 0, 153, 255, 12, 0, 146, 255, 5, 0, 83, 255, 237, 255, 110, 255, 197, 255, 252, 255, 214, 255, 51, 0, 1, 0, 233, 255, 250, 255, 226, 255, 250, 255, 45, 0, 46, 0, 47, 0, 70, 0, 6, 0, 55, 0, 19, 0, 60, 0, 38, 0, 62, 0, 42, 0, 47, 0, 61, 0, 46, 0, 40, 0, 42, 0, 237, 255, 22, 0, 222, 255, 6, 0, 221, 255, 206, 255, 195, 255, 115, 255, 219, 255, 85, 255, 17, 0, 93, 255, 26, 0, 76, 255, 46, 0, 102, 255, 80, 0, 193, 255, 48, 0, 252, 255, 18, 0, 20, 0, 50, 0, 47, 0, 58, 0, 53, 0, 44, 0, 61, 0, 57, 0, 85, 0, 37, 0, 80, 0, 0, 0, 86, 0, 248, 255, 106, 0, 161, 255, 49, 0, 43, 255, 248, 255, 125, 255, 47, 0, 49, 0, 63, 0, 40, 0, 217, 255, 187, 255, 182, 255, 219, 255, 236, 255, 63, 0, 244, 255, 58, 0, 242, 255, 244, 255, 25, 0, 225, 255, 41, 0, 11, 0, 45, 0, 76, 0, 47, 0, 167, 0, 5, 0, 5, 1, 219, 255, 21, 1, 173, 255, 183, 0, 84, 255, 35, 0, 134, 255, 177, 255, 138, 0, 186, 255, 10, 1, 69, 0, 124, 0, 228, 0, 0, 0, 135, 1, 227, 255, 82, 2, 172, 255, 190, 2, 178, 255, 115, 2, 248, 255, 39, 2, 243, 255, 253, 1, 13, 0, 116, 1, 120, 0, 96, 1, 125, 0, 110, 2, 127, 0, 179, 2, 223, 0, 106, 1, 126, 0, 130, 1, 223, 255, 147, 3, 198, 0, 190, 3, 201, 1, 200, 1, 42, 1, 244, 1, 233, 0, 3, 4, 213, 1, 72, 4, 170, 1, 150, 3, 160, 0, 43, 4, 141, 0, 196, 4, 189, 0, 221, 4, 164, 0, 95, 5, 41, 1, 98, 5, 247, 1, 19, 5, 190, 2, 14, 6, 161, 3, 7, 7, 87, 3, 216, 6, 35, 2, 38, 7, 90, 2, 136, 7, 64, 3, 200, 6, 28, 3, 199, 6, 165, 3, 169, 7, 105, 5, 143, 7, 26, 6, 57, 8, 205, 5, 156, 10, 169, 5, 132, 11, 25, 5, 208, 10, 181, 4, 156, 10, 66, 5, 227, 9, 170, 5, 166, 9, 117, 6, 45, 12, 63, 8, 42, 13, 128, 8, 136, 10, 155, 7, 109, 11, 1, 9, 6, 15, 98, 10, 121, 9, 136, 8, 147, 252, 189, 7, 43, 247, 63, 10, 147, 249, 92, 11, 172, 248, 172, 10, 112, 245, 137, 11, 76, 246, 44, 12, 184, 247, 138, 11, 118, 246, 144, 12, 94, 246, 171, 13, 112, 247, 162, 12, 168, 246, 33, 13, 63, 246, 29, 15, 226, 247, 188, 14, 190, 248, 75, 15, 238, 247, 86, 17, 19, 247, 118, 11, 10, 247, 232, 254, 238, 247, 30, 249, 56, 248, 124, 250, 6, 247, 1, 250, 161, 246, 3, 249, 81, 247, 117, 250, 60, 247, 202, 250, 212, 247, 60, 250, 15, 249, 140, 250, 34, 248, 221, 249, 105, 247, 218, 249, 205, 248, 113, 251, 138, 248, 90, 250, 41, 248, 230, 248];\n+#[rustfmt::skip]\n+static PCM: &[i16] = &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 1, 0, 0, -2, 0, -2, 0, -2, 0, -2, -2, -2, -3, -3, -3, -3, -4, -2, -5, -2, -5, -2, -4, 0, -4, 0, -4, 0, -4, 1, -4, 1, -4, 2, -4, 2, -4, 2, -4, 2, -4, 2, -3, 1, -4, 0, -4, 0, -5, 0, -5, 0, -5, 0, -4, 2, -4, 3, -4, 4, -3, 5, -2, 5, -3, 6, -3, 6, -3, 5, -3, 5, -2, 4, -2, 3, -5, 0, -6, 0, -3, -2, -4, -4, -9, -5, -9, -4, -4, -2, -4, -2, -4, 0, -2, 1, 1, 1, 4, 2, 8, 2, 12, 1, 13, 0, 12, 0, 11, 0, 8, -2, 7, 0, 7, -3, 11, -8, 15, -9, 17, -6, 17, -5, 13, -3, 7, 0, 3, 0, -2, 0, -4, 0, -4, -2, -6, 0, -14, -2, -17, -4, -8, 0, -7, 5, -17, 7, -18, 10, -7, 18, -2, 25, -3, 27, 0, 31, 4, 34, 4, 34, 8, 36, 8, 37, 2, 36, 4, 34, 8, 28, 3, 15, 0, 11, 0, 12, -5, 8, -4, 10, 0, 23, -4, 31, -8, 30, -2, 30, 0, 26, -6, 22, -6, 20, -12, 15, -19, 10, -10, 13, -14, 6, -43, -13, -43, -16, -9, -12, -10, -29, -42, -40, -37, -28, -5, -21, 1, -24, -8, -20, 4, -18, 26, -24, 44, -26, 66, -30, 86, -37, 88, -41, 72, -46, 50, -31, 28, 23, 14, 64, 16, 51, 26, 32, 34, 39, 42, 48, 35, 58, 0, 72, -36, 69, -59, 58, -98, 54, -124, 36, -103, 12, -110, 5, -173, -19, -146, -59, -4, -42, 51, 1, -23, -6, -30, -6, 45, 46, 47, 70, 6, 55, 19, 60, 38, 62, 42, 47, 61, 46, 40, 42, -19, 22, -34, 6, -35, -50, -61, -141, -37, -171, 17, -163, 26, -180, 46, -154, 80, -63, 48, -4, 18, 20, 50, 47, 58, 53, 44, 61, 57, 85, 37, 80, 0, 86, -8, 106, -95, 49, -213, -8, -131, 47, 49, 63, 40, -39, -69, -74, -37, -20, 63, -12, 58, -14, -12, 25, -31, 41, 11, 45, 76, 47, 167, 5, 261, -37, 277, -83, 183, -172, 35, -122, -79, 138, -70, 266, 69, 124, 228, 0, 391, -29, 594, -84, 702, -78, 627, -8, 551, -13, 509, 13, 372, 120, 352, 125, 622, 127, 691, 223, 362, 126, 386, -33, 915, 198, 958, 457, 456, 298, 500, 233, 1027, 469, 1096, 426, 918, 160, 1067, 141, 1220, 189, 1245, 164, 1375, 297, 1378, 503, 1299, 702, 1550, 929, 1799, 855, 1752, 547, 1830, 602, 1928, 832, 1736, 796, 1735, 933, 1961, 1385, 1935, 1562, 2105, 1485, 2716, 1449, 2948, 1305, 2768, 1205, 2716, 1346, 2531, 1450, 2470, 1653, 3117, 2111, 3370, 2176, 2696, 1947, 2925, 2305, 3846, 2658, 2425, 2184, -877, 1981, -2261, 2623, -1645, 2908, -1876, 2732, -2704, 2953, -2484, 3116, -2120, 2954, -2442, 3216, -2466, 3499, -2192, 3234, -2392, 3361, -2497, 3869, -2078, 3772, -1858, 3915, -2066, 4438, -2285, 2934, -2294, -280, -2066, -1762, -1992, -1412, -2298, -1535, -2399, -1789, -2223, -1419, -2244, -1334, -2092, -1476, -1777, -1396, -2014, -1571, -2199, -1574, -1843, -1167, -1910, -1446, -2007, -1818];\n+\n+fn main() {\n+    #[cfg(increase_thread_usage)]\n+    let thread = std::thread::spawn(|| 4);\n+\n+    for _ in 0..2 {\n+        mse(PCM.len(), PCM, EXPECTED);\n+    }\n+}\n+\n+fn read_i16(buffer: &[u8], index: usize) -> i16 {\n+    const SIZE: usize = std::mem::size_of::<i16>();\n+    let mut bytes: [u8; SIZE] = [0u8; SIZE];\n+    bytes.copy_from_slice(&buffer[(index * SIZE)..(index * SIZE + SIZE)]);\n+    unsafe { std::mem::transmute(bytes) }\n+}\n+\n+fn mse(samples: usize, frame_buf: &[i16], buf_ref: &[u8]) -> f64 {\n+    let mut mse = 0.0;\n+    let max_samples = std::cmp::min(buf_ref.len() / 2, samples as usize);\n+    for i in 0..max_samples {\n+        let ref_res = read_i16(buf_ref, i);\n+        let info_res = frame_buf[i as usize];\n+        let diff = (ref_res - info_res).abs();\n+        mse += f64::from(diff.pow(2));\n+    }\n+    mse / max_samples as f64\n+}"}, {"sha": "4875057613543158c0ee7d60cc2867372a578c13", "filename": "src/tools/miri/bench-cargo-miri/serde1/Cargo.lock", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,89 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"cargo-miri-test\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.39\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c54b25569025b7fc9651de43004ae593a75ad88543b17178aa5e1b9c4f15f56f\"\n+dependencies = [\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a1feb54ed693b93a84e14094943b84b7c4eae204c512b7ccb95ab0c66d278ad1\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f3f6f92acf49d1b98f7a81226834412ada05458b7364277387724a237f062695\"\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61ea8d54c77f8315140a05f4c7237403bf38b72704d031543aa1d16abbf517d1\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.81\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9b7ce2b32a1aed03c558dc61a5cd328f15aff2dbc17daad8fb8af04d2100e15c\"\n+dependencies = [\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.96\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0748dd251e24453cb8717f0354206b91557e4ec8703673a4b30208f2abaf1ebf\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"unicode-ident\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d22af068fba1eb5edcb4aea19d382b2a3deb4c8f9d475c589b6ada9e0fd493ee\""}, {"sha": "7cb863a7abf33ee070f229e6ccb1ee9b5ea6ee77", "filename": "src/tools/miri/bench-cargo-miri/serde1/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"cargo-miri-test\"\n+version = \"0.1.0\"\n+authors = [\"Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\""}, {"sha": "2712156d61b4aa749531616b6f698fc0febe831a", "filename": "src/tools/miri/bench-cargo-miri/serde1/src/main.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde1%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,13 @@\n+static JSON: &str = r#\"{\"buffer\":[-29,-42,-40,-37,-28,-5,-21,1,-24,-8,-20,4,-18,26,-24,44,-26,66,-30,86,-37,88,-41,72,-46,50,-31,28,23,14,64,16,51,26,32,34,39,42,48,35,58,0,72,-36,69,-59,58,-98,54,-124,36,-103,12,-110,5,-173,-19,-146,-59,-4,-42,51,1,-23,-6,-30,-6,45,46,47,70,6,55,19,60,38,62,42,47,61,46,40,42,-19,22,-34,6,-35,-50,-61,-141,-37,-171,17,-163,26,-180,46,-154,80,-63,48,-4,18,20,50,47,58,53,44,61,57,85,37,80,0,86,-8,106,-95,49,-213,-8,-131,47,49,63,40,-39,-69,-74,-37,-20,63,-12,58,-14,-12,25,-31,41,11,45,76,47,167,5,261,-37,277,-83,183,-172,35,-122,-79,138,-70,266,69,124,228,0,391,-29,594,-84,702,-78,627,-8,551,-13,509,13,372,120,352,125,622,127,691,223,362,126,386,-33,915,198,958,457,456,298,500,233,1027,469,1096,426,918,160,1067,141,1220,189,1245,164,1375,297,1378,503,1299,702,1550,929,1799,855,1752,547,1830,602,1928,832,1736,796,1735,933,1961,1385,1935,1562,2105,1485,2716,1449,2948,1305,2768,1205,2716,1346,2531,1450,2470,1653,3117,2111,3370,2176,2696,1947,2925,2305,3846,2658,2425,2184,-877,1981,-2261,2623,-1645,2908,-1876,2732,-2704,2953,-2484,3116,-2120,2954,-2442,3216,-2466,3499,-2192,3234,-2392,3361,-2497,3869,-2078,3772,-1858,3915,-2066,4438,-2285,2934,-2294,-280,-2066,-1762,-1992,-1412,-2298,-1535,-2399,-1789,-2223,-1419,-2244,-1334,-2092,-1476,-1777,-1396,-2014,-1571,-2199,-1574,-1843,-1167,-1910,-1446,-2007,-1818,-1506,-1331,-2526,-2048,-5535,-4573,-7148,-5828,-6422,-5327,-5840,-5488,-5992,-6144,-6014,-6164,-6109,-6234,-6271,-6388,-6288,-6156,-6517,-6249,-6794,-6602,-6822,-6418,-6788,-6245,-6490,-6560,-6394,-6794,-7920,-6937,-10397,-7140,-11428,-6972,-11019,-6610,-11141,-6665,-11913,-7046,-11979,-7235,-11599,-7015,-11854,-6912,-12161,-7441,-12136,-7761,-12861,-7292,-13390,-7254,-12345,-7809,-12490,-7463,-13983,-6969,-10489,-8465,-2382,-11054,1272,-12247,-270,-12060,-323,-12113,502,-12486,-697,-12251,-1086,-12141,-181,-13116,-670,-13509,-1173,-12592,-443,-12811,-449,-13698,-934,-12850,-747,-13083,-873,-15036,-1161,-11478,-1047,-2669,-1407,1006,-1658,-1146,-1195,-1297,-1421,-73,-1946,-977,-1590,-1499,-1577,-1010,-1862,-1256,-1389,-962,-1692,-509,-2613,-1317,-2087,-1359,-1997,-1034,-2891,-2024,-119,-84,5651,5723,8074,8306,7156,6870,6985,7106,7312,8403,7114,8096,7173,7848,7082,7827,6761,7189,6985,7368,7076,7835,6992,7297,7453,7260,7016,7755,6025,7429,8533,7352,14150,7628,17142,7077,16399,6947,15939,7475,16564,7069,16463,6882,16400,7602,17031,7233,16543,6517,15395,7018,15985,7104,16689,6869,15655,7622,16155,7198,17884,6022,14056,8856,5665,14484,1815,16782,3034,15786,3107,15664,2312,16517,2965,16443,3036,16120,2287,16584,2479,16720,2693,16073,2535,16159,2958,16609,3067,16086,2716,16579,3035,17752,3092,13704,2499,5265,2620,1452,2808,3024,2444,3275,2839,2267,3340,2857,2968,3232,3066,2867,3152,3072,2248,2961,2413,2807,3238,3237,2368,2699,2262,2392,3537,3339,827,823,-5020,-5359,-7095,-7857,-5973,-6274,-6208,-6279,-6934,-7181,-6893,-6647,-7146,-6687,-7026,-7328,-6451,-6924,-6763,-6535,-7109,-6639,-6926,-6559,-7188,-6799,-6727,-6955,-5786,-6554,-8543,-6796,-14465,-7190,-17356,-6641,-16372,-6529,-15941,-6898,-16526,-6434,-16219,-6520,-16222,-7449,-17077,-7097,-16665,-6476,-15675,-7026,-16498,-6848,-17147,-6271,-15894,-7069,-16266,-7032,-17817,-5991,-13796,-8594,-5421,-14349,-1649,-17288,-2847,-16525,-2974,-15945,-2324,-16482,-3022,-16593,-3097,-16451,-2420,-16780,-2649,-16641,-2836,-15900,-2660,-16214,-3050,-16827,-3111,-15993,-2741,-16151,-2994,-17537,-2933,-13812,-2314,-5216,-2475,-1125,-2648,-2801,-2290,-3285,-2796,-2243,-3415,-2642,-3109,-3000,-3271,-2839,-3408,-3161,-2497,-2876,-2603,-2570,-3351,-3173,-2416,-2832,-2235,-2408,-3405,-3186,-613,-768,5271,5201,7376,7644,6241,6176,6366,6275,6964,7124,6831,6508,6998,6566,6836,7230,6277,6777,6589,6376,6934,6536,6819,6494,7160,6749,6736,6900,5822,6476,8593,6747,14520,7204,17448,6637,16490,6483,16033,6906,16600,6511,16304,6568,16279,7438,17079,7072,16624,6463,15577,7028,16343,6877,16990,6331,15760,7121,16140,7023,17719,5944,13748,8575,5401,14336,1645,17210,2880,16419,3036,15896,2382,16483,3074,16584,3143,16425,2443,16782,2650,16695,2825,15978,2632,16272,3015,16880,3084,16096,2709,16289,2965,17641,2932,13887,2323,5330,2474,1286,2656,2954,2309,3410,2803,2373,3414,2795,3106,3151,3263,2952,3403,3241,2483,2969,2568,2681,3316,3245,2383,2837,2199,2390,3396,3165,641,706,-5230,-5323,-7307,-7790,-6136,-6317,-6268,-6419,-6884,-7278,-6766,-6666,-6976,-6731,-6853,-7406,-6308,-6958,-6636,-6553,-6978,-6703,-6829,-6647,-7156,-6883,-6737,-7017,-5814,-6581,-8575,-6833,-14490,-7270,-17411,-6699,-16466,-6539,-16016,-6931,-16571,-6504,-16257,-6551,-16202,-7408,-16983,-7021,-16545,-6410,-15512,-6976,-16305,-6803,-17017,-6243,-15820,-7037,-16197,-6923,-17802,-5820,-13840,-8455,-5475,-14227,-1724,-17099,-2923,-16314,-3008,-15801,-2362,-16392,-3088,-16506,-3163,-16356,-2503,-16700,-2717,-16605,-2855,-15904,-2710,-16226,-3108,-16870,-3089,-16101,-2747,-16257,-3087,-17584,-2975,-13868,-2324,-5343,-2548,-1275,-2673,-2917,-2213,-3363,-2694,-2311,-3251,-2744,-2867,-3129,-3034,-2939,-3190,-3234,-2346,-2964,-2639,-2658,-3558,-3241,-2670,-2892,-2453,-2437,-3564,-3175,-771,-779,5105,5171,7308,7655,6265,6204,6397,6288,7024,7172,6903,6586,7002,6627,6777,7308,6190,6889,6537,6465,7011,6613,6985,6631,7393,6934,7073,7072,6112,6615,8751,6859,14672,7282,17448,6652,16146,6448,15565,6899,16151,6547,15860,6591,16048,7446,17065,7064,16661,6368,15774,6857,16524,6677,16825,6071,15577,6900,16119,7040,17490,6118,13495,8696,5432,14446,1678,17366,3036,16488,3624,15834,3012,16382,3575,16465,3685,16301,2815,16708,2982,16679,3356,15952,2934,16049,3290,16352,3964,15605,3612,16222,3647,17764,4272,13865,3977,5384,3592,1580,3794,3243,3627,3670,3622,2758,4007,3130,3835,3294,3964,3065,4468,3408,3933,3234,3789,3118,4634,3643,4211,3174,4155,3176,5512,4400,2792,1730,-3702,-4499,-5940,-6691,-4265,-5094,-4381,-5215,-4918,-5746,-4217,-4871,-4402,-4981,-4479,-5525,-3732,-4968,-4118,-4924,-4300,-5349,-3422,-5021,-3876,-4886,-4087,-4860,-2790,-4254,-5025,-4196,-10898,-4415,-13419,-4007,-12198,-4121,-11995,-4413,-12471,-3808,-11937,-3920,-11792,-4583,-12284,-3776,-12085,-3107,-11421,-3583,-11226,-3081,-11157,-2768,-10580,-3914,-10424,-3197,-11040,-1715,-9822,-5144,-6189,-11154,-4236,-13029,-5134,-11598,-5507,-10949,-4921,-11142,-4999,-11180,-4883,-11184,-4366,-11090,-4548,-10887,-4818,-10708,-4866,-10534,-5253,-10272,-5179,-9894,-4633,-10029,-4773,-10382,-4977,-8674,-4668,-5292,-4651,-3928,-4629,-4465,-4312,-3994,-4459,-3528,-4570,-4400,-4272,-4601,-4482,-4035,-4627,-4334,-4080,-4498,-4045,-3835,-4204,-3526,-3695,-3646,-4045,-4101,-4856,-4628,-3338,-3235,-673,-508,28,147,-453,-639,11,0,8,-2,7,0,7,-3,11,-8,15,-9,17,-6,17,-5,13,-3,7,0,3,0,-2,0,-4,0,-4,-2,-6,0,-14,-2,-17,-4,-8,0,-7,5,-17,7,-18,10,-7,18,-2,25,-3,27,0,31,4,34,4,34,8,36,8,37,2,36,4,34,8,28,3,15,0,11,0,12,-5,8,-4,10,0,23,-4,31,-8,30,-2,30,0,26,-6,22,-6,20,-12,15,-19,10,-10,13,-14,6,-43,-13,-43,-16,-9,-12,-10,-29,-42,-40,-37,-28,-5,-21,1,-24,-8,-20,4,-18,26,-24,44,-26,66,-30,86,-37,88,-41,72,-46,50,-31,28,23,14,64,16,51,26,32,34,39,42,48,35,58,0,72,-36,69,-59,58,-98,54,-124,36,-103,12,-110,5,-173,-19,-146,-59,-4,-42,51,1,-23,-6,-30,-6,45,46,47,70,6,55,19,60,38,62,42,47,61,46,40,42,-19,22,-34,6,-35,-50,-61,-141,-37,-171,17,-163,26,-180,46,-154,80,-63,48,-4,18,20,50,47,58,53,44,61,57,85,37,80,0,86,-8,106,-95,49,-213,-8,-131,47,49,63,40,-39,-69,-74,-37,-20,63,-12,58,-14,-12,25,-31,41,11,45,76,47,167,5,261,-37,277,-83,183,-172,35,-122,-79,138,-70,266,69,124,228,0,391,-29,594,-84,702,-78,627,-8,551,-13,509,13,372,120,352,125,622,127,691,223,362,126,386,-33,915,198,958,457,456,298,500,233,1027,469,1096,426,918,160,1067,141,1220,189,1245,164,1375,297,1378,503,1299,702,1550,929,1799,855,1752,547,1830,602,1928,832,1736,796,1735,933,1961,1385,1935,1562,2105,1485,2716,1449,2948,1305,2768,1205,2716,1346,2531,1450,2470,1653,3117,2111,3370,2176,2696,1947,2925,2305,3846,2658,2425,2184,-877,1981,-2261,2623,-1645,2908,-1876,2732,-2704,2953,-2484,3116,-2120,2954,-2442,3216,-2466,3499,-2192,3234,-2392,3361,-2497,3869,-2078,3772,-1858,3915,-2066,4438,-2285,2934,-2294,-280,-2066,-1762,-1992,-1412,-2298,-1535,-2399,-1789,-2223,-1419,-2244,-1334,-2092,-1476,-1777,-1396,-2014,-1571,-2199,-1574,-1843,-1167,-1910,-1446,-2007,-1818,-1506,-1331,-2526,-2048,-5535,-4573,-7148,-5828,-6422,-5327,-5840,-5488,-5992,-6144,-6014,-6164,-6109,-6234,-6271,-6388,-6288,-6156,-6517,-6249,-6794,-6602,-6822,-6418,-6788,-6245,-6490,-6560,-6394,-6794,-7920,-6937,-10397,-7140,-11428,-6972,-11019,-6610,-11141,-6665,-11913,-7046,-11979,-7235,-11599,-7015,-11854,-6912,-12161,-7441,-12136,-7761,-12861,-7292,-13390,-7254,-12345,-7809,-12490,-7463,-13983,-6969,-10489,-8465,-2382,-11054,1272,-12247,-270,-12060,-323,-12113,502,-12486,-697,-12251,-1086,-12141,-181,-13116,-670,-13509,-1173,-12592,-443,-12811,-449,-13698,-934,-12850,-747,-13083,-873,-15036,-1161,-11478,-1047,-2669,-1407,1006,-1658,-1146,-1195,-1297,-1421,-73,-1946,-977,-1590,-1499,-1577,-1010,-1862,-1256,-1389,-962,-1692,-509,-2613,-1317,-2087,-1359,-1997,-1034,-2891,-2024,-119,-84,5651,5723,8074,8306,7156,6870,6985,7106,7312,8403,7114,8096,7173,7848,7082,7827,6761,7189,6985,7368]}\"#;\n+\n+use serde::Deserialize;\n+\n+#[derive(Deserialize)]\n+struct DeriveStruct {\n+    buffer: Vec<i16>,\n+}\n+\n+fn main() {\n+    let info: DeriveStruct = serde_json::from_str(JSON).unwrap();\n+    println!(\"{}\", info.buffer.len());\n+}"}, {"sha": "4875057613543158c0ee7d60cc2867372a578c13", "filename": "src/tools/miri/bench-cargo-miri/serde2/Cargo.lock", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,89 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"cargo-miri-test\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.39\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c54b25569025b7fc9651de43004ae593a75ad88543b17178aa5e1b9c4f15f56f\"\n+dependencies = [\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a1feb54ed693b93a84e14094943b84b7c4eae204c512b7ccb95ab0c66d278ad1\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f3f6f92acf49d1b98f7a81226834412ada05458b7364277387724a237f062695\"\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61ea8d54c77f8315140a05f4c7237403bf38b72704d031543aa1d16abbf517d1\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.81\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9b7ce2b32a1aed03c558dc61a5cd328f15aff2dbc17daad8fb8af04d2100e15c\"\n+dependencies = [\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.96\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0748dd251e24453cb8717f0354206b91557e4ec8703673a4b30208f2abaf1ebf\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"unicode-ident\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d22af068fba1eb5edcb4aea19d382b2a3deb4c8f9d475c589b6ada9e0fd493ee\""}, {"sha": "7cb863a7abf33ee070f229e6ccb1ee9b5ea6ee77", "filename": "src/tools/miri/bench-cargo-miri/serde2/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"cargo-miri-test\"\n+version = \"0.1.0\"\n+authors = [\"Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\""}, {"sha": "c81b32c13fefb56808495d5eec1ec9f12e4b424c", "filename": "src/tools/miri/bench-cargo-miri/serde2/src/main.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fserde2%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,18 @@\n+// Like serde1, but in two threads concurrently. And we don't print.\n+static JSON: &str = r#\"{\"buffer\":[-29,-42,-40,-37,-28,-5,-21,1,-24,-8,-20,4,-18,26,-24,44,-26,66,-30,86,-37,88,-41,72,-46,50,-31,28,23,14,64,16,51,26,32,34,39,42,48,35,58,0,72,-36,69,-59,58,-98,54,-124,36,-103,12,-110,5,-173,-19,-146,-59,-4,-42,51,1,-23,-6,-30,-6,45,46,47,70,6,55,19,60,38,62,42,47,61,46,40,42,-19,22,-34,6,-35,-50,-61,-141,-37,-171,17,-163,26,-180,46,-154,80,-63,48,-4,18,20,50,47,58,53,44,61,57,85,37,80,0,86,-8,106,-95,49,-213,-8,-131,47,49,63,40,-39,-69,-74,-37,-20,63,-12,58,-14,-12,25,-31,41,11,45,76,47,167,5,261,-37,277,-83,183,-172,35,-122,-79,138,-70,266,69,124,228,0,391,-29,594,-84,702,-78,627,-8,551,-13,509,13,372,120,352,125,622,127,691,223,362,126,386,-33,915,198,958,457,456,298,500,233,1027,469,1096,426,918,160,1067,141,1220,189,1245,164,1375,297,1378,503,1299,702,1550,929,1799,855,1752,547,1830,602,1928,832,1736,796,1735,933,1961,1385,1935,1562,2105,1485,2716,1449,2948,1305,2768,1205,2716,1346,2531,1450,2470,1653,3117,2111,3370,2176,2696,1947,2925,2305,3846,2658,2425,2184,-877,1981,-2261,2623,-1645,2908,-1876,2732,-2704,2953,-2484,3116,-2120,2954,-2442,3216,-2466,3499,-2192,3234,-2392,3361,-2497,3869,-2078,3772,-1858,3915,-2066,4438,-2285,2934,-2294,-280,-2066,-1762,-1992,-1412,-2298,-1535,-2399,-1789,-2223,-1419,-2244,-1334,-2092,-1476,-1777,-1396,-2014,-1571,-2199,-1574,-1843,-1167,-1910,-1446,-2007,-1818,-1506,-1331,-2526,-2048,-5535,-4573,-7148,-5828,-6422,-5327,-5840,-5488,-5992,-6144,-6014,-6164,-6109,-6234,-6271,-6388,-6288,-6156,-6517,-6249,-6794,-6602,-6822,-6418,-6788,-6245,-6490,-6560,-6394,-6794,-7920,-6937,-10397,-7140,-11428,-6972,-11019,-6610,-11141,-6665,-11913,-7046,-11979,-7235,-11599,-7015,-11854,-6912,-12161,-7441,-12136,-7761,-12861,-7292,-13390,-7254,-12345,-7809,-12490,-7463,-13983,-6969,-10489,-8465,-2382,-11054,1272,-12247,-270,-12060,-323,-12113,502,-12486,-697,-12251,-1086,-12141,-181,-13116,-670,-13509,-1173,-12592,-443,-12811,-449,-13698,-934,-12850,-747,-13083,-873,-15036,-1161,-11478,-1047,-2669,-1407,1006,-1658,-1146,-1195,-1297,-1421,-73,-1946,-977,-1590,-1499,-1577,-1010,-1862,-1256,-1389,-962,-1692,-509,-2613,-1317,-2087,-1359,-1997,-1034,-2891,-2024,-119,-84,5651,5723,8074,8306,7156,6870,6985,7106,7312,8403,7114,8096,7173,7848,7082,7827,6761,7189,6985,7368,7076,7835,6992,7297,7453,7260,7016,7755,6025,7429,8533,7352,14150,7628,17142,7077,16399,6947,15939,7475,16564,7069,16463,6882,16400,7602,17031,7233,16543,6517,15395,7018,15985,7104,16689,6869,15655,7622,16155,7198,17884,6022,14056,8856,5665,14484,1815,16782,3034,15786,3107,15664,2312,16517,2965,16443,3036,16120,2287,16584,2479,16720,2693,16073,2535,16159,2958,16609,3067,16086,2716,16579,3035,17752,3092,13704,2499,5265,2620,1452,2808,3024,2444,3275,2839,2267,3340,2857,2968,3232,3066,2867,3152,3072,2248,2961,2413,2807,3238,3237,2368,2699,2262,2392,3537,3339,827,823,-5020,-5359,-7095,-7857,-5973,-6274,-6208,-6279,-6934,-7181,-6893,-6647,-7146,-6687,-7026,-7328,-6451,-6924,-6763,-6535,-7109,-6639,-6926,-6559,-7188,-6799,-6727,-6955,-5786,-6554,-8543,-6796,-14465,-7190,-17356,-6641,-16372,-6529,-15941,-6898,-16526,-6434,-16219,-6520,-16222,-7449,-17077,-7097,-16665,-6476,-15675,-7026,-16498,-6848,-17147,-6271,-15894,-7069,-16266,-7032,-17817,-5991,-13796,-8594,-5421,-14349,-1649,-17288,-2847,-16525,-2974,-15945,-2324,-16482,-3022,-16593,-3097,-16451,-2420,-16780,-2649,-16641,-2836,-15900,-2660,-16214,-3050,-16827,-3111,-15993,-2741,-16151,-2994,-17537,-2933,-13812,-2314,-5216,-2475,-1125,-2648,-2801,-2290,-3285,-2796,-2243,-3415,-2642,-3109,-3000,-3271,-2839,-3408,-3161,-2497,-2876,-2603,-2570,-3351,-3173,-2416,-2832,-2235,-2408,-3405,-3186,-613,-768,5271,5201,7376,7644,6241,6176,6366,6275,6964,7124,6831,6508,6998,6566,6836,7230,6277,6777,6589,6376,6934,6536,6819,6494,7160,6749,6736,6900,5822,6476,8593,6747,14520,7204,17448,6637,16490,6483,16033,6906,16600,6511,16304,6568,16279,7438,17079,7072,16624,6463,15577,7028,16343,6877,16990,6331,15760,7121,16140,7023,17719,5944,13748,8575,5401,14336,1645,17210,2880,16419,3036,15896,2382,16483,3074,16584,3143,16425,2443,16782,2650,16695,2825,15978,2632,16272,3015,16880,3084,16096,2709,16289,2965,17641,2932,13887,2323,5330,2474,1286,2656,2954,2309,3410,2803,2373,3414,2795,3106,3151,3263,2952,3403,3241,2483,2969,2568,2681,3316,3245,2383,2837,2199,2390,3396,3165,641,706,-5230,-5323,-7307,-7790,-6136,-6317,-6268,-6419,-6884,-7278,-6766,-6666,-6976,-6731,-6853,-7406,-6308,-6958,-6636,-6553,-6978,-6703,-6829,-6647,-7156,-6883,-6737,-7017,-5814,-6581,-8575,-6833,-14490,-7270,-17411,-6699,-16466,-6539,-16016,-6931,-16571,-6504,-16257,-6551,-16202,-7408,-16983,-7021,-16545,-6410,-15512,-6976,-16305,-6803,-17017,-6243,-15820,-7037,-16197,-6923,-17802,-5820,-13840,-8455,-5475,-14227,-1724,-17099,-2923,-16314,-3008,-15801,-2362,-16392,-3088,-16506,-3163,-16356,-2503,-16700,-2717,-16605,-2855,-15904,-2710,-16226,-3108,-16870,-3089,-16101,-2747,-16257,-3087,-17584,-2975,-13868,-2324,-5343,-2548,-1275,-2673,-2917,-2213,-3363,-2694,-2311,-3251,-2744,-2867,-3129,-3034,-2939,-3190,-3234,-2346,-2964,-2639,-2658,-3558,-3241,-2670,-2892,-2453,-2437,-3564,-3175,-771,-779,5105,5171,7308,7655,6265,6204,6397,6288,7024,7172,6903,6586,7002,6627,6777,7308,6190,6889,6537,6465,7011,6613,6985,6631,7393,6934,7073,7072,6112,6615,8751,6859,14672,7282,17448,6652,16146,6448,15565,6899,16151,6547,15860,6591,16048,7446,17065,7064,16661,6368,15774,6857,16524,6677,16825,6071,15577,6900,16119,7040,17490,6118,13495,8696,5432,14446,1678,17366,3036,16488,3624,15834,3012,16382,3575,16465,3685,16301,2815,16708,2982,16679,3356,15952,2934,16049,3290,16352,3964,15605,3612,16222,3647,17764,4272,13865,3977,5384,3592,1580,3794,3243,3627,3670,3622,2758,4007,3130,3835,3294,3964,3065,4468,3408,3933,3234,3789,3118,4634,3643,4211,3174,4155,3176,5512,4400,2792,1730,-3702,-4499,-5940,-6691,-4265,-5094,-4381,-5215,-4918,-5746,-4217,-4871,-4402,-4981,-4479,-5525,-3732,-4968,-4118,-4924,-4300,-5349,-3422,-5021,-3876,-4886,-4087,-4860,-2790,-4254,-5025,-4196,-10898,-4415,-13419,-4007,-12198,-4121,-11995,-4413,-12471,-3808,-11937,-3920,-11792,-4583,-12284,-3776,-12085,-3107,-11421,-3583,-11226,-3081,-11157,-2768,-10580,-3914,-10424,-3197,-11040,-1715,-9822,-5144,-6189,-11154,-4236,-13029,-5134,-11598,-5507,-10949,-4921,-11142,-4999,-11180,-4883,-11184,-4366,-11090,-4548,-10887,-4818,-10708,-4866,-10534,-5253,-10272,-5179,-9894,-4633,-10029,-4773,-10382,-4977,-8674,-4668,-5292,-4651,-3928,-4629,-4465,-4312,-3994,-4459,-3528,-4570,-4400,-4272,-4601,-4482,-4035,-4627,-4334,-4080,-4498,-4045,-3835,-4204,-3526,-3695,-3646,-4045,-4101,-4856,-4628,-3338,-3235,-673,-508,28,147,-453,-639,11,0,8,-2,7,0,7,-3,11,-8,15,-9,17,-6,17,-5,13,-3,7,0,3,0,-2,0,-4,0,-4,-2,-6,0,-14,-2,-17,-4,-8,0,-7,5,-17,7,-18,10,-7,18,-2,25,-3,27,0,31,4,34,4,34,8,36,8,37,2,36,4,34,8,28,3,15,0,11,0,12,-5,8,-4,10,0,23,-4,31,-8,30,-2,30,0,26,-6,22,-6,20,-12,15,-19,10,-10,13,-14,6,-43,-13,-43,-16,-9,-12,-10,-29,-42,-40,-37,-28,-5,-21,1,-24,-8,-20,4,-18,26,-24,44,-26,66,-30,86,-37,88,-41,72,-46,50,-31,28,23,14,64,16,51,26,32,34,39,42,48,35,58,0,72,-36,69,-59,58,-98,54,-124,36,-103,12,-110,5,-173,-19,-146,-59,-4,-42,51,1,-23,-6,-30,-6,45,46,47,70,6,55,19,60,38,62,42,47,61,46,40,42,-19,22,-34,6,-35,-50,-61,-141,-37,-171,17,-163,26,-180,46,-154,80,-63,48,-4,18,20,50,47,58,53,44,61,57,85,37,80,0,86,-8,106,-95,49,-213,-8,-131,47,49,63,40,-39,-69,-74,-37,-20,63,-12,58,-14,-12,25,-31,41,11,45,76,47,167,5,261,-37,277,-83,183,-172,35,-122,-79,138,-70,266,69,124,228,0,391,-29,594,-84,702,-78,627,-8,551,-13,509,13,372,120,352,125,622,127,691,223,362,126,386,-33,915,198,958,457,456,298,500,233,1027,469,1096,426,918,160,1067,141,1220,189,1245,164,1375,297,1378,503,1299,702,1550,929,1799,855,1752,547,1830,602,1928,832,1736,796,1735,933,1961,1385,1935,1562,2105,1485,2716,1449,2948,1305,2768,1205,2716,1346,2531,1450,2470,1653,3117,2111,3370,2176,2696,1947,2925,2305,3846,2658,2425,2184,-877,1981,-2261,2623,-1645,2908,-1876,2732,-2704,2953,-2484,3116,-2120,2954,-2442,3216,-2466,3499,-2192,3234,-2392,3361,-2497,3869,-2078,3772,-1858,3915,-2066,4438,-2285,2934,-2294,-280,-2066,-1762,-1992,-1412,-2298,-1535,-2399,-1789,-2223,-1419,-2244,-1334,-2092,-1476,-1777,-1396,-2014,-1571,-2199,-1574,-1843,-1167,-1910,-1446,-2007,-1818,-1506,-1331,-2526,-2048,-5535,-4573,-7148,-5828,-6422,-5327,-5840,-5488,-5992,-6144,-6014,-6164,-6109,-6234,-6271,-6388,-6288,-6156,-6517,-6249,-6794,-6602,-6822,-6418,-6788,-6245,-6490,-6560,-6394,-6794,-7920,-6937,-10397,-7140,-11428,-6972,-11019,-6610,-11141,-6665,-11913,-7046,-11979,-7235,-11599,-7015,-11854,-6912,-12161,-7441,-12136,-7761,-12861,-7292,-13390,-7254,-12345,-7809,-12490,-7463,-13983,-6969,-10489,-8465,-2382,-11054,1272,-12247,-270,-12060,-323,-12113,502,-12486,-697,-12251,-1086,-12141,-181,-13116,-670,-13509,-1173,-12592,-443,-12811,-449,-13698,-934,-12850,-747,-13083,-873,-15036,-1161,-11478,-1047,-2669,-1407,1006,-1658,-1146,-1195,-1297,-1421,-73,-1946,-977,-1590,-1499,-1577,-1010,-1862,-1256,-1389,-962,-1692,-509,-2613,-1317,-2087,-1359,-1997,-1034,-2891,-2024,-119,-84,5651,5723,8074,8306,7156,6870,6985,7106,7312,8403,7114,8096,7173,7848,7082,7827,6761,7189,6985,7368]}\"#;\n+\n+use serde::Deserialize;\n+use std::thread;\n+\n+#[derive(Deserialize)]\n+struct DeriveStruct {\n+    buffer: Vec<i16>,\n+}\n+\n+fn main() {\n+    let t = thread::spawn(|| {\n+        let _info: DeriveStruct = serde_json::from_str(JSON).unwrap();\n+    });\n+    let _info: DeriveStruct = serde_json::from_str(JSON).unwrap();\n+    t.join().unwrap();\n+}"}, {"sha": "a375afaed3098558995c2174b1ed323e15115de6", "filename": "src/tools/miri/bench-cargo-miri/slice-get-unchecked/Cargo.lock", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,7 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"slice-get-unchecked\"\n+version = \"0.1.0\""}, {"sha": "1ac2276866ff7f14952759851cc47350514b478c", "filename": "src/tools/miri/bench-cargo-miri/slice-get-unchecked/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"slice-get-unchecked\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "a72083bd9de31e181d7fdf643b9c83798de3d167", "filename": "src/tools/miri/bench-cargo-miri/slice-get-unchecked/src/main.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fslice-get-unchecked%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,12 @@\n+//! This is a stripped-down version of the code pattern that causes runtime blowup when printing\n+//! backtraces in a failed test under cargo miri test with -Zmiri-disable-isolation.\n+//! See https://github.com/rust-lang/miri/issues/2273\n+\n+fn main() {\n+    let x = vec![0u8; 4096];\n+    let mut i = 0;\n+    while i < x.len() {\n+        let _element = unsafe { *x.get_unchecked(i) };\n+        i += 1;\n+    }\n+}"}, {"sha": "80d013b7d6d84c6c4b1ed0d4e8247694ee2274d2", "filename": "src/tools/miri/bench-cargo-miri/unicode/Cargo.lock", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,16 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"unicode\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"957e51f3646910546462e67d5f7599b9e4fb8acdd304b087a6494730f9eebf04\""}, {"sha": "7e8708b03f19c1503534128298ca3bc8856d45d2", "filename": "src/tools/miri/bench-cargo-miri/unicode/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"unicode\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+unicode-xid = \"0.2.3\""}, {"sha": "3cf25ba9cf6c287a9d75cc9c993541d38b4dbf60", "filename": "src/tools/miri/bench-cargo-miri/unicode/src/main.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Funicode%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,20 @@\n+//! Extracted from the unicode-xid exhaustive test all_valid_chars_do_not_panic_for_is_xid_continue\n+\n+use unicode_xid::UnicodeXID;\n+\n+/// A `char` in Rust is a Unicode Scalar Value\n+///\n+/// See: http://www.unicode.org/glossary/#unicode_scalar_value\n+fn all_valid_chars() -> impl Iterator<Item = char> {\n+    (0u32..=0xD7FF).chain(0xE000u32..=0x10FFFF).map(|u| {\n+        core::convert::TryFrom::try_from(u)\n+            .expect(\"The selected range should be infallible if the docs match impl\")\n+    })\n+}\n+\n+fn main() {\n+    // Take only the first few chars because we don't want to wait all day\n+    for c in all_valid_chars().take(1_500) {\n+        let _ = UnicodeXID::is_xid_continue(c);\n+    }\n+}"}, {"sha": "37c626baab58a49a6388f8336a28b27ab03f7926", "filename": "src/tools/miri/build.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbuild.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    // Don't rebuild miri when nothing changed.\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    // Re-export the TARGET environment variable so it can\n+    // be accessed by miri.\n+    let target = std::env::var(\"TARGET\").unwrap();\n+    println!(\"cargo:rustc-env=TARGET={}\", target);\n+}"}, {"sha": "95c2bda505c5bc206c12ad3f749ab59371fcfb7c", "filename": "src/tools/miri/cargo-miri/Cargo.lock", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,554 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"anyhow\"\n+version = \"1.0.51\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8b26702f315f53b6071259e15dd9d64528213b44d61de1ec926eca7715d62203\"\n+\n+[[package]]\n+name = \"autocfg\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"1.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n+\n+[[package]]\n+name = \"camino\"\n+version = \"1.0.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"869119e97797867fd90f5e22af7d0bd274bd4635ebb9eb68c04f3f513ae6c412\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"cargo-miri\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo_metadata\",\n+ \"directories\",\n+ \"rustc-workspace-hack\",\n+ \"rustc_version\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"vergen\",\n+]\n+\n+[[package]]\n+name = \"cargo-platform\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cbdb825da8a5df079a43676dbe042702f1707b1109f713a01420fbb4cc71fa27\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.15.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3abb7553d5b9b8421c6de7cb02606ff15e0c6eea7d8eadd75ef013fd636bec36\"\n+dependencies = [\n+ \"camino\",\n+ \"cargo-platform\",\n+ \"semver\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.72\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"22a9137b95ea06864e018375b72adfb7db6e6f68cfc8df5a04d00288050485ee\"\n+dependencies = [\n+ \"jobserver\",\n+]\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+\n+[[package]]\n+name = \"chrono\"\n+version = \"0.4.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"670ad68c9088c2a963aaa298cb369688cf3f9465ce5e2d4ca10e6e0098a1ce73\"\n+dependencies = [\n+ \"libc\",\n+ \"num-integer\",\n+ \"num-traits\",\n+ \"time\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"directories\"\n+version = \"3.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e69600ff1703123957937708eb27f7a564e48885c537782722ed0ba3189ce1d7\"\n+dependencies = [\n+ \"dirs-sys\",\n+]\n+\n+[[package]]\n+name = \"dirs-sys\"\n+version = \"0.3.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"03d86534ed367a67548dc68113a0f5db55432fdfbb6e6f9d77704397d95d5780\"\n+dependencies = [\n+ \"libc\",\n+ \"redox_users\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"enum-iterator\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4eeac5c5edb79e4e39fe8439ef35207780a11f69c52cbe424ce3dfad4cb78de6\"\n+dependencies = [\n+ \"enum-iterator-derive\",\n+]\n+\n+[[package]]\n+name = \"enum-iterator-derive\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c134c37760b27a871ba422106eedbb8247da973a09e82558bf26d619c882b159\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"form_urlencoded\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5fc25a87fa4fd2094bffb06925852034d90a17f0d1e05197d4956d3555752191\"\n+dependencies = [\n+ \"matches\",\n+ \"percent-encoding\",\n+]\n+\n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n+[[package]]\n+name = \"getset\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e45727250e75cc04ff2846a66397da8ef2b3db8e40e0cef4df67950a07621eb9\"\n+dependencies = [\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"git2\"\n+version = \"0.13.25\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f29229cc1b24c0e6062f6e742aa3e256492a5323365e5ed3413599f8a5eff7d6\"\n+dependencies = [\n+ \"bitflags\",\n+ \"libc\",\n+ \"libgit2-sys\",\n+ \"log\",\n+ \"url\",\n+]\n+\n+[[package]]\n+name = \"idna\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"418a0a6fab821475f634efe3ccc45c013f742efe03d853e8d3355d5cb850ecf8\"\n+dependencies = [\n+ \"matches\",\n+ \"unicode-bidi\",\n+ \"unicode-normalization\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1aab8fc367588b89dcee83ab0fd66b72b50b72fa1904d7095045ace2b0c81c35\"\n+\n+[[package]]\n+name = \"jobserver\"\n+version = \"0.1.24\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"af25a77299a7f711a01975c35a6a424eb6862092cc2d6c72c4ed6cbc56dfc1fa\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.112\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n+\n+[[package]]\n+name = \"libgit2-sys\"\n+version = \"0.12.26+1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"19e1c899248e606fbfe68dcb31d8b0176ebab833b103824af31bddf4b7457494\"\n+dependencies = [\n+ \"cc\",\n+ \"libc\",\n+ \"libz-sys\",\n+ \"pkg-config\",\n+]\n+\n+[[package]]\n+name = \"libz-sys\"\n+version = \"1.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"de5435b8549c16d423ed0c03dbaafe57cf6c3344744f1242520d59c9d8ecec66\"\n+dependencies = [\n+ \"cc\",\n+ \"libc\",\n+ \"pkg-config\",\n+ \"vcpkg\",\n+]\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.4.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"matches\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a3e378b66a060d48947b590737b30a1be76706c8dd7b8ba0f2fe3989c68a853f\"\n+\n+[[package]]\n+name = \"num-integer\"\n+version = \"0.1.44\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d2cc698a63b549a70bc047073d2949cce27cd1c7b0a4a862d08a8031bc2801db\"\n+dependencies = [\n+ \"autocfg\",\n+ \"num-traits\",\n+]\n+\n+[[package]]\n+name = \"num-traits\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9a64b1ec5cda2586e284722486d802acf1f7dbdc623e2bfc57e65ca1cd099290\"\n+dependencies = [\n+ \"autocfg\",\n+]\n+\n+[[package]]\n+name = \"percent-encoding\"\n+version = \"2.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n+\n+[[package]]\n+name = \"pkg-config\"\n+version = \"0.3.24\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"58893f751c9b0412871a09abd62ecd2a00298c6c83befa223ef98c52aef40cbe\"\n+\n+[[package]]\n+name = \"proc-macro-error\"\n+version = \"1.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c\"\n+dependencies = [\n+ \"proc-macro-error-attr\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"version_check\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-error-attr\"\n+version = \"1.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"version_check\",\n+]\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.42\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c278e965f1d8cf32d6e0e96de3d3e79712178ae67986d9cf9151f51e95aac89b\"\n+dependencies = [\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"38bc8cc6a5f2e3655e0899c1b848643b2562f853f114bfec7be120678e3ace05\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.2.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8383f39639269cde97d255a32bdb68c047337295414940c68bdd30c2e13203ff\"\n+dependencies = [\n+ \"bitflags\",\n+]\n+\n+[[package]]\n+name = \"redox_users\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64\"\n+dependencies = [\n+ \"getrandom\",\n+ \"redox_syscall\",\n+]\n+\n+[[package]]\n+name = \"rustc-workspace-hack\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fc71d2faa173b74b232dedc235e3ee1696581bb132fc116fa3626d6151a1a8fb\"\n+\n+[[package]]\n+name = \"rustc_version\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366\"\n+dependencies = [\n+ \"semver\",\n+]\n+\n+[[package]]\n+name = \"rustversion\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f2cc38e8fa666e2de3c4aba7edeb5ffc5246c1c2ed0e3d17e560aeeba736b23f\"\n+\n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"73b4b750c782965c211b42f022f59af1fbceabdd026623714f104152f1ec149f\"\n+\n+[[package]]\n+name = \"semver\"\n+version = \"1.0.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a2333e6df6d6598f2b1974829f853c2b4c5f4a6e503c10af918081aa6f8564e1\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.140\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fc855a42c7967b7c369eb5860f7164ef1f6f81c20c7cc1141f2a604e18723b03\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.140\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6f2122636b9fe3b81f1cb25099fcf2d3f542cdb1d45940d56c713158884a05da\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.82\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"82c2c1fdcd807d1098552c5b9a36e425e42e9fbd7c6a37a8425f390f781f7fa7\"\n+dependencies = [\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.98\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c50aef8a904de4c23c788f104b7dddc7d6f79c647c7c8ce4cc8f73eb0ca773dd\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"thiserror\"\n+version = \"1.0.30\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"854babe52e4df1653706b98fcfc05843010039b406875930a70e4d9644e5c417\"\n+dependencies = [\n+ \"thiserror-impl\",\n+]\n+\n+[[package]]\n+name = \"thiserror-impl\"\n+version = \"1.0.30\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aa32fd3f627f367fe16f893e2597ae3c05020f8bba2666a4e6ea73d377e5714b\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"time\"\n+version = \"0.1.43\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca8a50ef2360fbd1eeb0ecd46795a87a19024eb4b53c5dc916ca1fd95fe62438\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"tinyvec\"\n+version = \"1.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2c1c1d5a42b6245520c249549ec267180beaffcc0615401ac8e31853d4b6d8d2\"\n+dependencies = [\n+ \"tinyvec_macros\",\n+]\n+\n+[[package]]\n+name = \"tinyvec_macros\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c\"\n+\n+[[package]]\n+name = \"unicode-bidi\"\n+version = \"0.3.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1a01404663e3db436ed2746d9fefef640d868edae3cceb81c3b8d5732fda678f\"\n+\n+[[package]]\n+name = \"unicode-ident\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"15c61ba63f9235225a22310255a29b806b907c9b8c964bcbd0a2c70f3f2deea7\"\n+\n+[[package]]\n+name = \"unicode-normalization\"\n+version = \"0.1.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d54590932941a9e9266f0832deed84ebe1bf2e4c9e4a3554d393d18f5e854bf9\"\n+dependencies = [\n+ \"tinyvec\",\n+]\n+\n+[[package]]\n+name = \"url\"\n+version = \"2.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a507c383b2d33b5fc35d1861e77e6b383d158b2da5e14fe51b83dfedf6fd578c\"\n+dependencies = [\n+ \"form_urlencoded\",\n+ \"idna\",\n+ \"matches\",\n+ \"percent-encoding\",\n+]\n+\n+[[package]]\n+name = \"vcpkg\"\n+version = \"0.2.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426\"\n+\n+[[package]]\n+name = \"vergen\"\n+version = \"5.1.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6cf88d94e969e7956d924ba70741316796177fa0c79a2c9f4ab04998d96e966e\"\n+dependencies = [\n+ \"anyhow\",\n+ \"cfg-if\",\n+ \"chrono\",\n+ \"enum-iterator\",\n+ \"getset\",\n+ \"git2\",\n+ \"rustversion\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"version_check\"\n+version = \"0.9.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5fecdca9a5291cc2b8dcf7dc02453fee791a280f3743cb0905f8822ae463b3fe\"\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.10.2+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\""}, {"sha": "9ac170c5b5377588611d9f1a9f032c6035e9f310", "filename": "src/tools/miri/cargo-miri/Cargo.toml", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,32 @@\n+[package]\n+authors = [\"Miri Team\"]\n+description = \"An experimental interpreter for Rust MIR (cargo wrapper).\"\n+license = \"MIT OR Apache-2.0\"\n+name = \"cargo-miri\"\n+repository = \"https://github.com/rust-lang/miri\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[[bin]]\n+name = \"cargo-miri\"\n+path = \"src/main.rs\"\n+test = false # we have no unit tests\n+doctest = false # and no doc tests\n+\n+[dependencies]\n+directories = \"3\"\n+rustc_version = \"0.4\"\n+serde_json = \"1.0.40\"\n+cargo_metadata = \"0.15.0\"\n+\n+# A noop dependency that changes in the Rust repository, it's a bit of a hack.\n+# See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n+# for more information.\n+rustc-workspace-hack = \"1.0.0\"\n+\n+# Enable some feature flags that dev-dependencies need but dependencies\n+# do not.  This makes `./miri install` after `./miri build` faster.\n+serde = { version = \"*\", features = [\"derive\"] }\n+\n+[build-dependencies]\n+vergen = { version = \"5\", default_features = false, features = [\"git\"] }"}, {"sha": "ebd8e7003d5f72c70cc5a0992258f291c9cc4a99", "filename": "src/tools/miri/cargo-miri/build.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fbuild.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,11 @@\n+use vergen::vergen;\n+\n+fn main() {\n+    // Don't rebuild miri when nothing changed.\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    // vergen\n+    let mut gen_config = vergen::Config::default();\n+    *gen_config.git_mut().sha_kind_mut() = vergen::ShaKind::Short;\n+    *gen_config.git_mut().commit_timestamp_kind_mut() = vergen::TimestampKind::DateOnly;\n+    vergen(gen_config).ok(); // Ignore failure (in case we are built outside a git repo)\n+}"}, {"sha": "cf3ad06788ab1311b9c98f7df8c08431f64370f7", "filename": "src/tools/miri/cargo-miri/miri", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fmiri?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,4 @@\n+#!/bin/sh\n+# RA invokes `./miri cargo ...` for each workspace, so we need to forward that to the main `miri`\n+# script. See <https://github.com/rust-analyzer/rust-analyzer/issues/10793>.\n+exec \"$(dirname \"$0\")\"/../miri \"$@\""}, {"sha": "e8bac4625f71053d0784513a8f32821a2cdcdf20", "filename": "src/tools/miri/cargo-miri/src/arg.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Farg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Farg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Farg.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,134 @@\n+//! Utilities for dealing with argument flags\n+\n+use std::borrow::Cow;\n+use std::env;\n+\n+/// Determines whether a `--flag` is present.\n+pub fn has_arg_flag(name: &str) -> bool {\n+    num_arg_flag(name) > 0\n+}\n+\n+/// Determines how many times a `--flag` is present.\n+pub fn num_arg_flag(name: &str) -> usize {\n+    env::args().take_while(|val| val != \"--\").filter(|val| val == name).count()\n+}\n+\n+/// Yields all values of command line flag `name` as `Ok(arg)`, and all other arguments except\n+/// the flag as `Err(arg)`. (The flag `name` itself is not yielded at all, only its values are.)\n+pub struct ArgSplitFlagValue<'a, I> {\n+    args: Option<I>,\n+    name: &'a str,\n+}\n+\n+impl<'a, I: Iterator> ArgSplitFlagValue<'a, I> {\n+    fn new(args: I, name: &'a str) -> Self {\n+        Self { args: Some(args), name }\n+    }\n+}\n+\n+impl<'s, I: Iterator<Item = Cow<'s, str>>> Iterator for ArgSplitFlagValue<'_, I> {\n+    // If the original iterator was all `Owned`, then we will only ever yield `Owned`\n+    // (so `into_owned()` is cheap).\n+    type Item = Result<Cow<'s, str>, Cow<'s, str>>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let Some(args) = self.args.as_mut() else {\n+            // We already canceled this iterator.\n+            return None;\n+        };\n+        let arg = args.next()?;\n+        if arg == \"--\" {\n+            // Stop searching at `--`.\n+            self.args = None;\n+            return None;\n+        }\n+        // These branches cannot be merged if we want to avoid the allocation in the `Borrowed` branch.\n+        match &arg {\n+            Cow::Borrowed(arg) =>\n+                if let Some(suffix) = arg.strip_prefix(self.name) {\n+                    // Strip leading `name`.\n+                    if suffix.is_empty() {\n+                        // This argument is exactly `name`; the next one is the value.\n+                        return args.next().map(Ok);\n+                    } else if let Some(suffix) = suffix.strip_prefix('=') {\n+                        // This argument is `name=value`; get the value.\n+                        return Some(Ok(Cow::Borrowed(suffix)));\n+                    }\n+                },\n+            Cow::Owned(arg) =>\n+                if let Some(suffix) = arg.strip_prefix(self.name) {\n+                    // Strip leading `name`.\n+                    if suffix.is_empty() {\n+                        // This argument is exactly `name`; the next one is the value.\n+                        return args.next().map(Ok);\n+                    } else if let Some(suffix) = suffix.strip_prefix('=') {\n+                        // This argument is `name=value`; get the value. We need to do an allocation\n+                        // here as a `String` cannot be subsliced (what would the lifetime be?).\n+                        return Some(Ok(Cow::Owned(suffix.to_owned())));\n+                    }\n+                },\n+        }\n+        Some(Err(arg))\n+    }\n+}\n+\n+impl<'a, I: Iterator<Item = String> + 'a> ArgSplitFlagValue<'a, I> {\n+    pub fn from_string_iter(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = Result<String, String>> + 'a {\n+        ArgSplitFlagValue::new(args.map(Cow::Owned), name).map(|x| {\n+            match x {\n+                Ok(Cow::Owned(s)) => Ok(s),\n+                Err(Cow::Owned(s)) => Err(s),\n+                _ => panic!(\"iterator converted owned to borrowed\"),\n+            }\n+        })\n+    }\n+}\n+\n+impl<'x: 'a, 'a, I: Iterator<Item = &'x str> + 'a> ArgSplitFlagValue<'a, I> {\n+    pub fn from_str_iter(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = Result<&'x str, &'x str>> + 'a {\n+        ArgSplitFlagValue::new(args.map(Cow::Borrowed), name).map(|x| {\n+            match x {\n+                Ok(Cow::Borrowed(s)) => Ok(s),\n+                Err(Cow::Borrowed(s)) => Err(s),\n+                _ => panic!(\"iterator converted borrowed to owned\"),\n+            }\n+        })\n+    }\n+}\n+\n+/// Yields all values of command line flag `name`.\n+pub struct ArgFlagValueIter;\n+\n+impl ArgFlagValueIter {\n+    pub fn from_string_iter<'a, I: Iterator<Item = String> + 'a>(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = String> + 'a {\n+        ArgSplitFlagValue::from_string_iter(args, name).filter_map(Result::ok)\n+    }\n+}\n+\n+impl ArgFlagValueIter {\n+    pub fn from_str_iter<'x: 'a, 'a, I: Iterator<Item = &'x str> + 'a>(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = &'x str> + 'a {\n+        ArgSplitFlagValue::from_str_iter(args, name).filter_map(Result::ok)\n+    }\n+}\n+\n+/// Gets the values of a `--flag`.\n+pub fn get_arg_flag_values(name: &str) -> impl Iterator<Item = String> + '_ {\n+    ArgFlagValueIter::from_string_iter(env::args(), name)\n+}\n+\n+/// Gets the value of a `--flag`.\n+pub fn get_arg_flag_value(name: &str) -> Option<String> {\n+    get_arg_flag_values(name).next()\n+}"}, {"sha": "331c4c9c2b0e7ecbbe9acbd1b1950c526bea19da", "filename": "src/tools/miri/cargo-miri/src/main.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,97 @@\n+#![allow(clippy::useless_format, clippy::derive_partial_eq_without_eq, rustc::internal)]\n+\n+#[macro_use]\n+mod util;\n+\n+mod arg;\n+mod phases;\n+mod setup;\n+mod version;\n+\n+use std::{env, iter};\n+\n+use crate::phases::*;\n+\n+fn main() {\n+    // Rustc does not support non-UTF-8 arguments so we make no attempt either.\n+    // (We do support non-UTF-8 environment variables though.)\n+    let mut args = std::env::args();\n+    // Skip binary name.\n+    args.next().unwrap();\n+\n+    // Dispatch to `cargo-miri` phase. Here is a rough idea of \"who calls who\".\n+    //\n+    // Initially, we are invoked as `cargo-miri miri run/test`. We first run the setup phase:\n+    // - We call `xargo`, and set `RUSTC` back to us, together with `MIRI_CALLED_FROM_XARGO`,\n+    //   so that xargo's rustc invocations end up in `phase_rustc` with `RustcPhase::Setup`.\n+    //   There we then call the Miri driver with `MIRI_BE_RUSTC` to perform the actual build.\n+    //\n+    // Then we call `cargo run/test`, exactly forwarding all user flags, plus some configuration so\n+    // that we control every binary invoked by cargo:\n+    // - We set RUSTC_WRAPPER to ourselves, so for (almost) all rustc invocations, we end up in\n+    //   `phase_rustc` with `RustcPhase::Build`. This will in turn either determine that a\n+    //   dependency needs to be built (for which it invokes the Miri driver with `MIRI_BE_RUSTC`),\n+    //   or determine that this is a binary Miri should run, in which case we generate a JSON file\n+    //   with all the information needed to build and run this crate.\n+    //   (We don't run it yet since cargo thinks this is a build step, not a run step -- running the\n+    //   binary here would lead to a bad user experience.)\n+    // - We set RUSTC to the Miri driver and also set `MIRI_BE_RUSTC`, so that gets called by build\n+    //   scripts (and cargo uses it for the version query).\n+    // - We set `target.*.runner` to `cargo-miri runner`, which ends up calling `phase_runner` for\n+    //   `RunnerPhase::Cargo`. This parses the JSON file written in `phase_rustc` and then invokes\n+    //   the actual Miri driver for interpretation.\n+    // - We set RUSTDOC to ourselves, which ends up in `phase_rustdoc`. There we call regular\n+    //   rustdoc with some extra flags, and we set `MIRI_CALLED_FROM_RUSTDOC` to recognize this\n+    //   phase in our recursive invocations:\n+    //   - We set the `--test-builder` flag of rustdoc to ourselves, which ends up in `phase_rustc`\n+    //     with `RustcPhase::Rustdoc`. There we perform a check-build (needed to get the expected\n+    //     build failures for `compile_fail` doctests) and then store a JSON file with the\n+    //     information needed to run this test.\n+    //   - We also set `--runtool` to ourselves, which ends up in `phase_runner` with\n+    //     `RunnerPhase::Rustdoc`. There we parse the JSON file written in `phase_rustc` and invoke\n+    //     the Miri driver for interpretation.\n+\n+    // Dispatch running as part of sysroot compilation.\n+    if env::var_os(\"MIRI_CALLED_FROM_XARGO\").is_some() {\n+        phase_rustc(args, RustcPhase::Setup);\n+        return;\n+    }\n+\n+    // The way rustdoc invokes rustc is indistuingishable from the way cargo invokes rustdoc by the\n+    // arguments alone. `phase_cargo_rustdoc` sets this environment variable to let us disambiguate.\n+    if env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some() {\n+        // ...however, we then also see this variable when rustdoc invokes us as the testrunner!\n+        // The runner is invoked as `$runtool ($runtool-arg)* output_file`;\n+        // since we don't specify any runtool-args, and rustdoc supplies multiple arguments to\n+        // the test-builder unconditionally, we can just check the number of remaining arguments:\n+        if args.len() == 1 {\n+            phase_runner(args, RunnerPhase::Rustdoc);\n+        } else {\n+            phase_rustc(args, RustcPhase::Rustdoc);\n+        }\n+\n+        return;\n+    }\n+\n+    let Some(first) = args.next() else {\n+        show_error!(\n+            \"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\"\n+        )\n+    };\n+    match first.as_str() {\n+        \"miri\" => phase_cargo_miri(args),\n+        \"runner\" => phase_runner(args, RunnerPhase::Cargo),\n+        arg if arg == env::var(\"RUSTC\").unwrap() => {\n+            // If the first arg is equal to the RUSTC env ariable (which should be set at this\n+            // point), then we need to behave as rustc. This is the somewhat counter-intuitive\n+            // behavior of having both RUSTC and RUSTC_WRAPPER set\n+            // (see https://github.com/rust-lang/cargo/issues/10886).\n+            phase_rustc(args, RustcPhase::Build)\n+        }\n+        _ => {\n+            // Everything else must be rustdoc. But we need to get `first` \"back onto the iterator\",\n+            // it is some part of the rustdoc invocation.\n+            phase_rustdoc(iter::once(first).chain(args));\n+        }\n+    }\n+}"}, {"sha": "93eb3cb174659c7d8337f67be296971a59886169", "filename": "src/tools/miri/cargo-miri/src/phases.rs", "status": "added", "additions": 601, "deletions": 0, "changes": 601, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,601 @@\n+//! Implements the various phases of `cargo miri run/test`.\n+\n+use std::env;\n+use std::fmt::Write as _;\n+use std::fs::{self, File};\n+use std::io::BufReader;\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+use crate::{setup::*, util::*};\n+\n+const CARGO_MIRI_HELP: &str = r#\"Runs binary crates and tests in Miri\n+\n+Usage:\n+    cargo miri [subcommand] [<cargo options>...] [--] [<program/test suite options>...]\n+\n+Subcommands:\n+    run, r                   Run binaries\n+    test, t                  Run tests\n+    nextest                  Run tests with nextest (requires cargo-nextest installed)\n+    setup                    Only perform automatic setup, but without asking questions (for getting a proper libstd)\n+\n+The cargo options are exactly the same as for `cargo run` and `cargo test`, respectively.\n+\n+Examples:\n+    cargo miri run\n+    cargo miri test -- test-suite-filter\n+\n+    cargo miri setup --print sysroot\n+        This will print the path to the generated sysroot (and nothing else) on stdout.\n+        stderr will still contain progress information about how the build is doing.\n+\n+\"#;\n+\n+fn show_help() {\n+    println!(\"{}\", CARGO_MIRI_HELP);\n+}\n+\n+fn show_version() {\n+    let mut version = format!(\"miri {}\", env!(\"CARGO_PKG_VERSION\"));\n+    // Only use `option_env` on vergen variables to ensure the build succeeds\n+    // when vergen failed to find the git info.\n+    if let Some(sha) = option_env!(\"VERGEN_GIT_SHA_SHORT\") {\n+        // This `unwrap` can never fail because if VERGEN_GIT_SHA_SHORT exists, then so does\n+        // VERGEN_GIT_COMMIT_DATE.\n+        #[allow(clippy::option_env_unwrap)]\n+        write!(&mut version, \" ({} {})\", sha, option_env!(\"VERGEN_GIT_COMMIT_DATE\").unwrap())\n+            .unwrap();\n+    }\n+    println!(\"{}\", version);\n+}\n+\n+fn forward_patched_extern_arg(args: &mut impl Iterator<Item = String>, cmd: &mut Command) {\n+    cmd.arg(\"--extern\"); // always forward flag, but adjust filename:\n+    let path = args.next().expect(\"`--extern` should be followed by a filename\");\n+    if let Some(lib) = path.strip_suffix(\".rlib\") {\n+        // If this is an rlib, make it an rmeta.\n+        cmd.arg(format!(\"{}.rmeta\", lib));\n+    } else {\n+        // Some other extern file (e.g. a `.so`). Forward unchanged.\n+        cmd.arg(path);\n+    }\n+}\n+\n+pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n+    // Check for version and help flags even when invoked as `cargo-miri`.\n+    if has_arg_flag(\"--help\") || has_arg_flag(\"-h\") {\n+        show_help();\n+        return;\n+    }\n+    if has_arg_flag(\"--version\") || has_arg_flag(\"-V\") {\n+        show_version();\n+        return;\n+    }\n+\n+    // Require a subcommand before any flags.\n+    // We cannot know which of those flags take arguments and which do not,\n+    // so we cannot detect subcommands later.\n+    let Some(subcommand) = args.next() else {\n+        show_error!(\"`cargo miri` needs to be called with a subcommand (`run`, `test`)\");\n+    };\n+    let subcommand = match &*subcommand {\n+        \"setup\" => MiriCommand::Setup,\n+        \"test\" | \"t\" | \"run\" | \"r\" | \"nextest\" => MiriCommand::Forward(subcommand),\n+        _ =>\n+            show_error!(\n+                \"`cargo miri` supports the following subcommands: `run`, `test`, `nextest`, and `setup`.\"\n+            ),\n+    };\n+    let verbose = num_arg_flag(\"-v\");\n+\n+    // Determine the involved architectures.\n+    let host = version_info().host;\n+    let target = get_arg_flag_value(\"--target\");\n+    let target = target.as_ref().unwrap_or(&host);\n+\n+    // We always setup.\n+    setup(&subcommand, &host, target);\n+\n+    // Invoke actual cargo for the job, but with different flags.\n+    // We re-use `cargo test` and `cargo run`, which makes target and binary handling very easy but\n+    // requires some extra work to make the build check-only (see all the `--emit` hacks below).\n+    // <https://github.com/rust-lang/miri/pull/1540#issuecomment-693553191> describes an alternative\n+    // approach that uses `cargo check`, making that part easier but target and binary handling\n+    // harder.\n+    let cargo_miri_path = std::env::current_exe()\n+        .expect(\"current executable path invalid\")\n+        .into_os_string()\n+        .into_string()\n+        .expect(\"current executable path is not valid UTF-8\");\n+    let cargo_cmd = match subcommand {\n+        MiriCommand::Forward(s) => s,\n+        MiriCommand::Setup => return, // `cargo miri setup` stops here.\n+    };\n+    let metadata = get_cargo_metadata();\n+    let mut cmd = cargo();\n+    cmd.arg(cargo_cmd);\n+\n+    // Forward all arguments before `--` other than `--target-dir` and its value to Cargo.\n+    // (We want to *change* the target-dir value, so we must not forward it.)\n+    let mut target_dir = None;\n+    for arg in ArgSplitFlagValue::from_string_iter(&mut args, \"--target-dir\") {\n+        match arg {\n+            Ok(value) => {\n+                if target_dir.is_some() {\n+                    show_error!(\"`--target-dir` is provided more than once\");\n+                }\n+                target_dir = Some(value.into());\n+            }\n+            Err(arg) => {\n+                cmd.arg(arg);\n+            }\n+        }\n+    }\n+    // Detect the target directory if it's not specified via `--target-dir`.\n+    // (`cargo metadata` does not support `--target-dir`, that's why we have to handle this ourselves.)\n+    let target_dir = target_dir.get_or_insert_with(|| metadata.target_directory.clone());\n+    // Set `--target-dir` to `miri` inside the original target directory.\n+    target_dir.push(\"miri\");\n+    cmd.arg(\"--target-dir\").arg(target_dir);\n+\n+    // Make sure the build target is explicitly set.\n+    // This is needed to make the `target.runner` settings do something,\n+    // and it later helps us detect which crates are proc-macro/build-script\n+    // (host crates) and which crates are needed for the program itself.\n+    if get_arg_flag_value(\"--target\").is_none() {\n+        // No target given. Explicitly pick the host.\n+        cmd.arg(\"--target\");\n+        cmd.arg(&host);\n+    }\n+\n+    // Set ourselves as runner for al binaries invoked by cargo.\n+    // We use `all()` since `true` is not a thing in cfg-lang, but the empty conjunction is. :)\n+    let cargo_miri_path_for_toml = escape_for_toml(&cargo_miri_path);\n+    cmd.arg(\"--config\")\n+        .arg(format!(\"target.'cfg(all())'.runner=[{cargo_miri_path_for_toml}, 'runner']\"));\n+\n+    // Forward all further arguments after `--` to cargo.\n+    cmd.arg(\"--\").args(args);\n+\n+    // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n+    // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n+    // the two codepaths. (That extra argument is why we prefer this over setting `RUSTC`.)\n+    if env::var_os(\"RUSTC_WRAPPER\").is_some() {\n+        println!(\n+            \"WARNING: Ignoring `RUSTC_WRAPPER` environment variable, Miri does not support wrapping.\"\n+        );\n+    }\n+    cmd.env(\"RUSTC_WRAPPER\", &cargo_miri_path);\n+    // We are going to invoke `MIRI` for everything, not `RUSTC`.\n+    if env::var_os(\"RUSTC\").is_some() && env::var_os(\"MIRI\").is_none() {\n+        println!(\n+            \"WARNING: Ignoring `RUSTC` environment variable; set `MIRI` if you want to control the binary used as the driver.\"\n+        );\n+    }\n+    // Build scripts (and also cargo: https://github.com/rust-lang/cargo/issues/10885) will invoke\n+    // `rustc` even when `RUSTC_WRAPPER` is set. To make sure everything is coherent, we want that\n+    // to be the Miri driver, but acting as rustc, on the target level. (Target, rather than host,\n+    // is needed for cross-interpretation situations.) This is not a perfect emulation of real rustc\n+    // (it might be unable to produce binaries since the sysroot is check-only), but it's as close\n+    // as we can get, and it's good enough for autocfg.\n+    //\n+    // In `main`, we need the value of `RUSTC` to distinguish RUSTC_WRAPPER invocations from rustdoc\n+    // or TARGET_RUNNER invocations, so we canonicalize it here to make it exceedingly unlikely that\n+    // there would be a collision with other invocations of cargo-miri (as rustdoc or as runner). We\n+    // explicitly do this even if RUSTC_STAGE is set, since for these builds we do *not* want the\n+    // bootstrap `rustc` thing in our way! Instead, we have MIRI_HOST_SYSROOT to use for host\n+    // builds.\n+    cmd.env(\"RUSTC\", &fs::canonicalize(find_miri()).unwrap());\n+    cmd.env(\"MIRI_BE_RUSTC\", \"target\"); // we better remember to *unset* this in the other phases!\n+\n+    // Set rustdoc to us as well, so we can run doctests.\n+    cmd.env(\"RUSTDOC\", &cargo_miri_path);\n+\n+    cmd.env(\"MIRI_LOCAL_CRATES\", local_crates(&metadata));\n+    if verbose > 0 {\n+        cmd.env(\"MIRI_VERBOSE\", verbose.to_string()); // This makes the other phases verbose.\n+    }\n+\n+    // Run cargo.\n+    debug_cmd(\"[cargo-miri miri]\", verbose, &cmd);\n+    exec(cmd)\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+pub enum RustcPhase {\n+    /// `rustc` called via `xargo` for sysroot build.\n+    Setup,\n+    /// `rustc` called by `cargo` for regular build.\n+    Build,\n+    /// `rustc` called by `rustdoc` for doctest.\n+    Rustdoc,\n+}\n+\n+pub fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n+    /// Determines if we are being invoked (as rustc) to build a crate for\n+    /// the \"target\" architecture, in contrast to the \"host\" architecture.\n+    /// Host crates are for build scripts and proc macros and still need to\n+    /// be built like normal; target crates need to be built for or interpreted\n+    /// by Miri.\n+    ///\n+    /// Currently, we detect this by checking for \"--target=\", which is\n+    /// never set for host crates. This matches what rustc bootstrap does,\n+    /// which hopefully makes it \"reliable enough\". This relies on us always\n+    /// invoking cargo itself with `--target`, which `in_cargo_miri` ensures.\n+    fn is_target_crate() -> bool {\n+        get_arg_flag_value(\"--target\").is_some()\n+    }\n+\n+    /// Returns whether or not Cargo invoked the wrapper (this binary) to compile\n+    /// the final, binary crate (either a test for 'cargo test', or a binary for 'cargo run')\n+    /// Cargo does not give us this information directly, so we need to check\n+    /// various command-line flags.\n+    fn is_runnable_crate() -> bool {\n+        let is_bin = get_arg_flag_value(\"--crate-type\").as_deref().unwrap_or(\"bin\") == \"bin\";\n+        let is_test = has_arg_flag(\"--test\");\n+        is_bin || is_test\n+    }\n+\n+    fn out_filename(prefix: &str, suffix: &str) -> PathBuf {\n+        if let Some(out_dir) = get_arg_flag_value(\"--out-dir\") {\n+            let mut path = PathBuf::from(out_dir);\n+            path.push(format!(\n+                \"{}{}{}{}\",\n+                prefix,\n+                get_arg_flag_value(\"--crate-name\").unwrap(),\n+                // This is technically a `-C` flag but the prefix seems unique enough...\n+                // (and cargo passes this before the filename so it should be unique)\n+                get_arg_flag_value(\"extra-filename\").unwrap_or_default(),\n+                suffix,\n+            ));\n+            path\n+        } else {\n+            let out_file = get_arg_flag_value(\"-o\").unwrap();\n+            PathBuf::from(out_file)\n+        }\n+    }\n+\n+    // phase_cargo_miri set `MIRI_BE_RUSTC` for when build scripts directly invoke the driver;\n+    // however, if we get called back by cargo here, we'll carefully compute the right flags\n+    // ourselves, so we first un-do what the earlier phase did.\n+    env::remove_var(\"MIRI_BE_RUSTC\");\n+\n+    let verbose = std::env::var(\"MIRI_VERBOSE\")\n+        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n+    let target_crate = is_target_crate();\n+    // Determine whether this is cargo/xargo invoking rustc to get some infos.\n+    let info_query = get_arg_flag_value(\"--print\").is_some() || has_arg_flag(\"-vV\");\n+\n+    let store_json = |info: CrateRunInfo| {\n+        // Create a stub .d file to stop Cargo from \"rebuilding\" the crate:\n+        // https://github.com/rust-lang/miri/issues/1724#issuecomment-787115693\n+        // As we store a JSON file instead of building the crate here, an empty file is fine.\n+        let dep_info_name = out_filename(\"\", \".d\");\n+        if verbose > 0 {\n+            eprintln!(\"[cargo-miri rustc] writing stub dep-info to `{}`\", dep_info_name.display());\n+        }\n+        File::create(dep_info_name).expect(\"failed to create fake .d file\");\n+\n+        let filename = out_filename(\"\", \"\");\n+        if verbose > 0 {\n+            eprintln!(\"[cargo-miri rustc] writing run info to `{}`\", filename.display());\n+        }\n+        info.store(&filename);\n+        // For Windows, do the same thing again with `.exe` appended to the filename.\n+        // (Need to do this here as cargo moves that \"binary\" to a different place before running it.)\n+        info.store(&out_filename(\"\", \".exe\"));\n+    };\n+\n+    let runnable_crate = !info_query && is_runnable_crate();\n+\n+    if runnable_crate && target_crate {\n+        assert!(\n+            phase != RustcPhase::Setup,\n+            \"there should be no interpretation during sysroot build\"\n+        );\n+        let inside_rustdoc = phase == RustcPhase::Rustdoc;\n+        // This is the binary or test crate that we want to interpret under Miri.\n+        // But we cannot run it here, as cargo invoked us as a compiler -- our stdin and stdout are not\n+        // like we want them.\n+        // Instead of compiling, we write JSON into the output file with all the relevant command-line flags\n+        // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n+        let env = CrateRunEnv::collect(args, inside_rustdoc);\n+\n+        store_json(CrateRunInfo::RunWith(env.clone()));\n+\n+        // Rustdoc expects us to exit with an error code if the test is marked as `compile_fail`,\n+        // just creating the JSON file is not enough: we need to detect syntax errors,\n+        // so we need to run Miri with `MIRI_BE_RUSTC` for a check-only build.\n+        if inside_rustdoc {\n+            let mut cmd = miri();\n+\n+            // Ensure --emit argument for a check-only build is present.\n+            if let Some(val) =\n+                ArgFlagValueIter::from_str_iter(env.args.iter().map(|s| s as &str), \"--emit\").next()\n+            {\n+                // For `no_run` tests, rustdoc passes a `--emit` flag; make sure it has the right shape.\n+                assert_eq!(val, \"metadata\");\n+            } else {\n+                // For all other kinds of tests, we can just add our flag.\n+                cmd.arg(\"--emit=metadata\");\n+            }\n+\n+            // Alter the `-o` parameter so that it does not overwrite the JSON file we stored above.\n+            let mut args = env.args;\n+            for i in 0..args.len() {\n+                if args[i] == \"-o\" {\n+                    args[i + 1].push_str(\".miri\");\n+                }\n+            }\n+\n+            cmd.args(&args);\n+            cmd.env(\"MIRI_BE_RUSTC\", \"target\");\n+\n+            if verbose > 0 {\n+                eprintln!(\n+                    \"[cargo-miri rustc inside rustdoc] captured input:\\n{}\",\n+                    std::str::from_utf8(&env.stdin).unwrap()\n+                );\n+                eprintln!(\"[cargo-miri rustc inside rustdoc] going to run:\\n{:?}\", cmd);\n+            }\n+\n+            exec_with_pipe(cmd, &env.stdin, format!(\"{}.stdin\", out_filename(\"\", \"\").display()));\n+        }\n+\n+        return;\n+    }\n+\n+    if runnable_crate && get_arg_flag_values(\"--extern\").any(|krate| krate == \"proc_macro\") {\n+        // This is a \"runnable\" `proc-macro` crate (unit tests). We do not support\n+        // interpreting that under Miri now, so we write a JSON file to (display a\n+        // helpful message and) skip it in the runner phase.\n+        store_json(CrateRunInfo::SkipProcMacroTest);\n+        return;\n+    }\n+\n+    let mut cmd = miri();\n+    let mut emit_link_hack = false;\n+    // Arguments are treated very differently depending on whether this crate is\n+    // for interpretation by Miri, or for use by a build script / proc macro.\n+    if !info_query && target_crate {\n+        // Forward arguments, but remove \"link\" from \"--emit\" to make this a check-only build.\n+        let emit_flag = \"--emit\";\n+        while let Some(arg) = args.next() {\n+            if let Some(val) = arg.strip_prefix(emit_flag) {\n+                // Patch this argument. First, extract its value.\n+                let val =\n+                    val.strip_prefix('=').expect(\"`cargo` should pass `--emit=X` as one argument\");\n+                let mut val: Vec<_> = val.split(',').collect();\n+                // Now make sure \"link\" is not in there, but \"metadata\" is.\n+                if let Some(i) = val.iter().position(|&s| s == \"link\") {\n+                    emit_link_hack = true;\n+                    val.remove(i);\n+                    if !val.iter().any(|&s| s == \"metadata\") {\n+                        val.push(\"metadata\");\n+                    }\n+                }\n+                cmd.arg(format!(\"{}={}\", emit_flag, val.join(\",\")));\n+            } else if arg == \"--extern\" {\n+                // Patch `--extern` filenames, since Cargo sometimes passes stub `.rlib` files:\n+                // https://github.com/rust-lang/miri/issues/1705\n+                forward_patched_extern_arg(&mut args, &mut cmd);\n+            } else {\n+                cmd.arg(arg);\n+            }\n+        }\n+\n+        // During setup, patch the panic runtime for `libpanic_abort` (mirroring what bootstrap usually does).\n+        if phase == RustcPhase::Setup\n+            && get_arg_flag_value(\"--crate-name\").as_deref() == Some(\"panic_abort\")\n+        {\n+            cmd.arg(\"-C\").arg(\"panic=abort\");\n+        }\n+    } else {\n+        // For host crates (but not when we are just printing some info),\n+        // we might still have to set the sysroot.\n+        if !info_query {\n+            // When we're running `cargo-miri` from `x.py` we need to pass the sysroot explicitly\n+            // due to bootstrap complications.\n+            if let Some(sysroot) = std::env::var_os(\"MIRI_HOST_SYSROOT\") {\n+                cmd.arg(\"--sysroot\").arg(sysroot);\n+            }\n+        }\n+\n+        // For host crates or when we are printing, just forward everything.\n+        cmd.args(args);\n+    }\n+\n+    // We want to compile, not interpret. We still use Miri to make sure the compiler version etc\n+    // are the exact same as what is used for interpretation.\n+    // MIRI_DEFAULT_ARGS should not be used to build host crates, hence setting \"target\" or \"host\"\n+    // as the value here to help Miri differentiate them.\n+    cmd.env(\"MIRI_BE_RUSTC\", if target_crate { \"target\" } else { \"host\" });\n+\n+    // Run it.\n+    if verbose > 0 {\n+        eprintln!(\n+            \"[cargo-miri rustc] target_crate={target_crate} runnable_crate={runnable_crate} info_query={info_query}\"\n+        );\n+    }\n+\n+    // Create a stub .rlib file if \"link\" was requested by cargo.\n+    // This is necessary to prevent cargo from doing rebuilds all the time.\n+    if emit_link_hack {\n+        // Some platforms prepend \"lib\", some do not... let's just create both files.\n+        File::create(out_filename(\"lib\", \".rlib\")).expect(\"failed to create fake .rlib file\");\n+        File::create(out_filename(\"\", \".rlib\")).expect(\"failed to create fake .rlib file\");\n+        // Just in case this is a cdylib or staticlib, also create those fake files.\n+        File::create(out_filename(\"lib\", \".so\")).expect(\"failed to create fake .so file\");\n+        File::create(out_filename(\"lib\", \".a\")).expect(\"failed to create fake .a file\");\n+        File::create(out_filename(\"lib\", \".dylib\")).expect(\"failed to create fake .dylib file\");\n+        File::create(out_filename(\"\", \".dll\")).expect(\"failed to create fake .dll file\");\n+        File::create(out_filename(\"\", \".lib\")).expect(\"failed to create fake .lib file\");\n+    }\n+\n+    debug_cmd(\"[cargo-miri rustc]\", verbose, &cmd);\n+    exec(cmd);\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+pub enum RunnerPhase {\n+    /// `cargo` is running a binary\n+    Cargo,\n+    /// `rustdoc` is running a binary\n+    Rustdoc,\n+}\n+\n+pub fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: RunnerPhase) {\n+    // phase_cargo_miri set `MIRI_BE_RUSTC` for when build scripts directly invoke the driver;\n+    // however, if we get called back by cargo here, we'll carefully compute the right flags\n+    // ourselves, so we first un-do what the earlier phase did.\n+    env::remove_var(\"MIRI_BE_RUSTC\");\n+\n+    let verbose = std::env::var(\"MIRI_VERBOSE\")\n+        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n+\n+    let binary = binary_args.next().unwrap();\n+    let file = File::open(&binary)\n+        .unwrap_or_else(|_| show_error!(\n+            \"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary\n+        ));\n+    let file = BufReader::new(file);\n+\n+    let info = serde_json::from_reader(file).unwrap_or_else(|_| {\n+        show_error!(\"file {:?} contains outdated or invalid JSON; try `cargo clean`\", binary)\n+    });\n+    let info = match info {\n+        CrateRunInfo::RunWith(info) => info,\n+        CrateRunInfo::SkipProcMacroTest => {\n+            eprintln!(\n+                \"Running unit tests of `proc-macro` crates is not currently supported by Miri.\"\n+            );\n+            return;\n+        }\n+    };\n+\n+    let mut cmd = miri();\n+\n+    // Set missing env vars. We prefer build-time env vars over run-time ones; see\n+    // <https://github.com/rust-lang/miri/issues/1661> for the kind of issue that fixes.\n+    for (name, val) in info.env {\n+        if let Some(old_val) = env::var_os(&name) {\n+            if old_val == val {\n+                // This one did not actually change, no need to re-set it.\n+                // (This keeps the `debug_cmd` below more manageable.)\n+                continue;\n+            } else if verbose > 0 {\n+                eprintln!(\n+                    \"[cargo-miri runner] Overwriting run-time env var {:?}={:?} with build-time value {:?}\",\n+                    name, old_val, val\n+                );\n+            }\n+        }\n+        cmd.env(name, val);\n+    }\n+\n+    // Forward rustc arguments.\n+    // We need to patch \"--extern\" filenames because we forced a check-only\n+    // build without cargo knowing about that: replace `.rlib` suffix by\n+    // `.rmeta`.\n+    // We also need to remove `--error-format` as cargo specifies that to be JSON,\n+    // but when we run here, cargo does not interpret the JSON any more. `--json`\n+    // then also nees to be dropped.\n+    let mut args = info.args.into_iter();\n+    let error_format_flag = \"--error-format\";\n+    let json_flag = \"--json\";\n+    while let Some(arg) = args.next() {\n+        if arg == \"--extern\" {\n+            forward_patched_extern_arg(&mut args, &mut cmd);\n+        } else if let Some(suffix) = arg.strip_prefix(error_format_flag) {\n+            assert!(suffix.starts_with('='));\n+            // Drop this argument.\n+        } else if let Some(suffix) = arg.strip_prefix(json_flag) {\n+            assert!(suffix.starts_with('='));\n+            // Drop this argument.\n+        } else {\n+            cmd.arg(arg);\n+        }\n+    }\n+    // Respect `MIRIFLAGS`.\n+    if let Ok(a) = env::var(\"MIRIFLAGS\") {\n+        // This code is taken from `RUSTFLAGS` handling in cargo.\n+        let args = a.split(' ').map(str::trim).filter(|s| !s.is_empty()).map(str::to_string);\n+        cmd.args(args);\n+    }\n+\n+    // Then pass binary arguments.\n+    cmd.arg(\"--\");\n+    cmd.args(binary_args);\n+\n+    // Make sure we use the build-time working directory for interpreting Miri/rustc arguments.\n+    // But then we need to switch to the run-time one, which we instruct Miri do do by setting `MIRI_CWD`.\n+    cmd.current_dir(info.current_dir);\n+    cmd.env(\"MIRI_CWD\", env::current_dir().unwrap());\n+\n+    // Run it.\n+    debug_cmd(\"[cargo-miri runner]\", verbose, &cmd);\n+    match phase {\n+        RunnerPhase::Rustdoc => exec_with_pipe(cmd, &info.stdin, format!(\"{}.stdin\", binary)),\n+        RunnerPhase::Cargo => exec(cmd),\n+    }\n+}\n+\n+pub fn phase_rustdoc(mut args: impl Iterator<Item = String>) {\n+    let verbose = std::env::var(\"MIRI_VERBOSE\")\n+        .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n+\n+    // phase_cargo_miri sets the RUSTDOC env var to ourselves, so we can't use that here;\n+    // just default to a straight-forward invocation for now:\n+    let mut cmd = Command::new(\"rustdoc\");\n+\n+    let extern_flag = \"--extern\";\n+    let runtool_flag = \"--runtool\";\n+    while let Some(arg) = args.next() {\n+        if arg == extern_flag {\n+            // Patch --extern arguments to use *.rmeta files, since phase_cargo_rustc only creates stub *.rlib files.\n+            forward_patched_extern_arg(&mut args, &mut cmd);\n+        } else if arg == runtool_flag {\n+            // An existing --runtool flag indicates cargo is running in cross-target mode, which we don't support.\n+            // Note that this is only passed when cargo is run with the unstable -Zdoctest-xcompile flag;\n+            // otherwise, we won't be called as rustdoc at all.\n+            show_error!(\"cross-interpreting doctests is not currently supported by Miri.\");\n+        } else {\n+            cmd.arg(arg);\n+        }\n+    }\n+\n+    // Doctests of `proc-macro` crates (and their dependencies) are always built for the host,\n+    // so we are not able to run them in Miri.\n+    if get_arg_flag_values(\"--crate-type\").any(|crate_type| crate_type == \"proc-macro\") {\n+        eprintln!(\"Running doctests of `proc-macro` crates is not currently supported by Miri.\");\n+        return;\n+    }\n+\n+    // For each doctest, rustdoc starts two child processes: first the test is compiled,\n+    // then the produced executable is invoked. We want to reroute both of these to cargo-miri,\n+    // such that the first time we'll enter phase_cargo_rustc, and phase_cargo_runner second.\n+    //\n+    // rustdoc invokes the test-builder by forwarding most of its own arguments, which makes\n+    // it difficult to determine when phase_cargo_rustc should run instead of phase_cargo_rustdoc.\n+    // Furthermore, the test code is passed via stdin, rather than a temporary file, so we need\n+    // to let phase_cargo_rustc know to expect that. We'll use this environment variable as a flag:\n+    cmd.env(\"MIRI_CALLED_FROM_RUSTDOC\", \"1\");\n+\n+    // The `--test-builder` and `--runtool` arguments are unstable rustdoc features,\n+    // which are disabled by default. We first need to enable them explicitly:\n+    cmd.arg(\"-Z\").arg(\"unstable-options\");\n+\n+    // rustdoc needs to know the right sysroot.\n+    cmd.arg(\"--sysroot\").arg(env::var_os(\"MIRI_SYSROOT\").unwrap());\n+    // make sure the 'miri' flag is set for rustdoc\n+    cmd.arg(\"--cfg\").arg(\"miri\");\n+\n+    // Make rustdoc call us back.\n+    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    cmd.arg(\"--test-builder\").arg(&cargo_miri_path); // invoked by forwarding most arguments\n+    cmd.arg(\"--runtool\").arg(&cargo_miri_path); // invoked with just a single path argument\n+\n+    debug_cmd(\"[cargo-miri rustdoc]\", verbose, &cmd);\n+    exec(cmd)\n+}"}, {"sha": "c27bb1863175896dd9e64c3f52107a459290af2c", "filename": "src/tools/miri/cargo-miri/src/setup.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,245 @@\n+//! Implements `cargo miri setup` via xargo\n+\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs::{self};\n+use std::io::BufRead;\n+use std::ops::Not;\n+use std::path::{Path, PathBuf};\n+use std::process::{self, Command};\n+\n+use crate::{util::*, version::*};\n+\n+fn xargo_version() -> Option<(u32, u32, u32)> {\n+    let out = xargo_check().arg(\"--version\").output().ok()?;\n+    if !out.status.success() {\n+        return None;\n+    }\n+    // Parse output. The first line looks like \"xargo 0.3.12 (b004f1c 2018-12-13)\".\n+    let line = out\n+        .stderr\n+        .lines()\n+        .next()\n+        .expect(\"malformed `xargo --version` output: not at least one line\")\n+        .expect(\"malformed `xargo --version` output: error reading first line\");\n+    let (name, version) = {\n+        let mut split = line.split(' ');\n+        (\n+            split.next().expect(\"malformed `xargo --version` output: empty\"),\n+            split.next().expect(\"malformed `xargo --version` output: not at least two words\"),\n+        )\n+    };\n+    if name != \"xargo\" {\n+        // This is some fork of xargo\n+        return None;\n+    }\n+    let mut version_pieces = version.split('.');\n+    let major = version_pieces\n+        .next()\n+        .expect(\"malformed `xargo --version` output: not a major version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: major version is not an integer\");\n+    let minor = version_pieces\n+        .next()\n+        .expect(\"malformed `xargo --version` output: not a minor version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: minor version is not an integer\");\n+    let patch = version_pieces\n+        .next()\n+        .expect(\"malformed `xargo --version` output: not a patch version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: patch version is not an integer\");\n+    if version_pieces.next().is_some() {\n+        panic!(\"malformed `xargo --version` output: more than three pieces in version\");\n+    }\n+    Some((major, minor, patch))\n+}\n+\n+/// Performs the setup required to make `cargo miri` work: Getting a custom-built libstd. Then sets\n+/// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n+/// done all this already.\n+pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n+    let only_setup = matches!(subcommand, MiriCommand::Setup);\n+    let ask_user = !only_setup;\n+    let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n+    if std::env::var_os(\"MIRI_SYSROOT\").is_some() {\n+        if only_setup {\n+            println!(\"WARNING: MIRI_SYSROOT already set, not doing anything.\")\n+        }\n+        return;\n+    }\n+\n+    // First, we need xargo.\n+    if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n+        if std::env::var_os(\"XARGO_CHECK\").is_some() {\n+            // The user manually gave us a xargo binary; don't do anything automatically.\n+            show_error!(\"xargo is too old; please upgrade to the latest version\")\n+        }\n+        let mut cmd = cargo();\n+        cmd.args([\"install\", \"xargo\"]);\n+        ask_to_run(cmd, ask_user, \"install a recent enough xargo\");\n+    }\n+\n+    // Determine where the rust sources are located.  The env vars manually setting the source\n+    // (`MIRI_LIB_SRC`, `XARGO_RUST_SRC`) trump auto-detection.\n+    let rust_src_env_var =\n+        std::env::var_os(\"MIRI_LIB_SRC\").or_else(|| std::env::var_os(\"XARGO_RUST_SRC\"));\n+    let rust_src = match rust_src_env_var {\n+        Some(path) => {\n+            let path = PathBuf::from(path);\n+            // Make path absolute if possible.\n+            path.canonicalize().unwrap_or(path)\n+        }\n+        None => {\n+            // Check for `rust-src` rustup component.\n+            let output = miri_for_host()\n+                .args([\"--print\", \"sysroot\"])\n+                .output()\n+                .expect(\"failed to determine sysroot\");\n+            if !output.status.success() {\n+                show_error!(\n+                    \"Failed to determine sysroot; Miri said:\\n{}\",\n+                    String::from_utf8_lossy(&output.stderr).trim_end()\n+                );\n+            }\n+            let sysroot = std::str::from_utf8(&output.stdout).unwrap();\n+            let sysroot = Path::new(sysroot.trim_end_matches('\\n'));\n+            // Check for `$SYSROOT/lib/rustlib/src/rust/library`; test if that contains `std/Cargo.toml`.\n+            let rustup_src =\n+                sysroot.join(\"lib\").join(\"rustlib\").join(\"src\").join(\"rust\").join(\"library\");\n+            if !rustup_src.join(\"std\").join(\"Cargo.toml\").exists() {\n+                // Ask the user to install the `rust-src` component, and use that.\n+                let mut cmd = Command::new(\"rustup\");\n+                cmd.args([\"component\", \"add\", \"rust-src\"]);\n+                ask_to_run(\n+                    cmd,\n+                    ask_user,\n+                    \"install the `rust-src` component for the selected toolchain\",\n+                );\n+            }\n+            rustup_src\n+        }\n+    };\n+    if !rust_src.exists() {\n+        show_error!(\"given Rust source directory `{}` does not exist.\", rust_src.display());\n+    }\n+    if rust_src.file_name().and_then(OsStr::to_str) != Some(\"library\") {\n+        show_error!(\n+            \"given Rust source directory `{}` does not seem to be the `library` subdirectory of \\\n+             a Rust source checkout.\",\n+            rust_src.display()\n+        );\n+    }\n+\n+    // Next, we need our own libstd. Prepare a xargo project for that purpose.\n+    // We will do this work in whatever is a good cache dir for this platform.\n+    let dirs = directories::ProjectDirs::from(\"org\", \"rust-lang\", \"miri\").unwrap();\n+    let dir = dirs.cache_dir();\n+    if !dir.exists() {\n+        fs::create_dir_all(dir).unwrap();\n+    }\n+    // The interesting bit: Xargo.toml (only needs content if we actually need std)\n+    let xargo_toml = if std::env::var_os(\"MIRI_NO_STD\").is_some() {\n+        \"\"\n+    } else {\n+        r#\"\n+[dependencies.std]\n+default_features = false\n+# We support unwinding, so enable that panic runtime.\n+features = [\"panic_unwind\", \"backtrace\"]\n+\n+[dependencies.test]\n+\"#\n+    };\n+    write_to_file(&dir.join(\"Xargo.toml\"), xargo_toml);\n+    // The boring bits: a dummy project for xargo.\n+    // FIXME: With xargo-check, can we avoid doing this?\n+    write_to_file(\n+        &dir.join(\"Cargo.toml\"),\n+        r#\"\n+[package]\n+name = \"miri-xargo\"\n+description = \"A dummy project for building libstd with xargo.\"\n+version = \"0.0.0\"\n+\n+[lib]\n+path = \"lib.rs\"\n+\"#,\n+    );\n+    write_to_file(&dir.join(\"lib.rs\"), \"#![no_std]\");\n+\n+    // Figure out where xargo will build its stuff.\n+    // Unfortunately, it puts things into a different directory when the\n+    // architecture matches the host.\n+    let sysroot = if target == host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n+    // Make sure all target-level Miri invocations know their sysroot.\n+    std::env::set_var(\"MIRI_SYSROOT\", &sysroot);\n+\n+    // Now invoke xargo.\n+    let mut command = xargo_check();\n+    command.arg(\"check\").arg(\"-q\");\n+    command.current_dir(dir);\n+    command.env(\"XARGO_HOME\", dir);\n+    command.env(\"XARGO_RUST_SRC\", &rust_src);\n+    // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n+    command.arg(\"--target\").arg(target);\n+    // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n+    // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n+    // because we still need bootstrap to distinguish between host and target crates.\n+    // In that case we overwrite `RUSTC_REAL` instead which determines the rustc used\n+    // for target crates.\n+    // We set ourselves (`cargo-miri`) instead of Miri directly to be able to patch the flags\n+    // for `libpanic_abort` (usually this is done by bootstrap but we have to do it ourselves).\n+    // The `MIRI_CALLED_FROM_XARGO` will mean we dispatch to `phase_setup_rustc`.\n+    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    if env::var_os(\"RUSTC_STAGE\").is_some() {\n+        assert!(env::var_os(\"RUSTC\").is_some());\n+        command.env(\"RUSTC_REAL\", &cargo_miri_path);\n+    } else {\n+        command.env(\"RUSTC\", &cargo_miri_path);\n+    }\n+    command.env(\"MIRI_CALLED_FROM_XARGO\", \"1\");\n+    // Make sure there are no other wrappers getting in our way\n+    // (Cc https://github.com/rust-lang/miri/issues/1421, https://github.com/rust-lang/miri/issues/2429).\n+    // Looks like setting `RUSTC_WRAPPER` to the empty string overwrites `build.rustc-wrapper` set via `config.toml`.\n+    command.env(\"RUSTC_WRAPPER\", \"\");\n+    // Disable debug assertions in the standard library -- Miri is already slow enough. But keep the\n+    // overflow checks, they are cheap. This completely overwrites flags the user might have set,\n+    // which is consistent with normal `cargo build` that does not apply `RUSTFLAGS` to the sysroot\n+    // either.\n+    command.env(\"RUSTFLAGS\", \"-Cdebug-assertions=off -Coverflow-checks=on\");\n+    // Manage the output the user sees.\n+    if only_setup {\n+        // We want to be explicit.\n+        eprintln!(\"Preparing a sysroot for Miri (target: {target})...\");\n+        if print_sysroot {\n+            // Be extra sure there is no noise on stdout.\n+            command.stdout(process::Stdio::null());\n+        }\n+    } else {\n+        // We want to be quiet, but still let the user know that something is happening.\n+        eprint!(\"Preparing a sysroot for Miri (target: {target})... \");\n+        command.stdout(process::Stdio::null());\n+        command.stderr(process::Stdio::null());\n+    }\n+\n+    // Finally run it!\n+    if command.status().expect(\"failed to run xargo\").success().not() {\n+        if only_setup {\n+            show_error!(\"failed to run xargo, see error details above\")\n+        } else {\n+            show_error!(\"failed to run xargo; run `cargo miri setup` to see the error details\")\n+        }\n+    }\n+\n+    // Figure out what to print.\n+    if only_setup {\n+        eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot.display());\n+    } else {\n+        eprintln!(\"done\");\n+    }\n+    if print_sysroot {\n+        // Print just the sysroot and nothing else to stdout; this way we do not need any escaping.\n+        println!(\"{}\", sysroot.display());\n+    }\n+}"}, {"sha": "8f29eebaac1008fbe2ab9e57ce89fdbd88f6992f", "filename": "src/tools/miri/cargo-miri/src/util.rs", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Futil.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,314 @@\n+use std::collections::HashMap;\n+use std::env;\n+use std::ffi::OsString;\n+use std::fmt::Write as _;\n+use std::fs::{self, File};\n+use std::io::{self, BufWriter, Read, Write};\n+use std::ops::Not;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use cargo_metadata::{Metadata, MetadataCommand};\n+use rustc_version::VersionMeta;\n+use serde::{Deserialize, Serialize};\n+\n+pub use crate::arg::*;\n+\n+pub fn show_error(msg: &impl std::fmt::Display) -> ! {\n+    eprintln!(\"fatal error: {msg}\");\n+    std::process::exit(1)\n+}\n+\n+macro_rules! show_error {\n+    ($($tt:tt)*) => { crate::util::show_error(&format_args!($($tt)*)) };\n+}\n+\n+/// The information to run a crate with the given environment.\n+#[derive(Clone, Serialize, Deserialize)]\n+pub struct CrateRunEnv {\n+    /// The command-line arguments.\n+    pub args: Vec<String>,\n+    /// The environment.\n+    pub env: Vec<(OsString, OsString)>,\n+    /// The current working directory.\n+    pub current_dir: OsString,\n+    /// The contents passed via standard input.\n+    pub stdin: Vec<u8>,\n+}\n+\n+impl CrateRunEnv {\n+    /// Gather all the information we need.\n+    pub fn collect(args: impl Iterator<Item = String>, capture_stdin: bool) -> Self {\n+        let args = args.collect();\n+        let env = env::vars_os().collect();\n+        let current_dir = env::current_dir().unwrap().into_os_string();\n+\n+        let mut stdin = Vec::new();\n+        if capture_stdin {\n+            std::io::stdin().lock().read_to_end(&mut stdin).expect(\"cannot read stdin\");\n+        }\n+\n+        CrateRunEnv { args, env, current_dir, stdin }\n+    }\n+}\n+\n+/// The information Miri needs to run a crate. Stored as JSON when the crate is \"compiled\".\n+#[derive(Serialize, Deserialize)]\n+pub enum CrateRunInfo {\n+    /// Run it with the given environment.\n+    RunWith(CrateRunEnv),\n+    /// Skip it as Miri does not support interpreting such kind of crates.\n+    SkipProcMacroTest,\n+}\n+\n+impl CrateRunInfo {\n+    pub fn store(&self, filename: &Path) {\n+        let file = File::create(filename)\n+            .unwrap_or_else(|_| show_error!(\"cannot create `{}`\", filename.display()));\n+        let file = BufWriter::new(file);\n+        serde_json::ser::to_writer(file, self)\n+            .unwrap_or_else(|_| show_error!(\"cannot write to `{}`\", filename.display()));\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum MiriCommand {\n+    /// Our own special 'setup' command.\n+    Setup,\n+    /// A command to be forwarded to cargo.\n+    Forward(String),\n+}\n+\n+/// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n+pub fn escape_for_toml(s: &str) -> String {\n+    // We want to surround this string in quotes `\"`. So we first escape all quotes,\n+    // and also all backslashes (that are used to escape quotes).\n+    let s = s.replace('\\\\', r#\"\\\\\"#).replace('\"', r#\"\\\"\"#);\n+    format!(\"\\\"{}\\\"\", s)\n+}\n+\n+/// Returns the path to the `miri` binary\n+pub fn find_miri() -> PathBuf {\n+    if let Some(path) = env::var_os(\"MIRI\") {\n+        return path.into();\n+    }\n+    let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n+    if cfg!(windows) {\n+        path.set_file_name(\"miri.exe\");\n+    } else {\n+        path.set_file_name(\"miri\");\n+    }\n+    path\n+}\n+\n+pub fn miri() -> Command {\n+    Command::new(find_miri())\n+}\n+\n+pub fn miri_for_host() -> Command {\n+    let mut cmd = miri();\n+    cmd.env(\"MIRI_BE_RUSTC\", \"host\");\n+    cmd\n+}\n+\n+pub fn version_info() -> VersionMeta {\n+    VersionMeta::for_command(miri_for_host())\n+        .expect(\"failed to determine underlying rustc version of Miri\")\n+}\n+\n+pub fn cargo() -> Command {\n+    Command::new(env::var_os(\"CARGO\").unwrap_or_else(|| OsString::from(\"cargo\")))\n+}\n+\n+pub fn xargo_check() -> Command {\n+    Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n+}\n+\n+/// Execute the `Command`, where possible by replacing the current process with a new process\n+/// described by the `Command`. Then exit this process with the exit code of the new process.\n+pub fn exec(mut cmd: Command) -> ! {\n+    // On non-Unix imitate POSIX exec as closely as we can\n+    #[cfg(not(unix))]\n+    {\n+        let exit_status = cmd.status().expect(\"failed to run command\");\n+        std::process::exit(exit_status.code().unwrap_or(-1))\n+    }\n+    // On Unix targets, actually exec.\n+    // If exec returns, process setup has failed. This is the same error condition as the expect in\n+    // the non-Unix case.\n+    #[cfg(unix)]\n+    {\n+        use std::os::unix::process::CommandExt;\n+        let error = cmd.exec();\n+        Err(error).expect(\"failed to run command\")\n+    }\n+}\n+\n+/// Execute the `Command`, where possible by replacing the current process with a new process\n+/// described by the `Command`. Then exit this process with the exit code of the new process.\n+/// `input` is also piped to the new process's stdin, on cfg(unix) platforms by writing its\n+/// contents to `path` first, then setting stdin to that file.\n+pub fn exec_with_pipe<P>(mut cmd: Command, input: &[u8], path: P) -> !\n+where\n+    P: AsRef<Path>,\n+{\n+    #[cfg(unix)]\n+    {\n+        // Write the bytes we want to send to stdin out to a file\n+        std::fs::write(&path, input).unwrap();\n+        // Open the file for reading, and set our new stdin to it\n+        let stdin = File::open(&path).unwrap();\n+        cmd.stdin(stdin);\n+        // Unlink the file so that it is fully cleaned up as soon as the new process exits\n+        std::fs::remove_file(&path).unwrap();\n+        // Finally, we can hand off control.\n+        exec(cmd)\n+    }\n+    #[cfg(not(unix))]\n+    {\n+        drop(path); // We don't need the path, we can pipe the bytes directly\n+        cmd.stdin(std::process::Stdio::piped());\n+        let mut child = cmd.spawn().expect(\"failed to spawn process\");\n+        {\n+            let stdin = child.stdin.as_mut().expect(\"failed to open stdin\");\n+            stdin.write_all(input).expect(\"failed to write out test source\");\n+        }\n+        let exit_status = child.wait().expect(\"failed to run command\");\n+        std::process::exit(exit_status.code().unwrap_or(-1))\n+    }\n+}\n+\n+pub fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n+    // Disable interactive prompts in CI (GitHub Actions, Travis, AppVeyor, etc).\n+    // Azure doesn't set `CI` though (nothing to see here, just Microsoft being Microsoft),\n+    // so we also check their `TF_BUILD`.\n+    let is_ci = env::var_os(\"CI\").is_some() || env::var_os(\"TF_BUILD\").is_some();\n+    if ask && !is_ci {\n+        let mut buf = String::new();\n+        print!(\"I will run `{:?}` to {}. Proceed? [Y/n] \", cmd, text);\n+        io::stdout().flush().unwrap();\n+        io::stdin().read_line(&mut buf).unwrap();\n+        match buf.trim().to_lowercase().as_ref() {\n+            // Proceed.\n+            \"\" | \"y\" | \"yes\" => {}\n+            \"n\" | \"no\" => show_error!(\"aborting as per your request\"),\n+            a => show_error!(\"invalid answer `{}`\", a),\n+        };\n+    } else {\n+        eprintln!(\"Running `{:?}` to {}.\", cmd, text);\n+    }\n+\n+    if cmd.status().unwrap_or_else(|_| panic!(\"failed to execute {:?}\", cmd)).success().not() {\n+        show_error!(\"failed to {}\", text);\n+    }\n+}\n+\n+/// Writes the given content to the given file *cross-process atomically*, in the sense that another\n+/// process concurrently reading that file will see either the old content or the new content, but\n+/// not some intermediate (e.g., empty) state.\n+///\n+/// We assume no other parts of this same process are trying to read or write that file.\n+pub fn write_to_file(filename: &Path, content: &str) {\n+    // Create a temporary file with the desired contents.\n+    let mut temp_filename = filename.as_os_str().to_os_string();\n+    temp_filename.push(&format!(\".{}\", std::process::id()));\n+    let mut temp_file = File::create(&temp_filename).unwrap();\n+    temp_file.write_all(content.as_bytes()).unwrap();\n+    drop(temp_file);\n+\n+    // Move file to the desired location.\n+    fs::rename(temp_filename, filename).unwrap();\n+}\n+\n+// Computes the extra flags that need to be passed to cargo to make it behave like the current\n+// cargo invocation.\n+fn cargo_extra_flags() -> Vec<String> {\n+    let mut flags = Vec::new();\n+    // `-Zunstable-options` is required by `--config`.\n+    flags.push(\"-Zunstable-options\".to_string());\n+\n+    // Forward `--config` flags.\n+    let config_flag = \"--config\";\n+    for arg in get_arg_flag_values(config_flag) {\n+        flags.push(config_flag.to_string());\n+        flags.push(arg);\n+    }\n+\n+    // Forward `--manifest-path`.\n+    let manifest_flag = \"--manifest-path\";\n+    if let Some(manifest) = get_arg_flag_value(manifest_flag) {\n+        flags.push(manifest_flag.to_string());\n+        flags.push(manifest);\n+    }\n+\n+    // Forwarding `--target-dir` would make sense, but `cargo metadata` does not support that flag.\n+\n+    flags\n+}\n+\n+pub fn get_cargo_metadata() -> Metadata {\n+    // This will honor the `CARGO` env var the same way our `cargo()` does.\n+    MetadataCommand::new().no_deps().other_options(cargo_extra_flags()).exec().unwrap()\n+}\n+\n+/// Pulls all the crates in this workspace from the cargo metadata.\n+/// Workspace members are emitted like \"miri 0.1.0 (path+file:///path/to/miri)\"\n+/// Additionally, somewhere between cargo metadata and TyCtxt, '-' gets replaced with '_' so we\n+/// make that same transformation here.\n+pub fn local_crates(metadata: &Metadata) -> String {\n+    assert!(!metadata.workspace_members.is_empty());\n+    let mut local_crates = String::new();\n+    for member in &metadata.workspace_members {\n+        let name = member.repr.split(' ').next().unwrap();\n+        let name = name.replace('-', \"_\");\n+        local_crates.push_str(&name);\n+        local_crates.push(',');\n+    }\n+    local_crates.pop(); // Remove the trailing ','\n+\n+    local_crates\n+}\n+\n+fn env_vars_from_cmd(cmd: &Command) -> Vec<(String, String)> {\n+    let mut envs = HashMap::new();\n+    for (key, value) in std::env::vars() {\n+        envs.insert(key, value);\n+    }\n+    for (key, value) in cmd.get_envs() {\n+        if let Some(value) = value {\n+            envs.insert(key.to_string_lossy().to_string(), value.to_string_lossy().to_string());\n+        } else {\n+            envs.remove(&key.to_string_lossy().to_string());\n+        }\n+    }\n+    let mut envs: Vec<_> = envs.into_iter().collect();\n+    envs.sort();\n+    envs\n+}\n+\n+/// Debug-print a command that is going to be run.\n+pub fn debug_cmd(prefix: &str, verbose: usize, cmd: &Command) {\n+    if verbose == 0 {\n+        return;\n+    }\n+    // We only do a single `eprintln!` call to minimize concurrency interactions.\n+    let mut out = prefix.to_string();\n+    writeln!(out, \" running command: env \\\\\").unwrap();\n+    if verbose > 1 {\n+        // Print the full environment this will be called in.\n+        for (key, value) in env_vars_from_cmd(cmd) {\n+            writeln!(out, \"{key}={value:?} \\\\\").unwrap();\n+        }\n+    } else {\n+        // Print only what has been changed for this `cmd`.\n+        for (var, val) in cmd.get_envs() {\n+            if let Some(val) = val {\n+                writeln!(out, \"{}={:?} \\\\\", var.to_string_lossy(), val).unwrap();\n+            } else {\n+                writeln!(out, \"--unset={}\", var.to_string_lossy()).unwrap();\n+            }\n+        }\n+    }\n+    write!(out, \"{cmd:?}\").unwrap();\n+    eprintln!(\"{}\", out);\n+}"}, {"sha": "366e90df179835ed89d6dffc5932e724a7d4a136", "filename": "src/tools/miri/cargo-miri/src/version.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fversion.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,2 @@\n+// We put this in a separate file so that it can be hashed for GHA caching.\n+pub const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 26);"}, {"sha": "aa322e54a31da02da19282f7ee4d2b55761c5c53", "filename": "src/tools/miri/ci.sh", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fci.sh?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,101 @@\n+#!/bin/bash\n+set -euo pipefail\n+set -x\n+\n+# Determine configuration for installed build\n+echo \"Installing release version of Miri\"\n+export RUSTFLAGS=\"-D warnings\"\n+export CARGO_INCREMENTAL=0\n+./miri install # implicitly locked\n+\n+# Prepare debug build for direct `./miri` invocations\n+echo \"Building debug version of Miri\"\n+export CARGO_EXTRA_FLAGS=\"--locked\"\n+./miri check --no-default-features # make sure this can be built\n+./miri check --all-features # and this, too\n+./miri build --all-targets # the build that all the `./miri test` below will use\n+echo\n+\n+# Test\n+function run_tests {\n+  if [ -n \"${MIRI_TEST_TARGET+exists}\" ]; then\n+    echo \"Testing foreign architecture $MIRI_TEST_TARGET\"\n+  else\n+    echo \"Testing host architecture\"\n+  fi\n+\n+  ## ui test suite\n+  ./miri test\n+  if [ -z \"${MIRI_TEST_TARGET+exists}\" ]; then\n+    # Only for host architecture: tests with optimizations (`-O` is what cargo passes, but crank MIR\n+    # optimizations up all the way).\n+    # Optimizations change diagnostics (mostly backtraces), so we don't check them\n+    #FIXME(#2155): we want to only run the pass and panic tests here, not the fail tests.\n+    MIRIFLAGS=\"${MIRIFLAGS:-} -O -Zmir-opt-level=4\" MIRI_SKIP_UI_CHECKS=1 ./miri test -- tests/{pass,panic}\n+  fi\n+\n+  ## test-cargo-miri\n+  # On Windows, there is always \"python\", not \"python3\" or \"python2\".\n+  if command -v python3 > /dev/null; then\n+    PYTHON=python3\n+  else\n+    PYTHON=python\n+  fi\n+  # Some environment setup that attempts to confuse the heck out of cargo-miri.\n+  if [ \"$HOST_TARGET\" = x86_64-unknown-linux-gnu ]; then\n+    # These act up on Windows (`which miri` produces a filename that does not exist?!?),\n+    # so let's do this only on Linux. Also makes sure things work without these set.\n+    export RUSTC=$(which rustc)\n+    export MIRI=$(which miri)\n+  fi\n+  mkdir -p .cargo\n+  echo 'build.rustc-wrapper = \"thisdoesnotexist\"' > .cargo/config.toml\n+  # Run the actual test\n+  ${PYTHON} test-cargo-miri/run-test.py\n+  echo\n+  # Clean up\n+  unset RUSTC MIRI\n+  rm -rf .cargo\n+\n+  # Ensure that our benchmarks all work, but only on Linux hosts.\n+  if [ -z \"${MIRI_TEST_TARGET+exists}\" ] && [ \"$HOST_TARGET\" = x86_64-unknown-linux-gnu ] ; then\n+    for BENCH in $(ls \"bench-cargo-miri\"); do\n+      cargo miri run --manifest-path bench-cargo-miri/$BENCH/Cargo.toml\n+    done\n+  fi\n+}\n+\n+function run_tests_minimal {\n+  if [ -n \"${MIRI_TEST_TARGET+exists}\" ]; then\n+    echo \"Testing MINIMAL foreign architecture $MIRI_TEST_TARGET: only testing $@\"\n+  else\n+    echo \"Testing MINIMAL host architecture: only testing $@\"\n+  fi\n+\n+  ./miri test -- \"$@\"\n+}\n+\n+# host\n+run_tests\n+\n+case $HOST_TARGET in\n+  x86_64-unknown-linux-gnu)\n+    MIRI_TEST_TARGET=i686-unknown-linux-gnu run_tests\n+    MIRI_TEST_TARGET=aarch64-apple-darwin run_tests\n+    MIRI_TEST_TARGET=i686-pc-windows-msvc run_tests\n+    MIRI_TEST_TARGET=x86_64-unknown-freebsd run_tests_minimal hello integer vec panic/panic concurrency/simple atomic data_race env/var\n+    MIRI_TEST_TARGET=aarch64-linux-android run_tests_minimal hello integer vec panic/panic\n+    MIRI_TEST_TARGET=thumbv7em-none-eabihf MIRI_NO_STD=1 run_tests_minimal no_std # no_std embedded architecture\n+    ;;\n+  x86_64-apple-darwin)\n+    MIRI_TEST_TARGET=mips64-unknown-linux-gnuabi64 run_tests # big-endian architecture\n+    MIRI_TEST_TARGET=x86_64-pc-windows-msvc run_tests\n+    ;;\n+  i686-pc-windows-msvc)\n+    MIRI_TEST_TARGET=x86_64-unknown-linux-gnu run_tests\n+    ;;\n+  *)\n+    echo \"FATAL: unknown OS\"\n+    exit 1\n+    ;;\n+esac"}, {"sha": "19f1a987ace4aac6b8c3162b2551d5d5c856ca2d", "filename": "src/tools/miri/miri", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,236 @@\n+#!/bin/bash\n+set -e\n+USAGE=$(cat <<\"EOF\"\n+  COMMANDS\n+\n+./miri install <flags>:\n+Installs the miri driver and cargo-miri. <flags> are passed to `cargo\n+install`. Sets up the rpath such that the installed binary should work in any\n+working directory. However, the rustup toolchain when invoking `cargo miri`\n+needs to be the same one used for `./miri install`.\n+\n+./miri build <flags>:\n+Just build miri. <flags> are passed to `cargo build`.\n+\n+./miri check <flags>:\n+Just check miri. <flags> are passed to `cargo check`.\n+\n+./miri test <flags>:\n+Build miri, set up a sysroot and then run the test suite. <flags> are passed\n+to the final `cargo test` invocation.\n+\n+./miri run <flags>:\n+Build miri, set up a sysroot and then run the driver with the given <flags>.\n+(Also respects MIRIFLAGS environment variable.)\n+\n+./miri fmt <flags>:\n+Format all sources and tests. <flags> are passed to `rustfmt`.\n+\n+./miri clippy <flags>:\n+Runs clippy on all sources. <flags> are passed to `cargo clippy`.\n+\n+./miri cargo <flags>:\n+Runs just `cargo <flags>` with the Miri-specific environment variables.\n+Mainly meant to be invoked by rust-analyzer.\n+\n+./miri many-seeds <command>:\n+Runs <command> over and over again with different seeds for Miri. The MIRIFLAGS\n+variable is set to its original value appended with ` -Zmiri-seed=$SEED` for\n+many different seeds.\n+\n+./miri bench <benches>:\n+Runs the benchmarks from bench-cargo-miri in hyperfine. hyperfine needs to be installed.\n+<benches> can explicitly list the benchmarks to run; by default, all of them are run.\n+\n+  ENVIRONMENT VARIABLES\n+\n+MIRI_SYSROOT:\n+If already set, the \"sysroot setup\" step is skipped.\n+\n+CARGO_EXTRA_FLAGS:\n+Pass extra flags to all cargo invocations. (Ignored by `./miri cargo`.)\n+EOF\n+)\n+\n+## We need to know where we are.\n+# macOS does not have a useful readlink/realpath so we have to use Python instead...\n+MIRIDIR=$(python3 -c 'import os, sys; print(os.path.dirname(os.path.realpath(sys.argv[1])))' \"$0\")\n+\n+## Run the auto-things.\n+if [ -z \"$MIRI_AUTO_OPS\" ]; then\n+    export MIRI_AUTO_OPS=42\n+\n+    # Run this first, so that the toolchain doesn't change after\n+    # other code has run.\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-toolchain\" ] ; then\n+        (cd \"$MIRIDIR\" && ./rustup-toolchain)\n+    fi\n+\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-fmt\" ] ; then\n+        $0 fmt\n+    fi\n+\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-clippy\" ] ; then\n+        $0 clippy -- -D warnings\n+    fi\n+fi\n+\n+## Determine command and toolchain.\n+COMMAND=\"$1\"\n+[ $# -gt 0 ] && shift\n+# Doing this *after* auto-toolchain logic above, since that might change the toolchain.\n+TOOLCHAIN=$(cd \"$MIRIDIR\"; rustup show active-toolchain | head -n 1 | cut -d ' ' -f 1)\n+\n+## Handle some commands early, since they should *not* alter the environment.\n+case \"$COMMAND\" in\n+many-seeds)\n+    for SEED in $({ echo obase=16; seq 0 255; } | bc); do\n+        echo \"Trying seed: $SEED\"\n+        MIRIFLAGS=\"$MIRIFLAGS -Zmiri-seed=$SEED\" $@ || { echo \"Failing seed: $SEED\"; break; }\n+    done\n+    exit 0\n+    ;;\n+bench)\n+    # Make sure we have an up-to-date Miri installed\n+    \"$0\" install\n+    # Run the requested benchmarks\n+    if [ -z \"${1+exists}\" ]; then\n+        BENCHES=( $(ls \"$MIRIDIR/bench-cargo-miri\" ) )\n+    else\n+        BENCHES=(\"$@\")\n+    fi\n+    for BENCH in \"${BENCHES[@]}\"; do\n+        hyperfine -w 1 -m 5 --shell=none \"cargo +$TOOLCHAIN miri run --manifest-path $MIRIDIR/bench-cargo-miri/$BENCH/Cargo.toml\"\n+    done\n+    exit 0\n+    ;;\n+esac\n+\n+## Prepare the environment\n+# Determine some toolchain properties\n+# export the target so its available in miri\n+TARGET=$(rustc +$TOOLCHAIN --version --verbose | grep \"^host:\" | cut -d ' ' -f 2)\n+SYSROOT=$(rustc +$TOOLCHAIN --print sysroot)\n+LIBDIR=$SYSROOT/lib/rustlib/$TARGET/lib\n+if ! test -d \"$LIBDIR\"; then\n+    echo \"Something went wrong determining the library dir.\"\n+    echo \"I got $LIBDIR but that does not exist.\"\n+    echo \"Please report a bug at https://github.com/rust-lang/miri/issues.\"\n+    exit 2\n+fi\n+\n+# Prepare flags for cargo and rustc.\n+CARGO=\"cargo +$TOOLCHAIN\"\n+# Share target dir between `miri` and `cargo-miri`.\n+if [ -z \"$CARGO_TARGET_DIR\" ]; then\n+    export CARGO_TARGET_DIR=\"$MIRIDIR/target\"\n+fi\n+# We configure dev builds to not be unusably slow.\n+if [ -z \"$CARGO_PROFILE_DEV_OPT_LEVEL\" ]; then\n+    export CARGO_PROFILE_DEV_OPT_LEVEL=2\n+fi\n+# Enable rustc-specific lints (ignored without `-Zunstable-options`).\n+export RUSTFLAGS=\"-Zunstable-options -Wrustc::internal $RUSTFLAGS\"\n+# We set the rpath so that Miri finds the private rustc libraries it needs.\n+export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$LIBDIR $RUSTFLAGS\"\n+\n+## Helper functions\n+\n+# Build a sysroot and set MIRI_SYSROOT to use it. Arguments are passed to `cargo miri setup`.\n+build_sysroot() {\n+    if ! MIRI_SYSROOT=\"$($CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -q -- miri setup --print-sysroot \"$@\")\"; then\n+        echo \"'cargo miri setup' failed\"\n+        exit 1\n+    fi\n+    export MIRI_SYSROOT\n+}\n+\n+# Prepare and set MIRI_SYSROOT. Respects `MIRI_TEST_TARGET` and takes into account\n+# locally built vs. distributed rustc.\n+find_sysroot() {\n+    if [ -n \"$MIRI_SYSROOT\" ]; then\n+        # Sysroot already set, use that.\n+        return 0\n+    fi\n+    # We need to build a sysroot.\n+    if [ -n \"$MIRI_TEST_TARGET\" ]; then\n+        build_sysroot --target \"$MIRI_TEST_TARGET\"\n+    else\n+        build_sysroot\n+    fi\n+}\n+\n+## Main\n+\n+# Run command.\n+case \"$COMMAND\" in\n+install)\n+    # \"--locked\" to respect the Cargo.lock file if it exists.\n+    $CARGO install $CARGO_EXTRA_FLAGS --path \"$MIRIDIR\" --force --locked \"$@\"\n+    $CARGO install $CARGO_EXTRA_FLAGS --path \"$MIRIDIR\"/cargo-miri --force --locked \"$@\"\n+    ;;\n+check)\n+    # Check, and let caller control flags.\n+    $CARGO check $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml --all-targets \"$@\"\n+    $CARGO check $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml \"$@\"\n+    ;;\n+build)\n+    # Build, and let caller control flags.\n+    $CARGO build $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml \"$@\"\n+    $CARGO build $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml \"$@\"\n+    ;;\n+test|bless)\n+    # First build and get a sysroot.\n+    $CARGO build $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml\n+    find_sysroot\n+    if [ \"$COMMAND\" = \"bless\" ]; then\n+        export MIRI_BLESS=\"Gesundheit\"\n+    fi\n+    # Then test, and let caller control flags.\n+    # Only in root project as `cargo-miri` has no tests.\n+    $CARGO test $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml \"$@\"\n+    ;;\n+run)\n+    # Scan for \"--target\" to overwrite the \"MIRI_TEST_TARGET\" env var so\n+    # that we set the MIRI_SYSROOT up the right way.\n+    FOUND_TARGET_OPT=0\n+    for ARG in \"$@\"; do\n+        if [ \"$LAST_ARG\" = \"--target\" ]; then\n+            # Found it!\n+            export MIRI_TEST_TARGET=\"$ARG\"\n+            FOUND_TARGET_OPT=1\n+            break\n+        fi\n+        LAST_ARG=\"$ARG\"\n+    done\n+    if [ \"$FOUND_TARGET_OPT\" = \"0\" ] && [ -n \"$MIRI_TEST_TARGET\" ]; then\n+        # Make sure Miri actually uses this target.\n+        MIRIFLAGS=\"$MIRIFLAGS --target $MIRI_TEST_TARGET\"\n+    fi\n+    # First build and get a sysroot.\n+    $CARGO build $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml\n+    find_sysroot\n+    # Then run the actual command.\n+    exec $CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml -- $MIRIFLAGS \"$@\"\n+    ;;\n+fmt)\n+    find \"$MIRIDIR\" -not \\( -name target -prune \\) -name '*.rs' \\\n+        | xargs rustfmt +$TOOLCHAIN --edition=2021 --config-path \"$MIRIDIR/rustfmt.toml\" \"$@\"\n+    ;;\n+clippy)\n+    $CARGO clippy $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml --all-targets \"$@\"\n+    $CARGO clippy $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml \"$@\"\n+    ;;\n+cargo)\n+    # We carefully kept the working dir intact, so this will run cargo *on the workspace in the\n+    # current working dir*, not on the main Miri workspace. That is exactly what RA needs.\n+    $CARGO \"$@\"\n+    ;;\n+*)\n+    if [ -n \"$COMMAND\" ]; then\n+      echo \"Unknown command: $COMMAND\"\n+      echo\n+    fi\n+    echo \"$USAGE\"\n+    exit 1\n+esac"}, {"sha": "78b9a110aa7c73d5df529993f3b52d712be43e11", "filename": "src/tools/miri/rust-version", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1 @@\n+acb8934fd57b3c2740c4abac0a5728c2c9b1423b"}, {"sha": "be5af7379eae7773e98f4cb968cf4296c13a76cf", "filename": "src/tools/miri/rustfmt.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Frustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Frustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frustfmt.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,5 @@\n+version = \"Two\"\n+use_small_heuristics = \"Max\"\n+match_arm_blocks = false\n+match_arm_leading_pipes = \"Preserve\"\n+force_multiline_blocks = true"}, {"sha": "d7730f2b06d36a33cceb880461bef5213ff719c3", "filename": "src/tools/miri/rustup-toolchain", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Frustup-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Frustup-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frustup-toolchain?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,53 @@\n+#!/bin/bash\n+set -e\n+# Manages a rustup toolchain called \"miri\".\n+#\n+# All commands set \"miri\" as the override toolchain for the current directory,\n+# and make the `rust-version` file match that toolchain.\n+#\n+# USAGE:\n+#\n+# ./rustup-toolchain: Update \"miri\" toolchain to match `rust-version` (the known-good version for this commit).\n+#\n+# ./rustup-toolchain HEAD: Update \"miri\" toolchain and `rust-version` file to latest rustc HEAD.\n+#\n+# ./rustup-toolchain $COMMIT: Update \"miri\" toolchain and `rust-version` file to match that commit.\n+#\n+# Any extra parameters are passed to `rustup-toolchain-install-master`.\n+\n+# Make sure rustup-toolchain-install-master is installed.\n+if ! which rustup-toolchain-install-master >/dev/null; then\n+    echo \"Please install rustup-toolchain-install-master by running 'cargo install rustup-toolchain-install-master'\"\n+    exit 1\n+fi\n+\n+# Determine new commit.\n+if [[ \"$1\" == \"\" ]]; then\n+    NEW_COMMIT=$(cat rust-version)\n+elif [[ \"$1\" == \"HEAD\" ]]; then\n+    NEW_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n+else\n+    NEW_COMMIT=\"$1\"\n+fi\n+echo \"$NEW_COMMIT\" > rust-version\n+shift || true # don't fail if shifting fails\n+\n+# Check if we already are at that commit.\n+CUR_COMMIT=$(rustc +miri --version -v 2>/dev/null | grep \"^commit-hash: \" | cut -d \" \" -f 2)\n+if [[ \"$CUR_COMMIT\" == \"$NEW_COMMIT\" ]]; then\n+    echo \"miri toolchain is already at commit $CUR_COMMIT.\"\n+    rustup override set miri\n+    exit 0\n+fi\n+\n+# Install and setup new toolchain.\n+rustup toolchain uninstall miri\n+rustup-toolchain-install-master -n miri -c cargo -c rust-src -c rustc-dev -c llvm-tools -c rustfmt -c clippy \"$@\" -- \"$NEW_COMMIT\"\n+rustup override set miri\n+\n+# Cleanup.\n+cargo clean\n+\n+# Call 'cargo metadata' on the sources in case that changes the lockfile\n+# (which fails under some setups when it is done from inside vscode).\n+cargo metadata --format-version 1 --manifest-path \"$(rustc --print sysroot)/lib/rustlib/rustc-src/rust/compiler/rustc/Cargo.toml\" >/dev/null"}, {"sha": "7d32ee42573268ed8d6d6b513ae07f8c31d266d5", "filename": "src/tools/miri/src/bin/miri.rs", "status": "added", "additions": 562, "deletions": 0, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,562 @@\n+#![feature(rustc_private, stmt_expr_attributes)]\n+#![allow(\n+    clippy::manual_range_contains,\n+    clippy::useless_format,\n+    clippy::field_reassign_with_default\n+)]\n+\n+extern crate rustc_data_structures;\n+extern crate rustc_driver;\n+extern crate rustc_hir;\n+extern crate rustc_interface;\n+extern crate rustc_metadata;\n+extern crate rustc_middle;\n+extern crate rustc_session;\n+\n+use std::env;\n+use std::num::NonZeroU64;\n+use std::path::PathBuf;\n+use std::str::FromStr;\n+\n+use log::debug;\n+\n+use rustc_data_structures::sync::Lrc;\n+use rustc_driver::Compilation;\n+use rustc_hir::{self as hir, def_id::LOCAL_CRATE, Node};\n+use rustc_interface::interface::Config;\n+use rustc_middle::{\n+    middle::exported_symbols::{\n+        ExportedSymbol, SymbolExportInfo, SymbolExportKind, SymbolExportLevel,\n+    },\n+    ty::{query::ExternProviders, TyCtxt},\n+};\n+use rustc_session::{config::CrateType, search_paths::PathKind, CtfeBacktrace};\n+\n+use miri::{BacktraceStyle, ProvenanceMode};\n+\n+struct MiriCompilerCalls {\n+    miri_config: miri::MiriConfig,\n+}\n+\n+impl rustc_driver::Callbacks for MiriCompilerCalls {\n+    fn config(&mut self, config: &mut Config) {\n+        config.override_queries = Some(|_, _, external_providers| {\n+            external_providers.used_crate_source = |tcx, cnum| {\n+                let mut providers = ExternProviders::default();\n+                rustc_metadata::provide_extern(&mut providers);\n+                let mut crate_source = (providers.used_crate_source)(tcx, cnum);\n+                // HACK: rustc will emit \"crate ... required to be available in rlib format, but\n+                // was not found in this form\" errors once we use `tcx.dependency_formats()` if\n+                // there's no rlib provided, so setting a dummy path here to workaround those errors.\n+                Lrc::make_mut(&mut crate_source).rlib = Some((PathBuf::new(), PathKind::All));\n+                crate_source\n+            };\n+        });\n+    }\n+\n+    fn after_analysis<'tcx>(\n+        &mut self,\n+        compiler: &rustc_interface::interface::Compiler,\n+        queries: &'tcx rustc_interface::Queries<'tcx>,\n+    ) -> Compilation {\n+        compiler.session().abort_if_errors();\n+\n+        queries.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+            init_late_loggers(tcx);\n+            if !tcx.sess.crate_types().contains(&CrateType::Executable) {\n+                tcx.sess.fatal(\"miri only makes sense on bin crates\");\n+            }\n+\n+            let (entry_def_id, entry_type) = if let Some(entry_def) = tcx.entry_fn(()) {\n+                entry_def\n+            } else {\n+                tcx.sess.fatal(\"miri can only run programs that have a main function\");\n+            };\n+            let mut config = self.miri_config.clone();\n+\n+            // Add filename to `miri` arguments.\n+            config.args.insert(0, compiler.input().filestem().to_string());\n+\n+            // Adjust working directory for interpretation.\n+            if let Some(cwd) = env::var_os(\"MIRI_CWD\") {\n+                env::set_current_dir(cwd).unwrap();\n+            }\n+\n+            if let Some(return_code) = miri::eval_entry(tcx, entry_def_id, entry_type, config) {\n+                std::process::exit(\n+                    i32::try_from(return_code).expect(\"Return value was too large!\"),\n+                );\n+            }\n+        });\n+\n+        compiler.session().abort_if_errors();\n+\n+        Compilation::Stop\n+    }\n+}\n+\n+struct MiriBeRustCompilerCalls {\n+    target_crate: bool,\n+}\n+\n+impl rustc_driver::Callbacks for MiriBeRustCompilerCalls {\n+    #[allow(rustc::potential_query_instability)] // rustc_codegen_ssa (where this code is copied from) also allows this lint\n+    fn config(&mut self, config: &mut Config) {\n+        if config.opts.prints.is_empty() && self.target_crate {\n+            // Queries overriden here affect the data stored in `rmeta` files of dependencies,\n+            // which will be used later in non-`MIRI_BE_RUSTC` mode.\n+            config.override_queries = Some(|_, local_providers, _| {\n+                // `exported_symbols` and `reachable_non_generics` provided by rustc always returns\n+                // an empty result if `tcx.sess.opts.output_types.should_codegen()` is false.\n+                local_providers.exported_symbols = |tcx, cnum| {\n+                    assert_eq!(cnum, LOCAL_CRATE);\n+                    tcx.arena.alloc_from_iter(\n+                        // This is based on:\n+                        // https://github.com/rust-lang/rust/blob/2962e7c0089d5c136f4e9600b7abccfbbde4973d/compiler/rustc_codegen_ssa/src/back/symbol_export.rs#L62-L63\n+                        // https://github.com/rust-lang/rust/blob/2962e7c0089d5c136f4e9600b7abccfbbde4973d/compiler/rustc_codegen_ssa/src/back/symbol_export.rs#L174\n+                        tcx.reachable_set(()).iter().filter_map(|&local_def_id| {\n+                            // Do the same filtering that rustc does:\n+                            // https://github.com/rust-lang/rust/blob/2962e7c0089d5c136f4e9600b7abccfbbde4973d/compiler/rustc_codegen_ssa/src/back/symbol_export.rs#L84-L102\n+                            // Otherwise it may cause unexpected behaviours and ICEs\n+                            // (https://github.com/rust-lang/rust/issues/86261).\n+                            let is_reachable_non_generic = matches!(\n+                                tcx.hir().get(tcx.hir().local_def_id_to_hir_id(local_def_id)),\n+                                Node::Item(&hir::Item {\n+                                    kind: hir::ItemKind::Static(..) | hir::ItemKind::Fn(..),\n+                                    ..\n+                                }) | Node::ImplItem(&hir::ImplItem {\n+                                    kind: hir::ImplItemKind::Fn(..),\n+                                    ..\n+                                })\n+                                if !tcx.generics_of(local_def_id).requires_monomorphization(tcx)\n+                            );\n+                            (is_reachable_non_generic\n+                                && tcx.codegen_fn_attrs(local_def_id).contains_extern_indicator())\n+                            .then_some((\n+                                ExportedSymbol::NonGeneric(local_def_id.to_def_id()),\n+                                // Some dummy `SymbolExportInfo` here. We only use\n+                                // `exported_symbols` in shims/foreign_items.rs and the export info\n+                                // is ignored.\n+                                SymbolExportInfo {\n+                                    level: SymbolExportLevel::C,\n+                                    kind: SymbolExportKind::Text,\n+                                    used: false,\n+                                },\n+                            ))\n+                        }),\n+                    )\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+fn show_error(msg: &impl std::fmt::Display) -> ! {\n+    eprintln!(\"fatal error: {msg}\");\n+    std::process::exit(1)\n+}\n+\n+macro_rules! show_error {\n+    ($($tt:tt)*) => { show_error(&format_args!($($tt)*)) };\n+}\n+\n+fn init_early_loggers() {\n+    // Note that our `extern crate log` is *not* the same as rustc's; as a result, we have to\n+    // initialize them both, and we always initialize `miri`'s first.\n+    let env = env_logger::Env::new().filter(\"MIRI_LOG\").write_style(\"MIRI_LOG_STYLE\");\n+    env_logger::init_from_env(env);\n+    // Enable verbose entry/exit logging by default if MIRI_LOG is set.\n+    if env::var_os(\"MIRI_LOG\").is_some() && env::var_os(\"RUSTC_LOG_ENTRY_EXIT\").is_none() {\n+        env::set_var(\"RUSTC_LOG_ENTRY_EXIT\", \"1\");\n+    }\n+    // We only initialize `rustc` if the env var is set (so the user asked for it).\n+    // If it is not set, we avoid initializing now so that we can initialize\n+    // later with our custom settings, and *not* log anything for what happens before\n+    // `miri` gets started.\n+    if env::var_os(\"RUSTC_LOG\").is_some() {\n+        rustc_driver::init_rustc_env_logger();\n+    }\n+}\n+\n+fn init_late_loggers(tcx: TyCtxt<'_>) {\n+    // We initialize loggers right before we start evaluation. We overwrite the `RUSTC_LOG`\n+    // env var if it is not set, control it based on `MIRI_LOG`.\n+    // (FIXME: use `var_os`, but then we need to manually concatenate instead of `format!`.)\n+    if let Ok(var) = env::var(\"MIRI_LOG\") {\n+        if env::var_os(\"RUSTC_LOG\").is_none() {\n+            // We try to be a bit clever here: if `MIRI_LOG` is just a single level\n+            // used for everything, we only apply it to the parts of rustc that are\n+            // CTFE-related. Otherwise, we use it verbatim for `RUSTC_LOG`.\n+            // This way, if you set `MIRI_LOG=trace`, you get only the right parts of\n+            // rustc traced, but you can also do `MIRI_LOG=miri=trace,rustc_const_eval::interpret=debug`.\n+            if log::Level::from_str(&var).is_ok() {\n+                env::set_var(\n+                    \"RUSTC_LOG\",\n+                    &format!(\n+                        \"rustc_middle::mir::interpret={0},rustc_const_eval::interpret={0}\",\n+                        var\n+                    ),\n+                );\n+            } else {\n+                env::set_var(\"RUSTC_LOG\", &var);\n+            }\n+            rustc_driver::init_rustc_env_logger();\n+        }\n+    }\n+\n+    // If `MIRI_BACKTRACE` is set and `RUSTC_CTFE_BACKTRACE` is not, set `RUSTC_CTFE_BACKTRACE`.\n+    // Do this late, so we ideally only apply this to Miri's errors.\n+    if let Some(val) = env::var_os(\"MIRI_BACKTRACE\") {\n+        let ctfe_backtrace = match &*val.to_string_lossy() {\n+            \"immediate\" => CtfeBacktrace::Immediate,\n+            \"0\" => CtfeBacktrace::Disabled,\n+            _ => CtfeBacktrace::Capture,\n+        };\n+        *tcx.sess.ctfe_backtrace.borrow_mut() = ctfe_backtrace;\n+    }\n+}\n+\n+/// Returns the \"default sysroot\" that Miri will use for host things if no `--sysroot` flag is set.\n+/// Should be a compile-time constant.\n+fn host_sysroot() -> Option<String> {\n+    if option_env!(\"RUSTC_STAGE\").is_some() {\n+        // This is being built as part of rustc, and gets shipped with rustup.\n+        // We can rely on the sysroot computation in librustc_session.\n+        return None;\n+    }\n+    // For builds outside rustc, we need to ensure that we got a sysroot\n+    // that gets used as a default.  The sysroot computation in librustc_session would\n+    // end up somewhere in the build dir (see `get_or_default_sysroot`).\n+    // Taken from PR <https://github.com/Manishearth/rust-clippy/pull/911>.\n+    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n+    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n+    Some(match (home, toolchain) {\n+        (Some(home), Some(toolchain)) => {\n+            // Check that at runtime, we are still in this toolchain (if there is any toolchain).\n+            if let Some(toolchain_runtime) =\n+                env::var_os(\"RUSTUP_TOOLCHAIN\").or_else(|| env::var_os(\"MULTIRUST_TOOLCHAIN\"))\n+            {\n+                if toolchain_runtime != toolchain {\n+                    show_error!(\n+                        \"This Miri got built with local toolchain `{toolchain}`, but now is being run under a different toolchain. \\n\\\n+                        Make sure to run Miri in the toolchain it got built with, e.g. via `cargo +{toolchain} miri`.\"\n+                    )\n+                }\n+            }\n+            format!(\"{}/toolchains/{}\", home, toolchain)\n+        }\n+        _ => option_env!(\"RUST_SYSROOT\")\n+            .unwrap_or_else(|| {\n+                show_error!(\n+                    \"To build Miri without rustup, set the `RUST_SYSROOT` env var at build time\",\n+                )\n+            })\n+            .to_owned(),\n+    })\n+}\n+\n+/// Execute a compiler with the given CLI arguments and callbacks.\n+fn run_compiler(\n+    mut args: Vec<String>,\n+    target_crate: bool,\n+    callbacks: &mut (dyn rustc_driver::Callbacks + Send),\n+) -> ! {\n+    // Make sure we use the right default sysroot. The default sysroot is wrong,\n+    // because `get_or_default_sysroot` in `librustc_session` bases that on `current_exe`.\n+    //\n+    // Make sure we always call `host_sysroot` as that also does some sanity-checks\n+    // of the environment we were built in and whether it matches what we are running in.\n+    let host_default_sysroot = host_sysroot();\n+    // Now see if we even need to set something.\n+    let sysroot_flag = \"--sysroot\";\n+    if !args.iter().any(|e| e == sysroot_flag) {\n+        // No sysroot was set, let's see if we have a custom default we want to configure.\n+        let default_sysroot = if target_crate {\n+            // Using the built-in default here would be plain wrong, so we *require*\n+            // the env var to make sure things make sense.\n+            Some(env::var(\"MIRI_SYSROOT\").unwrap_or_else(|_| {\n+                show_error!(\n+                    \"Miri was invoked in 'target' mode without `MIRI_SYSROOT` or `--sysroot` being set\"\n+                )\n+            }))\n+        } else {\n+            host_default_sysroot\n+        };\n+        if let Some(sysroot) = default_sysroot {\n+            // We need to overwrite the default that librustc_session would compute.\n+            args.push(sysroot_flag.to_owned());\n+            args.push(sysroot);\n+        }\n+    }\n+\n+    // Don't insert `MIRI_DEFAULT_ARGS`, in particular, `--cfg=miri`, if we are building\n+    // a \"host\" crate. That may cause procedural macros (and probably build scripts) to\n+    // depend on Miri-only symbols, such as `miri_resolve_frame`:\n+    // https://github.com/rust-lang/miri/issues/1760\n+    if target_crate {\n+        // Some options have different defaults in Miri than in plain rustc; apply those by making\n+        // them the first arguments after the binary name (but later arguments can overwrite them).\n+        args.splice(1..1, miri::MIRI_DEFAULT_ARGS.iter().map(ToString::to_string));\n+    }\n+\n+    // Invoke compiler, and handle return code.\n+    let exit_code = rustc_driver::catch_with_exit_code(move || {\n+        rustc_driver::RunCompiler::new(&args, callbacks).run()\n+    });\n+    std::process::exit(exit_code)\n+}\n+\n+/// Parses a comma separated list of `T` from the given string:\n+///\n+/// `<value1>,<value2>,<value3>,...`\n+fn parse_comma_list<T: FromStr>(input: &str) -> Result<Vec<T>, T::Err> {\n+    input.split(',').map(str::parse::<T>).collect()\n+}\n+\n+fn main() {\n+    // Snapshot a copy of the environment before `rustc` starts messing with it.\n+    // (`install_ice_hook` might change `RUST_BACKTRACE`.)\n+    let env_snapshot = env::vars_os().collect::<Vec<_>>();\n+\n+    // Earliest rustc setup.\n+    rustc_driver::install_ice_hook();\n+\n+    // If the environment asks us to actually be rustc, then do that.\n+    if let Some(crate_kind) = env::var_os(\"MIRI_BE_RUSTC\") {\n+        rustc_driver::init_rustc_env_logger();\n+\n+        let target_crate = if crate_kind == \"target\" {\n+            true\n+        } else if crate_kind == \"host\" {\n+            false\n+        } else {\n+            panic!(\"invalid `MIRI_BE_RUSTC` value: {:?}\", crate_kind)\n+        };\n+\n+        // We cannot use `rustc_driver::main` as we need to adjust the CLI arguments.\n+        run_compiler(\n+            env::args().collect(),\n+            target_crate,\n+            &mut MiriBeRustCompilerCalls { target_crate },\n+        )\n+    }\n+\n+    // Init loggers the Miri way.\n+    init_early_loggers();\n+\n+    // Parse our arguments and split them across `rustc` and `miri`.\n+    let mut miri_config = miri::MiriConfig::default();\n+    miri_config.env = env_snapshot;\n+\n+    let mut rustc_args = vec![];\n+    let mut after_dashdash = false;\n+\n+    // If user has explicitly enabled/disabled isolation\n+    let mut isolation_enabled: Option<bool> = None;\n+    for arg in env::args() {\n+        if rustc_args.is_empty() {\n+            // Very first arg: binary name.\n+            rustc_args.push(arg);\n+        } else if after_dashdash {\n+            // Everything that comes after `--` is forwarded to the interpreted crate.\n+            miri_config.args.push(arg);\n+        } else if arg == \"--\" {\n+            after_dashdash = true;\n+        } else if arg == \"-Zmiri-disable-validation\" {\n+            miri_config.validate = false;\n+        } else if arg == \"-Zmiri-disable-stacked-borrows\" {\n+            miri_config.stacked_borrows = false;\n+        } else if arg == \"-Zmiri-disable-data-race-detector\" {\n+            miri_config.data_race_detector = false;\n+            miri_config.weak_memory_emulation = false;\n+        } else if arg == \"-Zmiri-disable-alignment-check\" {\n+            miri_config.check_alignment = miri::AlignmentCheck::None;\n+        } else if arg == \"-Zmiri-symbolic-alignment-check\" {\n+            miri_config.check_alignment = miri::AlignmentCheck::Symbolic;\n+        } else if arg == \"-Zmiri-check-number-validity\" {\n+            eprintln!(\n+                \"WARNING: the flag `-Zmiri-check-number-validity` no longer has any effect \\\n+                        since it is now enabled by default\"\n+            );\n+        } else if arg == \"-Zmiri-disable-abi-check\" {\n+            miri_config.check_abi = false;\n+        } else if arg == \"-Zmiri-disable-isolation\" {\n+            if matches!(isolation_enabled, Some(true)) {\n+                show_error!(\n+                    \"-Zmiri-disable-isolation cannot be used along with -Zmiri-isolation-error\"\n+                );\n+            } else {\n+                isolation_enabled = Some(false);\n+            }\n+            miri_config.isolated_op = miri::IsolatedOp::Allow;\n+        } else if arg == \"-Zmiri-disable-weak-memory-emulation\" {\n+            miri_config.weak_memory_emulation = false;\n+        } else if arg == \"-Zmiri-track-weak-memory-loads\" {\n+            miri_config.track_outdated_loads = true;\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-isolation-error=\") {\n+            if matches!(isolation_enabled, Some(false)) {\n+                show_error!(\n+                    \"-Zmiri-isolation-error cannot be used along with -Zmiri-disable-isolation\"\n+                );\n+            } else {\n+                isolation_enabled = Some(true);\n+            }\n+\n+            miri_config.isolated_op = match param {\n+                \"abort\" => miri::IsolatedOp::Reject(miri::RejectOpWith::Abort),\n+                \"hide\" => miri::IsolatedOp::Reject(miri::RejectOpWith::NoWarning),\n+                \"warn\" => miri::IsolatedOp::Reject(miri::RejectOpWith::Warning),\n+                \"warn-nobacktrace\" =>\n+                    miri::IsolatedOp::Reject(miri::RejectOpWith::WarningWithoutBacktrace),\n+                _ =>\n+                    show_error!(\n+                        \"-Zmiri-isolation-error must be `abort`, `hide`, `warn`, or `warn-nobacktrace`\"\n+                    ),\n+            };\n+        } else if arg == \"-Zmiri-ignore-leaks\" {\n+            miri_config.ignore_leaks = true;\n+        } else if arg == \"-Zmiri-panic-on-unsupported\" {\n+            miri_config.panic_on_unsupported = true;\n+        } else if arg == \"-Zmiri-tag-raw-pointers\" {\n+            eprintln!(\"WARNING: `-Zmiri-tag-raw-pointers` has no effect; it is enabled by default\");\n+        } else if arg == \"-Zmiri-strict-provenance\" {\n+            miri_config.provenance_mode = ProvenanceMode::Strict;\n+        } else if arg == \"-Zmiri-permissive-provenance\" {\n+            miri_config.provenance_mode = ProvenanceMode::Permissive;\n+        } else if arg == \"-Zmiri-mute-stdout-stderr\" {\n+            miri_config.mute_stdout_stderr = true;\n+        } else if arg == \"-Zmiri-retag-fields\" {\n+            miri_config.retag_fields = true;\n+        } else if arg == \"-Zmiri-track-raw-pointers\" {\n+            eprintln!(\n+                \"WARNING: `-Zmiri-track-raw-pointers` has no effect; it is enabled by default\"\n+            );\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-seed=\") {\n+            if miri_config.seed.is_some() {\n+                show_error!(\"Cannot specify -Zmiri-seed multiple times!\");\n+            }\n+            let seed = u64::from_str_radix(param, 16)\n+                        .unwrap_or_else(|_| show_error!(\n+                            \"-Zmiri-seed should only contain valid hex digits [0-9a-fA-F] and must fit into a u64 (max 16 characters)\"\n+                        ));\n+            miri_config.seed = Some(seed);\n+        } else if let Some(_param) = arg.strip_prefix(\"-Zmiri-env-exclude=\") {\n+            show_error!(\n+                \"`-Zmiri-env-exclude` has been removed; unset env vars before starting Miri instead\"\n+            );\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-env-forward=\") {\n+            miri_config.forwarded_env_vars.push(param.to_owned());\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-track-pointer-tag=\") {\n+            let ids: Vec<u64> = match parse_comma_list(param) {\n+                Ok(ids) => ids,\n+                Err(err) =>\n+                    show_error!(\n+                        \"-Zmiri-track-pointer-tag requires a comma separated list of valid `u64` arguments: {}\",\n+                        err\n+                    ),\n+            };\n+            for id in ids.into_iter().map(miri::SbTag::new) {\n+                if let Some(id) = id {\n+                    miri_config.tracked_pointer_tags.insert(id);\n+                } else {\n+                    show_error!(\"-Zmiri-track-pointer-tag requires nonzero arguments\");\n+                }\n+            }\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-track-call-id=\") {\n+            let ids: Vec<u64> = match parse_comma_list(param) {\n+                Ok(ids) => ids,\n+                Err(err) =>\n+                    show_error!(\n+                        \"-Zmiri-track-call-id requires a comma separated list of valid `u64` arguments: {}\",\n+                        err\n+                    ),\n+            };\n+            for id in ids.into_iter().map(miri::CallId::new) {\n+                if let Some(id) = id {\n+                    miri_config.tracked_call_ids.insert(id);\n+                } else {\n+                    show_error!(\"-Zmiri-track-call-id requires a nonzero argument\");\n+                }\n+            }\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-track-alloc-id=\") {\n+            let ids: Vec<miri::AllocId> = match parse_comma_list::<NonZeroU64>(param) {\n+                Ok(ids) => ids.into_iter().map(miri::AllocId).collect(),\n+                Err(err) =>\n+                    show_error!(\n+                        \"-Zmiri-track-alloc-id requires a comma separated list of valid non-zero `u64` arguments: {}\",\n+                        err\n+                    ),\n+            };\n+            miri_config.tracked_alloc_ids.extend(ids);\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-compare-exchange-weak-failure-rate=\") {\n+            let rate = match param.parse::<f64>() {\n+                Ok(rate) if rate >= 0.0 && rate <= 1.0 => rate,\n+                Ok(_) =>\n+                    show_error!(\n+                        \"-Zmiri-compare-exchange-weak-failure-rate must be between `0.0` and `1.0`\"\n+                    ),\n+                Err(err) =>\n+                    show_error!(\n+                        \"-Zmiri-compare-exchange-weak-failure-rate requires a `f64` between `0.0` and `1.0`: {}\",\n+                        err\n+                    ),\n+            };\n+            miri_config.cmpxchg_weak_failure_rate = rate;\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-preemption-rate=\") {\n+            let rate = match param.parse::<f64>() {\n+                Ok(rate) if rate >= 0.0 && rate <= 1.0 => rate,\n+                Ok(_) => show_error!(\"-Zmiri-preemption-rate must be between `0.0` and `1.0`\"),\n+                Err(err) =>\n+                    show_error!(\n+                        \"-Zmiri-preemption-rate requires a `f64` between `0.0` and `1.0`: {}\",\n+                        err\n+                    ),\n+            };\n+            miri_config.preemption_rate = rate;\n+        } else if arg == \"-Zmiri-report-progress\" {\n+            // This makes it take a few seconds between progress reports on my laptop.\n+            miri_config.report_progress = Some(1_000_000);\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-report-progress=\") {\n+            let interval = match param.parse::<u32>() {\n+                Ok(i) => i,\n+                Err(err) => show_error!(\"-Zmiri-report-progress requires a `u32`: {}\", err),\n+            };\n+            miri_config.report_progress = Some(interval);\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-tag-gc=\") {\n+            let interval = match param.parse::<u32>() {\n+                Ok(i) => i,\n+                Err(err) => show_error!(\"-Zmiri-tag-gc requires a `u32`: {}\", err),\n+            };\n+            miri_config.gc_interval = interval;\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-measureme=\") {\n+            miri_config.measureme_out = Some(param.to_string());\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-backtrace=\") {\n+            miri_config.backtrace_style = match param {\n+                \"0\" => BacktraceStyle::Off,\n+                \"1\" => BacktraceStyle::Short,\n+                \"full\" => BacktraceStyle::Full,\n+                _ => show_error!(\"-Zmiri-backtrace may only be 0, 1, or full\"),\n+            };\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-extern-so-file=\") {\n+            let filename = param.to_string();\n+            if std::path::Path::new(&filename).exists() {\n+                if let Some(other_filename) = miri_config.external_so_file {\n+                    show_error!(\n+                        \"-Zmiri-extern-so-file is already set to {}\",\n+                        other_filename.display()\n+                    );\n+                }\n+                miri_config.external_so_file = Some(filename.into());\n+            } else {\n+                show_error!(\"-Zmiri-extern-so-file `{}` does not exist\", filename);\n+            }\n+        } else {\n+            // Forward to rustc.\n+            rustc_args.push(arg);\n+        }\n+    }\n+\n+    debug!(\"rustc arguments: {:?}\", rustc_args);\n+    debug!(\"crate arguments: {:?}\", miri_config.args);\n+    run_compiler(rustc_args, /* target_crate: */ true, &mut MiriCompilerCalls { miri_config })\n+}"}, {"sha": "3f33273e1e541d577409d58e6fd756da531580bc", "filename": "src/tools/miri/src/clock.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fclock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fclock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fclock.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,115 @@\n+use std::sync::atomic::{AtomicU64, Ordering};\n+use std::time::{Duration, Instant as StdInstant};\n+\n+/// When using a virtual clock, this defines how many nanoseconds we pretend are passing for each\n+/// basic block.\n+const NANOSECONDS_PER_BASIC_BLOCK: u64 = 10;\n+\n+#[derive(Debug)]\n+pub struct Instant {\n+    kind: InstantKind,\n+}\n+\n+#[derive(Debug)]\n+enum InstantKind {\n+    Host(StdInstant),\n+    Virtual { nanoseconds: u64 },\n+}\n+\n+impl Instant {\n+    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {\n+        match self.kind {\n+            InstantKind::Host(instant) =>\n+                instant.checked_add(duration).map(|i| Instant { kind: InstantKind::Host(i) }),\n+            InstantKind::Virtual { nanoseconds } =>\n+                u128::from(nanoseconds)\n+                    .checked_add(duration.as_nanos())\n+                    .and_then(|n| u64::try_from(n).ok())\n+                    .map(|nanoseconds| Instant { kind: InstantKind::Virtual { nanoseconds } }),\n+        }\n+    }\n+\n+    pub fn duration_since(&self, earlier: Instant) -> Duration {\n+        match (&self.kind, earlier.kind) {\n+            (InstantKind::Host(instant), InstantKind::Host(earlier)) =>\n+                instant.duration_since(earlier),\n+            (\n+                InstantKind::Virtual { nanoseconds },\n+                InstantKind::Virtual { nanoseconds: earlier },\n+            ) => Duration::from_nanos(nanoseconds.saturating_sub(earlier)),\n+            _ => panic!(\"all `Instant` must be of the same kind\"),\n+        }\n+    }\n+}\n+\n+/// A monotone clock used for `Instant` simulation.\n+#[derive(Debug)]\n+pub struct Clock {\n+    kind: ClockKind,\n+}\n+\n+#[derive(Debug)]\n+enum ClockKind {\n+    Host {\n+        /// The \"time anchor\" for this machine's monotone clock.\n+        time_anchor: StdInstant,\n+    },\n+    Virtual {\n+        /// The \"current virtual time\".\n+        nanoseconds: AtomicU64,\n+    },\n+}\n+\n+impl Clock {\n+    /// Create a new clock based on the availability of communication with the host.\n+    pub fn new(communicate: bool) -> Self {\n+        let kind = if communicate {\n+            ClockKind::Host { time_anchor: StdInstant::now() }\n+        } else {\n+            ClockKind::Virtual { nanoseconds: 0.into() }\n+        };\n+\n+        Self { kind }\n+    }\n+\n+    /// Let the time pass for a small interval.\n+    pub fn tick(&self) {\n+        match &self.kind {\n+            ClockKind::Host { .. } => {\n+                // Time will pass without us doing anything.\n+            }\n+            ClockKind::Virtual { nanoseconds } => {\n+                nanoseconds.fetch_add(NANOSECONDS_PER_BASIC_BLOCK, Ordering::SeqCst);\n+            }\n+        }\n+    }\n+\n+    /// Sleep for the desired duration.\n+    pub fn sleep(&self, duration: Duration) {\n+        match &self.kind {\n+            ClockKind::Host { .. } => std::thread::sleep(duration),\n+            ClockKind::Virtual { nanoseconds } => {\n+                // Just pretend that we have slept for some time.\n+                nanoseconds.fetch_add(duration.as_nanos().try_into().unwrap(), Ordering::SeqCst);\n+            }\n+        }\n+    }\n+\n+    /// Return the `anchor` instant, to convert between monotone instants and durations relative to the anchor.\n+    pub fn anchor(&self) -> Instant {\n+        match &self.kind {\n+            ClockKind::Host { time_anchor } => Instant { kind: InstantKind::Host(*time_anchor) },\n+            ClockKind::Virtual { .. } => Instant { kind: InstantKind::Virtual { nanoseconds: 0 } },\n+        }\n+    }\n+\n+    pub fn now(&self) -> Instant {\n+        match &self.kind {\n+            ClockKind::Host { .. } => Instant { kind: InstantKind::Host(StdInstant::now()) },\n+            ClockKind::Virtual { nanoseconds } =>\n+                Instant {\n+                    kind: InstantKind::Virtual { nanoseconds: nanoseconds.load(Ordering::SeqCst) },\n+                },\n+        }\n+    }\n+}"}, {"sha": "2e54ddaaba1132e152be05595e21a18c38a28955", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "added", "additions": 1596, "deletions": 0, "changes": 1596, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,1596 @@\n+//! Implementation of a data-race detector using Lamport Timestamps / Vector-clocks\n+//! based on the Dynamic Race Detection for C++:\n+//! <https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf>\n+//! which does not report false-positives when fences are used, and gives better\n+//! accuracy in presence of read-modify-write operations.\n+//!\n+//! The implementation contains modifications to correctly model the changes to the memory model in C++20\n+//! regarding the weakening of release sequences: <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html>.\n+//! Relaxed stores now unconditionally block all currently active release sequences and so per-thread tracking of release\n+//! sequences is not needed.\n+//!\n+//! The implementation also models races with memory allocation and deallocation via treating allocation and\n+//! deallocation as a type of write internally for detecting data-races.\n+//!\n+//! Weak memory orders are explored but not all weak behaviours are exhibited, so it can still miss data-races\n+//! but should not report false-positives\n+//!\n+//! Data-race definition from(<https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races>):\n+//! a data race occurs between two memory accesses if they are on different threads, at least one operation\n+//! is non-atomic, at least one operation is a write and neither access happens-before the other. Read the link\n+//! for full definition.\n+//!\n+//! This re-uses vector indexes for threads that are known to be unable to report data-races, this is valid\n+//! because it only re-uses vector indexes once all currently-active (not-terminated) threads have an internal\n+//! vector clock that happens-after the join operation of the candidate thread. Threads that have not been joined\n+//! on are not considered. Since the thread's vector clock will only increase and a data-race implies that\n+//! there is some index x where `clock[x] > thread_clock`, when this is true `clock[candidate-idx] > thread_clock`\n+//! can never hold and hence a data-race can never be reported in that vector index again.\n+//! This means that the thread-index can be safely re-used, starting on the next timestamp for the newly created\n+//! thread.\n+//!\n+//! The timestamps used in the data-race detector assign each sequence of non-atomic operations\n+//! followed by a single atomic or concurrent operation a single timestamp.\n+//! Write, Read, Write, ThreadJoin will be represented by a single timestamp value on a thread.\n+//! This is because extra increment operations between the operations in the sequence are not\n+//! required for accurate reporting of data-race values.\n+//!\n+//! As per the paper a threads timestamp is only incremented after a release operation is performed\n+//! so some atomic operations that only perform acquires do not increment the timestamp. Due to shared\n+//! code some atomic operations may increment the timestamp when not necessary but this has no effect\n+//! on the data-race detection code.\n+\n+use std::{\n+    cell::{Cell, Ref, RefCell, RefMut},\n+    fmt::Debug,\n+    mem,\n+};\n+\n+use rustc_ast::Mutability;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::{mir, ty::layout::TyAndLayout};\n+use rustc_target::abi::{Align, Size};\n+\n+use crate::*;\n+\n+use super::{\n+    vector_clock::{VClock, VTimestamp, VectorIdx},\n+    weak_memory::EvalContextExt as _,\n+};\n+\n+pub type AllocExtra = VClockAlloc;\n+\n+/// Valid atomic read-write orderings, alias of atomic::Ordering (not non-exhaustive).\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum AtomicRwOrd {\n+    Relaxed,\n+    Acquire,\n+    Release,\n+    AcqRel,\n+    SeqCst,\n+}\n+\n+/// Valid atomic read orderings, subset of atomic::Ordering.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum AtomicReadOrd {\n+    Relaxed,\n+    Acquire,\n+    SeqCst,\n+}\n+\n+/// Valid atomic write orderings, subset of atomic::Ordering.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum AtomicWriteOrd {\n+    Relaxed,\n+    Release,\n+    SeqCst,\n+}\n+\n+/// Valid atomic fence orderings, subset of atomic::Ordering.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum AtomicFenceOrd {\n+    Acquire,\n+    Release,\n+    AcqRel,\n+    SeqCst,\n+}\n+\n+/// The current set of vector clocks describing the state\n+/// of a thread, contains the happens-before clock and\n+/// additional metadata to model atomic fence operations.\n+#[derive(Clone, Default, Debug)]\n+pub(super) struct ThreadClockSet {\n+    /// The increasing clock representing timestamps\n+    /// that happen-before this thread.\n+    pub(super) clock: VClock,\n+\n+    /// The set of timestamps that will happen-before this\n+    /// thread once it performs an acquire fence.\n+    fence_acquire: VClock,\n+\n+    /// The last timestamp of happens-before relations that\n+    /// have been released by this thread by a fence.\n+    fence_release: VClock,\n+\n+    /// Timestamps of the last SC fence performed by each\n+    /// thread, updated when this thread performs an SC fence\n+    pub(super) fence_seqcst: VClock,\n+\n+    /// Timestamps of the last SC write performed by each\n+    /// thread, updated when this thread performs an SC fence\n+    pub(super) write_seqcst: VClock,\n+\n+    /// Timestamps of the last SC fence performed by each\n+    /// thread, updated when this thread performs an SC read\n+    pub(super) read_seqcst: VClock,\n+}\n+\n+impl ThreadClockSet {\n+    /// Apply the effects of a release fence to this\n+    /// set of thread vector clocks.\n+    #[inline]\n+    fn apply_release_fence(&mut self) {\n+        self.fence_release.clone_from(&self.clock);\n+    }\n+\n+    /// Apply the effects of an acquire fence to this\n+    /// set of thread vector clocks.\n+    #[inline]\n+    fn apply_acquire_fence(&mut self) {\n+        self.clock.join(&self.fence_acquire);\n+    }\n+\n+    /// Increment the happens-before clock at a\n+    /// known index.\n+    #[inline]\n+    fn increment_clock(&mut self, index: VectorIdx) {\n+        self.clock.increment_index(index);\n+    }\n+\n+    /// Join the happens-before clock with that of\n+    /// another thread, used to model thread join\n+    /// operations.\n+    fn join_with(&mut self, other: &ThreadClockSet) {\n+        self.clock.join(&other.clock);\n+    }\n+}\n+\n+/// Error returned by finding a data race\n+/// should be elaborated upon.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct DataRace;\n+\n+/// Externally stored memory cell clocks\n+/// explicitly to reduce memory usage for the\n+/// common case where no atomic operations\n+/// exists on the memory cell.\n+#[derive(Clone, PartialEq, Eq, Default, Debug)]\n+struct AtomicMemoryCellClocks {\n+    /// The clock-vector of the timestamp of the last atomic\n+    /// read operation performed by each thread.\n+    /// This detects potential data-races between atomic read\n+    /// and non-atomic write operations.\n+    read_vector: VClock,\n+\n+    /// The clock-vector of the timestamp of the last atomic\n+    /// write operation performed by each thread.\n+    /// This detects potential data-races between atomic write\n+    /// and non-atomic read or write operations.\n+    write_vector: VClock,\n+\n+    /// Synchronization vector for acquire-release semantics\n+    /// contains the vector of timestamps that will\n+    /// happen-before a thread if an acquire-load is\n+    /// performed on the data.\n+    sync_vector: VClock,\n+}\n+\n+/// Type of write operation: allocating memory\n+/// non-atomic writes and deallocating memory\n+/// are all treated as writes for the purpose\n+/// of the data-race detector.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum WriteType {\n+    /// Allocate memory.\n+    Allocate,\n+\n+    /// Standard unsynchronized write.\n+    Write,\n+\n+    /// Deallocate memory.\n+    /// Note that when memory is deallocated first, later non-atomic accesses\n+    /// will be reported as use-after-free, not as data races.\n+    /// (Same for `Allocate` above.)\n+    Deallocate,\n+}\n+impl WriteType {\n+    fn get_descriptor(self) -> &'static str {\n+        match self {\n+            WriteType::Allocate => \"Allocate\",\n+            WriteType::Write => \"Write\",\n+            WriteType::Deallocate => \"Deallocate\",\n+        }\n+    }\n+}\n+\n+/// Memory Cell vector clock metadata\n+/// for data-race detection.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+struct MemoryCellClocks {\n+    /// The vector-clock timestamp of the last write\n+    /// corresponding to the writing threads timestamp.\n+    write: VTimestamp,\n+\n+    /// The identifier of the vector index, corresponding to a thread\n+    /// that performed the last write operation.\n+    write_index: VectorIdx,\n+\n+    /// The type of operation that the write index represents,\n+    /// either newly allocated memory, a non-atomic write or\n+    /// a deallocation of memory.\n+    write_type: WriteType,\n+\n+    /// The vector-clock of the timestamp of the last read operation\n+    /// performed by a thread since the last write operation occurred.\n+    /// It is reset to zero on each write operation.\n+    read: VClock,\n+\n+    /// Atomic acquire & release sequence tracking clocks.\n+    /// For non-atomic memory in the common case this\n+    /// value is set to None.\n+    atomic_ops: Option<Box<AtomicMemoryCellClocks>>,\n+}\n+\n+impl MemoryCellClocks {\n+    /// Create a new set of clocks representing memory allocated\n+    ///  at a given vector timestamp and index.\n+    fn new(alloc: VTimestamp, alloc_index: VectorIdx) -> Self {\n+        MemoryCellClocks {\n+            read: VClock::default(),\n+            write: alloc,\n+            write_index: alloc_index,\n+            write_type: WriteType::Allocate,\n+            atomic_ops: None,\n+        }\n+    }\n+\n+    /// Load the internal atomic memory cells if they exist.\n+    #[inline]\n+    fn atomic(&self) -> Option<&AtomicMemoryCellClocks> {\n+        self.atomic_ops.as_deref()\n+    }\n+\n+    /// Load or create the internal atomic memory metadata\n+    /// if it does not exist.\n+    #[inline]\n+    fn atomic_mut(&mut self) -> &mut AtomicMemoryCellClocks {\n+        self.atomic_ops.get_or_insert_with(Default::default)\n+    }\n+\n+    /// Update memory cell data-race tracking for atomic\n+    /// load acquire semantics, is a no-op if this memory was\n+    /// not used previously as atomic memory.\n+    fn load_acquire(\n+        &mut self,\n+        clocks: &mut ThreadClockSet,\n+        index: VectorIdx,\n+    ) -> Result<(), DataRace> {\n+        self.atomic_read_detect(clocks, index)?;\n+        if let Some(atomic) = self.atomic() {\n+            clocks.clock.join(&atomic.sync_vector);\n+        }\n+        Ok(())\n+    }\n+\n+    /// Checks if the memory cell access is ordered with all prior atomic reads and writes\n+    fn race_free_with_atomic(&self, clocks: &ThreadClockSet) -> bool {\n+        if let Some(atomic) = self.atomic() {\n+            atomic.read_vector <= clocks.clock && atomic.write_vector <= clocks.clock\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Update memory cell data-race tracking for atomic\n+    /// load relaxed semantics, is a no-op if this memory was\n+    /// not used previously as atomic memory.\n+    fn load_relaxed(\n+        &mut self,\n+        clocks: &mut ThreadClockSet,\n+        index: VectorIdx,\n+    ) -> Result<(), DataRace> {\n+        self.atomic_read_detect(clocks, index)?;\n+        if let Some(atomic) = self.atomic() {\n+            clocks.fence_acquire.join(&atomic.sync_vector);\n+        }\n+        Ok(())\n+    }\n+\n+    /// Update the memory cell data-race tracking for atomic\n+    /// store release semantics.\n+    fn store_release(&mut self, clocks: &ThreadClockSet, index: VectorIdx) -> Result<(), DataRace> {\n+        self.atomic_write_detect(clocks, index)?;\n+        let atomic = self.atomic_mut();\n+        atomic.sync_vector.clone_from(&clocks.clock);\n+        Ok(())\n+    }\n+\n+    /// Update the memory cell data-race tracking for atomic\n+    /// store relaxed semantics.\n+    fn store_relaxed(&mut self, clocks: &ThreadClockSet, index: VectorIdx) -> Result<(), DataRace> {\n+        self.atomic_write_detect(clocks, index)?;\n+\n+        // The handling of release sequences was changed in C++20 and so\n+        // the code here is different to the paper since now all relaxed\n+        // stores block release sequences. The exception for same-thread\n+        // relaxed stores has been removed.\n+        let atomic = self.atomic_mut();\n+        atomic.sync_vector.clone_from(&clocks.fence_release);\n+        Ok(())\n+    }\n+\n+    /// Update the memory cell data-race tracking for atomic\n+    /// store release semantics for RMW operations.\n+    fn rmw_release(&mut self, clocks: &ThreadClockSet, index: VectorIdx) -> Result<(), DataRace> {\n+        self.atomic_write_detect(clocks, index)?;\n+        let atomic = self.atomic_mut();\n+        atomic.sync_vector.join(&clocks.clock);\n+        Ok(())\n+    }\n+\n+    /// Update the memory cell data-race tracking for atomic\n+    /// store relaxed semantics for RMW operations.\n+    fn rmw_relaxed(&mut self, clocks: &ThreadClockSet, index: VectorIdx) -> Result<(), DataRace> {\n+        self.atomic_write_detect(clocks, index)?;\n+        let atomic = self.atomic_mut();\n+        atomic.sync_vector.join(&clocks.fence_release);\n+        Ok(())\n+    }\n+\n+    /// Detect data-races with an atomic read, caused by a non-atomic write that does\n+    /// not happen-before the atomic-read.\n+    fn atomic_read_detect(\n+        &mut self,\n+        clocks: &ThreadClockSet,\n+        index: VectorIdx,\n+    ) -> Result<(), DataRace> {\n+        log::trace!(\"Atomic read with vectors: {:#?} :: {:#?}\", self, clocks);\n+        if self.write <= clocks.clock[self.write_index] {\n+            let atomic = self.atomic_mut();\n+            atomic.read_vector.set_at_index(&clocks.clock, index);\n+            Ok(())\n+        } else {\n+            Err(DataRace)\n+        }\n+    }\n+\n+    /// Detect data-races with an atomic write, either with a non-atomic read or with\n+    /// a non-atomic write.\n+    fn atomic_write_detect(\n+        &mut self,\n+        clocks: &ThreadClockSet,\n+        index: VectorIdx,\n+    ) -> Result<(), DataRace> {\n+        log::trace!(\"Atomic write with vectors: {:#?} :: {:#?}\", self, clocks);\n+        if self.write <= clocks.clock[self.write_index] && self.read <= clocks.clock {\n+            let atomic = self.atomic_mut();\n+            atomic.write_vector.set_at_index(&clocks.clock, index);\n+            Ok(())\n+        } else {\n+            Err(DataRace)\n+        }\n+    }\n+\n+    /// Detect races for non-atomic read operations at the current memory cell\n+    /// returns true if a data-race is detected.\n+    fn read_race_detect(\n+        &mut self,\n+        clocks: &ThreadClockSet,\n+        index: VectorIdx,\n+    ) -> Result<(), DataRace> {\n+        log::trace!(\"Unsynchronized read with vectors: {:#?} :: {:#?}\", self, clocks);\n+        if self.write <= clocks.clock[self.write_index] {\n+            let race_free = if let Some(atomic) = self.atomic() {\n+                atomic.write_vector <= clocks.clock\n+            } else {\n+                true\n+            };\n+            if race_free {\n+                self.read.set_at_index(&clocks.clock, index);\n+                Ok(())\n+            } else {\n+                Err(DataRace)\n+            }\n+        } else {\n+            Err(DataRace)\n+        }\n+    }\n+\n+    /// Detect races for non-atomic write operations at the current memory cell\n+    /// returns true if a data-race is detected.\n+    fn write_race_detect(\n+        &mut self,\n+        clocks: &ThreadClockSet,\n+        index: VectorIdx,\n+        write_type: WriteType,\n+    ) -> Result<(), DataRace> {\n+        log::trace!(\"Unsynchronized write with vectors: {:#?} :: {:#?}\", self, clocks);\n+        if self.write <= clocks.clock[self.write_index] && self.read <= clocks.clock {\n+            let race_free = if let Some(atomic) = self.atomic() {\n+                atomic.write_vector <= clocks.clock && atomic.read_vector <= clocks.clock\n+            } else {\n+                true\n+            };\n+            if race_free {\n+                self.write = clocks.clock[index];\n+                self.write_index = index;\n+                self.write_type = write_type;\n+                self.read.set_zero_vector();\n+                Ok(())\n+            } else {\n+                Err(DataRace)\n+            }\n+        } else {\n+            Err(DataRace)\n+        }\n+    }\n+}\n+\n+/// Evaluation context extensions.\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n+    /// Atomic variant of read_scalar_at_offset.\n+    fn read_scalar_at_offset_atomic(\n+        &self,\n+        op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+        layout: TyAndLayout<'tcx>,\n+        atomic: AtomicReadOrd,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_ref();\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n+        this.read_scalar_atomic(&value_place, atomic)\n+    }\n+\n+    /// Atomic variant of write_scalar_at_offset.\n+    fn write_scalar_at_offset_atomic(\n+        &mut self,\n+        op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+        value: impl Into<Scalar<Provenance>>,\n+        layout: TyAndLayout<'tcx>,\n+        atomic: AtomicWriteOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n+        this.write_scalar_atomic(value.into(), &value_place, atomic)\n+    }\n+\n+    /// Perform an atomic read operation at the memory location.\n+    fn read_scalar_atomic(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicReadOrd,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_ref();\n+        this.atomic_access_check(place)?;\n+        // This will read from the last store in the modification order of this location. In case\n+        // weak memory emulation is enabled, this may not be the store we will pick to actually read from and return.\n+        // This is fine with StackedBorrow and race checks because they don't concern metadata on\n+        // the *value* (including the associated provenance if this is an AtomicPtr) at this location.\n+        // Only metadata on the location itself is used.\n+        let scalar = this.allow_data_races_ref(move |this| this.read_scalar(&place.into()))?;\n+        this.validate_overlapping_atomic(place)?;\n+        this.buffered_atomic_read(place, atomic, scalar, || {\n+            this.validate_atomic_load(place, atomic)\n+        })\n+    }\n+\n+    /// Perform an atomic write operation at the memory location.\n+    fn write_scalar_atomic(\n+        &mut self,\n+        val: Scalar<Provenance>,\n+        dest: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicWriteOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.atomic_access_check(dest)?;\n+\n+        this.validate_overlapping_atomic(dest)?;\n+        this.allow_data_races_mut(move |this| this.write_scalar(val, &dest.into()))?;\n+        this.validate_atomic_store(dest, atomic)?;\n+        // FIXME: it's not possible to get the value before write_scalar. A read_scalar will cause\n+        // side effects from a read the program did not perform. So we have to initialise\n+        // the store buffer with the value currently being written\n+        // ONCE this is fixed please remove the hack in buffered_atomic_write() in weak_memory.rs\n+        // https://github.com/rust-lang/miri/issues/2164\n+        this.buffered_atomic_write(val, dest, atomic, val)\n+    }\n+\n+    /// Perform an atomic operation on a memory location.\n+    fn atomic_op_immediate(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        rhs: &ImmTy<'tcx, Provenance>,\n+        op: mir::BinOp,\n+        neg: bool,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        this.atomic_access_check(place)?;\n+\n+        this.validate_overlapping_atomic(place)?;\n+        let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n+\n+        // Atomics wrap around on overflow.\n+        let val = this.binary_op(op, &old, rhs)?;\n+        let val = if neg { this.unary_op(mir::UnOp::Not, &val)? } else { val };\n+        this.allow_data_races_mut(|this| this.write_immediate(*val, &place.into()))?;\n+\n+        this.validate_atomic_rmw(place, atomic)?;\n+\n+        this.buffered_atomic_rmw(val.to_scalar(), place, atomic, old.to_scalar())?;\n+        Ok(old)\n+    }\n+\n+    /// Perform an atomic exchange with a memory place and a new\n+    /// scalar value, the old value is returned.\n+    fn atomic_exchange_scalar(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        new: Scalar<Provenance>,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+        this.atomic_access_check(place)?;\n+\n+        this.validate_overlapping_atomic(place)?;\n+        let old = this.allow_data_races_mut(|this| this.read_scalar(&place.into()))?;\n+        this.allow_data_races_mut(|this| this.write_scalar(new, &place.into()))?;\n+\n+        this.validate_atomic_rmw(place, atomic)?;\n+\n+        this.buffered_atomic_rmw(new, place, atomic, old)?;\n+        Ok(old)\n+    }\n+\n+    /// Perform an conditional atomic exchange with a memory place and a new\n+    /// scalar value, the old value is returned.\n+    fn atomic_min_max_scalar(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        rhs: ImmTy<'tcx, Provenance>,\n+        min: bool,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        this.atomic_access_check(place)?;\n+\n+        this.validate_overlapping_atomic(place)?;\n+        let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n+        let lt = this.binary_op(mir::BinOp::Lt, &old, &rhs)?.to_scalar().to_bool()?;\n+\n+        let new_val = if min {\n+            if lt { &old } else { &rhs }\n+        } else {\n+            if lt { &rhs } else { &old }\n+        };\n+\n+        this.allow_data_races_mut(|this| this.write_immediate(**new_val, &place.into()))?;\n+\n+        this.validate_atomic_rmw(place, atomic)?;\n+\n+        this.buffered_atomic_rmw(new_val.to_scalar(), place, atomic, old.to_scalar())?;\n+\n+        // Return the old value.\n+        Ok(old)\n+    }\n+\n+    /// Perform an atomic compare and exchange at a given memory location.\n+    /// On success an atomic RMW operation is performed and on failure\n+    /// only an atomic read occurs. If `can_fail_spuriously` is true,\n+    /// then we treat it as a \"compare_exchange_weak\" operation, and\n+    /// some portion of the time fail even when the values are actually\n+    /// identical.\n+    fn atomic_compare_exchange_scalar(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        expect_old: &ImmTy<'tcx, Provenance>,\n+        new: Scalar<Provenance>,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n+        can_fail_spuriously: bool,\n+    ) -> InterpResult<'tcx, Immediate<Provenance>> {\n+        use rand::Rng as _;\n+        let this = self.eval_context_mut();\n+        this.atomic_access_check(place)?;\n+\n+        this.validate_overlapping_atomic(place)?;\n+        // Failure ordering cannot be stronger than success ordering, therefore first attempt\n+        // to read with the failure ordering and if successful then try again with the success\n+        // read ordering and write in the success case.\n+        // Read as immediate for the sake of `binary_op()`\n+        let old = this.allow_data_races_mut(|this| this.read_immediate(&(place.into())))?;\n+        // `binary_op` will bail if either of them is not a scalar.\n+        let eq = this.binary_op(mir::BinOp::Eq, &old, expect_old)?;\n+        // If the operation would succeed, but is \"weak\", fail some portion\n+        // of the time, based on `success_rate`.\n+        let success_rate = 1.0 - this.machine.cmpxchg_weak_failure_rate;\n+        let cmpxchg_success = eq.to_scalar().to_bool()?\n+            && if can_fail_spuriously {\n+                this.machine.rng.get_mut().gen_bool(success_rate)\n+            } else {\n+                true\n+            };\n+        let res = Immediate::ScalarPair(old.to_scalar(), Scalar::from_bool(cmpxchg_success));\n+\n+        // Update ptr depending on comparison.\n+        // if successful, perform a full rw-atomic validation\n+        // otherwise treat this as an atomic load with the fail ordering.\n+        if cmpxchg_success {\n+            this.allow_data_races_mut(|this| this.write_scalar(new, &place.into()))?;\n+            this.validate_atomic_rmw(place, success)?;\n+            this.buffered_atomic_rmw(new, place, success, old.to_scalar())?;\n+        } else {\n+            this.validate_atomic_load(place, fail)?;\n+            // A failed compare exchange is equivalent to a load, reading from the latest store\n+            // in the modification order.\n+            // Since `old` is only a value and not the store element, we need to separately\n+            // find it in our store buffer and perform load_impl on it.\n+            this.perform_read_on_buffered_latest(place, fail, old.to_scalar())?;\n+        }\n+\n+        // Return the old value.\n+        Ok(res)\n+    }\n+\n+    /// Update the data-race detector for an atomic fence on the current thread.\n+    fn atomic_fence(&mut self, atomic: AtomicFenceOrd) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        if let Some(data_race) = &mut this.machine.data_race {\n+            data_race.maybe_perform_sync_operation(&this.machine.threads, |index, mut clocks| {\n+                log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n+\n+                // Apply data-race detection for the current fences\n+                // this treats AcqRel and SeqCst as the same as an acquire\n+                // and release fence applied in the same timestamp.\n+                if atomic != AtomicFenceOrd::Release {\n+                    // Either Acquire | AcqRel | SeqCst\n+                    clocks.apply_acquire_fence();\n+                }\n+                if atomic != AtomicFenceOrd::Acquire {\n+                    // Either Release | AcqRel | SeqCst\n+                    clocks.apply_release_fence();\n+                }\n+                if atomic == AtomicFenceOrd::SeqCst {\n+                    data_race.last_sc_fence.borrow_mut().set_at_index(&clocks.clock, index);\n+                    clocks.fence_seqcst.join(&data_race.last_sc_fence.borrow());\n+                    clocks.write_seqcst.join(&data_race.last_sc_write.borrow());\n+                }\n+\n+                // Increment timestamp in case of release semantics.\n+                Ok(atomic != AtomicFenceOrd::Acquire)\n+            })\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    /// After all threads are done running, this allows data races to occur for subsequent\n+    /// 'administrative' machine accesses (that logically happen outside of the Abstract Machine).\n+    fn allow_data_races_all_threads_done(&mut self) {\n+        let this = self.eval_context_ref();\n+        assert!(this.have_all_terminated());\n+        if let Some(data_race) = &this.machine.data_race {\n+            let old = data_race.ongoing_action_data_race_free.replace(true);\n+            assert!(!old, \"cannot nest allow_data_races\");\n+        }\n+    }\n+}\n+\n+/// Vector clock metadata for a logical memory allocation.\n+#[derive(Debug, Clone)]\n+pub struct VClockAlloc {\n+    /// Assigning each byte a MemoryCellClocks.\n+    alloc_ranges: RefCell<RangeMap<MemoryCellClocks>>,\n+}\n+\n+impl VClockAlloc {\n+    /// Create a new data-race detector for newly allocated memory.\n+    pub fn new_allocation(\n+        global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        len: Size,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> VClockAlloc {\n+        let (alloc_timestamp, alloc_index) = match kind {\n+            // User allocated and stack memory should track allocation.\n+            MemoryKind::Machine(\n+                MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap,\n+            )\n+            | MemoryKind::Stack => {\n+                let (alloc_index, clocks) = global.current_thread_state(thread_mgr);\n+                let alloc_timestamp = clocks.clock[alloc_index];\n+                (alloc_timestamp, alloc_index)\n+            }\n+            // Other global memory should trace races but be allocated at the 0 timestamp.\n+            MemoryKind::Machine(\n+                MiriMemoryKind::Global\n+                | MiriMemoryKind::Machine\n+                | MiriMemoryKind::Runtime\n+                | MiriMemoryKind::ExternStatic\n+                | MiriMemoryKind::Tls,\n+            )\n+            | MemoryKind::CallerLocation => (0, VectorIdx::MAX_INDEX),\n+        };\n+        VClockAlloc {\n+            alloc_ranges: RefCell::new(RangeMap::new(\n+                len,\n+                MemoryCellClocks::new(alloc_timestamp, alloc_index),\n+            )),\n+        }\n+    }\n+\n+    // Find an index, if one exists where the value\n+    // in `l` is greater than the value in `r`.\n+    fn find_gt_index(l: &VClock, r: &VClock) -> Option<VectorIdx> {\n+        log::trace!(\"Find index where not {:?} <= {:?}\", l, r);\n+        let l_slice = l.as_slice();\n+        let r_slice = r.as_slice();\n+        l_slice\n+            .iter()\n+            .zip(r_slice.iter())\n+            .enumerate()\n+            .find_map(|(idx, (&l, &r))| if l > r { Some(idx) } else { None })\n+            .or_else(|| {\n+                if l_slice.len() > r_slice.len() {\n+                    // By invariant, if l_slice is longer\n+                    // then one element must be larger.\n+                    // This just validates that this is true\n+                    // and reports earlier elements first.\n+                    let l_remainder_slice = &l_slice[r_slice.len()..];\n+                    let idx = l_remainder_slice\n+                        .iter()\n+                        .enumerate()\n+                        .find_map(|(idx, &r)| if r == 0 { None } else { Some(idx) })\n+                        .expect(\"Invalid VClock Invariant\");\n+                    Some(idx + r_slice.len())\n+                } else {\n+                    None\n+                }\n+            })\n+            .map(VectorIdx::new)\n+    }\n+\n+    /// Report a data-race found in the program.\n+    /// This finds the two racing threads and the type\n+    /// of data-race that occurred. This will also\n+    /// return info about the memory location the data-race\n+    /// occurred in.\n+    #[cold]\n+    #[inline(never)]\n+    fn report_data_race<'tcx>(\n+        global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        range: &MemoryCellClocks,\n+        action: &str,\n+        is_atomic: bool,\n+        ptr_dbg: Pointer<AllocId>,\n+    ) -> InterpResult<'tcx> {\n+        let (current_index, current_clocks) = global.current_thread_state(thread_mgr);\n+        let write_clock;\n+        let (other_action, other_thread, _other_clock) = if range.write\n+            > current_clocks.clock[range.write_index]\n+        {\n+            // Convert the write action into the vector clock it\n+            // represents for diagnostic purposes.\n+            write_clock = VClock::new_with_index(range.write_index, range.write);\n+            (range.write_type.get_descriptor(), range.write_index, &write_clock)\n+        } else if let Some(idx) = Self::find_gt_index(&range.read, &current_clocks.clock) {\n+            (\"Read\", idx, &range.read)\n+        } else if !is_atomic {\n+            if let Some(atomic) = range.atomic() {\n+                if let Some(idx) = Self::find_gt_index(&atomic.write_vector, &current_clocks.clock)\n+                {\n+                    (\"Atomic Store\", idx, &atomic.write_vector)\n+                } else if let Some(idx) =\n+                    Self::find_gt_index(&atomic.read_vector, &current_clocks.clock)\n+                {\n+                    (\"Atomic Load\", idx, &atomic.read_vector)\n+                } else {\n+                    unreachable!(\n+                        \"Failed to report data-race for non-atomic operation: no race found\"\n+                    )\n+                }\n+            } else {\n+                unreachable!(\n+                    \"Failed to report data-race for non-atomic operation: no atomic component\"\n+                )\n+            }\n+        } else {\n+            unreachable!(\"Failed to report data-race for atomic operation\")\n+        };\n+\n+        // Load elaborated thread information about the racing thread actions.\n+        let current_thread_info = global.print_thread_metadata(thread_mgr, current_index);\n+        let other_thread_info = global.print_thread_metadata(thread_mgr, other_thread);\n+\n+        // Throw the data-race detection.\n+        throw_ub_format!(\n+            \"Data race detected between {} on {} and {} on {} at {:?}\",\n+            action,\n+            current_thread_info,\n+            other_action,\n+            other_thread_info,\n+            ptr_dbg,\n+        )\n+    }\n+\n+    /// Detect racing atomic read and writes (not data races)\n+    /// on every byte of the current access range\n+    pub(super) fn race_free_with_atomic(\n+        &self,\n+        range: AllocRange,\n+        global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> bool {\n+        if global.race_detecting() {\n+            let (_, clocks) = global.current_thread_state(thread_mgr);\n+            let alloc_ranges = self.alloc_ranges.borrow();\n+            for (_, range) in alloc_ranges.iter(range.start, range.size) {\n+                if !range.race_free_with_atomic(&clocks) {\n+                    return false;\n+                }\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Detect data-races for an unsynchronized read operation, will not perform\n+    /// data-race detection if `race_detecting()` is false, either due to no threads\n+    /// being created or if it is temporarily disabled during a racy read or write\n+    /// operation for which data-race detection is handled separately, for example\n+    /// atomic read operations.\n+    pub fn read<'tcx>(\n+        &self,\n+        alloc_id: AllocId,\n+        range: AllocRange,\n+        global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> InterpResult<'tcx> {\n+        if global.race_detecting() {\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n+            for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n+                if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n+                    // Report data-race.\n+                    return Self::report_data_race(\n+                        global,\n+                        thread_mgr,\n+                        range,\n+                        \"Read\",\n+                        false,\n+                        Pointer::new(alloc_id, offset),\n+                    );\n+                }\n+            }\n+            Ok(())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    // Shared code for detecting data-races on unique access to a section of memory\n+    fn unique_access<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        range: AllocRange,\n+        write_type: WriteType,\n+        global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> InterpResult<'tcx> {\n+        if global.race_detecting() {\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n+                if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n+                    // Report data-race\n+                    return Self::report_data_race(\n+                        global,\n+                        thread_mgr,\n+                        range,\n+                        write_type.get_descriptor(),\n+                        false,\n+                        Pointer::new(alloc_id, offset),\n+                    );\n+                }\n+            }\n+            Ok(())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    /// Detect data-races for an unsynchronized write operation, will not perform\n+    /// data-race threads if `race_detecting()` is false, either due to no threads\n+    /// being created or if it is temporarily disabled during a racy read or write\n+    /// operation\n+    pub fn write<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        range: AllocRange,\n+        global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> InterpResult<'tcx> {\n+        self.unique_access(alloc_id, range, WriteType::Write, global, thread_mgr)\n+    }\n+\n+    /// Detect data-races for an unsynchronized deallocate operation, will not perform\n+    /// data-race threads if `race_detecting()` is false, either due to no threads\n+    /// being created or if it is temporarily disabled during a racy read or write\n+    /// operation\n+    pub fn deallocate<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        range: AllocRange,\n+        global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> InterpResult<'tcx> {\n+        self.unique_access(alloc_id, range, WriteType::Deallocate, global, thread_mgr)\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n+    /// Temporarily allow data-races to occur. This should only be used in\n+    /// one of these cases:\n+    /// - One of the appropriate `validate_atomic` functions will be called to\n+    /// to treat a memory access as atomic.\n+    /// - The memory being accessed should be treated as internal state, that\n+    /// cannot be accessed by the interpreted program.\n+    /// - Execution of the interpreted program execution has halted.\n+    #[inline]\n+    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriInterpCx<'mir, 'tcx>) -> R) -> R {\n+        let this = self.eval_context_ref();\n+        if let Some(data_race) = &this.machine.data_race {\n+            let old = data_race.ongoing_action_data_race_free.replace(true);\n+            assert!(!old, \"cannot nest allow_data_races\");\n+        }\n+        let result = op(this);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(false);\n+        }\n+        result\n+    }\n+\n+    /// Same as `allow_data_races_ref`, this temporarily disables any data-race detection and\n+    /// so should only be used for atomic operations or internal state that the program cannot\n+    /// access.\n+    #[inline]\n+    fn allow_data_races_mut<R>(\n+        &mut self,\n+        op: impl FnOnce(&mut MiriInterpCx<'mir, 'tcx>) -> R,\n+    ) -> R {\n+        let this = self.eval_context_mut();\n+        if let Some(data_race) = &this.machine.data_race {\n+            let old = data_race.ongoing_action_data_race_free.replace(true);\n+            assert!(!old, \"cannot nest allow_data_races\");\n+        }\n+        let result = op(this);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(false);\n+        }\n+        result\n+    }\n+\n+    /// Checks that an atomic access is legal at the given place.\n+    fn atomic_access_check(&self, place: &MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        // Check alignment requirements. Atomics must always be aligned to their size,\n+        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+        // be 8-aligned).\n+        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+        this.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n+        // Ensure the allocation is mutable. Even failing (read-only) compare_exchange need mutable\n+        // memory on many targets (i.e., they segfault if taht memory is mapped read-only), and\n+        // atomic loads can be implemented via compare_exchange on some targets. There could\n+        // possibly be some very specific exceptions to this, see\n+        // <https://github.com/rust-lang/miri/pull/2464#discussion_r939636130> for details.\n+        // We avoid `get_ptr_alloc` since we do *not* want to run the access hooks -- the actual\n+        // access will happen later.\n+        let (alloc_id, _offset, _prov) =\n+            this.ptr_try_get_alloc_id(place.ptr).expect(\"there are no zero-sized atomic accesses\");\n+        if this.get_alloc_mutability(alloc_id)? == Mutability::Not {\n+            // FIXME: make this prettier, once these messages have separate title/span/help messages.\n+            throw_ub_format!(\n+                \"atomic operations cannot be performed on read-only memory\\n\\\n+                many platforms require atomic read-modify-write instructions to be performed on writeable memory, even if the operation fails \\\n+                (and is hence nominally read-only)\\n\\\n+                some platforms implement (some) atomic loads via compare-exchange, which means they do not work on read-only memory; \\\n+                it is possible that we could have an exception permitting this for specific kinds of loads\\n\\\n+                please report an issue at <https://github.com/rust-lang/miri/issues> if this is a problem for you\"\n+            );\n+        }\n+        Ok(())\n+    }\n+\n+    /// Update the data-race detector for an atomic read occurring at the\n+    /// associated memory-place and on the current thread.\n+    fn validate_atomic_load(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicReadOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        this.validate_overlapping_atomic(place)?;\n+        this.validate_atomic_op(\n+            place,\n+            atomic,\n+            \"Atomic Load\",\n+            move |memory, clocks, index, atomic| {\n+                if atomic == AtomicReadOrd::Relaxed {\n+                    memory.load_relaxed(&mut *clocks, index)\n+                } else {\n+                    memory.load_acquire(&mut *clocks, index)\n+                }\n+            },\n+        )\n+    }\n+\n+    /// Update the data-race detector for an atomic write occurring at the\n+    /// associated memory-place and on the current thread.\n+    fn validate_atomic_store(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicWriteOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.validate_overlapping_atomic(place)?;\n+        this.validate_atomic_op(\n+            place,\n+            atomic,\n+            \"Atomic Store\",\n+            move |memory, clocks, index, atomic| {\n+                if atomic == AtomicWriteOrd::Relaxed {\n+                    memory.store_relaxed(clocks, index)\n+                } else {\n+                    memory.store_release(clocks, index)\n+                }\n+            },\n+        )\n+    }\n+\n+    /// Update the data-race detector for an atomic read-modify-write occurring\n+    /// at the associated memory place and on the current thread.\n+    fn validate_atomic_rmw(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx> {\n+        use AtomicRwOrd::*;\n+        let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n+        let release = matches!(atomic, Release | AcqRel | SeqCst);\n+        let this = self.eval_context_mut();\n+        this.validate_overlapping_atomic(place)?;\n+        this.validate_atomic_op(place, atomic, \"Atomic RMW\", move |memory, clocks, index, _| {\n+            if acquire {\n+                memory.load_acquire(clocks, index)?;\n+            } else {\n+                memory.load_relaxed(clocks, index)?;\n+            }\n+            if release {\n+                memory.rmw_release(clocks, index)\n+            } else {\n+                memory.rmw_relaxed(clocks, index)\n+            }\n+        })\n+    }\n+\n+    /// Generic atomic operation implementation\n+    fn validate_atomic_op<A: Debug + Copy>(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: A,\n+        description: &str,\n+        mut op: impl FnMut(\n+            &mut MemoryCellClocks,\n+            &mut ThreadClockSet,\n+            VectorIdx,\n+            A,\n+        ) -> Result<(), DataRace>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        if let Some(data_race) = &this.machine.data_race {\n+            if data_race.race_detecting() {\n+                let size = place.layout.size;\n+                let (alloc_id, base_offset, _prov) = this.ptr_get_alloc_id(place.ptr)?;\n+                // Load and log the atomic operation.\n+                // Note that atomic loads are possible even from read-only allocations, so `get_alloc_extra_mut` is not an option.\n+                let alloc_meta = this.get_alloc_extra(alloc_id)?.data_race.as_ref().unwrap();\n+                log::trace!(\n+                    \"Atomic op({}) with ordering {:?} on {:?} (size={})\",\n+                    description,\n+                    &atomic,\n+                    place.ptr,\n+                    size.bytes()\n+                );\n+\n+                // Perform the atomic operation.\n+                data_race.maybe_perform_sync_operation(\n+                    &this.machine.threads,\n+                    |index, mut clocks| {\n+                        for (offset, range) in\n+                            alloc_meta.alloc_ranges.borrow_mut().iter_mut(base_offset, size)\n+                        {\n+                            if let Err(DataRace) = op(range, &mut clocks, index, atomic) {\n+                                mem::drop(clocks);\n+                                return VClockAlloc::report_data_race(\n+                                    data_race,\n+                                    &this.machine.threads,\n+                                    range,\n+                                    description,\n+                                    true,\n+                                    Pointer::new(alloc_id, offset),\n+                                )\n+                                .map(|_| true);\n+                            }\n+                        }\n+\n+                        // This conservatively assumes all operations have release semantics\n+                        Ok(true)\n+                    },\n+                )?;\n+\n+                // Log changes to atomic memory.\n+                if log::log_enabled!(log::Level::Trace) {\n+                    for (_offset, range) in alloc_meta.alloc_ranges.borrow().iter(base_offset, size)\n+                    {\n+                        log::trace!(\n+                            \"Updated atomic memory({:?}, size={}) to {:#?}\",\n+                            place.ptr,\n+                            size.bytes(),\n+                            range.atomic_ops\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Extra metadata associated with a thread.\n+#[derive(Debug, Clone, Default)]\n+struct ThreadExtraState {\n+    /// The current vector index in use by the\n+    /// thread currently, this is set to None\n+    /// after the vector index has been re-used\n+    /// and hence the value will never need to be\n+    /// read during data-race reporting.\n+    vector_index: Option<VectorIdx>,\n+\n+    /// Thread termination vector clock, this\n+    /// is set on thread termination and is used\n+    /// for joining on threads since the vector_index\n+    /// may be re-used when the join operation occurs.\n+    termination_vector_clock: Option<VClock>,\n+}\n+\n+/// Global data-race detection state, contains the currently\n+/// executing thread as well as the vector-clocks associated\n+/// with each of the threads.\n+// FIXME: it is probably better to have one large RefCell, than to have so many small ones.\n+#[derive(Debug, Clone)]\n+pub struct GlobalState {\n+    /// Set to true once the first additional\n+    /// thread has launched, due to the dependency\n+    /// between before and after a thread launch.\n+    /// Any data-races must be recorded after this\n+    /// so concurrent execution can ignore recording\n+    /// any data-races.\n+    multi_threaded: Cell<bool>,\n+\n+    /// A flag to mark we are currently performing\n+    /// a data race free action (such as atomic access)\n+    /// to supress the race detector\n+    ongoing_action_data_race_free: Cell<bool>,\n+\n+    /// Mapping of a vector index to a known set of thread\n+    /// clocks, this is not directly mapping from a thread id\n+    /// since it may refer to multiple threads.\n+    vector_clocks: RefCell<IndexVec<VectorIdx, ThreadClockSet>>,\n+\n+    /// Mapping of a given vector index to the current thread\n+    /// that the execution is representing, this may change\n+    /// if a vector index is re-assigned to a new thread.\n+    vector_info: RefCell<IndexVec<VectorIdx, ThreadId>>,\n+\n+    /// The mapping of a given thread to associated thread metadata.\n+    thread_info: RefCell<IndexVec<ThreadId, ThreadExtraState>>,\n+\n+    /// Potential vector indices that could be re-used on thread creation\n+    /// values are inserted here on after the thread has terminated and\n+    /// been joined with, and hence may potentially become free\n+    /// for use as the index for a new thread.\n+    /// Elements in this set may still require the vector index to\n+    /// report data-races, and can only be re-used after all\n+    /// active vector-clocks catch up with the threads timestamp.\n+    reuse_candidates: RefCell<FxHashSet<VectorIdx>>,\n+\n+    /// This contains threads that have terminated, but not yet joined\n+    /// and so cannot become re-use candidates until a join operation\n+    /// occurs.\n+    /// The associated vector index will be moved into re-use candidates\n+    /// after the join operation occurs.\n+    terminated_threads: RefCell<FxHashMap<ThreadId, VectorIdx>>,\n+\n+    /// The timestamp of last SC fence performed by each thread\n+    last_sc_fence: RefCell<VClock>,\n+\n+    /// The timestamp of last SC write performed by each thread\n+    last_sc_write: RefCell<VClock>,\n+\n+    /// Track when an outdated (weak memory) load happens.\n+    pub track_outdated_loads: bool,\n+}\n+\n+impl GlobalState {\n+    /// Create a new global state, setup with just thread-id=0\n+    /// advanced to timestamp = 1.\n+    pub fn new(config: &MiriConfig) -> Self {\n+        let mut global_state = GlobalState {\n+            multi_threaded: Cell::new(false),\n+            ongoing_action_data_race_free: Cell::new(false),\n+            vector_clocks: RefCell::new(IndexVec::new()),\n+            vector_info: RefCell::new(IndexVec::new()),\n+            thread_info: RefCell::new(IndexVec::new()),\n+            reuse_candidates: RefCell::new(FxHashSet::default()),\n+            terminated_threads: RefCell::new(FxHashMap::default()),\n+            last_sc_fence: RefCell::new(VClock::default()),\n+            last_sc_write: RefCell::new(VClock::default()),\n+            track_outdated_loads: config.track_outdated_loads,\n+        };\n+\n+        // Setup the main-thread since it is not explicitly created:\n+        // uses vector index and thread-id 0.\n+        let index = global_state.vector_clocks.get_mut().push(ThreadClockSet::default());\n+        global_state.vector_info.get_mut().push(ThreadId::new(0));\n+        global_state\n+            .thread_info\n+            .get_mut()\n+            .push(ThreadExtraState { vector_index: Some(index), termination_vector_clock: None });\n+\n+        global_state\n+    }\n+\n+    // We perform data race detection when there are more than 1 active thread\n+    // and we have not temporarily disabled race detection to perform something\n+    // data race free\n+    fn race_detecting(&self) -> bool {\n+        self.multi_threaded.get() && !self.ongoing_action_data_race_free.get()\n+    }\n+\n+    pub fn ongoing_action_data_race_free(&self) -> bool {\n+        self.ongoing_action_data_race_free.get()\n+    }\n+\n+    // Try to find vector index values that can potentially be re-used\n+    // by a new thread instead of a new vector index being created.\n+    fn find_vector_index_reuse_candidate(&self) -> Option<VectorIdx> {\n+        let mut reuse = self.reuse_candidates.borrow_mut();\n+        let vector_clocks = self.vector_clocks.borrow();\n+        let vector_info = self.vector_info.borrow();\n+        let terminated_threads = self.terminated_threads.borrow();\n+        for &candidate in reuse.iter() {\n+            let target_timestamp = vector_clocks[candidate].clock[candidate];\n+            if vector_clocks.iter_enumerated().all(|(clock_idx, clock)| {\n+                // The thread happens before the clock, and hence cannot report\n+                // a data-race with this the candidate index.\n+                let no_data_race = clock.clock[candidate] >= target_timestamp;\n+\n+                // The vector represents a thread that has terminated and hence cannot\n+                // report a data-race with the candidate index.\n+                let thread_id = vector_info[clock_idx];\n+                let vector_terminated =\n+                    reuse.contains(&clock_idx) || terminated_threads.contains_key(&thread_id);\n+\n+                // The vector index cannot report a race with the candidate index\n+                // and hence allows the candidate index to be re-used.\n+                no_data_race || vector_terminated\n+            }) {\n+                // All vector clocks for each vector index are equal to\n+                // the target timestamp, and the thread is known to have\n+                // terminated, therefore this vector clock index cannot\n+                // report any more data-races.\n+                assert!(reuse.remove(&candidate));\n+                return Some(candidate);\n+            }\n+        }\n+        None\n+    }\n+\n+    // Hook for thread creation, enabled multi-threaded execution and marks\n+    // the current thread timestamp as happening-before the current thread.\n+    #[inline]\n+    pub fn thread_created(&mut self, thread_mgr: &ThreadManager<'_, '_>, thread: ThreadId) {\n+        let current_index = self.current_index(thread_mgr);\n+\n+        // Enable multi-threaded execution, there are now at least two threads\n+        // so data-races are now possible.\n+        self.multi_threaded.set(true);\n+\n+        // Load and setup the associated thread metadata\n+        let mut thread_info = self.thread_info.borrow_mut();\n+        thread_info.ensure_contains_elem(thread, Default::default);\n+\n+        // Assign a vector index for the thread, attempting to re-use an old\n+        // vector index that can no longer report any data-races if possible.\n+        let created_index = if let Some(reuse_index) = self.find_vector_index_reuse_candidate() {\n+            // Now re-configure the re-use candidate, increment the clock\n+            // for the new sync use of the vector.\n+            let vector_clocks = self.vector_clocks.get_mut();\n+            vector_clocks[reuse_index].increment_clock(reuse_index);\n+\n+            // Locate the old thread the vector was associated with and update\n+            // it to represent the new thread instead.\n+            let vector_info = self.vector_info.get_mut();\n+            let old_thread = vector_info[reuse_index];\n+            vector_info[reuse_index] = thread;\n+\n+            // Mark the thread the vector index was associated with as no longer\n+            // representing a thread index.\n+            thread_info[old_thread].vector_index = None;\n+\n+            reuse_index\n+        } else {\n+            // No vector re-use candidates available, instead create\n+            // a new vector index.\n+            let vector_info = self.vector_info.get_mut();\n+            vector_info.push(thread)\n+        };\n+\n+        log::trace!(\"Creating thread = {:?} with vector index = {:?}\", thread, created_index);\n+\n+        // Mark the chosen vector index as in use by the thread.\n+        thread_info[thread].vector_index = Some(created_index);\n+\n+        // Create a thread clock set if applicable.\n+        let vector_clocks = self.vector_clocks.get_mut();\n+        if created_index == vector_clocks.next_index() {\n+            vector_clocks.push(ThreadClockSet::default());\n+        }\n+\n+        // Now load the two clocks and configure the initial state.\n+        let (current, created) = vector_clocks.pick2_mut(current_index, created_index);\n+\n+        // Join the created with current, since the current threads\n+        // previous actions happen-before the created thread.\n+        created.join_with(current);\n+\n+        // Advance both threads after the synchronized operation.\n+        // Both operations are considered to have release semantics.\n+        current.increment_clock(current_index);\n+        created.increment_clock(created_index);\n+    }\n+\n+    /// Hook on a thread join to update the implicit happens-before relation between the joined\n+    /// thread (the joinee, the thread that someone waited on) and the current thread (the joiner,\n+    /// the thread who was waiting).\n+    #[inline]\n+    pub fn thread_joined(\n+        &mut self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        joiner: ThreadId,\n+        joinee: ThreadId,\n+    ) {\n+        let clocks_vec = self.vector_clocks.get_mut();\n+        let thread_info = self.thread_info.get_mut();\n+\n+        // Load the vector clock of the current thread.\n+        let current_index = thread_info[joiner]\n+            .vector_index\n+            .expect(\"Performed thread join on thread with no assigned vector\");\n+        let current = &mut clocks_vec[current_index];\n+\n+        // Load the associated vector clock for the terminated thread.\n+        let join_clock = thread_info[joinee]\n+            .termination_vector_clock\n+            .as_ref()\n+            .expect(\"Joined with thread but thread has not terminated\");\n+\n+        // The join thread happens-before the current thread\n+        // so update the current vector clock.\n+        // Is not a release operation so the clock is not incremented.\n+        current.clock.join(join_clock);\n+\n+        // Check the number of live threads, if the value is 1\n+        // then test for potentially disabling multi-threaded execution.\n+        if thread_mgr.get_live_thread_count() == 1 {\n+            // May potentially be able to disable multi-threaded execution.\n+            let current_clock = &clocks_vec[current_index];\n+            if clocks_vec\n+                .iter_enumerated()\n+                .all(|(idx, clocks)| clocks.clock[idx] <= current_clock.clock[idx])\n+            {\n+                // All thread terminations happen-before the current clock\n+                // therefore no data-races can be reported until a new thread\n+                // is created, so disable multi-threaded execution.\n+                self.multi_threaded.set(false);\n+            }\n+        }\n+\n+        // If the thread is marked as terminated but not joined\n+        // then move the thread to the re-use set.\n+        let termination = self.terminated_threads.get_mut();\n+        if let Some(index) = termination.remove(&joinee) {\n+            let reuse = self.reuse_candidates.get_mut();\n+            reuse.insert(index);\n+        }\n+    }\n+\n+    /// On thread termination, the vector-clock may re-used\n+    /// in the future once all remaining thread-clocks catch\n+    /// up with the time index of the terminated thread.\n+    /// This assigns thread termination with a unique index\n+    /// which will be used to join the thread\n+    /// This should be called strictly before any calls to\n+    /// `thread_joined`.\n+    #[inline]\n+    pub fn thread_terminated(&mut self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let current_index = self.current_index(thread_mgr);\n+\n+        // Increment the clock to a unique termination timestamp.\n+        let vector_clocks = self.vector_clocks.get_mut();\n+        let current_clocks = &mut vector_clocks[current_index];\n+        current_clocks.increment_clock(current_index);\n+\n+        // Load the current thread id for the executing vector.\n+        let vector_info = self.vector_info.get_mut();\n+        let current_thread = vector_info[current_index];\n+\n+        // Load the current thread metadata, and move to a terminated\n+        // vector state. Setting up the vector clock all join operations\n+        // will use.\n+        let thread_info = self.thread_info.get_mut();\n+        let current = &mut thread_info[current_thread];\n+        current.termination_vector_clock = Some(current_clocks.clock.clone());\n+\n+        // Add this thread as a candidate for re-use after a thread join\n+        // occurs.\n+        let termination = self.terminated_threads.get_mut();\n+        termination.insert(current_thread, current_index);\n+    }\n+\n+    /// Attempt to perform a synchronized operation, this\n+    /// will perform no operation if multi-threading is\n+    /// not currently enabled.\n+    /// Otherwise it will increment the clock for the current\n+    /// vector before and after the operation for data-race\n+    /// detection between any happens-before edges the\n+    /// operation may create.\n+    fn maybe_perform_sync_operation<'tcx>(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        op: impl FnOnce(VectorIdx, RefMut<'_, ThreadClockSet>) -> InterpResult<'tcx, bool>,\n+    ) -> InterpResult<'tcx> {\n+        if self.multi_threaded.get() {\n+            let (index, clocks) = self.current_thread_state_mut(thread_mgr);\n+            if op(index, clocks)? {\n+                let (_, mut clocks) = self.current_thread_state_mut(thread_mgr);\n+                clocks.increment_clock(index);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Internal utility to identify a thread stored internally\n+    /// returns the id and the name for better diagnostics.\n+    fn print_thread_metadata(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        vector: VectorIdx,\n+    ) -> String {\n+        let thread = self.vector_info.borrow()[vector];\n+        let thread_name = thread_mgr.get_thread_name(thread);\n+        format!(\"thread `{}`\", String::from_utf8_lossy(thread_name))\n+    }\n+\n+    /// Acquire a lock, express that the previous call of\n+    /// `validate_lock_release` must happen before this.\n+    /// As this is an acquire operation, the thread timestamp is not\n+    /// incremented.\n+    pub fn validate_lock_acquire(&self, lock: &VClock, thread: ThreadId) {\n+        let (_, mut clocks) = self.load_thread_state_mut(thread);\n+        clocks.clock.join(lock);\n+    }\n+\n+    /// Release a lock handle, express that this happens-before\n+    /// any subsequent calls to `validate_lock_acquire`.\n+    /// For normal locks this should be equivalent to `validate_lock_release_shared`\n+    /// since an acquire operation should have occurred before, however\n+    /// for futex & condvar operations this is not the case and this\n+    /// operation must be used.\n+    pub fn validate_lock_release(&self, lock: &mut VClock, thread: ThreadId) {\n+        let (index, mut clocks) = self.load_thread_state_mut(thread);\n+        lock.clone_from(&clocks.clock);\n+        clocks.increment_clock(index);\n+    }\n+\n+    /// Release a lock handle, express that this happens-before\n+    /// any subsequent calls to `validate_lock_acquire` as well\n+    /// as any previous calls to this function after any\n+    /// `validate_lock_release` calls.\n+    /// For normal locks this should be equivalent to `validate_lock_release`.\n+    /// This function only exists for joining over the set of concurrent readers\n+    /// in a read-write lock and should not be used for anything else.\n+    pub fn validate_lock_release_shared(&self, lock: &mut VClock, thread: ThreadId) {\n+        let (index, mut clocks) = self.load_thread_state_mut(thread);\n+        lock.join(&clocks.clock);\n+        clocks.increment_clock(index);\n+    }\n+\n+    /// Load the vector index used by the given thread as well as the set of vector clocks\n+    /// used by the thread.\n+    #[inline]\n+    fn load_thread_state_mut(&self, thread: ThreadId) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n+        let index = self.thread_info.borrow()[thread]\n+            .vector_index\n+            .expect(\"Loading thread state for thread with no assigned vector\");\n+        let ref_vector = self.vector_clocks.borrow_mut();\n+        let clocks = RefMut::map(ref_vector, |vec| &mut vec[index]);\n+        (index, clocks)\n+    }\n+\n+    /// Load the current vector clock in use and the current set of thread clocks\n+    /// in use for the vector.\n+    #[inline]\n+    pub(super) fn current_thread_state(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> (VectorIdx, Ref<'_, ThreadClockSet>) {\n+        let index = self.current_index(thread_mgr);\n+        let ref_vector = self.vector_clocks.borrow();\n+        let clocks = Ref::map(ref_vector, |vec| &vec[index]);\n+        (index, clocks)\n+    }\n+\n+    /// Load the current vector clock in use and the current set of thread clocks\n+    /// in use for the vector mutably for modification.\n+    #[inline]\n+    pub(super) fn current_thread_state_mut(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n+        let index = self.current_index(thread_mgr);\n+        let ref_vector = self.vector_clocks.borrow_mut();\n+        let clocks = RefMut::map(ref_vector, |vec| &mut vec[index]);\n+        (index, clocks)\n+    }\n+\n+    /// Return the current thread, should be the same\n+    /// as the data-race active thread.\n+    #[inline]\n+    fn current_index(&self, thread_mgr: &ThreadManager<'_, '_>) -> VectorIdx {\n+        let active_thread_id = thread_mgr.get_active_thread_id();\n+        self.thread_info.borrow()[active_thread_id]\n+            .vector_index\n+            .expect(\"active thread has no assigned vector\")\n+    }\n+\n+    // SC ATOMIC STORE rule in the paper.\n+    pub(super) fn sc_write(&self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let (index, clocks) = self.current_thread_state(thread_mgr);\n+        self.last_sc_write.borrow_mut().set_at_index(&clocks.clock, index);\n+    }\n+\n+    // SC ATOMIC READ rule in the paper.\n+    pub(super) fn sc_read(&self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let (.., mut clocks) = self.current_thread_state_mut(thread_mgr);\n+        clocks.read_seqcst.join(&self.last_sc_fence.borrow());\n+    }\n+}"}, {"sha": "61ef3d5640e00cd4d0df402332b31bd5f78b7fda", "filename": "src/tools/miri/src/concurrency/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,6 @@\n+pub mod data_race;\n+mod range_object_map;\n+pub mod sync;\n+pub mod thread;\n+mod vector_clock;\n+pub mod weak_memory;"}, {"sha": "50d3f8c9b20eaadf525c74d7e6f321438ad3e66f", "filename": "src/tools/miri/src/concurrency/range_object_map.rs", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,277 @@\n+//! Implements a map from allocation ranges to data. This is somewhat similar to RangeMap, but the\n+//! ranges and data are discrete and non-splittable -- they represent distinct \"objects\". An\n+//! allocation in the map will always have the same range until explicitly removed\n+\n+use rustc_target::abi::Size;\n+use std::ops::{Index, IndexMut, Range};\n+\n+use rustc_const_eval::interpret::AllocRange;\n+\n+#[derive(Clone, Debug)]\n+struct Elem<T> {\n+    /// The range covered by this element; never empty.\n+    range: AllocRange,\n+    /// The data stored for this element.\n+    data: T,\n+}\n+\n+/// Index of an allocation within the map\n+type Position = usize;\n+\n+#[derive(Clone, Debug)]\n+pub struct RangeObjectMap<T> {\n+    v: Vec<Elem<T>>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum AccessType {\n+    /// The access perfectly overlaps (same offset and range) with the exsiting allocation\n+    PerfectlyOverlapping(Position),\n+    /// The access does not touch any exising allocation\n+    Empty(Position),\n+    /// The access overlaps with one or more existing allocations\n+    ImperfectlyOverlapping(Range<Position>),\n+}\n+\n+impl<T> RangeObjectMap<T> {\n+    pub fn new() -> Self {\n+        Self { v: Vec::new() }\n+    }\n+\n+    /// Finds the position of the allocation containing the given offset. If the offset is not\n+    /// in an existing allocation, then returns Err containing the position\n+    /// where such allocation should be inserted\n+    fn find_offset(&self, offset: Size) -> Result<Position, Position> {\n+        // We do a binary search.\n+        let mut left = 0usize; // inclusive\n+        let mut right = self.v.len(); // exclusive\n+        loop {\n+            if left == right {\n+                // No element contains the given offset. But the\n+                // position is where such element should be placed at.\n+                return Err(left);\n+            }\n+            let candidate = left.checked_add(right).unwrap() / 2;\n+            let elem = &self.v[candidate];\n+            if offset < elem.range.start {\n+                // We are too far right (offset is further left).\n+                debug_assert!(candidate < right); // we are making progress\n+                right = candidate;\n+            } else if offset >= elem.range.end() {\n+                // We are too far left (offset is further right).\n+                debug_assert!(candidate >= left); // we are making progress\n+                left = candidate + 1;\n+            } else {\n+                // This is it!\n+                return Ok(candidate);\n+            }\n+        }\n+    }\n+\n+    /// Determines whether a given access on `range` overlaps with\n+    /// an existing allocation\n+    pub fn access_type(&self, range: AllocRange) -> AccessType {\n+        match self.find_offset(range.start) {\n+            Ok(pos) => {\n+                // Start of the range belongs to an existing object, now let's check the overlapping situation\n+                let elem = &self.v[pos];\n+                // FIXME: derive Eq for AllocRange in rustc\n+                if elem.range.start == range.start && elem.range.size == range.size {\n+                    // Happy case: perfectly overlapping access\n+                    AccessType::PerfectlyOverlapping(pos)\n+                } else {\n+                    // FIXME: add a last() method to AllocRange that returns the last inclusive offset (end() is exclusive)\n+                    let end_pos = match self.find_offset(range.end() - Size::from_bytes(1)) {\n+                        // If the end lands in an existing object, add one to get the exclusive position\n+                        Ok(inclusive_pos) => inclusive_pos + 1,\n+                        Err(exclusive_pos) => exclusive_pos,\n+                    };\n+\n+                    AccessType::ImperfectlyOverlapping(pos..end_pos)\n+                }\n+            }\n+            Err(pos) => {\n+                // Start of the range doesn't belong to an existing object\n+                match self.find_offset(range.end() - Size::from_bytes(1)) {\n+                    // Neither does the end\n+                    Err(end_pos) =>\n+                        if pos == end_pos {\n+                            // There's nothing between the start and the end, so the range thing is empty\n+                            AccessType::Empty(pos)\n+                        } else {\n+                            // Otherwise we have entirely covered an existing object\n+                            AccessType::ImperfectlyOverlapping(pos..end_pos)\n+                        },\n+                    // Otherwise at least part of it overlaps with something else\n+                    Ok(end_pos) => AccessType::ImperfectlyOverlapping(pos..end_pos + 1),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Inserts an object and its occupied range at given position\n+    // The Position can be calculated from AllocRange, but the only user of AllocationMap\n+    // always calls access_type before calling insert/index/index_mut, and we don't\n+    // want to repeat the binary search on each time, so we ask the caller to supply Position\n+    pub fn insert_at_pos(&mut self, pos: Position, range: AllocRange, data: T) {\n+        self.v.insert(pos, Elem { range, data });\n+        // If we aren't the first element, then our start must be greater than the preivous element's end\n+        if pos > 0 {\n+            assert!(self.v[pos - 1].range.end() <= range.start);\n+        }\n+        // If we aren't the last element, then our end must be smaller than next element's start\n+        if pos < self.v.len() - 1 {\n+            assert!(range.end() <= self.v[pos + 1].range.start);\n+        }\n+    }\n+\n+    pub fn remove_pos_range(&mut self, pos_range: Range<Position>) {\n+        self.v.drain(pos_range);\n+    }\n+\n+    pub fn remove_from_pos(&mut self, pos: Position) {\n+        self.v.remove(pos);\n+    }\n+}\n+\n+impl<T> Index<Position> for RangeObjectMap<T> {\n+    type Output = T;\n+\n+    fn index(&self, pos: Position) -> &Self::Output {\n+        &self.v[pos].data\n+    }\n+}\n+\n+impl<T> IndexMut<Position> for RangeObjectMap<T> {\n+    fn index_mut(&mut self, pos: Position) -> &mut Self::Output {\n+        &mut self.v[pos].data\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use rustc_const_eval::interpret::alloc_range;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn empty_map() {\n+        // FIXME: make Size::from_bytes const\n+        let four = Size::from_bytes(4);\n+        let map = RangeObjectMap::<()>::new();\n+\n+        // Correctly tells where we should insert the first element (at position 0)\n+        assert_eq!(map.find_offset(Size::from_bytes(3)), Err(0));\n+\n+        // Correctly tells the access type along with the supposed position\n+        assert_eq!(map.access_type(alloc_range(Size::ZERO, four)), AccessType::Empty(0));\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn no_overlapping_inserts() {\n+        let four = Size::from_bytes(4);\n+\n+        let mut map = RangeObjectMap::<&str>::new();\n+\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 2 3 4 5 6 7 8 9 a b c d\n+        map.insert_at_pos(0, alloc_range(four, four), \"#\");\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 ^ ^ ^ ^ 5 6 7 8 9 a b c d\n+        map.insert_at_pos(0, alloc_range(Size::from_bytes(1), four), \"@\");\n+    }\n+\n+    #[test]\n+    fn boundaries() {\n+        let four = Size::from_bytes(4);\n+\n+        let mut map = RangeObjectMap::<&str>::new();\n+\n+        // |#|#|#|#|_|_|...\n+        //  0 1 2 3 4 5\n+        map.insert_at_pos(0, alloc_range(Size::ZERO, four), \"#\");\n+        // |#|#|#|#|_|_|...\n+        //  0 1 2 3 ^ 5\n+        assert_eq!(map.find_offset(four), Err(1));\n+        // |#|#|#|#|_|_|_|_|_|...\n+        //  0 1 2 3 ^ ^ ^ ^ 8\n+        assert_eq!(map.access_type(alloc_range(four, four)), AccessType::Empty(1));\n+\n+        let eight = Size::from_bytes(8);\n+        // |#|#|#|#|_|_|_|_|@|@|@|@|_|_|...\n+        //  0 1 2 3 4 5 6 7 8 9 a b c d\n+        map.insert_at_pos(1, alloc_range(eight, four), \"@\");\n+        // |#|#|#|#|_|_|_|_|@|@|@|@|_|_|...\n+        //  0 1 2 3 4 5 6 ^ 8 9 a b c d\n+        assert_eq!(map.find_offset(Size::from_bytes(7)), Err(1));\n+        // |#|#|#|#|_|_|_|_|@|@|@|@|_|_|...\n+        //  0 1 2 3 ^ ^ ^ ^ 8 9 a b c d\n+        assert_eq!(map.access_type(alloc_range(four, four)), AccessType::Empty(1));\n+    }\n+\n+    #[test]\n+    fn perfectly_overlapping() {\n+        let four = Size::from_bytes(4);\n+\n+        let mut map = RangeObjectMap::<&str>::new();\n+\n+        // |#|#|#|#|_|_|...\n+        //  0 1 2 3 4 5\n+        map.insert_at_pos(0, alloc_range(Size::ZERO, four), \"#\");\n+        // |#|#|#|#|_|_|...\n+        //  ^ ^ ^ ^ 4 5\n+        assert_eq!(map.find_offset(Size::ZERO), Ok(0));\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::ZERO, four)),\n+            AccessType::PerfectlyOverlapping(0)\n+        );\n+\n+        // |#|#|#|#|@|@|@|@|_|...\n+        //  0 1 2 3 4 5 6 7 8\n+        map.insert_at_pos(1, alloc_range(four, four), \"@\");\n+        // |#|#|#|#|@|@|@|@|_|...\n+        //  0 1 2 3 ^ ^ ^ ^ 8\n+        assert_eq!(map.find_offset(four), Ok(1));\n+        assert_eq!(map.access_type(alloc_range(four, four)), AccessType::PerfectlyOverlapping(1));\n+    }\n+\n+    #[test]\n+    fn straddling() {\n+        let four = Size::from_bytes(4);\n+\n+        let mut map = RangeObjectMap::<&str>::new();\n+\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 2 3 4 5 6 7 8 9 a b c d\n+        map.insert_at_pos(0, alloc_range(four, four), \"#\");\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 ^ ^ ^ ^ 6 7 8 9 a b c d\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::from_bytes(2), four)),\n+            AccessType::ImperfectlyOverlapping(0..1)\n+        );\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 2 3 4 5 ^ ^ ^ ^ a b c d\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::from_bytes(6), four)),\n+            AccessType::ImperfectlyOverlapping(0..1)\n+        );\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 ^ ^ ^ ^ ^ ^ ^ ^ a b c d\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::from_bytes(2), Size::from_bytes(8))),\n+            AccessType::ImperfectlyOverlapping(0..1)\n+        );\n+\n+        // |_|_|_|_|#|#|#|#|_|_|@|@|_|_|...\n+        //  0 1 2 3 4 5 6 7 8 9 a b c d\n+        map.insert_at_pos(1, alloc_range(Size::from_bytes(10), Size::from_bytes(2)), \"@\");\n+        // |_|_|_|_|#|#|#|#|_|_|@|@|_|_|...\n+        //  0 1 2 3 4 5 ^ ^ ^ ^ ^ ^ ^ ^\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::from_bytes(6), Size::from_bytes(8))),\n+            AccessType::ImperfectlyOverlapping(0..2)\n+        );\n+    }\n+}"}, {"sha": "464f452ca76962b6d068939581665964e599b454", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "added", "additions": 584, "deletions": 0, "changes": 584, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,584 @@\n+use std::collections::{hash_map::Entry, VecDeque};\n+use std::num::NonZeroU32;\n+use std::ops::Not;\n+\n+use log::trace;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::vec::{Idx, IndexVec};\n+\n+use super::vector_clock::VClock;\n+use crate::*;\n+\n+/// We cannot use the `newtype_index!` macro because we have to use 0 as a\n+/// sentinel value meaning that the identifier is not assigned. This is because\n+/// the pthreads static initializers initialize memory with zeros (see the\n+/// `src/shims/sync.rs` file).\n+macro_rules! declare_id {\n+    ($name: ident) => {\n+        /// 0 is used to indicate that the id was not yet assigned and,\n+        /// therefore, is not a valid identifier.\n+        #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n+        pub struct $name(NonZeroU32);\n+\n+        impl $name {\n+            // Panics if `id == 0`.\n+            pub fn from_u32(id: u32) -> Self {\n+                Self(NonZeroU32::new(id).unwrap())\n+            }\n+        }\n+\n+        impl Idx for $name {\n+            fn new(idx: usize) -> Self {\n+                // We use 0 as a sentinel value (see the comment above) and,\n+                // therefore, need to shift by one when converting from an index\n+                // into a vector.\n+                let shifted_idx = u32::try_from(idx).unwrap().checked_add(1).unwrap();\n+                $name(NonZeroU32::new(shifted_idx).unwrap())\n+            }\n+            fn index(self) -> usize {\n+                // See the comment in `Self::new`.\n+                // (This cannot underflow because self is NonZeroU32.)\n+                usize::try_from(self.0.get() - 1).unwrap()\n+            }\n+        }\n+\n+        impl $name {\n+            pub fn to_u32_scalar(&self) -> Scalar<Provenance> {\n+                Scalar::from_u32(self.0.get())\n+            }\n+        }\n+    };\n+}\n+\n+declare_id!(MutexId);\n+\n+/// The mutex state.\n+#[derive(Default, Debug)]\n+struct Mutex {\n+    /// The thread that currently owns the lock.\n+    owner: Option<ThreadId>,\n+    /// How many times the mutex was locked by the owner.\n+    lock_count: usize,\n+    /// The queue of threads waiting for this mutex.\n+    queue: VecDeque<ThreadId>,\n+    /// Data race handle, this tracks the happens-before\n+    /// relationship between each mutex access. It is\n+    /// released to during unlock and acquired from during\n+    /// locking, and therefore stores the clock of the last\n+    /// thread to release this mutex.\n+    data_race: VClock,\n+}\n+\n+declare_id!(RwLockId);\n+\n+/// The read-write lock state.\n+#[derive(Default, Debug)]\n+struct RwLock {\n+    /// The writer thread that currently owns the lock.\n+    writer: Option<ThreadId>,\n+    /// The readers that currently own the lock and how many times they acquired\n+    /// the lock.\n+    readers: FxHashMap<ThreadId, usize>,\n+    /// The queue of writer threads waiting for this lock.\n+    writer_queue: VecDeque<ThreadId>,\n+    /// The queue of reader threads waiting for this lock.\n+    reader_queue: VecDeque<ThreadId>,\n+    /// Data race handle for writers, tracks the happens-before\n+    /// ordering between each write access to a rwlock and is updated\n+    /// after a sequence of concurrent readers to track the happens-\n+    /// before ordering between the set of previous readers and\n+    /// the current writer.\n+    /// Contains the clock of the last thread to release a writer\n+    /// lock or the joined clock of the set of last threads to release\n+    /// shared reader locks.\n+    data_race: VClock,\n+    /// Data race handle for readers, this is temporary storage\n+    /// for the combined happens-before ordering for between all\n+    /// concurrent readers and the next writer, and the value\n+    /// is stored to the main data_race variable once all\n+    /// readers are finished.\n+    /// Has to be stored separately since reader lock acquires\n+    /// must load the clock of the last write and must not\n+    /// add happens-before orderings between shared reader\n+    /// locks.\n+    data_race_reader: VClock,\n+}\n+\n+declare_id!(CondvarId);\n+\n+/// A thread waiting on a conditional variable.\n+#[derive(Debug)]\n+struct CondvarWaiter {\n+    /// The thread that is waiting on this variable.\n+    thread: ThreadId,\n+    /// The mutex on which the thread is waiting.\n+    mutex: MutexId,\n+}\n+\n+/// The conditional variable state.\n+#[derive(Default, Debug)]\n+struct Condvar {\n+    waiters: VecDeque<CondvarWaiter>,\n+    /// Tracks the happens-before relationship\n+    /// between a cond-var signal and a cond-var\n+    /// wait during a non-suprious signal event.\n+    /// Contains the clock of the last thread to\n+    /// perform a futex-signal.\n+    data_race: VClock,\n+}\n+\n+/// The futex state.\n+#[derive(Default, Debug)]\n+struct Futex {\n+    waiters: VecDeque<FutexWaiter>,\n+    /// Tracks the happens-before relationship\n+    /// between a futex-wake and a futex-wait\n+    /// during a non-spurious wake event.\n+    /// Contains the clock of the last thread to\n+    /// perform a futex-wake.\n+    data_race: VClock,\n+}\n+\n+/// A thread waiting on a futex.\n+#[derive(Debug)]\n+struct FutexWaiter {\n+    /// The thread that is waiting on this futex.\n+    thread: ThreadId,\n+    /// The bitset used by FUTEX_*_BITSET, or u32::MAX for other operations.\n+    bitset: u32,\n+}\n+\n+/// The state of all synchronization variables.\n+#[derive(Default, Debug)]\n+pub(crate) struct SynchronizationState {\n+    mutexes: IndexVec<MutexId, Mutex>,\n+    rwlocks: IndexVec<RwLockId, RwLock>,\n+    condvars: IndexVec<CondvarId, Condvar>,\n+    futexes: FxHashMap<u64, Futex>,\n+}\n+\n+// Private extension trait for local helper methods\n+impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Take a reader out of the queue waiting for the lock.\n+    /// Returns `true` if some thread got the rwlock.\n+    #[inline]\n+    fn rwlock_dequeue_and_lock_reader(&mut self, id: RwLockId) -> bool {\n+        let this = self.eval_context_mut();\n+        if let Some(reader) = this.machine.threads.sync.rwlocks[id].reader_queue.pop_front() {\n+            this.unblock_thread(reader);\n+            this.rwlock_reader_lock(id, reader);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Take the writer out of the queue waiting for the lock.\n+    /// Returns `true` if some thread got the rwlock.\n+    #[inline]\n+    fn rwlock_dequeue_and_lock_writer(&mut self, id: RwLockId) -> bool {\n+        let this = self.eval_context_mut();\n+        if let Some(writer) = this.machine.threads.sync.rwlocks[id].writer_queue.pop_front() {\n+            this.unblock_thread(writer);\n+            this.rwlock_writer_lock(id, writer);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Take a thread out of the queue waiting for the mutex, and lock\n+    /// the mutex for it. Returns `true` if some thread has the mutex now.\n+    #[inline]\n+    fn mutex_dequeue_and_lock(&mut self, id: MutexId) -> bool {\n+        let this = self.eval_context_mut();\n+        if let Some(thread) = this.machine.threads.sync.mutexes[id].queue.pop_front() {\n+            this.unblock_thread(thread);\n+            this.mutex_lock(id, thread);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+// Public interface to synchronization primitives. Please note that in most\n+// cases, the function calls are infallible and it is the client's (shim\n+// implementation's) responsibility to detect and deal with erroneous\n+// situations.\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    #[inline]\n+    /// Create state for a new mutex.\n+    fn mutex_create(&mut self) -> MutexId {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.sync.mutexes.push(Default::default())\n+    }\n+\n+    #[inline]\n+    /// Provides the closure with the next MutexId. Creates that mutex if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn mutex_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, MutexId>\n+    where\n+        F: FnOnce(&mut MiriInterpCx<'mir, 'tcx>, MutexId) -> InterpResult<'tcx, Option<MutexId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.mutexes.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.mutexes.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n+    #[inline]\n+    /// Get the id of the thread that currently owns this lock.\n+    fn mutex_get_owner(&mut self, id: MutexId) -> ThreadId {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.mutexes[id].owner.unwrap()\n+    }\n+\n+    #[inline]\n+    /// Check if locked.\n+    fn mutex_is_locked(&self, id: MutexId) -> bool {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.mutexes[id].owner.is_some()\n+    }\n+\n+    /// Lock by setting the mutex owner and increasing the lock count.\n+    fn mutex_lock(&mut self, id: MutexId, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        let mutex = &mut this.machine.threads.sync.mutexes[id];\n+        if let Some(current_owner) = mutex.owner {\n+            assert_eq!(thread, current_owner, \"mutex already locked by another thread\");\n+            assert!(\n+                mutex.lock_count > 0,\n+                \"invariant violation: lock_count == 0 iff the thread is unlocked\"\n+            );\n+        } else {\n+            mutex.owner = Some(thread);\n+        }\n+        mutex.lock_count = mutex.lock_count.checked_add(1).unwrap();\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_acquire(&mutex.data_race, thread);\n+        }\n+    }\n+\n+    /// Try unlocking by decreasing the lock count and returning the old lock\n+    /// count. If the lock count reaches 0, release the lock and potentially\n+    /// give to a new owner. If the lock was not locked by `expected_owner`,\n+    /// return `None`.\n+    fn mutex_unlock(&mut self, id: MutexId, expected_owner: ThreadId) -> Option<usize> {\n+        let this = self.eval_context_mut();\n+        let mutex = &mut this.machine.threads.sync.mutexes[id];\n+        if let Some(current_owner) = mutex.owner {\n+            // Mutex is locked.\n+            if current_owner != expected_owner {\n+                // Only the owner can unlock the mutex.\n+                return None;\n+            }\n+            let old_lock_count = mutex.lock_count;\n+            mutex.lock_count = old_lock_count\n+                .checked_sub(1)\n+                .expect(\"invariant violation: lock_count == 0 iff the thread is unlocked\");\n+            if mutex.lock_count == 0 {\n+                mutex.owner = None;\n+                // The mutex is completely unlocked. Try transfering ownership\n+                // to another thread.\n+                if let Some(data_race) = &this.machine.data_race {\n+                    data_race.validate_lock_release(&mut mutex.data_race, current_owner);\n+                }\n+                this.mutex_dequeue_and_lock(id);\n+            }\n+            Some(old_lock_count)\n+        } else {\n+            // Mutex is not locked.\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    /// Put the thread into the queue waiting for the mutex.\n+    fn mutex_enqueue_and_block(&mut self, id: MutexId, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        assert!(this.mutex_is_locked(id), \"queing on unlocked mutex\");\n+        this.machine.threads.sync.mutexes[id].queue.push_back(thread);\n+        this.block_thread(thread);\n+    }\n+\n+    #[inline]\n+    /// Create state for a new read write lock.\n+    fn rwlock_create(&mut self) -> RwLockId {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.sync.rwlocks.push(Default::default())\n+    }\n+\n+    #[inline]\n+    /// Provides the closure with the next RwLockId. Creates that RwLock if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn rwlock_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, RwLockId>\n+    where\n+        F: FnOnce(&mut MiriInterpCx<'mir, 'tcx>, RwLockId) -> InterpResult<'tcx, Option<RwLockId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.rwlocks.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.rwlocks.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n+    #[inline]\n+    /// Check if locked.\n+    fn rwlock_is_locked(&self, id: RwLockId) -> bool {\n+        let this = self.eval_context_ref();\n+        let rwlock = &this.machine.threads.sync.rwlocks[id];\n+        trace!(\n+            \"rwlock_is_locked: {:?} writer is {:?} and there are {} reader threads (some of which could hold multiple read locks)\",\n+            id,\n+            rwlock.writer,\n+            rwlock.readers.len(),\n+        );\n+        rwlock.writer.is_some() || rwlock.readers.is_empty().not()\n+    }\n+\n+    #[inline]\n+    /// Check if write locked.\n+    fn rwlock_is_write_locked(&self, id: RwLockId) -> bool {\n+        let this = self.eval_context_ref();\n+        let rwlock = &this.machine.threads.sync.rwlocks[id];\n+        trace!(\"rwlock_is_write_locked: {:?} writer is {:?}\", id, rwlock.writer);\n+        rwlock.writer.is_some()\n+    }\n+\n+    /// Read-lock the lock by adding the `reader` the list of threads that own\n+    /// this lock.\n+    fn rwlock_reader_lock(&mut self, id: RwLockId, reader: ThreadId) {\n+        let this = self.eval_context_mut();\n+        assert!(!this.rwlock_is_write_locked(id), \"the lock is write locked\");\n+        trace!(\"rwlock_reader_lock: {:?} now also held (one more time) by {:?}\", id, reader);\n+        let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n+        let count = rwlock.readers.entry(reader).or_insert(0);\n+        *count = count.checked_add(1).expect(\"the reader counter overflowed\");\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_acquire(&rwlock.data_race, reader);\n+        }\n+    }\n+\n+    /// Try read-unlock the lock for `reader` and potentially give the lock to a new owner.\n+    /// Returns `true` if succeeded, `false` if this `reader` did not hold the lock.\n+    fn rwlock_reader_unlock(&mut self, id: RwLockId, reader: ThreadId) -> bool {\n+        let this = self.eval_context_mut();\n+        let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n+        match rwlock.readers.entry(reader) {\n+            Entry::Occupied(mut entry) => {\n+                let count = entry.get_mut();\n+                assert!(*count > 0, \"rwlock locked with count == 0\");\n+                *count -= 1;\n+                if *count == 0 {\n+                    trace!(\"rwlock_reader_unlock: {:?} no longer held by {:?}\", id, reader);\n+                    entry.remove();\n+                } else {\n+                    trace!(\"rwlock_reader_unlock: {:?} held one less time by {:?}\", id, reader);\n+                }\n+            }\n+            Entry::Vacant(_) => return false, // we did not even own this lock\n+        }\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release_shared(&mut rwlock.data_race_reader, reader);\n+        }\n+\n+        // The thread was a reader. If the lock is not held any more, give it to a writer.\n+        if this.rwlock_is_locked(id).not() {\n+            // All the readers are finished, so set the writer data-race handle to the value\n+            //  of the union of all reader data race handles, since the set of readers\n+            //  happen-before the writers\n+            let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n+            rwlock.data_race.clone_from(&rwlock.data_race_reader);\n+            this.rwlock_dequeue_and_lock_writer(id);\n+        }\n+        true\n+    }\n+\n+    #[inline]\n+    /// Put the reader in the queue waiting for the lock and block it.\n+    fn rwlock_enqueue_and_block_reader(&mut self, id: RwLockId, reader: ThreadId) {\n+        let this = self.eval_context_mut();\n+        assert!(this.rwlock_is_write_locked(id), \"read-queueing on not write locked rwlock\");\n+        this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n+        this.block_thread(reader);\n+    }\n+\n+    #[inline]\n+    /// Lock by setting the writer that owns the lock.\n+    fn rwlock_writer_lock(&mut self, id: RwLockId, writer: ThreadId) {\n+        let this = self.eval_context_mut();\n+        assert!(!this.rwlock_is_locked(id), \"the rwlock is already locked\");\n+        trace!(\"rwlock_writer_lock: {:?} now held by {:?}\", id, writer);\n+        let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n+        rwlock.writer = Some(writer);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_acquire(&rwlock.data_race, writer);\n+        }\n+    }\n+\n+    #[inline]\n+    /// Try to unlock by removing the writer.\n+    fn rwlock_writer_unlock(&mut self, id: RwLockId, expected_writer: ThreadId) -> bool {\n+        let this = self.eval_context_mut();\n+        let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n+        if let Some(current_writer) = rwlock.writer {\n+            if current_writer != expected_writer {\n+                // Only the owner can unlock the rwlock.\n+                return false;\n+            }\n+            rwlock.writer = None;\n+            trace!(\"rwlock_writer_unlock: {:?} unlocked by {:?}\", id, expected_writer);\n+            // Release memory to both reader and writer vector clocks\n+            //  since this writer happens-before both the union of readers once they are finished\n+            //  and the next writer\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_release(&mut rwlock.data_race, current_writer);\n+                data_race.validate_lock_release(&mut rwlock.data_race_reader, current_writer);\n+            }\n+            // The thread was a writer.\n+            //\n+            // We are prioritizing writers here against the readers. As a\n+            // result, not only readers can starve writers, but also writers can\n+            // starve readers.\n+            if this.rwlock_dequeue_and_lock_writer(id) {\n+                // Someone got the write lock, nice.\n+            } else {\n+                // Give the lock to all readers.\n+                while this.rwlock_dequeue_and_lock_reader(id) {\n+                    // Rinse and repeat.\n+                }\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    /// Put the writer in the queue waiting for the lock.\n+    fn rwlock_enqueue_and_block_writer(&mut self, id: RwLockId, writer: ThreadId) {\n+        let this = self.eval_context_mut();\n+        assert!(this.rwlock_is_locked(id), \"write-queueing on unlocked rwlock\");\n+        this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n+        this.block_thread(writer);\n+    }\n+\n+    #[inline]\n+    /// Create state for a new conditional variable.\n+    fn condvar_create(&mut self) -> CondvarId {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.sync.condvars.push(Default::default())\n+    }\n+\n+    #[inline]\n+    /// Provides the closure with the next CondvarId. Creates that Condvar if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn condvar_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, CondvarId>\n+    where\n+        F: FnOnce(\n+            &mut MiriInterpCx<'mir, 'tcx>,\n+            CondvarId,\n+        ) -> InterpResult<'tcx, Option<CondvarId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.condvars.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.condvars.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n+    #[inline]\n+    /// Is the conditional variable awaited?\n+    fn condvar_is_awaited(&mut self, id: CondvarId) -> bool {\n+        let this = self.eval_context_mut();\n+        !this.machine.threads.sync.condvars[id].waiters.is_empty()\n+    }\n+\n+    /// Mark that the thread is waiting on the conditional variable.\n+    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, mutex: MutexId) {\n+        let this = self.eval_context_mut();\n+        let waiters = &mut this.machine.threads.sync.condvars[id].waiters;\n+        assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n+        waiters.push_back(CondvarWaiter { thread, mutex });\n+    }\n+\n+    /// Wake up some thread (if there is any) sleeping on the conditional\n+    /// variable.\n+    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, MutexId)> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let condvar = &mut this.machine.threads.sync.condvars[id];\n+        let data_race = &this.machine.data_race;\n+\n+        // Each condvar signal happens-before the end of the condvar wake\n+        if let Some(data_race) = data_race {\n+            data_race.validate_lock_release(&mut condvar.data_race, current_thread);\n+        }\n+        condvar.waiters.pop_front().map(|waiter| {\n+            if let Some(data_race) = data_race {\n+                data_race.validate_lock_acquire(&condvar.data_race, waiter.thread);\n+            }\n+            (waiter.thread, waiter.mutex)\n+        })\n+    }\n+\n+    #[inline]\n+    /// Remove the thread from the queue of threads waiting on this conditional variable.\n+    fn condvar_remove_waiter(&mut self, id: CondvarId, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.sync.condvars[id].waiters.retain(|waiter| waiter.thread != thread);\n+    }\n+\n+    fn futex_wait(&mut self, addr: u64, thread: ThreadId, bitset: u32) {\n+        let this = self.eval_context_mut();\n+        let futex = &mut this.machine.threads.sync.futexes.entry(addr).or_default();\n+        let waiters = &mut futex.waiters;\n+        assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n+        waiters.push_back(FutexWaiter { thread, bitset });\n+    }\n+\n+    fn futex_wake(&mut self, addr: u64, bitset: u32) -> Option<ThreadId> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr)?;\n+        let data_race = &this.machine.data_race;\n+\n+        // Each futex-wake happens-before the end of the futex wait\n+        if let Some(data_race) = data_race {\n+            data_race.validate_lock_release(&mut futex.data_race, current_thread);\n+        }\n+\n+        // Wake up the first thread in the queue that matches any of the bits in the bitset.\n+        futex.waiters.iter().position(|w| w.bitset & bitset != 0).map(|i| {\n+            let waiter = futex.waiters.remove(i).unwrap();\n+            if let Some(data_race) = data_race {\n+                data_race.validate_lock_acquire(&futex.data_race, waiter.thread);\n+            }\n+            waiter.thread\n+        })\n+    }\n+\n+    fn futex_remove_waiter(&mut self, addr: u64, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        if let Some(futex) = this.machine.threads.sync.futexes.get_mut(&addr) {\n+            futex.waiters.retain(|waiter| waiter.thread != thread);\n+        }\n+    }\n+}"}, {"sha": "f1a3d19fb4cbc6d09a84e2456d641bedd87fddcd", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "added", "additions": 933, "deletions": 0, "changes": 933, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,933 @@\n+//! Implements threads.\n+\n+use std::cell::RefCell;\n+use std::collections::hash_map::Entry;\n+use std::num::TryFromIntError;\n+use std::time::{Duration, SystemTime};\n+\n+use log::trace;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::concurrency::data_race;\n+use crate::concurrency::sync::SynchronizationState;\n+use crate::*;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum SchedulingAction {\n+    /// Execute step on the active thread.\n+    ExecuteStep,\n+    /// Execute a timeout callback.\n+    ExecuteTimeoutCallback,\n+    /// Execute destructors of the active thread.\n+    ExecuteDtors,\n+    /// Stop the program.\n+    Stop,\n+}\n+\n+/// Timeout callbacks can be created by synchronization primitives to tell the\n+/// scheduler that they should be called once some period of time passes.\n+type TimeoutCallback<'mir, 'tcx> = Box<\n+    dyn FnOnce(&mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx> + 'tcx,\n+>;\n+\n+/// A thread identifier.\n+#[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n+pub struct ThreadId(u32);\n+\n+/// The main thread. When it terminates, the whole application terminates.\n+const MAIN_THREAD: ThreadId = ThreadId(0);\n+\n+impl ThreadId {\n+    pub fn to_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl Idx for ThreadId {\n+    fn new(idx: usize) -> Self {\n+        ThreadId(u32::try_from(idx).unwrap())\n+    }\n+\n+    fn index(self) -> usize {\n+        usize::try_from(self.0).unwrap()\n+    }\n+}\n+\n+impl TryFrom<u64> for ThreadId {\n+    type Error = TryFromIntError;\n+    fn try_from(id: u64) -> Result<Self, Self::Error> {\n+        u32::try_from(id).map(Self)\n+    }\n+}\n+\n+impl From<u32> for ThreadId {\n+    fn from(id: u32) -> Self {\n+        Self(id)\n+    }\n+}\n+\n+impl From<ThreadId> for u64 {\n+    fn from(t: ThreadId) -> Self {\n+        t.0.into()\n+    }\n+}\n+\n+/// The state of a thread.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum ThreadState {\n+    /// The thread is enabled and can be executed.\n+    Enabled,\n+    /// The thread tried to join the specified thread and is blocked until that\n+    /// thread terminates.\n+    BlockedOnJoin(ThreadId),\n+    /// The thread is blocked on some synchronization primitive. It is the\n+    /// responsibility of the synchronization primitives to track threads that\n+    /// are blocked by them.\n+    BlockedOnSync,\n+    /// The thread has terminated its execution. We do not delete terminated\n+    /// threads (FIXME: why?).\n+    Terminated,\n+}\n+\n+/// The join status of a thread.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum ThreadJoinStatus {\n+    /// The thread can be joined.\n+    Joinable,\n+    /// A thread is detached if its join handle was destroyed and no other\n+    /// thread can join it.\n+    Detached,\n+    /// The thread was already joined by some thread and cannot be joined again.\n+    Joined,\n+}\n+\n+/// A thread.\n+pub struct Thread<'mir, 'tcx> {\n+    state: ThreadState,\n+\n+    /// Name of the thread.\n+    thread_name: Option<Vec<u8>>,\n+\n+    /// The virtual call stack.\n+    stack: Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>>,\n+\n+    /// The join status.\n+    join_status: ThreadJoinStatus,\n+\n+    /// The temporary used for storing the argument of\n+    /// the call to `miri_start_panic` (the panic payload) when unwinding.\n+    /// This is pointer-sized, and matches the `Payload` type in `src/libpanic_unwind/miri.rs`.\n+    pub(crate) panic_payload: Option<Scalar<Provenance>>,\n+\n+    /// Last OS error location in memory. It is a 32-bit integer.\n+    pub(crate) last_error: Option<MPlaceTy<'tcx, Provenance>>,\n+}\n+\n+impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n+    /// Check if the thread is done executing (no more stack frames). If yes,\n+    /// change the state to terminated and return `true`.\n+    fn check_terminated(&mut self) -> bool {\n+        if self.state == ThreadState::Enabled {\n+            if self.stack.is_empty() {\n+                self.state = ThreadState::Terminated;\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Get the name of the current thread, or `<unnamed>` if it was not set.\n+    fn thread_name(&self) -> &[u8] {\n+        if let Some(ref thread_name) = self.thread_name { thread_name } else { b\"<unnamed>\" }\n+    }\n+}\n+\n+impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}({:?}, {:?})\",\n+            String::from_utf8_lossy(self.thread_name()),\n+            self.state,\n+            self.join_status\n+        )\n+    }\n+}\n+\n+impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n+    fn default() -> Self {\n+        Self {\n+            state: ThreadState::Enabled,\n+            thread_name: None,\n+            stack: Vec::new(),\n+            join_status: ThreadJoinStatus::Joinable,\n+            panic_payload: None,\n+            last_error: None,\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n+    fn new(name: &str) -> Self {\n+        let mut thread = Thread::default();\n+        thread.thread_name = Some(Vec::from(name.as_bytes()));\n+        thread\n+    }\n+}\n+\n+/// A specific moment in time.\n+#[derive(Debug)]\n+pub enum Time {\n+    Monotonic(Instant),\n+    RealTime(SystemTime),\n+}\n+\n+impl Time {\n+    /// How long do we have to wait from now until the specified time?\n+    fn get_wait_time(&self, clock: &Clock) -> Duration {\n+        match self {\n+            Time::Monotonic(instant) => instant.duration_since(clock.now()),\n+            Time::RealTime(time) =>\n+                time.duration_since(SystemTime::now()).unwrap_or(Duration::new(0, 0)),\n+        }\n+    }\n+}\n+\n+/// Callbacks are used to implement timeouts. For example, waiting on a\n+/// conditional variable with a timeout creates a callback that is called after\n+/// the specified time and unblocks the thread. If another thread signals on the\n+/// conditional variable, the signal handler deletes the callback.\n+struct TimeoutCallbackInfo<'mir, 'tcx> {\n+    /// The callback should be called no earlier than this time.\n+    call_time: Time,\n+    /// The called function.\n+    callback: TimeoutCallback<'mir, 'tcx>,\n+}\n+\n+impl<'mir, 'tcx> std::fmt::Debug for TimeoutCallbackInfo<'mir, 'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"TimeoutCallback({:?})\", self.call_time)\n+    }\n+}\n+\n+/// A set of threads.\n+#[derive(Debug)]\n+pub struct ThreadManager<'mir, 'tcx> {\n+    /// Identifier of the currently active thread.\n+    active_thread: ThreadId,\n+    /// Threads used in the program.\n+    ///\n+    /// Note that this vector also contains terminated threads.\n+    threads: IndexVec<ThreadId, Thread<'mir, 'tcx>>,\n+    /// This field is pub(crate) because the synchronization primitives\n+    /// (`crate::sync`) need a way to access it.\n+    pub(crate) sync: SynchronizationState,\n+    /// A mapping from a thread-local static to an allocation id of a thread\n+    /// specific allocation.\n+    thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), Pointer<Provenance>>>,\n+    /// A flag that indicates that we should change the active thread.\n+    yield_active_thread: bool,\n+    /// Callbacks that are called once the specified time passes.\n+    timeout_callbacks: FxHashMap<ThreadId, TimeoutCallbackInfo<'mir, 'tcx>>,\n+}\n+\n+impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n+    fn default() -> Self {\n+        let mut threads = IndexVec::new();\n+        // Create the main thread and add it to the list of threads.\n+        threads.push(Thread::new(\"main\"));\n+        Self {\n+            active_thread: ThreadId::new(0),\n+            threads,\n+            sync: SynchronizationState::default(),\n+            thread_local_alloc_ids: Default::default(),\n+            yield_active_thread: false,\n+            timeout_callbacks: FxHashMap::default(),\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n+    pub(crate) fn init(ecx: &mut MiriInterpCx<'mir, 'tcx>) {\n+        if ecx.tcx.sess.target.os.as_ref() != \"windows\" {\n+            // The main thread can *not* be joined on except on windows.\n+            ecx.machine.threads.threads[ThreadId::new(0)].join_status = ThreadJoinStatus::Detached;\n+        }\n+    }\n+\n+    /// Check if we have an allocation for the given thread local static for the\n+    /// active thread.\n+    fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<Pointer<Provenance>> {\n+        self.thread_local_alloc_ids.borrow().get(&(def_id, self.active_thread)).cloned()\n+    }\n+\n+    /// Set the pointer for the allocation of the given thread local\n+    /// static for the active thread.\n+    ///\n+    /// Panics if a thread local is initialized twice for the same thread.\n+    fn set_thread_local_alloc(&self, def_id: DefId, ptr: Pointer<Provenance>) {\n+        self.thread_local_alloc_ids\n+            .borrow_mut()\n+            .try_insert((def_id, self.active_thread), ptr)\n+            .unwrap();\n+    }\n+\n+    /// Borrow the stack of the active thread.\n+    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>] {\n+        &self.threads[self.active_thread].stack\n+    }\n+\n+    /// Mutably borrow the stack of the active thread.\n+    fn active_thread_stack_mut(\n+        &mut self,\n+    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+        &mut self.threads[self.active_thread].stack\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = &Thread<'mir, 'tcx>> {\n+        self.threads.iter()\n+    }\n+\n+    pub fn all_stacks(\n+        &self,\n+    ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>]> {\n+        self.threads.iter().map(|t| &t.stack[..])\n+    }\n+\n+    /// Create a new thread and returns its id.\n+    fn create_thread(&mut self) -> ThreadId {\n+        let new_thread_id = ThreadId::new(self.threads.len());\n+        self.threads.push(Default::default());\n+        new_thread_id\n+    }\n+\n+    /// Set an active thread and return the id of the thread that was active before.\n+    fn set_active_thread_id(&mut self, id: ThreadId) -> ThreadId {\n+        let active_thread_id = self.active_thread;\n+        self.active_thread = id;\n+        assert!(self.active_thread.index() < self.threads.len());\n+        active_thread_id\n+    }\n+\n+    /// Get the id of the currently active thread.\n+    pub fn get_active_thread_id(&self) -> ThreadId {\n+        self.active_thread\n+    }\n+\n+    /// Get the total number of threads that were ever spawn by this program.\n+    pub fn get_total_thread_count(&self) -> usize {\n+        self.threads.len()\n+    }\n+\n+    /// Get the total of threads that are currently live, i.e., not yet terminated.\n+    /// (They might be blocked.)\n+    pub fn get_live_thread_count(&self) -> usize {\n+        self.threads.iter().filter(|t| !matches!(t.state, ThreadState::Terminated)).count()\n+    }\n+\n+    /// Has the given thread terminated?\n+    fn has_terminated(&self, thread_id: ThreadId) -> bool {\n+        self.threads[thread_id].state == ThreadState::Terminated\n+    }\n+\n+    /// Have all threads terminated?\n+    fn have_all_terminated(&self) -> bool {\n+        self.threads.iter().all(|thread| thread.state == ThreadState::Terminated)\n+    }\n+\n+    /// Enable the thread for execution. The thread must be terminated.\n+    fn enable_thread(&mut self, thread_id: ThreadId) {\n+        assert!(self.has_terminated(thread_id));\n+        self.threads[thread_id].state = ThreadState::Enabled;\n+    }\n+\n+    /// Get a mutable borrow of the currently active thread.\n+    fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n+        &mut self.threads[self.active_thread]\n+    }\n+\n+    /// Get a shared borrow of the currently active thread.\n+    fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n+        &self.threads[self.active_thread]\n+    }\n+\n+    /// Mark the thread as detached, which means that no other thread will try\n+    /// to join it and the thread is responsible for cleaning up.\n+    ///\n+    /// `allow_terminated_joined` allows detaching joined threads that have already terminated.\n+    /// This matches Windows's behavior for `CloseHandle`.\n+    ///\n+    /// See <https://docs.microsoft.com/en-us/windows/win32/procthread/thread-handles-and-identifiers>:\n+    /// > The handle is valid until closed, even after the thread it represents has been terminated.\n+    fn detach_thread(&mut self, id: ThreadId, allow_terminated_joined: bool) -> InterpResult<'tcx> {\n+        trace!(\"detaching {:?}\", id);\n+\n+        let is_ub = if allow_terminated_joined && self.threads[id].state == ThreadState::Terminated\n+        {\n+            // \"Detached\" in particular means \"not yet joined\". Redundant detaching is still UB.\n+            self.threads[id].join_status == ThreadJoinStatus::Detached\n+        } else {\n+            self.threads[id].join_status != ThreadJoinStatus::Joinable\n+        };\n+        if is_ub {\n+            throw_ub_format!(\"trying to detach thread that was already detached or joined\");\n+        }\n+\n+        self.threads[id].join_status = ThreadJoinStatus::Detached;\n+        Ok(())\n+    }\n+\n+    /// Mark that the active thread tries to join the thread with `joined_thread_id`.\n+    fn join_thread(\n+        &mut self,\n+        joined_thread_id: ThreadId,\n+        data_race: Option<&mut data_race::GlobalState>,\n+    ) -> InterpResult<'tcx> {\n+        if self.threads[joined_thread_id].join_status == ThreadJoinStatus::Detached {\n+            throw_ub_format!(\"trying to join a detached thread\");\n+        }\n+\n+        // Mark the joined thread as being joined so that we detect if other\n+        // threads try to join it.\n+        self.threads[joined_thread_id].join_status = ThreadJoinStatus::Joined;\n+        if self.threads[joined_thread_id].state != ThreadState::Terminated {\n+            // The joined thread is still running, we need to wait for it.\n+            self.active_thread_mut().state = ThreadState::BlockedOnJoin(joined_thread_id);\n+            trace!(\n+                \"{:?} blocked on {:?} when trying to join\",\n+                self.active_thread,\n+                joined_thread_id\n+            );\n+        } else {\n+            // The thread has already terminated - mark join happens-before\n+            if let Some(data_race) = data_race {\n+                data_race.thread_joined(self, self.active_thread, joined_thread_id);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Mark that the active thread tries to exclusively join the thread with `joined_thread_id`.\n+    /// If the thread is already joined by another thread, it will throw UB\n+    fn join_thread_exclusive(\n+        &mut self,\n+        joined_thread_id: ThreadId,\n+        data_race: Option<&mut data_race::GlobalState>,\n+    ) -> InterpResult<'tcx> {\n+        if self.threads[joined_thread_id].join_status == ThreadJoinStatus::Joined {\n+            throw_ub_format!(\"trying to join an already joined thread\");\n+        }\n+\n+        if joined_thread_id == self.active_thread {\n+            throw_ub_format!(\"trying to join itself\");\n+        }\n+\n+        assert!(\n+            self.threads\n+                .iter()\n+                .all(|thread| thread.state != ThreadState::BlockedOnJoin(joined_thread_id)),\n+            \"this thread already has threads waiting for its termination\"\n+        );\n+\n+        self.join_thread(joined_thread_id, data_race)\n+    }\n+\n+    /// Set the name of the given thread.\n+    pub fn set_thread_name(&mut self, thread: ThreadId, new_thread_name: Vec<u8>) {\n+        self.threads[thread].thread_name = Some(new_thread_name);\n+    }\n+\n+    /// Get the name of the given thread.\n+    pub fn get_thread_name(&self, thread: ThreadId) -> &[u8] {\n+        self.threads[thread].thread_name()\n+    }\n+\n+    /// Put the thread into the blocked state.\n+    fn block_thread(&mut self, thread: ThreadId) {\n+        let state = &mut self.threads[thread].state;\n+        assert_eq!(*state, ThreadState::Enabled);\n+        *state = ThreadState::BlockedOnSync;\n+    }\n+\n+    /// Put the blocked thread into the enabled state.\n+    fn unblock_thread(&mut self, thread: ThreadId) {\n+        let state = &mut self.threads[thread].state;\n+        assert_eq!(*state, ThreadState::BlockedOnSync);\n+        *state = ThreadState::Enabled;\n+    }\n+\n+    /// Change the active thread to some enabled thread.\n+    fn yield_active_thread(&mut self) {\n+        // We do not yield immediately, as swapping out the current stack while executing a MIR statement\n+        // could lead to all sorts of confusion.\n+        // We should only switch stacks between steps.\n+        self.yield_active_thread = true;\n+    }\n+\n+    /// Register the given `callback` to be called once the `call_time` passes.\n+    ///\n+    /// The callback will be called with `thread` being the active thread, and\n+    /// the callback may not change the active thread.\n+    fn register_timeout_callback(\n+        &mut self,\n+        thread: ThreadId,\n+        call_time: Time,\n+        callback: TimeoutCallback<'mir, 'tcx>,\n+    ) {\n+        self.timeout_callbacks\n+            .try_insert(thread, TimeoutCallbackInfo { call_time, callback })\n+            .unwrap();\n+    }\n+\n+    /// Unregister the callback for the `thread`.\n+    fn unregister_timeout_callback_if_exists(&mut self, thread: ThreadId) {\n+        self.timeout_callbacks.remove(&thread);\n+    }\n+\n+    /// Get a callback that is ready to be called.\n+    fn get_ready_callback(\n+        &mut self,\n+        clock: &Clock,\n+    ) -> Option<(ThreadId, TimeoutCallback<'mir, 'tcx>)> {\n+        // We iterate over all threads in the order of their indices because\n+        // this allows us to have a deterministic scheduler.\n+        for thread in self.threads.indices() {\n+            match self.timeout_callbacks.entry(thread) {\n+                Entry::Occupied(entry) =>\n+                    if entry.get().call_time.get_wait_time(clock) == Duration::new(0, 0) {\n+                        return Some((thread, entry.remove().callback));\n+                    },\n+                Entry::Vacant(_) => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Wakes up threads joining on the active one and deallocates thread-local statics.\n+    /// The `AllocId` that can now be freed are returned.\n+    fn thread_terminated(\n+        &mut self,\n+        mut data_race: Option<&mut data_race::GlobalState>,\n+    ) -> Vec<Pointer<Provenance>> {\n+        let mut free_tls_statics = Vec::new();\n+        {\n+            let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n+            thread_local_statics.retain(|&(_def_id, thread), &mut alloc_id| {\n+                if thread != self.active_thread {\n+                    // Keep this static around.\n+                    return true;\n+                }\n+                // Delete this static from the map and from memory.\n+                // We cannot free directly here as we cannot use `?` in this context.\n+                free_tls_statics.push(alloc_id);\n+                false\n+            });\n+        }\n+        // Set the thread into a terminated state in the data-race detector.\n+        if let Some(ref mut data_race) = data_race {\n+            data_race.thread_terminated(self);\n+        }\n+        // Check if we need to unblock any threads.\n+        let mut joined_threads = vec![]; // store which threads joined, we'll need it\n+        for (i, thread) in self.threads.iter_enumerated_mut() {\n+            if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n+                // The thread has terminated, mark happens-before edge to joining thread\n+                if data_race.is_some() {\n+                    joined_threads.push(i);\n+                }\n+                trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n+                thread.state = ThreadState::Enabled;\n+            }\n+        }\n+        for &i in &joined_threads {\n+            data_race.as_mut().unwrap().thread_joined(self, i, self.active_thread);\n+        }\n+        free_tls_statics\n+    }\n+\n+    /// Decide which action to take next and on which thread.\n+    ///\n+    /// The currently implemented scheduling policy is the one that is commonly\n+    /// used in stateless model checkers such as Loom: run the active thread as\n+    /// long as we can and switch only when we have to (the active thread was\n+    /// blocked, terminated, or has explicitly asked to be preempted).\n+    fn schedule(&mut self, clock: &Clock) -> InterpResult<'tcx, SchedulingAction> {\n+        // Check whether the thread has **just** terminated (`check_terminated`\n+        // checks whether the thread has popped all its stack and if yes, sets\n+        // the thread state to terminated).\n+        if self.threads[self.active_thread].check_terminated() {\n+            return Ok(SchedulingAction::ExecuteDtors);\n+        }\n+        // If we get here again and the thread is *still* terminated, there are no more dtors to run.\n+        if self.threads[MAIN_THREAD].state == ThreadState::Terminated {\n+            // The main thread terminated; stop the program.\n+            // We do *not* run TLS dtors of remaining threads, which seems to match rustc behavior.\n+            return Ok(SchedulingAction::Stop);\n+        }\n+        // This thread and the program can keep going.\n+        if self.threads[self.active_thread].state == ThreadState::Enabled\n+            && !self.yield_active_thread\n+        {\n+            // The currently active thread is still enabled, just continue with it.\n+            return Ok(SchedulingAction::ExecuteStep);\n+        }\n+        // The active thread yielded. Let's see if there are any timeouts to take care of. We do\n+        // this *before* running any other thread, to ensure that timeouts \"in the past\" fire before\n+        // any other thread can take an action. This ensures that for `pthread_cond_timedwait`, \"an\n+        // error is returned if [...] the absolute time specified by abstime has already been passed\n+        // at the time of the call\".\n+        // <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html>\n+        let potential_sleep_time =\n+            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time(clock)).min();\n+        if potential_sleep_time == Some(Duration::new(0, 0)) {\n+            return Ok(SchedulingAction::ExecuteTimeoutCallback);\n+        }\n+        // No callbacks scheduled, pick a regular thread to execute.\n+        // The active thread blocked or yielded. So we go search for another enabled thread.\n+        // Crucially, we start searching at the current active thread ID, rather than at 0, since we\n+        // want to avoid always scheduling threads 0 and 1 without ever making progress in thread 2.\n+        //\n+        // `skip(N)` means we start iterating at thread N, so we skip 1 more to start just *after*\n+        // the active thread. Then after that we look at `take(N)`, i.e., the threads *before* the\n+        // active thread.\n+        let threads = self\n+            .threads\n+            .iter_enumerated()\n+            .skip(self.active_thread.index() + 1)\n+            .chain(self.threads.iter_enumerated().take(self.active_thread.index()));\n+        for (id, thread) in threads {\n+            debug_assert_ne!(self.active_thread, id);\n+            if thread.state == ThreadState::Enabled {\n+                self.active_thread = id;\n+                break;\n+            }\n+        }\n+        self.yield_active_thread = false;\n+        if self.threads[self.active_thread].state == ThreadState::Enabled {\n+            return Ok(SchedulingAction::ExecuteStep);\n+        }\n+        // We have not found a thread to execute.\n+        if self.threads.iter().all(|thread| thread.state == ThreadState::Terminated) {\n+            unreachable!(\"all threads terminated without the main thread terminating?!\");\n+        } else if let Some(sleep_time) = potential_sleep_time {\n+            // All threads are currently blocked, but we have unexecuted\n+            // timeout_callbacks, which may unblock some of the threads. Hence,\n+            // sleep until the first callback.\n+\n+            clock.sleep(sleep_time);\n+            Ok(SchedulingAction::ExecuteTimeoutCallback)\n+        } else {\n+            throw_machine_stop!(TerminationInfo::Deadlock);\n+        }\n+    }\n+}\n+\n+// Public interface to thread management.\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Get a thread-specific allocation id for the given thread-local static.\n+    /// If needed, allocate a new one.\n+    fn get_or_create_thread_local_alloc(\n+        &mut self,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n+        let this = self.eval_context_mut();\n+        let tcx = this.tcx;\n+        if let Some(old_alloc) = this.machine.threads.get_thread_local_alloc_id(def_id) {\n+            // We already have a thread-specific allocation id for this\n+            // thread-local static.\n+            Ok(old_alloc)\n+        } else {\n+            // We need to allocate a thread-specific allocation id for this\n+            // thread-local static.\n+            // First, we compute the initial value for this static.\n+            if tcx.is_foreign_item(def_id) {\n+                throw_unsup_format!(\"foreign thread-local statics are not supported\");\n+            }\n+            let allocation = tcx.eval_static_initializer(def_id)?;\n+            let mut allocation = allocation.inner().clone();\n+            // This allocation will be deallocated when the thread dies, so it is not in read-only memory.\n+            allocation.mutability = Mutability::Mut;\n+            // Create a fresh allocation with this content.\n+            let new_alloc = this.allocate_raw_ptr(allocation, MiriMemoryKind::Tls.into())?;\n+            this.machine.threads.set_thread_local_alloc(def_id, new_alloc);\n+            Ok(new_alloc)\n+        }\n+    }\n+\n+    #[inline]\n+    fn create_thread(&mut self) -> ThreadId {\n+        let this = self.eval_context_mut();\n+        let id = this.machine.threads.create_thread();\n+        if let Some(data_race) = &mut this.machine.data_race {\n+            data_race.thread_created(&this.machine.threads, id);\n+        }\n+        id\n+    }\n+\n+    #[inline]\n+    fn start_thread(\n+        &mut self,\n+        thread: Option<MPlaceTy<'tcx, Provenance>>,\n+        start_routine: Pointer<Option<Provenance>>,\n+        start_abi: Abi,\n+        func_arg: ImmTy<'tcx, Provenance>,\n+        ret_layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ThreadId> {\n+        let this = self.eval_context_mut();\n+\n+        // Create the new thread\n+        let new_thread_id = this.create_thread();\n+\n+        // Write the current thread-id, switch to the next thread later\n+        // to treat this write operation as occuring on the current thread.\n+        if let Some(thread_info_place) = thread {\n+            this.write_scalar(\n+                Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n+                &thread_info_place.into(),\n+            )?;\n+        }\n+\n+        // Finally switch to new thread so that we can push the first stackframe.\n+        // After this all accesses will be treated as occuring in the new thread.\n+        let old_thread_id = this.set_active_thread(new_thread_id);\n+\n+        // Perform the function pointer load in the new thread frame.\n+        let instance = this.get_ptr_fn(start_routine)?.as_instance()?;\n+\n+        // Note: the returned value is currently ignored (see the FIXME in\n+        // pthread_join in shims/unix/thread.rs) because the Rust standard library does not use\n+        // it.\n+        let ret_place = this.allocate(ret_layout, MiriMemoryKind::Machine.into())?;\n+\n+        this.call_function(\n+            instance,\n+            start_abi,\n+            &[*func_arg],\n+            Some(&ret_place.into()),\n+            StackPopCleanup::Root { cleanup: true },\n+        )?;\n+\n+        // Restore the old active thread frame.\n+        this.set_active_thread(old_thread_id);\n+\n+        Ok(new_thread_id)\n+    }\n+\n+    #[inline]\n+    fn detach_thread(\n+        &mut self,\n+        thread_id: ThreadId,\n+        allow_terminated_joined: bool,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.detach_thread(thread_id, allow_terminated_joined)\n+    }\n+\n+    #[inline]\n+    fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.join_thread(joined_thread_id, this.machine.data_race.as_mut())?;\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn join_thread_exclusive(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine\n+            .threads\n+            .join_thread_exclusive(joined_thread_id, this.machine.data_race.as_mut())?;\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn set_active_thread(&mut self, thread_id: ThreadId) -> ThreadId {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.set_active_thread_id(thread_id)\n+    }\n+\n+    #[inline]\n+    fn get_active_thread(&self) -> ThreadId {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.get_active_thread_id()\n+    }\n+\n+    #[inline]\n+    fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.active_thread_mut()\n+    }\n+\n+    #[inline]\n+    fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.active_thread_ref()\n+    }\n+\n+    #[inline]\n+    fn get_total_thread_count(&self) -> usize {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.get_total_thread_count()\n+    }\n+\n+    #[inline]\n+    fn has_terminated(&self, thread_id: ThreadId) -> bool {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.has_terminated(thread_id)\n+    }\n+\n+    #[inline]\n+    fn have_all_terminated(&self) -> bool {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.have_all_terminated()\n+    }\n+\n+    #[inline]\n+    fn enable_thread(&mut self, thread_id: ThreadId) {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.enable_thread(thread_id);\n+    }\n+\n+    #[inline]\n+    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>] {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.active_thread_stack()\n+    }\n+\n+    #[inline]\n+    fn active_thread_stack_mut(\n+        &mut self,\n+    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.active_thread_stack_mut()\n+    }\n+\n+    #[inline]\n+    fn set_thread_name(&mut self, thread: ThreadId, new_thread_name: Vec<u8>) {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.set_thread_name(thread, new_thread_name);\n+    }\n+\n+    #[inline]\n+    fn set_thread_name_wide(&mut self, thread: ThreadId, new_thread_name: &[u16]) {\n+        let this = self.eval_context_mut();\n+\n+        // The Windows `GetThreadDescription` shim to get the thread name isn't implemented, so being lossy is okay.\n+        // This is only read by diagnostics, which already use `from_utf8_lossy`.\n+        this.machine\n+            .threads\n+            .set_thread_name(thread, String::from_utf16_lossy(new_thread_name).into_bytes());\n+    }\n+\n+    #[inline]\n+    fn get_thread_name<'c>(&'c self, thread: ThreadId) -> &'c [u8]\n+    where\n+        'mir: 'c,\n+    {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.get_thread_name(thread)\n+    }\n+\n+    #[inline]\n+    fn block_thread(&mut self, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.block_thread(thread);\n+    }\n+\n+    #[inline]\n+    fn unblock_thread(&mut self, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.unblock_thread(thread);\n+    }\n+\n+    #[inline]\n+    fn yield_active_thread(&mut self) {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.yield_active_thread();\n+    }\n+\n+    #[inline]\n+    fn maybe_preempt_active_thread(&mut self) {\n+        use rand::Rng as _;\n+\n+        let this = self.eval_context_mut();\n+        if this.machine.rng.get_mut().gen_bool(this.machine.preemption_rate) {\n+            this.yield_active_thread();\n+        }\n+    }\n+\n+    #[inline]\n+    fn register_timeout_callback(\n+        &mut self,\n+        thread: ThreadId,\n+        call_time: Time,\n+        callback: TimeoutCallback<'mir, 'tcx>,\n+    ) {\n+        let this = self.eval_context_mut();\n+        if !this.machine.communicate() && matches!(call_time, Time::RealTime(..)) {\n+            panic!(\"cannot have `RealTime` callback with isolation enabled!\")\n+        }\n+        this.machine.threads.register_timeout_callback(thread, call_time, callback);\n+    }\n+\n+    #[inline]\n+    fn unregister_timeout_callback_if_exists(&mut self, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.unregister_timeout_callback_if_exists(thread);\n+    }\n+\n+    /// Execute a timeout callback on the callback's thread.\n+    #[inline]\n+    fn run_timeout_callback(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (thread, callback) = if let Some((thread, callback)) =\n+            this.machine.threads.get_ready_callback(&this.machine.clock)\n+        {\n+            (thread, callback)\n+        } else {\n+            // get_ready_callback can return None if the computer's clock\n+            // was shifted after calling the scheduler and before the call\n+            // to get_ready_callback (see issue\n+            // https://github.com/rust-lang/miri/issues/1763). In this case,\n+            // just do nothing, which effectively just returns to the\n+            // scheduler.\n+            return Ok(());\n+        };\n+        // This back-and-forth with `set_active_thread` is here because of two\n+        // design decisions:\n+        // 1. Make the caller and not the callback responsible for changing\n+        //    thread.\n+        // 2. Make the scheduler the only place that can change the active\n+        //    thread.\n+        let old_thread = this.set_active_thread(thread);\n+        callback(this)?;\n+        this.set_active_thread(old_thread);\n+        Ok(())\n+    }\n+\n+    /// Decide which action to take next and on which thread.\n+    #[inline]\n+    fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.schedule(&this.machine.clock)\n+    }\n+\n+    /// Handles thread termination of the active thread: wakes up threads joining on this one,\n+    /// and deallocated thread-local statics.\n+    ///\n+    /// This is called from `tls.rs` after handling the TLS dtors.\n+    #[inline]\n+    fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for ptr in this.machine.threads.thread_terminated(this.machine.data_race.as_mut()) {\n+            this.deallocate_ptr(ptr.into(), None, MiriMemoryKind::Tls.into())?;\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "32449f8eb1884ef9dde27316f44a017e7238d442", "filename": "src/tools/miri/src/concurrency/vector_clock.rs", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,470 @@\n+use rustc_index::vec::Idx;\n+use smallvec::SmallVec;\n+use std::{cmp::Ordering, fmt::Debug, ops::Index};\n+\n+/// A vector clock index, this is associated with a thread id\n+/// but in some cases one vector index may be shared with\n+/// multiple thread ids if it safe to do so.\n+#[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n+pub struct VectorIdx(u32);\n+\n+impl VectorIdx {\n+    #[inline(always)]\n+    pub fn to_u32(self) -> u32 {\n+        self.0\n+    }\n+\n+    pub const MAX_INDEX: VectorIdx = VectorIdx(u32::MAX);\n+}\n+\n+impl Idx for VectorIdx {\n+    #[inline]\n+    fn new(idx: usize) -> Self {\n+        VectorIdx(u32::try_from(idx).unwrap())\n+    }\n+\n+    #[inline]\n+    fn index(self) -> usize {\n+        usize::try_from(self.0).unwrap()\n+    }\n+}\n+\n+impl From<u32> for VectorIdx {\n+    #[inline]\n+    fn from(id: u32) -> Self {\n+        Self(id)\n+    }\n+}\n+\n+/// The size of the vector-clock to store inline\n+/// clock vectors larger than this will be stored on the heap\n+const SMALL_VECTOR: usize = 4;\n+\n+/// The type of the time-stamps recorded in the data-race detector\n+/// set to a type of unsigned integer\n+pub type VTimestamp = u32;\n+\n+/// A vector clock for detecting data-races, this is conceptually\n+/// a map from a vector index (and thus a thread id) to a timestamp.\n+/// The compare operations require that the invariant that the last\n+/// element in the internal timestamp slice must not be a 0, hence\n+/// all zero vector clocks are always represented by the empty slice;\n+/// and allows for the implementation of compare operations to short\n+/// circuit the calculation and return the correct result faster,\n+/// also this means that there is only one unique valid length\n+/// for each set of vector clock values and hence the PartialEq\n+/// and Eq derivations are correct.\n+#[derive(PartialEq, Eq, Default, Debug)]\n+pub struct VClock(SmallVec<[VTimestamp; SMALL_VECTOR]>);\n+\n+impl VClock {\n+    /// Create a new vector-clock containing all zeros except\n+    /// for a value at the given index\n+    pub fn new_with_index(index: VectorIdx, timestamp: VTimestamp) -> VClock {\n+        let len = index.index() + 1;\n+        let mut vec = smallvec::smallvec![0; len];\n+        vec[index.index()] = timestamp;\n+        VClock(vec)\n+    }\n+\n+    /// Load the internal timestamp slice in the vector clock\n+    #[inline]\n+    pub fn as_slice(&self) -> &[VTimestamp] {\n+        self.0.as_slice()\n+    }\n+\n+    /// Get a mutable slice to the internal vector with minimum `min_len`\n+    /// elements, to preserve invariants this vector must modify\n+    /// the `min_len`-1 nth element to a non-zero value\n+    #[inline]\n+    fn get_mut_with_min_len(&mut self, min_len: usize) -> &mut [VTimestamp] {\n+        if self.0.len() < min_len {\n+            self.0.resize(min_len, 0);\n+        }\n+        assert!(self.0.len() >= min_len);\n+        self.0.as_mut_slice()\n+    }\n+\n+    /// Increment the vector clock at a known index\n+    /// this will panic if the vector index overflows\n+    #[inline]\n+    pub fn increment_index(&mut self, idx: VectorIdx) {\n+        let idx = idx.index();\n+        let mut_slice = self.get_mut_with_min_len(idx + 1);\n+        let idx_ref = &mut mut_slice[idx];\n+        *idx_ref = idx_ref.checked_add(1).expect(\"Vector clock overflow\")\n+    }\n+\n+    // Join the two vector-clocks together, this\n+    // sets each vector-element to the maximum value\n+    // of that element in either of the two source elements.\n+    pub fn join(&mut self, other: &Self) {\n+        let rhs_slice = other.as_slice();\n+        let lhs_slice = self.get_mut_with_min_len(rhs_slice.len());\n+        for (l, &r) in lhs_slice.iter_mut().zip(rhs_slice.iter()) {\n+            *l = r.max(*l);\n+        }\n+    }\n+\n+    /// Set the element at the current index of the vector\n+    pub fn set_at_index(&mut self, other: &Self, idx: VectorIdx) {\n+        let mut_slice = self.get_mut_with_min_len(idx.index() + 1);\n+        mut_slice[idx.index()] = other[idx];\n+    }\n+\n+    /// Set the vector to the all-zero vector\n+    #[inline]\n+    pub fn set_zero_vector(&mut self) {\n+        self.0.clear();\n+    }\n+\n+    /// Return if this vector is the all-zero vector\n+    pub fn is_zero_vector(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+}\n+\n+impl Clone for VClock {\n+    fn clone(&self) -> Self {\n+        VClock(self.0.clone())\n+    }\n+\n+    // Optimized clone-from, can be removed\n+    // and replaced with a derive once a similar\n+    // optimization is inserted into SmallVec's\n+    // clone implementation.\n+    fn clone_from(&mut self, source: &Self) {\n+        let source_slice = source.as_slice();\n+        self.0.clear();\n+        self.0.extend_from_slice(source_slice);\n+    }\n+}\n+\n+impl PartialOrd for VClock {\n+    fn partial_cmp(&self, other: &VClock) -> Option<Ordering> {\n+        // Load the values as slices\n+        let lhs_slice = self.as_slice();\n+        let rhs_slice = other.as_slice();\n+\n+        // Iterate through the combined vector slice continuously updating\n+        // the value of `order` to the current comparison of the vector from\n+        // index 0 to the currently checked index.\n+        // An Equal ordering can be converted into Less or Greater ordering\n+        // on finding an element that is less than or greater than the other\n+        // but if one Greater and one Less element-wise comparison is found\n+        // then no ordering is possible and so directly return an ordering\n+        // of None.\n+        let mut iter = lhs_slice.iter().zip(rhs_slice.iter());\n+        let mut order = match iter.next() {\n+            Some((lhs, rhs)) => lhs.cmp(rhs),\n+            None => Ordering::Equal,\n+        };\n+        for (l, r) in iter {\n+            match order {\n+                Ordering::Equal => order = l.cmp(r),\n+                Ordering::Less =>\n+                    if l > r {\n+                        return None;\n+                    },\n+                Ordering::Greater =>\n+                    if l < r {\n+                        return None;\n+                    },\n+            }\n+        }\n+\n+        // Now test if either left or right have trailing elements,\n+        // by the invariant the trailing elements have at least 1\n+        // non zero value, so no additional calculation is required\n+        // to determine the result of the PartialOrder.\n+        let l_len = lhs_slice.len();\n+        let r_len = rhs_slice.len();\n+        match l_len.cmp(&r_len) {\n+            // Equal means no additional elements: return current order\n+            Ordering::Equal => Some(order),\n+            // Right has at least 1 element > than the implicit 0,\n+            // so the only valid values are Ordering::Less or None.\n+            Ordering::Less =>\n+                match order {\n+                    Ordering::Less | Ordering::Equal => Some(Ordering::Less),\n+                    Ordering::Greater => None,\n+                },\n+            // Left has at least 1 element > than the implicit 0,\n+            // so the only valid values are Ordering::Greater or None.\n+            Ordering::Greater =>\n+                match order {\n+                    Ordering::Greater | Ordering::Equal => Some(Ordering::Greater),\n+                    Ordering::Less => None,\n+                },\n+        }\n+    }\n+\n+    fn lt(&self, other: &VClock) -> bool {\n+        // Load the values as slices\n+        let lhs_slice = self.as_slice();\n+        let rhs_slice = other.as_slice();\n+\n+        // If l_len > r_len then at least one element\n+        // in l_len is > than r_len, therefore the result\n+        // is either Some(Greater) or None, so return false\n+        // early.\n+        let l_len = lhs_slice.len();\n+        let r_len = rhs_slice.len();\n+        if l_len <= r_len {\n+            // If any elements on the left are greater than the right\n+            // then the result is None or Some(Greater), both of which\n+            // return false, the earlier test asserts that no elements in the\n+            // extended tail violate this assumption. Otherwise l <= r, finally\n+            // the case where the values are potentially equal needs to be considered\n+            // and false returned as well\n+            let mut equal = l_len == r_len;\n+            for (&l, &r) in lhs_slice.iter().zip(rhs_slice.iter()) {\n+                if l > r {\n+                    return false;\n+                } else if l < r {\n+                    equal = false;\n+                }\n+            }\n+            !equal\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn le(&self, other: &VClock) -> bool {\n+        // Load the values as slices\n+        let lhs_slice = self.as_slice();\n+        let rhs_slice = other.as_slice();\n+\n+        // If l_len > r_len then at least one element\n+        // in l_len is > than r_len, therefore the result\n+        // is either Some(Greater) or None, so return false\n+        // early.\n+        let l_len = lhs_slice.len();\n+        let r_len = rhs_slice.len();\n+        if l_len <= r_len {\n+            // If any elements on the left are greater than the right\n+            // then the result is None or Some(Greater), both of which\n+            // return false, the earlier test asserts that no elements in the\n+            // extended tail violate this assumption. Otherwise l <= r\n+            !lhs_slice.iter().zip(rhs_slice.iter()).any(|(&l, &r)| l > r)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn gt(&self, other: &VClock) -> bool {\n+        // Load the values as slices\n+        let lhs_slice = self.as_slice();\n+        let rhs_slice = other.as_slice();\n+\n+        // If r_len > l_len then at least one element\n+        // in r_len is > than l_len, therefore the result\n+        // is either Some(Less) or None, so return false\n+        // early.\n+        let l_len = lhs_slice.len();\n+        let r_len = rhs_slice.len();\n+        if l_len >= r_len {\n+            // If any elements on the left are less than the right\n+            // then the result is None or Some(Less), both of which\n+            // return false, the earlier test asserts that no elements in the\n+            // extended tail violate this assumption. Otherwise l >=, finally\n+            // the case where the values are potentially equal needs to be considered\n+            // and false returned as well\n+            let mut equal = l_len == r_len;\n+            for (&l, &r) in lhs_slice.iter().zip(rhs_slice.iter()) {\n+                if l < r {\n+                    return false;\n+                } else if l > r {\n+                    equal = false;\n+                }\n+            }\n+            !equal\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn ge(&self, other: &VClock) -> bool {\n+        // Load the values as slices\n+        let lhs_slice = self.as_slice();\n+        let rhs_slice = other.as_slice();\n+\n+        // If r_len > l_len then at least one element\n+        // in r_len is > than l_len, therefore the result\n+        // is either Some(Less) or None, so return false\n+        // early.\n+        let l_len = lhs_slice.len();\n+        let r_len = rhs_slice.len();\n+        if l_len >= r_len {\n+            // If any elements on the left are less than the right\n+            // then the result is None or Some(Less), both of which\n+            // return false, the earlier test asserts that no elements in the\n+            // extended tail violate this assumption. Otherwise l >= r\n+            !lhs_slice.iter().zip(rhs_slice.iter()).any(|(&l, &r)| l < r)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl Index<VectorIdx> for VClock {\n+    type Output = VTimestamp;\n+\n+    #[inline]\n+    fn index(&self, index: VectorIdx) -> &VTimestamp {\n+        self.as_slice().get(index.to_u32() as usize).unwrap_or(&0)\n+    }\n+}\n+\n+/// Test vector clock ordering operations\n+///  data-race detection is tested in the external\n+///  test suite\n+#[cfg(test)]\n+mod tests {\n+\n+    use super::{VClock, VTimestamp, VectorIdx};\n+    use std::cmp::Ordering;\n+\n+    #[test]\n+    fn test_equal() {\n+        let mut c1 = VClock::default();\n+        let mut c2 = VClock::default();\n+        assert_eq!(c1, c2);\n+        c1.increment_index(VectorIdx(5));\n+        assert_ne!(c1, c2);\n+        c2.increment_index(VectorIdx(53));\n+        assert_ne!(c1, c2);\n+        c1.increment_index(VectorIdx(53));\n+        assert_ne!(c1, c2);\n+        c2.increment_index(VectorIdx(5));\n+        assert_eq!(c1, c2);\n+    }\n+\n+    #[test]\n+    fn test_partial_order() {\n+        // Small test\n+        assert_order(&[1], &[1], Some(Ordering::Equal));\n+        assert_order(&[1], &[2], Some(Ordering::Less));\n+        assert_order(&[2], &[1], Some(Ordering::Greater));\n+        assert_order(&[1], &[1, 2], Some(Ordering::Less));\n+        assert_order(&[2], &[1, 2], None);\n+\n+        // Misc tests\n+        assert_order(&[400], &[0, 1], None);\n+\n+        // Large test\n+        assert_order(\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0],\n+            Some(Ordering::Equal),\n+        );\n+        assert_order(\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 0],\n+            Some(Ordering::Less),\n+        );\n+        assert_order(\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11],\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0],\n+            Some(Ordering::Greater),\n+        );\n+        assert_order(\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11],\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 0],\n+            None,\n+        );\n+        assert_order(\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9],\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0],\n+            Some(Ordering::Less),\n+        );\n+        assert_order(\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9],\n+            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 0],\n+            Some(Ordering::Less),\n+        );\n+    }\n+\n+    fn from_slice(mut slice: &[VTimestamp]) -> VClock {\n+        while let Some(0) = slice.last() {\n+            slice = &slice[..slice.len() - 1]\n+        }\n+        VClock(smallvec::SmallVec::from_slice(slice))\n+    }\n+\n+    fn assert_order(l: &[VTimestamp], r: &[VTimestamp], o: Option<Ordering>) {\n+        let l = from_slice(l);\n+        let r = from_slice(r);\n+\n+        //Test partial_cmp\n+        let compare = l.partial_cmp(&r);\n+        assert_eq!(compare, o, \"Invalid comparison\\n l: {:?}\\n r: {:?}\", l, r);\n+        let alt_compare = r.partial_cmp(&l);\n+        assert_eq!(\n+            alt_compare,\n+            o.map(Ordering::reverse),\n+            \"Invalid alt comparison\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+\n+        //Test operators with faster implementations\n+        assert_eq!(\n+            matches!(compare, Some(Ordering::Less)),\n+            l < r,\n+            \"Invalid (<):\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+        assert_eq!(\n+            matches!(compare, Some(Ordering::Less) | Some(Ordering::Equal)),\n+            l <= r,\n+            \"Invalid (<=):\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+        assert_eq!(\n+            matches!(compare, Some(Ordering::Greater)),\n+            l > r,\n+            \"Invalid (>):\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+        assert_eq!(\n+            matches!(compare, Some(Ordering::Greater) | Some(Ordering::Equal)),\n+            l >= r,\n+            \"Invalid (>=):\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+        assert_eq!(\n+            matches!(alt_compare, Some(Ordering::Less)),\n+            r < l,\n+            \"Invalid alt (<):\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+        assert_eq!(\n+            matches!(alt_compare, Some(Ordering::Less) | Some(Ordering::Equal)),\n+            r <= l,\n+            \"Invalid alt (<=):\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+        assert_eq!(\n+            matches!(alt_compare, Some(Ordering::Greater)),\n+            r > l,\n+            \"Invalid alt (>):\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+        assert_eq!(\n+            matches!(alt_compare, Some(Ordering::Greater) | Some(Ordering::Equal)),\n+            r >= l,\n+            \"Invalid alt (>=):\\n l: {:?}\\n r: {:?}\",\n+            l,\n+            r\n+        );\n+    }\n+}"}, {"sha": "bac403e9ec7b1f1d33d6d3164809fa0523f2bc60", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "added", "additions": 630, "deletions": 0, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,630 @@\n+//! Implementation of C++11-consistent weak memory emulation using store buffers\n+//! based on Dynamic Race Detection for C++ (\"the paper\"):\n+//! <https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf>\n+//!\n+//! This implementation will never generate weak memory behaviours forbidden by the C++11 model,\n+//! but it is incapable of producing all possible weak behaviours allowed by the model. There are\n+//! certain weak behaviours observable on real hardware but not while using this.\n+//!\n+//! Note that this implementation does not fully take into account of C++20's memory model revision to SC accesses\n+//! and fences introduced by P0668 (<https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html>).\n+//! This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20\n+//! disallows (<https://github.com/rust-lang/miri/issues/2301>).\n+//!\n+//! A modification is made to the paper's model to partially address C++20 changes.\n+//! Specifically, if an SC load reads from an atomic store of any ordering, then a later SC load cannot read from\n+//! an earlier store in the location's modification order. This is to prevent creating a backwards S edge from the second\n+//! load to the first, as a result of C++20's coherence-ordered before rules.\n+//!\n+//! Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++'s\n+//! std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the\n+//! same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes\n+//! an implementable and C++20-compatible relaxed memory model that supports all atomic operation existing in Rust. The closest one is\n+//! A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (<https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf>)\n+//! However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).\n+//!\n+//! If you find anything that proposes a relaxed memory model that is C++20-consistent, supports all orderings Rust's atomic accesses\n+//! and fences accept, and is implementable (with operational semanitcs), please open a GitHub issue!\n+//!\n+//! One characteristic of this implementation, in contrast to some other notable operational models such as ones proposed in\n+//! Taming Release-Acquire Consistency by Ori Lahav et al. (<https://plv.mpi-sws.org/sra/paper.pdf>) or Promising Semantics noted above,\n+//! is that this implementation does not require each thread to hold an isolated view of the entire memory. Here, store buffers are per-location\n+//! and shared across all threads. This is more memory efficient but does require store elements (representing writes to a location) to record\n+//! information about reads, whereas in the other two models it is the other way round: reads points to the write it got its value from.\n+//! Additionally, writes in our implementation do not have globally unique timestamps attached. In the other two models this timestamp is\n+//! used to make sure a value in a thread's view is not overwritten by a write that occured earlier than the one in the existing view.\n+//! In our implementation, this is detected using read information attached to store elements, as there is no data strucutre representing reads.\n+//!\n+//! The C++ memory model is built around the notion of an 'atomic object', so it would be natural\n+//! to attach store buffers to atomic objects. However, Rust follows LLVM in that it only has\n+//! 'atomic accesses'. Therefore Miri cannot know when and where atomic 'objects' are being\n+//! created or destroyed, to manage its store buffers. Instead, we hence lazily create an\n+//! atomic object on the first atomic access to a given region, and we destroy that object\n+//! on the next non-atomic or imperfectly overlapping atomic access to that region.\n+//! These lazy (de)allocations happen in memory_accessed() on non-atomic accesses, and\n+//! get_or_create_store_buffer() on atomic accesses. This mostly works well, but it does\n+//! lead to some issues (<https://github.com/rust-lang/miri/issues/2164>).\n+//!\n+//! One consequence of this difference is that safe/sound Rust allows for more operations on atomic locations\n+//! than the C++20 atomic API was intended to allow, such as non-atomically accessing\n+//! a previously atomically accessed location, or accessing previously atomically accessed locations with a differently sized operation\n+//! (such as accessing the top 16 bits of an AtomicU32). These senarios are generally undiscussed in formalisations of C++ memory model.\n+//! In Rust, these operations can only be done through a `&mut AtomicFoo` reference or one derived from it, therefore these operations\n+//! can only happen after all previous accesses on the same locations. This implementation is adapted to allow these operations.\n+//! A mixed atomicity read that races with writes, or a write that races with reads or writes will still cause UBs to be thrown.\n+//! Mixed size atomic accesses must not race with any other atomic access, whether read or write, or a UB will be thrown.\n+//! You can refer to test cases in weak_memory/extra_cpp.rs and weak_memory/extra_cpp_unsafe.rs for examples of these operations.\n+\n+// Our and the author's own implementation (tsan11) of the paper have some deviations from the provided operational semantics in \u00a75.3:\n+// 1. In the operational semantics, store elements keep a copy of the atomic object's vector clock (AtomicCellClocks::sync_vector in miri),\n+// but this is not used anywhere so it's omitted here.\n+//\n+// 2. In the operational semantics, each store element keeps the timestamp of a thread when it loads from the store.\n+// If the same thread loads from the same store element multiple times, then the timestamps at all loads are saved in a list of load elements.\n+// This is not necessary as later loads by the same thread will always have greater timetstamp values, so we only need to record the timestamp of the first\n+// load by each thread. This optimisation is done in tsan11\n+// (https://github.com/ChrisLidbury/tsan11/blob/ecbd6b81e9b9454e01cba78eb9d88684168132c7/lib/tsan/rtl/tsan_relaxed.h#L35-L37)\n+// and here.\n+//\n+// 3. \u00a74.5 of the paper wants an SC store to mark all existing stores in the buffer that happens before it\n+// as SC. This is not done in the operational semantics but implemented correctly in tsan11\n+// (https://github.com/ChrisLidbury/tsan11/blob/ecbd6b81e9b9454e01cba78eb9d88684168132c7/lib/tsan/rtl/tsan_relaxed.cc#L160-L167)\n+// and here.\n+//\n+// 4. W_SC ; R_SC case requires the SC load to ignore all but last store maked SC (stores not marked SC are not\n+// affected). But this rule is applied to all loads in ReadsFromSet from the paper (last two lines of code), not just SC load.\n+// This is implemented correctly in tsan11\n+// (https://github.com/ChrisLidbury/tsan11/blob/ecbd6b81e9b9454e01cba78eb9d88684168132c7/lib/tsan/rtl/tsan_relaxed.cc#L295)\n+// and here.\n+\n+use std::{\n+    cell::{Ref, RefCell},\n+    collections::VecDeque,\n+};\n+\n+use rustc_const_eval::interpret::{alloc_range, AllocRange, InterpResult, MPlaceTy, Scalar};\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use crate::*;\n+\n+use super::{\n+    data_race::{GlobalState as DataRaceState, ThreadClockSet},\n+    range_object_map::{AccessType, RangeObjectMap},\n+    vector_clock::{VClock, VTimestamp, VectorIdx},\n+};\n+\n+pub type AllocExtra = StoreBufferAlloc;\n+\n+// Each store buffer must be bounded otherwise it will grow indefinitely.\n+// However, bounding the store buffer means restricting the amount of weak\n+// behaviours observable. The author picked 128 as a good tradeoff\n+// so we follow them here.\n+const STORE_BUFFER_LIMIT: usize = 128;\n+\n+#[derive(Debug, Clone)]\n+pub struct StoreBufferAlloc {\n+    /// Store buffer of each atomic object in this allocation\n+    // Behind a RefCell because we need to allocate/remove on read access\n+    store_buffers: RefCell<RangeObjectMap<StoreBuffer>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(super) struct StoreBuffer {\n+    // Stores to this location in modification order\n+    buffer: VecDeque<StoreElement>,\n+}\n+\n+/// Whether a load returned the latest value or not.\n+#[derive(PartialEq, Eq)]\n+enum LoadRecency {\n+    Latest,\n+    Outdated,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+struct StoreElement {\n+    /// The identifier of the vector index, corresponding to a thread\n+    /// that performed the store.\n+    store_index: VectorIdx,\n+\n+    /// Whether this store is SC.\n+    is_seqcst: bool,\n+\n+    /// The timestamp of the storing thread when it performed the store\n+    timestamp: VTimestamp,\n+    /// The value of this store\n+    // FIXME: this means the store must be fully initialized;\n+    // we will have to change this if we want to support atomics on\n+    // (partially) uninitialized data.\n+    val: Scalar<Provenance>,\n+\n+    /// Metadata about loads from this store element,\n+    /// behind a RefCell to keep load op take &self\n+    load_info: RefCell<LoadInfo>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+struct LoadInfo {\n+    /// Timestamp of first loads from this store element by each thread\n+    timestamps: FxHashMap<VectorIdx, VTimestamp>,\n+    /// Whether this store element has been read by an SC load\n+    sc_loaded: bool,\n+}\n+\n+impl StoreBufferAlloc {\n+    pub fn new_allocation() -> Self {\n+        Self { store_buffers: RefCell::new(RangeObjectMap::new()) }\n+    }\n+\n+    /// Checks if the range imperfectly overlaps with existing buffers\n+    /// Used to determine if mixed-size atomic accesses\n+    fn is_overlapping(&self, range: AllocRange) -> bool {\n+        let buffers = self.store_buffers.borrow();\n+        let access_type = buffers.access_type(range);\n+        matches!(access_type, AccessType::ImperfectlyOverlapping(_))\n+    }\n+\n+    /// When a non-atomic access happens on a location that has been atomically accessed\n+    /// before without data race, we can determine that the non-atomic access fully happens\n+    /// after all the prior atomic accesses so the location no longer needs to exhibit\n+    /// any weak memory behaviours until further atomic accesses.\n+    pub fn memory_accessed(&self, range: AllocRange, global: &DataRaceState) {\n+        if !global.ongoing_action_data_race_free() {\n+            let mut buffers = self.store_buffers.borrow_mut();\n+            let access_type = buffers.access_type(range);\n+            match access_type {\n+                AccessType::PerfectlyOverlapping(pos) => {\n+                    buffers.remove_from_pos(pos);\n+                }\n+                AccessType::ImperfectlyOverlapping(pos_range) => {\n+                    buffers.remove_pos_range(pos_range);\n+                }\n+                AccessType::Empty(_) => {\n+                    // The range had no weak behaivours attached, do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Gets a store buffer associated with an atomic object in this allocation,\n+    /// or creates one with the specified initial value if no atomic object exists yet.\n+    fn get_or_create_store_buffer<'tcx>(\n+        &self,\n+        range: AllocRange,\n+        init: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx, Ref<'_, StoreBuffer>> {\n+        let access_type = self.store_buffers.borrow().access_type(range);\n+        let pos = match access_type {\n+            AccessType::PerfectlyOverlapping(pos) => pos,\n+            AccessType::Empty(pos) => {\n+                let mut buffers = self.store_buffers.borrow_mut();\n+                buffers.insert_at_pos(pos, range, StoreBuffer::new(init));\n+                pos\n+            }\n+            AccessType::ImperfectlyOverlapping(pos_range) => {\n+                // Once we reach here we would've already checked that this access is not racy\n+                let mut buffers = self.store_buffers.borrow_mut();\n+                buffers.remove_pos_range(pos_range.clone());\n+                buffers.insert_at_pos(pos_range.start, range, StoreBuffer::new(init));\n+                pos_range.start\n+            }\n+        };\n+        Ok(Ref::map(self.store_buffers.borrow(), |buffer| &buffer[pos]))\n+    }\n+\n+    /// Gets a mutable store buffer associated with an atomic object in this allocation\n+    fn get_or_create_store_buffer_mut<'tcx>(\n+        &mut self,\n+        range: AllocRange,\n+        init: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx, &mut StoreBuffer> {\n+        let buffers = self.store_buffers.get_mut();\n+        let access_type = buffers.access_type(range);\n+        let pos = match access_type {\n+            AccessType::PerfectlyOverlapping(pos) => pos,\n+            AccessType::Empty(pos) => {\n+                buffers.insert_at_pos(pos, range, StoreBuffer::new(init));\n+                pos\n+            }\n+            AccessType::ImperfectlyOverlapping(pos_range) => {\n+                buffers.remove_pos_range(pos_range.clone());\n+                buffers.insert_at_pos(pos_range.start, range, StoreBuffer::new(init));\n+                pos_range.start\n+            }\n+        };\n+        Ok(&mut buffers[pos])\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> StoreBuffer {\n+    fn new(init: Scalar<Provenance>) -> Self {\n+        let mut buffer = VecDeque::new();\n+        buffer.reserve(STORE_BUFFER_LIMIT);\n+        let mut ret = Self { buffer };\n+        let store_elem = StoreElement {\n+            // The thread index and timestamp of the initialisation write\n+            // are never meaningfully used, so it's fine to leave them as 0\n+            store_index: VectorIdx::from(0),\n+            timestamp: 0,\n+            val: init,\n+            is_seqcst: false,\n+            load_info: RefCell::new(LoadInfo::default()),\n+        };\n+        ret.buffer.push_back(store_elem);\n+        ret\n+    }\n+\n+    /// Reads from the last store in modification order\n+    fn read_from_last_store(\n+        &self,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        is_seqcst: bool,\n+    ) {\n+        let store_elem = self.buffer.back();\n+        if let Some(store_elem) = store_elem {\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            store_elem.load_impl(index, &clocks, is_seqcst);\n+        }\n+    }\n+\n+    fn buffered_read(\n+        &self,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        is_seqcst: bool,\n+        rng: &mut (impl rand::Rng + ?Sized),\n+        validate: impl FnOnce() -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx, (Scalar<Provenance>, LoadRecency)> {\n+        // Having a live borrow to store_buffer while calling validate_atomic_load is fine\n+        // because the race detector doesn't touch store_buffer\n+\n+        let (store_elem, recency) = {\n+            // The `clocks` we got here must be dropped before calling validate_atomic_load\n+            // as the race detector will update it\n+            let (.., clocks) = global.current_thread_state(thread_mgr);\n+            // Load from a valid entry in the store buffer\n+            self.fetch_store(is_seqcst, &clocks, &mut *rng)\n+        };\n+\n+        // Unlike in buffered_atomic_write, thread clock updates have to be done\n+        // after we've picked a store element from the store buffer, as presented\n+        // in ATOMIC LOAD rule of the paper. This is because fetch_store\n+        // requires access to ThreadClockSet.clock, which is updated by the race detector\n+        validate()?;\n+\n+        let (index, clocks) = global.current_thread_state(thread_mgr);\n+        let loaded = store_elem.load_impl(index, &clocks, is_seqcst);\n+        Ok((loaded, recency))\n+    }\n+\n+    fn buffered_write(\n+        &mut self,\n+        val: Scalar<Provenance>,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        is_seqcst: bool,\n+    ) -> InterpResult<'tcx> {\n+        let (index, clocks) = global.current_thread_state(thread_mgr);\n+\n+        self.store_impl(val, index, &clocks.clock, is_seqcst);\n+        Ok(())\n+    }\n+\n+    #[allow(clippy::if_same_then_else, clippy::needless_bool)]\n+    /// Selects a valid store element in the buffer.\n+    fn fetch_store<R: rand::Rng + ?Sized>(\n+        &self,\n+        is_seqcst: bool,\n+        clocks: &ThreadClockSet,\n+        rng: &mut R,\n+    ) -> (&StoreElement, LoadRecency) {\n+        use rand::seq::IteratorRandom;\n+        let mut found_sc = false;\n+        // FIXME: we want an inclusive take_while (stops after a false predicate, but\n+        // includes the element that gave the false), but such function doesn't yet\n+        // exist in the standard libary https://github.com/rust-lang/rust/issues/62208\n+        // so we have to hack around it with keep_searching\n+        let mut keep_searching = true;\n+        let candidates = self\n+            .buffer\n+            .iter()\n+            .rev()\n+            .take_while(move |&store_elem| {\n+                if !keep_searching {\n+                    return false;\n+                }\n+\n+                keep_searching = if store_elem.timestamp <= clocks.clock[store_elem.store_index] {\n+                    // CoWR: if a store happens-before the current load,\n+                    // then we can't read-from anything earlier in modification order.\n+                    // C++20 \u00a76.9.2.2 [intro.races] paragraph 18\n+                    false\n+                } else if store_elem.load_info.borrow().timestamps.iter().any(\n+                    |(&load_index, &load_timestamp)| load_timestamp <= clocks.clock[load_index],\n+                ) {\n+                    // CoRR: if there was a load from this store which happened-before the current load,\n+                    // then we cannot read-from anything earlier in modification order.\n+                    // C++20 \u00a76.9.2.2 [intro.races] paragraph 16\n+                    false\n+                } else if store_elem.timestamp <= clocks.fence_seqcst[store_elem.store_index] {\n+                    // The current load, which may be sequenced-after an SC fence, cannot read-before\n+                    // the last store sequenced-before an SC fence in another thread.\n+                    // C++17 \u00a732.4 [atomics.order] paragraph 6\n+                    false\n+                } else if store_elem.timestamp <= clocks.write_seqcst[store_elem.store_index]\n+                    && store_elem.is_seqcst\n+                {\n+                    // The current non-SC load, which may be sequenced-after an SC fence,\n+                    // cannot read-before the last SC store executed before the fence.\n+                    // C++17 \u00a732.4 [atomics.order] paragraph 4\n+                    false\n+                } else if is_seqcst\n+                    && store_elem.timestamp <= clocks.read_seqcst[store_elem.store_index]\n+                {\n+                    // The current SC load cannot read-before the last store sequenced-before\n+                    // the last SC fence.\n+                    // C++17 \u00a732.4 [atomics.order] paragraph 5\n+                    false\n+                } else if is_seqcst && store_elem.load_info.borrow().sc_loaded {\n+                    // The current SC load cannot read-before a store that an earlier SC load has observed.\n+                    // See https://github.com/rust-lang/miri/issues/2301#issuecomment-1222720427\n+                    // Consequences of C++20 \u00a731.4 [atomics.order] paragraph 3.1, 3.3 (coherence-ordered before)\n+                    // and 4.1 (coherence-ordered before between SC makes global total order S)\n+                    false\n+                } else {\n+                    true\n+                };\n+\n+                true\n+            })\n+            .filter(|&store_elem| {\n+                if is_seqcst && store_elem.is_seqcst {\n+                    // An SC load needs to ignore all but last store maked SC (stores not marked SC are not\n+                    // affected)\n+                    let include = !found_sc;\n+                    found_sc = true;\n+                    include\n+                } else {\n+                    true\n+                }\n+            });\n+\n+        let chosen = candidates.choose(rng).expect(\"store buffer cannot be empty\");\n+        if std::ptr::eq(chosen, self.buffer.back().expect(\"store buffer cannot be empty\")) {\n+            (chosen, LoadRecency::Latest)\n+        } else {\n+            (chosen, LoadRecency::Outdated)\n+        }\n+    }\n+\n+    /// ATOMIC STORE IMPL in the paper (except we don't need the location's vector clock)\n+    fn store_impl(\n+        &mut self,\n+        val: Scalar<Provenance>,\n+        index: VectorIdx,\n+        thread_clock: &VClock,\n+        is_seqcst: bool,\n+    ) {\n+        let store_elem = StoreElement {\n+            store_index: index,\n+            timestamp: thread_clock[index],\n+            // In the language provided in the paper, an atomic store takes the value from a\n+            // non-atomic memory location.\n+            // But we already have the immediate value here so we don't need to do the memory\n+            // access\n+            val,\n+            is_seqcst,\n+            load_info: RefCell::new(LoadInfo::default()),\n+        };\n+        self.buffer.push_back(store_elem);\n+        if self.buffer.len() > STORE_BUFFER_LIMIT {\n+            self.buffer.pop_front();\n+        }\n+        if is_seqcst {\n+            // Every store that happens before this needs to be marked as SC\n+            // so that in a later SC load, only the last SC store (i.e. this one) or stores that\n+            // aren't ordered by hb with the last SC is picked.\n+            self.buffer.iter_mut().rev().for_each(|elem| {\n+                if elem.timestamp <= thread_clock[elem.store_index] {\n+                    elem.is_seqcst = true;\n+                }\n+            })\n+        }\n+    }\n+}\n+\n+impl StoreElement {\n+    /// ATOMIC LOAD IMPL in the paper\n+    /// Unlike the operational semantics in the paper, we don't need to keep track\n+    /// of the thread timestamp for every single load. Keeping track of the first (smallest)\n+    /// timestamp of each thread that has loaded from a store is sufficient: if the earliest\n+    /// load of another thread happens before the current one, then we must stop searching the store\n+    /// buffer regardless of subsequent loads by the same thread; if the earliest load of another\n+    /// thread doesn't happen before the current one, then no subsequent load by the other thread\n+    /// can happen before the current one.\n+    fn load_impl(\n+        &self,\n+        index: VectorIdx,\n+        clocks: &ThreadClockSet,\n+        is_seqcst: bool,\n+    ) -> Scalar<Provenance> {\n+        let mut load_info = self.load_info.borrow_mut();\n+        load_info.sc_loaded |= is_seqcst;\n+        let _ = load_info.timestamps.try_insert(index, clocks.clock[index]);\n+        self.val\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n+    crate::MiriInterpCxExt<'mir, 'tcx>\n+{\n+    // If weak memory emulation is enabled, check if this atomic op imperfectly overlaps with a previous\n+    // atomic read or write. If it does, then we require it to be ordered (non-racy) with all previous atomic\n+    // accesses on all the bytes in range\n+    fn validate_overlapping_atomic(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n+        if let crate::AllocExtra {\n+            weak_memory: Some(alloc_buffers),\n+            data_race: Some(alloc_clocks),\n+            ..\n+        } = this.get_alloc_extra(alloc_id)?\n+        {\n+            let range = alloc_range(base_offset, place.layout.size);\n+            if alloc_buffers.is_overlapping(range)\n+                && !alloc_clocks.race_free_with_atomic(\n+                    range,\n+                    this.machine.data_race.as_ref().unwrap(),\n+                    &this.machine.threads,\n+                )\n+            {\n+                throw_unsup_format!(\n+                    \"racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\"\n+                );\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn buffered_atomic_rmw(\n+        &mut self,\n+        new_val: Scalar<Provenance>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicRwOrd,\n+        init: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n+        if let (\n+            crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n+            crate::MiriMachine { data_race: Some(global), threads, .. },\n+        ) = this.get_alloc_extra_mut(alloc_id)?\n+        {\n+            if atomic == AtomicRwOrd::SeqCst {\n+                global.sc_read(threads);\n+                global.sc_write(threads);\n+            }\n+            let range = alloc_range(base_offset, place.layout.size);\n+            let buffer = alloc_buffers.get_or_create_store_buffer_mut(range, init)?;\n+            buffer.read_from_last_store(global, threads, atomic == AtomicRwOrd::SeqCst);\n+            buffer.buffered_write(new_val, global, threads, atomic == AtomicRwOrd::SeqCst)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn buffered_atomic_read(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicReadOrd,\n+        latest_in_mo: Scalar<Provenance>,\n+        validate: impl FnOnce() -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_ref();\n+        if let Some(global) = &this.machine.data_race {\n+            let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n+            if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n+                if atomic == AtomicReadOrd::SeqCst {\n+                    global.sc_read(&this.machine.threads);\n+                }\n+                let mut rng = this.machine.rng.borrow_mut();\n+                let buffer = alloc_buffers.get_or_create_store_buffer(\n+                    alloc_range(base_offset, place.layout.size),\n+                    latest_in_mo,\n+                )?;\n+                let (loaded, recency) = buffer.buffered_read(\n+                    global,\n+                    &this.machine.threads,\n+                    atomic == AtomicReadOrd::SeqCst,\n+                    &mut *rng,\n+                    validate,\n+                )?;\n+                if global.track_outdated_loads && recency == LoadRecency::Outdated {\n+                    this.emit_diagnostic(NonHaltingDiagnostic::WeakMemoryOutdatedLoad);\n+                }\n+\n+                return Ok(loaded);\n+            }\n+        }\n+\n+        // Race detector or weak memory disabled, simply read the latest value\n+        validate()?;\n+        Ok(latest_in_mo)\n+    }\n+\n+    fn buffered_atomic_write(\n+        &mut self,\n+        val: Scalar<Provenance>,\n+        dest: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicWriteOrd,\n+        init: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(dest.ptr)?;\n+        if let (\n+            crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n+            crate::MiriMachine { data_race: Some(global), threads, .. },\n+        ) = this.get_alloc_extra_mut(alloc_id)?\n+        {\n+            if atomic == AtomicWriteOrd::SeqCst {\n+                global.sc_write(threads);\n+            }\n+\n+            // UGLY HACK: in write_scalar_atomic() we don't know the value before our write,\n+            // so init == val always. If the buffer is fresh then we would've duplicated an entry,\n+            // so we need to remove it.\n+            // See https://github.com/rust-lang/miri/issues/2164\n+            let was_empty = matches!(\n+                alloc_buffers\n+                    .store_buffers\n+                    .borrow()\n+                    .access_type(alloc_range(base_offset, dest.layout.size)),\n+                AccessType::Empty(_)\n+            );\n+            let buffer = alloc_buffers\n+                .get_or_create_store_buffer_mut(alloc_range(base_offset, dest.layout.size), init)?;\n+            if was_empty {\n+                buffer.buffer.pop_front();\n+            }\n+\n+            buffer.buffered_write(val, global, threads, atomic == AtomicWriteOrd::SeqCst)?;\n+        }\n+\n+        // Caller should've written to dest with the vanilla scalar write, we do nothing here\n+        Ok(())\n+    }\n+\n+    /// Caller should never need to consult the store buffer for the latest value.\n+    /// This function is used exclusively for failed atomic_compare_exchange_scalar\n+    /// to perform load_impl on the latest store element\n+    fn perform_read_on_buffered_latest(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicReadOrd,\n+        init: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+\n+        if let Some(global) = &this.machine.data_race {\n+            if atomic == AtomicReadOrd::SeqCst {\n+                global.sc_read(&this.machine.threads);\n+            }\n+            let size = place.layout.size;\n+            let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n+            if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n+                let buffer = alloc_buffers\n+                    .get_or_create_store_buffer(alloc_range(base_offset, size), init)?;\n+                buffer.read_from_last_store(\n+                    global,\n+                    &this.machine.threads,\n+                    atomic == AtomicReadOrd::SeqCst,\n+                );\n+            }\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "868c85c04a88d5d8367ff2435c98c432f7cef5e9", "filename": "src/tools/miri/src/diagnostics.rs", "status": "added", "additions": 500, "deletions": 0, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,500 @@\n+use std::fmt;\n+use std::num::NonZeroU64;\n+\n+use log::trace;\n+\n+use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n+use rustc_target::abi::{Align, Size};\n+\n+use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind};\n+use crate::*;\n+\n+/// Details of premature program termination.\n+pub enum TerminationInfo {\n+    Exit(i64),\n+    Abort(String),\n+    UnsupportedInIsolation(String),\n+    StackedBorrowsUb {\n+        msg: String,\n+        help: Option<String>,\n+        history: Option<TagHistory>,\n+    },\n+    Int2PtrWithStrictProvenance,\n+    Deadlock,\n+    MultipleSymbolDefinitions {\n+        link_name: Symbol,\n+        first: SpanData,\n+        first_crate: Symbol,\n+        second: SpanData,\n+        second_crate: Symbol,\n+    },\n+    SymbolShimClashing {\n+        link_name: Symbol,\n+        span: SpanData,\n+    },\n+}\n+\n+impl fmt::Display for TerminationInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use TerminationInfo::*;\n+        match self {\n+            Exit(code) => write!(f, \"the evaluated program completed with exit code {code}\"),\n+            Abort(msg) => write!(f, \"{msg}\"),\n+            UnsupportedInIsolation(msg) => write!(f, \"{msg}\"),\n+            Int2PtrWithStrictProvenance =>\n+                write!(\n+                    f,\n+                    \"integer-to-pointer casts and `ptr::from_exposed_addr` are not supported with `-Zmiri-strict-provenance`\"\n+                ),\n+            StackedBorrowsUb { msg, .. } => write!(f, \"{msg}\"),\n+            Deadlock => write!(f, \"the evaluated program deadlocked\"),\n+            MultipleSymbolDefinitions { link_name, .. } =>\n+                write!(f, \"multiple definitions of symbol `{link_name}`\"),\n+            SymbolShimClashing { link_name, .. } =>\n+                write!(f, \"found `{link_name}` symbol definition that clashes with a built-in shim\",),\n+        }\n+    }\n+}\n+\n+impl MachineStopType for TerminationInfo {}\n+\n+/// Miri specific diagnostics\n+pub enum NonHaltingDiagnostic {\n+    CreatedPointerTag(NonZeroU64, Option<(AllocId, AllocRange)>),\n+    /// This `Item` was popped from the borrow stack, either due to an access with the given tag or\n+    /// a deallocation when the second argument is `None`.\n+    PoppedPointerTag(Item, Option<(ProvenanceExtra, AccessKind)>),\n+    CreatedCallId(CallId),\n+    CreatedAlloc(AllocId, Size, Align, MemoryKind<MiriMemoryKind>),\n+    FreedAlloc(AllocId),\n+    RejectedIsolatedOp(String),\n+    ProgressReport {\n+        block_count: u64, // how many basic blocks have been run so far\n+    },\n+    Int2Ptr {\n+        details: bool,\n+    },\n+    WeakMemoryOutdatedLoad,\n+}\n+\n+/// Level of Miri specific diagnostics\n+enum DiagLevel {\n+    Error,\n+    Warning,\n+    Note,\n+}\n+\n+/// Attempts to prune a stacktrace to omit the Rust runtime, and returns a bool indicating if any\n+/// frames were pruned. If the stacktrace does not have any local frames, we conclude that it must\n+/// be pointing to a problem in the Rust runtime itself, and do not prune it at all.\n+fn prune_stacktrace<'tcx>(\n+    mut stacktrace: Vec<FrameInfo<'tcx>>,\n+    machine: &MiriMachine<'_, 'tcx>,\n+) -> (Vec<FrameInfo<'tcx>>, bool) {\n+    match machine.backtrace_style {\n+        BacktraceStyle::Off => {\n+            // Remove all frames marked with `caller_location` -- that attribute indicates we\n+            // usually want to point at the caller, not them.\n+            stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(machine.tcx));\n+            // Retain one frame so that we can print a span for the error itself\n+            stacktrace.truncate(1);\n+            (stacktrace, false)\n+        }\n+        BacktraceStyle::Short => {\n+            let original_len = stacktrace.len();\n+            // Only prune frames if there is at least one local frame. This check ensures that if\n+            // we get a backtrace that never makes it to the user code because it has detected a\n+            // bug in the Rust runtime, we don't prune away every frame.\n+            let has_local_frame = stacktrace.iter().any(|frame| machine.is_local(frame));\n+            if has_local_frame {\n+                // Remove all frames marked with `caller_location` -- that attribute indicates we\n+                // usually want to point at the caller, not them.\n+                stacktrace\n+                    .retain(|frame| !frame.instance.def.requires_caller_location(machine.tcx));\n+\n+                // This is part of the logic that `std` uses to select the relevant part of a\n+                // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n+                // __rust_end_short_backtrace because the end symbol comes from a call to the default\n+                // panic handler.\n+                stacktrace = stacktrace\n+                    .into_iter()\n+                    .take_while(|frame| {\n+                        let def_id = frame.instance.def_id();\n+                        let path = machine.tcx.def_path_str(def_id);\n+                        !path.contains(\"__rust_begin_short_backtrace\")\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                // After we prune frames from the bottom, there are a few left that are part of the\n+                // Rust runtime. So we remove frames until we get to a local symbol, which should be\n+                // main or a test.\n+                // This len check ensures that we don't somehow remove every frame, as doing so breaks\n+                // the primary error message.\n+                while stacktrace.len() > 1\n+                    && stacktrace.last().map_or(false, |frame| !machine.is_local(frame))\n+                {\n+                    stacktrace.pop();\n+                }\n+            }\n+            let was_pruned = stacktrace.len() != original_len;\n+            (stacktrace, was_pruned)\n+        }\n+        BacktraceStyle::Full => (stacktrace, false),\n+    }\n+}\n+\n+/// Emit a custom diagnostic without going through the miri-engine machinery\n+pub fn report_error<'tcx, 'mir>(\n+    ecx: &InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n+    e: InterpErrorInfo<'tcx>,\n+) -> Option<i64> {\n+    use InterpError::*;\n+\n+    let mut msg = vec![];\n+\n+    let (title, helps) = match &e.kind() {\n+        MachineStop(info) => {\n+            let info = info.downcast_ref::<TerminationInfo>().expect(\"invalid MachineStop payload\");\n+            use TerminationInfo::*;\n+            let title = match info {\n+                Exit(code) => return Some(*code),\n+                Abort(_) => Some(\"abnormal termination\"),\n+                UnsupportedInIsolation(_) | Int2PtrWithStrictProvenance =>\n+                    Some(\"unsupported operation\"),\n+                StackedBorrowsUb { .. } => Some(\"Undefined Behavior\"),\n+                Deadlock => Some(\"deadlock\"),\n+                MultipleSymbolDefinitions { .. } | SymbolShimClashing { .. } => None,\n+            };\n+            #[rustfmt::skip]\n+            let helps = match info {\n+                UnsupportedInIsolation(_) =>\n+                    vec![\n+                        (None, format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation;\")),\n+                        (None, format!(\"or pass `-Zmiri-isolation-error=warn` to configure Miri to return an error code from isolated operations (if supported for that operation) and continue with a warning\")),\n+                    ],\n+                StackedBorrowsUb { help, history, .. } => {\n+                    let url = \"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\";\n+                    msg.extend(help.clone());\n+                    let mut helps = vec![\n+                        (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\")),\n+                        (None, format!(\"see {url} for further information\")),\n+                    ];\n+                    if let Some(TagHistory {created, invalidated, protected}) = history.clone() {\n+                        helps.push((Some(created.1), created.0));\n+                        if let Some((msg, span)) = invalidated {\n+                            helps.push((Some(span), msg));\n+                        }\n+                        if let Some((protector_msg, protector_span)) = protected {\n+                            helps.push((Some(protector_span), protector_msg));\n+                        }\n+                    }\n+                    helps\n+                }\n+                MultipleSymbolDefinitions { first, first_crate, second, second_crate, .. } =>\n+                    vec![\n+                        (Some(*first), format!(\"it's first defined here, in crate `{first_crate}`\")),\n+                        (Some(*second), format!(\"then it's defined here again, in crate `{second_crate}`\")),\n+                    ],\n+                SymbolShimClashing { link_name, span } =>\n+                    vec![(Some(*span), format!(\"the `{link_name}` symbol is defined here\"))],\n+                Int2PtrWithStrictProvenance =>\n+                    vec![(None, format!(\"use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\"))],\n+                _ => vec![],\n+            };\n+            (title, helps)\n+        }\n+        _ => {\n+            #[rustfmt::skip]\n+            let title = match e.kind() {\n+                Unsupported(_) =>\n+                    \"unsupported operation\",\n+                UndefinedBehavior(_) =>\n+                    \"Undefined Behavior\",\n+                ResourceExhaustion(_) =>\n+                    \"resource exhaustion\",\n+                InvalidProgram(\n+                    InvalidProgramInfo::AlreadyReported(_) |\n+                    InvalidProgramInfo::Layout(..) |\n+                    InvalidProgramInfo::ReferencedConstant\n+                ) =>\n+                    \"post-monomorphization error\",\n+                kind =>\n+                    bug!(\"This error should be impossible in Miri: {kind:?}\"),\n+            };\n+            #[rustfmt::skip]\n+            let helps = match e.kind() {\n+                Unsupported(\n+                    UnsupportedOpInfo::ThreadLocalStatic(_) |\n+                    UnsupportedOpInfo::ReadExternStatic(_) |\n+                    UnsupportedOpInfo::PartialPointerOverwrite(_) | // we make memory uninit instead\n+                    UnsupportedOpInfo::ReadPointerAsBytes\n+                ) =>\n+                    panic!(\"Error should never be raised by Miri: {kind:?}\", kind = e.kind()),\n+                Unsupported(\n+                    UnsupportedOpInfo::Unsupported(_) |\n+                    UnsupportedOpInfo::PartialPointerCopy(_)\n+                ) =>\n+                    vec![(None, format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\"))],\n+                UndefinedBehavior(UndefinedBehaviorInfo::AlignmentCheckFailed { .. })\n+                    if ecx.machine.check_alignment == AlignmentCheck::Symbolic\n+                =>\n+                    vec![\n+                        (None, format!(\"this usually indicates that your program performed an invalid operation and caused Undefined Behavior\")),\n+                        (None, format!(\"but due to `-Zmiri-symbolic-alignment-check`, alignment errors can also be false positives\")),\n+                    ],\n+                UndefinedBehavior(_) =>\n+                    vec![\n+                        (None, format!(\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\")),\n+                        (None, format!(\"see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\")),\n+                    ],\n+                InvalidProgram(_) | ResourceExhaustion(_) | MachineStop(_) =>\n+                    vec![],\n+            };\n+            (Some(title), helps)\n+        }\n+    };\n+\n+    let stacktrace = ecx.generate_stacktrace();\n+    let (stacktrace, was_pruned) = prune_stacktrace(stacktrace, &ecx.machine);\n+    e.print_backtrace();\n+    msg.insert(0, e.to_string());\n+    report_msg(\n+        DiagLevel::Error,\n+        &if let Some(title) = title { format!(\"{}: {}\", title, msg[0]) } else { msg[0].clone() },\n+        msg,\n+        vec![],\n+        helps,\n+        &stacktrace,\n+        &ecx.machine,\n+    );\n+\n+    // Include a note like `std` does when we omit frames from a backtrace\n+    if was_pruned {\n+        ecx.tcx.sess.diagnostic().note_without_error(\n+            \"some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\",\n+        );\n+    }\n+\n+    // Debug-dump all locals.\n+    for (i, frame) in ecx.active_thread_stack().iter().enumerate() {\n+        trace!(\"-------------------\");\n+        trace!(\"Frame {}\", i);\n+        trace!(\"    return: {:?}\", *frame.return_place);\n+        for (i, local) in frame.locals.iter().enumerate() {\n+            trace!(\"    local {}: {:?}\", i, local.value);\n+        }\n+    }\n+\n+    // Extra output to help debug specific issues.\n+    match e.kind() {\n+        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) => {\n+            eprintln!(\n+                \"Uninitialized memory occurred at {alloc_id:?}{range:?}, in this allocation:\",\n+                range = access.uninit,\n+            );\n+            eprintln!(\"{:?}\", ecx.dump_alloc(*alloc_id));\n+        }\n+        _ => {}\n+    }\n+\n+    None\n+}\n+\n+/// Report an error or note (depending on the `error` argument) with the given stacktrace.\n+/// Also emits a full stacktrace of the interpreter stack.\n+/// We want to present a multi-line span message for some errors. Diagnostics do not support this\n+/// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n+/// additional `span_label` or `note` call.\n+fn report_msg<'tcx>(\n+    diag_level: DiagLevel,\n+    title: &str,\n+    span_msg: Vec<String>,\n+    notes: Vec<(Option<SpanData>, String)>,\n+    helps: Vec<(Option<SpanData>, String)>,\n+    stacktrace: &[FrameInfo<'tcx>],\n+    machine: &MiriMachine<'_, 'tcx>,\n+) {\n+    let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n+    let sess = machine.tcx.sess;\n+    let mut err = match diag_level {\n+        DiagLevel::Error => sess.struct_span_err(span, title).forget_guarantee(),\n+        DiagLevel::Warning => sess.struct_span_warn(span, title),\n+        DiagLevel::Note => sess.diagnostic().span_note_diag(span, title),\n+    };\n+\n+    // Show main message.\n+    if span != DUMMY_SP {\n+        for line in span_msg {\n+            err.span_label(span, line);\n+        }\n+    } else {\n+        // Make sure we show the message even when it is a dummy span.\n+        for line in span_msg {\n+            err.note(&line);\n+        }\n+        err.note(\"(no span available)\");\n+    }\n+\n+    // Show note and help messages.\n+    for (span_data, note) in &notes {\n+        if let Some(span_data) = span_data {\n+            err.span_note(span_data.span(), note);\n+        } else {\n+            err.note(note);\n+        }\n+    }\n+    for (span_data, help) in &helps {\n+        if let Some(span_data) = span_data {\n+            err.span_help(span_data.span(), help);\n+        } else {\n+            err.help(help);\n+        }\n+    }\n+    if notes.len() + helps.len() > 0 {\n+        // Add visual separator before backtrace.\n+        err.note(\"BACKTRACE:\");\n+    }\n+    // Add backtrace\n+    for (idx, frame_info) in stacktrace.iter().enumerate() {\n+        let is_local = machine.is_local(frame_info);\n+        // No span for non-local frames and the first frame (which is the error site).\n+        if is_local && idx > 0 {\n+            err.span_note(frame_info.span, &frame_info.to_string());\n+        } else {\n+            err.note(&frame_info.to_string());\n+        }\n+    }\n+\n+    err.emit();\n+}\n+\n+impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n+    pub fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n+        use NonHaltingDiagnostic::*;\n+\n+        let stacktrace =\n+            MiriInterpCx::generate_stacktrace_from_stack(self.threads.active_thread_stack());\n+        let (stacktrace, _was_pruned) = prune_stacktrace(stacktrace, self);\n+\n+        let (title, diag_level) = match e {\n+            RejectedIsolatedOp(_) => (\"operation rejected by isolation\", DiagLevel::Warning),\n+            Int2Ptr { .. } => (\"integer-to-pointer cast\", DiagLevel::Warning),\n+            CreatedPointerTag(..)\n+            | PoppedPointerTag(..)\n+            | CreatedCallId(..)\n+            | CreatedAlloc(..)\n+            | FreedAlloc(..)\n+            | ProgressReport { .. }\n+            | WeakMemoryOutdatedLoad => (\"tracking was triggered\", DiagLevel::Note),\n+        };\n+\n+        let msg = match e {\n+            CreatedPointerTag(tag, None) => format!(\"created tag {tag:?}\"),\n+            CreatedPointerTag(tag, Some((alloc_id, range))) =>\n+                format!(\"created tag {tag:?} at {alloc_id:?}{range:?}\"),\n+            PoppedPointerTag(item, tag) =>\n+                match tag {\n+                    None => format!(\"popped tracked tag for item {item:?} due to deallocation\",),\n+                    Some((tag, access)) => {\n+                        format!(\n+                            \"popped tracked tag for item {item:?} due to {access:?} access for {tag:?}\",\n+                        )\n+                    }\n+                },\n+            CreatedCallId(id) => format!(\"function call with id {id}\"),\n+            CreatedAlloc(AllocId(id), size, align, kind) =>\n+                format!(\n+                    \"created {kind} allocation of {size} bytes (alignment {align} bytes) with id {id}\",\n+                    size = size.bytes(),\n+                    align = align.bytes(),\n+                ),\n+            FreedAlloc(AllocId(id)) => format!(\"freed allocation with id {id}\"),\n+            RejectedIsolatedOp(ref op) =>\n+                format!(\"{op} was made to return an error due to isolation\"),\n+            ProgressReport { .. } =>\n+                format!(\"progress report: current operation being executed is here\"),\n+            Int2Ptr { .. } => format!(\"integer-to-pointer cast\"),\n+            WeakMemoryOutdatedLoad =>\n+                format!(\"weak memory emulation: outdated value returned from load\"),\n+        };\n+\n+        let notes = match e {\n+            ProgressReport { block_count } => {\n+                // It is important that each progress report is slightly different, since\n+                // identical diagnostics are being deduplicated.\n+                vec![(None, format!(\"so far, {block_count} basic blocks have been executed\"))]\n+            }\n+            _ => vec![],\n+        };\n+\n+        let helps = match e {\n+            Int2Ptr { details: true } =>\n+                vec![\n+                    (\n+                        None,\n+                        format!(\n+                            \"This program is using integer-to-pointer casts or (equivalently) `ptr::from_exposed_addr`,\"\n+                        ),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\"which means that Miri might miss pointer bugs in this program.\"),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\n+                            \"See https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation.\"\n+                        ),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\n+                            \"To ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead.\"\n+                        ),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\n+                            \"You can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics.\"\n+                        ),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\n+                            \"Alternatively, the `-Zmiri-permissive-provenance` flag disables this warning.\"\n+                        ),\n+                    ),\n+                ],\n+            _ => vec![],\n+        };\n+\n+        report_msg(diag_level, title, vec![msg], notes, helps, &stacktrace, self);\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n+        let this = self.eval_context_ref();\n+        this.machine.emit_diagnostic(e);\n+    }\n+\n+    /// We had a panic in Miri itself, try to print something useful.\n+    fn handle_ice(&self) {\n+        eprintln!();\n+        eprintln!(\n+            \"Miri caused an ICE during evaluation. Here's the interpreter backtrace at the time of the panic:\"\n+        );\n+        let this = self.eval_context_ref();\n+        let stacktrace = this.generate_stacktrace();\n+        report_msg(\n+            DiagLevel::Note,\n+            \"the place in the program where the ICE was triggered\",\n+            vec![],\n+            vec![],\n+            vec![],\n+            &stacktrace,\n+            &this.machine,\n+        );\n+    }\n+}"}, {"sha": "91a2ac13b1b1986652b0ff0c618adbec2c4c0ef2", "filename": "src/tools/miri/src/eval.rs", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,514 @@\n+//! Main evaluator loop and setting up the initial stack frame.\n+\n+use std::ffi::{OsStr, OsString};\n+use std::iter;\n+use std::panic::{self, AssertUnwindSafe};\n+use std::path::PathBuf;\n+use std::thread;\n+\n+use log::info;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{\n+    self,\n+    layout::{LayoutCx, LayoutOf},\n+    TyCtxt,\n+};\n+use rustc_target::spec::abi::Abi;\n+\n+use rustc_session::config::EntryFnType;\n+\n+use crate::*;\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum AlignmentCheck {\n+    /// Do not check alignment.\n+    None,\n+    /// Check alignment \"symbolically\", i.e., using only the requested alignment for an allocation and not its real base address.\n+    Symbolic,\n+    /// Check alignment on the actual physical integer address.\n+    Int,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum RejectOpWith {\n+    /// Isolated op is rejected with an abort of the machine.\n+    Abort,\n+\n+    /// If not Abort, miri returns an error for an isolated op.\n+    /// Following options determine if user should be warned about such error.\n+    /// Do not print warning about rejected isolated op.\n+    NoWarning,\n+\n+    /// Print a warning about rejected isolated op, with backtrace.\n+    Warning,\n+\n+    /// Print a warning about rejected isolated op, without backtrace.\n+    WarningWithoutBacktrace,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum IsolatedOp {\n+    /// Reject an op requiring communication with the host. By\n+    /// default, miri rejects the op with an abort. If not, it returns\n+    /// an error code, and prints a warning about it. Warning levels\n+    /// are controlled by `RejectOpWith` enum.\n+    Reject(RejectOpWith),\n+\n+    /// Execute op requiring communication with the host, i.e. disable isolation.\n+    Allow,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum BacktraceStyle {\n+    /// Prints a terser backtrace which ideally only contains relevant information.\n+    Short,\n+    /// Prints a backtrace with all possible information.\n+    Full,\n+    /// Prints only the frame that the error occurs in.\n+    Off,\n+}\n+\n+/// Configuration needed to spawn a Miri instance.\n+#[derive(Clone)]\n+pub struct MiriConfig {\n+    /// The host environment snapshot to use as basis for what is provided to the interpreted program.\n+    /// (This is still subject to isolation as well as `forwarded_env_vars`.)\n+    pub env: Vec<(OsString, OsString)>,\n+    /// Determine if validity checking is enabled.\n+    pub validate: bool,\n+    /// Determines if Stacked Borrows is enabled.\n+    pub stacked_borrows: bool,\n+    /// Controls alignment checking.\n+    pub check_alignment: AlignmentCheck,\n+    /// Controls function [ABI](Abi) checking.\n+    pub check_abi: bool,\n+    /// Action for an op requiring communication with the host.\n+    pub isolated_op: IsolatedOp,\n+    /// Determines if memory leaks should be ignored.\n+    pub ignore_leaks: bool,\n+    /// Environment variables that should always be forwarded from the host.\n+    pub forwarded_env_vars: Vec<String>,\n+    /// Command-line arguments passed to the interpreted program.\n+    pub args: Vec<String>,\n+    /// The seed to use when non-determinism or randomness are required (e.g. ptr-to-int cast, `getrandom()`).\n+    pub seed: Option<u64>,\n+    /// The stacked borrows pointer ids to report about\n+    pub tracked_pointer_tags: FxHashSet<SbTag>,\n+    /// The stacked borrows call IDs to report about\n+    pub tracked_call_ids: FxHashSet<CallId>,\n+    /// The allocation ids to report about.\n+    pub tracked_alloc_ids: FxHashSet<AllocId>,\n+    /// Determine if data race detection should be enabled\n+    pub data_race_detector: bool,\n+    /// Determine if weak memory emulation should be enabled. Requires data race detection to be enabled\n+    pub weak_memory_emulation: bool,\n+    /// Track when an outdated (weak memory) load happens.\n+    pub track_outdated_loads: bool,\n+    /// Rate of spurious failures for compare_exchange_weak atomic operations,\n+    /// between 0.0 and 1.0, defaulting to 0.8 (80% chance of failure).\n+    pub cmpxchg_weak_failure_rate: f64,\n+    /// If `Some`, enable the `measureme` profiler, writing results to a file\n+    /// with the specified prefix.\n+    pub measureme_out: Option<String>,\n+    /// Panic when unsupported functionality is encountered.\n+    pub panic_on_unsupported: bool,\n+    /// Which style to use for printing backtraces.\n+    pub backtrace_style: BacktraceStyle,\n+    /// Which provenance to use for int2ptr casts\n+    pub provenance_mode: ProvenanceMode,\n+    /// Whether to ignore any output by the program. This is helpful when debugging miri\n+    /// as its messages don't get intermingled with the program messages.\n+    pub mute_stdout_stderr: bool,\n+    /// The probability of the active thread being preempted at the end of each basic block.\n+    pub preemption_rate: f64,\n+    /// Report the current instruction being executed every N basic blocks.\n+    pub report_progress: Option<u32>,\n+    /// Whether Stacked Borrows retagging should recurse into fields of datatypes.\n+    pub retag_fields: bool,\n+    /// The location of a shared object file to load when calling external functions\n+    /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory\n+    pub external_so_file: Option<PathBuf>,\n+    /// Run a garbage collector for SbTags every N basic blocks.\n+    pub gc_interval: u32,\n+}\n+\n+impl Default for MiriConfig {\n+    fn default() -> MiriConfig {\n+        MiriConfig {\n+            env: vec![],\n+            validate: true,\n+            stacked_borrows: true,\n+            check_alignment: AlignmentCheck::Int,\n+            check_abi: true,\n+            isolated_op: IsolatedOp::Reject(RejectOpWith::Abort),\n+            ignore_leaks: false,\n+            forwarded_env_vars: vec![],\n+            args: vec![],\n+            seed: None,\n+            tracked_pointer_tags: FxHashSet::default(),\n+            tracked_call_ids: FxHashSet::default(),\n+            tracked_alloc_ids: FxHashSet::default(),\n+            data_race_detector: true,\n+            weak_memory_emulation: true,\n+            track_outdated_loads: false,\n+            cmpxchg_weak_failure_rate: 0.8, // 80%\n+            measureme_out: None,\n+            panic_on_unsupported: false,\n+            backtrace_style: BacktraceStyle::Short,\n+            provenance_mode: ProvenanceMode::Default,\n+            mute_stdout_stderr: false,\n+            preemption_rate: 0.01, // 1%\n+            report_progress: None,\n+            retag_fields: false,\n+            external_so_file: None,\n+            gc_interval: 10_000,\n+        }\n+    }\n+}\n+\n+/// Returns a freshly created `InterpCx`, along with an `MPlaceTy` representing\n+/// the location where the return value of the `start` function will be\n+/// written to.\n+/// Public because this is also used by `priroda`.\n+pub fn create_ecx<'mir, 'tcx: 'mir>(\n+    tcx: TyCtxt<'tcx>,\n+    entry_id: DefId,\n+    entry_type: EntryFnType,\n+    config: &MiriConfig,\n+) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>, MPlaceTy<'tcx, Provenance>)>\n+{\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let layout_cx = LayoutCx { tcx, param_env };\n+    let mut ecx = InterpCx::new(\n+        tcx,\n+        rustc_span::source_map::DUMMY_SP,\n+        param_env,\n+        MiriMachine::new(config, layout_cx),\n+    );\n+\n+    // Some parts of initialization require a full `InterpCx`.\n+    MiriMachine::late_init(&mut ecx, config)?;\n+\n+    // Make sure we have MIR. We check MIR for some stable monomorphic function in libcore.\n+    let sentinel = ecx.try_resolve_path(&[\"core\", \"ascii\", \"escape_default\"]);\n+    if !matches!(sentinel, Some(s) if tcx.is_mir_available(s.def.def_id())) {\n+        tcx.sess.fatal(\n+            \"the current sysroot was built without `-Zalways-encode-mir`, or libcore seems missing. \\\n+            Use `cargo miri setup` to prepare a sysroot that is suitable for Miri.\"\n+        );\n+    }\n+\n+    // Setup first stack frame.\n+    let entry_instance = ty::Instance::mono(tcx, entry_id);\n+\n+    // First argument is constructed later, because it's skipped if the entry function uses #[start].\n+\n+    // Second argument (argc): length of `config.args`.\n+    let argc = Scalar::from_machine_usize(u64::try_from(config.args.len()).unwrap(), &ecx);\n+    // Third argument (`argv`): created from `config.args`.\n+    let argv = {\n+        // Put each argument in memory, collect pointers.\n+        let mut argvs = Vec::<Immediate<Provenance>>::new();\n+        for arg in config.args.iter() {\n+            // Make space for `0` terminator.\n+            let size = u64::try_from(arg.len()).unwrap().checked_add(1).unwrap();\n+            let arg_type = tcx.mk_array(tcx.types.u8, size);\n+            let arg_place =\n+                ecx.allocate(ecx.layout_of(arg_type)?, MiriMemoryKind::Machine.into())?;\n+            ecx.write_os_str_to_c_str(OsStr::new(arg), arg_place.ptr, size)?;\n+            ecx.mark_immutable(&arg_place);\n+            argvs.push(arg_place.to_ref(&ecx));\n+        }\n+        // Make an array with all these pointers, in the Miri memory.\n+        let argvs_layout = ecx.layout_of(\n+            tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), u64::try_from(argvs.len()).unwrap()),\n+        )?;\n+        let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Machine.into())?;\n+        for (idx, arg) in argvs.into_iter().enumerate() {\n+            let place = ecx.mplace_field(&argvs_place, idx)?;\n+            ecx.write_immediate(arg, &place.into())?;\n+        }\n+        ecx.mark_immutable(&argvs_place);\n+        // A pointer to that place is the 3rd argument for main.\n+        let argv = argvs_place.to_ref(&ecx);\n+        // Store `argc` and `argv` for macOS `_NSGetArg{c,v}`.\n+        {\n+            let argc_place =\n+                ecx.allocate(ecx.machine.layouts.isize, MiriMemoryKind::Machine.into())?;\n+            ecx.write_scalar(argc, &argc_place.into())?;\n+            ecx.mark_immutable(&argc_place);\n+            ecx.machine.argc = Some(*argc_place);\n+\n+            let argv_place = ecx.allocate(\n+                ecx.layout_of(tcx.mk_imm_ptr(tcx.types.unit))?,\n+                MiriMemoryKind::Machine.into(),\n+            )?;\n+            ecx.write_immediate(argv, &argv_place.into())?;\n+            ecx.mark_immutable(&argv_place);\n+            ecx.machine.argv = Some(*argv_place);\n+        }\n+        // Store command line as UTF-16 for Windows `GetCommandLineW`.\n+        {\n+            // Construct a command string with all the arguments.\n+            let cmd_utf16: Vec<u16> = args_to_utf16_command_string(config.args.iter());\n+\n+            let cmd_type = tcx.mk_array(tcx.types.u16, u64::try_from(cmd_utf16.len()).unwrap());\n+            let cmd_place =\n+                ecx.allocate(ecx.layout_of(cmd_type)?, MiriMemoryKind::Machine.into())?;\n+            ecx.machine.cmd_line = Some(*cmd_place);\n+            // Store the UTF-16 string. We just allocated so we know the bounds are fine.\n+            for (idx, &c) in cmd_utf16.iter().enumerate() {\n+                let place = ecx.mplace_field(&cmd_place, idx)?;\n+                ecx.write_scalar(Scalar::from_u16(c), &place.into())?;\n+            }\n+            ecx.mark_immutable(&cmd_place);\n+        }\n+        argv\n+    };\n+\n+    // Return place (in static memory so that it does not count as leak).\n+    let ret_place = ecx.allocate(ecx.machine.layouts.isize, MiriMemoryKind::Machine.into())?;\n+    // Call start function.\n+\n+    match entry_type {\n+        EntryFnType::Main { .. } => {\n+            let start_id = tcx.lang_items().start_fn().unwrap();\n+            let main_ret_ty = tcx.fn_sig(entry_id).output();\n+            let main_ret_ty = main_ret_ty.no_bound_vars().unwrap();\n+            let start_instance = ty::Instance::resolve(\n+                tcx,\n+                ty::ParamEnv::reveal_all(),\n+                start_id,\n+                tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(main_ret_ty))),\n+            )\n+            .unwrap()\n+            .unwrap();\n+\n+            let main_ptr = ecx.create_fn_alloc_ptr(FnVal::Instance(entry_instance));\n+\n+            // Inlining of `DEFAULT` from\n+            // https://github.com/rust-lang/rust/blob/master/compiler/rustc_session/src/config/sigpipe.rs.\n+            // Alaways using DEFAULT is okay since we don't support signals in Miri anyway.\n+            let sigpipe = 2;\n+\n+            ecx.call_function(\n+                start_instance,\n+                Abi::Rust,\n+                &[\n+                    Scalar::from_pointer(main_ptr, &ecx).into(),\n+                    argc.into(),\n+                    argv,\n+                    Scalar::from_u8(sigpipe).into(),\n+                ],\n+                Some(&ret_place.into()),\n+                StackPopCleanup::Root { cleanup: true },\n+            )?;\n+        }\n+        EntryFnType::Start => {\n+            ecx.call_function(\n+                entry_instance,\n+                Abi::Rust,\n+                &[argc.into(), argv],\n+                Some(&ret_place.into()),\n+                StackPopCleanup::Root { cleanup: true },\n+            )?;\n+        }\n+    }\n+\n+    Ok((ecx, ret_place))\n+}\n+\n+/// Evaluates the entry function specified by `entry_id`.\n+/// Returns `Some(return_code)` if program executed completed.\n+/// Returns `None` if an evaluation error occurred.\n+#[allow(clippy::needless_lifetimes)]\n+pub fn eval_entry<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    entry_id: DefId,\n+    entry_type: EntryFnType,\n+    config: MiriConfig,\n+) -> Option<i64> {\n+    // Copy setting before we move `config`.\n+    let ignore_leaks = config.ignore_leaks;\n+\n+    let (mut ecx, ret_place) = match create_ecx(tcx, entry_id, entry_type, &config) {\n+        Ok(v) => v,\n+        Err(err) => {\n+            err.print_backtrace();\n+            panic!(\"Miri initialization error: {}\", err.kind())\n+        }\n+    };\n+\n+    // Perform the main execution.\n+    let res: thread::Result<InterpResult<'_, i64>> = panic::catch_unwind(AssertUnwindSafe(|| {\n+        // Main loop.\n+        loop {\n+            match ecx.schedule()? {\n+                SchedulingAction::ExecuteStep => {\n+                    assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n+                }\n+                SchedulingAction::ExecuteTimeoutCallback => {\n+                    ecx.run_timeout_callback()?;\n+                }\n+                SchedulingAction::ExecuteDtors => {\n+                    // This will either enable the thread again (so we go back\n+                    // to `ExecuteStep`), or determine that this thread is done\n+                    // for good.\n+                    ecx.schedule_next_tls_dtor_for_active_thread()?;\n+                }\n+                SchedulingAction::Stop => {\n+                    break;\n+                }\n+            }\n+        }\n+        let return_code = ecx.read_scalar(&ret_place.into())?.to_machine_isize(&ecx)?;\n+        Ok(return_code)\n+    }));\n+    let res = res.unwrap_or_else(|panic_payload| {\n+        ecx.handle_ice();\n+        panic::resume_unwind(panic_payload)\n+    });\n+\n+    // Machine cleanup. Only do this if all threads have terminated; threads that are still running\n+    // might cause Stacked Borrows errors (https://github.com/rust-lang/miri/issues/2396).\n+    if ecx.have_all_terminated() {\n+        // Even if all threads have terminated, we have to beware of data races since some threads\n+        // might not have joined the main thread (https://github.com/rust-lang/miri/issues/2020,\n+        // https://github.com/rust-lang/miri/issues/2508).\n+        ecx.allow_data_races_all_threads_done();\n+        EnvVars::cleanup(&mut ecx).expect(\"error during env var cleanup\");\n+    }\n+\n+    // Process the result.\n+    match res {\n+        Ok(return_code) => {\n+            if !ignore_leaks {\n+                // Check for thread leaks.\n+                if !ecx.have_all_terminated() {\n+                    tcx.sess.err(\n+                        \"the main thread terminated without waiting for all remaining threads\",\n+                    );\n+                    tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n+                    return None;\n+                }\n+                // Check for memory leaks.\n+                info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n+                let leaks = ecx.leak_report(&ecx.machine.static_roots);\n+                if leaks != 0 {\n+                    tcx.sess.err(\"the evaluated program leaked memory\");\n+                    tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n+                    // Ignore the provided return code - let the reported error\n+                    // determine the return code.\n+                    return None;\n+                }\n+            }\n+            Some(return_code)\n+        }\n+        Err(e) => report_error(&ecx, e),\n+    }\n+}\n+\n+/// Turns an array of arguments into a Windows command line string.\n+///\n+/// The string will be UTF-16 encoded and NUL terminated.\n+///\n+/// Panics if the zeroth argument contains the `\"` character because doublequotes\n+/// in `argv[0]` cannot be encoded using the standard command line parsing rules.\n+///\n+/// Further reading:\n+/// * [Parsing C++ command-line arguments](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-160#parsing-c-command-line-arguments)\n+/// * [The C/C++ Parameter Parsing Rules](https://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES)\n+fn args_to_utf16_command_string<I, T>(mut args: I) -> Vec<u16>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<str>,\n+{\n+    // Parse argv[0]. Slashes aren't escaped. Literal double quotes are not allowed.\n+    let mut cmd = {\n+        let arg0 = if let Some(arg0) = args.next() {\n+            arg0\n+        } else {\n+            return vec![0];\n+        };\n+        let arg0 = arg0.as_ref();\n+        if arg0.contains('\"') {\n+            panic!(\"argv[0] cannot contain a doublequote (\\\") character\");\n+        } else {\n+            // Always surround argv[0] with quotes.\n+            let mut s = String::new();\n+            s.push('\"');\n+            s.push_str(arg0);\n+            s.push('\"');\n+            s\n+        }\n+    };\n+\n+    // Build the other arguments.\n+    for arg in args {\n+        let arg = arg.as_ref();\n+        cmd.push(' ');\n+        if arg.is_empty() {\n+            cmd.push_str(\"\\\"\\\"\");\n+        } else if !arg.bytes().any(|c| matches!(c, b'\"' | b'\\t' | b' ')) {\n+            // No quote, tab, or space -- no escaping required.\n+            cmd.push_str(arg);\n+        } else {\n+            // Spaces and tabs are escaped by surrounding them in quotes.\n+            // Quotes are themselves escaped by using backslashes when in a\n+            // quoted block.\n+            // Backslashes only need to be escaped when one or more are directly\n+            // followed by a quote. Otherwise they are taken literally.\n+\n+            cmd.push('\"');\n+            let mut chars = arg.chars().peekable();\n+            loop {\n+                let mut nslashes = 0;\n+                while let Some(&'\\\\') = chars.peek() {\n+                    chars.next();\n+                    nslashes += 1;\n+                }\n+\n+                match chars.next() {\n+                    Some('\"') => {\n+                        cmd.extend(iter::repeat('\\\\').take(nslashes * 2 + 1));\n+                        cmd.push('\"');\n+                    }\n+                    Some(c) => {\n+                        cmd.extend(iter::repeat('\\\\').take(nslashes));\n+                        cmd.push(c);\n+                    }\n+                    None => {\n+                        cmd.extend(iter::repeat('\\\\').take(nslashes * 2));\n+                        break;\n+                    }\n+                }\n+            }\n+            cmd.push('\"');\n+        }\n+    }\n+\n+    if cmd.contains('\\0') {\n+        panic!(\"interior null in command line arguments\");\n+    }\n+    cmd.encode_utf16().chain(iter::once(0)).collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    #[test]\n+    #[should_panic(expected = \"argv[0] cannot contain a doublequote (\\\") character\")]\n+    fn windows_argv0_panic_on_quote() {\n+        args_to_utf16_command_string([\"\\\"\"].iter());\n+    }\n+    #[test]\n+    fn windows_argv0_no_escape() {\n+        // Ensure that a trailing backslash in argv[0] is not escaped.\n+        let cmd = String::from_utf16_lossy(&args_to_utf16_command_string(\n+            [r\"C:\\Program Files\\\", \"arg1\", \"arg 2\", \"arg \\\" 3\"].iter(),\n+        ));\n+        assert_eq!(cmd.trim_end_matches('\\0'), r#\"\"C:\\Program Files\\\" arg1 \"arg 2\" \"arg \\\" 3\"\"#);\n+    }\n+}"}, {"sha": "0f0bfa355bdc71fde50b7ca01eb586297e947054", "filename": "src/tools/miri/src/helpers.rs", "status": "added", "additions": 1004, "deletions": 0, "changes": 1004, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,1004 @@\n+pub mod convert;\n+\n+use std::mem;\n+use std::num::NonZeroUsize;\n+use std::time::Duration;\n+\n+use log::trace;\n+\n+use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_middle::mir;\n+use rustc_middle::ty::{\n+    self,\n+    layout::{LayoutOf, TyAndLayout},\n+    List, TyCtxt,\n+};\n+use rustc_span::{def_id::CrateNum, sym, Span, Symbol};\n+use rustc_target::abi::{Align, FieldsShape, Size, Variants};\n+use rustc_target::spec::abi::Abi;\n+\n+use rand::RngCore;\n+\n+use crate::*;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+\n+// This mapping should match `decode_error_kind` in\n+// <https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/mod.rs>.\n+const UNIX_IO_ERROR_TABLE: &[(&str, std::io::ErrorKind)] = {\n+    use std::io::ErrorKind::*;\n+    &[\n+        (\"E2BIG\", ArgumentListTooLong),\n+        (\"EADDRINUSE\", AddrInUse),\n+        (\"EADDRNOTAVAIL\", AddrNotAvailable),\n+        (\"EBUSY\", ResourceBusy),\n+        (\"ECONNABORTED\", ConnectionAborted),\n+        (\"ECONNREFUSED\", ConnectionRefused),\n+        (\"ECONNRESET\", ConnectionReset),\n+        (\"EDEADLK\", Deadlock),\n+        (\"EDQUOT\", FilesystemQuotaExceeded),\n+        (\"EEXIST\", AlreadyExists),\n+        (\"EFBIG\", FileTooLarge),\n+        (\"EHOSTUNREACH\", HostUnreachable),\n+        (\"EINTR\", Interrupted),\n+        (\"EINVAL\", InvalidInput),\n+        (\"EISDIR\", IsADirectory),\n+        (\"ELOOP\", FilesystemLoop),\n+        (\"ENOENT\", NotFound),\n+        (\"ENOMEM\", OutOfMemory),\n+        (\"ENOSPC\", StorageFull),\n+        (\"ENOSYS\", Unsupported),\n+        (\"EMLINK\", TooManyLinks),\n+        (\"ENAMETOOLONG\", InvalidFilename),\n+        (\"ENETDOWN\", NetworkDown),\n+        (\"ENETUNREACH\", NetworkUnreachable),\n+        (\"ENOTCONN\", NotConnected),\n+        (\"ENOTDIR\", NotADirectory),\n+        (\"ENOTEMPTY\", DirectoryNotEmpty),\n+        (\"EPIPE\", BrokenPipe),\n+        (\"EROFS\", ReadOnlyFilesystem),\n+        (\"ESPIPE\", NotSeekable),\n+        (\"ESTALE\", StaleNetworkFileHandle),\n+        (\"ETIMEDOUT\", TimedOut),\n+        (\"ETXTBSY\", ExecutableFileBusy),\n+        (\"EXDEV\", CrossesDevices),\n+        // The following have two valid options. We have both for the forwards mapping; only the\n+        // first one will be used for the backwards mapping.\n+        (\"EPERM\", PermissionDenied),\n+        (\"EACCES\", PermissionDenied),\n+        (\"EWOULDBLOCK\", WouldBlock),\n+        (\"EAGAIN\", WouldBlock),\n+    ]\n+};\n+\n+/// Gets an instance for a path.\n+fn try_resolve_did<'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId> {\n+    tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == path[0]).and_then(\n+        |krate| {\n+            let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n+            let mut items = tcx.module_children(krate);\n+            let mut path_it = path.iter().skip(1).peekable();\n+\n+            while let Some(segment) = path_it.next() {\n+                for item in mem::take(&mut items).iter() {\n+                    if item.ident.name.as_str() == *segment {\n+                        if path_it.peek().is_none() {\n+                            return Some(item.res.def_id());\n+                        }\n+\n+                        items = tcx.module_children(item.res.def_id());\n+                        break;\n+                    }\n+                }\n+            }\n+            None\n+        },\n+    )\n+}\n+\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Gets an instance for a path; fails gracefully if the path does not exist.\n+    fn try_resolve_path(&self, path: &[&str]) -> Option<ty::Instance<'tcx>> {\n+        let did = try_resolve_did(self.eval_context_ref().tcx.tcx, path)?;\n+        Some(ty::Instance::mono(self.eval_context_ref().tcx.tcx, did))\n+    }\n+\n+    /// Gets an instance for a path.\n+    fn resolve_path(&self, path: &[&str]) -> ty::Instance<'tcx> {\n+        self.try_resolve_path(path)\n+            .unwrap_or_else(|| panic!(\"failed to find required Rust item: {:?}\", path))\n+    }\n+\n+    /// Evaluates the scalar at the specified path. Returns Some(val)\n+    /// if the path could be resolved, and None otherwise\n+    fn eval_path_scalar(&self, path: &[&str]) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_ref();\n+        let instance = this.resolve_path(path);\n+        let cid = GlobalId { instance, promoted: None };\n+        let const_val = this.eval_to_allocation(cid)?;\n+        this.read_scalar(&const_val.into())\n+    }\n+\n+    /// Helper function to get a `libc` constant as a `Scalar`.\n+    fn eval_libc(&self, name: &str) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        self.eval_path_scalar(&[\"libc\", name])\n+    }\n+\n+    /// Helper function to get a `libc` constant as an `i32`.\n+    fn eval_libc_i32(&self, name: &str) -> InterpResult<'tcx, i32> {\n+        // TODO: Cache the result.\n+        self.eval_libc(name)?.to_i32()\n+    }\n+\n+    /// Helper function to get a `windows` constant as a `Scalar`.\n+    fn eval_windows(&self, module: &str, name: &str) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        self.eval_context_ref().eval_path_scalar(&[\"std\", \"sys\", \"windows\", module, name])\n+    }\n+\n+    /// Helper function to get a `windows` constant as a `u64`.\n+    fn eval_windows_u64(&self, module: &str, name: &str) -> InterpResult<'tcx, u64> {\n+        // TODO: Cache the result.\n+        self.eval_windows(module, name)?.to_u64()\n+    }\n+\n+    /// Helper function to get the `TyAndLayout` of a `libc` type\n+    fn libc_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n+        let this = self.eval_context_ref();\n+        let ty = this.resolve_path(&[\"libc\", name]).ty(*this.tcx, ty::ParamEnv::reveal_all());\n+        this.layout_of(ty)\n+    }\n+\n+    /// Helper function to get the `TyAndLayout` of a `windows` type\n+    fn windows_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n+        let this = self.eval_context_ref();\n+        let ty = this\n+            .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name])\n+            .ty(*this.tcx, ty::ParamEnv::reveal_all());\n+        this.layout_of(ty)\n+    }\n+\n+    /// Project to the given *named* field of the mplace (which must be a struct or union type).\n+    fn mplace_field_named(\n+        &self,\n+        mplace: &MPlaceTy<'tcx, Provenance>,\n+        name: &str,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Provenance>> {\n+        let this = self.eval_context_ref();\n+        let adt = mplace.layout.ty.ty_adt_def().unwrap();\n+        for (idx, field) in adt.non_enum_variant().fields.iter().enumerate() {\n+            if field.name.as_str() == name {\n+                return this.mplace_field(mplace, idx);\n+            }\n+        }\n+        bug!(\"No field named {} in type {}\", name, mplace.layout.ty);\n+    }\n+\n+    /// Write an int of the appropriate size to `dest`. The target type may be signed or unsigned,\n+    /// we try to do the right thing anyway. `i128` can fit all integer types except for `u128` so\n+    /// this method is fine for almost all integer types.\n+    fn write_int(\n+        &mut self,\n+        i: impl Into<i128>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        assert!(dest.layout.abi.is_scalar(), \"write_int on non-scalar type {}\", dest.layout.ty);\n+        let val = if dest.layout.abi.is_signed() {\n+            Scalar::from_int(i, dest.layout.size)\n+        } else {\n+            Scalar::from_uint(u64::try_from(i.into()).unwrap(), dest.layout.size)\n+        };\n+        self.eval_context_mut().write_scalar(val, dest)\n+    }\n+\n+    /// Write the first N fields of the given place.\n+    fn write_int_fields(\n+        &mut self,\n+        values: &[i128],\n+        dest: &MPlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for (idx, &val) in values.iter().enumerate() {\n+            let field = this.mplace_field(dest, idx)?;\n+            this.write_int(val, &field.into())?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Write the given fields of the given place.\n+    fn write_int_fields_named(\n+        &mut self,\n+        values: &[(&str, i128)],\n+        dest: &MPlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for &(name, val) in values.iter() {\n+            let field = this.mplace_field_named(dest, name)?;\n+            this.write_int(val, &field.into())?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Write a 0 of the appropriate size to `dest`.\n+    fn write_null(&mut self, dest: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        self.write_int(0, dest)\n+    }\n+\n+    /// Test if this pointer equals 0.\n+    fn ptr_is_null(&self, ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, bool> {\n+        Ok(ptr.addr().bytes() == 0)\n+    }\n+\n+    /// Get the `Place` for a local\n+    fn local_place(&mut self, local: mir::Local) -> InterpResult<'tcx, PlaceTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        let place = mir::Place { local, projection: List::empty() };\n+        this.eval_place(place)\n+    }\n+\n+    /// Generate some random bytes, and write them to `dest`.\n+    fn gen_random(&mut self, ptr: Pointer<Option<Provenance>>, len: u64) -> InterpResult<'tcx> {\n+        // Some programs pass in a null pointer and a length of 0\n+        // to their platform's random-generation function (e.g. getrandom())\n+        // on Linux. For compatibility with these programs, we don't perform\n+        // any additional checks - it's okay if the pointer is invalid,\n+        // since we wouldn't actually be writing to it.\n+        if len == 0 {\n+            return Ok(());\n+        }\n+        let this = self.eval_context_mut();\n+\n+        let mut data = vec![0; usize::try_from(len).unwrap()];\n+\n+        if this.machine.communicate() {\n+            // Fill the buffer using the host's rng.\n+            getrandom::getrandom(&mut data)\n+                .map_err(|err| err_unsup_format!(\"host getrandom failed: {}\", err))?;\n+        } else {\n+            let rng = this.machine.rng.get_mut();\n+            rng.fill_bytes(&mut data);\n+        }\n+\n+        this.write_bytes_ptr(ptr, data.iter().copied())\n+    }\n+\n+    /// Call a function: Push the stack frame and pass the arguments.\n+    /// For now, arguments must be scalars (so that the caller does not have to know the layout).\n+    ///\n+    /// If you do not provie a return place, a dangling zero-sized place will be created\n+    /// for your convenience.\n+    fn call_function(\n+        &mut self,\n+        f: ty::Instance<'tcx>,\n+        caller_abi: Abi,\n+        args: &[Immediate<Provenance>],\n+        dest: Option<&PlaceTy<'tcx, Provenance>>,\n+        stack_pop: StackPopCleanup,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let param_env = ty::ParamEnv::reveal_all(); // in Miri this is always the param_env we use... and this.param_env is private.\n+        let callee_abi = f.ty(*this.tcx, param_env).fn_sig(*this.tcx).abi();\n+        if this.machine.enforce_abi && callee_abi != caller_abi {\n+            throw_ub_format!(\n+                \"calling a function with ABI {} using caller ABI {}\",\n+                callee_abi.name(),\n+                caller_abi.name()\n+            )\n+        }\n+\n+        // Push frame.\n+        let mir = this.load_mir(f.def, None)?;\n+        let dest = match dest {\n+            Some(dest) => dest.clone(),\n+            None => MPlaceTy::fake_alloc_zst(this.layout_of(mir.return_ty())?).into(),\n+        };\n+        this.push_stack_frame(f, mir, &dest, stack_pop)?;\n+\n+        // Initialize arguments.\n+        let mut callee_args = this.frame().body.args_iter();\n+        for arg in args {\n+            let callee_arg = this.local_place(\n+                callee_args\n+                    .next()\n+                    .ok_or_else(|| err_ub_format!(\"callee has fewer arguments than expected\"))?,\n+            )?;\n+            this.write_immediate(*arg, &callee_arg)?;\n+        }\n+        if callee_args.next().is_some() {\n+            throw_ub_format!(\"callee has more arguments than expected\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Visits the memory covered by `place`, sensitive to freezing: the 2nd parameter\n+    /// of `action` will be true if this is frozen, false if this is in an `UnsafeCell`.\n+    /// The range is relative to `place`.\n+    fn visit_freeze_sensitive(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        size: Size,\n+        mut action: impl FnMut(AllocRange, bool) -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        trace!(\"visit_frozen(place={:?}, size={:?})\", *place, size);\n+        debug_assert_eq!(\n+            size,\n+            this.size_and_align_of_mplace(place)?\n+                .map(|(size, _)| size)\n+                .unwrap_or_else(|| place.layout.size)\n+        );\n+        // Store how far we proceeded into the place so far. Everything to the left of\n+        // this offset has already been handled, in the sense that the frozen parts\n+        // have had `action` called on them.\n+        let start_addr = place.ptr.addr();\n+        let mut cur_addr = start_addr;\n+        // Called when we detected an `UnsafeCell` at the given offset and size.\n+        // Calls `action` and advances `cur_ptr`.\n+        let mut unsafe_cell_action = |unsafe_cell_ptr: &Pointer<Option<Provenance>>,\n+                                      unsafe_cell_size: Size| {\n+            // We assume that we are given the fields in increasing offset order,\n+            // and nothing else changes.\n+            let unsafe_cell_addr = unsafe_cell_ptr.addr();\n+            assert!(unsafe_cell_addr >= cur_addr);\n+            let frozen_size = unsafe_cell_addr - cur_addr;\n+            // Everything between the cur_ptr and this `UnsafeCell` is frozen.\n+            if frozen_size != Size::ZERO {\n+                action(alloc_range(cur_addr - start_addr, frozen_size), /*frozen*/ true)?;\n+            }\n+            cur_addr += frozen_size;\n+            // This `UnsafeCell` is NOT frozen.\n+            if unsafe_cell_size != Size::ZERO {\n+                action(\n+                    alloc_range(cur_addr - start_addr, unsafe_cell_size),\n+                    /*frozen*/ false,\n+                )?;\n+            }\n+            cur_addr += unsafe_cell_size;\n+            // Done\n+            Ok(())\n+        };\n+        // Run a visitor\n+        {\n+            let mut visitor = UnsafeCellVisitor {\n+                ecx: this,\n+                unsafe_cell_action: |place| {\n+                    trace!(\"unsafe_cell_action on {:?}\", place.ptr);\n+                    // We need a size to go on.\n+                    let unsafe_cell_size = this\n+                        .size_and_align_of_mplace(place)?\n+                        .map(|(size, _)| size)\n+                        // for extern types, just cover what we can\n+                        .unwrap_or_else(|| place.layout.size);\n+                    // Now handle this `UnsafeCell`, unless it is empty.\n+                    if unsafe_cell_size != Size::ZERO {\n+                        unsafe_cell_action(&place.ptr, unsafe_cell_size)\n+                    } else {\n+                        Ok(())\n+                    }\n+                },\n+            };\n+            visitor.visit_value(place)?;\n+        }\n+        // The part between the end_ptr and the end of the place is also frozen.\n+        // So pretend there is a 0-sized `UnsafeCell` at the end.\n+        unsafe_cell_action(&place.ptr.offset(size, this)?, Size::ZERO)?;\n+        // Done!\n+        return Ok(());\n+\n+        /// Visiting the memory covered by a `MemPlace`, being aware of\n+        /// whether we are inside an `UnsafeCell` or not.\n+        struct UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n+        where\n+            F: FnMut(&MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx>,\n+        {\n+            ecx: &'ecx MiriInterpCx<'mir, 'tcx>,\n+            unsafe_cell_action: F,\n+        }\n+\n+        impl<'ecx, 'mir, 'tcx: 'mir, F> ValueVisitor<'mir, 'tcx, MiriMachine<'mir, 'tcx>>\n+            for UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n+        where\n+            F: FnMut(&MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx>,\n+        {\n+            type V = MPlaceTy<'tcx, Provenance>;\n+\n+            #[inline(always)]\n+            fn ecx(&self) -> &MiriInterpCx<'mir, 'tcx> {\n+                self.ecx\n+            }\n+\n+            // Hook to detect `UnsafeCell`.\n+            fn visit_value(&mut self, v: &MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+                trace!(\"UnsafeCellVisitor: {:?} {:?}\", *v, v.layout.ty);\n+                let is_unsafe_cell = match v.layout.ty.kind() {\n+                    ty::Adt(adt, _) =>\n+                        Some(adt.did()) == self.ecx.tcx.lang_items().unsafe_cell_type(),\n+                    _ => false,\n+                };\n+                if is_unsafe_cell {\n+                    // We do not have to recurse further, this is an `UnsafeCell`.\n+                    (self.unsafe_cell_action)(v)\n+                } else if self.ecx.type_is_freeze(v.layout.ty) {\n+                    // This is `Freeze`, there cannot be an `UnsafeCell`\n+                    Ok(())\n+                } else if matches!(v.layout.fields, FieldsShape::Union(..)) {\n+                    // A (non-frozen) union. We fall back to whatever the type says.\n+                    (self.unsafe_cell_action)(v)\n+                } else {\n+                    // We want to not actually read from memory for this visit. So, before\n+                    // walking this value, we have to make sure it is not a\n+                    // `Variants::Multiple`.\n+                    match v.layout.variants {\n+                        Variants::Multiple { .. } => {\n+                            // A multi-variant enum, or generator, or so.\n+                            // Treat this like a union: without reading from memory,\n+                            // we cannot determine the variant we are in. Reading from\n+                            // memory would be subject to Stacked Borrows rules, leading\n+                            // to all sorts of \"funny\" recursion.\n+                            // We only end up here if the type is *not* freeze, so we just call the\n+                            // `UnsafeCell` action.\n+                            (self.unsafe_cell_action)(v)\n+                        }\n+                        Variants::Single { .. } => {\n+                            // Proceed further, try to find where exactly that `UnsafeCell`\n+                            // is hiding.\n+                            self.walk_value(v)\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Make sure we visit aggregrates in increasing offset order.\n+            fn visit_aggregate(\n+                &mut self,\n+                place: &MPlaceTy<'tcx, Provenance>,\n+                fields: impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Provenance>>>,\n+            ) -> InterpResult<'tcx> {\n+                match place.layout.fields {\n+                    FieldsShape::Array { .. } => {\n+                        // For the array layout, we know the iterator will yield sorted elements so\n+                        // we can avoid the allocation.\n+                        self.walk_aggregate(place, fields)\n+                    }\n+                    FieldsShape::Arbitrary { .. } => {\n+                        // Gather the subplaces and sort them before visiting.\n+                        let mut places = fields\n+                            .collect::<InterpResult<'tcx, Vec<MPlaceTy<'tcx, Provenance>>>>()?;\n+                        // we just compare offsets, the abs. value never matters\n+                        places.sort_by_key(|place| place.ptr.addr());\n+                        self.walk_aggregate(place, places.into_iter().map(Ok))\n+                    }\n+                    FieldsShape::Union { .. } | FieldsShape::Primitive => {\n+                        // Uh, what?\n+                        bug!(\"unions/primitives are not aggregates we should ever visit\")\n+                    }\n+                }\n+            }\n+\n+            fn visit_union(\n+                &mut self,\n+                _v: &MPlaceTy<'tcx, Provenance>,\n+                _fields: NonZeroUsize,\n+            ) -> InterpResult<'tcx> {\n+                bug!(\"we should have already handled unions in `visit_value`\")\n+            }\n+        }\n+    }\n+\n+    /// Helper function used inside the shims of foreign functions to check that isolation is\n+    /// disabled. It returns an error using the `name` of the foreign function if this is not the\n+    /// case.\n+    fn check_no_isolation(&self, name: &str) -> InterpResult<'tcx> {\n+        if !self.eval_context_ref().machine.communicate() {\n+            self.reject_in_isolation(name, RejectOpWith::Abort)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Helper function used inside the shims of foreign functions which reject the op\n+    /// when isolation is enabled. It is used to print a warning/backtrace about the rejection.\n+    fn reject_in_isolation(&self, op_name: &str, reject_with: RejectOpWith) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        match reject_with {\n+            RejectOpWith::Abort => isolation_abort_error(op_name),\n+            RejectOpWith::WarningWithoutBacktrace => {\n+                this.tcx\n+                    .sess\n+                    .warn(&format!(\"{} was made to return an error due to isolation\", op_name));\n+                Ok(())\n+            }\n+            RejectOpWith::Warning => {\n+                this.emit_diagnostic(NonHaltingDiagnostic::RejectedIsolatedOp(op_name.to_string()));\n+                Ok(())\n+            }\n+            RejectOpWith::NoWarning => Ok(()), // no warning\n+        }\n+    }\n+\n+    /// Helper function used inside the shims of foreign functions to assert that the target OS\n+    /// is `target_os`. It panics showing a message with the `name` of the foreign function\n+    /// if this is not the case.\n+    fn assert_target_os(&self, target_os: &str, name: &str) {\n+        assert_eq!(\n+            self.eval_context_ref().tcx.sess.target.os,\n+            target_os,\n+            \"`{}` is only available on the `{}` target OS\",\n+            name,\n+            target_os,\n+        )\n+    }\n+\n+    /// Helper function used inside the shims of foreign functions to assert that the target OS\n+    /// is part of the UNIX family. It panics showing a message with the `name` of the foreign function\n+    /// if this is not the case.\n+    fn assert_target_os_is_unix(&self, name: &str) {\n+        assert!(\n+            target_os_is_unix(self.eval_context_ref().tcx.sess.target.os.as_ref()),\n+            \"`{}` is only available for supported UNIX family targets\",\n+            name,\n+        );\n+    }\n+\n+    /// Get last error variable as a place, lazily allocating thread-local storage for it if\n+    /// necessary.\n+    fn last_error_place(&mut self) -> InterpResult<'tcx, MPlaceTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        if let Some(errno_place) = this.active_thread_ref().last_error {\n+            Ok(errno_place)\n+        } else {\n+            // Allocate new place, set initial value to 0.\n+            let errno_layout = this.machine.layouts.u32;\n+            let errno_place = this.allocate(errno_layout, MiriMemoryKind::Machine.into())?;\n+            this.write_scalar(Scalar::from_u32(0), &errno_place.into())?;\n+            this.active_thread_mut().last_error = Some(errno_place);\n+            Ok(errno_place)\n+        }\n+    }\n+\n+    /// Sets the last error variable.\n+    fn set_last_error(&mut self, scalar: Scalar<Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let errno_place = this.last_error_place()?;\n+        this.write_scalar(scalar, &errno_place.into())\n+    }\n+\n+    /// Gets the last error variable.\n+    fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+        let errno_place = this.last_error_place()?;\n+        this.read_scalar(&errno_place.into())\n+    }\n+\n+    /// This function tries to produce the most similar OS error from the `std::io::ErrorKind`\n+    /// as a platform-specific errnum.\n+    fn io_error_to_errnum(\n+        &self,\n+        err_kind: std::io::ErrorKind,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_ref();\n+        let target = &this.tcx.sess.target;\n+        if target.families.iter().any(|f| f == \"unix\") {\n+            for &(name, kind) in UNIX_IO_ERROR_TABLE {\n+                if err_kind == kind {\n+                    return this.eval_libc(name);\n+                }\n+            }\n+            throw_unsup_format!(\"io error {:?} cannot be translated into a raw os error\", err_kind)\n+        } else if target.families.iter().any(|f| f == \"windows\") {\n+            // FIXME: we have to finish implementing the Windows equivalent of this.\n+            use std::io::ErrorKind::*;\n+            this.eval_windows(\n+                \"c\",\n+                match err_kind {\n+                    NotFound => \"ERROR_FILE_NOT_FOUND\",\n+                    PermissionDenied => \"ERROR_ACCESS_DENIED\",\n+                    _ =>\n+                        throw_unsup_format!(\n+                            \"io error {:?} cannot be translated into a raw os error\",\n+                            err_kind\n+                        ),\n+                },\n+            )\n+        } else {\n+            throw_unsup_format!(\n+                \"converting io::Error into errnum is unsupported for OS {}\",\n+                target.os\n+            )\n+        }\n+    }\n+\n+    /// The inverse of `io_error_to_errnum`.\n+    #[allow(clippy::needless_return)]\n+    fn try_errnum_to_io_error(\n+        &self,\n+        errnum: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx, Option<std::io::ErrorKind>> {\n+        let this = self.eval_context_ref();\n+        let target = &this.tcx.sess.target;\n+        if target.families.iter().any(|f| f == \"unix\") {\n+            let errnum = errnum.to_i32()?;\n+            for &(name, kind) in UNIX_IO_ERROR_TABLE {\n+                if errnum == this.eval_libc_i32(name)? {\n+                    return Ok(Some(kind));\n+                }\n+            }\n+            // Our table is as complete as the mapping in std, so we are okay with saying \"that's a\n+            // strange one\" here.\n+            return Ok(None);\n+        } else {\n+            throw_unsup_format!(\n+                \"converting errnum into io::Error is unsupported for OS {}\",\n+                target.os\n+            )\n+        }\n+    }\n+\n+    /// Sets the last OS error using a `std::io::ErrorKind`.\n+    fn set_last_error_from_io_error(&mut self, err_kind: std::io::ErrorKind) -> InterpResult<'tcx> {\n+        self.set_last_error(self.io_error_to_errnum(err_kind)?)\n+    }\n+\n+    /// Helper function that consumes an `std::io::Result<T>` and returns an\n+    /// `InterpResult<'tcx,T>::Ok` instead. In case the result is an error, this function returns\n+    /// `Ok(-1)` and sets the last OS error accordingly.\n+    ///\n+    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n+    /// functions return different integer types (like `read`, that returns an `i64`).\n+    fn try_unwrap_io_result<T: From<i32>>(\n+        &mut self,\n+        result: std::io::Result<T>,\n+    ) -> InterpResult<'tcx, T> {\n+        match result {\n+            Ok(ok) => Ok(ok),\n+            Err(e) => {\n+                self.eval_context_mut().set_last_error_from_io_error(e.kind())?;\n+                Ok((-1).into())\n+            }\n+        }\n+    }\n+\n+    /// Calculates the MPlaceTy given the offset and layout of an access on an operand\n+    fn deref_operand_and_offset(\n+        &self,\n+        op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Provenance>> {\n+        let this = self.eval_context_ref();\n+        let op_place = this.deref_operand(op)?;\n+        let offset = Size::from_bytes(offset);\n+\n+        // Ensure that the access is within bounds.\n+        assert!(op_place.layout.size >= offset + layout.size);\n+        let value_place = op_place.offset(offset, layout, this)?;\n+        Ok(value_place)\n+    }\n+\n+    fn read_scalar_at_offset(\n+        &self,\n+        op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_ref();\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n+        this.read_scalar(&value_place.into())\n+    }\n+\n+    fn write_immediate_at_offset(\n+        &mut self,\n+        op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+        value: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ()> {\n+        let this = self.eval_context_mut();\n+        let value_place = this.deref_operand_and_offset(op, offset, value.layout)?;\n+        this.write_immediate(**value, &value_place.into())\n+    }\n+\n+    fn write_scalar_at_offset(\n+        &mut self,\n+        op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+        value: impl Into<Scalar<Provenance>>,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ()> {\n+        self.write_immediate_at_offset(op, offset, &ImmTy::from_scalar(value.into(), layout))\n+    }\n+\n+    /// Parse a `timespec` struct and return it as a `std::time::Duration`. It returns `None`\n+    /// if the value in the `timespec` struct is invalid. Some libc functions will return\n+    /// `EINVAL` in this case.\n+    fn read_timespec(\n+        &mut self,\n+        tp: &MPlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Option<Duration>> {\n+        let this = self.eval_context_mut();\n+        let seconds_place = this.mplace_field(tp, 0)?;\n+        let seconds_scalar = this.read_scalar(&seconds_place.into())?;\n+        let seconds = seconds_scalar.to_machine_isize(this)?;\n+        let nanoseconds_place = this.mplace_field(tp, 1)?;\n+        let nanoseconds_scalar = this.read_scalar(&nanoseconds_place.into())?;\n+        let nanoseconds = nanoseconds_scalar.to_machine_isize(this)?;\n+\n+        Ok(try {\n+            // tv_sec must be non-negative.\n+            let seconds: u64 = seconds.try_into().ok()?;\n+            // tv_nsec must be non-negative.\n+            let nanoseconds: u32 = nanoseconds.try_into().ok()?;\n+            if nanoseconds >= 1_000_000_000 {\n+                // tv_nsec must not be greater than 999,999,999.\n+                None?\n+            }\n+            Duration::new(seconds, nanoseconds)\n+        })\n+    }\n+\n+    fn read_c_str<'a>(&'a self, ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, &'a [u8]>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        let this = self.eval_context_ref();\n+        let size1 = Size::from_bytes(1);\n+\n+        // Step 1: determine the length.\n+        let mut len = Size::ZERO;\n+        loop {\n+            // FIXME: We are re-getting the allocation each time around the loop.\n+            // Would be nice if we could somehow \"extend\" an existing AllocRange.\n+            let alloc = this.get_ptr_alloc(ptr.offset(len, this)?, size1, Align::ONE)?.unwrap(); // not a ZST, so we will get a result\n+            let byte = alloc.read_integer(alloc_range(Size::ZERO, size1))?.to_u8()?;\n+            if byte == 0 {\n+                break;\n+            } else {\n+                len += size1;\n+            }\n+        }\n+\n+        // Step 2: get the bytes.\n+        this.read_bytes_ptr_strip_provenance(ptr, len)\n+    }\n+\n+    fn read_wide_str(&self, mut ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, Vec<u16>> {\n+        let this = self.eval_context_ref();\n+        let size2 = Size::from_bytes(2);\n+        let align2 = Align::from_bytes(2).unwrap();\n+\n+        let mut wchars = Vec::new();\n+        loop {\n+            // FIXME: We are re-getting the allocation each time around the loop.\n+            // Would be nice if we could somehow \"extend\" an existing AllocRange.\n+            let alloc = this.get_ptr_alloc(ptr, size2, align2)?.unwrap(); // not a ZST, so we will get a result\n+            let wchar = alloc.read_integer(alloc_range(Size::ZERO, size2))?.to_u16()?;\n+            if wchar == 0 {\n+                break;\n+            } else {\n+                wchars.push(wchar);\n+                ptr = ptr.offset(size2, this)?;\n+            }\n+        }\n+\n+        Ok(wchars)\n+    }\n+\n+    /// Check that the ABI is what we expect.\n+    fn check_abi<'a>(&self, abi: Abi, exp_abi: Abi) -> InterpResult<'a, ()> {\n+        if self.eval_context_ref().machine.enforce_abi && abi != exp_abi {\n+            throw_ub_format!(\n+                \"calling a function with ABI {} using caller ABI {}\",\n+                exp_abi.name(),\n+                abi.name()\n+            )\n+        }\n+        Ok(())\n+    }\n+\n+    fn frame_in_std(&self) -> bool {\n+        let this = self.eval_context_ref();\n+        let Some(start_fn) = this.tcx.lang_items().start_fn() else {\n+            // no_std situations\n+            return false;\n+        };\n+        let frame = this.frame();\n+        // Make an attempt to get at the instance of the function this is inlined from.\n+        let instance: Option<_> = try {\n+            let scope = frame.current_source_info()?.scope;\n+            let inlined_parent = frame.body.source_scopes[scope].inlined_parent_scope?;\n+            let source = &frame.body.source_scopes[inlined_parent];\n+            source.inlined.expect(\"inlined_parent_scope points to scope without inline info\").0\n+        };\n+        // Fall back to the instance of the function itself.\n+        let instance = instance.unwrap_or(frame.instance);\n+        // Now check if this is in the same crate as start_fn.\n+        // As a special exception we also allow unit tests from\n+        // <https://github.com/rust-lang/miri-test-libstd/tree/master/std_miri_test> to call these\n+        // shims.\n+        let frame_crate = this.tcx.def_path(instance.def_id()).krate;\n+        frame_crate == this.tcx.def_path(start_fn).krate\n+            || this.tcx.crate_name(frame_crate).as_str() == \"std_miri_test\"\n+    }\n+\n+    /// Handler that should be called when unsupported functionality is encountered.\n+    /// This function will either panic within the context of the emulated application\n+    /// or return an error in the Miri process context\n+    ///\n+    /// Return value of `Ok(bool)` indicates whether execution should continue.\n+    fn handle_unsupported<S: AsRef<str>>(&mut self, error_msg: S) -> InterpResult<'tcx, ()> {\n+        let this = self.eval_context_mut();\n+        if this.machine.panic_on_unsupported {\n+            // message is slightly different here to make automated analysis easier\n+            let error_msg = format!(\"unsupported Miri functionality: {}\", error_msg.as_ref());\n+            this.start_panic(error_msg.as_ref(), StackPopUnwind::Skip)?;\n+            Ok(())\n+        } else {\n+            throw_unsup_format!(\"{}\", error_msg.as_ref());\n+        }\n+    }\n+\n+    fn check_abi_and_shim_symbol_clash(\n+        &mut self,\n+        abi: Abi,\n+        exp_abi: Abi,\n+        link_name: Symbol,\n+    ) -> InterpResult<'tcx, ()> {\n+        self.check_abi(abi, exp_abi)?;\n+        if let Some((body, _)) = self.eval_context_mut().lookup_exported_symbol(link_name)? {\n+            throw_machine_stop!(TerminationInfo::SymbolShimClashing {\n+                link_name,\n+                span: body.span.data(),\n+            })\n+        }\n+        Ok(())\n+    }\n+\n+    fn check_shim<'a, const N: usize>(\n+        &mut self,\n+        abi: Abi,\n+        exp_abi: Abi,\n+        link_name: Symbol,\n+        args: &'a [OpTy<'tcx, Provenance>],\n+    ) -> InterpResult<'tcx, &'a [OpTy<'tcx, Provenance>; N]>\n+    where\n+        &'a [OpTy<'tcx, Provenance>; N]: TryFrom<&'a [OpTy<'tcx, Provenance>]>,\n+    {\n+        self.check_abi_and_shim_symbol_clash(abi, exp_abi, link_name)?;\n+        check_arg_count(args)\n+    }\n+\n+    /// Mark a machine allocation that was just created as immutable.\n+    fn mark_immutable(&mut self, mplace: &MemPlace<Provenance>) {\n+        let this = self.eval_context_mut();\n+        // This got just allocated, so there definitely is a pointer here.\n+        let provenance = mplace.ptr.into_pointer_or_addr().unwrap().provenance;\n+        this.alloc_mark_immutable(provenance.get_alloc_id().unwrap()).unwrap();\n+    }\n+\n+    fn item_link_name(&self, def_id: DefId) -> Symbol {\n+        let tcx = self.eval_context_ref().tcx;\n+        match tcx.get_attrs(def_id, sym::link_name).filter_map(|a| a.value_str()).next() {\n+            Some(name) => name,\n+            None => tcx.item_name(def_id),\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n+    pub fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n+        CurrentSpan { current_frame_idx: None, machine: self }\n+    }\n+}\n+\n+/// A `CurrentSpan` should be created infrequently (ideally once) per interpreter step. It does\n+/// nothing on creation, but when `CurrentSpan::get` is called, searches the current stack for the\n+/// topmost frame which corresponds to a local crate, and returns the current span in that frame.\n+/// The result of that search is cached so that later calls are approximately free.\n+#[derive(Clone)]\n+pub struct CurrentSpan<'a, 'mir, 'tcx> {\n+    current_frame_idx: Option<usize>,\n+    machine: &'a MiriMachine<'mir, 'tcx>,\n+}\n+\n+impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n+    pub fn machine(&self) -> &'a MiriMachine<'mir, 'tcx> {\n+        self.machine\n+    }\n+\n+    /// Get the current span, skipping non-local frames.\n+    /// This function is backed by a cache, and can be assumed to be very fast.\n+    pub fn get(&mut self) -> Span {\n+        let idx = self.current_frame_idx();\n+        Self::frame_span(self.machine, idx)\n+    }\n+\n+    /// Similar to `CurrentSpan::get`, but retrieves the parent frame of the first non-local frame.\n+    /// This is useful when we are processing something which occurs on function-entry and we want\n+    /// to point at the call to the function, not the function definition generally.\n+    pub fn get_parent(&mut self) -> Span {\n+        let idx = self.current_frame_idx();\n+        Self::frame_span(self.machine, idx.wrapping_sub(1))\n+    }\n+\n+    fn frame_span(machine: &MiriMachine<'_, '_>, idx: usize) -> Span {\n+        machine\n+            .threads\n+            .active_thread_stack()\n+            .get(idx)\n+            .map(Frame::current_span)\n+            .unwrap_or(rustc_span::DUMMY_SP)\n+    }\n+\n+    fn current_frame_idx(&mut self) -> usize {\n+        *self\n+            .current_frame_idx\n+            .get_or_insert_with(|| Self::compute_current_frame_index(self.machine))\n+    }\n+\n+    // Find the position of the inner-most frame which is part of the crate being\n+    // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n+    #[inline(never)]\n+    fn compute_current_frame_index(machine: &MiriMachine<'_, '_>) -> usize {\n+        machine\n+            .threads\n+            .active_thread_stack()\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(idx, frame)| {\n+                let def_id = frame.instance.def_id();\n+                if (def_id.is_local() || machine.local_crates.contains(&def_id.krate))\n+                    && !frame.instance.def.requires_caller_location(machine.tcx)\n+                {\n+                    Some(idx)\n+                } else {\n+                    None\n+                }\n+            })\n+            .unwrap_or(0)\n+    }\n+}\n+\n+/// Check that the number of args is what we expect.\n+pub fn check_arg_count<'a, 'tcx, const N: usize>(\n+    args: &'a [OpTy<'tcx, Provenance>],\n+) -> InterpResult<'tcx, &'a [OpTy<'tcx, Provenance>; N]>\n+where\n+    &'a [OpTy<'tcx, Provenance>; N]: TryFrom<&'a [OpTy<'tcx, Provenance>]>,\n+{\n+    if let Ok(ops) = args.try_into() {\n+        return Ok(ops);\n+    }\n+    throw_ub_format!(\"incorrect number of arguments: got {}, expected {}\", args.len(), N)\n+}\n+\n+pub fn isolation_abort_error<'tcx>(name: &str) -> InterpResult<'tcx> {\n+    throw_machine_stop!(TerminationInfo::UnsupportedInIsolation(format!(\n+        \"{} not available when isolation is enabled\",\n+        name,\n+    )))\n+}\n+\n+/// Retrieve the list of local crates that should have been passed by cargo-miri in\n+/// MIRI_LOCAL_CRATES and turn them into `CrateNum`s.\n+pub fn get_local_crates(tcx: TyCtxt<'_>) -> Vec<CrateNum> {\n+    // Convert the local crate names from the passed-in config into CrateNums so that they can\n+    // be looked up quickly during execution\n+    let local_crate_names = std::env::var(\"MIRI_LOCAL_CRATES\")\n+        .map(|crates| crates.split(',').map(|krate| krate.to_string()).collect::<Vec<_>>())\n+        .unwrap_or_default();\n+    let mut local_crates = Vec::new();\n+    for &crate_num in tcx.crates(()) {\n+        let name = tcx.crate_name(crate_num);\n+        let name = name.as_str();\n+        if local_crate_names.iter().any(|local_name| local_name == name) {\n+            local_crates.push(crate_num);\n+        }\n+    }\n+    local_crates\n+}\n+\n+/// Helper function used inside the shims of foreign functions to check that\n+/// `target_os` is a supported UNIX OS.\n+pub fn target_os_is_unix(target_os: &str) -> bool {\n+    matches!(target_os, \"linux\" | \"macos\" | \"freebsd\" | \"android\")\n+}"}, {"sha": "4506fe47495d045c2842c86ded56927e7adba233", "filename": "src/tools/miri/src/helpers/convert.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers%2Fconvert.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,49 @@\n+use implementations::NarrowerThan;\n+\n+/// Replacement for `as` casts going from wide integer to narrower integer.\n+///\n+/// # Example\n+///\n+/// ```ignore\n+/// let x = 99_u64;\n+/// let lo = x.truncate::<u16>();\n+/// // lo is of type u16, equivalent to `x as u16`.\n+/// ```\n+pub(crate) trait Truncate: Sized {\n+    fn truncate<To>(self) -> To\n+    where\n+        To: NarrowerThan<Self>,\n+    {\n+        NarrowerThan::truncate_from(self)\n+    }\n+}\n+\n+impl Truncate for u16 {}\n+impl Truncate for u32 {}\n+impl Truncate for u64 {}\n+impl Truncate for u128 {}\n+\n+mod implementations {\n+    pub(crate) trait NarrowerThan<T> {\n+        fn truncate_from(wide: T) -> Self;\n+    }\n+\n+    macro_rules! impl_narrower_than {\n+        ($(NarrowerThan<{$($ty:ty),*}> for $self:ty)*) => {\n+            $($(\n+                impl NarrowerThan<$ty> for $self {\n+                    fn truncate_from(wide: $ty) -> Self {\n+                        wide as Self\n+                    }\n+                }\n+            )*)*\n+        };\n+    }\n+\n+    impl_narrower_than! {\n+        NarrowerThan<{u128, u64, u32, u16}> for u8\n+        NarrowerThan<{u128, u64, u32}> for u16\n+        NarrowerThan<{u128, u64}> for u32\n+        NarrowerThan<{u128}> for u64\n+    }\n+}"}, {"sha": "b9e5def8fa7cb9c00a345ce5bdc83aef14852cb8", "filename": "src/tools/miri/src/intptrcast.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,260 @@\n+use std::cell::RefCell;\n+use std::cmp::max;\n+use std::collections::hash_map::Entry;\n+\n+use log::trace;\n+use rand::Rng;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_span::Span;\n+use rustc_target::abi::{HasDataLayout, Size};\n+\n+use crate::*;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ProvenanceMode {\n+    /// We support `expose_addr`/`from_exposed_addr` via \"wildcard\" provenance.\n+    /// However, we want on `from_exposed_addr` to alert the user of the precision loss.\n+    Default,\n+    /// Like `Default`, but without the warning.\n+    Permissive,\n+    /// We error on `from_exposed_addr`, ensuring no precision loss.\n+    Strict,\n+}\n+\n+pub type GlobalState = RefCell<GlobalStateInner>;\n+\n+#[derive(Clone, Debug)]\n+pub struct GlobalStateInner {\n+    /// This is used as a map between the address of each allocation and its `AllocId`.\n+    /// It is always sorted\n+    int_to_ptr_map: Vec<(u64, AllocId)>,\n+    /// The base address for each allocation.  We cannot put that into\n+    /// `AllocExtra` because function pointers also have a base address, and\n+    /// they do not have an `AllocExtra`.\n+    /// This is the inverse of `int_to_ptr_map`.\n+    base_addr: FxHashMap<AllocId, u64>,\n+    /// Whether an allocation has been exposed or not. This cannot be put\n+    /// into `AllocExtra` for the same reason as `base_addr`.\n+    exposed: FxHashSet<AllocId>,\n+    /// This is used as a memory address when a new pointer is casted to an integer. It\n+    /// is always larger than any address that was previously made part of a block.\n+    next_base_addr: u64,\n+    /// The provenance to use for int2ptr casts\n+    provenance_mode: ProvenanceMode,\n+}\n+\n+impl GlobalStateInner {\n+    pub fn new(config: &MiriConfig) -> Self {\n+        GlobalStateInner {\n+            int_to_ptr_map: Vec::default(),\n+            base_addr: FxHashMap::default(),\n+            exposed: FxHashSet::default(),\n+            next_base_addr: STACK_ADDR,\n+            provenance_mode: config.provenance_mode,\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> GlobalStateInner {\n+    // Returns the exposed `AllocId` that corresponds to the specified addr,\n+    // or `None` if the addr is out of bounds\n+    fn alloc_id_from_addr(ecx: &MiriInterpCx<'mir, 'tcx>, addr: u64) -> Option<AllocId> {\n+        let global_state = ecx.machine.intptrcast.borrow();\n+        assert!(global_state.provenance_mode != ProvenanceMode::Strict);\n+\n+        let pos = global_state.int_to_ptr_map.binary_search_by_key(&addr, |(addr, _)| *addr);\n+\n+        // Determine the in-bounds provenance for this pointer.\n+        // (This is only called on an actual access, so in-bounds is the only possible kind of provenance.)\n+        let alloc_id = match pos {\n+            Ok(pos) => Some(global_state.int_to_ptr_map[pos].1),\n+            Err(0) => None,\n+            Err(pos) => {\n+                // This is the largest of the adresses smaller than `int`,\n+                // i.e. the greatest lower bound (glb)\n+                let (glb, alloc_id) = global_state.int_to_ptr_map[pos - 1];\n+                // This never overflows because `addr >= glb`\n+                let offset = addr - glb;\n+                // If the offset exceeds the size of the allocation, don't use this `alloc_id`.\n+                let size = ecx.get_alloc_info(alloc_id).0;\n+                if offset <= size.bytes() { Some(alloc_id) } else { None }\n+            }\n+        }?;\n+\n+        // We only use this provenance if it has been exposed, *and* is still live.\n+        if global_state.exposed.contains(&alloc_id) {\n+            let (_size, _align, kind) = ecx.get_alloc_info(alloc_id);\n+            match kind {\n+                AllocKind::LiveData | AllocKind::Function | AllocKind::VTable => {\n+                    return Some(alloc_id);\n+                }\n+                AllocKind::Dead => {}\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    pub fn expose_ptr(\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+        alloc_id: AllocId,\n+        sb: SbTag,\n+    ) -> InterpResult<'tcx> {\n+        let global_state = ecx.machine.intptrcast.get_mut();\n+        // In strict mode, we don't need this, so we can save some cycles by not tracking it.\n+        if global_state.provenance_mode != ProvenanceMode::Strict {\n+            trace!(\"Exposing allocation id {alloc_id:?}\");\n+            global_state.exposed.insert(alloc_id);\n+            if ecx.machine.stacked_borrows.is_some() {\n+                ecx.expose_tag(alloc_id, sb)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn ptr_from_addr_transmute(\n+        _ecx: &MiriInterpCx<'mir, 'tcx>,\n+        addr: u64,\n+    ) -> Pointer<Option<Provenance>> {\n+        trace!(\"Transmuting {:#x} to a pointer\", addr);\n+\n+        // We consider transmuted pointers to be \"invalid\" (`None` provenance).\n+        Pointer::new(None, Size::from_bytes(addr))\n+    }\n+\n+    pub fn ptr_from_addr_cast(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        addr: u64,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        trace!(\"Casting {:#x} to a pointer\", addr);\n+\n+        let global_state = ecx.machine.intptrcast.borrow();\n+\n+        match global_state.provenance_mode {\n+            ProvenanceMode::Default => {\n+                // The first time this happens at a particular location, print a warning.\n+                thread_local! {\n+                    // `Span` is non-`Send`, so we use a thread-local instead.\n+                    static PAST_WARNINGS: RefCell<FxHashSet<Span>> = RefCell::default();\n+                }\n+                PAST_WARNINGS.with_borrow_mut(|past_warnings| {\n+                    let first = past_warnings.is_empty();\n+                    if past_warnings.insert(ecx.cur_span()) {\n+                        // Newly inserted, so first time we see this span.\n+                        ecx.emit_diagnostic(NonHaltingDiagnostic::Int2Ptr { details: first });\n+                    }\n+                });\n+            }\n+            ProvenanceMode::Strict => {\n+                throw_machine_stop!(TerminationInfo::Int2PtrWithStrictProvenance);\n+            }\n+            ProvenanceMode::Permissive => {}\n+        }\n+\n+        // This is how wildcard pointers are born.\n+        Ok(Pointer::new(Some(Provenance::Wildcard), Size::from_bytes(addr)))\n+    }\n+\n+    fn alloc_base_addr(ecx: &MiriInterpCx<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n+        let mut global_state = ecx.machine.intptrcast.borrow_mut();\n+        let global_state = &mut *global_state;\n+\n+        match global_state.base_addr.entry(alloc_id) {\n+            Entry::Occupied(entry) => *entry.get(),\n+            Entry::Vacant(entry) => {\n+                // There is nothing wrong with a raw pointer being cast to an integer only after\n+                // it became dangling.  Hence we allow dead allocations.\n+                let (size, align, _kind) = ecx.get_alloc_info(alloc_id);\n+\n+                // This allocation does not have a base address yet, pick one.\n+                // Leave some space to the previous allocation, to give it some chance to be less aligned.\n+                let slack = {\n+                    let mut rng = ecx.machine.rng.borrow_mut();\n+                    // This means that `(global_state.next_base_addr + slack) % 16` is uniformly distributed.\n+                    rng.gen_range(0..16)\n+                };\n+                // From next_base_addr + slack, round up to adjust for alignment.\n+                let base_addr = global_state.next_base_addr.checked_add(slack).unwrap();\n+                let base_addr = Self::align_addr(base_addr, align.bytes());\n+                entry.insert(base_addr);\n+                trace!(\n+                    \"Assigning base address {:#x} to allocation {:?} (size: {}, align: {}, slack: {})\",\n+                    base_addr,\n+                    alloc_id,\n+                    size.bytes(),\n+                    align.bytes(),\n+                    slack,\n+                );\n+\n+                // Remember next base address.  If this allocation is zero-sized, leave a gap\n+                // of at least 1 to avoid two allocations having the same base address.\n+                // (The logic in `alloc_id_from_addr` assumes unique addresses, and different\n+                // function/vtable pointers need to be distinguishable!)\n+                global_state.next_base_addr = base_addr.checked_add(max(size.bytes(), 1)).unwrap();\n+                // Given that `next_base_addr` increases in each allocation, pushing the\n+                // corresponding tuple keeps `int_to_ptr_map` sorted\n+                global_state.int_to_ptr_map.push((base_addr, alloc_id));\n+\n+                base_addr\n+            }\n+        }\n+    }\n+\n+    /// Convert a relative (tcx) pointer to an absolute address.\n+    pub fn rel_ptr_to_addr(ecx: &MiriInterpCx<'mir, 'tcx>, ptr: Pointer<AllocId>) -> u64 {\n+        let (alloc_id, offset) = ptr.into_parts(); // offset is relative (AllocId provenance)\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n+\n+        // Add offset with the right kind of pointer-overflowing arithmetic.\n+        let dl = ecx.data_layout();\n+        dl.overflowing_offset(base_addr, offset.bytes()).0\n+    }\n+\n+    /// When a pointer is used for a memory access, this computes where in which allocation the\n+    /// access is going.\n+    pub fn abs_ptr_to_rel(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        ptr: Pointer<Provenance>,\n+    ) -> Option<(AllocId, Size)> {\n+        let (tag, addr) = ptr.into_parts(); // addr is absolute (Tag provenance)\n+\n+        let alloc_id = if let Provenance::Concrete { alloc_id, .. } = tag {\n+            alloc_id\n+        } else {\n+            // A wildcard pointer.\n+            GlobalStateInner::alloc_id_from_addr(ecx, addr.bytes())?\n+        };\n+\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n+\n+        // Wrapping \"addr - base_addr\"\n+        let dl = ecx.data_layout();\n+        #[allow(clippy::cast_possible_wrap)] // we want to wrap here\n+        let neg_base_addr = (base_addr as i64).wrapping_neg();\n+        Some((\n+            alloc_id,\n+            Size::from_bytes(dl.overflowing_signed_offset(addr.bytes(), neg_base_addr).0),\n+        ))\n+    }\n+\n+    /// Shifts `addr` to make it aligned with `align` by rounding `addr` to the smallest multiple\n+    /// of `align` that is larger or equal to `addr`\n+    fn align_addr(addr: u64, align: u64) -> u64 {\n+        match addr % align {\n+            0 => addr,\n+            rem => addr.checked_add(align).unwrap() - rem,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_align_addr() {\n+        assert_eq!(GlobalStateInner::align_addr(37, 4), 40);\n+        assert_eq!(GlobalStateInner::align_addr(44, 4), 44);\n+    }\n+}"}, {"sha": "6006d6c89dbcab993e15237ea55890c7aa916349", "filename": "src/tools/miri/src/lib.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,126 @@\n+#![feature(rustc_private)]\n+#![feature(map_first_last)]\n+#![feature(map_try_insert)]\n+#![feature(never_type)]\n+#![feature(try_blocks)]\n+#![feature(io_error_more)]\n+#![feature(int_log)]\n+#![feature(variant_count)]\n+#![feature(yeet_expr)]\n+#![feature(is_some_with)]\n+#![feature(nonzero_ops)]\n+#![feature(local_key_cell_methods)]\n+// Configure clippy and other lints\n+#![allow(\n+    clippy::collapsible_else_if,\n+    clippy::collapsible_if,\n+    clippy::comparison_chain,\n+    clippy::enum_variant_names,\n+    clippy::field_reassign_with_default,\n+    clippy::manual_map,\n+    clippy::new_without_default,\n+    clippy::single_match,\n+    clippy::useless_format,\n+    clippy::derive_partial_eq_without_eq,\n+    clippy::derive_hash_xor_eq,\n+    clippy::too_many_arguments,\n+    clippy::type_complexity,\n+    clippy::single_element_loop,\n+    clippy::needless_return,\n+    // We are not implementing queries here so it's fine\n+    rustc::potential_query_instability\n+)]\n+#![warn(\n+    rust_2018_idioms,\n+    clippy::cast_possible_wrap, // unsigned -> signed\n+    clippy::cast_sign_loss, // signed -> unsigned\n+    clippy::cast_lossless,\n+    clippy::cast_possible_truncation,\n+)]\n+\n+extern crate rustc_apfloat;\n+extern crate rustc_ast;\n+#[macro_use]\n+extern crate rustc_middle;\n+extern crate rustc_const_eval;\n+extern crate rustc_data_structures;\n+extern crate rustc_hir;\n+extern crate rustc_index;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+extern crate rustc_target;\n+\n+mod clock;\n+mod concurrency;\n+mod diagnostics;\n+mod eval;\n+mod helpers;\n+mod intptrcast;\n+mod machine;\n+mod mono_hash_map;\n+mod operator;\n+mod range_map;\n+mod shims;\n+mod stacked_borrows;\n+mod tag_gc;\n+\n+// Establish a \"crate-wide prelude\": we often import `crate::*`.\n+\n+// Make all those symbols available in the same place as our own.\n+pub use rustc_const_eval::interpret::*;\n+// Resolve ambiguity.\n+pub use rustc_const_eval::interpret::{self, AllocMap, PlaceTy, Provenance as _};\n+\n+pub use crate::shims::dlsym::{Dlsym, EvalContextExt as _};\n+pub use crate::shims::env::{EnvVars, EvalContextExt as _};\n+pub use crate::shims::foreign_items::EvalContextExt as _;\n+pub use crate::shims::intrinsics::EvalContextExt as _;\n+pub use crate::shims::os_str::EvalContextExt as _;\n+pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as _};\n+pub use crate::shims::time::EvalContextExt as _;\n+pub use crate::shims::tls::{EvalContextExt as _, TlsData};\n+pub use crate::shims::EvalContextExt as _;\n+\n+pub use crate::clock::{Clock, Instant};\n+pub use crate::concurrency::{\n+    data_race::{\n+        AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n+        EvalContextExt as DataRaceEvalContextExt,\n+    },\n+    sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId},\n+    thread::{\n+        EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager,\n+        ThreadState, Time,\n+    },\n+};\n+pub use crate::diagnostics::{\n+    report_error, EvalContextExt as DiagnosticsEvalContextExt, NonHaltingDiagnostic,\n+    TerminationInfo,\n+};\n+pub use crate::eval::{\n+    create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n+};\n+pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n+pub use crate::intptrcast::ProvenanceMode;\n+pub use crate::machine::{\n+    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind, Provenance,\n+    ProvenanceExtra, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+};\n+pub use crate::mono_hash_map::MonoHashMap;\n+pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n+pub use crate::range_map::RangeMap;\n+pub use crate::stacked_borrows::{\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n+};\n+pub use crate::tag_gc::EvalContextExt as _;\n+\n+/// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n+/// set per default, for maximal validation power.\n+pub const MIRI_DEFAULT_ARGS: &[&str] = &[\n+    \"-Zalways-encode-mir\",\n+    \"-Zmir-emit-retag\",\n+    \"-Zmir-opt-level=0\",\n+    \"--cfg=miri\",\n+    \"-Cdebug-assertions=on\",\n+    \"-Zextra-const-ub-checks\",\n+];"}, {"sha": "dcfb998c5645dfd08893124e6f848300f47dd6e9", "filename": "src/tools/miri/src/machine.rs", "status": "added", "additions": 1077, "deletions": 0, "changes": 1077, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,1077 @@\n+//! Global machine state as well as implementation of the interpreter engine\n+//! `Machine` trait.\n+\n+use std::borrow::Cow;\n+use std::cell::RefCell;\n+use std::fmt;\n+\n+use rand::rngs::StdRng;\n+use rand::SeedableRng;\n+\n+use rustc_ast::ast::Mutability;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+#[allow(unused)]\n+use rustc_data_structures::static_assert_size;\n+use rustc_middle::{\n+    mir,\n+    ty::{\n+        self,\n+        layout::{LayoutCx, LayoutError, LayoutOf, TyAndLayout},\n+        Instance, Ty, TyCtxt, TypeAndMut,\n+    },\n+};\n+use rustc_span::def_id::{CrateNum, DefId};\n+use rustc_span::Symbol;\n+use rustc_target::abi::Size;\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::{\n+    concurrency::{data_race, weak_memory},\n+    shims::unix::FileHandler,\n+    *,\n+};\n+\n+// Some global facts about the emulated machine.\n+pub const PAGE_SIZE: u64 = 4 * 1024; // FIXME: adjust to target architecture\n+pub const STACK_ADDR: u64 = 32 * PAGE_SIZE; // not really about the \"stack\", but where we start assigning integer addresses to allocations\n+pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n+pub const NUM_CPUS: u64 = 1;\n+\n+/// Extra data stored with each stack frame\n+pub struct FrameData<'tcx> {\n+    /// Extra data for Stacked Borrows.\n+    pub stacked_borrows: Option<stacked_borrows::FrameExtra>,\n+\n+    /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n+    /// called by `try`). When this frame is popped during unwinding a panic,\n+    /// we stop unwinding, use the `CatchUnwindData` to handle catching.\n+    pub catch_unwind: Option<CatchUnwindData<'tcx>>,\n+\n+    /// If `measureme` profiling is enabled, holds timing information\n+    /// for the start of this frame. When we finish executing this frame,\n+    /// we use this to register a completed event with `measureme`.\n+    pub timing: Option<measureme::DetachedTiming>,\n+}\n+\n+impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        // Omitting `timing`, it does not support `Debug`.\n+        let FrameData { stacked_borrows, catch_unwind, timing: _ } = self;\n+        f.debug_struct(\"FrameData\")\n+            .field(\"stacked_borrows\", stacked_borrows)\n+            .field(\"catch_unwind\", catch_unwind)\n+            .finish()\n+    }\n+}\n+\n+/// Extra memory kinds\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum MiriMemoryKind {\n+    /// `__rust_alloc` memory.\n+    Rust,\n+    /// `malloc` memory.\n+    C,\n+    /// Windows `HeapAlloc` memory.\n+    WinHeap,\n+    /// Memory for args, errno, and other parts of the machine-managed environment.\n+    /// This memory may leak.\n+    Machine,\n+    /// Memory allocated by the runtime (e.g. env vars). Separate from `Machine`\n+    /// because we clean it up and leak-check it.\n+    Runtime,\n+    /// Globals copied from `tcx`.\n+    /// This memory may leak.\n+    Global,\n+    /// Memory for extern statics.\n+    /// This memory may leak.\n+    ExternStatic,\n+    /// Memory for thread-local statics.\n+    /// This memory may leak.\n+    Tls,\n+}\n+\n+impl From<MiriMemoryKind> for MemoryKind<MiriMemoryKind> {\n+    #[inline(always)]\n+    fn from(kind: MiriMemoryKind) -> MemoryKind<MiriMemoryKind> {\n+        MemoryKind::Machine(kind)\n+    }\n+}\n+\n+impl MayLeak for MiriMemoryKind {\n+    #[inline(always)]\n+    fn may_leak(self) -> bool {\n+        use self::MiriMemoryKind::*;\n+        match self {\n+            Rust | C | WinHeap | Runtime => false,\n+            Machine | Global | ExternStatic | Tls => true,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for MiriMemoryKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use self::MiriMemoryKind::*;\n+        match self {\n+            Rust => write!(f, \"Rust heap\"),\n+            C => write!(f, \"C heap\"),\n+            WinHeap => write!(f, \"Windows heap\"),\n+            Machine => write!(f, \"machine-managed memory\"),\n+            Runtime => write!(f, \"language runtime memory\"),\n+            Global => write!(f, \"global (static or const)\"),\n+            ExternStatic => write!(f, \"extern static\"),\n+            Tls => write!(f, \"thread-local static\"),\n+        }\n+    }\n+}\n+\n+/// Pointer provenance.\n+#[derive(Debug, Clone, Copy)]\n+pub enum Provenance {\n+    Concrete {\n+        alloc_id: AllocId,\n+        /// Stacked Borrows tag.\n+        sb: SbTag,\n+    },\n+    Wildcard,\n+}\n+\n+// This needs to be `Eq`+`Hash` because the `Machine` trait needs that because validity checking\n+// *might* be recursive and then it has to track which places have already been visited.\n+// However, comparing provenance is meaningless, since `Wildcard` might be any provenance -- and of\n+// course we don't actually do recursive checking.\n+// We could change `RefTracking` to strip provenance for its `seen` set but that type is generic so that is quite annoying.\n+// Instead owe add the required instances but make them panic.\n+impl PartialEq for Provenance {\n+    fn eq(&self, _other: &Self) -> bool {\n+        panic!(\"Provenance must not be compared\")\n+    }\n+}\n+impl Eq for Provenance {}\n+impl std::hash::Hash for Provenance {\n+    fn hash<H: std::hash::Hasher>(&self, _state: &mut H) {\n+        panic!(\"Provenance must not be hashed\")\n+    }\n+}\n+\n+/// The \"extra\" information a pointer has over a regular AllocId.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum ProvenanceExtra {\n+    Concrete(SbTag),\n+    Wildcard,\n+}\n+\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(Pointer<Provenance>, 24);\n+// FIXME: this would with in 24bytes but layout optimizations are not smart enough\n+// #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+//static_assert_size!(Pointer<Option<Provenance>>, 24);\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(Scalar<Provenance>, 32);\n+\n+impl interpret::Provenance for Provenance {\n+    /// We use absolute addresses in the `offset` of a `Pointer<Provenance>`.\n+    const OFFSET_IS_ADDR: bool = true;\n+\n+    /// We cannot err on partial overwrites, it happens too often in practice (due to unions).\n+    const ERR_ON_PARTIAL_PTR_OVERWRITE: bool = false;\n+\n+    fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let (prov, addr) = ptr.into_parts(); // address is absolute\n+        write!(f, \"{:#x}\", addr.bytes())?;\n+\n+        match prov {\n+            Provenance::Concrete { alloc_id, sb } => {\n+                // Forward `alternate` flag to `alloc_id` printing.\n+                if f.alternate() {\n+                    write!(f, \"[{:#?}]\", alloc_id)?;\n+                } else {\n+                    write!(f, \"[{:?}]\", alloc_id)?;\n+                }\n+                // Print Stacked Borrows tag.\n+                write!(f, \"{:?}\", sb)?;\n+            }\n+            Provenance::Wildcard => {\n+                write!(f, \"[wildcard]\")?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn get_alloc_id(self) -> Option<AllocId> {\n+        match self {\n+            Provenance::Concrete { alloc_id, .. } => Some(alloc_id),\n+            Provenance::Wildcard => None,\n+        }\n+    }\n+\n+    fn join(left: Option<Self>, right: Option<Self>) -> Option<Self> {\n+        match (left, right) {\n+            // If both are the *same* concrete tag, that is the result.\n+            (\n+                Some(Provenance::Concrete { alloc_id: left_alloc, sb: left_sb }),\n+                Some(Provenance::Concrete { alloc_id: right_alloc, sb: right_sb }),\n+            ) if left_alloc == right_alloc && left_sb == right_sb => left,\n+            // If one side is a wildcard, the best possible outcome is that it is equal to the other\n+            // one, and we use that.\n+            (Some(Provenance::Wildcard), o) | (o, Some(Provenance::Wildcard)) => o,\n+            // Otherwise, fall back to `None`.\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ProvenanceExtra {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ProvenanceExtra::Concrete(pid) => write!(f, \"{pid:?}\"),\n+            ProvenanceExtra::Wildcard => write!(f, \"<wildcard>\"),\n+        }\n+    }\n+}\n+\n+impl ProvenanceExtra {\n+    pub fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n+        match self {\n+            ProvenanceExtra::Concrete(pid) => f(pid),\n+            ProvenanceExtra::Wildcard => None,\n+        }\n+    }\n+}\n+\n+/// Extra per-allocation data\n+#[derive(Debug, Clone)]\n+pub struct AllocExtra {\n+    /// Stacked Borrows state is only added if it is enabled.\n+    pub stacked_borrows: Option<stacked_borrows::AllocExtra>,\n+    /// Data race detection via the use of a vector-clock,\n+    ///  this is only added if it is enabled.\n+    pub data_race: Option<data_race::AllocExtra>,\n+    /// Weak memory emulation via the use of store buffers,\n+    ///  this is only added if it is enabled.\n+    pub weak_memory: Option<weak_memory::AllocExtra>,\n+}\n+\n+/// Precomputed layouts of primitive types\n+pub struct PrimitiveLayouts<'tcx> {\n+    pub unit: TyAndLayout<'tcx>,\n+    pub i8: TyAndLayout<'tcx>,\n+    pub i16: TyAndLayout<'tcx>,\n+    pub i32: TyAndLayout<'tcx>,\n+    pub isize: TyAndLayout<'tcx>,\n+    pub u8: TyAndLayout<'tcx>,\n+    pub u16: TyAndLayout<'tcx>,\n+    pub u32: TyAndLayout<'tcx>,\n+    pub usize: TyAndLayout<'tcx>,\n+    pub bool: TyAndLayout<'tcx>,\n+    pub mut_raw_ptr: TyAndLayout<'tcx>,   // *mut ()\n+    pub const_raw_ptr: TyAndLayout<'tcx>, // *const ()\n+}\n+\n+impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n+    fn new(layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Result<Self, LayoutError<'tcx>> {\n+        let tcx = layout_cx.tcx;\n+        let mut_raw_ptr = tcx.mk_ptr(TypeAndMut { ty: tcx.types.unit, mutbl: Mutability::Mut });\n+        let const_raw_ptr = tcx.mk_ptr(TypeAndMut { ty: tcx.types.unit, mutbl: Mutability::Not });\n+        Ok(Self {\n+            unit: layout_cx.layout_of(tcx.mk_unit())?,\n+            i8: layout_cx.layout_of(tcx.types.i8)?,\n+            i16: layout_cx.layout_of(tcx.types.i16)?,\n+            i32: layout_cx.layout_of(tcx.types.i32)?,\n+            isize: layout_cx.layout_of(tcx.types.isize)?,\n+            u8: layout_cx.layout_of(tcx.types.u8)?,\n+            u16: layout_cx.layout_of(tcx.types.u16)?,\n+            u32: layout_cx.layout_of(tcx.types.u32)?,\n+            usize: layout_cx.layout_of(tcx.types.usize)?,\n+            bool: layout_cx.layout_of(tcx.types.bool)?,\n+            mut_raw_ptr: layout_cx.layout_of(mut_raw_ptr)?,\n+            const_raw_ptr: layout_cx.layout_of(const_raw_ptr)?,\n+        })\n+    }\n+}\n+\n+/// The machine itself.\n+pub struct MiriMachine<'mir, 'tcx> {\n+    // We carry a copy of the global `TyCtxt` for convenience, so methods taking just `&Evaluator` have `tcx` access.\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// Stacked Borrows global data.\n+    pub stacked_borrows: Option<stacked_borrows::GlobalState>,\n+\n+    /// Data race detector global data.\n+    pub data_race: Option<data_race::GlobalState>,\n+\n+    /// Ptr-int-cast module global data.\n+    pub intptrcast: intptrcast::GlobalState,\n+\n+    /// Environment variables set by `setenv`.\n+    /// Miri does not expose env vars from the host to the emulated program.\n+    pub(crate) env_vars: EnvVars<'tcx>,\n+\n+    /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n+    /// These are *pointers* to argc/argv because macOS.\n+    /// We also need the full command line as one string because of Windows.\n+    pub(crate) argc: Option<MemPlace<Provenance>>,\n+    pub(crate) argv: Option<MemPlace<Provenance>>,\n+    pub(crate) cmd_line: Option<MemPlace<Provenance>>,\n+\n+    /// TLS state.\n+    pub(crate) tls: TlsData<'tcx>,\n+\n+    /// What should Miri do when an op requires communicating with the host,\n+    /// such as accessing host env vars, random number generation, and\n+    /// file system access.\n+    pub(crate) isolated_op: IsolatedOp,\n+\n+    /// Whether to enforce the validity invariant.\n+    pub(crate) validate: bool,\n+\n+    /// Whether to enforce [ABI](Abi) of function calls.\n+    pub(crate) enforce_abi: bool,\n+\n+    /// The table of file descriptors.\n+    pub(crate) file_handler: shims::unix::FileHandler,\n+    /// The table of directory descriptors.\n+    pub(crate) dir_handler: shims::unix::DirHandler,\n+\n+    /// This machine's monotone clock.\n+    pub(crate) clock: Clock,\n+\n+    /// The set of threads.\n+    pub(crate) threads: ThreadManager<'mir, 'tcx>,\n+\n+    /// Precomputed `TyLayout`s for primitive data types that are commonly used inside Miri.\n+    pub(crate) layouts: PrimitiveLayouts<'tcx>,\n+\n+    /// Allocations that are considered roots of static memory (that may leak).\n+    pub(crate) static_roots: Vec<AllocId>,\n+\n+    /// The `measureme` profiler used to record timing information about\n+    /// the emulated program.\n+    profiler: Option<measureme::Profiler>,\n+    /// Used with `profiler` to cache the `StringId`s for event names\n+    /// uesd with `measureme`.\n+    string_cache: FxHashMap<String, measureme::StringId>,\n+\n+    /// Cache of `Instance` exported under the given `Symbol` name.\n+    /// `None` means no `Instance` exported under the given name is found.\n+    pub(crate) exported_symbols_cache: FxHashMap<Symbol, Option<Instance<'tcx>>>,\n+\n+    /// Whether to raise a panic in the context of the evaluated process when unsupported\n+    /// functionality is encountered. If `false`, an error is propagated in the Miri application context\n+    /// instead (default behavior)\n+    pub(crate) panic_on_unsupported: bool,\n+\n+    /// Equivalent setting as RUST_BACKTRACE on encountering an error.\n+    pub(crate) backtrace_style: BacktraceStyle,\n+\n+    /// Crates which are considered local for the purposes of error reporting.\n+    pub(crate) local_crates: Vec<CrateNum>,\n+\n+    /// Mapping extern static names to their base pointer.\n+    extern_statics: FxHashMap<Symbol, Pointer<Provenance>>,\n+\n+    /// The random number generator used for resolving non-determinism.\n+    /// Needs to be queried by ptr_to_int, hence needs interior mutability.\n+    pub(crate) rng: RefCell<StdRng>,\n+\n+    /// The allocation IDs to report when they are being allocated\n+    /// (helps for debugging memory leaks and use after free bugs).\n+    tracked_alloc_ids: FxHashSet<AllocId>,\n+\n+    /// Controls whether alignment of memory accesses is being checked.\n+    pub(crate) check_alignment: AlignmentCheck,\n+\n+    /// Failure rate of compare_exchange_weak, between 0.0 and 1.0\n+    pub(crate) cmpxchg_weak_failure_rate: f64,\n+\n+    /// Corresponds to -Zmiri-mute-stdout-stderr and doesn't write the output but acts as if it succeeded.\n+    pub(crate) mute_stdout_stderr: bool,\n+\n+    /// Whether weak memory emulation is enabled\n+    pub(crate) weak_memory: bool,\n+\n+    /// The probability of the active thread being preempted at the end of each basic block.\n+    pub(crate) preemption_rate: f64,\n+\n+    /// If `Some`, we will report the current stack every N basic blocks.\n+    pub(crate) report_progress: Option<u32>,\n+    // The total number of blocks that have been executed.\n+    pub(crate) basic_block_count: u64,\n+\n+    /// Handle of the optional shared object file for external functions.\n+    #[cfg(unix)]\n+    pub external_so_lib: Option<(libloading::Library, std::path::PathBuf)>,\n+\n+    /// Run a garbage collector for SbTags every N basic blocks.\n+    pub(crate) gc_interval: u32,\n+    /// The number of blocks that passed since the last SbTag GC pass.\n+    pub(crate) since_gc: u32,\n+}\n+\n+impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n+    pub(crate) fn new(config: &MiriConfig, layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Self {\n+        let local_crates = helpers::get_local_crates(layout_cx.tcx);\n+        let layouts =\n+            PrimitiveLayouts::new(layout_cx).expect(\"Couldn't get layouts of primitive types\");\n+        let profiler = config.measureme_out.as_ref().map(|out| {\n+            measureme::Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n+        });\n+        let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n+        let stacked_borrows = config.stacked_borrows.then(|| {\n+            RefCell::new(stacked_borrows::GlobalStateInner::new(\n+                config.tracked_pointer_tags.clone(),\n+                config.tracked_call_ids.clone(),\n+                config.retag_fields,\n+            ))\n+        });\n+        let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n+        MiriMachine {\n+            tcx: layout_cx.tcx,\n+            stacked_borrows,\n+            data_race,\n+            intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config)),\n+            // `env_vars` depends on a full interpreter so we cannot properly initialize it yet.\n+            env_vars: EnvVars::default(),\n+            argc: None,\n+            argv: None,\n+            cmd_line: None,\n+            tls: TlsData::default(),\n+            isolated_op: config.isolated_op,\n+            validate: config.validate,\n+            enforce_abi: config.check_abi,\n+            file_handler: FileHandler::new(config.mute_stdout_stderr),\n+            dir_handler: Default::default(),\n+            layouts,\n+            threads: ThreadManager::default(),\n+            static_roots: Vec::new(),\n+            profiler,\n+            string_cache: Default::default(),\n+            exported_symbols_cache: FxHashMap::default(),\n+            panic_on_unsupported: config.panic_on_unsupported,\n+            backtrace_style: config.backtrace_style,\n+            local_crates,\n+            extern_statics: FxHashMap::default(),\n+            rng: RefCell::new(rng),\n+            tracked_alloc_ids: config.tracked_alloc_ids.clone(),\n+            check_alignment: config.check_alignment,\n+            cmpxchg_weak_failure_rate: config.cmpxchg_weak_failure_rate,\n+            mute_stdout_stderr: config.mute_stdout_stderr,\n+            weak_memory: config.weak_memory_emulation,\n+            preemption_rate: config.preemption_rate,\n+            report_progress: config.report_progress,\n+            basic_block_count: 0,\n+            clock: Clock::new(config.isolated_op == IsolatedOp::Allow),\n+            #[cfg(unix)]\n+            external_so_lib: config.external_so_file.as_ref().map(|lib_file_path| {\n+                let target_triple = layout_cx.tcx.sess.opts.target_triple.triple();\n+                // Check if host target == the session target.\n+                if env!(\"TARGET\") != target_triple {\n+                    panic!(\n+                        \"calling external C functions in linked .so file requires host and target to be the same: host={}, target={}\",\n+                        env!(\"TARGET\"),\n+                        target_triple,\n+                    );\n+                }\n+                // Note: it is the user's responsibility to provide a correct SO file.\n+                // WATCH OUT: If an invalid/incorrect SO file is specified, this can cause\n+                // undefined behaviour in Miri itself!\n+                (\n+                    unsafe {\n+                        libloading::Library::new(lib_file_path)\n+                            .expect(\"failed to read specified extern shared object file\")\n+                    },\n+                    lib_file_path.clone(),\n+                )\n+            }),\n+            gc_interval: config.gc_interval,\n+            since_gc: 0,\n+        }\n+    }\n+\n+    pub(crate) fn late_init(\n+        this: &mut MiriInterpCx<'mir, 'tcx>,\n+        config: &MiriConfig,\n+    ) -> InterpResult<'tcx> {\n+        EnvVars::init(this, config)?;\n+        MiriMachine::init_extern_statics(this)?;\n+        ThreadManager::init(this);\n+        Ok(())\n+    }\n+\n+    fn add_extern_static(\n+        this: &mut MiriInterpCx<'mir, 'tcx>,\n+        name: &str,\n+        ptr: Pointer<Option<Provenance>>,\n+    ) {\n+        // This got just allocated, so there definitely is a pointer here.\n+        let ptr = ptr.into_pointer_or_addr().unwrap();\n+        this.machine.extern_statics.try_insert(Symbol::intern(name), ptr).unwrap();\n+    }\n+\n+    fn alloc_extern_static(\n+        this: &mut MiriInterpCx<'mir, 'tcx>,\n+        name: &str,\n+        val: ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let place = this.allocate(val.layout, MiriMemoryKind::ExternStatic.into())?;\n+        this.write_immediate(*val, &place.into())?;\n+        Self::add_extern_static(this, name, place.ptr);\n+        Ok(())\n+    }\n+\n+    /// Sets up the \"extern statics\" for this machine.\n+    fn init_extern_statics(this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+        match this.tcx.sess.target.os.as_ref() {\n+            \"linux\" => {\n+                // \"environ\"\n+                Self::add_extern_static(\n+                    this,\n+                    \"environ\",\n+                    this.machine.env_vars.environ.unwrap().ptr,\n+                );\n+                // A couple zero-initialized pointer-sized extern statics.\n+                // Most of them are for weak symbols, which we all set to null (indicating that the\n+                // symbol is not supported, and triggering fallback code which ends up calling a\n+                // syscall that we do support).\n+                for name in &[\"__cxa_thread_atexit_impl\", \"getrandom\", \"statx\", \"__clock_gettime64\"]\n+                {\n+                    let val = ImmTy::from_int(0, this.machine.layouts.usize);\n+                    Self::alloc_extern_static(this, name, val)?;\n+                }\n+            }\n+            \"freebsd\" => {\n+                // \"environ\"\n+                Self::add_extern_static(\n+                    this,\n+                    \"environ\",\n+                    this.machine.env_vars.environ.unwrap().ptr,\n+                );\n+            }\n+            \"android\" => {\n+                // \"signal\"\n+                let layout = this.machine.layouts.const_raw_ptr;\n+                let dlsym = Dlsym::from_str(\"signal\".as_bytes(), &this.tcx.sess.target.os)?\n+                    .expect(\"`signal` must be an actual dlsym on android\");\n+                let ptr = this.create_fn_alloc_ptr(FnVal::Other(dlsym));\n+                let val = ImmTy::from_scalar(Scalar::from_pointer(ptr, this), layout);\n+                Self::alloc_extern_static(this, \"signal\", val)?;\n+                // A couple zero-initialized pointer-sized extern statics.\n+                // Most of them are for weak symbols, which we all set to null (indicating that the\n+                // symbol is not supported, and triggering fallback code.)\n+                for name in &[\"bsd_signal\"] {\n+                    let val = ImmTy::from_int(0, this.machine.layouts.usize);\n+                    Self::alloc_extern_static(this, name, val)?;\n+                }\n+            }\n+            \"windows\" => {\n+                // \"_tls_used\"\n+                // This is some obscure hack that is part of the Windows TLS story. It's a `u8`.\n+                let val = ImmTy::from_int(0, this.machine.layouts.u8);\n+                Self::alloc_extern_static(this, \"_tls_used\", val)?;\n+            }\n+            _ => {} // No \"extern statics\" supported on this target\n+        }\n+        Ok(())\n+    }\n+\n+    pub(crate) fn communicate(&self) -> bool {\n+        self.isolated_op == IsolatedOp::Allow\n+    }\n+\n+    /// Check whether the stack frame that this `FrameInfo` refers to is part of a local crate.\n+    pub(crate) fn is_local(&self, frame: &FrameInfo<'_>) -> bool {\n+        let def_id = frame.instance.def_id();\n+        def_id.is_local() || self.local_crates.contains(&def_id.krate)\n+    }\n+}\n+\n+/// A rustc InterpCx for Miri.\n+pub type MiriInterpCx<'mir, 'tcx> = InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>;\n+\n+/// A little trait that's useful to be inherited by extension traits.\n+pub trait MiriInterpCxExt<'mir, 'tcx> {\n+    fn eval_context_ref<'a>(&'a self) -> &'a MiriInterpCx<'mir, 'tcx>;\n+    fn eval_context_mut<'a>(&'a mut self) -> &'a mut MiriInterpCx<'mir, 'tcx>;\n+}\n+impl<'mir, 'tcx> MiriInterpCxExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {\n+    #[inline(always)]\n+    fn eval_context_ref(&self) -> &MiriInterpCx<'mir, 'tcx> {\n+        self\n+    }\n+    #[inline(always)]\n+    fn eval_context_mut(&mut self) -> &mut MiriInterpCx<'mir, 'tcx> {\n+        self\n+    }\n+}\n+\n+/// Machine hook implementations.\n+impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n+    type MemoryKind = MiriMemoryKind;\n+    type ExtraFnVal = Dlsym;\n+\n+    type FrameExtra = FrameData<'tcx>;\n+    type AllocExtra = AllocExtra;\n+\n+    type Provenance = Provenance;\n+    type ProvenanceExtra = ProvenanceExtra;\n+\n+    type MemoryMap = MonoHashMap<\n+        AllocId,\n+        (MemoryKind<MiriMemoryKind>, Allocation<Provenance, Self::AllocExtra>),\n+    >;\n+\n+    const GLOBAL_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Global);\n+\n+    const PANIC_ON_ALLOC_FAIL: bool = false;\n+\n+    #[inline(always)]\n+    fn enforce_alignment(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+        ecx.machine.check_alignment != AlignmentCheck::None\n+    }\n+\n+    #[inline(always)]\n+    fn use_addr_for_alignment_check(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+        ecx.machine.check_alignment == AlignmentCheck::Int\n+    }\n+\n+    #[inline(always)]\n+    fn enforce_validity(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+        ecx.machine.validate\n+    }\n+\n+    #[inline(always)]\n+    fn enforce_abi(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+        ecx.machine.enforce_abi\n+    }\n+\n+    #[inline(always)]\n+    fn checked_binop_checks_overflow(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+        ecx.tcx.sess.overflow_checks()\n+    }\n+\n+    #[inline(always)]\n+    fn find_mir_or_eval_fn(\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+        instance: ty::Instance<'tcx>,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+        unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n+        ecx.find_mir_or_eval_fn(instance, abi, args, dest, ret, unwind)\n+    }\n+\n+    #[inline(always)]\n+    fn call_extra_fn(\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+        fn_val: Dlsym,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+        _unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx> {\n+        ecx.call_dlsym(fn_val, abi, args, dest, ret)\n+    }\n+\n+    #[inline(always)]\n+    fn call_intrinsic(\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+        unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx> {\n+        ecx.call_intrinsic(instance, args, dest, ret, unwind)\n+    }\n+\n+    #[inline(always)]\n+    fn assert_panic(\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+        msg: &mir::AssertMessage<'tcx>,\n+        unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        ecx.assert_panic(msg, unwind)\n+    }\n+\n+    #[inline(always)]\n+    fn abort(_ecx: &mut MiriInterpCx<'mir, 'tcx>, msg: String) -> InterpResult<'tcx, !> {\n+        throw_machine_stop!(TerminationInfo::Abort(msg))\n+    }\n+\n+    #[inline(always)]\n+    fn binary_ptr_op(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        bin_op: mir::BinOp,\n+        left: &ImmTy<'tcx, Provenance>,\n+        right: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<Provenance>, bool, Ty<'tcx>)> {\n+        ecx.binary_ptr_op(bin_op, left, right)\n+    }\n+\n+    fn thread_local_static_base_pointer(\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n+        ecx.get_or_create_thread_local_alloc(def_id)\n+    }\n+\n+    fn extern_static_base_pointer(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n+        let link_name = ecx.item_link_name(def_id);\n+        if let Some(&ptr) = ecx.machine.extern_statics.get(&link_name) {\n+            // Various parts of the engine rely on `get_alloc_info` for size and alignment\n+            // information. That uses the type information of this static.\n+            // Make sure it matches the Miri allocation for this.\n+            let Provenance::Concrete { alloc_id, .. } = ptr.provenance else {\n+                panic!(\"extern_statics cannot contain wildcards\")\n+            };\n+            let (shim_size, shim_align, _kind) = ecx.get_alloc_info(alloc_id);\n+            let extern_decl_layout =\n+                ecx.tcx.layout_of(ty::ParamEnv::empty().and(ecx.tcx.type_of(def_id))).unwrap();\n+            if extern_decl_layout.size != shim_size || extern_decl_layout.align.abi != shim_align {\n+                throw_unsup_format!(\n+                    \"`extern` static `{name}` from crate `{krate}` has been declared \\\n+                    with a size of {decl_size} bytes and alignment of {decl_align} bytes, \\\n+                    but Miri emulates it via an extern static shim \\\n+                    with a size of {shim_size} bytes and alignment of {shim_align} bytes\",\n+                    name = ecx.tcx.def_path_str(def_id),\n+                    krate = ecx.tcx.crate_name(def_id.krate),\n+                    decl_size = extern_decl_layout.size.bytes(),\n+                    decl_align = extern_decl_layout.align.abi.bytes(),\n+                    shim_size = shim_size.bytes(),\n+                    shim_align = shim_align.bytes(),\n+                )\n+            }\n+            Ok(ptr)\n+        } else {\n+            throw_unsup_format!(\n+                \"`extern` static `{name}` from crate `{krate}` is not supported by Miri\",\n+                name = ecx.tcx.def_path_str(def_id),\n+                krate = ecx.tcx.crate_name(def_id.krate),\n+            )\n+        }\n+    }\n+\n+    fn adjust_allocation<'b>(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        kind: Option<MemoryKind<Self::MemoryKind>>,\n+    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>> {\n+        let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n+        if ecx.machine.tracked_alloc_ids.contains(&id) {\n+            ecx.emit_diagnostic(NonHaltingDiagnostic::CreatedAlloc(\n+                id,\n+                alloc.size(),\n+                alloc.align,\n+                kind,\n+            ));\n+        }\n+\n+        let alloc = alloc.into_owned();\n+        let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n+            Stacks::new_allocation(\n+                id,\n+                alloc.size(),\n+                stacked_borrows,\n+                kind,\n+                ecx.machine.current_span(),\n+            )\n+        });\n+        let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n+            data_race::AllocExtra::new_allocation(\n+                data_race,\n+                &ecx.machine.threads,\n+                alloc.size(),\n+                kind,\n+            )\n+        });\n+        let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocExtra::new_allocation);\n+        let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n+            &ecx.tcx,\n+            AllocExtra {\n+                stacked_borrows: stacks.map(RefCell::new),\n+                data_race: race_alloc,\n+                weak_memory: buffer_alloc,\n+            },\n+            |ptr| ecx.global_base_pointer(ptr),\n+        )?;\n+        Ok(Cow::Owned(alloc))\n+    }\n+\n+    fn adjust_alloc_base_pointer(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        ptr: Pointer<AllocId>,\n+    ) -> Pointer<Provenance> {\n+        if cfg!(debug_assertions) {\n+            // The machine promises to never call us on thread-local or extern statics.\n+            let alloc_id = ptr.provenance;\n+            match ecx.tcx.try_get_global_alloc(alloc_id) {\n+                Some(GlobalAlloc::Static(def_id)) if ecx.tcx.is_thread_local_static(def_id) => {\n+                    panic!(\"adjust_alloc_base_pointer called on thread-local static\")\n+                }\n+                Some(GlobalAlloc::Static(def_id)) if ecx.tcx.is_foreign_item(def_id) => {\n+                    panic!(\"adjust_alloc_base_pointer called on extern static\")\n+                }\n+                _ => {}\n+            }\n+        }\n+        let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n+        let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n+            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n+        } else {\n+            // Value does not matter, SB is disabled\n+            SbTag::default()\n+        };\n+        Pointer::new(\n+            Provenance::Concrete { alloc_id: ptr.provenance, sb: sb_tag },\n+            Size::from_bytes(absolute_addr),\n+        )\n+    }\n+\n+    #[inline(always)]\n+    fn ptr_from_addr_cast(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        addr: u64,\n+    ) -> InterpResult<'tcx, Pointer<Option<Self::Provenance>>> {\n+        intptrcast::GlobalStateInner::ptr_from_addr_cast(ecx, addr)\n+    }\n+\n+    fn expose_ptr(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        match ptr.provenance {\n+            Provenance::Concrete { alloc_id, sb } =>\n+                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, sb),\n+            Provenance::Wildcard => {\n+                // No need to do anything for wildcard pointers as\n+                // their provenances have already been previously exposed.\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    /// Convert a pointer with provenance into an allocation-offset pair,\n+    /// or a `None` with an absolute address if that conversion is not possible.\n+    fn ptr_get_alloc(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        ptr: Pointer<Self::Provenance>,\n+    ) -> Option<(AllocId, Size, Self::ProvenanceExtra)> {\n+        let rel = intptrcast::GlobalStateInner::abs_ptr_to_rel(ecx, ptr);\n+\n+        rel.map(|(alloc_id, size)| {\n+            let sb = match ptr.provenance {\n+                Provenance::Concrete { sb, .. } => ProvenanceExtra::Concrete(sb),\n+                Provenance::Wildcard => ProvenanceExtra::Wildcard,\n+            };\n+            (alloc_id, size, sb)\n+        })\n+    }\n+\n+    #[inline(always)]\n+    fn before_memory_read(\n+        _tcx: TyCtxt<'tcx>,\n+        machine: &Self,\n+        alloc_extra: &AllocExtra,\n+        (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n+        range: AllocRange,\n+    ) -> InterpResult<'tcx> {\n+        if let Some(data_race) = &alloc_extra.data_race {\n+            data_race.read(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_ref().unwrap(),\n+                &machine.threads,\n+            )?;\n+        }\n+        if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n+            stacked_borrows.borrow_mut().before_memory_read(\n+                alloc_id,\n+                prov_extra,\n+                range,\n+                machine.stacked_borrows.as_ref().unwrap(),\n+                machine.current_span(),\n+                &machine.threads,\n+            )?;\n+        }\n+        if let Some(weak_memory) = &alloc_extra.weak_memory {\n+            weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n+        }\n+        Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn before_memory_write(\n+        _tcx: TyCtxt<'tcx>,\n+        machine: &mut Self,\n+        alloc_extra: &mut AllocExtra,\n+        (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n+        range: AllocRange,\n+    ) -> InterpResult<'tcx> {\n+        if let Some(data_race) = &mut alloc_extra.data_race {\n+            data_race.write(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_mut().unwrap(),\n+                &machine.threads,\n+            )?;\n+        }\n+        if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n+            stacked_borrows.get_mut().before_memory_write(\n+                alloc_id,\n+                prov_extra,\n+                range,\n+                machine.stacked_borrows.as_ref().unwrap(),\n+                machine.current_span(),\n+                &machine.threads,\n+            )?;\n+        }\n+        if let Some(weak_memory) = &alloc_extra.weak_memory {\n+            weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n+        }\n+        Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn before_memory_deallocation(\n+        _tcx: TyCtxt<'tcx>,\n+        machine: &mut Self,\n+        alloc_extra: &mut AllocExtra,\n+        (alloc_id, prove_extra): (AllocId, Self::ProvenanceExtra),\n+        range: AllocRange,\n+    ) -> InterpResult<'tcx> {\n+        if machine.tracked_alloc_ids.contains(&alloc_id) {\n+            machine.emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n+        }\n+        if let Some(data_race) = &mut alloc_extra.data_race {\n+            data_race.deallocate(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_mut().unwrap(),\n+                &machine.threads,\n+            )?;\n+        }\n+        if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n+            stacked_borrows.get_mut().before_memory_deallocation(\n+                alloc_id,\n+                prove_extra,\n+                range,\n+                machine.stacked_borrows.as_ref().unwrap(),\n+                machine.current_span(),\n+                &machine.threads,\n+            )\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn retag(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        kind: mir::RetagKind,\n+        place: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        if ecx.machine.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n+    }\n+\n+    #[inline(always)]\n+    fn init_frame_extra(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+        // Start recording our event before doing anything else\n+        let timing = if let Some(profiler) = ecx.machine.profiler.as_ref() {\n+            let fn_name = frame.instance.to_string();\n+            let entry = ecx.machine.string_cache.entry(fn_name.clone());\n+            let name = entry.or_insert_with(|| profiler.alloc_string(&*fn_name));\n+\n+            Some(profiler.start_recording_interval_event_detached(\n+                *name,\n+                measureme::EventId::from_label(*name),\n+                ecx.get_active_thread().to_u32(),\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n+\n+        let extra = FrameData {\n+            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n+            catch_unwind: None,\n+            timing,\n+        };\n+        Ok(frame.with_extra(extra))\n+    }\n+\n+    fn stack<'a>(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>] {\n+        ecx.active_thread_stack()\n+    }\n+\n+    fn stack_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>> {\n+        ecx.active_thread_stack_mut()\n+    }\n+\n+    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        ecx.machine.basic_block_count += 1u64; // a u64 that is only incremented by 1 will \"never\" overflow\n+        ecx.machine.since_gc += 1;\n+        // Possibly report our progress.\n+        if let Some(report_progress) = ecx.machine.report_progress {\n+            if ecx.machine.basic_block_count % u64::from(report_progress) == 0 {\n+                ecx.emit_diagnostic(NonHaltingDiagnostic::ProgressReport {\n+                    block_count: ecx.machine.basic_block_count,\n+                });\n+            }\n+        }\n+\n+        // Search for SbTags to find all live pointers, then remove all other tags from borrow\n+        // stacks.\n+        // When debug assertions are enabled, run the GC as often as possible so that any cases\n+        // where it mistakenly removes an important tag become visible.\n+        if ecx.machine.gc_interval > 0 && ecx.machine.since_gc >= ecx.machine.gc_interval {\n+            ecx.machine.since_gc = 0;\n+            ecx.garbage_collect_tags()?;\n+        }\n+\n+        // These are our preemption points.\n+        ecx.maybe_preempt_active_thread();\n+\n+        // Make sure some time passes.\n+        ecx.machine.clock.tick();\n+\n+        Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n+    }\n+\n+    #[inline(always)]\n+    fn after_stack_pop(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        mut frame: Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>,\n+        unwinding: bool,\n+    ) -> InterpResult<'tcx, StackPopJump> {\n+        let timing = frame.extra.timing.take();\n+        if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n+            stacked_borrows.borrow_mut().end_call(&frame.extra);\n+        }\n+        let res = ecx.handle_stack_pop_unwind(frame.extra, unwinding);\n+        if let Some(profiler) = ecx.machine.profiler.as_ref() {\n+            profiler.finish_recording_interval_event(timing.unwrap());\n+        }\n+        res\n+    }\n+}"}, {"sha": "45057632df9b528274b767cbc76c4f87a8eeeb52", "filename": "src/tools/miri/src/mono_hash_map.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmono_hash_map.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,110 @@\n+//! This is a \"monotonic `FxHashMap`\": A `FxHashMap` that, when shared, can be pushed to but not\n+//! otherwise mutated. We also box items in the map. This means we can safely provide\n+//! shared references into existing items in the `FxHashMap`, because they will not be dropped\n+//! (from being removed) or moved (because they are boxed).\n+//! The API is is completely tailored to what `memory.rs` needs. It is still in\n+//! a separate file to minimize the amount of code that has to care about the unsafety.\n+\n+use std::borrow::Borrow;\n+use std::cell::RefCell;\n+use std::collections::hash_map::Entry;\n+use std::hash::Hash;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use crate::AllocMap;\n+\n+#[derive(Debug, Clone)]\n+pub struct MonoHashMap<K: Hash + Eq, V>(RefCell<FxHashMap<K, Box<V>>>);\n+\n+impl<K: Hash + Eq, V> MonoHashMap<K, V> {\n+    /// This function exists for priroda to be able to iterate over all evaluator memory.\n+    ///\n+    /// The function is somewhat roundabout with the closure argument because internally the\n+    /// `MonoHashMap` uses a `RefCell`. When iterating over the `FxHashMap` inside the `RefCell`,\n+    /// we need to keep a borrow to the `FxHashMap` inside the iterator. The borrow is only alive\n+    /// as long as the `Ref` returned by `RefCell::borrow()` is alive. So we can't return the\n+    /// iterator, as that would drop the `Ref`. We can't return both, as it's not possible in Rust\n+    /// to have a struct/tuple with a field that refers to another field.\n+    pub fn iter<T>(&self, f: impl FnOnce(&mut dyn Iterator<Item = (&K, &V)>) -> T) -> T {\n+        f(&mut self.0.borrow().iter().map(|(k, v)| (k, &**v)))\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> Default for MonoHashMap<K, V> {\n+    fn default() -> Self {\n+        MonoHashMap(RefCell::new(Default::default()))\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> AllocMap<K, V> for MonoHashMap<K, V> {\n+    #[inline(always)]\n+    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+    {\n+        self.0.get_mut().contains_key(k)\n+    }\n+\n+    #[inline(always)]\n+    fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        self.0.get_mut().insert(k, Box::new(v)).map(|x| *x)\n+    }\n+\n+    #[inline(always)]\n+    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n+    where\n+        K: Borrow<Q>,\n+    {\n+        self.0.get_mut().remove(k).map(|x| *x)\n+    }\n+\n+    #[inline(always)]\n+    fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n+        self.0.borrow().iter().filter_map(move |(k, v)| f(k, v)).collect()\n+    }\n+\n+    /// The most interesting method: Providing a shared reference without\n+    /// holding the `RefCell` open, and inserting new data if the key\n+    /// is not used yet.\n+    /// `vacant` is called if the key is not found in the map;\n+    /// if it returns a reference, that is used directly, if it\n+    /// returns owned data, that is put into the map and returned.\n+    #[inline(always)]\n+    fn get_or<E>(&self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&V, E> {\n+        // We cannot hold borrow_mut while calling `vacant`, since that might have to do lookups in this very map.\n+        if let Some(v) = self.0.borrow().get(&k) {\n+            let val: *const V = &**v;\n+            // This is safe because `val` points into a `Box`, that we know will not move and\n+            // will also not be dropped as long as the shared reference `self` is live.\n+            return unsafe { Ok(&*val) };\n+        }\n+        let new_val = Box::new(vacant()?);\n+        let val: *const V = &**self.0.borrow_mut().try_insert(k, new_val).ok().unwrap();\n+        // This is safe because `val` points into a `Box`, that we know will not move and\n+        // will also not be dropped as long as the shared reference `self` is live.\n+        unsafe { Ok(&*val) }\n+    }\n+\n+    /// Read-only lookup (avoid read-acquiring the RefCell).\n+    fn get(&self, k: K) -> Option<&V> {\n+        let val: *const V = match self.0.borrow().get(&k) {\n+            Some(v) => &**v,\n+            None => return None,\n+        };\n+        // This is safe because `val` points into a `Box`, that we know will not move and\n+        // will also not be dropped as long as the shared reference `self` is live.\n+        unsafe { Some(&*val) }\n+    }\n+\n+    #[inline(always)]\n+    fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n+        match self.0.get_mut().entry(k) {\n+            Entry::Occupied(e) => Ok(e.into_mut()),\n+            Entry::Vacant(e) => {\n+                let v = vacant()?;\n+                Ok(e.insert(Box::new(v)))\n+            }\n+        }\n+    }\n+}"}, {"sha": "a0ef7fcad16dcca5843aff2791d80848985621db", "filename": "src/tools/miri/src/operator.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,90 @@\n+use log::trace;\n+\n+use rustc_middle::{mir, ty::Ty};\n+use rustc_target::abi::Size;\n+\n+use crate::*;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn binary_ptr_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: &ImmTy<'tcx, Provenance>,\n+        right: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<Provenance>, bool, Ty<'tcx>)>;\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriInterpCx<'mir, 'tcx> {\n+    fn binary_ptr_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: &ImmTy<'tcx, Provenance>,\n+        right: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<Provenance>, bool, Ty<'tcx>)> {\n+        use rustc_middle::mir::BinOp::*;\n+\n+        trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n+\n+        Ok(match bin_op {\n+            Eq | Ne | Lt | Le | Gt | Ge => {\n+                assert_eq!(left.layout.abi, right.layout.abi); // types an differ, e.g. fn ptrs with different `for`\n+                let size = self.pointer_size();\n+                // Just compare the bits. ScalarPairs are compared lexicographically.\n+                // We thus always compare pairs and simply fill scalars up with 0.\n+                let left = match **left {\n+                    Immediate::Scalar(l) => (l.to_bits(size)?, 0),\n+                    Immediate::ScalarPair(l1, l2) => (l1.to_bits(size)?, l2.to_bits(size)?),\n+                    Immediate::Uninit => panic!(\"we should never see uninit data here\"),\n+                };\n+                let right = match **right {\n+                    Immediate::Scalar(r) => (r.to_bits(size)?, 0),\n+                    Immediate::ScalarPair(r1, r2) => (r1.to_bits(size)?, r2.to_bits(size)?),\n+                    Immediate::Uninit => panic!(\"we should never see uninit data here\"),\n+                };\n+                let res = match bin_op {\n+                    Eq => left == right,\n+                    Ne => left != right,\n+                    Lt => left < right,\n+                    Le => left <= right,\n+                    Gt => left > right,\n+                    Ge => left >= right,\n+                    _ => bug!(),\n+                };\n+                (Scalar::from_bool(res), false, self.tcx.types.bool)\n+            }\n+\n+            Offset => {\n+                assert!(left.layout.ty.is_unsafe_ptr());\n+                let ptr = left.to_scalar().to_pointer(self)?;\n+                let offset = right.to_scalar().to_machine_isize(self)?;\n+\n+                let pointee_ty =\n+                    left.layout.ty.builtin_deref(true).expect(\"Offset called on non-ptr type\").ty;\n+                let ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset)?;\n+                (Scalar::from_maybe_pointer(ptr, self), false, left.layout.ty)\n+            }\n+\n+            // Some more operations are possible with atomics.\n+            // The return value always has the provenance of the *left* operand.\n+            Add | Sub | BitOr | BitAnd | BitXor => {\n+                assert!(left.layout.ty.is_unsafe_ptr());\n+                assert!(right.layout.ty.is_unsafe_ptr());\n+                let ptr = left.to_scalar().to_pointer(self)?;\n+                // We do the actual operation with usize-typed scalars.\n+                let left = ImmTy::from_uint(ptr.addr().bytes(), self.machine.layouts.usize);\n+                let right = ImmTy::from_uint(\n+                    right.to_scalar().to_machine_usize(self)?,\n+                    self.machine.layouts.usize,\n+                );\n+                let (result, overflowing, _ty) =\n+                    self.overflowing_binary_op(bin_op, &left, &right)?;\n+                // Construct a new pointer with the provenance of `ptr` (the LHS).\n+                let result_ptr =\n+                    Pointer::new(ptr.provenance, Size::from_bytes(result.to_machine_usize(self)?));\n+                (Scalar::from_maybe_pointer(result_ptr, self), overflowing, left.layout.ty)\n+            }\n+\n+            _ => span_bug!(self.cur_span(), \"Invalid operator on pointers: {:?}\", bin_op),\n+        })\n+    }\n+}"}, {"sha": "c77ea63b0873f1eb3f83c338e10e158129ca6cca", "filename": "src/tools/miri/src/range_map.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,300 @@\n+//! Implements a map from integer indices to data.\n+//! Rather than storing data for every index, internally, this maps entire ranges to the data.\n+//! To this end, the APIs all work on ranges, not on individual integers. Ranges are split as\n+//! necessary (e.g., when [0,5) is first associated with X, and then [1,2) is mutated).\n+//! Users must not depend on whether a range is coalesced or not, even though this is observable\n+//! via the iteration APIs.\n+\n+use std::ops;\n+\n+use rustc_target::abi::Size;\n+\n+#[derive(Clone, Debug)]\n+struct Elem<T> {\n+    /// The range covered by this element; never empty.\n+    range: ops::Range<u64>,\n+    /// The data stored for this element.\n+    data: T,\n+}\n+#[derive(Clone, Debug)]\n+pub struct RangeMap<T> {\n+    v: Vec<Elem<T>>,\n+}\n+\n+impl<T> RangeMap<T> {\n+    /// Creates a new `RangeMap` for the given size, and with the given initial value used for\n+    /// the entire range.\n+    #[inline(always)]\n+    pub fn new(size: Size, init: T) -> RangeMap<T> {\n+        let size = size.bytes();\n+        let mut map = RangeMap { v: Vec::new() };\n+        if size > 0 {\n+            map.v.push(Elem { range: 0..size, data: init });\n+        }\n+        map\n+    }\n+\n+    /// Finds the index containing the given offset.\n+    fn find_offset(&self, offset: u64) -> usize {\n+        // We do a binary search.\n+        let mut left = 0usize; // inclusive\n+        let mut right = self.v.len(); // exclusive\n+        loop {\n+            debug_assert!(left < right, \"find_offset: offset {} is out-of-bounds\", offset);\n+            let candidate = left.checked_add(right).unwrap() / 2;\n+            let elem = &self.v[candidate];\n+            if offset < elem.range.start {\n+                // We are too far right (offset is further left).\n+                debug_assert!(candidate < right); // we are making progress\n+                right = candidate;\n+            } else if offset >= elem.range.end {\n+                // We are too far left (offset is further right).\n+                debug_assert!(candidate >= left); // we are making progress\n+                left = candidate + 1;\n+            } else {\n+                // This is it!\n+                return candidate;\n+            }\n+        }\n+    }\n+\n+    /// Provides read-only iteration over everything in the given range. This does\n+    /// *not* split items if they overlap with the edges. Do not use this to mutate\n+    /// through interior mutability.\n+    ///\n+    /// The iterator also provides the offset of the given element.\n+    pub fn iter(&self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &T)> {\n+        let offset = offset.bytes();\n+        let len = len.bytes();\n+        // Compute a slice starting with the elements we care about.\n+        let slice: &[Elem<T>] = if len == 0 {\n+            // We just need any empty iterator. We don't even want to\n+            // yield the element that surrounds this position.\n+            &[]\n+        } else {\n+            let first_idx = self.find_offset(offset);\n+            &self.v[first_idx..]\n+        };\n+        // The first offset that is not included any more.\n+        let end = offset + len;\n+        assert!(\n+            end <= self.v.last().unwrap().range.end,\n+            \"iterating beyond the bounds of this RangeMap\"\n+        );\n+        slice\n+            .iter()\n+            .take_while(move |elem| elem.range.start < end)\n+            .map(|elem| (Size::from_bytes(elem.range.start), &elem.data))\n+    }\n+\n+    pub fn iter_mut_all(&mut self) -> impl Iterator<Item = &mut T> {\n+        self.v.iter_mut().map(|elem| &mut elem.data)\n+    }\n+\n+    // Splits the element situated at the given `index`, such that the 2nd one starts at offset\n+    // `split_offset`. Do nothing if the element already starts there.\n+    // Returns whether a split was necessary.\n+    fn split_index(&mut self, index: usize, split_offset: u64) -> bool\n+    where\n+        T: Clone,\n+    {\n+        let elem = &mut self.v[index];\n+        if split_offset == elem.range.start || split_offset == elem.range.end {\n+            // Nothing to do.\n+            return false;\n+        }\n+        debug_assert!(\n+            elem.range.contains(&split_offset),\n+            \"the `split_offset` is not in the element to be split\"\n+        );\n+\n+        // Now we really have to split. Reduce length of first element.\n+        let second_range = split_offset..elem.range.end;\n+        elem.range.end = split_offset;\n+        // Copy the data, and insert second element.\n+        let second = Elem { range: second_range, data: elem.data.clone() };\n+        self.v.insert(index + 1, second);\n+        true\n+    }\n+\n+    /// Provides mutable iteration over everything in the given range. As a side-effect,\n+    /// this will split entries in the map that are only partially hit by the given range,\n+    /// to make sure that when they are mutated, the effect is constrained to the given range.\n+    /// Moreover, this will opportunistically merge neighbouring equal blocks.\n+    ///\n+    /// The iterator also provides the offset of the given element.\n+    pub fn iter_mut(&mut self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &mut T)>\n+    where\n+        T: Clone + PartialEq,\n+    {\n+        let offset = offset.bytes();\n+        let len = len.bytes();\n+        // Compute a slice containing exactly the elements we care about\n+        let slice: &mut [Elem<T>] = if len == 0 {\n+            // We just need any empty iterator. We don't even want to\n+            // yield the element that surrounds this position, nor do\n+            // any splitting.\n+            &mut []\n+        } else {\n+            // Make sure we got a clear beginning\n+            let mut first_idx = self.find_offset(offset);\n+            if self.split_index(first_idx, offset) {\n+                // The newly created 2nd element is ours\n+                first_idx += 1;\n+            }\n+            // No more mutation.\n+            let first_idx = first_idx;\n+            // Find our end. Linear scan, but that's ok because the iteration\n+            // is doing the same linear scan anyway -- no increase in complexity.\n+            // We combine this scan with a scan for duplicates that we can merge, to reduce\n+            // the number of elements.\n+            // We stop searching after the first \"block\" of size 1, to avoid spending excessive\n+            // amounts of time on the merging.\n+            let mut equal_since_idx = first_idx;\n+            // Once we see too many non-mergeable blocks, we stop.\n+            // The initial value is chosen via... magic. Benchmarking and magic.\n+            let mut successful_merge_count = 3usize;\n+            // When the loop is done, this is the first excluded element.\n+            let mut end_idx = first_idx;\n+            loop {\n+                // Compute if `end` is the last element we need to look at.\n+                let done = self.v[end_idx].range.end >= offset + len;\n+                // We definitely need to include `end`, so move the index.\n+                end_idx += 1;\n+                debug_assert!(\n+                    done || end_idx < self.v.len(),\n+                    \"iter_mut: end-offset {} is out-of-bounds\",\n+                    offset + len\n+                );\n+                // see if we want to merge everything in `equal_since..end` (exclusive at the end!)\n+                if successful_merge_count > 0 {\n+                    if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n+                        // Everything in `equal_since..end` was equal. Make them just one element covering\n+                        // the entire range.\n+                        let removed_elems = end_idx - equal_since_idx - 1; // number of elements that we would remove\n+                        if removed_elems > 0 {\n+                            // Adjust the range of the first element to cover all of them.\n+                            let equal_until = self.v[end_idx - 1].range.end; // end of range of last of the equal elements\n+                            self.v[equal_since_idx].range.end = equal_until;\n+                            // Delete the rest of them.\n+                            self.v.splice(equal_since_idx + 1..end_idx, std::iter::empty());\n+                            // Adjust `end_idx` because we made the list shorter.\n+                            end_idx -= removed_elems;\n+                            // Adjust the count for the cutoff.\n+                            successful_merge_count += removed_elems;\n+                        } else {\n+                            // Adjust the count for the cutoff.\n+                            successful_merge_count -= 1;\n+                        }\n+                        // Go on scanning for the next block starting here.\n+                        equal_since_idx = end_idx;\n+                    }\n+                }\n+                // Leave loop if this is the last element.\n+                if done {\n+                    break;\n+                }\n+            }\n+            // Move to last included instead of first excluded index.\n+            let end_idx = end_idx - 1;\n+            // We need to split the end as well. Even if this performs a\n+            // split, we don't have to adjust our index as we only care about\n+            // the first part of the split.\n+            self.split_index(end_idx, offset + len);\n+            // Now we yield the slice. `end` is inclusive.\n+            &mut self.v[first_idx..=end_idx]\n+        };\n+        slice.iter_mut().map(|elem| (Size::from_bytes(elem.range.start), &mut elem.data))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    /// Query the map at every offset in the range and collect the results.\n+    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n+        (offset..offset + len)\n+            .into_iter()\n+            .map(|i| {\n+                map.iter(Size::from_bytes(i), Size::from_bytes(1)).next().map(|(_, &t)| t).unwrap()\n+            })\n+            .collect()\n+    }\n+\n+    #[test]\n+    fn basic_insert() {\n+        let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n+        // Insert.\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n+            *x = 42;\n+        }\n+        // Check.\n+        assert_eq!(to_vec(&map, 10, 1), vec![42]);\n+        assert_eq!(map.v.len(), 3);\n+\n+        // Insert with size 0.\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n+            *x = 19;\n+        }\n+        for (_, x) in map.iter_mut(Size::from_bytes(11), Size::from_bytes(0)) {\n+            *x = 19;\n+        }\n+        assert_eq!(to_vec(&map, 10, 2), vec![42, -1]);\n+        assert_eq!(map.v.len(), 3);\n+    }\n+\n+    #[test]\n+    fn gaps() {\n+        let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n+        for (_, x) in map.iter_mut(Size::from_bytes(11), Size::from_bytes(1)) {\n+            *x = 42;\n+        }\n+        for (_, x) in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n+            *x = 43;\n+        }\n+        assert_eq!(map.v.len(), 5);\n+        assert_eq!(to_vec(&map, 10, 10), vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]);\n+\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n+            if *x < 42 {\n+                *x = 23;\n+            }\n+        }\n+        assert_eq!(map.v.len(), 6);\n+        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]);\n+        assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 43, 23, 23]);\n+\n+        for (_, x) in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n+            *x = 19;\n+        }\n+        assert_eq!(map.v.len(), 6);\n+        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]);\n+        // Should be seeing two blocks with 19.\n+        assert_eq!(\n+            map.iter(Size::from_bytes(15), Size::from_bytes(2))\n+                .map(|(_, &t)| t)\n+                .collect::<Vec<_>>(),\n+            vec![19, 19]\n+        );\n+\n+        // A NOP `iter_mut` should trigger merging.\n+        for _ in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {}\n+        assert_eq!(map.v.len(), 5);\n+        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn out_of_range_iter_mut() {\n+        let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n+        let _ = map.iter_mut(Size::from_bytes(11), Size::from_bytes(11));\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn out_of_range_iter() {\n+        let map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n+        let _ = map.iter(Size::from_bytes(11), Size::from_bytes(11));\n+    }\n+}"}, {"sha": "15987eee537fd72372cab58e2c654ab206631c9e", "filename": "src/tools/miri/src/shims/backtrace.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,254 @@\n+use crate::*;\n+use rustc_ast::ast::Mutability;\n+use rustc_middle::ty::layout::LayoutOf as _;\n+use rustc_middle::ty::{self, Instance};\n+use rustc_span::{BytePos, Loc, Symbol};\n+use rustc_target::{abi::Size, spec::abi::Abi};\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn handle_miri_backtrace_size(\n+        &mut self,\n+        abi: Abi,\n+        link_name: Symbol,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let [flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+\n+        let flags = this.read_scalar(flags)?.to_u64()?;\n+        if flags != 0 {\n+            throw_unsup_format!(\"unknown `miri_backtrace_size` flags {}\", flags);\n+        }\n+\n+        let frame_count = this.active_thread_stack().len();\n+\n+        this.write_scalar(Scalar::from_machine_usize(frame_count.try_into().unwrap(), this), dest)\n+    }\n+\n+    fn handle_miri_get_backtrace(\n+        &mut self,\n+        abi: Abi,\n+        link_name: Symbol,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let tcx = this.tcx;\n+\n+        let flags = if let Some(flags_op) = args.get(0) {\n+            this.read_scalar(flags_op)?.to_u64()?\n+        } else {\n+            throw_ub_format!(\"expected at least 1 argument\")\n+        };\n+\n+        let mut data = Vec::new();\n+        for frame in this.active_thread_stack().iter().rev() {\n+            let mut span = frame.current_span();\n+            // Match the behavior of runtime backtrace spans\n+            // by using a non-macro span in our backtrace. See `FunctionCx::debug_loc`.\n+            if span.from_expansion() && !tcx.sess.opts.unstable_opts.debug_macros {\n+                span = rustc_span::hygiene::walk_chain(span, frame.body.span.ctxt())\n+            }\n+            data.push((frame.instance, span.lo()));\n+        }\n+\n+        let ptrs: Vec<_> = data\n+            .into_iter()\n+            .map(|(instance, pos)| {\n+                // We represent a frame pointer by using the `span.lo` value\n+                // as an offset into the function's allocation. This gives us an\n+                // opaque pointer that we can return to user code, and allows us\n+                // to reconstruct the needed frame information in `handle_miri_resolve_frame`.\n+                // Note that we never actually read or write anything from/to this pointer -\n+                // all of the data is represented by the pointer value itself.\n+                let fn_ptr = this.create_fn_alloc_ptr(FnVal::Instance(instance));\n+                fn_ptr.wrapping_offset(Size::from_bytes(pos.0), this)\n+            })\n+            .collect();\n+\n+        let len: u64 = ptrs.len().try_into().unwrap();\n+\n+        let ptr_ty = this.machine.layouts.mut_raw_ptr.ty;\n+        let array_layout = this.layout_of(tcx.mk_array(ptr_ty, len)).unwrap();\n+\n+        match flags {\n+            // storage for pointers is allocated by miri\n+            // deallocating the slice is undefined behavior with a custom global allocator\n+            0 => {\n+                let [_flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+\n+                let alloc = this.allocate(array_layout, MiriMemoryKind::Rust.into())?;\n+\n+                // Write pointers into array\n+                for (i, ptr) in ptrs.into_iter().enumerate() {\n+                    let place = this.mplace_index(&alloc, i as u64)?;\n+\n+                    this.write_pointer(ptr, &place.into())?;\n+                }\n+\n+                this.write_immediate(\n+                    Immediate::new_slice(Scalar::from_maybe_pointer(alloc.ptr, this), len, this),\n+                    dest,\n+                )?;\n+            }\n+            // storage for pointers is allocated by the caller\n+            1 => {\n+                let [_flags, buf] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+\n+                let buf_place = this.deref_operand(buf)?;\n+\n+                let ptr_layout = this.layout_of(ptr_ty)?;\n+\n+                for (i, ptr) in ptrs.into_iter().enumerate() {\n+                    let offset = ptr_layout.size * i.try_into().unwrap();\n+\n+                    let op_place = buf_place.offset(offset, ptr_layout, this)?;\n+\n+                    this.write_pointer(ptr, &op_place.into())?;\n+                }\n+            }\n+            _ => throw_unsup_format!(\"unknown `miri_get_backtrace` flags {}\", flags),\n+        };\n+\n+        Ok(())\n+    }\n+\n+    fn resolve_frame_pointer(\n+        &mut self,\n+        ptr: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, (Instance<'tcx>, Loc, String, String)> {\n+        let this = self.eval_context_mut();\n+\n+        let ptr = this.read_pointer(ptr)?;\n+        // Take apart the pointer, we need its pieces. The offset encodes the span.\n+        let (alloc_id, offset, _prov) = this.ptr_get_alloc_id(ptr)?;\n+\n+        // This has to be an actual global fn ptr, not a dlsym function.\n+        let fn_instance = if let Some(GlobalAlloc::Function(instance)) =\n+            this.tcx.try_get_global_alloc(alloc_id)\n+        {\n+            instance\n+        } else {\n+            throw_ub_format!(\"expected static function pointer, found {:?}\", ptr);\n+        };\n+\n+        let lo =\n+            this.tcx.sess.source_map().lookup_char_pos(BytePos(offset.bytes().try_into().unwrap()));\n+\n+        let name = fn_instance.to_string();\n+        let filename = lo.file.name.prefer_remapped().to_string();\n+\n+        Ok((fn_instance, lo, name, filename))\n+    }\n+\n+    fn handle_miri_resolve_frame(\n+        &mut self,\n+        abi: Abi,\n+        link_name: Symbol,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let [ptr, flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+\n+        let flags = this.read_scalar(flags)?.to_u64()?;\n+\n+        let (fn_instance, lo, name, filename) = this.resolve_frame_pointer(ptr)?;\n+\n+        // Reconstruct the original function pointer,\n+        // which we pass to user code.\n+        let fn_ptr = this.create_fn_alloc_ptr(FnVal::Instance(fn_instance));\n+\n+        let num_fields = dest.layout.fields.count();\n+\n+        if !(4..=5).contains(&num_fields) {\n+            // Always mention 5 fields, since the 4-field struct\n+            // is deprecated and slated for removal.\n+            throw_ub_format!(\n+                \"bad declaration of miri_resolve_frame - should return a struct with 5 fields\"\n+            );\n+        }\n+\n+        // `u32` is not enough to fit line/colno, which can be `usize`. It seems unlikely that a\n+        // file would have more than 2^32 lines or columns, but whatever, just default to 0.\n+        let lineno: u32 = u32::try_from(lo.line).unwrap_or(0);\n+        // `lo.col` is 0-based - add 1 to make it 1-based for the caller.\n+        let colno: u32 = u32::try_from(lo.col.0.saturating_add(1)).unwrap_or(0);\n+\n+        let dest = this.force_allocation(dest)?;\n+        if let ty::Adt(adt, _) = dest.layout.ty.kind() {\n+            if !adt.repr().c() {\n+                throw_ub_format!(\n+                    \"miri_resolve_frame must be declared with a `#[repr(C)]` return type\"\n+                );\n+            }\n+        }\n+\n+        match flags {\n+            0 => {\n+                // These are \"mutable\" allocations as we consider them to be owned by the callee.\n+                let name_alloc =\n+                    this.allocate_str(&name, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+                let filename_alloc =\n+                    this.allocate_str(&filename, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+\n+                this.write_immediate(\n+                    name_alloc.to_ref(this),\n+                    &this.mplace_field(&dest, 0)?.into(),\n+                )?;\n+                this.write_immediate(\n+                    filename_alloc.to_ref(this),\n+                    &this.mplace_field(&dest, 1)?.into(),\n+                )?;\n+            }\n+            1 => {\n+                this.write_scalar(\n+                    Scalar::from_machine_usize(name.len().try_into().unwrap(), this),\n+                    &this.mplace_field(&dest, 0)?.into(),\n+                )?;\n+                this.write_scalar(\n+                    Scalar::from_machine_usize(filename.len().try_into().unwrap(), this),\n+                    &this.mplace_field(&dest, 1)?.into(),\n+                )?;\n+            }\n+            _ => throw_unsup_format!(\"unknown `miri_resolve_frame` flags {}\", flags),\n+        }\n+\n+        this.write_scalar(Scalar::from_u32(lineno), &this.mplace_field(&dest, 2)?.into())?;\n+        this.write_scalar(Scalar::from_u32(colno), &this.mplace_field(&dest, 3)?.into())?;\n+\n+        // Support a 4-field struct for now - this is deprecated\n+        // and slated for removal.\n+        if num_fields == 5 {\n+            this.write_pointer(fn_ptr, &this.mplace_field(&dest, 4)?.into())?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn handle_miri_resolve_frame_names(\n+        &mut self,\n+        abi: Abi,\n+        link_name: Symbol,\n+        args: &[OpTy<'tcx, Provenance>],\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [ptr, flags, name_ptr, filename_ptr] =\n+            this.check_shim(abi, Abi::Rust, link_name, args)?;\n+\n+        let flags = this.read_scalar(flags)?.to_u64()?;\n+        if flags != 0 {\n+            throw_unsup_format!(\"unknown `miri_resolve_frame_names` flags {}\", flags);\n+        }\n+\n+        let (_, _, name, filename) = this.resolve_frame_pointer(ptr)?;\n+\n+        this.write_bytes_ptr(this.read_pointer(name_ptr)?, name.bytes())?;\n+        this.write_bytes_ptr(this.read_pointer(filename_ptr)?, filename.bytes())?;\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "8bf6d24f85f31a1407b765b1d34b4e8aacb5ac59", "filename": "src/tools/miri/src/shims/dlsym.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fdlsym.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,48 @@\n+use rustc_middle::mir;\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::helpers::target_os_is_unix;\n+use crate::*;\n+use shims::unix::dlsym as unix;\n+use shims::windows::dlsym as windows;\n+\n+#[derive(Debug, Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+pub enum Dlsym {\n+    Posix(unix::Dlsym),\n+    Windows(windows::Dlsym),\n+}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str<'tcx>(name: &[u8], target_os: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n+        let name = &*String::from_utf8_lossy(name);\n+        Ok(match target_os {\n+            target if target_os_is_unix(target) =>\n+                unix::Dlsym::from_str(name, target)?.map(Dlsym::Posix),\n+            \"windows\" => windows::Dlsym::from_str(name)?.map(Dlsym::Windows),\n+            os => bug!(\"dlsym not implemented for target_os {}\", os),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        match dlsym {\n+            Dlsym::Posix(dlsym) =>\n+                unix::EvalContextExt::call_dlsym(this, dlsym, abi, args, dest, ret),\n+            Dlsym::Windows(dlsym) =>\n+                windows::EvalContextExt::call_dlsym(this, dlsym, abi, args, dest, ret),\n+        }\n+    }\n+}"}, {"sha": "95051c998e5fd5800e01a9b291e53c40e3f21142", "filename": "src/tools/miri/src/shims/env.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,469 @@\n+use std::env;\n+use std::ffi::{OsStr, OsString};\n+use std::io::ErrorKind;\n+use std::mem;\n+\n+use rustc_const_eval::interpret::Pointer;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_target::abi::Size;\n+\n+use crate::helpers::target_os_is_unix;\n+use crate::*;\n+\n+/// Check whether an operation that writes to a target buffer was successful.\n+/// Accordingly select return value.\n+/// Local helper function to be used in Windows shims.\n+fn windows_check_buffer_size((success, len): (bool, u64)) -> u32 {\n+    if success {\n+        // If the function succeeds, the return value is the number of characters stored in the target buffer,\n+        // not including the terminating null character.\n+        u32::try_from(len.checked_sub(1).unwrap()).unwrap()\n+    } else {\n+        // If the target buffer was not large enough to hold the data, the return value is the buffer size, in characters,\n+        // required to hold the string and its terminating null character.\n+        u32::try_from(len).unwrap()\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct EnvVars<'tcx> {\n+    /// Stores pointers to the environment variables. These variables must be stored as\n+    /// null-terminated target strings (c_str or wide_str) with the `\"{name}={value}\"` format.\n+    map: FxHashMap<OsString, Pointer<Option<Provenance>>>,\n+\n+    /// Place where the `environ` static is stored. Lazily initialized, but then never changes.\n+    pub(crate) environ: Option<MPlaceTy<'tcx, Provenance>>,\n+}\n+\n+impl<'tcx> EnvVars<'tcx> {\n+    pub(crate) fn init<'mir>(\n+        ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n+        config: &MiriConfig,\n+    ) -> InterpResult<'tcx> {\n+        let target_os = ecx.tcx.sess.target.os.as_ref();\n+\n+        // Skip the loop entirely if we don't want to forward anything.\n+        if ecx.machine.communicate() || !config.forwarded_env_vars.is_empty() {\n+            for (name, value) in &config.env {\n+                let forward = ecx.machine.communicate()\n+                    || config.forwarded_env_vars.iter().any(|v| **v == *name);\n+                if forward {\n+                    let var_ptr = match target_os {\n+                        target if target_os_is_unix(target) =>\n+                            alloc_env_var_as_c_str(name.as_ref(), value.as_ref(), ecx)?,\n+                        \"windows\" => alloc_env_var_as_wide_str(name.as_ref(), value.as_ref(), ecx)?,\n+                        unsupported =>\n+                            throw_unsup_format!(\n+                                \"environment support for target OS `{}` not yet available\",\n+                                unsupported\n+                            ),\n+                    };\n+                    ecx.machine.env_vars.map.insert(name.clone(), var_ptr);\n+                }\n+            }\n+        }\n+        ecx.update_environ()\n+    }\n+\n+    pub(crate) fn cleanup<'mir>(\n+        ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n+    ) -> InterpResult<'tcx> {\n+        // Deallocate individual env vars.\n+        let env_vars = mem::take(&mut ecx.machine.env_vars.map);\n+        for (_name, ptr) in env_vars {\n+            ecx.deallocate_ptr(ptr, None, MiriMemoryKind::Runtime.into())?;\n+        }\n+        // Deallocate environ var list.\n+        let environ = ecx.machine.env_vars.environ.unwrap();\n+        let old_vars_ptr = ecx.read_pointer(&environ.into())?;\n+        ecx.deallocate_ptr(old_vars_ptr, None, MiriMemoryKind::Runtime.into())?;\n+        Ok(())\n+    }\n+}\n+\n+fn alloc_env_var_as_c_str<'mir, 'tcx>(\n+    name: &OsStr,\n+    value: &OsStr,\n+    ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n+) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+    let mut name_osstring = name.to_os_string();\n+    name_osstring.push(\"=\");\n+    name_osstring.push(value);\n+    ecx.alloc_os_str_as_c_str(name_osstring.as_os_str(), MiriMemoryKind::Runtime.into())\n+}\n+\n+fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n+    name: &OsStr,\n+    value: &OsStr,\n+    ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n+) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+    let mut name_osstring = name.to_os_string();\n+    name_osstring.push(\"=\");\n+    name_osstring.push(value);\n+    ecx.alloc_os_str_as_wide_str(name_osstring.as_os_str(), MiriMemoryKind::Runtime.into())\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn getenv(\n+        &mut self,\n+        name_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os_is_unix(\"getenv\");\n+\n+        let name_ptr = this.read_pointer(name_op)?;\n+        let name = this.read_os_str_from_c_str(name_ptr)?;\n+        Ok(match this.machine.env_vars.map.get(name) {\n+            Some(var_ptr) => {\n+                // The offset is used to strip the \"{name}=\" part of the string.\n+                var_ptr.offset(\n+                    Size::from_bytes(u64::try_from(name.len()).unwrap().checked_add(1).unwrap()),\n+                    this,\n+                )?\n+            }\n+            None => Pointer::null(),\n+        })\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn GetEnvironmentVariableW(\n+        &mut self,\n+        name_op: &OpTy<'tcx, Provenance>, // LPCWSTR\n+        buf_op: &OpTy<'tcx, Provenance>,  // LPWSTR\n+        size_op: &OpTy<'tcx, Provenance>, // DWORD\n+    ) -> InterpResult<'tcx, u32> {\n+        // ^ Returns DWORD (u32 on Windows)\n+\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"GetEnvironmentVariableW\");\n+\n+        let name_ptr = this.read_pointer(name_op)?;\n+        let name = this.read_os_str_from_wide_str(name_ptr)?;\n+        Ok(match this.machine.env_vars.map.get(&name) {\n+            Some(var_ptr) => {\n+                // The offset is used to strip the \"{name}=\" part of the string.\n+                #[rustfmt::skip]\n+                let name_offset_bytes = u64::try_from(name.len()).unwrap()\n+                    .checked_add(1).unwrap()\n+                    .checked_mul(2).unwrap();\n+                let var_ptr = var_ptr.offset(Size::from_bytes(name_offset_bytes), this)?;\n+                let var = this.read_os_str_from_wide_str(var_ptr)?;\n+\n+                let buf_ptr = this.read_pointer(buf_op)?;\n+                // `buf_size` represents the size in characters.\n+                let buf_size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n+                windows_check_buffer_size(this.write_os_str_to_wide_str(&var, buf_ptr, buf_size)?)\n+            }\n+            None => {\n+                let envvar_not_found = this.eval_windows(\"c\", \"ERROR_ENVVAR_NOT_FOUND\")?;\n+                this.set_last_error(envvar_not_found)?;\n+                0 // return zero upon failure\n+            }\n+        })\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn GetEnvironmentStringsW(&mut self) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"GetEnvironmentStringsW\");\n+\n+        // Info on layout of environment blocks in Windows:\n+        // https://docs.microsoft.com/en-us/windows/win32/procthread/environment-variables\n+        let mut env_vars = std::ffi::OsString::new();\n+        for &item in this.machine.env_vars.map.values() {\n+            let env_var = this.read_os_str_from_wide_str(item)?;\n+            env_vars.push(env_var);\n+            env_vars.push(\"\\0\");\n+        }\n+        // Allocate environment block & Store environment variables to environment block.\n+        // Final null terminator(block terminator) is added by `alloc_os_str_to_wide_str`.\n+        let envblock_ptr =\n+            this.alloc_os_str_as_wide_str(&env_vars, MiriMemoryKind::Runtime.into())?;\n+        // If the function succeeds, the return value is a pointer to the environment block of the current process.\n+        Ok(envblock_ptr)\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn FreeEnvironmentStringsW(\n+        &mut self,\n+        env_block_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"FreeEnvironmentStringsW\");\n+\n+        let env_block_ptr = this.read_pointer(env_block_op)?;\n+        let result = this.deallocate_ptr(env_block_ptr, None, MiriMemoryKind::Runtime.into());\n+        // If the function succeeds, the return value is nonzero.\n+        Ok(i32::from(result.is_ok()))\n+    }\n+\n+    fn setenv(\n+        &mut self,\n+        name_op: &OpTy<'tcx, Provenance>,\n+        value_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os_is_unix(\"setenv\");\n+\n+        let name_ptr = this.read_pointer(name_op)?;\n+        let value_ptr = this.read_pointer(value_op)?;\n+\n+        let mut new = None;\n+        if !this.ptr_is_null(name_ptr)? {\n+            let name = this.read_os_str_from_c_str(name_ptr)?;\n+            if !name.is_empty() && !name.to_string_lossy().contains('=') {\n+                let value = this.read_os_str_from_c_str(value_ptr)?;\n+                new = Some((name.to_owned(), value.to_owned()));\n+            }\n+        }\n+        if let Some((name, value)) = new {\n+            let var_ptr = alloc_env_var_as_c_str(&name, &value, this)?;\n+            if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n+                this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n+            }\n+            this.update_environ()?;\n+            Ok(0) // return zero on success\n+        } else {\n+            // name argument is a null pointer, points to an empty string, or points to a string containing an '=' character.\n+            let einval = this.eval_libc(\"EINVAL\")?;\n+            this.set_last_error(einval)?;\n+            Ok(-1)\n+        }\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn SetEnvironmentVariableW(\n+        &mut self,\n+        name_op: &OpTy<'tcx, Provenance>,  // LPCWSTR\n+        value_op: &OpTy<'tcx, Provenance>, // LPCWSTR\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"SetEnvironmentVariableW\");\n+\n+        let name_ptr = this.read_pointer(name_op)?;\n+        let value_ptr = this.read_pointer(value_op)?;\n+\n+        if this.ptr_is_null(name_ptr)? {\n+            // ERROR CODE is not clearly explained in docs.. For now, throw UB instead.\n+            throw_ub_format!(\"pointer to environment variable name is NULL\");\n+        }\n+\n+        let name = this.read_os_str_from_wide_str(name_ptr)?;\n+        if name.is_empty() {\n+            throw_unsup_format!(\"environment variable name is an empty string\");\n+        } else if name.to_string_lossy().contains('=') {\n+            throw_unsup_format!(\"environment variable name contains '='\");\n+        } else if this.ptr_is_null(value_ptr)? {\n+            // Delete environment variable `{name}`\n+            if let Some(var) = this.machine.env_vars.map.remove(&name) {\n+                this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n+                this.update_environ()?;\n+            }\n+            Ok(1) // return non-zero on success\n+        } else {\n+            let value = this.read_os_str_from_wide_str(value_ptr)?;\n+            let var_ptr = alloc_env_var_as_wide_str(&name, &value, this)?;\n+            if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n+                this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n+            }\n+            this.update_environ()?;\n+            Ok(1) // return non-zero on success\n+        }\n+    }\n+\n+    fn unsetenv(&mut self, name_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os_is_unix(\"unsetenv\");\n+\n+        let name_ptr = this.read_pointer(name_op)?;\n+        let mut success = None;\n+        if !this.ptr_is_null(name_ptr)? {\n+            let name = this.read_os_str_from_c_str(name_ptr)?.to_owned();\n+            if !name.is_empty() && !name.to_string_lossy().contains('=') {\n+                success = Some(this.machine.env_vars.map.remove(&name));\n+            }\n+        }\n+        if let Some(old) = success {\n+            if let Some(var) = old {\n+                this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n+            }\n+            this.update_environ()?;\n+            Ok(0)\n+        } else {\n+            // name argument is a null pointer, points to an empty string, or points to a string containing an '=' character.\n+            let einval = this.eval_libc(\"EINVAL\")?;\n+            this.set_last_error(einval)?;\n+            Ok(-1)\n+        }\n+    }\n+\n+    fn getcwd(\n+        &mut self,\n+        buf_op: &OpTy<'tcx, Provenance>,\n+        size_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os_is_unix(\"getcwd\");\n+\n+        let buf = this.read_pointer(buf_op)?;\n+        let size = this.read_scalar(size_op)?.to_machine_usize(&*this.tcx)?;\n+\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`getcwd`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(Pointer::null());\n+        }\n+\n+        // If we cannot get the current directory, we return null\n+        match env::current_dir() {\n+            Ok(cwd) => {\n+                if this.write_path_to_c_str(&cwd, buf, size)?.0 {\n+                    return Ok(buf);\n+                }\n+                let erange = this.eval_libc(\"ERANGE\")?;\n+                this.set_last_error(erange)?;\n+            }\n+            Err(e) => this.set_last_error_from_io_error(e.kind())?,\n+        }\n+\n+        Ok(Pointer::null())\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn GetCurrentDirectoryW(\n+        &mut self,\n+        size_op: &OpTy<'tcx, Provenance>, // DWORD\n+        buf_op: &OpTy<'tcx, Provenance>,  // LPTSTR\n+    ) -> InterpResult<'tcx, u32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"GetCurrentDirectoryW\");\n+\n+        let size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n+        let buf = this.read_pointer(buf_op)?;\n+\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`GetCurrentDirectoryW`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(0);\n+        }\n+\n+        // If we cannot get the current directory, we return 0\n+        match env::current_dir() {\n+            Ok(cwd) =>\n+                return Ok(windows_check_buffer_size(this.write_path_to_wide_str(&cwd, buf, size)?)),\n+            Err(e) => this.set_last_error_from_io_error(e.kind())?,\n+        }\n+        Ok(0)\n+    }\n+\n+    fn chdir(&mut self, path_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os_is_unix(\"chdir\");\n+\n+        let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n+\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`chdir`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+\n+            return Ok(-1);\n+        }\n+\n+        match env::set_current_dir(path) {\n+            Ok(()) => Ok(0),\n+            Err(e) => {\n+                this.set_last_error_from_io_error(e.kind())?;\n+                Ok(-1)\n+            }\n+        }\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn SetCurrentDirectoryW(\n+        &mut self,\n+        path_op: &OpTy<'tcx, Provenance>, // LPCTSTR\n+    ) -> InterpResult<'tcx, i32> {\n+        // ^ Returns BOOL (i32 on Windows)\n+\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"SetCurrentDirectoryW\");\n+\n+        let path = this.read_path_from_wide_str(this.read_pointer(path_op)?)?;\n+\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`SetCurrentDirectoryW`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+\n+            return Ok(0);\n+        }\n+\n+        match env::set_current_dir(path) {\n+            Ok(()) => Ok(1),\n+            Err(e) => {\n+                this.set_last_error_from_io_error(e.kind())?;\n+                Ok(0)\n+            }\n+        }\n+    }\n+\n+    /// Updates the `environ` static.\n+    /// The first time it gets called, also initializes `extra.environ`.\n+    fn update_environ(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        // Deallocate the old environ list, if any.\n+        if let Some(environ) = this.machine.env_vars.environ {\n+            let old_vars_ptr = this.read_pointer(&environ.into())?;\n+            this.deallocate_ptr(old_vars_ptr, None, MiriMemoryKind::Runtime.into())?;\n+        } else {\n+            // No `environ` allocated yet, let's do that.\n+            // This is memory backing an extern static, hence `ExternStatic`, not `Env`.\n+            let layout = this.machine.layouts.mut_raw_ptr;\n+            let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into())?;\n+            this.machine.env_vars.environ = Some(place);\n+        }\n+\n+        // Collect all the pointers to each variable in a vector.\n+        let mut vars: Vec<Pointer<Option<Provenance>>> =\n+            this.machine.env_vars.map.values().copied().collect();\n+        // Add the trailing null pointer.\n+        vars.push(Pointer::null());\n+        // Make an array with all these pointers inside Miri.\n+        let tcx = this.tcx;\n+        let vars_layout = this.layout_of(\n+            tcx.mk_array(this.machine.layouts.mut_raw_ptr.ty, u64::try_from(vars.len()).unwrap()),\n+        )?;\n+        let vars_place = this.allocate(vars_layout, MiriMemoryKind::Runtime.into())?;\n+        for (idx, var) in vars.into_iter().enumerate() {\n+            let place = this.mplace_field(&vars_place, idx)?;\n+            this.write_pointer(var, &place.into())?;\n+        }\n+        this.write_pointer(vars_place.ptr, &this.machine.env_vars.environ.unwrap().into())?;\n+\n+        Ok(())\n+    }\n+\n+    fn getpid(&mut self) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os_is_unix(\"getpid\");\n+\n+        this.check_no_isolation(\"`getpid`\")?;\n+\n+        // The reason we need to do this wacky of a conversion is because\n+        // `libc::getpid` returns an i32, however, `std::process::id()` return an u32.\n+        // So we un-do the conversion that stdlib does and turn it back into an i32.\n+        #[allow(clippy::cast_possible_wrap)]\n+        Ok(std::process::id() as i32)\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn GetCurrentProcessId(&mut self) -> InterpResult<'tcx, u32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"GetCurrentProcessId\");\n+\n+        this.check_no_isolation(\"`GetCurrentProcessId`\")?;\n+\n+        Ok(std::process::id())\n+    }\n+}"}, {"sha": "0813554e9d24e851a47bba681b9b654a686b2cb6", "filename": "src/tools/miri/src/shims/ffi_support.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,291 @@\n+use libffi::{high::call as ffi, low::CodePtr};\n+use std::ops::Deref;\n+\n+use rustc_middle::ty::{self as ty, IntTy, Ty, UintTy};\n+use rustc_span::Symbol;\n+use rustc_target::abi::HasDataLayout;\n+\n+use crate::*;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Extract the scalar value from the result of reading a scalar from the machine,\n+    /// and convert it to a `CArg`.\n+    fn scalar_to_carg(\n+        k: Scalar<Provenance>,\n+        arg_type: Ty<'tcx>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, CArg> {\n+        match arg_type.kind() {\n+            // If the primitive provided can be converted to a type matching the type pattern\n+            // then create a `CArg` of this primitive value with the corresponding `CArg` constructor.\n+            // the ints\n+            ty::Int(IntTy::I8) => {\n+                return Ok(CArg::Int8(k.to_i8()?));\n+            }\n+            ty::Int(IntTy::I16) => {\n+                return Ok(CArg::Int16(k.to_i16()?));\n+            }\n+            ty::Int(IntTy::I32) => {\n+                return Ok(CArg::Int32(k.to_i32()?));\n+            }\n+            ty::Int(IntTy::I64) => {\n+                return Ok(CArg::Int64(k.to_i64()?));\n+            }\n+            ty::Int(IntTy::Isize) => {\n+                // This will fail if host != target, but then the entire FFI thing probably won't work well\n+                // in that situation.\n+                return Ok(CArg::ISize(k.to_machine_isize(cx)?.try_into().unwrap()));\n+            }\n+            // the uints\n+            ty::Uint(UintTy::U8) => {\n+                return Ok(CArg::UInt8(k.to_u8()?));\n+            }\n+            ty::Uint(UintTy::U16) => {\n+                return Ok(CArg::UInt16(k.to_u16()?));\n+            }\n+            ty::Uint(UintTy::U32) => {\n+                return Ok(CArg::UInt32(k.to_u32()?));\n+            }\n+            ty::Uint(UintTy::U64) => {\n+                return Ok(CArg::UInt64(k.to_u64()?));\n+            }\n+            ty::Uint(UintTy::Usize) => {\n+                // This will fail if host != target, but then the entire FFI thing probably won't work well\n+                // in that situation.\n+                return Ok(CArg::USize(k.to_machine_usize(cx)?.try_into().unwrap()));\n+            }\n+            _ => {}\n+        }\n+        // If no primitives were returned then we have an unsupported type.\n+        throw_unsup_format!(\n+            \"unsupported scalar argument type to external C function: {:?}\",\n+            arg_type\n+        );\n+    }\n+\n+    /// Call external C function and\n+    /// store output, depending on return type in the function signature.\n+    fn call_external_c_and_store_return<'a>(\n+        &mut self,\n+        link_name: Symbol,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ptr: CodePtr,\n+        libffi_args: Vec<libffi::high::Arg<'a>>,\n+    ) -> InterpResult<'tcx, ()> {\n+        let this = self.eval_context_mut();\n+\n+        // Unsafe because of the call to external C code.\n+        // Because this is calling a C function it is not necessarily sound,\n+        // but there is no way around this and we've checked as much as we can.\n+        unsafe {\n+            // If the return type of a function is a primitive integer type,\n+            // then call the function (`ptr`) with arguments `libffi_args`, store the return value as the specified\n+            // primitive integer type, and then write this value out to the miri memory as an integer.\n+            match dest.layout.ty.kind() {\n+                // ints\n+                ty::Int(IntTy::I8) => {\n+                    let x = ffi::call::<i8>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Int(IntTy::I16) => {\n+                    let x = ffi::call::<i16>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Int(IntTy::I32) => {\n+                    let x = ffi::call::<i32>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Int(IntTy::I64) => {\n+                    let x = ffi::call::<i64>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Int(IntTy::Isize) => {\n+                    let x = ffi::call::<isize>(ptr, libffi_args.as_slice());\n+                    // `isize` doesn't `impl Into<i128>`, so convert manually.\n+                    // Convert to `i64` since this covers both 32- and 64-bit machines.\n+                    this.write_int(i64::try_from(x).unwrap(), dest)?;\n+                    return Ok(());\n+                }\n+                // uints\n+                ty::Uint(UintTy::U8) => {\n+                    let x = ffi::call::<u8>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Uint(UintTy::U16) => {\n+                    let x = ffi::call::<u16>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Uint(UintTy::U32) => {\n+                    let x = ffi::call::<u32>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Uint(UintTy::U64) => {\n+                    let x = ffi::call::<u64>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Uint(UintTy::Usize) => {\n+                    let x = ffi::call::<usize>(ptr, libffi_args.as_slice());\n+                    // `usize` doesn't `impl Into<i128>`, so convert manually.\n+                    // Convert to `u64` since this covers both 32- and 64-bit machines.\n+                    this.write_int(u64::try_from(x).unwrap(), dest)?;\n+                    return Ok(());\n+                }\n+                // Functions with no declared return type (i.e., the default return)\n+                // have the output_type `Tuple([])`.\n+                ty::Tuple(t_list) =>\n+                    if t_list.len() == 0 {\n+                        ffi::call::<()>(ptr, libffi_args.as_slice());\n+                        return Ok(());\n+                    },\n+                _ => {}\n+            }\n+            // FIXME ellen! deal with all the other return types\n+            throw_unsup_format!(\"unsupported return type to external C function: {:?}\", link_name);\n+        }\n+    }\n+\n+    /// Get the pointer to the function of the specified name in the shared object file,\n+    /// if it exists. The function must be in the shared object file specified: we do *not*\n+    /// return pointers to functions in dependencies of the library.  \n+    fn get_func_ptr_explicitly_from_lib(&mut self, link_name: Symbol) -> Option<CodePtr> {\n+        let this = self.eval_context_mut();\n+        // Try getting the function from the shared library.\n+        // On windows `_lib_path` will be unused, hence the name starting with `_`.\n+        let (lib, _lib_path) = this.machine.external_so_lib.as_ref().unwrap();\n+        let func: libloading::Symbol<'_, unsafe extern \"C\" fn()> = unsafe {\n+            match lib.get(link_name.as_str().as_bytes()) {\n+                Ok(x) => x,\n+                Err(_) => {\n+                    return None;\n+                }\n+            }\n+        };\n+\n+        // FIXME: this is a hack!\n+        // The `libloading` crate will automatically load system libraries like `libc`.\n+        // On linux `libloading` is based on `dlsym`: https://docs.rs/libloading/0.7.3/src/libloading/os/unix/mod.rs.html#202\n+        // and `dlsym`(https://linux.die.net/man/3/dlsym) looks through the dependency tree of the\n+        // library if it can't find the symbol in the library itself.\n+        // So, in order to check if the function was actually found in the specified\n+        // `machine.external_so_lib` we need to check its `dli_fname` and compare it to\n+        // the specified SO file path.\n+        // This code is a reimplementation of the mechanism for getting `dli_fname` in `libloading`,\n+        // from: https://docs.rs/libloading/0.7.3/src/libloading/os/unix/mod.rs.html#411\n+        // using the `libc` crate where this interface is public.\n+        // No `libc::dladdr` on windows.\n+        #[cfg(unix)]\n+        let mut info = std::mem::MaybeUninit::<libc::Dl_info>::uninit();\n+        #[cfg(unix)]\n+        unsafe {\n+            if libc::dladdr(*func.deref() as *const _, info.as_mut_ptr()) != 0 {\n+                if std::ffi::CStr::from_ptr(info.assume_init().dli_fname).to_str().unwrap()\n+                    != _lib_path.to_str().unwrap()\n+                {\n+                    return None;\n+                }\n+            }\n+        }\n+        // Return a pointer to the function.\n+        Some(CodePtr(*func.deref() as *mut _))\n+    }\n+\n+    /// Call specified external C function, with supplied arguments.\n+    /// Need to convert all the arguments from their hir representations to\n+    /// a form compatible with C (through `libffi` call).\n+    /// Then, convert return from the C call into a corresponding form that\n+    /// can be stored in Miri internal memory.\n+    fn call_external_c_fct(\n+        &mut self,\n+        link_name: Symbol,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        args: &[OpTy<'tcx, Provenance>],\n+    ) -> InterpResult<'tcx, bool> {\n+        // Get the pointer to the function in the shared object file if it exists.\n+        let code_ptr = match self.get_func_ptr_explicitly_from_lib(link_name) {\n+            Some(ptr) => ptr,\n+            None => {\n+                // Shared object file does not export this function -- try the shims next.\n+                return Ok(false);\n+            }\n+        };\n+\n+        let this = self.eval_context_mut();\n+\n+        // Get the function arguments, and convert them to `libffi`-compatible form.\n+        let mut libffi_args = Vec::<CArg>::with_capacity(args.len());\n+        for cur_arg in args.iter() {\n+            libffi_args.push(Self::scalar_to_carg(\n+                this.read_scalar(cur_arg)?,\n+                cur_arg.layout.ty,\n+                this,\n+            )?);\n+        }\n+\n+        // Convert them to `libffi::high::Arg` type.\n+        let libffi_args = libffi_args\n+            .iter()\n+            .map(|cur_arg| cur_arg.arg_downcast())\n+            .collect::<Vec<libffi::high::Arg<'_>>>();\n+\n+        // Call the function and store output, depending on return type in the function signature.\n+        self.call_external_c_and_store_return(link_name, dest, code_ptr, libffi_args)?;\n+        Ok(true)\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+/// Enum of supported arguments to external C functions.\n+// We introduce this enum instead of just calling `ffi::arg` and storing a list\n+// of `libffi::high::Arg` directly, because the `libffi::high::Arg` just wraps a reference\n+// to the value it represents: https://docs.rs/libffi/latest/libffi/high/call/struct.Arg.html\n+// and we need to store a copy of the value, and pass a reference to this copy to C instead.\n+pub enum CArg {\n+    /// 8-bit signed integer.\n+    Int8(i8),\n+    /// 16-bit signed integer.\n+    Int16(i16),\n+    /// 32-bit signed integer.\n+    Int32(i32),\n+    /// 64-bit signed integer.\n+    Int64(i64),\n+    /// isize.\n+    ISize(isize),\n+    /// 8-bit unsigned integer.\n+    UInt8(u8),\n+    /// 16-bit unsigned integer.\n+    UInt16(u16),\n+    /// 32-bit unsigned integer.\n+    UInt32(u32),\n+    /// 64-bit unsigned integer.\n+    UInt64(u64),\n+    /// usize.\n+    USize(usize),\n+}\n+\n+impl<'a> CArg {\n+    /// Convert a `CArg` to a `libffi` argument type.\n+    fn arg_downcast(&'a self) -> libffi::high::Arg<'a> {\n+        match self {\n+            CArg::Int8(i) => ffi::arg(i),\n+            CArg::Int16(i) => ffi::arg(i),\n+            CArg::Int32(i) => ffi::arg(i),\n+            CArg::Int64(i) => ffi::arg(i),\n+            CArg::ISize(i) => ffi::arg(i),\n+            CArg::UInt8(i) => ffi::arg(i),\n+            CArg::UInt16(i) => ffi::arg(i),\n+            CArg::UInt32(i) => ffi::arg(i),\n+            CArg::UInt64(i) => ffi::arg(i),\n+            CArg::USize(i) => ffi::arg(i),\n+        }\n+    }\n+}"}, {"sha": "bb62a2a7ec1b597dddd32ddb299dfda7b22d11db", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "added", "additions": 811, "deletions": 0, "changes": 811, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,811 @@\n+use std::{collections::hash_map::Entry, iter};\n+\n+use log::trace;\n+\n+use rustc_apfloat::Float;\n+use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_hir::{\n+    def::DefKind,\n+    def_id::{CrateNum, DefId, LOCAL_CRATE},\n+};\n+use rustc_middle::middle::{\n+    codegen_fn_attrs::CodegenFnAttrFlags, dependency_format::Linkage,\n+    exported_symbols::ExportedSymbol,\n+};\n+use rustc_middle::mir;\n+use rustc_middle::ty;\n+use rustc_session::config::CrateType;\n+use rustc_span::Symbol;\n+use rustc_target::{\n+    abi::{Align, Size},\n+    spec::abi::Abi,\n+};\n+\n+use super::backtrace::EvalContextExt as _;\n+use crate::helpers::{convert::Truncate, target_os_is_unix};\n+#[cfg(unix)]\n+use crate::shims::ffi_support::EvalContextExt as _;\n+use crate::*;\n+\n+/// Returned by `emulate_foreign_item_by_name`.\n+pub enum EmulateByNameResult<'mir, 'tcx> {\n+    /// The caller is expected to jump to the return block.\n+    NeedsJumping,\n+    /// Jumping has already been taken care of.\n+    AlreadyJumped,\n+    /// A MIR body has been found for the function.\n+    MirBody(&'mir mir::Body<'tcx>, ty::Instance<'tcx>),\n+    /// The item is not supported.\n+    NotSupported,\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Returns the minimum alignment for the target architecture for allocations of the given size.\n+    fn min_align(&self, size: u64, kind: MiriMemoryKind) -> Align {\n+        let this = self.eval_context_ref();\n+        // List taken from `library/std/src/sys/common/alloc.rs`.\n+        // This list should be kept in sync with the one from libstd.\n+        let min_align = match this.tcx.sess.target.arch.as_ref() {\n+            \"x86\" | \"arm\" | \"mips\" | \"powerpc\" | \"powerpc64\" | \"asmjs\" | \"wasm32\" => 8,\n+            \"x86_64\" | \"aarch64\" | \"mips64\" | \"s390x\" | \"sparc64\" => 16,\n+            arch => bug!(\"Unsupported target architecture: {}\", arch),\n+        };\n+        // Windows always aligns, even small allocations.\n+        // Source: <https://support.microsoft.com/en-us/help/286470/how-to-use-pageheap-exe-in-windows-xp-windows-2000-and-windows-server>\n+        // But jemalloc does not, so for the C heap we only align if the allocation is sufficiently big.\n+        if kind == MiriMemoryKind::WinHeap || size >= min_align {\n+            return Align::from_bytes(min_align).unwrap();\n+        }\n+        // We have `size < min_align`. Round `size` *down* to the next power of two and use that.\n+        fn prev_power_of_two(x: u64) -> u64 {\n+            let next_pow2 = x.next_power_of_two();\n+            if next_pow2 == x {\n+                // x *is* a power of two, just use that.\n+                x\n+            } else {\n+                // x is between two powers, so next = 2*prev.\n+                next_pow2 / 2\n+            }\n+        }\n+        Align::from_bytes(prev_power_of_two(size)).unwrap()\n+    }\n+\n+    fn malloc(\n+        &mut self,\n+        size: u64,\n+        zero_init: bool,\n+        kind: MiriMemoryKind,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let this = self.eval_context_mut();\n+        if size == 0 {\n+            Ok(Pointer::null())\n+        } else {\n+            let align = this.min_align(size, kind);\n+            let ptr = this.allocate_ptr(Size::from_bytes(size), align, kind.into())?;\n+            if zero_init {\n+                // We just allocated this, the access is definitely in-bounds and fits into our address space.\n+                this.write_bytes_ptr(\n+                    ptr.into(),\n+                    iter::repeat(0u8).take(usize::try_from(size).unwrap()),\n+                )\n+                .unwrap();\n+            }\n+            Ok(ptr.into())\n+        }\n+    }\n+\n+    fn free(\n+        &mut self,\n+        ptr: Pointer<Option<Provenance>>,\n+        kind: MiriMemoryKind,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        if !this.ptr_is_null(ptr)? {\n+            this.deallocate_ptr(ptr, None, kind.into())?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn realloc(\n+        &mut self,\n+        old_ptr: Pointer<Option<Provenance>>,\n+        new_size: u64,\n+        kind: MiriMemoryKind,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let this = self.eval_context_mut();\n+        let new_align = this.min_align(new_size, kind);\n+        if this.ptr_is_null(old_ptr)? {\n+            if new_size == 0 {\n+                Ok(Pointer::null())\n+            } else {\n+                let new_ptr =\n+                    this.allocate_ptr(Size::from_bytes(new_size), new_align, kind.into())?;\n+                Ok(new_ptr.into())\n+            }\n+        } else {\n+            if new_size == 0 {\n+                this.deallocate_ptr(old_ptr, None, kind.into())?;\n+                Ok(Pointer::null())\n+            } else {\n+                let new_ptr = this.reallocate_ptr(\n+                    old_ptr,\n+                    None,\n+                    Size::from_bytes(new_size),\n+                    new_align,\n+                    kind.into(),\n+                )?;\n+                Ok(new_ptr.into())\n+            }\n+        }\n+    }\n+\n+    /// Lookup the body of a function that has `link_name` as the symbol name.\n+    fn lookup_exported_symbol(\n+        &mut self,\n+        link_name: Symbol,\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n+        let this = self.eval_context_mut();\n+        let tcx = this.tcx.tcx;\n+\n+        // If the result was cached, just return it.\n+        // (Cannot use `or_insert` since the code below might have to throw an error.)\n+        let entry = this.machine.exported_symbols_cache.entry(link_name);\n+        let instance = *match entry {\n+            Entry::Occupied(e) => e.into_mut(),\n+            Entry::Vacant(e) => {\n+                // Find it if it was not cached.\n+                let mut instance_and_crate: Option<(ty::Instance<'_>, CrateNum)> = None;\n+                // `dependency_formats` includes all the transitive informations needed to link a crate,\n+                // which is what we need here since we need to dig out `exported_symbols` from all transitive\n+                // dependencies.\n+                let dependency_formats = tcx.dependency_formats(());\n+                let dependency_format = dependency_formats\n+                    .iter()\n+                    .find(|(crate_type, _)| *crate_type == CrateType::Executable)\n+                    .expect(\"interpreting a non-executable crate\");\n+                for cnum in iter::once(LOCAL_CRATE).chain(\n+                    dependency_format.1.iter().enumerate().filter_map(|(num, &linkage)| {\n+                        // We add 1 to the number because that's what rustc also does everywhere it\n+                        // calls `CrateNum::new`...\n+                        #[allow(clippy::integer_arithmetic)]\n+                        (linkage != Linkage::NotLinked).then_some(CrateNum::new(num + 1))\n+                    }),\n+                ) {\n+                    // We can ignore `_export_info` here: we are a Rust crate, and everything is exported\n+                    // from a Rust crate.\n+                    for &(symbol, _export_info) in tcx.exported_symbols(cnum) {\n+                        if let ExportedSymbol::NonGeneric(def_id) = symbol {\n+                            let attrs = tcx.codegen_fn_attrs(def_id);\n+                            let symbol_name = if let Some(export_name) = attrs.export_name {\n+                                export_name\n+                            } else if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n+                                tcx.item_name(def_id)\n+                            } else {\n+                                // Skip over items without an explicitly defined symbol name.\n+                                continue;\n+                            };\n+                            if symbol_name == link_name {\n+                                if let Some((original_instance, original_cnum)) = instance_and_crate\n+                                {\n+                                    // Make sure we are consistent wrt what is 'first' and 'second'.\n+                                    let original_span =\n+                                        tcx.def_span(original_instance.def_id()).data();\n+                                    let span = tcx.def_span(def_id).data();\n+                                    if original_span < span {\n+                                        throw_machine_stop!(\n+                                            TerminationInfo::MultipleSymbolDefinitions {\n+                                                link_name,\n+                                                first: original_span,\n+                                                first_crate: tcx.crate_name(original_cnum),\n+                                                second: span,\n+                                                second_crate: tcx.crate_name(cnum),\n+                                            }\n+                                        );\n+                                    } else {\n+                                        throw_machine_stop!(\n+                                            TerminationInfo::MultipleSymbolDefinitions {\n+                                                link_name,\n+                                                first: span,\n+                                                first_crate: tcx.crate_name(cnum),\n+                                                second: original_span,\n+                                                second_crate: tcx.crate_name(original_cnum),\n+                                            }\n+                                        );\n+                                    }\n+                                }\n+                                if !matches!(tcx.def_kind(def_id), DefKind::Fn | DefKind::AssocFn) {\n+                                    throw_ub_format!(\n+                                        \"attempt to call an exported symbol that is not defined as a function\"\n+                                    );\n+                                }\n+                                instance_and_crate = Some((ty::Instance::mono(tcx, def_id), cnum));\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                e.insert(instance_and_crate.map(|ic| ic.0))\n+            }\n+        };\n+        match instance {\n+            None => Ok(None), // no symbol with this name\n+            Some(instance) => Ok(Some((this.load_mir(instance.def, None)?, instance))),\n+        }\n+    }\n+\n+    /// Emulates calling a foreign item, failing if the item is not supported.\n+    /// This function will handle `goto_block` if needed.\n+    /// Returns Ok(None) if the foreign item was completely handled\n+    /// by this function.\n+    /// Returns Ok(Some(body)) if processing the foreign item\n+    /// is delegated to another function.\n+    fn emulate_foreign_item(\n+        &mut self,\n+        def_id: DefId,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+        unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n+        let this = self.eval_context_mut();\n+        let link_name = this.item_link_name(def_id);\n+        let tcx = this.tcx.tcx;\n+\n+        // First: functions that diverge.\n+        let ret = match ret {\n+            None =>\n+                match link_name.as_str() {\n+                    \"miri_start_panic\" => {\n+                        // `check_shim` happens inside `handle_miri_start_panic`.\n+                        this.handle_miri_start_panic(abi, link_name, args, unwind)?;\n+                        return Ok(None);\n+                    }\n+                    // This matches calls to the foreign item `panic_impl`.\n+                    // The implementation is provided by the function with the `#[panic_handler]` attribute.\n+                    \"panic_impl\" => {\n+                        // We don't use `check_shim` here because we are just forwarding to the lang\n+                        // item. Argument count checking will be performed when the returned `Body` is\n+                        // called.\n+                        this.check_abi_and_shim_symbol_clash(abi, Abi::Rust, link_name)?;\n+                        let panic_impl_id = tcx.lang_items().panic_impl().unwrap();\n+                        let panic_impl_instance = ty::Instance::mono(tcx, panic_impl_id);\n+                        return Ok(Some((\n+                            this.load_mir(panic_impl_instance.def, None)?,\n+                            panic_impl_instance,\n+                        )));\n+                    }\n+                    #[rustfmt::skip]\n+                    | \"exit\"\n+                    | \"ExitProcess\"\n+                    => {\n+                        let exp_abi = if link_name.as_str() == \"exit\" {\n+                            Abi::C { unwind: false }\n+                        } else {\n+                            Abi::System { unwind: false }\n+                        };\n+                        let [code] = this.check_shim(abi, exp_abi, link_name, args)?;\n+                        // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n+                        let code = this.read_scalar(code)?.to_i32()?;\n+                        throw_machine_stop!(TerminationInfo::Exit(code.into()));\n+                    }\n+                    \"abort\" => {\n+                        let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                        throw_machine_stop!(TerminationInfo::Abort(\n+                            \"the program aborted execution\".to_owned()\n+                        ))\n+                    }\n+                    _ => {\n+                        if let Some(body) = this.lookup_exported_symbol(link_name)? {\n+                            return Ok(Some(body));\n+                        }\n+                        this.handle_unsupported(format!(\n+                            \"can't call (diverging) foreign function: {}\",\n+                            link_name\n+                        ))?;\n+                        return Ok(None);\n+                    }\n+                },\n+            Some(p) => p,\n+        };\n+\n+        // Second: functions that return immediately.\n+        match this.emulate_foreign_item_by_name(link_name, abi, args, dest)? {\n+            EmulateByNameResult::NeedsJumping => {\n+                trace!(\"{:?}\", this.dump_place(**dest));\n+                this.go_to_block(ret);\n+            }\n+            EmulateByNameResult::AlreadyJumped => (),\n+            EmulateByNameResult::MirBody(mir, instance) => return Ok(Some((mir, instance))),\n+            EmulateByNameResult::NotSupported => {\n+                if let Some(body) = this.lookup_exported_symbol(link_name)? {\n+                    return Ok(Some(body));\n+                }\n+\n+                this.handle_unsupported(format!(\"can't call foreign function: {}\", link_name))?;\n+                return Ok(None);\n+            }\n+        }\n+\n+        Ok(None)\n+    }\n+\n+    /// Emulates calling the internal __rust_* allocator functions\n+    fn emulate_allocator(\n+        &mut self,\n+        symbol: Symbol,\n+        default: impl FnOnce(&mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n+        let this = self.eval_context_mut();\n+\n+        let allocator_kind = if let Some(allocator_kind) = this.tcx.allocator_kind(()) {\n+            allocator_kind\n+        } else {\n+            // in real code, this symbol does not exist without an allocator\n+            return Ok(EmulateByNameResult::NotSupported);\n+        };\n+\n+        match allocator_kind {\n+            AllocatorKind::Global => {\n+                let (body, instance) = this\n+                    .lookup_exported_symbol(symbol)?\n+                    .expect(\"symbol should be present if there is a global allocator\");\n+\n+                Ok(EmulateByNameResult::MirBody(body, instance))\n+            }\n+            AllocatorKind::Default => {\n+                default(this)?;\n+                Ok(EmulateByNameResult::NeedsJumping)\n+            }\n+        }\n+    }\n+\n+    /// Emulates calling a foreign item using its name.\n+    fn emulate_foreign_item_by_name(\n+        &mut self,\n+        link_name: Symbol,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n+        let this = self.eval_context_mut();\n+\n+        // First deal with any external C functions in linked .so file.\n+        #[cfg(unix)]\n+        if this.machine.external_so_lib.as_ref().is_some() {\n+            // An Ok(false) here means that the function being called was not exported\n+            // by the specified `.so` file; we should continue and check if it corresponds to\n+            // a provided shim.\n+            if this.call_external_c_fct(link_name, dest, args)? {\n+                return Ok(EmulateByNameResult::NeedsJumping);\n+            }\n+        }\n+\n+        // When adding a new shim, you should follow the following pattern:\n+        // ```\n+        // \"shim_name\" => {\n+        //     let [arg1, arg2, arg3] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+        //     let result = this.shim_name(arg1, arg2, arg3)?;\n+        //     this.write_scalar(result, dest)?;\n+        // }\n+        // ```\n+        // and then define `shim_name` as a helper function in an extension trait in a suitable file\n+        // (see e.g. `unix/fs.rs`):\n+        // ```\n+        // fn shim_name(\n+        //     &mut self,\n+        //     arg1: &OpTy<'tcx, Provenance>,\n+        //     arg2: &OpTy<'tcx, Provenance>,\n+        //     arg3: &OpTy<'tcx, Provenance>)\n+        // -> InterpResult<'tcx, Scalar<Provenance>> {\n+        //     let this = self.eval_context_mut();\n+        //\n+        //     // First thing: load all the arguments. Details depend on the shim.\n+        //     let arg1 = this.read_scalar(arg1)?.to_u32()?;\n+        //     let arg2 = this.read_pointer(arg2)?; // when you need to work with the pointer directly\n+        //     let arg3 = this.deref_operand(arg3)?; // when you want to load/store through the pointer at its declared type\n+        //\n+        //     // ...\n+        //\n+        //     Ok(Scalar::from_u32(42))\n+        // }\n+        // ```\n+        // You might find existing shims not following this pattern, most\n+        // likely because they predate it or because for some reason they cannot be made to fit.\n+\n+        // Here we dispatch all the shims for foreign functions. If you have a platform specific\n+        // shim, add it to the corresponding submodule.\n+        match link_name.as_str() {\n+            // Miri-specific extern functions\n+            \"miri_static_root\" => {\n+                let [ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let (alloc_id, offset, _) = this.ptr_get_alloc_id(ptr)?;\n+                if offset != Size::ZERO {\n+                    throw_unsup_format!(\"pointer passed to miri_static_root must point to beginning of an allocated block\");\n+                }\n+                this.machine.static_roots.push(alloc_id);\n+            }\n+\n+            // Obtains the size of a Miri backtrace. See the README for details.\n+            \"miri_backtrace_size\" => {\n+                this.handle_miri_backtrace_size(abi, link_name, args, dest)?;\n+            }\n+\n+            // Obtains a Miri backtrace. See the README for details.\n+            \"miri_get_backtrace\" => {\n+                // `check_shim` happens inside `handle_miri_get_backtrace`.\n+                this.handle_miri_get_backtrace(abi, link_name, args, dest)?;\n+            }\n+\n+            // Resolves a Miri backtrace frame. See the README for details.\n+            \"miri_resolve_frame\" => {\n+                // `check_shim` happens inside `handle_miri_resolve_frame`.\n+                this.handle_miri_resolve_frame(abi, link_name, args, dest)?;\n+            }\n+\n+            // Writes the function and file names of a Miri backtrace frame into a user provided buffer. See the README for details.\n+            \"miri_resolve_frame_names\" => {\n+                this.handle_miri_resolve_frame_names(abi, link_name, args)?;\n+            }\n+\n+            // Standard C allocation\n+            \"malloc\" => {\n+                let [size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n+                let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C)?;\n+                this.write_pointer(res, dest)?;\n+            }\n+            \"calloc\" => {\n+                let [items, len] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let items = this.read_scalar(items)?.to_machine_usize(this)?;\n+                let len = this.read_scalar(len)?.to_machine_usize(this)?;\n+                let size =\n+                    items.checked_mul(len).ok_or_else(|| err_ub_format!(\"overflow during calloc size computation\"))?;\n+                let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C)?;\n+                this.write_pointer(res, dest)?;\n+            }\n+            \"free\" => {\n+                let [ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                this.free(ptr, MiriMemoryKind::C)?;\n+            }\n+            \"realloc\" => {\n+                let [old_ptr, new_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let old_ptr = this.read_pointer(old_ptr)?;\n+                let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n+                let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n+                this.write_pointer(res, dest)?;\n+            }\n+\n+            // Rust allocation\n+            \"__rust_alloc\" => {\n+                let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n+\n+                return this.emulate_allocator(Symbol::intern(\"__rg_alloc\"), |this| {\n+                    Self::check_alloc_request(size, align)?;\n+\n+                    let ptr = this.allocate_ptr(\n+                        Size::from_bytes(size),\n+                        Align::from_bytes(align).unwrap(),\n+                        MiriMemoryKind::Rust.into(),\n+                    )?;\n+\n+                    this.write_pointer(ptr, dest)\n+                });\n+            }\n+            \"__rust_alloc_zeroed\" => {\n+                let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n+\n+                return this.emulate_allocator(Symbol::intern(\"__rg_alloc_zeroed\"), |this| {\n+                    Self::check_alloc_request(size, align)?;\n+\n+                    let ptr = this.allocate_ptr(\n+                        Size::from_bytes(size),\n+                        Align::from_bytes(align).unwrap(),\n+                        MiriMemoryKind::Rust.into(),\n+                    )?;\n+\n+                    // We just allocated this, the access is definitely in-bounds.\n+                    this.write_bytes_ptr(ptr.into(), iter::repeat(0u8).take(usize::try_from(size).unwrap())).unwrap();\n+                    this.write_pointer(ptr, dest)\n+                });\n+            }\n+            \"__rust_dealloc\" => {\n+                let [ptr, old_size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n+\n+                return this.emulate_allocator(Symbol::intern(\"__rg_dealloc\"), |this| {\n+                    // No need to check old_size/align; we anyway check that they match the allocation.\n+                    this.deallocate_ptr(\n+                        ptr,\n+                        Some((Size::from_bytes(old_size), Align::from_bytes(align).unwrap())),\n+                        MiriMemoryKind::Rust.into(),\n+                    )\n+                });\n+            }\n+            \"__rust_realloc\" => {\n+                let [ptr, old_size, align, new_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n+                let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n+                // No need to check old_size; we anyway check that they match the allocation.\n+\n+                return this.emulate_allocator(Symbol::intern(\"__rg_realloc\"), |this| {\n+                    Self::check_alloc_request(new_size, align)?;\n+\n+                    let align = Align::from_bytes(align).unwrap();\n+                    let new_ptr = this.reallocate_ptr(\n+                        ptr,\n+                        Some((Size::from_bytes(old_size), align)),\n+                        Size::from_bytes(new_size),\n+                        align,\n+                        MiriMemoryKind::Rust.into(),\n+                    )?;\n+                    this.write_pointer(new_ptr, dest)\n+                });\n+            }\n+\n+            // C memory handling functions\n+            \"memcmp\" => {\n+                let [left, right, n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let left = this.read_pointer(left)?;\n+                let right = this.read_pointer(right)?;\n+                let n = Size::from_bytes(this.read_scalar(n)?.to_machine_usize(this)?);\n+\n+                let result = {\n+                    let left_bytes = this.read_bytes_ptr_strip_provenance(left, n)?;\n+                    let right_bytes = this.read_bytes_ptr_strip_provenance(right, n)?;\n+\n+                    use std::cmp::Ordering::*;\n+                    match left_bytes.cmp(right_bytes) {\n+                        Less => -1i32,\n+                        Equal => 0,\n+                        Greater => 1,\n+                    }\n+                };\n+\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"memrchr\" => {\n+                let [ptr, val, num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let val = this.read_scalar(val)?.to_i32()?;\n+                let num = this.read_scalar(num)?.to_machine_usize(this)?;\n+                // The docs say val is \"interpreted as unsigned char\".\n+                #[allow(clippy::cast_sign_loss, clippy::cast_possible_truncation)]\n+                let val = val as u8;\n+\n+                if let Some(idx) = this\n+                    .read_bytes_ptr_strip_provenance(ptr, Size::from_bytes(num))?\n+                    .iter()\n+                    .rev()\n+                    .position(|&c| c == val)\n+                {\n+                    let idx = u64::try_from(idx).unwrap();\n+                    #[allow(clippy::integer_arithmetic)] // idx < num, so this never wraps\n+                    let new_ptr = ptr.offset(Size::from_bytes(num - idx - 1), this)?;\n+                    this.write_pointer(new_ptr, dest)?;\n+                } else {\n+                    this.write_null(dest)?;\n+                }\n+            }\n+            \"memchr\" => {\n+                let [ptr, val, num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let val = this.read_scalar(val)?.to_i32()?;\n+                let num = this.read_scalar(num)?.to_machine_usize(this)?;\n+                // The docs say val is \"interpreted as unsigned char\".\n+                #[allow(clippy::cast_sign_loss, clippy::cast_possible_truncation)]\n+                let val = val as u8;\n+\n+                let idx = this\n+                    .read_bytes_ptr_strip_provenance(ptr, Size::from_bytes(num))?\n+                    .iter()\n+                    .position(|&c| c == val);\n+                if let Some(idx) = idx {\n+                    let new_ptr = ptr.offset(Size::from_bytes(idx as u64), this)?;\n+                    this.write_pointer(new_ptr, dest)?;\n+                } else {\n+                    this.write_null(dest)?;\n+                }\n+            }\n+            \"strlen\" => {\n+                let [ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let n = this.read_c_str(ptr)?.len();\n+                this.write_scalar(Scalar::from_machine_usize(u64::try_from(n).unwrap(), this), dest)?;\n+            }\n+\n+            // math functions (note that there are also intrinsics for some other functions)\n+            #[rustfmt::skip]\n+            | \"cbrtf\"\n+            | \"coshf\"\n+            | \"sinhf\"\n+            | \"tanf\"\n+            | \"tanhf\"\n+            | \"acosf\"\n+            | \"asinf\"\n+            | \"atanf\"\n+            | \"log1pf\"\n+            | \"expm1f\"\n+            => {\n+                let [f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                // FIXME: Using host floats.\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let res = match link_name.as_str() {\n+                    \"cbrtf\" => f.cbrt(),\n+                    \"coshf\" => f.cosh(),\n+                    \"sinhf\" => f.sinh(),\n+                    \"tanf\" => f.tan(),\n+                    \"tanhf\" => f.tanh(),\n+                    \"acosf\" => f.acos(),\n+                    \"asinf\" => f.asin(),\n+                    \"atanf\" => f.atan(),\n+                    \"log1pf\" => f.ln_1p(),\n+                    \"expm1f\" => f.exp_m1(),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"_hypotf\"\n+            | \"hypotf\"\n+            | \"atan2f\"\n+            | \"fdimf\"\n+            => {\n+                let [f1, f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                // underscore case for windows, here and below\n+                // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n+                // FIXME: Using host floats.\n+                let f1 = f32::from_bits(this.read_scalar(f1)?.to_u32()?);\n+                let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n+                let res = match link_name.as_str() {\n+                    \"_hypotf\" | \"hypotf\" => f1.hypot(f2),\n+                    \"atan2f\" => f1.atan2(f2),\n+                    #[allow(deprecated)]\n+                    \"fdimf\" => f1.abs_sub(f2),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"cbrt\"\n+            | \"cosh\"\n+            | \"sinh\"\n+            | \"tan\"\n+            | \"tanh\"\n+            | \"acos\"\n+            | \"asin\"\n+            | \"atan\"\n+            | \"log1p\"\n+            | \"expm1\"\n+            => {\n+                let [f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                // FIXME: Using host floats.\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let res = match link_name.as_str() {\n+                    \"cbrt\" => f.cbrt(),\n+                    \"cosh\" => f.cosh(),\n+                    \"sinh\" => f.sinh(),\n+                    \"tan\" => f.tan(),\n+                    \"tanh\" => f.tanh(),\n+                    \"acos\" => f.acos(),\n+                    \"asin\" => f.asin(),\n+                    \"atan\" => f.atan(),\n+                    \"log1p\" => f.ln_1p(),\n+                    \"expm1\" => f.exp_m1(),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"_hypot\"\n+            | \"hypot\"\n+            | \"atan2\"\n+            | \"fdim\"\n+            => {\n+                let [f1, f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                // FIXME: Using host floats.\n+                let f1 = f64::from_bits(this.read_scalar(f1)?.to_u64()?);\n+                let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n+                let res = match link_name.as_str() {\n+                    \"_hypot\" | \"hypot\" => f1.hypot(f2),\n+                    \"atan2\" => f1.atan2(f2),\n+                    #[allow(deprecated)]\n+                    \"fdim\" => f1.abs_sub(f2),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"_ldexp\"\n+            | \"ldexp\"\n+            | \"scalbn\"\n+            => {\n+                let [x, exp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n+                let x = this.read_scalar(x)?.to_f64()?;\n+                let exp = this.read_scalar(exp)?.to_i32()?;\n+\n+                // Saturating cast to i16. Even those are outside the valid exponent range so\n+                // `scalbn` below will do its over/underflow handling.\n+                let exp = if exp > i32::from(i16::MAX) {\n+                    i16::MAX\n+                } else if exp < i32::from(i16::MIN) {\n+                    i16::MIN\n+                } else {\n+                    exp.try_into().unwrap()\n+                };\n+\n+                let res = x.scalbn(exp);\n+                this.write_scalar(Scalar::from_f64(res), dest)?;\n+            }\n+\n+            // Architecture-specific shims\n+            \"llvm.x86.addcarry.64\" if this.tcx.sess.target.arch == \"x86_64\" => {\n+                // Computes u8+u64+u64, returning tuple (u8,u64) comprising the output carry and truncated sum.\n+                let [c_in, a, b] = this.check_shim(abi, Abi::Unadjusted, link_name, args)?;\n+                let c_in = this.read_scalar(c_in)?.to_u8()?;\n+                let a = this.read_scalar(a)?.to_u64()?;\n+                let b = this.read_scalar(b)?.to_u64()?;\n+\n+                #[allow(clippy::integer_arithmetic)] // adding two u64 and a u8 cannot wrap in a u128\n+                let wide_sum = u128::from(c_in) + u128::from(a) + u128::from(b);\n+                #[allow(clippy::integer_arithmetic)] // it's a u128, we can shift by 64\n+                let (c_out, sum) = ((wide_sum >> 64).truncate::<u8>(), wide_sum.truncate::<u64>());\n+\n+                let c_out_field = this.place_field(dest, 0)?;\n+                this.write_scalar(Scalar::from_u8(c_out), &c_out_field)?;\n+                let sum_field = this.place_field(dest, 1)?;\n+                this.write_scalar(Scalar::from_u64(sum), &sum_field)?;\n+            }\n+            \"llvm.x86.sse2.pause\" if this.tcx.sess.target.arch == \"x86\" || this.tcx.sess.target.arch == \"x86_64\" => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.yield_active_thread();\n+            }\n+            \"llvm.aarch64.isb\" if this.tcx.sess.target.arch == \"aarch64\" => {\n+                let [arg] = this.check_shim(abi, Abi::Unadjusted, link_name, args)?;\n+                let arg = this.read_scalar(arg)?.to_i32()?;\n+                match arg {\n+                    15 => { // SY (\"full system scope\")\n+                        this.yield_active_thread();\n+                    }\n+                    _ => {\n+                        throw_unsup_format!(\"unsupported llvm.aarch64.isb argument {}\", arg);\n+                    }\n+                }\n+            }\n+\n+            // Platform-specific shims\n+            _ => match this.tcx.sess.target.os.as_ref() {\n+                target if target_os_is_unix(target) => return shims::unix::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                \"windows\" => return shims::windows::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                target => throw_unsup_format!(\"the target `{}` is not supported\", target),\n+            }\n+        };\n+        // We only fall through to here if we did *not* hit the `_` arm above,\n+        // i.e., if we actually emulated the function with one of the shims.\n+        Ok(EmulateByNameResult::NeedsJumping)\n+    }\n+\n+    /// Check some basic requirements for this allocation request:\n+    /// non-zero size, power-of-two alignment.\n+    fn check_alloc_request(size: u64, align: u64) -> InterpResult<'tcx> {\n+        if size == 0 {\n+            throw_ub_format!(\"creating allocation with size 0\");\n+        }\n+        if !align.is_power_of_two() {\n+            throw_ub_format!(\"creating allocation with non-power-of-two alignment {}\", align);\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "50f69bdca363197f4517bdf48742bc48fab025ac", "filename": "src/tools/miri/src/shims/intrinsics/atomic.rs", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fatomic.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,288 @@\n+use rustc_middle::{mir, mir::BinOp, ty};\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+\n+pub enum AtomicOp {\n+    /// The `bool` indicates whether the result of the operation should be negated\n+    /// (must be a boolean-typed operation).\n+    MirOp(mir::BinOp, bool),\n+    Max,\n+    Min,\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Calls the atomic intrinsic `intrinsic`; the `atomic_` prefix has already been removed.\n+    fn emulate_atomic_intrinsic(\n+        &mut self,\n+        intrinsic_name: &str,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let intrinsic_structure: Vec<_> = intrinsic_name.split('_').collect();\n+\n+        fn read_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicReadOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicReadOrd::SeqCst,\n+                \"acquire\" => AtomicReadOrd::Acquire,\n+                \"relaxed\" => AtomicReadOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported read ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn write_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicWriteOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicWriteOrd::SeqCst,\n+                \"release\" => AtomicWriteOrd::Release,\n+                \"relaxed\" => AtomicWriteOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported write ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn rw_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicRwOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicRwOrd::SeqCst,\n+                \"acqrel\" => AtomicRwOrd::AcqRel,\n+                \"acquire\" => AtomicRwOrd::Acquire,\n+                \"release\" => AtomicRwOrd::Release,\n+                \"relaxed\" => AtomicRwOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported read-write ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn fence_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicFenceOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicFenceOrd::SeqCst,\n+                \"acqrel\" => AtomicFenceOrd::AcqRel,\n+                \"acquire\" => AtomicFenceOrd::Acquire,\n+                \"release\" => AtomicFenceOrd::Release,\n+                _ => throw_unsup_format!(\"unsupported fence ordering `{ord}`\"),\n+            })\n+        }\n+\n+        match &*intrinsic_structure {\n+            [\"load\", ord] => this.atomic_load(args, dest, read_ord(ord)?)?,\n+            [\"store\", ord] => this.atomic_store(args, write_ord(ord)?)?,\n+\n+            [\"fence\", ord] => this.atomic_fence_intrinsic(args, fence_ord(ord)?)?,\n+            [\"singlethreadfence\", ord] => this.compiler_fence_intrinsic(args, fence_ord(ord)?)?,\n+\n+            [\"xchg\", ord] => this.atomic_exchange(args, dest, rw_ord(ord)?)?,\n+            [\"cxchg\", ord1, ord2] =>\n+                this.atomic_compare_exchange(args, dest, rw_ord(ord1)?, read_ord(ord2)?)?,\n+            [\"cxchgweak\", ord1, ord2] =>\n+                this.atomic_compare_exchange_weak(args, dest, rw_ord(ord1)?, read_ord(ord2)?)?,\n+\n+            [\"or\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), rw_ord(ord)?)?,\n+            [\"xor\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), rw_ord(ord)?)?,\n+            [\"and\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), rw_ord(ord)?)?,\n+            [\"nand\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), rw_ord(ord)?)?,\n+            [\"xadd\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), rw_ord(ord)?)?,\n+            [\"xsub\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), rw_ord(ord)?)?,\n+            [\"min\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Int(_)));\n+                this.atomic_op(args, dest, AtomicOp::Min, rw_ord(ord)?)?;\n+            }\n+            [\"umin\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Uint(_)));\n+                this.atomic_op(args, dest, AtomicOp::Min, rw_ord(ord)?)?;\n+            }\n+            [\"max\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Int(_)));\n+                this.atomic_op(args, dest, AtomicOp::Max, rw_ord(ord)?)?;\n+            }\n+            [\"umax\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Uint(_)));\n+                this.atomic_op(args, dest, AtomicOp::Max, rw_ord(ord)?)?;\n+            }\n+\n+            _ => throw_unsup_format!(\"unimplemented intrinsic: `atomic_{intrinsic_name}`\"),\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n+    fn atomic_load(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        atomic: AtomicReadOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+\n+        // Perform atomic load.\n+        let val = this.read_scalar_atomic(&place, atomic)?;\n+        // Perform regular store.\n+        this.write_scalar(val, dest)?;\n+        Ok(())\n+    }\n+\n+    fn atomic_store(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        atomic: AtomicWriteOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place, val] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+\n+        // Perform regular load.\n+        let val = this.read_scalar(val)?;\n+        // Perform atomic store\n+        this.write_scalar_atomic(val, &place, atomic)?;\n+        Ok(())\n+    }\n+\n+    fn compiler_fence_intrinsic(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        atomic: AtomicFenceOrd,\n+    ) -> InterpResult<'tcx> {\n+        let [] = check_arg_count(args)?;\n+        let _ = atomic;\n+        //FIXME: compiler fences are currently ignored\n+        Ok(())\n+    }\n+\n+    fn atomic_fence_intrinsic(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        atomic: AtomicFenceOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let [] = check_arg_count(args)?;\n+        this.atomic_fence(atomic)?;\n+        Ok(())\n+    }\n+\n+    fn atomic_op(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        atomic_op: AtomicOp,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place, rhs] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+        let rhs = this.read_immediate(rhs)?;\n+\n+        if !place.layout.ty.is_integral() && !place.layout.ty.is_unsafe_ptr() {\n+            span_bug!(\n+                this.cur_span(),\n+                \"atomic arithmetic operations only work on integer and raw pointer types\",\n+            );\n+        }\n+        if rhs.layout.ty != place.layout.ty {\n+            span_bug!(this.cur_span(), \"atomic arithmetic operation type mismatch\");\n+        }\n+\n+        match atomic_op {\n+            AtomicOp::Min => {\n+                let old = this.atomic_min_max_scalar(&place, rhs, true, atomic)?;\n+                this.write_immediate(*old, dest)?; // old value is returned\n+                Ok(())\n+            }\n+            AtomicOp::Max => {\n+                let old = this.atomic_min_max_scalar(&place, rhs, false, atomic)?;\n+                this.write_immediate(*old, dest)?; // old value is returned\n+                Ok(())\n+            }\n+            AtomicOp::MirOp(op, neg) => {\n+                let old = this.atomic_op_immediate(&place, &rhs, op, neg, atomic)?;\n+                this.write_immediate(*old, dest)?; // old value is returned\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn atomic_exchange(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place, new] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+        let new = this.read_scalar(new)?;\n+\n+        let old = this.atomic_exchange_scalar(&place, new, atomic)?;\n+        this.write_scalar(old, dest)?; // old value is returned\n+        Ok(())\n+    }\n+\n+    fn atomic_compare_exchange_impl(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n+        can_fail_spuriously: bool,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let [place, expect_old, new] = check_arg_count(args)?;\n+        let place = this.deref_operand(place)?;\n+        let expect_old = this.read_immediate(expect_old)?; // read as immediate for the sake of `binary_op()`\n+        let new = this.read_scalar(new)?;\n+\n+        let old = this.atomic_compare_exchange_scalar(\n+            &place,\n+            &expect_old,\n+            new,\n+            success,\n+            fail,\n+            can_fail_spuriously,\n+        )?;\n+\n+        // Return old value.\n+        this.write_immediate(old, dest)?;\n+        Ok(())\n+    }\n+\n+    fn atomic_compare_exchange(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n+    ) -> InterpResult<'tcx> {\n+        self.atomic_compare_exchange_impl(args, dest, success, fail, false)\n+    }\n+\n+    fn atomic_compare_exchange_weak(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n+    ) -> InterpResult<'tcx> {\n+        self.atomic_compare_exchange_impl(args, dest, success, fail, true)\n+    }\n+}"}, {"sha": "e0985ace5be7da3d8c2f0c3c3f0933013845cc76", "filename": "src/tools/miri/src/shims/intrinsics/mod.rs", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,429 @@\n+mod atomic;\n+mod simd;\n+\n+use std::iter;\n+\n+use log::trace;\n+\n+use rustc_apfloat::{Float, Round};\n+use rustc_middle::ty::layout::{IntegerExt, LayoutOf};\n+use rustc_middle::{\n+    mir,\n+    ty::{self, FloatTy, Ty},\n+};\n+use rustc_target::abi::Integer;\n+\n+use crate::*;\n+use atomic::EvalContextExt as _;\n+use helpers::check_arg_count;\n+use simd::EvalContextExt as _;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn call_intrinsic(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+        _unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        // See if the core engine can handle this intrinsic.\n+        if this.emulate_intrinsic(instance, args, dest, ret)? {\n+            return Ok(());\n+        }\n+\n+        // All remaining supported intrinsics have a return place.\n+        let intrinsic_name = this.tcx.item_name(instance.def_id());\n+        let intrinsic_name = intrinsic_name.as_str();\n+        let ret = match ret {\n+            None => throw_unsup_format!(\"unimplemented (diverging) intrinsic: `{intrinsic_name}`\"),\n+            Some(p) => p,\n+        };\n+\n+        // Some intrinsics are special and need the \"ret\".\n+        match intrinsic_name {\n+            \"try\" => return this.handle_try(args, dest, ret),\n+            _ => {}\n+        }\n+\n+        // The rest jumps to `ret` immediately.\n+        this.emulate_intrinsic_by_name(intrinsic_name, args, dest)?;\n+\n+        trace!(\"{:?}\", this.dump_place(**dest));\n+        this.go_to_block(ret);\n+        Ok(())\n+    }\n+\n+    /// Emulates a Miri-supported intrinsic (not supported by the core engine).\n+    fn emulate_intrinsic_by_name(\n+        &mut self,\n+        intrinsic_name: &str,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        if let Some(name) = intrinsic_name.strip_prefix(\"atomic_\") {\n+            return this.emulate_atomic_intrinsic(name, args, dest);\n+        }\n+        if let Some(name) = intrinsic_name.strip_prefix(\"simd_\") {\n+            return this.emulate_simd_intrinsic(name, args, dest);\n+        }\n+\n+        match intrinsic_name {\n+            // Miri overwriting CTFE intrinsics.\n+            \"ptr_guaranteed_cmp\" => {\n+                let [left, right] = check_arg_count(args)?;\n+                let left = this.read_immediate(left)?;\n+                let right = this.read_immediate(right)?;\n+                let (val, _overflowed, _ty) =\n+                    this.overflowing_binary_op(mir::BinOp::Eq, &left, &right)?;\n+                // We're type punning a bool as an u8 here.\n+                this.write_scalar(val, dest)?;\n+            }\n+            \"const_allocate\" => {\n+                // For now, for compatibility with the run-time implementation of this, we just return null.\n+                // See <https://github.com/rust-lang/rust/issues/93935>.\n+                this.write_null(dest)?;\n+            }\n+            \"const_deallocate\" => {\n+                // complete NOP\n+            }\n+\n+            // Raw memory accesses\n+            \"volatile_load\" => {\n+                let [place] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                this.copy_op(&place.into(), dest, /*allow_transmute*/ false)?;\n+            }\n+            \"volatile_store\" => {\n+                let [place, dest] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                this.copy_op(dest, &place.into(), /*allow_transmute*/ false)?;\n+            }\n+\n+            \"write_bytes\" | \"volatile_set_memory\" => {\n+                let [ptr, val_byte, count] = check_arg_count(args)?;\n+                let ty = ptr.layout.ty.builtin_deref(true).unwrap().ty;\n+                let ty_layout = this.layout_of(ty)?;\n+                let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let count = this.read_scalar(count)?.to_machine_usize(this)?;\n+                // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+                // but no actual allocation can be big enough for the difference to be noticeable.\n+                let byte_count = ty_layout.size.checked_mul(count, this).ok_or_else(|| {\n+                    err_ub_format!(\"overflow computing total size of `{intrinsic_name}`\")\n+                })?;\n+                this.write_bytes_ptr(ptr, iter::repeat(val_byte).take(byte_count.bytes_usize()))?;\n+            }\n+\n+            // Floating-point operations\n+            \"fabsf32\" => {\n+                let [f] = check_arg_count(args)?;\n+                let f = this.read_scalar(f)?.to_f32()?;\n+                // Can be implemented in soft-floats.\n+                this.write_scalar(Scalar::from_f32(f.abs()), dest)?;\n+            }\n+            \"fabsf64\" => {\n+                let [f] = check_arg_count(args)?;\n+                let f = this.read_scalar(f)?.to_f64()?;\n+                // Can be implemented in soft-floats.\n+                this.write_scalar(Scalar::from_f64(f.abs()), dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"sinf32\"\n+            | \"cosf32\"\n+            | \"sqrtf32\"\n+            | \"expf32\"\n+            | \"exp2f32\"\n+            | \"logf32\"\n+            | \"log10f32\"\n+            | \"log2f32\"\n+            | \"floorf32\"\n+            | \"ceilf32\"\n+            | \"truncf32\"\n+            | \"roundf32\"\n+            => {\n+                let [f] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let f = match intrinsic_name {\n+                    \"sinf32\" => f.sin(),\n+                    \"cosf32\" => f.cos(),\n+                    \"sqrtf32\" => f.sqrt(),\n+                    \"expf32\" => f.exp(),\n+                    \"exp2f32\" => f.exp2(),\n+                    \"logf32\" => f.ln(),\n+                    \"log10f32\" => f.log10(),\n+                    \"log2f32\" => f.log2(),\n+                    \"floorf32\" => f.floor(),\n+                    \"ceilf32\" => f.ceil(),\n+                    \"truncf32\" => f.trunc(),\n+                    \"roundf32\" => f.round(),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_u32(f.to_bits()), dest)?;\n+            }\n+\n+            #[rustfmt::skip]\n+            | \"sinf64\"\n+            | \"cosf64\"\n+            | \"sqrtf64\"\n+            | \"expf64\"\n+            | \"exp2f64\"\n+            | \"logf64\"\n+            | \"log10f64\"\n+            | \"log2f64\"\n+            | \"floorf64\"\n+            | \"ceilf64\"\n+            | \"truncf64\"\n+            | \"roundf64\"\n+            => {\n+                let [f] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let f = match intrinsic_name {\n+                    \"sinf64\" => f.sin(),\n+                    \"cosf64\" => f.cos(),\n+                    \"sqrtf64\" => f.sqrt(),\n+                    \"expf64\" => f.exp(),\n+                    \"exp2f64\" => f.exp2(),\n+                    \"logf64\" => f.ln(),\n+                    \"log10f64\" => f.log10(),\n+                    \"log2f64\" => f.log2(),\n+                    \"floorf64\" => f.floor(),\n+                    \"ceilf64\" => f.ceil(),\n+                    \"truncf64\" => f.trunc(),\n+                    \"roundf64\" => f.round(),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_u64(f.to_bits()), dest)?;\n+            }\n+\n+            #[rustfmt::skip]\n+            | \"fadd_fast\"\n+            | \"fsub_fast\"\n+            | \"fmul_fast\"\n+            | \"fdiv_fast\"\n+            | \"frem_fast\"\n+            => {\n+                let [a, b] = check_arg_count(args)?;\n+                let a = this.read_immediate(a)?;\n+                let b = this.read_immediate(b)?;\n+                let op = match intrinsic_name {\n+                    \"fadd_fast\" => mir::BinOp::Add,\n+                    \"fsub_fast\" => mir::BinOp::Sub,\n+                    \"fmul_fast\" => mir::BinOp::Mul,\n+                    \"fdiv_fast\" => mir::BinOp::Div,\n+                    \"frem_fast\" => mir::BinOp::Rem,\n+                    _ => bug!(),\n+                };\n+                let float_finite = |x: &ImmTy<'tcx, _>| -> InterpResult<'tcx, bool> {\n+                    Ok(match x.layout.ty.kind() {\n+                        ty::Float(FloatTy::F32) => x.to_scalar().to_f32()?.is_finite(),\n+                        ty::Float(FloatTy::F64) => x.to_scalar().to_f64()?.is_finite(),\n+                        _ => bug!(\n+                            \"`{intrinsic_name}` called with non-float input type {ty:?}\",\n+                            ty = x.layout.ty,\n+                        ),\n+                    })\n+                };\n+                match (float_finite(&a)?, float_finite(&b)?) {\n+                    (false, false) => throw_ub_format!(\n+                        \"`{intrinsic_name}` intrinsic called with non-finite value as both parameters\",\n+                    ),\n+                    (false, _) => throw_ub_format!(\n+                        \"`{intrinsic_name}` intrinsic called with non-finite value as first parameter\",\n+                    ),\n+                    (_, false) => throw_ub_format!(\n+                        \"`{intrinsic_name}` intrinsic called with non-finite value as second parameter\",\n+                    ),\n+                    _ => {}\n+                }\n+                this.binop_ignore_overflow(op, &a, &b, dest)?;\n+            }\n+\n+            #[rustfmt::skip]\n+            | \"minnumf32\"\n+            | \"maxnumf32\"\n+            | \"copysignf32\"\n+            => {\n+                let [a, b] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f32()?;\n+                let b = this.read_scalar(b)?.to_f32()?;\n+                let res = match intrinsic_name {\n+                    \"minnumf32\" => a.min(b),\n+                    \"maxnumf32\" => a.max(b),\n+                    \"copysignf32\" => a.copy_sign(b),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_f32(res), dest)?;\n+            }\n+\n+            #[rustfmt::skip]\n+            | \"minnumf64\"\n+            | \"maxnumf64\"\n+            | \"copysignf64\"\n+            => {\n+                let [a, b] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f64()?;\n+                let b = this.read_scalar(b)?.to_f64()?;\n+                let res = match intrinsic_name {\n+                    \"minnumf64\" => a.min(b),\n+                    \"maxnumf64\" => a.max(b),\n+                    \"copysignf64\" => a.copy_sign(b),\n+                    _ => bug!(),\n+                };\n+                this.write_scalar(Scalar::from_f64(res), dest)?;\n+            }\n+\n+            \"powf32\" => {\n+                let [f, f2] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n+                let res = f.powf(f2);\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n+            }\n+\n+            \"powf64\" => {\n+                let [f, f2] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n+                let res = f.powf(f2);\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n+            }\n+\n+            \"fmaf32\" => {\n+                let [a, b, c] = check_arg_count(args)?;\n+                // FIXME: Using host floats, to work around https://github.com/rust-lang/miri/issues/2468.\n+                let a = f32::from_bits(this.read_scalar(a)?.to_u32()?);\n+                let b = f32::from_bits(this.read_scalar(b)?.to_u32()?);\n+                let c = f32::from_bits(this.read_scalar(c)?.to_u32()?);\n+                let res = a.mul_add(b, c);\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n+            }\n+\n+            \"fmaf64\" => {\n+                let [a, b, c] = check_arg_count(args)?;\n+                // FIXME: Using host floats, to work around https://github.com/rust-lang/miri/issues/2468.\n+                let a = f64::from_bits(this.read_scalar(a)?.to_u64()?);\n+                let b = f64::from_bits(this.read_scalar(b)?.to_u64()?);\n+                let c = f64::from_bits(this.read_scalar(c)?.to_u64()?);\n+                let res = a.mul_add(b, c);\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n+            }\n+\n+            \"powif32\" => {\n+                let [f, i] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let i = this.read_scalar(i)?.to_i32()?;\n+                let res = f.powi(i);\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n+            }\n+\n+            \"powif64\" => {\n+                let [f, i] = check_arg_count(args)?;\n+                // FIXME: Using host floats.\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let i = this.read_scalar(i)?.to_i32()?;\n+                let res = f.powi(i);\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n+            }\n+\n+            \"float_to_int_unchecked\" => {\n+                let [val] = check_arg_count(args)?;\n+                let val = this.read_immediate(val)?;\n+\n+                let res = match val.layout.ty.kind() {\n+                    ty::Float(FloatTy::F32) =>\n+                        this.float_to_int_unchecked(val.to_scalar().to_f32()?, dest.layout.ty)?,\n+                    ty::Float(FloatTy::F64) =>\n+                        this.float_to_int_unchecked(val.to_scalar().to_f64()?, dest.layout.ty)?,\n+                    _ =>\n+                        span_bug!(\n+                            this.cur_span(),\n+                            \"`float_to_int_unchecked` called with non-float input type {:?}\",\n+                            val.layout.ty\n+                        ),\n+                };\n+\n+                this.write_scalar(res, dest)?;\n+            }\n+\n+            // Other\n+            \"exact_div\" => {\n+                let [num, denom] = check_arg_count(args)?;\n+                this.exact_div(&this.read_immediate(num)?, &this.read_immediate(denom)?, dest)?;\n+            }\n+\n+            \"breakpoint\" => {\n+                let [] = check_arg_count(args)?;\n+                // normally this would raise a SIGTRAP, which aborts if no debugger is connected\n+                throw_machine_stop!(TerminationInfo::Abort(format!(\"Trace/breakpoint trap\")))\n+            }\n+\n+            name => throw_unsup_format!(\"unimplemented intrinsic: `{name}`\"),\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn float_to_int_unchecked<F>(\n+        &self,\n+        f: F,\n+        dest_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>>\n+    where\n+        F: Float + Into<Scalar<Provenance>>,\n+    {\n+        let this = self.eval_context_ref();\n+\n+        // Step 1: cut off the fractional part of `f`. The result of this is\n+        // guaranteed to be precisely representable in IEEE floats.\n+        let f = f.round_to_integral(Round::TowardZero).value;\n+\n+        // Step 2: Cast the truncated float to the target integer type and see if we lose any information in this step.\n+        Ok(match dest_ty.kind() {\n+            // Unsigned\n+            ty::Uint(t) => {\n+                let size = Integer::from_uint_ty(this, *t).size();\n+                let res = f.to_u128(size.bits_usize());\n+                if res.status.is_empty() {\n+                    // No status flags means there was no further rounding or other loss of precision.\n+                    Scalar::from_uint(res.value, size)\n+                } else {\n+                    // `f` was not representable in this integer type.\n+                    throw_ub_format!(\n+                        \"`float_to_int_unchecked` intrinsic called on {f} which cannot be represented in target type `{dest_ty:?}`\",\n+                    );\n+                }\n+            }\n+            // Signed\n+            ty::Int(t) => {\n+                let size = Integer::from_int_ty(this, *t).size();\n+                let res = f.to_i128(size.bits_usize());\n+                if res.status.is_empty() {\n+                    // No status flags means there was no further rounding or other loss of precision.\n+                    Scalar::from_int(res.value, size)\n+                } else {\n+                    // `f` was not representable in this integer type.\n+                    throw_ub_format!(\n+                        \"`float_to_int_unchecked` intrinsic called on {f} which cannot be represented in target type `{dest_ty:?}`\",\n+                    );\n+                }\n+            }\n+            // Nothing else\n+            _ =>\n+                span_bug!(\n+                    this.cur_span(),\n+                    \"`float_to_int_unchecked` called with non-int output type {dest_ty:?}\"\n+                ),\n+        })\n+    }\n+}"}, {"sha": "163d185f66f3a1f4fc54fc635bfb16d9642defbd", "filename": "src/tools/miri/src/shims/intrinsics/simd.rs", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,627 @@\n+use rustc_apfloat::Float;\n+use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n+use rustc_middle::{mir, ty, ty::FloatTy};\n+use rustc_target::abi::{Endian, HasDataLayout, Size};\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Calls the simd intrinsic `intrinsic`; the `simd_` prefix has already been removed.\n+    fn emulate_simd_intrinsic(\n+        &mut self,\n+        intrinsic_name: &str,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        match intrinsic_name {\n+            #[rustfmt::skip]\n+            | \"neg\"\n+            | \"fabs\"\n+            | \"ceil\"\n+            | \"floor\"\n+            | \"round\"\n+            | \"trunc\"\n+            | \"fsqrt\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, op_len);\n+\n+                #[derive(Copy, Clone)]\n+                enum HostFloatOp {\n+                    Ceil,\n+                    Floor,\n+                    Round,\n+                    Trunc,\n+                    Sqrt,\n+                }\n+                #[derive(Copy, Clone)]\n+                enum Op {\n+                    MirOp(mir::UnOp),\n+                    Abs,\n+                    HostOp(HostFloatOp),\n+                }\n+                let which = match intrinsic_name {\n+                    \"neg\" => Op::MirOp(mir::UnOp::Neg),\n+                    \"fabs\" => Op::Abs,\n+                    \"ceil\" => Op::HostOp(HostFloatOp::Ceil),\n+                    \"floor\" => Op::HostOp(HostFloatOp::Floor),\n+                    \"round\" => Op::HostOp(HostFloatOp::Round),\n+                    \"trunc\" => Op::HostOp(HostFloatOp::Trunc),\n+                    \"fsqrt\" => Op::HostOp(HostFloatOp::Sqrt),\n+                    _ => unreachable!(),\n+                };\n+\n+                for i in 0..dest_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+                    let val = match which {\n+                        Op::MirOp(mir_op) => this.unary_op(mir_op, &op)?.to_scalar(),\n+                        Op::Abs => {\n+                            // Works for f32 and f64.\n+                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n+                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                            };\n+                            let op = op.to_scalar();\n+                            match float_ty {\n+                                FloatTy::F32 => Scalar::from_f32(op.to_f32()?.abs()),\n+                                FloatTy::F64 => Scalar::from_f64(op.to_f64()?.abs()),\n+                            }\n+                        }\n+                        Op::HostOp(host_op) => {\n+                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n+                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                            };\n+                            // FIXME using host floats\n+                            match float_ty {\n+                                FloatTy::F32 => {\n+                                    let f = f32::from_bits(op.to_scalar().to_u32()?);\n+                                    let res = match host_op {\n+                                        HostFloatOp::Ceil => f.ceil(),\n+                                        HostFloatOp::Floor => f.floor(),\n+                                        HostFloatOp::Round => f.round(),\n+                                        HostFloatOp::Trunc => f.trunc(),\n+                                        HostFloatOp::Sqrt => f.sqrt(),\n+                                    };\n+                                    Scalar::from_u32(res.to_bits())\n+                                }\n+                                FloatTy::F64 => {\n+                                    let f = f64::from_bits(op.to_scalar().to_u64()?);\n+                                    let res = match host_op {\n+                                        HostFloatOp::Ceil => f.ceil(),\n+                                        HostFloatOp::Floor => f.floor(),\n+                                        HostFloatOp::Round => f.round(),\n+                                        HostFloatOp::Trunc => f.trunc(),\n+                                        HostFloatOp::Sqrt => f.sqrt(),\n+                                    };\n+                                    Scalar::from_u64(res.to_bits())\n+                                }\n+                            }\n+\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            #[rustfmt::skip]\n+            | \"add\"\n+            | \"sub\"\n+            | \"mul\"\n+            | \"div\"\n+            | \"rem\"\n+            | \"shl\"\n+            | \"shr\"\n+            | \"and\"\n+            | \"or\"\n+            | \"xor\"\n+            | \"eq\"\n+            | \"ne\"\n+            | \"lt\"\n+            | \"le\"\n+            | \"gt\"\n+            | \"ge\"\n+            | \"fmax\"\n+            | \"fmin\"\n+            | \"saturating_add\"\n+            | \"saturating_sub\"\n+            | \"arith_offset\" => {\n+                use mir::BinOp;\n+\n+                let [left, right] = check_arg_count(args)?;\n+                let (left, left_len) = this.operand_to_simd(left)?;\n+                let (right, right_len) = this.operand_to_simd(right)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, left_len);\n+                assert_eq!(dest_len, right_len);\n+\n+                enum Op {\n+                    MirOp(BinOp),\n+                    SaturatingOp(BinOp),\n+                    FMax,\n+                    FMin,\n+                    WrappingOffset,\n+                }\n+                let which = match intrinsic_name {\n+                    \"add\" => Op::MirOp(BinOp::Add),\n+                    \"sub\" => Op::MirOp(BinOp::Sub),\n+                    \"mul\" => Op::MirOp(BinOp::Mul),\n+                    \"div\" => Op::MirOp(BinOp::Div),\n+                    \"rem\" => Op::MirOp(BinOp::Rem),\n+                    \"shl\" => Op::MirOp(BinOp::Shl),\n+                    \"shr\" => Op::MirOp(BinOp::Shr),\n+                    \"and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"or\" => Op::MirOp(BinOp::BitOr),\n+                    \"xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"eq\" => Op::MirOp(BinOp::Eq),\n+                    \"ne\" => Op::MirOp(BinOp::Ne),\n+                    \"lt\" => Op::MirOp(BinOp::Lt),\n+                    \"le\" => Op::MirOp(BinOp::Le),\n+                    \"gt\" => Op::MirOp(BinOp::Gt),\n+                    \"ge\" => Op::MirOp(BinOp::Ge),\n+                    \"fmax\" => Op::FMax,\n+                    \"fmin\" => Op::FMin,\n+                    \"saturating_add\" => Op::SaturatingOp(BinOp::Add),\n+                    \"saturating_sub\" => Op::SaturatingOp(BinOp::Sub),\n+                    \"arith_offset\" => Op::WrappingOffset,\n+                    _ => unreachable!(),\n+                };\n+\n+                for i in 0..dest_len {\n+                    let left = this.read_immediate(&this.mplace_index(&left, i)?.into())?;\n+                    let right = this.read_immediate(&this.mplace_index(&right, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+                    let val = match which {\n+                        Op::MirOp(mir_op) => {\n+                            let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n+                            if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n+                                // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n+                                // See <https://github.com/rust-lang/rust/issues/91237>.\n+                                if overflowed {\n+                                    let r_val = right.to_scalar().to_bits(right.layout.size)?;\n+                                    throw_ub_format!(\"overflowing shift by {r_val} in `simd_{intrinsic_name}` in SIMD lane {i}\");\n+                                }\n+                            }\n+                            if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n+                                // Special handling for boolean-returning operations\n+                                assert_eq!(ty, this.tcx.types.bool);\n+                                let val = val.to_bool().unwrap();\n+                                bool_to_simd_element(val, dest.layout.size)\n+                            } else {\n+                                assert_ne!(ty, this.tcx.types.bool);\n+                                assert_eq!(ty, dest.layout.ty);\n+                                val\n+                            }\n+                        }\n+                        Op::SaturatingOp(mir_op) => {\n+                            this.saturating_arith(mir_op, &left, &right)?\n+                        }\n+                        Op::WrappingOffset => {\n+                            let ptr = left.to_scalar().to_pointer(this)?;\n+                            let offset_count = right.to_scalar().to_machine_isize(this)?;\n+                            let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n+\n+                            let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();\n+                            let offset_bytes = offset_count.wrapping_mul(pointee_size);\n+                            let offset_ptr = ptr.wrapping_signed_offset(offset_bytes, this);\n+                            Scalar::from_maybe_pointer(offset_ptr, this)\n+                        }\n+                        Op::FMax => {\n+                            fmax_op(&left, &right)?\n+                        }\n+                        Op::FMin => {\n+                            fmin_op(&left, &right)?\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            \"fma\" => {\n+                let [a, b, c] = check_arg_count(args)?;\n+                let (a, a_len) = this.operand_to_simd(a)?;\n+                let (b, b_len) = this.operand_to_simd(b)?;\n+                let (c, c_len) = this.operand_to_simd(c)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, a_len);\n+                assert_eq!(dest_len, b_len);\n+                assert_eq!(dest_len, c_len);\n+\n+                for i in 0..dest_len {\n+                    let a = this.read_scalar(&this.mplace_index(&a, i)?.into())?;\n+                    let b = this.read_scalar(&this.mplace_index(&b, i)?.into())?;\n+                    let c = this.read_scalar(&this.mplace_index(&c, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    // Works for f32 and f64.\n+                    // FIXME: using host floats to work around https://github.com/rust-lang/miri/issues/2468.\n+                    let ty::Float(float_ty) = dest.layout.ty.kind() else {\n+                        span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                    };\n+                    let val = match float_ty {\n+                        FloatTy::F32 => {\n+                            let a = f32::from_bits(a.to_u32()?);\n+                            let b = f32::from_bits(b.to_u32()?);\n+                            let c = f32::from_bits(c.to_u32()?);\n+                            let res = a.mul_add(b, c);\n+                            Scalar::from_u32(res.to_bits())\n+                        }\n+                        FloatTy::F64 => {\n+                            let a = f64::from_bits(a.to_u64()?);\n+                            let b = f64::from_bits(b.to_u64()?);\n+                            let c = f64::from_bits(c.to_u64()?);\n+                            let res = a.mul_add(b, c);\n+                            Scalar::from_u64(res.to_bits())\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            #[rustfmt::skip]\n+            | \"reduce_and\"\n+            | \"reduce_or\"\n+            | \"reduce_xor\"\n+            | \"reduce_any\"\n+            | \"reduce_all\"\n+            | \"reduce_max\"\n+            | \"reduce_min\" => {\n+                use mir::BinOp;\n+\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+\n+                let imm_from_bool =\n+                    |b| ImmTy::from_scalar(Scalar::from_bool(b), this.machine.layouts.bool);\n+\n+                enum Op {\n+                    MirOp(BinOp),\n+                    MirOpBool(BinOp),\n+                    Max,\n+                    Min,\n+                }\n+                let which = match intrinsic_name {\n+                    \"reduce_and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"reduce_or\" => Op::MirOp(BinOp::BitOr),\n+                    \"reduce_xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"reduce_any\" => Op::MirOpBool(BinOp::BitOr),\n+                    \"reduce_all\" => Op::MirOpBool(BinOp::BitAnd),\n+                    \"reduce_max\" => Op::Max,\n+                    \"reduce_min\" => Op::Min,\n+                    _ => unreachable!(),\n+                };\n+\n+                // Initialize with first lane, then proceed with the rest.\n+                let mut res = this.read_immediate(&this.mplace_index(&op, 0)?.into())?;\n+                if matches!(which, Op::MirOpBool(_)) {\n+                    // Convert to `bool` scalar.\n+                    res = imm_from_bool(simd_element_to_bool(res)?);\n+                }\n+                for i in 1..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    res = match which {\n+                        Op::MirOp(mir_op) => {\n+                            this.binary_op(mir_op, &res, &op)?\n+                        }\n+                        Op::MirOpBool(mir_op) => {\n+                            let op = imm_from_bool(simd_element_to_bool(op)?);\n+                            this.binary_op(mir_op, &res, &op)?\n+                        }\n+                        Op::Max => {\n+                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n+                                ImmTy::from_scalar(fmax_op(&res, &op)?, res.layout)\n+                            } else {\n+                                // Just boring integers, so NaNs to worry about\n+                                if this.binary_op(BinOp::Ge, &res, &op)?.to_scalar().to_bool()? {\n+                                    res\n+                                } else {\n+                                    op\n+                                }\n+                            }\n+                        }\n+                        Op::Min => {\n+                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n+                                ImmTy::from_scalar(fmin_op(&res, &op)?, res.layout)\n+                            } else {\n+                                // Just boring integers, so NaNs to worry about\n+                                if this.binary_op(BinOp::Le, &res, &op)?.to_scalar().to_bool()? {\n+                                    res\n+                                } else {\n+                                    op\n+                                }\n+                            }\n+                        }\n+                    };\n+                }\n+                this.write_immediate(*res, dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"reduce_add_ordered\"\n+            | \"reduce_mul_ordered\" => {\n+                use mir::BinOp;\n+\n+                let [op, init] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let init = this.read_immediate(init)?;\n+\n+                let mir_op = match intrinsic_name {\n+                    \"reduce_add_ordered\" => BinOp::Add,\n+                    \"reduce_mul_ordered\" => BinOp::Mul,\n+                    _ => unreachable!(),\n+                };\n+\n+                let mut res = init;\n+                for i in 0..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    res = this.binary_op(mir_op, &res, &op)?;\n+                }\n+                this.write_immediate(*res, dest)?;\n+            }\n+            \"select\" => {\n+                let [mask, yes, no] = check_arg_count(args)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, mask_len);\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+\n+                for i in 0..dest_len {\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if simd_element_to_bool(mask)? { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"select_bitmask\" => {\n+                let [mask, yes, no] = check_arg_count(args)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+                let bitmask_len = dest_len.max(8);\n+\n+                assert!(mask.layout.ty.is_integral());\n+                assert!(bitmask_len <= 64);\n+                assert_eq!(bitmask_len, mask.layout.size.bits());\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+                let dest_len = u32::try_from(dest_len).unwrap();\n+                let bitmask_len = u32::try_from(bitmask_len).unwrap();\n+\n+                let mask: u64 =\n+                    this.read_scalar(mask)?.to_bits(mask.layout.size)?.try_into().unwrap();\n+                for i in 0..dest_len {\n+                    let mask = mask\n+                        & 1u64\n+                            .checked_shl(simd_bitmask_index(i, dest_len, this.data_layout().endian))\n+                            .unwrap();\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i.into())?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i.into())?.into())?;\n+                    let dest = this.mplace_index(&dest, i.into())?;\n+\n+                    let val = if mask != 0 { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+                for i in dest_len..bitmask_len {\n+                    // If the mask is \"padded\", ensure that padding is all-zero.\n+                    let mask = mask & 1u64.checked_shl(i).unwrap();\n+                    if mask != 0 {\n+                        throw_ub_format!(\n+                            \"a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\"\n+                        );\n+                    }\n+                }\n+            }\n+            #[rustfmt::skip]\n+            \"cast\" | \"as\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, op_len);\n+\n+                let safe_cast = intrinsic_name == \"as\";\n+\n+                for i in 0..dest_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n+                        // Int-to-(int|float): always safe\n+                        (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-float: always safe\n+                        (ty::Float(_), ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in safe mode\n+                        (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in unchecked mode\n+                        (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar().to_f32()?, dest.layout.ty)?.into(),\n+                        (ty::Float(FloatTy::F64), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar().to_f64()?, dest.layout.ty)?.into(),\n+                        _ =>\n+                            throw_unsup_format!(\n+                                \"Unsupported SIMD cast from element type {from_ty} to {to_ty}\",\n+                                from_ty = op.layout.ty,\n+                                to_ty = dest.layout.ty,\n+                            ),\n+                    };\n+                    this.write_immediate(val, &dest.into())?;\n+                }\n+            }\n+            \"shuffle\" => {\n+                let [left, right, index] = check_arg_count(args)?;\n+                let (left, left_len) = this.operand_to_simd(left)?;\n+                let (right, right_len) = this.operand_to_simd(right)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                // `index` is an array, not a SIMD type\n+                let ty::Array(_, index_len) = index.layout.ty.kind() else {\n+                    span_bug!(this.cur_span(), \"simd_shuffle index argument has non-array type {}\", index.layout.ty)\n+                };\n+                let index_len = index_len.eval_usize(*this.tcx, this.param_env());\n+\n+                assert_eq!(left_len, right_len);\n+                assert_eq!(index_len, dest_len);\n+\n+                for i in 0..dest_len {\n+                    let src_index: u64 = this\n+                        .read_immediate(&this.operand_index(index, i)?)?\n+                        .to_scalar()\n+                        .to_u32()?\n+                        .into();\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if src_index < left_len {\n+                        this.read_immediate(&this.mplace_index(&left, src_index)?.into())?\n+                    } else if src_index < left_len.checked_add(right_len).unwrap() {\n+                        let right_idx = src_index.checked_sub(left_len).unwrap();\n+                        this.read_immediate(&this.mplace_index(&right, right_idx)?.into())?\n+                    } else {\n+                        span_bug!(\n+                            this.cur_span(),\n+                            \"simd_shuffle index {src_index} is out of bounds for 2 vectors of size {left_len}\",\n+                        );\n+                    };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"gather\" => {\n+                let [passthru, ptrs, mask] = check_arg_count(args)?;\n+                let (passthru, passthru_len) = this.operand_to_simd(passthru)?;\n+                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, passthru_len);\n+                assert_eq!(dest_len, ptrs_len);\n+                assert_eq!(dest_len, mask_len);\n+\n+                for i in 0..dest_len {\n+                    let passthru = this.read_immediate(&this.mplace_index(&passthru, i)?.into())?;\n+                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if simd_element_to_bool(mask)? {\n+                        let place = this.deref_operand(&ptr.into())?;\n+                        this.read_immediate(&place.into())?\n+                    } else {\n+                        passthru\n+                    };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"scatter\" => {\n+                let [value, ptrs, mask] = check_arg_count(args)?;\n+                let (value, value_len) = this.operand_to_simd(value)?;\n+                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+\n+                assert_eq!(ptrs_len, value_len);\n+                assert_eq!(ptrs_len, mask_len);\n+\n+                for i in 0..ptrs_len {\n+                    let value = this.read_immediate(&this.mplace_index(&value, i)?.into())?;\n+                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+\n+                    if simd_element_to_bool(mask)? {\n+                        let place = this.deref_operand(&ptr.into())?;\n+                        this.write_immediate(*value, &place.into())?;\n+                    }\n+                }\n+            }\n+            \"bitmask\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let bitmask_len = op_len.max(8);\n+\n+                assert!(dest.layout.ty.is_integral());\n+                assert!(bitmask_len <= 64);\n+                assert_eq!(bitmask_len, dest.layout.size.bits());\n+                let op_len = u32::try_from(op_len).unwrap();\n+\n+                let mut res = 0u64;\n+                for i in 0..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i.into())?.into())?;\n+                    if simd_element_to_bool(op)? {\n+                        res |= 1u64\n+                            .checked_shl(simd_bitmask_index(i, op_len, this.data_layout().endian))\n+                            .unwrap();\n+                    }\n+                }\n+                this.write_int(res, dest)?;\n+            }\n+\n+            name => throw_unsup_format!(\"unimplemented intrinsic: `simd_{name}`\"),\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Provenance> {\n+    // SIMD uses all-1 as pattern for \"true\"\n+    let val = if b { -1 } else { 0 };\n+    Scalar::from_int(val, size)\n+}\n+\n+fn simd_element_to_bool(elem: ImmTy<'_, Provenance>) -> InterpResult<'_, bool> {\n+    let val = elem.to_scalar().to_int(elem.layout.size)?;\n+    Ok(match val {\n+        0 => false,\n+        -1 => true,\n+        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n+    })\n+}\n+\n+fn simd_bitmask_index(idx: u32, vec_len: u32, endianess: Endian) -> u32 {\n+    assert!(idx < vec_len);\n+    match endianess {\n+        Endian::Little => idx,\n+        #[allow(clippy::integer_arithmetic)] // idx < vec_len\n+        Endian::Big => vec_len - 1 - idx, // reverse order of bits\n+    }\n+}\n+\n+fn fmax_op<'tcx>(\n+    left: &ImmTy<'tcx, Provenance>,\n+    right: &ImmTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n+    assert_eq!(left.layout.ty, right.layout.ty);\n+    let ty::Float(float_ty) = left.layout.ty.kind() else {\n+        bug!(\"fmax operand is not a float\")\n+    };\n+    let left = left.to_scalar();\n+    let right = right.to_scalar();\n+    Ok(match float_ty {\n+        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.max(right.to_f32()?)),\n+        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.max(right.to_f64()?)),\n+    })\n+}\n+\n+fn fmin_op<'tcx>(\n+    left: &ImmTy<'tcx, Provenance>,\n+    right: &ImmTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n+    assert_eq!(left.layout.ty, right.layout.ty);\n+    let ty::Float(float_ty) = left.layout.ty.kind() else {\n+        bug!(\"fmin operand is not a float\")\n+    };\n+    let left = left.to_scalar();\n+    let right = right.to_scalar();\n+    Ok(match float_ty {\n+        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.min(right.to_f32()?)),\n+        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),\n+    })\n+}"}, {"sha": "8cb648e51732851ba39950edc6873050436edc38", "filename": "src/tools/miri/src/shims/mod.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,107 @@\n+#![warn(clippy::integer_arithmetic)]\n+\n+mod backtrace;\n+#[cfg(unix)]\n+pub mod ffi_support;\n+pub mod foreign_items;\n+pub mod intrinsics;\n+pub mod unix;\n+pub mod windows;\n+\n+pub mod dlsym;\n+pub mod env;\n+pub mod os_str;\n+pub mod panic;\n+pub mod time;\n+pub mod tls;\n+\n+// End module management, begin local code\n+\n+use log::trace;\n+\n+use rustc_middle::{mir, ty};\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn find_mir_or_eval_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+        unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n+        let this = self.eval_context_mut();\n+        trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest);\n+\n+        // There are some more lang items we want to hook that CTFE does not hook (yet).\n+        if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n+            let [ptr, align] = check_arg_count(args)?;\n+            if this.align_offset(ptr, align, dest, ret, unwind)? {\n+                return Ok(None);\n+            }\n+        }\n+\n+        // Try to see if we can do something about foreign items.\n+        if this.tcx.is_foreign_item(instance.def_id()) {\n+            // An external function call that does not have a MIR body. We either find MIR elsewhere\n+            // or emulate its effect.\n+            // This will be Ok(None) if we're emulating the intrinsic entirely within Miri (no need\n+            // to run extra MIR), and Ok(Some(body)) if we found MIR to run for the\n+            // foreign function\n+            // Any needed call to `goto_block` will be performed by `emulate_foreign_item`.\n+            return this.emulate_foreign_item(instance.def_id(), abi, args, dest, ret, unwind);\n+        }\n+\n+        // Otherwise, load the MIR.\n+        Ok(Some((this.load_mir(instance.def, None)?, instance)))\n+    }\n+\n+    /// Returns `true` if the computation was performed, and `false` if we should just evaluate\n+    /// the actual MIR of `align_offset`.\n+    fn align_offset(\n+        &mut self,\n+        ptr_op: &OpTy<'tcx, Provenance>,\n+        align_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+        unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx, bool> {\n+        let this = self.eval_context_mut();\n+        let ret = ret.unwrap();\n+\n+        if this.machine.check_alignment != AlignmentCheck::Symbolic {\n+            // Just use actual implementation.\n+            return Ok(false);\n+        }\n+\n+        let req_align = this.read_scalar(align_op)?.to_machine_usize(this)?;\n+\n+        // Stop if the alignment is not a power of two.\n+        if !req_align.is_power_of_two() {\n+            this.start_panic(\"align_offset: align is not a power-of-two\", unwind)?;\n+            return Ok(true); // nothing left to do\n+        }\n+\n+        let ptr = this.read_pointer(ptr_op)?;\n+        if let Ok((alloc_id, _offset, _)) = this.ptr_try_get_alloc_id(ptr) {\n+            // Only do anything if we can identify the allocation this goes to.\n+            let (_size, cur_align, _kind) = this.get_alloc_info(alloc_id);\n+            if cur_align.bytes() >= req_align {\n+                // If the allocation alignment is at least the required alignment we use the\n+                // real implementation.\n+                return Ok(false);\n+            }\n+        }\n+\n+        // Return error result (usize::MAX), and jump to caller.\n+        this.write_scalar(Scalar::from_machine_usize(this.machine_usize_max(), this), dest)?;\n+        this.go_to_block(ret);\n+        Ok(true)\n+    }\n+}"}, {"sha": "407dab970ad7dcdbcac28652f0aab4df58b96ae1", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,308 @@\n+use std::borrow::Cow;\n+use std::ffi::{OsStr, OsString};\n+use std::iter;\n+use std::path::{Path, PathBuf};\n+\n+#[cfg(unix)]\n+use std::os::unix::ffi::{OsStrExt, OsStringExt};\n+#[cfg(windows)]\n+use std::os::windows::ffi::{OsStrExt, OsStringExt};\n+\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_target::abi::{Align, Size};\n+\n+use crate::*;\n+\n+/// Represent how path separator conversion should be done.\n+pub enum PathConversion {\n+    HostToTarget,\n+    TargetToHost,\n+}\n+\n+#[cfg(unix)]\n+pub fn os_str_to_bytes<'a, 'tcx>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+    Ok(os_str.as_bytes())\n+}\n+\n+#[cfg(not(unix))]\n+pub fn os_str_to_bytes<'a, 'tcx>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+    // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n+    // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n+    // valid.\n+    os_str\n+        .to_str()\n+        .map(|s| s.as_bytes())\n+        .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n+}\n+\n+#[cfg(unix)]\n+pub fn bytes_to_os_str<'a, 'tcx>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n+    Ok(OsStr::from_bytes(bytes))\n+}\n+#[cfg(not(unix))]\n+pub fn bytes_to_os_str<'a, 'tcx>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n+    let s = std::str::from_utf8(bytes)\n+        .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n+    Ok(OsStr::new(s))\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n+    /// the Unix APIs usually handle.\n+    fn read_os_str_from_c_str<'a>(\n+        &'a self,\n+        ptr: Pointer<Option<Provenance>>,\n+    ) -> InterpResult<'tcx, &'a OsStr>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        let this = self.eval_context_ref();\n+        let bytes = this.read_c_str(ptr)?;\n+        bytes_to_os_str(bytes)\n+    }\n+\n+    /// Helper function to read an OsString from a 0x0000-terminated sequence of u16,\n+    /// which is what the Windows APIs usually handle.\n+    fn read_os_str_from_wide_str<'a>(\n+        &'a self,\n+        ptr: Pointer<Option<Provenance>>,\n+    ) -> InterpResult<'tcx, OsString>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        #[cfg(windows)]\n+        pub fn u16vec_to_osstring<'tcx>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+            Ok(OsString::from_wide(&u16_vec[..]))\n+        }\n+        #[cfg(not(windows))]\n+        pub fn u16vec_to_osstring<'tcx>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+            let s = String::from_utf16(&u16_vec[..])\n+                .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-16 string\", u16_vec))?;\n+            Ok(s.into())\n+        }\n+\n+        let u16_vec = self.eval_context_ref().read_wide_str(ptr)?;\n+        u16vec_to_osstring(u16_vec)\n+    }\n+\n+    /// Helper function to write an OsStr as a null-terminated sequence of bytes, which is what\n+    /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does include the null terminator.\n+    fn write_os_str_to_c_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        ptr: Pointer<Option<Provenance>>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        let bytes = os_str_to_bytes(os_str)?;\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n+        // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n+        let string_length = u64::try_from(bytes.len()).unwrap();\n+        let string_length = string_length.checked_add(1).unwrap();\n+        if size < string_length {\n+            return Ok((false, string_length));\n+        }\n+        self.eval_context_mut()\n+            .write_bytes_ptr(ptr, bytes.iter().copied().chain(iter::once(0u8)))?;\n+        Ok((true, string_length))\n+    }\n+\n+    /// Helper function to write an OsStr as a 0x0000-terminated u16-sequence, which is what\n+    /// the Windows APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does include the null terminator. Length is measured in units of\n+    /// `u16.`\n+    fn write_os_str_to_wide_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        ptr: Pointer<Option<Provenance>>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        #[cfg(windows)]\n+        fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n+            Ok(os_str.encode_wide().collect())\n+        }\n+        #[cfg(not(windows))]\n+        fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n+            // On non-Windows platforms the best we can do to transform Vec<u16> from/to OS strings is to do the\n+            // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n+            // valid.\n+            os_str\n+                .to_str()\n+                .map(|s| s.encode_utf16().collect())\n+                .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n+        }\n+\n+        let u16_vec = os_str_to_u16vec(os_str)?;\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n+        // 0x0000 terminator to memory would cause an out-of-bounds access.\n+        let string_length = u64::try_from(u16_vec.len()).unwrap();\n+        let string_length = string_length.checked_add(1).unwrap();\n+        if size < string_length {\n+            return Ok((false, string_length));\n+        }\n+\n+        // Store the UTF-16 string.\n+        let size2 = Size::from_bytes(2);\n+        let this = self.eval_context_mut();\n+        let mut alloc = this\n+            .get_ptr_alloc_mut(ptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n+            .unwrap(); // not a ZST, so we will get a result\n+        for (offset, wchar) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n+            let offset = u64::try_from(offset).unwrap();\n+            alloc.write_scalar(alloc_range(size2 * offset, size2), Scalar::from_u16(wchar))?;\n+        }\n+        Ok((true, string_length))\n+    }\n+\n+    /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of bytes.\n+    fn alloc_os_str_as_c_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        memkind: MemoryKind<MiriMemoryKind>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0` terminator.\n+        let this = self.eval_context_mut();\n+\n+        let arg_type = this.tcx.mk_array(this.tcx.types.u8, size);\n+        let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind)?;\n+        assert!(self.write_os_str_to_c_str(os_str, arg_place.ptr, size).unwrap().0);\n+        Ok(arg_place.ptr)\n+    }\n+\n+    /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of `u16`.\n+    fn alloc_os_str_as_wide_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        memkind: MemoryKind<MiriMemoryKind>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0x0000` terminator.\n+        let this = self.eval_context_mut();\n+\n+        let arg_type = this.tcx.mk_array(this.tcx.types.u16, size);\n+        let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind)?;\n+        assert!(self.write_os_str_to_wide_str(os_str, arg_place.ptr, size).unwrap().0);\n+        Ok(arg_place.ptr)\n+    }\n+\n+    /// Read a null-terminated sequence of bytes, and perform path separator conversion if needed.\n+    fn read_path_from_c_str<'a>(\n+        &'a self,\n+        ptr: Pointer<Option<Provenance>>,\n+    ) -> InterpResult<'tcx, Cow<'a, Path>>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        let this = self.eval_context_ref();\n+        let os_str = this.read_os_str_from_c_str(ptr)?;\n+\n+        Ok(match this.convert_path_separator(Cow::Borrowed(os_str), PathConversion::TargetToHost) {\n+            Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)),\n+            Cow::Owned(y) => Cow::Owned(PathBuf::from(y)),\n+        })\n+    }\n+\n+    /// Read a null-terminated sequence of `u16`s, and perform path separator conversion if needed.\n+    fn read_path_from_wide_str(\n+        &self,\n+        ptr: Pointer<Option<Provenance>>,\n+    ) -> InterpResult<'tcx, PathBuf> {\n+        let this = self.eval_context_ref();\n+        let os_str = this.read_os_str_from_wide_str(ptr)?;\n+\n+        Ok(this\n+            .convert_path_separator(Cow::Owned(os_str), PathConversion::TargetToHost)\n+            .into_owned()\n+            .into())\n+    }\n+\n+    /// Write a Path to the machine memory (as a null-terminated sequence of bytes),\n+    /// adjusting path separators if needed.\n+    fn write_path_to_c_str(\n+        &mut self,\n+        path: &Path,\n+        ptr: Pointer<Option<Provenance>>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        let this = self.eval_context_mut();\n+        let os_str = this\n+            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        this.write_os_str_to_c_str(&os_str, ptr, size)\n+    }\n+\n+    /// Write a Path to the machine memory (as a null-terminated sequence of `u16`s),\n+    /// adjusting path separators if needed.\n+    fn write_path_to_wide_str(\n+        &mut self,\n+        path: &Path,\n+        ptr: Pointer<Option<Provenance>>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        let this = self.eval_context_mut();\n+        let os_str = this\n+            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        this.write_os_str_to_wide_str(&os_str, ptr, size)\n+    }\n+\n+    /// Allocate enough memory to store a Path as a null-terminated sequence of bytes,\n+    /// adjusting path separators if needed.\n+    fn alloc_path_as_c_str(\n+        &mut self,\n+        path: &Path,\n+        memkind: MemoryKind<MiriMemoryKind>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let this = self.eval_context_mut();\n+        let os_str = this\n+            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        this.alloc_os_str_as_c_str(&os_str, memkind)\n+    }\n+\n+    fn convert_path_separator<'a>(\n+        &self,\n+        os_str: Cow<'a, OsStr>,\n+        direction: PathConversion,\n+    ) -> Cow<'a, OsStr> {\n+        let this = self.eval_context_ref();\n+        let target_os = &this.tcx.sess.target.os;\n+        #[cfg(windows)]\n+        return if target_os == \"windows\" {\n+            // Windows-on-Windows, all fine.\n+            os_str\n+        } else {\n+            // Unix target, Windows host.\n+            let (from, to) = match direction {\n+                PathConversion::HostToTarget => ('\\\\', '/'),\n+                PathConversion::TargetToHost => ('/', '\\\\'),\n+            };\n+            let converted = os_str\n+                .encode_wide()\n+                .map(|wchar| if wchar == from as u16 { to as u16 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(OsString::from_wide(&converted))\n+        };\n+        #[cfg(unix)]\n+        return if target_os == \"windows\" {\n+            // Windows target, Unix host.\n+            let (from, to) = match direction {\n+                PathConversion::HostToTarget => ('/', '\\\\'),\n+                PathConversion::TargetToHost => ('\\\\', '/'),\n+            };\n+            let converted = os_str\n+                .as_bytes()\n+                .iter()\n+                .map(|&wchar| if wchar == from as u8 { to as u8 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(OsString::from_vec(converted))\n+        } else {\n+            // Unix-on-Unix, all is fine.\n+            os_str\n+        };\n+    }\n+}"}, {"sha": "2e8245acf4a68daf2a12e3a0a64e7e049b78f5c5", "filename": "src/tools/miri/src/shims/panic.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,227 @@\n+//! Panic runtime for Miri.\n+//!\n+//! The core pieces of the runtime are:\n+//! - An implementation of `__rust_maybe_catch_panic` that pushes the invoked stack frame with\n+//!   some extra metadata derived from the panic-catching arguments of `__rust_maybe_catch_panic`.\n+//! - A hack in `libpanic_unwind` that calls the `miri_start_panic` intrinsic instead of the\n+//!   target-native panic runtime. (This lives in the rustc repo.)\n+//! - An implementation of `miri_start_panic` that stores its argument (the panic payload), and then\n+//!   immediately returns, but on the *unwind* edge (not the normal return edge), thus initiating unwinding.\n+//! - A hook executed each time a frame is popped, such that if the frame pushed by `__rust_maybe_catch_panic`\n+//!   gets popped *during unwinding*, we take the panic payload and store it according to the extra\n+//!   metadata we remembered when pushing said frame.\n+\n+use log::trace;\n+\n+use rustc_ast::Mutability;\n+use rustc_middle::{mir, ty};\n+use rustc_span::Symbol;\n+use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::PanicStrategy;\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+\n+/// Holds all of the relevant data for when unwinding hits a `try` frame.\n+#[derive(Debug)]\n+pub struct CatchUnwindData<'tcx> {\n+    /// The `catch_fn` callback to call in case of a panic.\n+    catch_fn: Pointer<Option<Provenance>>,\n+    /// The `data` argument for that callback.\n+    data: Scalar<Provenance>,\n+    /// The return place from the original call to `try`.\n+    dest: PlaceTy<'tcx, Provenance>,\n+    /// The return block from the original call to `try`.\n+    ret: mir::BasicBlock,\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Handles the special `miri_start_panic` intrinsic, which is called\n+    /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n+    fn handle_miri_start_panic(\n+        &mut self,\n+        abi: Abi,\n+        link_name: Symbol,\n+        args: &[OpTy<'tcx, Provenance>],\n+        unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        trace!(\"miri_start_panic: {:?}\", this.frame().instance);\n+\n+        // Get the raw pointer stored in arg[0] (the panic payload).\n+        let [payload] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+        let payload = this.read_scalar(payload)?;\n+        let thread = this.active_thread_mut();\n+        assert!(thread.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n+        thread.panic_payload = Some(payload);\n+\n+        // Jump to the unwind block to begin unwinding.\n+        this.unwind_to_block(unwind)?;\n+        Ok(())\n+    }\n+\n+    /// Handles the `try` intrinsic, the underlying implementation of `std::panicking::try`.\n+    fn handle_try(\n+        &mut self,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: mir::BasicBlock,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        // Signature:\n+        //   fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32\n+        // Calls `try_fn` with `data` as argument. If that executes normally, returns 0.\n+        // If that unwinds, calls `catch_fn` with the first argument being `data` and\n+        // then second argument being a target-dependent `payload` (i.e. it is up to us to define\n+        // what that is), and returns 1.\n+        // The `payload` is passed (by libstd) to `__rust_panic_cleanup`, which is then expected to\n+        // return a `Box<dyn Any + Send + 'static>`.\n+        // In Miri, `miri_start_panic` is passed exactly that type, so we make the `payload` simply\n+        // a pointer to `Box<dyn Any + Send + 'static>`.\n+\n+        // Get all the arguments.\n+        let [try_fn, data, catch_fn] = check_arg_count(args)?;\n+        let try_fn = this.read_pointer(try_fn)?;\n+        let data = this.read_scalar(data)?;\n+        let catch_fn = this.read_pointer(catch_fn)?;\n+\n+        // Now we make a function call, and pass `data` as first and only argument.\n+        let f_instance = this.get_ptr_fn(try_fn)?.as_instance()?;\n+        trace!(\"try_fn: {:?}\", f_instance);\n+        this.call_function(\n+            f_instance,\n+            Abi::Rust,\n+            &[data.into()],\n+            None,\n+            // Directly return to caller.\n+            StackPopCleanup::Goto { ret: Some(ret), unwind: StackPopUnwind::Skip },\n+        )?;\n+\n+        // We ourselves will return `0`, eventually (will be overwritten if we catch a panic).\n+        this.write_null(dest)?;\n+\n+        // In unwind mode, we tag this frame with the extra data needed to catch unwinding.\n+        // This lets `handle_stack_pop` (below) know that we should stop unwinding\n+        // when we pop this frame.\n+        if this.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n+            this.frame_mut().extra.catch_unwind =\n+                Some(CatchUnwindData { catch_fn, data, dest: dest.clone(), ret });\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn handle_stack_pop_unwind(\n+        &mut self,\n+        mut extra: FrameData<'tcx>,\n+        unwinding: bool,\n+    ) -> InterpResult<'tcx, StackPopJump> {\n+        let this = self.eval_context_mut();\n+        trace!(\"handle_stack_pop_unwind(extra = {:?}, unwinding = {})\", extra, unwinding);\n+\n+        // We only care about `catch_panic` if we're unwinding - if we're doing a normal\n+        // return, then we don't need to do anything special.\n+        if let (true, Some(catch_unwind)) = (unwinding, extra.catch_unwind.take()) {\n+            // We've just popped a frame that was pushed by `try`,\n+            // and we are unwinding, so we should catch that.\n+            trace!(\n+                \"unwinding: found catch_panic frame during unwinding: {:?}\",\n+                this.frame().instance\n+            );\n+\n+            // We set the return value of `try` to 1, since there was a panic.\n+            this.write_scalar(Scalar::from_i32(1), &catch_unwind.dest)?;\n+\n+            // The Thread's `panic_payload` holds what was passed to `miri_start_panic`.\n+            // This is exactly the second argument we need to pass to `catch_fn`.\n+            let payload = this.active_thread_mut().panic_payload.take().unwrap();\n+\n+            // Push the `catch_fn` stackframe.\n+            let f_instance = this.get_ptr_fn(catch_unwind.catch_fn)?.as_instance()?;\n+            trace!(\"catch_fn: {:?}\", f_instance);\n+            this.call_function(\n+                f_instance,\n+                Abi::Rust,\n+                &[catch_unwind.data.into(), payload.into()],\n+                None,\n+                // Directly return to caller of `try`.\n+                StackPopCleanup::Goto { ret: Some(catch_unwind.ret), unwind: StackPopUnwind::Skip },\n+            )?;\n+\n+            // We pushed a new stack frame, the engine should not do any jumping now!\n+            Ok(StackPopJump::NoJump)\n+        } else {\n+            Ok(StackPopJump::Normal)\n+        }\n+    }\n+\n+    /// Start a panic in the interpreter with the given message as payload.\n+    fn start_panic(&mut self, msg: &str, unwind: StackPopUnwind) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        // First arg: message.\n+        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into(), Mutability::Not);\n+\n+        // Call the lang item.\n+        let panic = this.tcx.lang_items().panic_fn().unwrap();\n+        let panic = ty::Instance::mono(this.tcx.tcx, panic);\n+        this.call_function(\n+            panic,\n+            Abi::Rust,\n+            &[msg.to_ref(this)],\n+            None,\n+            StackPopCleanup::Goto { ret: None, unwind },\n+        )\n+    }\n+\n+    fn assert_panic(\n+        &mut self,\n+        msg: &mir::AssertMessage<'tcx>,\n+        unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        use rustc_middle::mir::AssertKind::*;\n+        let this = self.eval_context_mut();\n+\n+        match msg {\n+            BoundsCheck { index, len } => {\n+                // Forward to `panic_bounds_check` lang item.\n+\n+                // First arg: index.\n+                let index = this.read_scalar(&this.eval_operand(index, None)?)?;\n+                // Second arg: len.\n+                let len = this.read_scalar(&this.eval_operand(len, None)?)?;\n+\n+                // Call the lang item.\n+                let panic_bounds_check = this.tcx.lang_items().panic_bounds_check_fn().unwrap();\n+                let panic_bounds_check = ty::Instance::mono(this.tcx.tcx, panic_bounds_check);\n+                this.call_function(\n+                    panic_bounds_check,\n+                    Abi::Rust,\n+                    &[index.into(), len.into()],\n+                    None,\n+                    StackPopCleanup::Goto {\n+                        ret: None,\n+                        unwind: match unwind {\n+                            Some(cleanup) => StackPopUnwind::Cleanup(cleanup),\n+                            None => StackPopUnwind::Skip,\n+                        },\n+                    },\n+                )?;\n+            }\n+            _ => {\n+                // Forward everything else to `panic` lang item.\n+                this.start_panic(\n+                    msg.description(),\n+                    match unwind {\n+                        Some(cleanup) => StackPopUnwind::Cleanup(cleanup),\n+                        None => StackPopUnwind::Skip,\n+                    },\n+                )?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "24fe52453939653720cf1286ae286f80829b85ef", "filename": "src/tools/miri/src/shims/time.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,255 @@\n+use std::time::{Duration, SystemTime};\n+\n+use crate::*;\n+\n+/// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n+pub fn system_time_to_duration<'tcx>(time: &SystemTime) -> InterpResult<'tcx, Duration> {\n+    time.duration_since(SystemTime::UNIX_EPOCH)\n+        .map_err(|_| err_unsup_format!(\"times before the Unix epoch are not supported\").into())\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn clock_gettime(\n+        &mut self,\n+        clk_id_op: &OpTy<'tcx, Provenance>,\n+        tp_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        // This clock support is deliberately minimal because a lot of clock types have fiddly\n+        // properties (is it possible for Miri to be suspended independently of the host?). If you\n+        // have a use for another clock type, please open an issue.\n+\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os(\"linux\", \"clock_gettime\");\n+\n+        let clk_id = this.read_scalar(clk_id_op)?.to_i32()?;\n+\n+        // Linux has two main kinds of clocks. REALTIME clocks return the actual time since the\n+        // Unix epoch, including effects which may cause time to move backwards such as NTP.\n+        // Linux further distinguishes regular and \"coarse\" clocks, but the \"coarse\" version\n+        // is just specified to be \"faster and less precise\", so we implement both the same way.\n+        let absolute_clocks =\n+            [this.eval_libc_i32(\"CLOCK_REALTIME\")?, this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\")?];\n+        // The second kind is MONOTONIC clocks for which 0 is an arbitrary time point, but they are\n+        // never allowed to go backwards. We don't need to do any additonal monotonicity\n+        // enforcement because std::time::Instant already guarantees that it is monotonic.\n+        let relative_clocks =\n+            [this.eval_libc_i32(\"CLOCK_MONOTONIC\")?, this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\")?];\n+\n+        let duration = if absolute_clocks.contains(&clk_id) {\n+            this.check_no_isolation(\"`clock_gettime` with `REALTIME` clocks\")?;\n+            system_time_to_duration(&SystemTime::now())?\n+        } else if relative_clocks.contains(&clk_id) {\n+            this.machine.clock.now().duration_since(this.machine.clock.anchor())\n+        } else {\n+            let einval = this.eval_libc(\"EINVAL\")?;\n+            this.set_last_error(einval)?;\n+            return Ok(Scalar::from_i32(-1));\n+        };\n+\n+        let tv_sec = duration.as_secs();\n+        let tv_nsec = duration.subsec_nanos();\n+\n+        this.write_int_fields(&[tv_sec.into(), tv_nsec.into()], &this.deref_operand(tp_op)?)?;\n+\n+        Ok(Scalar::from_i32(0))\n+    }\n+\n+    fn gettimeofday(\n+        &mut self,\n+        tv_op: &OpTy<'tcx, Provenance>,\n+        tz_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os_is_unix(\"gettimeofday\");\n+        this.check_no_isolation(\"`gettimeofday`\")?;\n+\n+        // Using tz is obsolete and should always be null\n+        let tz = this.read_pointer(tz_op)?;\n+        if !this.ptr_is_null(tz)? {\n+            let einval = this.eval_libc(\"EINVAL\")?;\n+            this.set_last_error(einval)?;\n+            return Ok(-1);\n+        }\n+\n+        let duration = system_time_to_duration(&SystemTime::now())?;\n+        let tv_sec = duration.as_secs();\n+        let tv_usec = duration.subsec_micros();\n+\n+        this.write_int_fields(&[tv_sec.into(), tv_usec.into()], &this.deref_operand(tv_op)?)?;\n+\n+        Ok(0)\n+    }\n+\n+    #[allow(non_snake_case, clippy::integer_arithmetic)]\n+    fn GetSystemTimeAsFileTime(\n+        &mut self,\n+        LPFILETIME_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os(\"windows\", \"GetSystemTimeAsFileTime\");\n+        this.check_no_isolation(\"`GetSystemTimeAsFileTime`\")?;\n+\n+        let NANOS_PER_SEC = this.eval_windows_u64(\"time\", \"NANOS_PER_SEC\")?;\n+        let INTERVALS_PER_SEC = this.eval_windows_u64(\"time\", \"INTERVALS_PER_SEC\")?;\n+        let INTERVALS_TO_UNIX_EPOCH = this.eval_windows_u64(\"time\", \"INTERVALS_TO_UNIX_EPOCH\")?;\n+        let NANOS_PER_INTERVAL = NANOS_PER_SEC / INTERVALS_PER_SEC;\n+        let SECONDS_TO_UNIX_EPOCH = INTERVALS_TO_UNIX_EPOCH / INTERVALS_PER_SEC;\n+\n+        let duration = system_time_to_duration(&SystemTime::now())?\n+            + Duration::from_secs(SECONDS_TO_UNIX_EPOCH);\n+        let duration_ticks = u64::try_from(duration.as_nanos() / u128::from(NANOS_PER_INTERVAL))\n+            .map_err(|_| err_unsup_format!(\"programs running more than 2^64 Windows ticks after the Windows epoch are not supported\"))?;\n+\n+        let dwLowDateTime = u32::try_from(duration_ticks & 0x00000000FFFFFFFF).unwrap();\n+        let dwHighDateTime = u32::try_from((duration_ticks & 0xFFFFFFFF00000000) >> 32).unwrap();\n+        this.write_int_fields(\n+            &[dwLowDateTime.into(), dwHighDateTime.into()],\n+            &this.deref_operand(LPFILETIME_op)?,\n+        )?;\n+\n+        Ok(())\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn QueryPerformanceCounter(\n+        &mut self,\n+        lpPerformanceCount_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os(\"windows\", \"QueryPerformanceCounter\");\n+\n+        // QueryPerformanceCounter uses a hardware counter as its basis.\n+        // Miri will emulate a counter with a resolution of 1 nanosecond.\n+        let duration = this.machine.clock.now().duration_since(this.machine.clock.anchor());\n+        let qpc = i64::try_from(duration.as_nanos()).map_err(|_| {\n+            err_unsup_format!(\"programs running longer than 2^63 nanoseconds are not supported\")\n+        })?;\n+        this.write_scalar(\n+            Scalar::from_i64(qpc),\n+            &this.deref_operand(lpPerformanceCount_op)?.into(),\n+        )?;\n+        Ok(-1) // return non-zero on success\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn QueryPerformanceFrequency(\n+        &mut self,\n+        lpFrequency_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os(\"windows\", \"QueryPerformanceFrequency\");\n+\n+        // Retrieves the frequency of the hardware performance counter.\n+        // The frequency of the performance counter is fixed at system boot and\n+        // is consistent across all processors.\n+        // Miri emulates a \"hardware\" performance counter with a resolution of 1ns,\n+        // and thus 10^9 counts per second.\n+        this.write_scalar(\n+            Scalar::from_i64(1_000_000_000),\n+            &this.deref_operand(lpFrequency_op)?.into(),\n+        )?;\n+        Ok(-1) // Return non-zero on success\n+    }\n+\n+    fn mach_absolute_time(&self) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_ref();\n+\n+        this.assert_target_os(\"macos\", \"mach_absolute_time\");\n+\n+        // This returns a u64, with time units determined dynamically by `mach_timebase_info`.\n+        // We return plain nanoseconds.\n+        let duration = this.machine.clock.now().duration_since(this.machine.clock.anchor());\n+        let res = u64::try_from(duration.as_nanos()).map_err(|_| {\n+            err_unsup_format!(\"programs running longer than 2^64 nanoseconds are not supported\")\n+        })?;\n+        Ok(Scalar::from_u64(res))\n+    }\n+\n+    fn mach_timebase_info(\n+        &mut self,\n+        info_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os(\"macos\", \"mach_timebase_info\");\n+\n+        let info = this.deref_operand(info_op)?;\n+\n+        // Since our emulated ticks in `mach_absolute_time` *are* nanoseconds,\n+        // no scaling needs to happen.\n+        let (numer, denom) = (1, 1);\n+        this.write_int_fields(&[numer.into(), denom.into()], &info)?;\n+\n+        Ok(Scalar::from_i32(0)) // KERN_SUCCESS\n+    }\n+\n+    fn nanosleep(\n+        &mut self,\n+        req_op: &OpTy<'tcx, Provenance>,\n+        _rem: &OpTy<'tcx, Provenance>, // Signal handlers are not supported, so rem will never be written to.\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os_is_unix(\"nanosleep\");\n+\n+        let duration = match this.read_timespec(&this.deref_operand(req_op)?)? {\n+            Some(duration) => duration,\n+            None => {\n+                let einval = this.eval_libc(\"EINVAL\")?;\n+                this.set_last_error(einval)?;\n+                return Ok(-1);\n+            }\n+        };\n+        // If adding the duration overflows, let's just sleep for an hour. Waking up early is always acceptable.\n+        let now = this.machine.clock.now();\n+        let timeout_time = now\n+            .checked_add(duration)\n+            .unwrap_or_else(|| now.checked_add(Duration::from_secs(3600)).unwrap());\n+\n+        let active_thread = this.get_active_thread();\n+        this.block_thread(active_thread);\n+\n+        this.register_timeout_callback(\n+            active_thread,\n+            Time::Monotonic(timeout_time),\n+            Box::new(move |ecx| {\n+                ecx.unblock_thread(active_thread);\n+                Ok(())\n+            }),\n+        );\n+\n+        Ok(0)\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn Sleep(&mut self, timeout: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os(\"windows\", \"Sleep\");\n+\n+        let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n+\n+        let duration = Duration::from_millis(timeout_ms.into());\n+        let timeout_time = this.machine.clock.now().checked_add(duration).unwrap();\n+\n+        let active_thread = this.get_active_thread();\n+        this.block_thread(active_thread);\n+\n+        this.register_timeout_callback(\n+            active_thread,\n+            Time::Monotonic(timeout_time),\n+            Box::new(move |ecx| {\n+                ecx.unblock_thread(active_thread);\n+                Ok(())\n+            }),\n+        );\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "d93d6a16a0736fe87883ef739895ddcd79e96dfb", "filename": "src/tools/miri/src/shims/tls.rs", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,400 @@\n+//! Implement thread-local storage.\n+\n+use std::collections::btree_map::Entry as BTreeEntry;\n+use std::collections::hash_map::Entry as HashMapEntry;\n+use std::collections::BTreeMap;\n+\n+use log::trace;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty;\n+use rustc_target::abi::{HasDataLayout, Size};\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::*;\n+\n+pub type TlsKey = u128;\n+\n+#[derive(Clone, Debug)]\n+pub struct TlsEntry<'tcx> {\n+    /// The data for this key. None is used to represent NULL.\n+    /// (We normalize this early to avoid having to do a NULL-ptr-test each time we access the data.)\n+    data: BTreeMap<ThreadId, Scalar<Provenance>>,\n+    dtor: Option<ty::Instance<'tcx>>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct RunningDtorsState {\n+    /// The last TlsKey used to retrieve a TLS destructor. `None` means that we\n+    /// have not tried to retrieve a TLS destructor yet or that we already tried\n+    /// all keys.\n+    last_dtor_key: Option<TlsKey>,\n+}\n+\n+#[derive(Debug)]\n+pub struct TlsData<'tcx> {\n+    /// The Key to use for the next thread-local allocation.\n+    next_key: TlsKey,\n+\n+    /// pthreads-style thread-local storage.\n+    keys: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+\n+    /// A single per thread destructor of the thread local storage (that's how\n+    /// things work on macOS) with a data argument.\n+    macos_thread_dtors: BTreeMap<ThreadId, (ty::Instance<'tcx>, Scalar<Provenance>)>,\n+\n+    /// State for currently running TLS dtors. If this map contains a key for a\n+    /// specific thread, it means that we are in the \"destruct\" phase, during\n+    /// which some operations are UB.\n+    dtors_running: FxHashMap<ThreadId, RunningDtorsState>,\n+}\n+\n+impl<'tcx> Default for TlsData<'tcx> {\n+    fn default() -> Self {\n+        TlsData {\n+            next_key: 1, // start with 1 as we must not use 0 on Windows\n+            keys: Default::default(),\n+            macos_thread_dtors: Default::default(),\n+            dtors_running: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TlsData<'tcx> {\n+    /// Generate a new TLS key with the given destructor.\n+    /// `max_size` determines the integer size the key has to fit in.\n+    #[allow(clippy::integer_arithmetic)]\n+    pub fn create_tls_key(\n+        &mut self,\n+        dtor: Option<ty::Instance<'tcx>>,\n+        max_size: Size,\n+    ) -> InterpResult<'tcx, TlsKey> {\n+        let new_key = self.next_key;\n+        self.next_key += 1;\n+        self.keys.try_insert(new_key, TlsEntry { data: Default::default(), dtor }).unwrap();\n+        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n+\n+        if max_size.bits() < 128 && new_key >= (1u128 << max_size.bits()) {\n+            throw_unsup_format!(\"we ran out of TLS key space\");\n+        }\n+        Ok(new_key)\n+    }\n+\n+    pub fn delete_tls_key(&mut self, key: TlsKey) -> InterpResult<'tcx> {\n+        match self.keys.remove(&key) {\n+            Some(_) => {\n+                trace!(\"TLS key {} removed\", key);\n+                Ok(())\n+            }\n+            None => throw_ub_format!(\"removing a non-existig TLS key: {}\", key),\n+        }\n+    }\n+\n+    pub fn load_tls(\n+        &self,\n+        key: TlsKey,\n+        thread_id: ThreadId,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        match self.keys.get(&key) {\n+            Some(TlsEntry { data, .. }) => {\n+                let value = data.get(&thread_id).copied();\n+                trace!(\"TLS key {} for thread {:?} loaded: {:?}\", key, thread_id, value);\n+                Ok(value.unwrap_or_else(|| Scalar::null_ptr(cx)))\n+            }\n+            None => throw_ub_format!(\"loading from a non-existing TLS key: {}\", key),\n+        }\n+    }\n+\n+    pub fn store_tls(\n+        &mut self,\n+        key: TlsKey,\n+        thread_id: ThreadId,\n+        new_data: Scalar<Provenance>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx> {\n+        match self.keys.get_mut(&key) {\n+            Some(TlsEntry { data, .. }) => {\n+                if new_data.to_machine_usize(cx)? != 0 {\n+                    trace!(\"TLS key {} for thread {:?} stored: {:?}\", key, thread_id, new_data);\n+                    data.insert(thread_id, new_data);\n+                } else {\n+                    trace!(\"TLS key {} for thread {:?} removed\", key, thread_id);\n+                    data.remove(&thread_id);\n+                }\n+                Ok(())\n+            }\n+            None => throw_ub_format!(\"storing to a non-existing TLS key: {}\", key),\n+        }\n+    }\n+\n+    /// Set the thread wide destructor of the thread local storage for the given\n+    /// thread. This function is used to implement `_tlv_atexit` shim on MacOS.\n+    ///\n+    /// Thread wide dtors are available only on MacOS. There is one destructor\n+    /// per thread as can be guessed from the following comment in the\n+    /// [`_tlv_atexit`\n+    /// implementation](https://github.com/opensource-apple/dyld/blob/195030646877261f0c8c7ad8b001f52d6a26f514/src/threadLocalVariables.c#L389):\n+    ///\n+    /// NOTE: this does not need locks because it only operates on current thread data\n+    pub fn set_macos_thread_dtor(\n+        &mut self,\n+        thread: ThreadId,\n+        dtor: ty::Instance<'tcx>,\n+        data: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        if self.dtors_running.contains_key(&thread) {\n+            // UB, according to libstd docs.\n+            throw_ub_format!(\n+                \"setting thread's local storage destructor while destructors are already running\"\n+            );\n+        }\n+        if self.macos_thread_dtors.insert(thread, (dtor, data)).is_some() {\n+            throw_unsup_format!(\n+                \"setting more than one thread local storage destructor for the same thread is not supported\"\n+            );\n+        }\n+        Ok(())\n+    }\n+\n+    /// Returns a dtor, its argument and its index, if one is supposed to run.\n+    /// `key` is the last dtors that was run; we return the *next* one after that.\n+    ///\n+    /// An optional destructor function may be associated with each key value.\n+    /// At thread exit, if a key value has a non-NULL destructor pointer,\n+    /// and the thread has a non-NULL value associated with that key,\n+    /// the value of the key is set to NULL, and then the function pointed\n+    /// to is called with the previously associated value as its sole argument.\n+    /// **The order of destructor calls is unspecified if more than one destructor\n+    /// exists for a thread when it exits.**\n+    ///\n+    /// If, after all the destructors have been called for all non-NULL values\n+    /// with associated destructors, there are still some non-NULL values with\n+    /// associated destructors, then the process is repeated.\n+    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n+    /// calls for outstanding non-NULL values, there are still some non-NULL values\n+    /// with associated destructors, implementations may stop calling destructors,\n+    /// or they may continue calling destructors until no non-NULL values with\n+    /// associated destructors exist, even though this might result in an infinite loop.\n+    fn fetch_tls_dtor(\n+        &mut self,\n+        key: Option<TlsKey>,\n+        thread_id: ThreadId,\n+    ) -> Option<(ty::Instance<'tcx>, Scalar<Provenance>, TlsKey)> {\n+        use std::ops::Bound::*;\n+\n+        let thread_local = &mut self.keys;\n+        let start = match key {\n+            Some(key) => Excluded(key),\n+            None => Unbounded,\n+        };\n+        // We interpret the documentaion above (taken from POSIX) as saying that we need to iterate\n+        // over all keys and run each destructor at least once before running any destructor a 2nd\n+        // time. That's why we have `key` to indicate how far we got in the current iteration. If we\n+        // return `None`, `schedule_next_pthread_tls_dtor` will re-try with `ket` set to `None` to\n+        // start the next round.\n+        // TODO: In the future, we might consider randomizing destructor order, but we still have to\n+        // uphold this requirement.\n+        for (&key, TlsEntry { data, dtor }) in thread_local.range_mut((start, Unbounded)) {\n+            match data.entry(thread_id) {\n+                BTreeEntry::Occupied(entry) => {\n+                    if let Some(dtor) = dtor {\n+                        // Set TLS data to NULL, and call dtor with old value.\n+                        let data_scalar = entry.remove();\n+                        let ret = Some((*dtor, data_scalar, key));\n+                        return ret;\n+                    }\n+                }\n+                BTreeEntry::Vacant(_) => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Set that dtors are running for `thread`. It is guaranteed not to change\n+    /// the existing values stored in `dtors_running` for this thread. Returns\n+    /// `true` if dtors for `thread` are already running.\n+    fn set_dtors_running_for_thread(&mut self, thread: ThreadId) -> bool {\n+        match self.dtors_running.entry(thread) {\n+            HashMapEntry::Occupied(_) => true,\n+            HashMapEntry::Vacant(entry) => {\n+                // We cannot just do `self.dtors_running.insert` because that\n+                // would overwrite `last_dtor_key` with `None`.\n+                entry.insert(RunningDtorsState { last_dtor_key: None });\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Delete all TLS entries for the given thread. This function should be\n+    /// called after all TLS destructors have already finished.\n+    fn delete_all_thread_tls(&mut self, thread_id: ThreadId) {\n+        for TlsEntry { data, .. } in self.keys.values_mut() {\n+            data.remove(&thread_id);\n+        }\n+    }\n+\n+    pub fn iter(&self, mut visitor: impl FnMut(&Scalar<Provenance>)) {\n+        for scalar in self.keys.values().flat_map(|v| v.data.values()) {\n+            visitor(scalar);\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Schedule TLS destructors for Windows.\n+    /// On windows, TLS destructors are managed by std.\n+    fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let active_thread = this.get_active_thread();\n+\n+        // Windows has a special magic linker section that is run on certain events.\n+        // Instead of searching for that section and supporting arbitrary hooks in there\n+        // (that would be basically https://github.com/rust-lang/miri/issues/450),\n+        // we specifically look up the static in libstd that we know is placed\n+        // in that section.\n+        let thread_callback =\n+            this.eval_windows(\"thread_local_key\", \"p_thread_callback\")?.to_pointer(this)?;\n+        let thread_callback = this.get_ptr_fn(thread_callback)?.as_instance()?;\n+\n+        // FIXME: Technically, the reason should be `DLL_PROCESS_DETACH` when the main thread exits\n+        // but std treats both the same.\n+        let reason = this.eval_windows(\"c\", \"DLL_THREAD_DETACH\")?;\n+\n+        // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n+        // FIXME: `h` should be a handle to the current module and what `pv` should be is unknown\n+        // but both are ignored by std\n+        this.call_function(\n+            thread_callback,\n+            Abi::System { unwind: false },\n+            &[Scalar::null_ptr(this).into(), reason.into(), Scalar::null_ptr(this).into()],\n+            None,\n+            StackPopCleanup::Root { cleanup: true },\n+        )?;\n+\n+        this.enable_thread(active_thread);\n+        Ok(())\n+    }\n+\n+    /// Schedule the MacOS thread destructor of the thread local storage to be\n+    /// executed. Returns `true` if scheduled.\n+    ///\n+    /// Note: It is safe to call this function also on other Unixes.\n+    fn schedule_macos_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n+        let this = self.eval_context_mut();\n+        let thread_id = this.get_active_thread();\n+        if let Some((instance, data)) = this.machine.tls.macos_thread_dtors.remove(&thread_id) {\n+            trace!(\"Running macos dtor {:?} on {:?} at {:?}\", instance, data, thread_id);\n+\n+            this.call_function(\n+                instance,\n+                Abi::C { unwind: false },\n+                &[data.into()],\n+                None,\n+                StackPopCleanup::Root { cleanup: true },\n+            )?;\n+\n+            // Enable the thread so that it steps through the destructor which\n+            // we just scheduled. Since we deleted the destructor, it is\n+            // guaranteed that we will schedule it again. The `dtors_running`\n+            // flag will prevent the code from adding the destructor again.\n+            this.enable_thread(thread_id);\n+            Ok(true)\n+        } else {\n+            Ok(false)\n+        }\n+    }\n+\n+    /// Schedule a pthread TLS destructor. Returns `true` if found\n+    /// a destructor to schedule, and `false` otherwise.\n+    fn schedule_next_pthread_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n+        let this = self.eval_context_mut();\n+        let active_thread = this.get_active_thread();\n+\n+        assert!(this.has_terminated(active_thread), \"running TLS dtors for non-terminated thread\");\n+        // Fetch next dtor after `key`.\n+        let last_key = this.machine.tls.dtors_running[&active_thread].last_dtor_key;\n+        let dtor = match this.machine.tls.fetch_tls_dtor(last_key, active_thread) {\n+            dtor @ Some(_) => dtor,\n+            // We ran each dtor once, start over from the beginning.\n+            None => this.machine.tls.fetch_tls_dtor(None, active_thread),\n+        };\n+        if let Some((instance, ptr, key)) = dtor {\n+            this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key =\n+                Some(key);\n+            trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, active_thread);\n+            assert!(\n+                !ptr.to_machine_usize(this).unwrap() != 0,\n+                \"data can't be NULL when dtor is called!\"\n+            );\n+\n+            this.call_function(\n+                instance,\n+                Abi::C { unwind: false },\n+                &[ptr.into()],\n+                None,\n+                StackPopCleanup::Root { cleanup: true },\n+            )?;\n+\n+            this.enable_thread(active_thread);\n+            return Ok(true);\n+        }\n+        this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key = None;\n+\n+        Ok(false)\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Schedule an active thread's TLS destructor to run on the active thread.\n+    /// Note that this function does not run the destructors itself, it just\n+    /// schedules them one by one each time it is called and reenables the\n+    /// thread so that it can be executed normally by the main execution loop.\n+    ///\n+    /// Note: we consistently run TLS destructors for all threads, including the\n+    /// main thread. However, it is not clear that we should run the TLS\n+    /// destructors for the main thread. See issue:\n+    /// <https://github.com/rust-lang/rust/issues/28129>.\n+    fn schedule_next_tls_dtor_for_active_thread(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let active_thread = this.get_active_thread();\n+        trace!(\"schedule_next_tls_dtor_for_active_thread on thread {:?}\", active_thread);\n+\n+        if !this.machine.tls.set_dtors_running_for_thread(active_thread) {\n+            // This is the first time we got asked to schedule a destructor. The\n+            // Windows schedule destructor function must be called exactly once,\n+            // this is why it is in this block.\n+            if this.tcx.sess.target.os == \"windows\" {\n+                // On Windows, we signal that the thread quit by starting the\n+                // relevant function, reenabling the thread, and going back to\n+                // the scheduler.\n+                this.schedule_windows_tls_dtors()?;\n+                return Ok(());\n+            }\n+        }\n+        // The remaining dtors make some progress each time around the scheduler loop,\n+        // until they return `false` to indicate that they are done.\n+\n+        // The macOS thread wide destructor runs \"before any TLS slots get\n+        // freed\", so do that first.\n+        if this.schedule_macos_tls_dtor()? {\n+            // We have scheduled a MacOS dtor to run on the thread. Execute it\n+            // to completion and come back here. Scheduling a destructor\n+            // destroys it, so we will not enter this branch again.\n+            return Ok(());\n+        }\n+        if this.schedule_next_pthread_tls_dtor()? {\n+            // We have scheduled a pthread destructor and removed it from the\n+            // destructors list. Run it to completion and come back here.\n+            return Ok(());\n+        }\n+\n+        // All dtors done!\n+        this.machine.tls.delete_all_thread_tls(active_thread);\n+        this.thread_terminated()?;\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "4cb78d4dabdcfd910cf9af0d5102448db9551fba", "filename": "src/tools/miri/src/shims/unix/android/dlsym.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fdlsym.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,54 @@\n+use rustc_middle::mir;\n+\n+use crate::helpers::check_arg_count;\n+use crate::*;\n+\n+#[derive(Debug, Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+pub enum Dlsym {\n+    signal,\n+}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str<'tcx>(name: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n+        Ok(match name {\n+            \"signal\" => Some(Dlsym::signal),\n+            \"android_set_abort_message\" => None,\n+            _ => throw_unsup_format!(\"unsupported Android dlsym: {}\", name),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let ret = ret.expect(\"we don't support any diverging dlsym\");\n+        assert!(this.tcx.sess.target.os == \"android\");\n+\n+        match dlsym {\n+            Dlsym::signal => {\n+                if !this.frame_in_std() {\n+                    throw_unsup_format!(\n+                        \"`signal` support is crude and just enough for libstd to work\"\n+                    );\n+                }\n+\n+                let &[ref _sig, ref _func] = check_arg_count(args)?;\n+                this.write_null(dest)?;\n+            }\n+        }\n+\n+        log::trace!(\"{:?}\", this.dump_place(**dest));\n+        this.go_to_block(ret);\n+        Ok(())\n+    }\n+}"}, {"sha": "756aed369f15b2c2042d9286f157c91fd6ed2085", "filename": "src/tools/miri/src/shims/unix/android/foreign_items.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fforeign_items.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,26 @@\n+use rustc_span::Symbol;\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::*;\n+use shims::foreign_items::EmulateByNameResult;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn emulate_foreign_item_by_name(\n+        &mut self,\n+        link_name: Symbol,\n+        _abi: Abi,\n+        _args: &[OpTy<'tcx, Provenance>],\n+        _dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n+        let _this = self.eval_context_mut();\n+        #[allow(clippy::match_single_binding)]\n+        match link_name.as_str() {\n+            _ => return Ok(EmulateByNameResult::NotSupported),\n+        }\n+\n+        #[allow(unreachable_code)]\n+        Ok(EmulateByNameResult::NeedsJumping)\n+    }\n+}"}, {"sha": "434f5f30b5a5689206655f20e623d99789556bb6", "filename": "src/tools/miri/src/shims/unix/android/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fandroid%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,2 @@\n+pub mod dlsym;\n+pub mod foreign_items;"}, {"sha": "8bc19d18f2b29858b0851ab1c819af10ffb5d0c8", "filename": "src/tools/miri/src/shims/unix/dlsym.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fdlsym.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,55 @@\n+use rustc_middle::mir;\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::*;\n+use shims::unix::android::dlsym as android;\n+use shims::unix::freebsd::dlsym as freebsd;\n+use shims::unix::linux::dlsym as linux;\n+use shims::unix::macos::dlsym as macos;\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum Dlsym {\n+    Android(android::Dlsym),\n+    FreeBsd(freebsd::Dlsym),\n+    Linux(linux::Dlsym),\n+    MacOs(macos::Dlsym),\n+}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str<'tcx>(name: &str, target_os: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n+        Ok(match target_os {\n+            \"android\" => android::Dlsym::from_str(name)?.map(Dlsym::Android),\n+            \"freebsd\" => freebsd::Dlsym::from_str(name)?.map(Dlsym::FreeBsd),\n+            \"linux\" => linux::Dlsym::from_str(name)?.map(Dlsym::Linux),\n+            \"macos\" => macos::Dlsym::from_str(name)?.map(Dlsym::MacOs),\n+            _ => panic!(\"unsupported Unix OS {target_os}\"),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_abi(abi, Abi::C { unwind: false })?;\n+\n+        match dlsym {\n+            Dlsym::Android(dlsym) =>\n+                android::EvalContextExt::call_dlsym(this, dlsym, args, dest, ret),\n+            Dlsym::FreeBsd(dlsym) =>\n+                freebsd::EvalContextExt::call_dlsym(this, dlsym, args, dest, ret),\n+            Dlsym::Linux(dlsym) => linux::EvalContextExt::call_dlsym(this, dlsym, args, dest, ret),\n+            Dlsym::MacOs(dlsym) => macos::EvalContextExt::call_dlsym(this, dlsym, args, dest, ret),\n+        }\n+    }\n+}"}, {"sha": "153e5852dcc882524391fc2a8745e89880906a5d", "filename": "src/tools/miri/src/shims/unix/foreign_items.rs", "status": "added", "additions": 606, "deletions": 0, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,606 @@\n+use std::ffi::OsStr;\n+\n+use log::trace;\n+\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_span::Symbol;\n+use rustc_target::abi::{Align, Size};\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::*;\n+use shims::foreign_items::EmulateByNameResult;\n+use shims::unix::fs::EvalContextExt as _;\n+use shims::unix::sync::EvalContextExt as _;\n+use shims::unix::thread::EvalContextExt as _;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn emulate_foreign_item_by_name(\n+        &mut self,\n+        link_name: Symbol,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n+        let this = self.eval_context_mut();\n+\n+        // See `fn emulate_foreign_item_by_name` in `shims/foreign_items.rs` for the general pattern.\n+        #[rustfmt::skip]\n+        match link_name.as_str() {\n+            // Environment related shims\n+            \"getenv\" => {\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.getenv(name)?;\n+                this.write_pointer(result, dest)?;\n+            }\n+            \"unsetenv\" => {\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.unsetenv(name)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"setenv\" => {\n+                let [name, value, overwrite] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.read_scalar(overwrite)?.to_i32()?;\n+                let result = this.setenv(name, value)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"getcwd\" => {\n+                let [buf, size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.getcwd(buf, size)?;\n+                this.write_pointer(result, dest)?;\n+            }\n+            \"chdir\" => {\n+                let [path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.chdir(path)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+\n+            // File related shims\n+            \"open\" | \"open64\" => {\n+                // `open` is variadic, the third argument is only present when the second argument has O_CREAT (or on linux O_TMPFILE, but miri doesn't support that) set\n+                this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n+                let result = this.open(args)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"close\" => {\n+                let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.close(fd)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"fcntl\" => {\n+                // `fcntl` is variadic. The argument count is checked based on the first argument\n+                // in `this.fcntl()`, so we do not use `check_shim` here.\n+                this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n+                let result = this.fcntl(args)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"read\" => {\n+                let [fd, buf, count] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let fd = this.read_scalar(fd)?.to_i32()?;\n+                let buf = this.read_pointer(buf)?;\n+                let count = this.read_scalar(count)?.to_machine_usize(this)?;\n+                let result = this.read(fd, buf, count)?;\n+                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+            }\n+            \"write\" => {\n+                let [fd, buf, n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let fd = this.read_scalar(fd)?.to_i32()?;\n+                let buf = this.read_pointer(buf)?;\n+                let count = this.read_scalar(n)?.to_machine_usize(this)?;\n+                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, count);\n+                let result = this.write(fd, buf, count)?;\n+                // Now, `result` is the value we return back to the program.\n+                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+            }\n+            \"unlink\" => {\n+                let [path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.unlink(path)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"symlink\" => {\n+                let [target, linkpath] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.symlink(target, linkpath)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"rename\" => {\n+                let [oldpath, newpath] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.rename(oldpath, newpath)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"mkdir\" => {\n+                let [path, mode] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.mkdir(path, mode)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"rmdir\" => {\n+                let [path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.rmdir(path)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"opendir\" => {\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.opendir(name)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"closedir\" => {\n+                let [dirp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.closedir(dirp)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"lseek64\" => {\n+                let [fd, offset, whence] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.lseek64(fd, offset, whence)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"ftruncate64\" => {\n+                let [fd, length] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.ftruncate64(fd, length)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"fsync\" => {\n+                let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.fsync(fd)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"fdatasync\" => {\n+                let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.fdatasync(fd)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"readlink\" => {\n+                let [pathname, buf, bufsize] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.readlink(pathname, buf, bufsize)?;\n+                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+            }\n+            \"posix_fadvise\" => {\n+                let [fd, offset, len, advice] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.read_scalar(fd)?.to_i32()?;\n+                this.read_scalar(offset)?.to_machine_isize(this)?;\n+                this.read_scalar(len)?.to_machine_isize(this)?;\n+                this.read_scalar(advice)?.to_i32()?;\n+                // fadvise is only informational, we can ignore it.\n+                this.write_null(dest)?;\n+            }\n+            \"realpath\" => {\n+                let [path, resolved_path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.realpath(path, resolved_path)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"mkstemp\" => {\n+                let [template] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.mkstemp(template)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+\n+            // Time related shims\n+            \"gettimeofday\" => {\n+                let [tv, tz] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.gettimeofday(tv, tz)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+\n+            // Allocation\n+            \"posix_memalign\" => {\n+                let [ret, align, size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ret = this.deref_operand(ret)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n+                // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n+                // But failure to adhere to this is not UB, it's an error condition.\n+                if !align.is_power_of_two() || align < this.pointer_size().bytes() {\n+                    let einval = this.eval_libc_i32(\"EINVAL\")?;\n+                    this.write_int(einval, dest)?;\n+                } else {\n+                    if size == 0 {\n+                        this.write_null(&ret.into())?;\n+                    } else {\n+                        let ptr = this.allocate_ptr(\n+                            Size::from_bytes(size),\n+                            Align::from_bytes(align).unwrap(),\n+                            MiriMemoryKind::C.into(),\n+                        )?;\n+                        this.write_pointer(ptr, &ret.into())?;\n+                    }\n+                    this.write_null(dest)?;\n+                }\n+            }\n+\n+            // Dynamic symbol loading\n+            \"dlsym\" => {\n+                let [handle, symbol] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.read_scalar(handle)?.to_machine_usize(this)?;\n+                let symbol = this.read_pointer(symbol)?;\n+                let symbol_name = this.read_c_str(symbol)?;\n+                if let Some(dlsym) = Dlsym::from_str(symbol_name, &this.tcx.sess.target.os)? {\n+                    let ptr = this.create_fn_alloc_ptr(FnVal::Other(dlsym));\n+                    this.write_pointer(ptr, dest)?;\n+                } else {\n+                    this.write_null(dest)?;\n+                }\n+            }\n+\n+            // Querying system information\n+            \"sysconf\" => {\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let name = this.read_scalar(name)?.to_i32()?;\n+\n+                // FIXME: Which of these are POSIX, and which are GNU/Linux?\n+                // At least the names seem to all also exist on macOS.\n+                let sysconfs: &[(&str, fn(&MiriInterpCx<'_, '_>) -> Scalar<Provenance>)] = &[\n+                    (\"_SC_PAGESIZE\", |this| Scalar::from_int(PAGE_SIZE, this.pointer_size())),\n+                    (\"_SC_NPROCESSORS_CONF\", |this| Scalar::from_int(NUM_CPUS, this.pointer_size())),\n+                    (\"_SC_NPROCESSORS_ONLN\", |this| Scalar::from_int(NUM_CPUS, this.pointer_size())),\n+                    // 512 seems to be a reasonable default. The value is not critical, in\n+                    // the sense that getpwuid_r takes and checks the buffer length.\n+                    (\"_SC_GETPW_R_SIZE_MAX\", |this| Scalar::from_int(512, this.pointer_size()))\n+                ];\n+                let mut result = None;\n+                for &(sysconf_name, value) in sysconfs {\n+                    let sysconf_name = this.eval_libc_i32(sysconf_name)?;\n+                    if sysconf_name == name {\n+                        result = Some(value(this));\n+                        break;\n+                    }\n+                }\n+                if let Some(result) = result {\n+                    this.write_scalar(result, dest)?;\n+                } else {\n+                    throw_unsup_format!(\"unimplemented sysconf name: {}\", name)\n+                }\n+            }\n+\n+            // Thread-local storage\n+            \"pthread_key_create\" => {\n+                let [key, dtor] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let key_place = this.deref_operand(key)?;\n+                let dtor = this.read_pointer(dtor)?;\n+\n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n+                let dtor = if !this.ptr_is_null(dtor)? {\n+                    Some(this.get_ptr_fn(dtor)?.as_instance()?)\n+                } else {\n+                    None\n+                };\n+\n+                // Figure out how large a pthread TLS key actually is.\n+                // To this end, deref the argument type. This is `libc::pthread_key_t`.\n+                let key_type = key.layout.ty\n+                    .builtin_deref(true)\n+                    .ok_or_else(|| err_ub_format!(\n+                        \"wrong signature used for `pthread_key_create`: first argument must be a raw pointer.\"\n+                    ))?\n+                    .ty;\n+                let key_layout = this.layout_of(key_type)?;\n+\n+                // Create key and write it into the memory where `key_ptr` wants it.\n+                let key = this.machine.tls.create_tls_key(dtor, key_layout.size)?;\n+                this.write_scalar(Scalar::from_uint(key, key_layout.size), &key_place.into())?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_key_delete\" => {\n+                let [key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let key = this.read_scalar(key)?.to_bits(key.layout.size)?;\n+                this.machine.tls.delete_tls_key(key)?;\n+                // Return success (0)\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_getspecific\" => {\n+                let [key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let key = this.read_scalar(key)?.to_bits(key.layout.size)?;\n+                let active_thread = this.get_active_thread();\n+                let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n+                this.write_scalar(ptr, dest)?;\n+            }\n+            \"pthread_setspecific\" => {\n+                let [key, new_ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let key = this.read_scalar(key)?.to_bits(key.layout.size)?;\n+                let active_thread = this.get_active_thread();\n+                let new_data = this.read_scalar(new_ptr)?;\n+                this.machine.tls.store_tls(key, active_thread, new_data, &*this.tcx)?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+\n+            // Synchronization primitives\n+            \"pthread_mutexattr_init\" => {\n+                let [attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_mutexattr_init(attr)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutexattr_settype\" => {\n+                let [attr, kind] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_mutexattr_settype(attr, kind)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutexattr_destroy\" => {\n+                let [attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_mutexattr_destroy(attr)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_init\" => {\n+                let [mutex, attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_mutex_init(mutex, attr)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_lock\" => {\n+                let [mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_mutex_lock(mutex)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_trylock\" => {\n+                let [mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_mutex_trylock(mutex)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_unlock\" => {\n+                let [mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_mutex_unlock(mutex)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_destroy\" => {\n+                let [mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_mutex_destroy(mutex)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_rdlock\" => {\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_rwlock_rdlock(rwlock)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_tryrdlock\" => {\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_rwlock_tryrdlock(rwlock)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_wrlock\" => {\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_rwlock_wrlock(rwlock)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_trywrlock\" => {\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_rwlock_trywrlock(rwlock)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_unlock\" => {\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_rwlock_unlock(rwlock)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_destroy\" => {\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_rwlock_destroy(rwlock)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_condattr_init\" => {\n+                let [attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_condattr_init(attr)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_condattr_destroy\" => {\n+                let [attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_condattr_destroy(attr)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_cond_init\" => {\n+                let [cond, attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_cond_init(cond, attr)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_cond_signal\" => {\n+                let [cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_cond_signal(cond)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_cond_broadcast\" => {\n+                let [cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_cond_broadcast(cond)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_cond_wait\" => {\n+                let [cond, mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_cond_wait(cond, mutex)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_cond_timedwait\" => {\n+                let [cond, mutex, abstime] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.pthread_cond_timedwait(cond, mutex, abstime, dest)?;\n+            }\n+            \"pthread_cond_destroy\" => {\n+                let [cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_cond_destroy(cond)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+\n+            // Threading\n+            \"pthread_create\" => {\n+                let [thread, attr, start, arg] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_create(thread, attr, start, arg)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_join\" => {\n+                let [thread, retval] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_join(thread, retval)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_detach\" => {\n+                let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.pthread_detach(thread)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_self\" => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let res = this.pthread_self()?;\n+                this.write_scalar(res, dest)?;\n+            }\n+            \"sched_yield\" => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.sched_yield()?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"nanosleep\" => {\n+                let [req, rem] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.nanosleep(req, rem)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+\n+            // Miscellaneous\n+            \"isatty\" => {\n+                let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.isatty(fd)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_atfork\" => {\n+                let [prepare, parent, child] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.read_pointer(prepare)?;\n+                this.read_pointer(parent)?;\n+                this.read_pointer(child)?;\n+                // We do not support forking, so there is nothing to do here.\n+                this.write_null(dest)?;\n+            }\n+            \"strerror_r\" | \"__xpg_strerror_r\" => {\n+                let [errnum, buf, buflen] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let errnum = this.read_scalar(errnum)?;\n+                let buf = this.read_pointer(buf)?;\n+                let buflen = this.read_scalar(buflen)?.to_machine_usize(this)?;\n+\n+                let error = this.try_errnum_to_io_error(errnum)?;\n+                let formatted = match error {\n+                    Some(err) => format!(\"{err}\"),\n+                    None => format!(\"<unknown errnum in strerror_r: {errnum}>\"),\n+                };\n+                let (complete, _) = this.write_os_str_to_c_str(OsStr::new(&formatted), buf, buflen)?;\n+                let ret = if complete { 0 } else { this.eval_libc_i32(\"ERANGE\")? };\n+                this.write_int(ret, dest)?;\n+            }\n+            \"getpid\" => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false}, link_name, args)?;\n+                let result = this.getpid()?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n+            // These shims are enabled only when the caller is in the standard library.\n+            \"pthread_attr_getguardsize\"\n+            if this.frame_in_std() => {\n+                let [_attr, guard_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let guard_size = this.deref_operand(guard_size)?;\n+                let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n+                this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), &guard_size.into())?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+\n+            | \"pthread_attr_init\"\n+            | \"pthread_attr_destroy\"\n+            if this.frame_in_std() => {\n+                let [_] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.write_null(dest)?;\n+            }\n+            | \"pthread_attr_setstacksize\"\n+            if this.frame_in_std() => {\n+                let [_, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.write_null(dest)?;\n+            }\n+\n+            \"pthread_attr_getstack\"\n+            if this.frame_in_std() => {\n+                // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n+                // Hence we can mostly ignore the input `attr_place`.\n+                let [attr_place, addr_place, size_place] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let _attr_place = this.deref_operand(attr_place)?;\n+                let addr_place = this.deref_operand(addr_place)?;\n+                let size_place = this.deref_operand(size_place)?;\n+\n+                this.write_scalar(\n+                    Scalar::from_uint(STACK_ADDR, this.pointer_size()),\n+                    &addr_place.into(),\n+                )?;\n+                this.write_scalar(\n+                    Scalar::from_uint(STACK_SIZE, this.pointer_size()),\n+                    &size_place.into(),\n+                )?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+\n+            | \"signal\"\n+            | \"sigaltstack\"\n+            if this.frame_in_std() => {\n+                let [_, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.write_null(dest)?;\n+            }\n+            | \"sigaction\"\n+            | \"mprotect\"\n+            if this.frame_in_std() => {\n+                let [_, _, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.write_null(dest)?;\n+            }\n+\n+            \"getuid\"\n+            if this.frame_in_std() => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                // FOr now, just pretend we always have this fixed UID.\n+                this.write_int(super::UID, dest)?;\n+            }\n+\n+            \"getpwuid_r\" if this.frame_in_std() => {\n+                let [uid, pwd, buf, buflen, result] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.check_no_isolation(\"`getpwuid_r`\")?;\n+\n+                let uid = this.read_scalar(uid)?.to_u32()?;\n+                let pwd = this.deref_operand(pwd)?;\n+                let buf = this.read_pointer(buf)?;\n+                let buflen = this.read_scalar(buflen)?.to_machine_usize(this)?;\n+                let result = this.deref_operand(result)?;\n+\n+                // Must be for \"us\".\n+                if uid != crate::shims::unix::UID {\n+                    throw_unsup_format!(\"`getpwuid_r` on other users is not supported\");\n+                }\n+\n+                // Reset all fields to `uninit` to make sure nobody reads them.\n+                // (This is a std-only shim so we are okay with such hacks.)\n+                this.write_uninit(&pwd.into())?;\n+\n+                // We only set the home_dir field.\n+                #[allow(deprecated)]\n+                let home_dir = std::env::home_dir().unwrap();\n+                let (written, _) = this.write_path_to_c_str(&home_dir, buf, buflen)?;\n+                let pw_dir = this.mplace_field_named(&pwd, \"pw_dir\")?;\n+                this.write_pointer(buf, &pw_dir.into())?;\n+\n+                if written {\n+                    this.write_pointer(pwd.ptr, &result.into())?;\n+                    this.write_null(dest)?;\n+                } else {\n+                    this.write_null(&result.into())?;\n+                    this.write_scalar(this.eval_libc(\"ERANGE\")?, dest)?;\n+                }\n+            }\n+\n+            // Platform-specific shims\n+            _ => {\n+                let target_os = &*this.tcx.sess.target.os;\n+                match target_os {\n+                    \"android\" => return shims::unix::android::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                    \"freebsd\" => return shims::unix::freebsd::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                    \"linux\" => return shims::unix::linux::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                    \"macos\" => return shims::unix::macos::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest),\n+                    _ => panic!(\"unsupported Unix OS {target_os}\"),\n+                }\n+            }\n+        };\n+\n+        Ok(EmulateByNameResult::NeedsJumping)\n+    }\n+}"}, {"sha": "d759ffb8994b7e7bfb7c5d17e9bc54c1313a6ac6", "filename": "src/tools/miri/src/shims/unix/freebsd/dlsym.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,36 @@\n+use rustc_middle::mir;\n+\n+use crate::*;\n+\n+#[derive(Debug, Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+pub enum Dlsym {}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str<'tcx>(name: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n+        throw_unsup_format!(\"unsupported FreeBSD dlsym: {}\", name)\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        _args: &[OpTy<'tcx, Provenance>],\n+        _dest: &PlaceTy<'tcx, Provenance>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let _ret = ret.expect(\"we don't support any diverging dlsym\");\n+        assert!(this.tcx.sess.target.os == \"freebsd\");\n+\n+        match dlsym {}\n+\n+        //trace!(\"{:?}\", this.dump_place(**dest));\n+        //this.go_to_block(ret);\n+        //Ok(())\n+    }\n+}"}, {"sha": "70798f98174533c4886b800a63157de32ce8b4a4", "filename": "src/tools/miri/src/shims/unix/freebsd/foreign_items.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,45 @@\n+use rustc_span::Symbol;\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::*;\n+use shims::foreign_items::EmulateByNameResult;\n+use shims::unix::thread::EvalContextExt as _;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn emulate_foreign_item_by_name(\n+        &mut self,\n+        link_name: Symbol,\n+        abi: Abi,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n+        let this = self.eval_context_mut();\n+        match link_name.as_str() {\n+            // Threading\n+            \"pthread_attr_get_np\" if this.frame_in_std() => {\n+                let [_thread, _attr] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_set_name_np\" => {\n+                let [thread, name] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let res =\n+                    this.pthread_setname_np(this.read_scalar(thread)?, this.read_scalar(name)?)?;\n+                this.write_scalar(res, dest)?;\n+            }\n+\n+            // errno\n+            \"__error\" => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let errno_place = this.last_error_place()?;\n+                this.write_scalar(errno_place.to_ref(this).to_scalar(), dest)?;\n+            }\n+\n+            _ => return Ok(EmulateByNameResult::NotSupported),\n+        }\n+        Ok(EmulateByNameResult::NeedsJumping)\n+    }\n+}"}, {"sha": "434f5f30b5a5689206655f20e623d99789556bb6", "filename": "src/tools/miri/src/shims/unix/freebsd/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a", "patch": "@@ -0,0 +1,2 @@\n+pub mod dlsym;\n+pub mod foreign_items;"}, {"sha": "8464c4589ed5d5a6242aa4201f281582c360cb59", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a96c14c142b25a42ee0821f4ea1ca70bfeace650", "filename": "src/tools/miri/src/shims/unix/linux/dlsym.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fdlsym.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5d000f9d121d48a75e8b262ae325cd11648c0a67", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "498eb57c57fe0ebc0e9c1d306dad37693046f9d6", "filename": "src/tools/miri/src/shims/unix/linux/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5a6ce28d25c9f439873ab99eccd5552bf2b314a7", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "18804b45efca91cc848434e40b95f4d5d4910e47", "filename": "src/tools/miri/src/shims/unix/macos/dlsym.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "38d791fba98a4debc99105ccf4ac83d00331121b", "filename": "src/tools/miri/src/shims/unix/macos/foreign_items.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "434f5f30b5a5689206655f20e623d99789556bb6", "filename": "src/tools/miri/src/shims/unix/macos/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "6fefb054f3c046c5b1fb202cd3febc3a7d7a05fa", "filename": "src/tools/miri/src/shims/unix/mod.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "2e972a27ffebe428441334c6309f0a3b455355c8", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "added", "additions": 907, "deletions": 0, "changes": 907, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "59474d8d10ad7b058e207536356b8b5a3f623ab0", "filename": "src/tools/miri/src/shims/unix/thread.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "41b9473f81fef6dbdc01f2b07b75106afb044fb2", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "53ab97b255e56f8644e29827b05508a52a99d288", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5b22c4bd73584806cf28ff3ff93735c7d342bbcf", "filename": "src/tools/miri/src/shims/windows/handle.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "40fe71b2dbd02c6c01071885d0ab5fcda5ad680a", "filename": "src/tools/miri/src/shims/windows/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "dc1052a824defa883266918b0cc893d35eedc2e1", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5ed0cb92f9e347acbb78a2259c392d131739c0d8", "filename": "src/tools/miri/src/shims/windows/thread.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "0d76ed4e30878c1f24dd8ee686280f3778262e17", "filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "709b27d191b26b51c3c346cf7737ff6c1042436d", "filename": "src/tools/miri/src/stacked_borrows/item.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fitem.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "f7f4b1357f1069ce880d2a6e6966571dfdd015fa", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "added", "additions": 1087, "deletions": 0, "changes": 1087, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "494ea08b56e48b2b594f4fa2725e2b14543613d1", "filename": "src/tools/miri/src/stacked_borrows/stack.rs", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "e20a86711478ae076cb1a261337320fc67b7c3e8", "filename": "src/tools/miri/src/tag_gc.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "af5854e0c3fd91b6c7e4c7ad2b62b03be0bbdecf", "filename": "src/tools/miri/test-cargo-miri/.gitignore", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2F.gitignore?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a297dd27dbc9455d5f5079e2852cb4cca5543c8a", "filename": "src/tools/miri/test-cargo-miri/Cargo.lock", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5d9e5d143b3b35b18867ca2b22bf461366871279", "filename": "src/tools/miri/test-cargo-miri/Cargo.toml", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "6c1f4d80d3392c26c13b3f4bd48bf6b5f18b9de0", "filename": "src/tools/miri/test-cargo-miri/build.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fbuild.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "527602e0a888f1a5c321f25813f2ed7f87718c08", "filename": "src/tools/miri/test-cargo-miri/cdylib/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fcdylib%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fcdylib%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fcdylib%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "e47e588251e4ed81f7bd23a313dd68a2474ce6f0", "filename": "src/tools/miri/test-cargo-miri/cdylib/src/lib.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fcdylib%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fcdylib%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fcdylib%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "00c41172c3af20a4f071721d1aedbda42ef2c199", "filename": "src/tools/miri/test-cargo-miri/exported-symbol-dep/Cargo.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol-dep%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol-dep%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol-dep%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5b8a314ae73245051cc58018ba9988075382ff18", "filename": "src/tools/miri/test-cargo-miri/exported-symbol-dep/src/lib.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol-dep%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol-dep%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol-dep%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7c01be1a85f9ce109d341f584b7d7da750f54423", "filename": "src/tools/miri/test-cargo-miri/exported-symbol/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "de55eb2a1a5a003b0b9575d118274d26d470b3ef", "filename": "src/tools/miri/test-cargo-miri/exported-symbol/src/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fexported-symbol%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "6a6e09036a01dc6380b8434f5df0580ff703db1b", "filename": "src/tools/miri/test-cargo-miri/issue-1567/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1567%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1567%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1567%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5479216832388d3fb6495e2fbe7e315b1b3c3cb3", "filename": "src/tools/miri/test-cargo-miri/issue-1567/src/lib.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1567%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1567%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1567%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "3100cc6a60b5861bf94f5264b01c128c787777cb", "filename": "src/tools/miri/test-cargo-miri/issue-1691/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1691%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1691%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1691%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "efde2b58e199e042ffea44db102ae2cc8be609ed", "filename": "src/tools/miri/test-cargo-miri/issue-1691/src/lib.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1691%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1691%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1691%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ae63647a88819b3a7d7d51b32fbd691ee30462b3", "filename": "src/tools/miri/test-cargo-miri/issue-1705/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1705%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1705%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1705%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "64633490f84b92a3a7bdf740749dbd7cce2795dd", "filename": "src/tools/miri/test-cargo-miri/issue-1705/src/lib.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1705%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1705%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1705%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "80925c74746387c3c557ba30a0ed81ca0bff1423", "filename": "src/tools/miri/test-cargo-miri/issue-1760/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "08427fd7164f1d68ec6aed161bebe8b7e5dd61ec", "filename": "src/tools/miri/test-cargo-miri/issue-1760/build.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2Fbuild.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "b4f6274af444809467129903aaa5d8023cc1828e", "filename": "src/tools/miri/test-cargo-miri/issue-1760/src/lib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-1760%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a6b65ebb5318d71886e2c9a61baf2b5c15c02e7e", "filename": "src/tools/miri/test-cargo-miri/issue-rust-86261/Cargo.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-rust-86261%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-rust-86261%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-rust-86261%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "1947c38b7745518418b22eec09955c37d865162f", "filename": "src/tools/miri/test-cargo-miri/issue-rust-86261/src/lib.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-rust-86261%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-rust-86261%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fissue-rust-86261%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "4485d3252ccc2c3b3bb0af621d10e4be54108d9c", "filename": "src/tools/miri/test-cargo-miri/run-test.py", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "01bb8952322b6521da600d534955c0b710f606c9", "filename": "src/tools/miri/test-cargo-miri/run.args.stderr.ref", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.args.stderr.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.args.stderr.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.args.stderr.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "6710f307cb26daf260543237456b7d44fa2998ab", "filename": "src/tools/miri/test-cargo-miri/run.args.stdout.ref", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.args.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.args.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.args.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "4395ff8879b96386f4b0f3a81348f32b3c0e98ec", "filename": "src/tools/miri/test-cargo-miri/run.custom-target-dir.stderr.ref", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.custom-target-dir.stderr.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.custom-target-dir.stderr.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.custom-target-dir.stderr.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ba2906d0666cf726c7eaadd2cd3db615dedfdf3a", "filename": "src/tools/miri/test-cargo-miri/run.default.stderr.ref", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.default.stderr.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.default.stderr.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.default.stderr.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "2eab8df967d5fc613a3085920c1a0cc81971da78", "filename": "src/tools/miri/test-cargo-miri/run.default.stdout.ref", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.default.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.default.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.default.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/miri/test-cargo-miri/run.subcrate.stderr.ref", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.subcrate.stderr.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.subcrate.stderr.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.subcrate.stderr.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "53340a502381d5a595671540cadf40e1a8ed2514", "filename": "src/tools/miri/test-cargo-miri/run.subcrate.stdout.ref", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.subcrate.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.subcrate.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun.subcrate.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "66c8aa2eac57e1e6233f589147aa50363c04ed66", "filename": "src/tools/miri/test-cargo-miri/src/lib.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "41c52b7017028caa8e17ce4c6e7505c02934a6a1", "filename": "src/tools/miri/test-cargo-miri/src/main.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "06b1ce1cba4b86b7dac922e044a163fa22cbdee5", "filename": "src/tools/miri/test-cargo-miri/subcrate/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "4ce80b370722670c7b67246cf8e82744c19b34f3", "filename": "src/tools/miri/test-cargo-miri/subcrate/main.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "2ccb6704b05e6d9ad51ac5bf87c7f8bbf61e2616", "filename": "src/tools/miri/test-cargo-miri/subcrate/src/lib.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fsrc%2Flib.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "77e3c2878ca0e152725146cc7533fc6efaeb6510", "filename": "src/tools/miri/test-cargo-miri/subcrate/test.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5264530160bc59bd212e4c0c33f7fd9754c99563", "filename": "src/tools/miri/test-cargo-miri/test.bin-target.stdout.ref", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.bin-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.bin-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.bin-target.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "8c543e479f4e0fc40a9f79d4d9dfdd78423337e0", "filename": "src/tools/miri/test-cargo-miri/test.cross-target.stdout.ref", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.cross-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.cross-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.cross-target.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "9a17f3d61b6acc445cfac5aa3712ca8cd47125b7", "filename": "src/tools/miri/test-cargo-miri/test.default.stdout.ref", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.default.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.default.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.default.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "bb0282d6c9167a84e1be7477748d05786a8d3048", "filename": "src/tools/miri/test-cargo-miri/test.filter.cross-target.stdout.ref", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.filter.cross-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.filter.cross-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.filter.cross-target.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c618956656a8a60f0c8a8be587ed729d0cef60e6", "filename": "src/tools/miri/test-cargo-miri/test.filter.stdout.ref", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.filter.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.filter.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.filter.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/miri/test-cargo-miri/test.stderr-empty.ref", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-empty.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-empty.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-empty.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ca5e3a2392db86f336a6ba03c2cc4abba6d0384a", "filename": "src/tools/miri/test-cargo-miri/test.stderr-proc-macro-doctest.ref", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-proc-macro-doctest.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-proc-macro-doctest.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-proc-macro-doctest.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "4983250917b596eb0a0bd74144262b7c5ca00428", "filename": "src/tools/miri/test-cargo-miri/test.stderr-proc-macro.ref", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-proc-macro.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-proc-macro.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stderr-proc-macro.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/miri/test-cargo-miri/test.stdout-empty.ref", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stdout-empty.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stdout-empty.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.stdout-empty.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "67e5c7f8e920cec3e214cc178b9652806d0b64bb", "filename": "src/tools/miri/test-cargo-miri/test.subcrate.stdout.ref", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.subcrate.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.subcrate.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.subcrate.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "dd59b32b780c85d7a21544f543889e1ffe0deba9", "filename": "src/tools/miri/test-cargo-miri/test.test-target.stdout.ref", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.test-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.test-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftest.test-target.stdout.ref?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "bb94c8f37876ca35598b66dc6885413e86820d35", "filename": "src/tools/miri/test-cargo-miri/tests/main.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftests%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "9ed2152893964a569fae129a4bfdeda153398c81", "filename": "src/tools/miri/test-cargo-miri/tests/test.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Ftests%2Ftest.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "d4b32e2c29a22ffa53e804e4269c314317ed732b", "filename": "src/tools/miri/test_dependencies/Cargo.lock", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "58f731f91d0f4453a43ce3ba238ee9d94e302467", "filename": "src/tools/miri/test_dependencies/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/tools/miri/test_dependencies/src/main.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest_dependencies%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftest_dependencies%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest_dependencies%2Fsrc%2Fmain.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "6b5668e2d6c4cbe3be62fd81d8d34956a2ad274f", "filename": "src/tools/miri/tests/compiletest.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "3aaeb632cad7b66412891a372fbd92068cbe7d2c", "filename": "src/tools/miri/tests/extern-so/fail/function_not_in_so.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ffail%2Ffunction_not_in_so.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ffail%2Ffunction_not_in_so.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ffail%2Ffunction_not_in_so.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "f649f0ae43e30992634235fd3f6b160d6e857ec1", "filename": "src/tools/miri/tests/extern-so/fail/function_not_in_so.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ffail%2Ffunction_not_in_so.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ffail%2Ffunction_not_in_so.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ffail%2Ffunction_not_in_so.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "0f04b9aaebb38e00f1fa2cb997cd1f53e2bb62e8", "filename": "src/tools/miri/tests/extern-so/libcode.version", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Flibcode.version", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Flibcode.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Flibcode.version?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "1e1d0b11e99ffd444443f5a3e11021307707a04b", "filename": "src/tools/miri/tests/extern-so/pass/call_extern_c_fn.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Fpass%2Fcall_extern_c_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Fpass%2Fcall_extern_c_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Fpass%2Fcall_extern_c_fn.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7ba13d2d7b02e396663d717879b01c9784c3ce3a", "filename": "src/tools/miri/tests/extern-so/pass/call_extern_c_fn.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Fpass%2Fcall_extern_c_fn.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Fpass%2Fcall_extern_c_fn.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Fpass%2Fcall_extern_c_fn.stdout?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "68714f1743b6ec751438ce1582302d3141778fee", "filename": "src/tools/miri/tests/extern-so/test.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fextern-so%2Ftest.c?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c954443a27629375b745ddccf22eec5990cf6f02", "filename": "src/tools/miri/tests/fail/abort-terminator.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fabort-terminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fabort-terminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fabort-terminator.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ec9ce76685b5572e6c43d3e4dad1fb10c552c751", "filename": "src/tools/miri/tests/fail/abort-terminator.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fabort-terminator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fabort-terminator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fabort-terminator.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a07d8254ad3d5095887bbce8f83510bb062aea5e", "filename": "src/tools/miri/tests/fail/alloc/deallocate-bad-alignment.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-alignment.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "28439b54b2908270a7ffbf3f8c022d9b49aab4a6", "filename": "src/tools/miri/tests/fail/alloc/deallocate-bad-alignment.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-alignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-alignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-alignment.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "47aaef1935e90220ef068ff7b4dded3a433ede0e", "filename": "src/tools/miri/tests/fail/alloc/deallocate-bad-size.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-size.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a6ceab1f56f513d742e5a5055a25a7000de269e3", "filename": "src/tools/miri/tests/fail/alloc/deallocate-bad-size.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-size.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-size.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-bad-size.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "1eb9bbf91ca5c2c0fb634f589164e99d782216bb", "filename": "src/tools/miri/tests/fail/alloc/deallocate-twice.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-twice.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "b6c5b6f97ee7b9fa9a7bb8f08bc8c492270b9b75", "filename": "src/tools/miri/tests/fail/alloc/deallocate-twice.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fdeallocate-twice.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "47b098c71a2bfb3da889734235bcab4962962042", "filename": "src/tools/miri/tests/fail/alloc/global_system_mixup.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fglobal_system_mixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fglobal_system_mixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fglobal_system_mixup.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "4ee85add6c228242c656d0bd1f2a361107fe771b", "filename": "src/tools/miri/tests/fail/alloc/global_system_mixup.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fglobal_system_mixup.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fglobal_system_mixup.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fglobal_system_mixup.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "fb0e7986bb5e6042caebb2a7508e4f0a0e348cf3", "filename": "src/tools/miri/tests/fail/alloc/no_global_allocator.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fno_global_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fno_global_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fno_global_allocator.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ea70970ae0fefbf499318cf12de8a12d68fb35dc", "filename": "src/tools/miri/tests/fail/alloc/no_global_allocator.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fno_global_allocator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fno_global_allocator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fno_global_allocator.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "145c3393d677ae69616225448ac64a8786fc84cd", "filename": "src/tools/miri/tests/fail/alloc/reallocate-bad-size.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-bad-size.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c11b5a851048f631c03532712c5a753dff1ac0a1", "filename": "src/tools/miri/tests/fail/alloc/reallocate-bad-size.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-bad-size.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-bad-size.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-bad-size.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "3ad56da2c2fffcadb17acd51b4c4e492e019d072", "filename": "src/tools/miri/tests/fail/alloc/reallocate-change-alloc.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-change-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-change-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-change-alloc.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5631dcb4cc084f50c73dfe5e88bf0d842c23d4e7", "filename": "src/tools/miri/tests/fail/alloc/reallocate-change-alloc.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-change-alloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-change-alloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-change-alloc.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "34f1658344a5e9312505346ef677d58dde4f9965", "filename": "src/tools/miri/tests/fail/alloc/reallocate-dangling.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-dangling.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c7db5a729048c234e899a153ef03dfc2d74d6fc8", "filename": "src/tools/miri/tests/fail/alloc/reallocate-dangling.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-dangling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-dangling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Freallocate-dangling.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "baf53decc4413874d71f192bbfea5cce14a0178a", "filename": "src/tools/miri/tests/fail/alloc/stack_free.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "44991542b135074d8fc1087f290fe7e74da10b6a", "filename": "src/tools/miri/tests/fail/alloc/stack_free.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "1a4a3b97ea3ff95bba2b65d101e0c543aa3f8940", "filename": "src/tools/miri/tests/fail/box-cell-alias.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "83701639976877fae534904ea29c8d878643d99f", "filename": "src/tools/miri/tests/fail/box-cell-alias.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "2b861e5447b03cfbe40b46bc039a92da19b7bf54", "filename": "src/tools/miri/tests/fail/branchless-select-i128-pointer.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "96f2ff3282c82a4955ec44bd1e30abb3eea32433", "filename": "src/tools/miri/tests/fail/branchless-select-i128-pointer.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "fb1d4d958ee6bc3c282f331866db751fa255724e", "filename": "src/tools/miri/tests/fail/breakpoint.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbreakpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbreakpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbreakpoint.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7b9bbdb382895a75b589e37b65e279571458db02", "filename": "src/tools/miri/tests/fail/breakpoint.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbreakpoint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbreakpoint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbreakpoint.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "065ad2d725f8f96e45fa81ecba42365c9ac7960a", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_create_main_terminate.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c5093c0e60113a3dd780be2d1eb5601d95bcf9fb", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_create_main_terminate.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "e1d3704af7c0b54cf7d69d402fbc4bed72e7f8b9", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_create_too_few_args.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "94463bef8f0fe9731cfda7ae7e4699655b0799da", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_create_too_few_args.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7408634db528fee3540fe7d52e02c2d87fd3130b", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_create_too_many_args.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "fdbe91cc8a803986f08fd32c29bde95d92ecf788", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_create_too_many_args.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "0b810dc8c7212e59f0c69b14dc888962a8f0bb96", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_detached.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "763e0d3665d8f6bae4c27a7bb03878a518db5ca0", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_detached.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "04ca4bbb3f6110db7b46644122a4be387fcd3ac1", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_joined.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a3253e2ef933bf712b0acfea7a9ca409007b6d4f", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_joined.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7576518216372370550127d3dbc1385964180851", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_main.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "09e14d46a967f708fae5a1dabbb51fce7e8fe837", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_main.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "966f416eeac7e5b8782446c41347b1c2b19503bb", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_multiple.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "db5d7bfd5daef9d80d1b8b5438fa31766ba0c000", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_multiple.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "0c25c690f3721db32266b2e91d7b1f6ee04457e8", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_self.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "8db4a83f9cebb3d71f41df2aaab37c16d55eed01", "filename": "src/tools/miri/tests/fail/concurrency/libc_pthread_join_self.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "cb6aeea665d3905b3c1d75e12a24f3d8ff94eddd", "filename": "src/tools/miri/tests/fail/concurrency/read_only_atomic_cmpxchg.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "d51fdee0b256fca3acdad3ccd756965a1007f49a", "filename": "src/tools/miri/tests/fail/concurrency/read_only_atomic_cmpxchg.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "6e92453e3c195e969713158c2bd5718eaefd288c", "filename": "src/tools/miri/tests/fail/concurrency/read_only_atomic_load.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "17851d6b470b4883fd68a62b22db08c8789d9cac", "filename": "src/tools/miri/tests/fail/concurrency/read_only_atomic_load.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "d89c670b632e6d5735fee65270cc2fd7121c6900", "filename": "src/tools/miri/tests/fail/concurrency/thread_local_static_dealloc.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "cc3e56398781bf6e59e5df80538f2199ef945b5c", "filename": "src/tools/miri/tests/fail/concurrency/thread_local_static_dealloc.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "4704cfed03938a9f2d72b571ef7fb752a7154c5a", "filename": "src/tools/miri/tests/fail/concurrency/unwind_top_of_stack.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "98db33e3206bd11bde8beb13550bd410a0235f36", "filename": "src/tools/miri/tests/fail/concurrency/unwind_top_of_stack.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "548ed63534dbd64be3bc3dece48d30bfbf878c2c", "filename": "src/tools/miri/tests/fail/concurrency/windows_join_detached.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "78c75611d3333a98385d2d6a984ba6b94cb12c90", "filename": "src/tools/miri/tests/fail/concurrency/windows_join_detached.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "cde6d19ef25bb73813f1ea30238e484287423854", "filename": "src/tools/miri/tests/fail/concurrency/windows_join_main.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ff0d074fa7d2604874b30c77f3fdbb365476ac4f", "filename": "src/tools/miri/tests/fail/concurrency/windows_join_main.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "d9bbf66a7dca5fca6eed97f4a646231a904af751", "filename": "src/tools/miri/tests/fail/concurrency/windows_join_self.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "bbec3f7257ec0d44be556eef3cab1c39b4ec4408", "filename": "src/tools/miri/tests/fail/concurrency/windows_join_self.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "fa522c30cbd0fdda4c397188b3383bea7070a8c8", "filename": "src/tools/miri/tests/fail/const-ub-checks.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a8b7ea242b97018c21811a80c08f22f3ed2cca47", "filename": "src/tools/miri/tests/fail/const-ub-checks.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "e1dcdda7fdfe344608cd137199d59a402ce01e23", "filename": "src/tools/miri/tests/fail/copy_half_a_pointer.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "21797757084eec6bba714e3cf6123aa1eadbe232", "filename": "src/tools/miri/tests/fail/copy_half_a_pointer.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7cb42c09a9677015c6dfab3772fdd0404dcfd1ca", "filename": "src/tools/miri/tests/fail/crates/tokio_mvp.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "016081d90adf78b8ef733782adafe5c31139c4c2", "filename": "src/tools/miri/tests/fail/crates/tokio_mvp.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "4249c1cbf01777a73bf2796578665d517e451a45", "filename": "src/tools/miri/tests/fail/dangling_pointers/dangling_pointer_addr_of.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_addr_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_addr_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_addr_of.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5f081afe68af89458165ed1dcd244c7eea7ef428", "filename": "src/tools/miri/tests/fail/dangling_pointers/dangling_pointer_addr_of.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_addr_of.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_addr_of.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_addr_of.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ad2a599b60b48f5010ce8bda1be056a605bebfb2", "filename": "src/tools/miri/tests/fail/dangling_pointers/dangling_pointer_deref.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_deref.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "cb323818845df248cf36e34b025a8b18355b9d62", "filename": "src/tools/miri/tests/fail/dangling_pointers/dangling_pointer_deref.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_pointer_deref.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "534d7d5f42f32cd39a4f2b98c309efda5bbde217", "filename": "src/tools/miri/tests/fail/dangling_pointers/dangling_zst_deref.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_zst_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_zst_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_zst_deref.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "02db6302a0a1ea671efd1587af94fb6e64dc4f21", "filename": "src/tools/miri/tests/fail/dangling_pointers/dangling_zst_deref.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_zst_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_zst_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdangling_zst_deref.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "57e95ef19dc9975a962b809b77269ecc8eb89fe1", "filename": "src/tools/miri/tests/fail/dangling_pointers/deref-invalid-ptr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "3e2c3903b7e47fc572412a6a870b89a8564b3325", "filename": "src/tools/miri/tests/fail/dangling_pointers/deref-invalid-ptr.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "27040c26dc2125ffe8ba5457fd8c6b2b3011e547", "filename": "src/tools/miri/tests/fail/dangling_pointers/deref-partially-dangling.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-partially-dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-partially-dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-partially-dangling.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "fe039ef3adaf96d5cf1ac6fb95d61afa10882693", "filename": "src/tools/miri/tests/fail/dangling_pointers/deref-partially-dangling.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-partially-dangling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-partially-dangling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fderef-partially-dangling.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "54f353ebebeb1bae3c4d3a1b67d25a3c9fd0bf76", "filename": "src/tools/miri/tests/fail/dangling_pointers/dyn_size.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdyn_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdyn_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdyn_size.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "33aa6c844101775e30cda9ceff6d33ad1ae8e93e", "filename": "src/tools/miri/tests/fail/dangling_pointers/dyn_size.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdyn_size.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdyn_size.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fdyn_size.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a48a3189db2e360ce96da57673c8aa5f5d0ead36", "filename": "src/tools/miri/tests/fail/dangling_pointers/maybe_null_pointer_deref_zst.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "3e492a170c8b14270f8bd12a3927380280433042", "filename": "src/tools/miri/tests/fail/dangling_pointers/maybe_null_pointer_deref_zst.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "449c65d218a020fa28bd804914e29a6479d4e5f3", "filename": "src/tools/miri/tests/fail/dangling_pointers/maybe_null_pointer_write_zst.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c41c20aaf4a7bb7665295de821a6b7780b5f5fe1", "filename": "src/tools/miri/tests/fail/dangling_pointers/maybe_null_pointer_write_zst.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "a0773c63cf6bfd1db686f02a6be7785109f6de93", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_deref.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "64dcaa4548476876afd2e252fff55c5e93ab7a7c", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_deref.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "d6a607c61cbeb97b880376040481844526350e39", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_deref_zst.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref_zst.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "301578a4f5fb411bb4c19099080820d4c7c51de3", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_deref_zst.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref_zst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref_zst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_deref_zst.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "954596f57542e3922714df12f33ab370bdafe9ae", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_write.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "0e5858a96f9d78cc59b599c27917843d6f29ebeb", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_write.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c00344b6de23a200d721a64f6753fec8f713302a", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_write_zst.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "2953d85c25f3f96b631fac89066963ede32c4963", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_write_zst.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "58a64eecace8cafba110e1c7e0b3d4b17f94464c", "filename": "src/tools/miri/tests/fail/dangling_pointers/out_of_bounds_read1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read1.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "b2461ce4230ad79f94604d25cc1890fa3883d3c2", "filename": "src/tools/miri/tests/fail/dangling_pointers/out_of_bounds_read1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read1.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "58a64eecace8cafba110e1c7e0b3d4b17f94464c", "filename": "src/tools/miri/tests/fail/dangling_pointers/out_of_bounds_read2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read2.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "b17058b406298a649fe5cf50505755f84c1540b1", "filename": "src/tools/miri/tests/fail/dangling_pointers/out_of_bounds_read2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fout_of_bounds_read2.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "1373773f68d59b7ae81585b66eb5bd1f6287d2cb", "filename": "src/tools/miri/tests/fail/dangling_pointers/stack_temporary.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstack_temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstack_temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstack_temporary.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "679e4809ca663bc2dbfdfcb3db2bcc2272834f02", "filename": "src/tools/miri/tests/fail/dangling_pointers/stack_temporary.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstack_temporary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstack_temporary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstack_temporary.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "03113585d14648e65621d203f80dd98edf0286fd", "filename": "src/tools/miri/tests/fail/dangling_pointers/storage_dead_dangling.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "72e5f20f924a42bfef5a3c184bff4590b6af6c2d", "filename": "src/tools/miri/tests/fail/dangling_pointers/storage_dead_dangling.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "9ffc681465504cc4b0891702e8c40cacb0659691", "filename": "src/tools/miri/tests/fail/dangling_pointers/wild_pointer_deref.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "658fb228174e56bf17380408c7282bd1dc08288a", "filename": "src/tools/miri/tests/fail/dangling_pointers/wild_pointer_deref.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "0bd3068af1ffe9995c8db5937ecd70115df08f88", "filename": "src/tools/miri/tests/fail/data_race/alloc_read_race.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c6bfd12b241101d7f1c0fdc4710c2f0e8807f4fe", "filename": "src/tools/miri/tests/fail/data_race/alloc_read_race.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7991280721e293907d0783a07b62a708e71c1965", "filename": "src/tools/miri/tests/fail/data_race/alloc_write_race.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c4efc175c207764bb8404bc3ba9956b05c6a7081", "filename": "src/tools/miri/tests/fail/data_race/alloc_write_race.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "2b0446d724a029e6fb8531ce494a61bafd95b71e", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race1.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "04adf0a98b6c55d32bacdc7b3d1c84c892178a15", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ef5157515c64a3274eff556b247e98b83d52e8f6", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "b48f927b8fcae501556bf93bf230f44bfe997686", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "8c17e7674843832ca6ba2182584ccb1fab1785c5", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race1.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "fdb9b353a67bf42f4268a63ec11068ddf6245fee", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "f14d7c704dbb18e43df9930a42fb626ed4ccbca7", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ec581e322b7d1da928d6c0da30bdf7a9c73a8edf", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "0804b33407580c8b8e8b96ecadc403b2c15d8e42", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race1.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "4c75f94d71cf55a0a4f6daf7808a7b34c7e485d4", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "658cddcc9c5b609a1dd6a69d9e0c9caa3aa997fb", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "8c7f14081c87b2634d705cc9770d4c347b76a495", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "af2588e923240d43070dafedbf871fbe5f0c68cc", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_async_race.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "663bb8d4af5122e24f171cfc9d21637209ff8392", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_async_race.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "1ee619c3f99d573ab20f86f7012f048083b65449", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_race.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ad3e1735378f37711f4f54bc2d10ed709d56d35f", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_race.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "cbc02549a2541c72c64fa81588dbe4f3e9988834", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race1.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "194c2260baaab478d8ac78d05fa5ca9cd5bceebb", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race1.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "24cce5d6fac1cb7495ccb7129fda8aebd1670ff5", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race2.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "f303d57c8bd9caa78af3eb2ec5e2823cd969099f", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "5484370f35c17bd0a89da9ee08e47c89f516857f", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race_stack.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c986e912f03baa3a3afa50fed8daae10bde0136c", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race_stack.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "23bf73fe8c5adf6d687d4312fddc8b4202823367", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race1.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "56eb0b519c484dcd6bdd62479df5254d20b8791b", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race1.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7c8033e2335e99e3d0d34120ef589a9f742979af", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race2.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "23b8e9ade0e0efe929a60ebbccaecb87117537cd", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "1872abfe021b305d38ba9443332d5a2a17a08933", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race_stack.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "7b77e2470a1ab597ce20866ab09bb0bd6728548d", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race_stack.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "c11239da7febba4710b45d0f7c64a2a2cc7a297f", "filename": "src/tools/miri/tests/fail/data_race/enable_after_join_to_main.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "26c07ae6962b56b87ca26405e70102c6176de97b", "filename": "src/tools/miri/tests/fail/data_race/enable_after_join_to_main.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "ae443908598fe59b20f18103fe378d6d7ef5da75", "filename": "src/tools/miri/tests/fail/data_race/fence_after_load.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "0abfe213db17dbf559f7c8e3983a93733e7d7f93", "filename": "src/tools/miri/tests/fail/data_race/fence_after_load.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "482dd2df7df91111604627eec894a169daac832e", "filename": "src/tools/miri/tests/fail/data_race/read_write_race.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "08a19537312cf957c5dc5f2f11317ccc0bf4e341", "filename": "src/tools/miri/tests/fail/data_race/read_write_race.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr?ref=f45b570e08f0f4146e16e426842210f395e8284a"}, {"sha": "1b4932439b010ebbfb0ec476b1e16a04be6b6cac", "filename": "src/tools/miri/tests/fail/data_race/read_write_race_stack.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45b570e08f0f4146e16e426842210f395e8284a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=f45b570e08f0f4146e16e426842210f395e8284a"}]}