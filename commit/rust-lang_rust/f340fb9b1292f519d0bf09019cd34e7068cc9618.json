{"sha": "f340fb9b1292f519d0bf09019cd34e7068cc9618", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNDBmYjliMTI5MmY1MTlkMGJmMDkwMTljZDM0ZTcwNjhjYzk2MTg=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-04T05:42:27Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:06:21Z"}, "message": "Handle fallout in os\n\nos::env(), os::args(), and related functions now use Vec<T> instead of\n~[T].", "tree": {"sha": "128f2c56b42e309e2400bbdbd818262f1a7dcb9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/128f2c56b42e309e2400bbdbd818262f1a7dcb9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f340fb9b1292f519d0bf09019cd34e7068cc9618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f340fb9b1292f519d0bf09019cd34e7068cc9618", "html_url": "https://github.com/rust-lang/rust/commit/f340fb9b1292f519d0bf09019cd34e7068cc9618", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f340fb9b1292f519d0bf09019cd34e7068cc9618/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "html_url": "https://github.com/rust-lang/rust/commit/001a8741b42be9fed5521d9a5a96cf1ea7269fbb"}], "stats": {"total": 91, "additions": 47, "deletions": 44}, "files": [{"sha": "66143b40d52514e3f572a768a64063c3383054af", "filename": "src/libstd/os.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f340fb9b1292f519d0bf09019cd34e7068cc9618/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f340fb9b1292f519d0bf09019cd34e7068cc9618/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f340fb9b1292f519d0bf09019cd34e7068cc9618", "patch": "@@ -169,7 +169,7 @@ fn with_env_lock<T>(f: || -> T) -> T {\n ///\n /// Invalid UTF-8 bytes are replaced with \\uFFFD. See `str::from_utf8_lossy()`\n /// for details.\n-pub fn env() -> ~[(~str,~str)] {\n+pub fn env() -> Vec<(~str,~str)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n         let k = str::from_utf8_lossy(k).into_owned();\n         let v = str::from_utf8_lossy(v).into_owned();\n@@ -179,7 +179,7 @@ pub fn env() -> ~[(~str,~str)] {\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n-pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n+pub fn env_as_bytes() -> Vec<(~[u8],~[u8])> {\n     unsafe {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> Vec<~[u8]> {\n@@ -224,16 +224,16 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n         fn env_convert(input: Vec<~[u8]>) -> Vec<(~[u8], ~[u8])> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n-                let vs: ~[&[u8]] = p.splitn(1, |b| *b == '=' as u8).collect();\n-                let key = vs[0].to_owned();\n-                let val = if vs.len() < 2 { box [] } else { vs[1].to_owned() };\n+                let mut it = p.splitn(1, |b| *b == '=' as u8);\n+                let key = it.next().unwrap().to_owned();\n+                let val = it.next().unwrap_or(&[]).to_owned();\n                 pairs.push((key, val));\n             }\n             pairs\n         }\n         with_env_lock(|| {\n             let unparsed_environ = get_env_pairs();\n-            env_convert(unparsed_environ).move_iter().collect()\n+            env_convert(unparsed_environ)\n         })\n     }\n }\n@@ -416,7 +416,7 @@ pub fn dll_filename(base: &str) -> ~str {\n pub fn self_exe_name() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    fn load_self() -> Option<~[u8]> {\n+    fn load_self() -> Option<Vec<u8>> {\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n@@ -436,23 +436,23 @@ pub fn self_exe_name() -> Option<Path> {\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v.move_iter().collect())\n+            Some(v)\n         }\n     }\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n-    fn load_self() -> Option<~[u8]> {\n+    fn load_self() -> Option<Vec<u8>> {\n         use std::io;\n \n         match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n-            Ok(path) => Some(path.as_vec().to_owned()),\n+            Ok(path) => Some(path.into_vec()),\n             Err(..) => None\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    fn load_self() -> Option<~[u8]> {\n+    fn load_self() -> Option<Vec<u8>> {\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n             let mut sz: u32 = 0;\n@@ -462,19 +462,19 @@ pub fn self_exe_name() -> Option<Path> {\n             let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n             if err != 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v.move_iter().collect())\n+            Some(v)\n         }\n     }\n \n     #[cfg(windows)]\n-    fn load_self() -> Option<~[u8]> {\n+    fn load_self() -> Option<Vec<u8>> {\n         use str::OwnedStr;\n \n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n             fill_utf16_buf_and_decode(|buf, sz| {\n                 libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }).map(|s| s.into_bytes())\n+            }).map(|s| s.into_strbuf().into_bytes())\n         }\n     }\n \n@@ -789,12 +789,12 @@ pub fn get_exit_status() -> int {\n }\n \n #[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u8]] {\n+unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> Vec<~[u8]> {\n     use c_str::CString;\n \n     Vec::from_fn(argc as uint, |i| {\n         CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_owned()\n-    }).move_iter().collect()\n+    })\n }\n \n /**\n@@ -803,7 +803,7 @@ unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u8]] {\n  * Returns a list of the command line arguments.\n  */\n #[cfg(target_os = \"macos\")]\n-fn real_args_as_bytes() -> ~[~[u8]] {\n+fn real_args_as_bytes() -> Vec<~[u8]> {\n     unsafe {\n         let (argc, argv) = (*_NSGetArgc() as int,\n                             *_NSGetArgv() as **c_char);\n@@ -814,7 +814,7 @@ fn real_args_as_bytes() -> ~[~[u8]] {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n-fn real_args_as_bytes() -> ~[~[u8]] {\n+fn real_args_as_bytes() -> Vec<~[u8]> {\n     use rt;\n \n     match rt::args::clone() {\n@@ -824,12 +824,12 @@ fn real_args_as_bytes() -> ~[~[u8]] {\n }\n \n #[cfg(not(windows))]\n-fn real_args() -> ~[~str] {\n+fn real_args() -> Vec<~str> {\n     real_args_as_bytes().move_iter().map(|v| str::from_utf8_lossy(v).into_owned()).collect()\n }\n \n #[cfg(windows)]\n-fn real_args() -> ~[~str] {\n+fn real_args() -> Vec<~str> {\n     use slice;\n     use option::Expect;\n \n@@ -855,11 +855,11 @@ fn real_args() -> ~[~str] {\n         LocalFree(szArgList as *c_void);\n     }\n \n-    return args.move_iter().collect();\n+    return args\n }\n \n #[cfg(windows)]\n-fn real_args_as_bytes() -> ~[~[u8]] {\n+fn real_args_as_bytes() -> Vec<~[u8]> {\n     real_args().move_iter().map(|s| s.into_bytes()).collect()\n }\n \n@@ -883,13 +883,13 @@ extern \"system\" {\n ///\n /// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n /// See `str::from_utf8_lossy` for details.\n-pub fn args() -> ~[~str] {\n+pub fn args() -> Vec<~str> {\n     real_args()\n }\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line) as byte vectors.\n-pub fn args_as_bytes() -> ~[~[u8]] {\n+pub fn args_as_bytes() -> Vec<~[u8]> {\n     real_args_as_bytes()\n }\n "}, {"sha": "df0f1d8d449e44f44919b7351a45b0d366eb3ae6", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f340fb9b1292f519d0bf09019cd34e7068cc9618/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f340fb9b1292f519d0bf09019cd34e7068cc9618/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=f340fb9b1292f519d0bf09019cd34e7068cc9618", "patch": "@@ -21,6 +21,7 @@\n //! FIXME #7756: This has a lot of C glue for lack of globals.\n \n use option::Option;\n+use vec::Vec;\n #[cfg(test)] use option::{Some, None};\n #[cfg(test)] use realstd;\n #[cfg(test)] use realargs = realstd::rt::args;\n@@ -36,25 +37,25 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n #[cfg(test)]      pub unsafe fn cleanup() { realargs::cleanup() }\n \n /// Take the global arguments from global storage.\n-#[cfg(not(test))] pub fn take() -> Option<~[~[u8]]> { imp::take() }\n-#[cfg(test)]      pub fn take() -> Option<~[~[u8]]> {\n+#[cfg(not(test))] pub fn take() -> Option<Vec<~[u8]>> { imp::take() }\n+#[cfg(test)]      pub fn take() -> Option<Vec<~[u8]>> {\n     match realargs::take() {\n-        realstd::option::Some(a) => Some(a),\n+        realstd::option::Some(v) => Some(unsafe{ ::cast::transmute(v) }),\n         realstd::option::None => None,\n     }\n }\n \n /// Give the global arguments to global storage.\n ///\n /// It is an error if the arguments already exist.\n-#[cfg(not(test))] pub fn put(args: ~[~[u8]]) { imp::put(args) }\n-#[cfg(test)]      pub fn put(args: ~[~[u8]]) { realargs::put(args) }\n+#[cfg(not(test))] pub fn put(args: Vec<~[u8]>) { imp::put(args) }\n+#[cfg(test)]      pub fn put(args: Vec<~[u8]>) { realargs::put(unsafe { ::cast::transmute(args) }) }\n \n /// Make a clone of the global arguments.\n-#[cfg(not(test))] pub fn clone() -> Option<~[~[u8]]> { imp::clone() }\n-#[cfg(test)]      pub fn clone() -> Option<~[~[u8]]> {\n+#[cfg(not(test))] pub fn clone() -> Option<Vec<~[u8]>> { imp::clone() }\n+#[cfg(test)]      pub fn clone() -> Option<Vec<~[u8]>> {\n     match realargs::clone() {\n-        realstd::option::Some(a) => Some(a),\n+        realstd::option::Some(v) => Some(unsafe { ::cast::transmute(v) }),\n         realstd::option::None => None,\n     }\n }\n@@ -70,6 +71,7 @@ mod imp {\n     use owned::Box;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n+    use vec::Vec;\n     #[cfg(not(test))] use ptr::RawPtr;\n \n     static mut global_args_ptr: uint = 0;\n@@ -87,26 +89,26 @@ mod imp {\n         lock.destroy();\n     }\n \n-    pub fn take() -> Option<~[~[u8]]> {\n+    pub fn take() -> Option<Vec<~[u8]>> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             let val = mem::replace(&mut *ptr, None);\n-            val.as_ref().map(|s: &Box<~[~[u8]]>| (**s).clone())\n+            val.as_ref().map(|s: &Box<Vec<~[u8]>>| (**s).clone())\n         })\n     }\n \n-    pub fn put(args: ~[~[u8]]) {\n+    pub fn put(args: Vec<~[u8]>) {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             rtassert!((*ptr).is_none());\n             (*ptr) = Some(box args.clone());\n         })\n     }\n \n-    pub fn clone() -> Option<~[~[u8]]> {\n+    pub fn clone() -> Option<Vec<~[u8]>> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n-            (*ptr).as_ref().map(|s: &Box<~[~[u8]]>| (**s).clone())\n+            (*ptr).as_ref().map(|s: &Box<Vec<~[u8]>>| (**s).clone())\n         })\n     }\n \n@@ -117,13 +119,13 @@ mod imp {\n         }\n     }\n \n-    fn get_global_ptr() -> *mut Option<Box<~[~[u8]]>> {\n+    fn get_global_ptr() -> *mut Option<Box<Vec<~[u8]>>> {\n         unsafe { cast::transmute(&global_args_ptr) }\n     }\n \n     // Copied from `os`.\n     #[cfg(not(test))]\n-    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~[u8]] {\n+    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> Vec<~[u8]> {\n         use c_str::CString;\n         use ptr::RawPtr;\n         use libc;\n@@ -133,7 +135,7 @@ mod imp {\n         Vec::from_fn(argc as uint, |i| {\n             let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n             cs.as_bytes_no_nul().to_owned()\n-        }).move_iter().collect()\n+        })\n     }\n \n     #[cfg(test)]\n@@ -147,7 +149,7 @@ mod imp {\n             // Preserve the actual global state.\n             let saved_value = take();\n \n-            let expected = box [bytes!(\"happy\").to_owned(), bytes!(\"today?\").to_owned()];\n+            let expected = vec![bytes!(\"happy\").to_owned(), bytes!(\"today?\").to_owned()];\n \n             put(expected.clone());\n             assert!(clone() == Some(expected.clone()));\n@@ -170,22 +172,23 @@ mod imp {\n #[cfg(target_os = \"win32\", not(test))]\n mod imp {\n     use option::Option;\n+    use vec::Vec;\n \n     pub unsafe fn init(_argc: int, _argv: **u8) {\n     }\n \n     pub fn cleanup() {\n     }\n \n-    pub fn take() -> Option<~[~[u8]]> {\n+    pub fn take() -> Option<Vec<~[u8]>> {\n         fail!()\n     }\n \n-    pub fn put(_args: ~[~[u8]]) {\n+    pub fn put(_args: Vec<~[u8]>) {\n         fail!()\n     }\n \n-    pub fn clone() -> Option<~[~[u8]]> {\n+    pub fn clone() -> Option<Vec<~[u8]>> {\n         fail!()\n     }\n }"}]}