{"sha": "485a80255b13840551e08f34a268528bbb2a33d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NWE4MDI1NWIxMzg0MDU1MWUwOGYzNGEyNjg1MjhiYmIyYTMzZDk=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-05-26T11:57:00Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-07-07T18:51:09Z"}, "message": "rustc/rustc_mir: Implement RFC 2203.\n\nThis commit implements RFC 2203, allowing constants in array repeat\nexpressions.\n\nFirstly, the check that the array repeat expression implements `Copy` is\nremoved and re-implemented in `rustc_mir::borrow_check::nll::type_check`\nby emitting an error when the MIR contains a `Operand::Move` and the\ntype does not implement `Copy`.\n\nNext, the `qualify_consts` pass is modified to construct a\n`Candidate::Repeat` when it would be correct to promote a array repeat\nexpression.\n\nFinally, the `promote_consts` pass is modified to promote the candidates\npreviously identified.", "tree": {"sha": "edc48f1df7eb38a5e02501e74db6be5047ca3bbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edc48f1df7eb38a5e02501e74db6be5047ca3bbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/485a80255b13840551e08f34a268528bbb2a33d9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl0iPx4ACgkQJZLnbIc4\nH9nzlBAAuWauGdPTOoY9/bT8Oajuwre9KXt52CHf8qP8qyhQQhIcI3SGQ/UJ/FVY\nUCOVeyEfoTzpfVO037EzOBz7r+1RLEhXlvT6cX3TTYrnGROKnf+flCrxkcwlpyfK\ndL98ajLUoU9d4gzWauruy05uNoEJ1Dy+M4/xhHi6Y9a+bQj6c7DRHxydlkgNEKnD\nNjmj6j2Sfp/ZLghqm0B/sSR7rNg9cYZK972GhmYTGDrGvc2z1+wf8bwCeEIL2Xlz\nH/gL7ZUUDMUCd2arW6DvvOC6LqynuePahN3ai3sNcoJtGB6XMwyusTDlbAzxFWQR\nmnOnsZiZ4Iqu3pXsNKFLUM8AkVVGKBmzI0+IIi+tnEGRL/3iM6FlZ8bKcfaVlDvv\n1/iWQsLl+I8gPis7U7DjCDYCJYQzm76VvxeQv9K6/Fmh9rRLl+Zh4QhFX/x9hkfw\ndJk9aKXKWlMrpG/zVjZTwdNU2HyZTAofoKaS0kSARCeYwS69JwB1/7wK4i3XmAqG\nzlGDTqnwg92t3S3yGewyLeQKuNq7+rCvpLVgwmg+3SB/XdOSCo1F+4/P1uGSnBia\nrY+VkIz0oCni5mX6qilVYCHWnRQwLb7+278Yi2bSnraS2WpKfoYv/DGSVLLdF15D\neiFExVm+1sTAnAg+DIwhwS8m4jGiaqbBc//vJvKduQAIGhSDD6Y=\n=W3oQ\n-----END PGP SIGNATURE-----", "payload": "tree edc48f1df7eb38a5e02501e74db6be5047ca3bbf\nparent 9210359b18185f46af9c0f30cc3d2678394930ef\nauthor David Wood <david@davidtw.co> 1558871820 +0100\ncommitter David Wood <david@davidtw.co> 1562525469 +0100\n\nrustc/rustc_mir: Implement RFC 2203.\n\nThis commit implements RFC 2203, allowing constants in array repeat\nexpressions.\n\nFirstly, the check that the array repeat expression implements `Copy` is\nremoved and re-implemented in `rustc_mir::borrow_check::nll::type_check`\nby emitting an error when the MIR contains a `Operand::Move` and the\ntype does not implement `Copy`.\n\nNext, the `qualify_consts` pass is modified to construct a\n`Candidate::Repeat` when it would be correct to promote a array repeat\nexpression.\n\nFinally, the `promote_consts` pass is modified to promote the candidates\npreviously identified.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/485a80255b13840551e08f34a268528bbb2a33d9", "html_url": "https://github.com/rust-lang/rust/commit/485a80255b13840551e08f34a268528bbb2a33d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/485a80255b13840551e08f34a268528bbb2a33d9/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9210359b18185f46af9c0f30cc3d2678394930ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/9210359b18185f46af9c0f30cc3d2678394930ef", "html_url": "https://github.com/rust-lang/rust/commit/9210359b18185f46af9c0f30cc3d2678394930ef"}], "stats": {"total": 654, "additions": 505, "deletions": 149}, "files": [{"sha": "a7b3a2cab119a1b13adddb36a822e9000e1e84cf", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -1564,10 +1564,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.note(&format!(\"required for the cast to the object type `{}`\",\n                                   self.ty_to_string(object_ty)));\n             }\n-            ObligationCauseCode::RepeatVec => {\n-                err.note(\"the `Copy` trait is required because the \\\n-                          repeated element will be copied\");\n-            }\n             ObligationCauseCode::VariableType(_) => {\n                 err.note(\"all local variables must have a statically known size\");\n                 if !self.tcx.features().unsized_locals {"}, {"sha": "b90f4ef91ce9cb0b16d0a564a405cd35ecd036b4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -195,8 +195,6 @@ pub enum ObligationCauseCode<'tcx> {\n     SizedReturnType,\n     /// Yield type must be Sized\n     SizedYieldType,\n-    /// [T,..n] --> T must be Copy\n-    RepeatVec,\n \n     /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n     FieldSized { adt_kind: AdtKind, last: bool },"}, {"sha": "7d160af1a561998ee8f9e9aa719ce87eace26e6f", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -488,7 +488,6 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::SizedArgumentType => Some(super::SizedArgumentType),\n             super::SizedReturnType => Some(super::SizedReturnType),\n             super::SizedYieldType => Some(super::SizedYieldType),\n-            super::RepeatVec => Some(super::RepeatVec),\n             super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n             super::ConstSized => Some(super::ConstSized),\n             super::SharedStatic => Some(super::SharedStatic),"}, {"sha": "90812599f93c81dbc58514da17692c672984ecd8", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 56, "deletions": 32, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -501,28 +501,38 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             // FIXME use place_projection.is_empty() when is available\n             if let Place::Base(_) = place {\n                 if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                    let tcx = self.tcx();\n-                    let trait_ref = ty::TraitRef {\n-                        def_id: tcx.lang_items().copy_trait().unwrap(),\n-                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                    let is_promoted = match place {\n+                        Place::Base(PlaceBase::Static(box Static {\n+                            kind: StaticKind::Promoted(_),\n+                            ..\n+                        })) => true,\n+                        _ => false,\n                     };\n \n-                    // In order to have a Copy operand, the type T of the\n-                    // value must be Copy. Note that we prove that T: Copy,\n-                    // rather than using the `is_copy_modulo_regions`\n-                    // test. This is important because\n-                    // `is_copy_modulo_regions` ignores the resulting region\n-                    // obligations and assumes they pass. This can result in\n-                    // bounds from Copy impls being unsoundly ignored (e.g.,\n-                    // #29149). Note that we decide to use Copy before knowing\n-                    // whether the bounds fully apply: in effect, the rule is\n-                    // that if a value of some type could implement Copy, then\n-                    // it must.\n-                    self.cx.prove_trait_ref(\n-                        trait_ref,\n-                        location.to_locations(),\n-                        ConstraintCategory::CopyBound,\n-                    );\n+                    if !is_promoted {\n+                        let tcx = self.tcx();\n+                        let trait_ref = ty::TraitRef {\n+                            def_id: tcx.lang_items().copy_trait().unwrap(),\n+                            substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                        };\n+\n+                        // In order to have a Copy operand, the type T of the\n+                        // value must be Copy. Note that we prove that T: Copy,\n+                        // rather than using the `is_copy_modulo_regions`\n+                        // test. This is important because\n+                        // `is_copy_modulo_regions` ignores the resulting region\n+                        // obligations and assumes they pass. This can result in\n+                        // bounds from Copy impls being unsoundly ignored (e.g.,\n+                        // #29149). Note that we decide to use Copy before knowing\n+                        // whether the bounds fully apply: in effect, the rule is\n+                        // that if a value of some type could implement Copy, then\n+                        // it must.\n+                        self.cx.prove_trait_ref(\n+                            trait_ref,\n+                            location.to_locations(),\n+                            ConstraintCategory::CopyBound,\n+                        );\n+                    }\n                 }\n             }\n \n@@ -1953,18 +1963,32 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::Repeat(operand, len) => if *len > 1 {\n-                let operand_ty = operand.ty(body, tcx);\n-\n-                let trait_ref = ty::TraitRef {\n-                    def_id: tcx.lang_items().copy_trait().unwrap(),\n-                    substs: tcx.mk_substs_trait(operand_ty, &[]),\n-                };\n-\n-                self.prove_trait_ref(\n-                    trait_ref,\n-                    location.to_locations(),\n-                    ConstraintCategory::CopyBound,\n-                );\n+                if let Operand::Move(_) = operand {\n+                    // While this is located in `nll::typeck` this error is not an NLL error, it's\n+                    // a required check to make sure that repeated elements implement `Copy`.\n+                    let span = body.source_info(location).span;\n+                    let ty = operand.ty(body, tcx);\n+                    let is_copy = self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span);\n+                    if !is_copy {\n+                        let copy_path = self.tcx().def_path_str(\n+                            self.tcx().lang_items().copy_trait().unwrap());\n+                        self.tcx().sess\n+                            .struct_span_err(\n+                                span,\n+                                &format!(\"repeated expression does not implement `{}`\", copy_path),\n+                            )\n+                            .span_label(span, &format!(\n+                                \"the trait `{}` is not implemented for `{}`\",\n+                                copy_path, ty,\n+                            ))\n+                            .note(&format!(\n+                                \"the `{}` trait is required because the repeated element will be \\\n+                                 copied\",\n+                                 copy_path,\n+                            ))\n+                            .emit();\n+                    }\n+                }\n             },\n \n             Rvalue::NullaryOp(_, ty) => {"}, {"sha": "33eb4106d073567ffc6ebdf05d35dd571ec9156e", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -60,6 +60,9 @@ pub enum Candidate {\n     /// Borrow of a constant temporary.\n     Ref(Location),\n \n+    /// Promotion of the `x` in `[x; 32]`.\n+    Repeat(Location),\n+\n     /// Currently applied to function calls where the callee has the unstable\n     /// `#[rustc_args_required_const]` attribute as well as the SIMD shuffle\n     /// intrinsic. The intrinsic requires the arguments are indeed constant and\n@@ -322,6 +325,17 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         _ => bug!()\n                     }\n                 }\n+                Candidate::Repeat(loc) => {\n+                    let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n+                    match statement.kind {\n+                        StatementKind::Assign(_, box Rvalue::Repeat(ref mut operand, _)) => {\n+                            let ty = operand.ty(local_decls, self.tcx);\n+                            let span = statement.source_info.span;\n+                            mem::replace(operand, Operand::Copy(promoted_place(ty, span)))\n+                        }\n+                        _ => bug!()\n+                    }\n+                },\n                 Candidate::Argument { bb, index } => {\n                     let terminator = blocks[bb].terminator_mut();\n                     match terminator.kind {\n@@ -380,6 +394,7 @@ pub fn promote_candidates<'tcx>(\n \n     for candidate in candidates.into_iter().rev() {\n         match candidate {\n+            Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n                 match body[block].statements[statement_index].kind {\n                     StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _) => {"}, {"sha": "0b90076bd4688a120024f146ce23f54159b863c3", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 96, "deletions": 78, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -726,84 +726,97 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let mut qualifs = self.qualifs_in_value(source);\n \n-        if let ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) = source {\n-            // Getting `true` from `HasMutInterior::in_rvalue` means\n-            // the borrowed place is disallowed from being borrowed,\n-            // due to either a mutable borrow (with some exceptions),\n-            // or an shared borrow of a value with interior mutability.\n-            // Then `HasMutInterior` is replaced with `IsNotPromotable`,\n-            // to avoid duplicate errors (e.g. from reborrowing).\n-            if qualifs[HasMutInterior] {\n-                qualifs[HasMutInterior] = false;\n-                qualifs[IsNotPromotable] = true;\n+        match source {\n+            ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) => {\n+                // Getting `true` from `HasMutInterior::in_rvalue` means\n+                // the borrowed place is disallowed from being borrowed,\n+                // due to either a mutable borrow (with some exceptions),\n+                // or an shared borrow of a value with interior mutability.\n+                // Then `HasMutInterior` is replaced with `IsNotPromotable`,\n+                // to avoid duplicate errors (e.g. from reborrowing).\n+                if qualifs[HasMutInterior] {\n+                    qualifs[HasMutInterior] = false;\n+                    qualifs[IsNotPromotable] = true;\n \n-                if self.mode.requires_const_checking() {\n-                    if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                        if let BorrowKind::Mut { .. } = kind {\n-                            let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                        \"references in {}s may only refer \\\n-                                                            to immutable values\", self.mode);\n-                            err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                                self.mode));\n-                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                                err.note(\"References in statics and constants may only refer to \\\n-                                        immutable values.\\n\\n\\\n-                                        Statics are shared everywhere, and if they refer to \\\n-                                        mutable data one might violate memory safety since \\\n-                                        holding multiple mutable references to shared data is \\\n-                                        not allowed.\\n\\n\\\n-                                        If you really want global mutable state, try using \\\n-                                        static mut or a global UnsafeCell.\");\n+                    if self.mode.requires_const_checking() {\n+                        if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                            if let BorrowKind::Mut { .. } = kind {\n+                                let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                               \"references in {}s may only refer \\\n+                                                                to immutable values\", self.mode);\n+                                err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                                    self.mode));\n+                                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                    err.note(\"References in statics and constants may only refer \\\n+                                              to immutable values.\\n\\n\\\n+                                              Statics are shared everywhere, and if they refer to \\\n+                                              mutable data one might violate memory safety since \\\n+                                              holding multiple mutable references to shared data \\\n+                                              is not allowed.\\n\\n\\\n+                                              If you really want global mutable state, try using \\\n+                                              static mut or a global UnsafeCell.\");\n+                                }\n+                                err.emit();\n+                            } else {\n+                                span_err!(self.tcx.sess, self.span, E0492,\n+                                          \"cannot borrow a constant which may contain \\\n+                                           interior mutability, create a static instead\");\n                             }\n-                            err.emit();\n-                        } else {\n-                            span_err!(self.tcx.sess, self.span, E0492,\n-                                    \"cannot borrow a constant which may contain \\\n-                                    interior mutability, create a static instead\");\n                         }\n                     }\n-                }\n-            } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n-                // Don't promote BorrowKind::Shallow borrows, as they don't\n-                // reach codegen.\n-\n-                // We might have a candidate for promotion.\n-                let candidate = Candidate::Ref(location);\n-                // Start by traversing to the \"base\", with non-deref projections removed.\n-                let mut place = place;\n-                while let Place::Projection(ref proj) = *place {\n-                    if proj.elem == ProjectionElem::Deref {\n-                        break;\n+                } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n+                    // Don't promote BorrowKind::Shallow borrows, as they don't\n+                    // reach codegen.\n+\n+                    // We might have a candidate for promotion.\n+                    let candidate = Candidate::Ref(location);\n+                    // Start by traversing to the \"base\", with non-deref projections removed.\n+                    let mut place = place;\n+                    while let Place::Projection(ref proj) = *place {\n+                        if proj.elem == ProjectionElem::Deref {\n+                            break;\n+                        }\n+                        place = &proj.base;\n                     }\n-                    place = &proj.base;\n-                }\n-                debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n-                // We can only promote interior borrows of promotable temps (non-temps\n-                // don't get promoted anyway).\n-                // (If we bailed out of the loop due to a `Deref` above, we will definitely\n-                // not enter the conditional here.)\n-                if let Place::Base(PlaceBase::Local(local)) = *place {\n-                    if self.body.local_kind(local) == LocalKind::Temp {\n-                        debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n-                        // The borrowed place doesn't have `HasMutInterior`\n-                        // (from `in_rvalue`), so we can safely ignore\n-                        // `HasMutInterior` from the local's qualifications.\n-                        // This allows borrowing fields which don't have\n-                        // `HasMutInterior`, from a type that does, e.g.:\n-                        // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                        let mut local_qualifs = self.qualifs_in_local(local);\n-                        // Any qualifications, except HasMutInterior (see above), disqualify\n-                        // from promotion.\n-                        // This is, in particular, the \"implicit promotion\" version of\n-                        // the check making sure that we don't run drop glue during const-eval.\n-                        local_qualifs[HasMutInterior] = false;\n-                        if !local_qualifs.0.iter().any(|&qualif| qualif) {\n-                            debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n-                            self.promotion_candidates.push(candidate);\n+                    debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n+                    // We can only promote interior borrows of promotable temps (non-temps\n+                    // don't get promoted anyway).\n+                    // (If we bailed out of the loop due to a `Deref` above, we will definitely\n+                    // not enter the conditional here.)\n+                    if let Place::Base(PlaceBase::Local(local)) = *place {\n+                        if self.body.local_kind(local) == LocalKind::Temp {\n+                            debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n+                            // The borrowed place doesn't have `HasMutInterior`\n+                            // (from `in_rvalue`), so we can safely ignore\n+                            // `HasMutInterior` from the local's qualifications.\n+                            // This allows borrowing fields which don't have\n+                            // `HasMutInterior`, from a type that does, e.g.:\n+                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                            let mut local_qualifs = self.qualifs_in_local(local);\n+                            // Any qualifications, except HasMutInterior (see above), disqualify\n+                            // from promotion.\n+                            // This is, in particular, the \"implicit promotion\" version of\n+                            // the check making sure that we don't run drop glue during const-eval.\n+                            local_qualifs[HasMutInterior] = false;\n+                            if !local_qualifs.0.iter().any(|&qualif| qualif) {\n+                                debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n+                                self.promotion_candidates.push(candidate);\n+                            }\n                         }\n                     }\n                 }\n-            }\n+            },\n+            ValueSource::Rvalue(&Rvalue::Repeat(ref operand, _)) => {\n+                let candidate = Candidate::Repeat(location);\n+                let not_promotable = IsNotImplicitlyPromotable::in_operand(self, operand) ||\n+                                     IsNotPromotable::in_operand(self, operand);\n+                debug!(\"assign: self.def_id={:?} operand={:?}\", self.def_id, operand);\n+                if !not_promotable {\n+                    debug!(\"assign: candidate={:?}\", candidate);\n+                    self.promotion_candidates.push(candidate);\n+                }\n+            },\n+            _ => {},\n         }\n \n         let mut dest = dest;\n@@ -933,15 +946,20 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         debug!(\"qualify_const: promotion_candidates={:?}\", self.promotion_candidates);\n         for candidate in &self.promotion_candidates {\n             match *candidate {\n+                Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n+                    if let StatementKind::Assign(_, box Rvalue::Repeat(\n+                        Operand::Move(Place::Base(PlaceBase::Local(index))),\n+                        _\n+                    )) = self.body[bb].statements[stmt_idx].kind {\n+                        promoted_temps.insert(index);\n+                    }\n+                }\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                    match self.body[bb].statements[stmt_idx].kind {\n-                        StatementKind::Assign(\n-                            _,\n-                            box Rvalue::Ref(_, _, Place::Base(PlaceBase::Local(index)))\n-                        ) => {\n-                            promoted_temps.insert(index);\n-                        }\n-                        _ => {}\n+                    if let StatementKind::Assign(\n+                        _,\n+                        box Rvalue::Ref(_, _, Place::Base(PlaceBase::Local(index)))\n+                    ) = self.body[bb].statements[stmt_idx].kind {\n+                        promoted_temps.insert(index);\n                     }\n                 }\n                 Candidate::Argument { .. } => {}"}, {"sha": "f2dbceb31b9ca58ea15cd43bc260a308a2e722cc", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -13,7 +13,6 @@ use crate::check::report_unexpected_variant_res;\n use crate::check::Needs;\n use crate::check::TupleArgumentsFlag::DontTupleArguments;\n use crate::check::method::SelfSource;\n-use crate::middle::lang_items;\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n@@ -863,7 +862,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         element: &'tcx hir::Expr,\n         count: &'tcx hir::AnonConst,\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        _expr: &'tcx hir::Expr,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let count_def_id = tcx.hir().local_def_id(count.hir_id);\n@@ -911,16 +910,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        if let Ok(count) = count {\n-            let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n-            if !zero_or_one {\n-                // For [foo, ..n] where n > 1, `foo` must have\n-                // Copy type:\n-                let lang_item = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n-            }\n-        }\n-\n         if element_ty.references_error() {\n             tcx.types.err\n         } else if let Ok(count) = count {"}, {"sha": "7bb36f41b8f9d1a3cd0b76a3ed31fa99b79dd35e", "filename": "src/test/ui/const-generics/issue-61336-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -3,11 +3,12 @@\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; {N}]\n+    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn g<T, const N: usize>(x: T) -> [T; N] {\n     [x; {N}]\n-    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied [E0277]\n+    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn main() {"}, {"sha": "473ed46b104e917e8f698ae248e1ab01fd5540ec", "filename": "src/test/ui/const-generics/issue-61336-2.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -4,15 +4,17 @@ warning: the feature `const_generics` is incomplete and may cause the compiler t\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n-  --> $DIR/issue-61336-2.rs:9:5\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336-2.rs:5:9\n    |\n LL |     [x; {N}]\n-   |     ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |         ^^^\n+\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336-2.rs:10:9\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n-   = note: the `Copy` trait is required because the repeated element will be copied\n+LL |     [x; {N}]\n+   |         ^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "edc012cbb3d13c7f30ee803381d5b4c94130a5bd", "filename": "src/test/ui/const-generics/issue-61336.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -3,11 +3,12 @@\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n+    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn g<T, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n-    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied [E0277]\n+    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn main() {"}, {"sha": "ae4ef3a906a4fd8c12c53f0878aaa8f11594c3e7", "filename": "src/test/ui/const-generics/issue-61336.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -4,15 +4,17 @@ warning: the feature `const_generics` is incomplete and may cause the compiler t\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n-  --> $DIR/issue-61336.rs:9:5\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336.rs:5:9\n    |\n LL |     [x; N]\n-   |     ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |         ^\n+\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336.rs:10:9\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n-   = note: the `Copy` trait is required because the repeated element will be copied\n+LL |     [x; N]\n+   |         ^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "9bed2b7197ce25779784949e9289883400dc7a6f", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/migrate-borrowck.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-borrowck.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -0,0 +1,138 @@\n+// ignore-compile-mode-nll\n+// compile-flags: -Z borrowck=migrate\n+#![allow(warnings)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+mod constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_no_elements() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 0] = [FOO; 0];\n+    }\n+\n+    fn no_impl_copy_empty_value_single_element() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 1] = [FOO; 1];\n+    }\n+\n+    fn no_impl_copy_empty_value_multiple_elements() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 2] = [FOO; 2];\n+    }\n+\n+    fn no_impl_copy_value_no_elements() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 0] = [FOO; 0];\n+    }\n+\n+    fn no_impl_copy_value_single_element() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 1] = [FOO; 1];\n+    }\n+\n+    fn no_impl_copy_value_multiple_elements() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 2] = [FOO; 2];\n+    }\n+\n+    fn impl_copy_empty_value_no_elements() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 0] = [FOO; 0];\n+    }\n+\n+    fn impl_copy_empty_value_one_element() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 1] = [FOO; 1];\n+    }\n+\n+    fn impl_copy_empty_value_multiple_elements() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 2] = [FOO; 2];\n+    }\n+\n+    fn impl_copy_value_no_elements() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 0] = [FOO; 0];\n+    }\n+\n+    fn impl_copy_value_one_element() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 1] = [FOO; 1];\n+    }\n+\n+    fn impl_copy_value_multiple_elements() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 2] = [FOO; 2];\n+    }\n+}\n+\n+mod non_constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_no_elements() {\n+        let x = None;\n+        let arr: [Option<Bar>; 0] = [x; 0];\n+    }\n+\n+    fn no_impl_copy_empty_value_single_element() {\n+        let x = None;\n+        let arr: [Option<Bar>; 1] = [x; 1];\n+    }\n+\n+    fn no_impl_copy_empty_value_multiple_elements() {\n+        let x = None;\n+        let arr: [Option<Bar>; 2] = [x; 2];\n+        //~^ ERROR repeated expression does not implement `std::marker::Copy`\n+    }\n+\n+    fn no_impl_copy_value_no_elements() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 0] = [x; 0];\n+    }\n+\n+    fn no_impl_copy_value_single_element() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 1] = [x; 1];\n+    }\n+\n+    fn no_impl_copy_value_multiple_elements() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 2] = [x; 2];\n+        //~^ ERROR repeated expression does not implement `std::marker::Copy`\n+    }\n+\n+    fn impl_copy_empty_value_no_elements() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 0] = [x; 0];\n+    }\n+\n+    fn impl_copy_empty_value_one_element() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_empty_value_multiple_elements() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 2] = [x; 2];\n+    }\n+\n+    fn impl_copy_value_no_elements() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 0] = [x; 0];\n+    }\n+\n+    fn impl_copy_value_one_element() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_value_multiple_elements() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 2] = [x; 2];\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7a9b6a099b7287c1f2e672386b4e8b1a515c425b", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/migrate-borrowck.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-borrowck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-borrowck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-borrowck.stderr?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -0,0 +1,18 @@\n+error: repeated expression does not implement `std::marker::Copy`\n+  --> $DIR/migrate-borrowck.rs:87:37\n+   |\n+LL |         let arr: [Option<Bar>; 2] = [x; 2];\n+   |                                     ^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = note: the `std::marker::Copy` trait is required because the repeated element will be copied\n+\n+error: repeated expression does not implement `std::marker::Copy`\n+  --> $DIR/migrate-borrowck.rs:103:37\n+   |\n+LL |         let arr: [Option<Bar>; 2] = [x; 2];\n+   |                                     ^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = note: the `std::marker::Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "054a0139109b04c3fa864e93a84d744cd27b17d3", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/nll-borrowck.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-borrowck.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -0,0 +1,138 @@\n+// ignore-compile-mode-nll\n+#![allow(warnings)]\n+#![feature(nll)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+mod constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_no_elements() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 0] = [FOO; 0];\n+    }\n+\n+    fn no_impl_copy_empty_value_single_element() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 1] = [FOO; 1];\n+    }\n+\n+    fn no_impl_copy_empty_value_multiple_elements() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 2] = [FOO; 2];\n+    }\n+\n+    fn no_impl_copy_value_no_elements() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 0] = [FOO; 0];\n+    }\n+\n+    fn no_impl_copy_value_single_element() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 1] = [FOO; 1];\n+    }\n+\n+    fn no_impl_copy_value_multiple_elements() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 2] = [FOO; 2];\n+    }\n+\n+    fn impl_copy_empty_value_no_elements() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 0] = [FOO; 0];\n+    }\n+\n+    fn impl_copy_empty_value_one_element() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 1] = [FOO; 1];\n+    }\n+\n+    fn impl_copy_empty_value_multiple_elements() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 2] = [FOO; 2];\n+    }\n+\n+    fn impl_copy_value_no_elements() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 0] = [FOO; 0];\n+    }\n+\n+    fn impl_copy_value_one_element() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 1] = [FOO; 1];\n+    }\n+\n+    fn impl_copy_value_multiple_elements() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 2] = [FOO; 2];\n+    }\n+}\n+\n+mod non_constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_no_elements() {\n+        let x = None;\n+        let arr: [Option<Bar>; 0] = [x; 0];\n+    }\n+\n+    fn no_impl_copy_empty_value_single_element() {\n+        let x = None;\n+        let arr: [Option<Bar>; 1] = [x; 1];\n+    }\n+\n+    fn no_impl_copy_empty_value_multiple_elements() {\n+        let x = None;\n+        let arr: [Option<Bar>; 2] = [x; 2];\n+        //~^ ERROR repeated expression does not implement `std::marker::Copy`\n+    }\n+\n+    fn no_impl_copy_value_no_elements() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 0] = [x; 0];\n+    }\n+\n+    fn no_impl_copy_value_single_element() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 1] = [x; 1];\n+    }\n+\n+    fn no_impl_copy_value_multiple_elements() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 2] = [x; 2];\n+        //~^ ERROR repeated expression does not implement `std::marker::Copy`\n+    }\n+\n+    fn impl_copy_empty_value_no_elements() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 0] = [x; 0];\n+    }\n+\n+    fn impl_copy_empty_value_one_element() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_empty_value_multiple_elements() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 2] = [x; 2];\n+    }\n+\n+    fn impl_copy_value_no_elements() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 0] = [x; 0];\n+    }\n+\n+    fn impl_copy_value_one_element() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_value_multiple_elements() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 2] = [x; 2];\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5cd6d2a8f06379dfcbb1e365477b6dbae228b972", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/nll-borrowck.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-borrowck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-borrowck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-borrowck.stderr?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -0,0 +1,18 @@\n+error: repeated expression does not implement `std::marker::Copy`\n+  --> $DIR/nll-borrowck.rs:87:37\n+   |\n+LL |         let arr: [Option<Bar>; 2] = [x; 2];\n+   |                                     ^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = note: the `std::marker::Copy` trait is required because the repeated element will be copied\n+\n+error: repeated expression does not implement `std::marker::Copy`\n+  --> $DIR/nll-borrowck.rs:103:37\n+   |\n+LL |         let arr: [Option<Bar>; 2] = [x; 2];\n+   |                                     ^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = note: the `std::marker::Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "14336435fe8cd9d318fefd502646146c7a765f60", "filename": "src/test/ui/repeat-to-run-dtor-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.rs?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -15,5 +15,5 @@ impl Drop for Foo {\n fn main() {\n     let a = Foo { x: 3 };\n     let _ = [ a; 5 ];\n-    //~^ ERROR `Foo: std::marker::Copy` is not satisfied\n+    //~^ ERROR repeated expression does not implement `std::marker::Copy`\n }"}, {"sha": "dff6332f61bf139b2d3933e0cbcdcf8e4f5da58b", "filename": "src/test/ui/repeat-to-run-dtor-twice.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/485a80255b13840551e08f34a268528bbb2a33d9/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.stderr?ref=485a80255b13840551e08f34a268528bbb2a33d9", "patch": "@@ -1,11 +1,10 @@\n-error[E0277]: the trait bound `Foo: std::marker::Copy` is not satisfied\n+error: repeated expression does not implement `std::marker::Copy`\n   --> $DIR/repeat-to-run-dtor-twice.rs:17:13\n    |\n LL |     let _ = [ a; 5 ];\n    |             ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `Foo`\n    |\n-   = note: the `Copy` trait is required because the repeated element will be copied\n+   = note: the `std::marker::Copy` trait is required because the repeated element will be copied\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}]}