{"sha": "13b235d1e5d7604f0f1b4bfd9941ff046cef1277", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzYjIzNWQxZTVkNzYwNGYwZjFiNGJmZDk5NDFmZjA0NmNlZjEyNzc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-27T20:05:13Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:56Z"}, "message": "libsyntax: De-`@mut` `StringReader::last_pos`", "tree": {"sha": "004518b3f75bcc6422ccd1e4ac8f747f152057af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/004518b3f75bcc6422ccd1e4ac8f747f152057af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13b235d1e5d7604f0f1b4bfd9941ff046cef1277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13b235d1e5d7604f0f1b4bfd9941ff046cef1277", "html_url": "https://github.com/rust-lang/rust/commit/13b235d1e5d7604f0f1b4bfd9941ff046cef1277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13b235d1e5d7604f0f1b4bfd9941ff046cef1277/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b33386d05599cc5991fcb4014efcfcf9e211064c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b33386d05599cc5991fcb4014efcfcf9e211064c", "html_url": "https://github.com/rust-lang/rust/commit/b33386d05599cc5991fcb4014efcfcf9e211064c"}], "stats": {"total": 102, "additions": 54, "deletions": 48}, "files": [{"sha": "a40505d7b4408fcffc2298b27356fecad52afa7f", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13b235d1e5d7604f0f1b4bfd9941ff046cef1277/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13b235d1e5d7604f0f1b4bfd9941ff046cef1277/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=13b235d1e5d7604f0f1b4bfd9941ff046cef1277", "patch": "@@ -161,7 +161,11 @@ fn consume_non_eol_whitespace(rdr: @mut StringReader) {\n fn push_blank_line_comment(rdr: @mut StringReader, comments: &mut ~[cmnt]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n-    comments.push(cmnt {style: blank_line, lines: v, pos: rdr.last_pos});\n+    comments.push(cmnt {\n+        style: blank_line,\n+        lines: v,\n+        pos: rdr.last_pos.get(),\n+    });\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: @mut StringReader,\n@@ -178,7 +182,7 @@ fn consume_whitespace_counting_blank_lines(rdr: @mut StringReader,\n fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n                                             comments: &mut ~[cmnt]) {\n     debug!(\">>> shebang comment\");\n-    let p = rdr.last_pos;\n+    let p = rdr.last_pos.get();\n     debug!(\"<<< shebang comment\");\n     comments.push(cmnt {\n         style: if code_to_the_left { trailing } else { isolated },\n@@ -190,7 +194,7 @@ fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n     debug!(\">>> line comments\");\n-    let p = rdr.last_pos;\n+    let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n@@ -248,7 +252,7 @@ fn read_block_comment(rdr: @mut StringReader,\n                       code_to_the_left: bool,\n                       comments: &mut ~[cmnt]) {\n     debug!(\">>> block comment\");\n-    let p = rdr.last_pos;\n+    let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n     let col: CharPos = rdr.col;\n     bump(rdr);\n@@ -370,7 +374,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         }\n \n \n-        let bstart = rdr.last_pos;\n+        let bstart = rdr.last_pos.get();\n         rdr.next_token();\n         //discard, and look ahead; we're working with internal state\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();"}, {"sha": "b6954d0ad7bba9da66ca4a4c057657b5249eca02", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/13b235d1e5d7604f0f1b4bfd9941ff046cef1277/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13b235d1e5d7604f0f1b4bfd9941ff046cef1277/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=13b235d1e5d7604f0f1b4bfd9941ff046cef1277", "patch": "@@ -46,7 +46,7 @@ pub struct StringReader {\n     // The absolute offset within the codemap of the next character to read\n     pos: Cell<BytePos>,\n     // The absolute offset within the codemap of the last character read(curr)\n-    last_pos: BytePos,\n+    last_pos: Cell<BytePos>,\n     // The column of the next character to read\n     col: CharPos,\n     // The last character to be read\n@@ -75,7 +75,7 @@ pub fn new_low_level_string_reader(span_diagnostic: @mut SpanHandler,\n         span_diagnostic: span_diagnostic,\n         src: filemap.src,\n         pos: Cell::new(filemap.start_pos),\n-        last_pos: filemap.start_pos,\n+        last_pos: Cell::new(filemap.start_pos),\n         col: CharPos(0),\n         curr: initial_char,\n         filemap: filemap,\n@@ -95,7 +95,7 @@ fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n         span_diagnostic: r.span_diagnostic,\n         src: r.src,\n         pos: Cell::new(r.pos.get()),\n-        last_pos: r.last_pos,\n+        last_pos: Cell::new(r.last_pos.get()),\n         col: r.col,\n         curr: r.curr,\n         filemap: r.filemap,\n@@ -201,9 +201,9 @@ fn string_advance_token(r: @mut StringReader) {\n             if is_eof(r) {\n                 r.peek_tok = token::EOF;\n             } else {\n-                let start_bytepos = r.last_pos;\n+                let start_bytepos = r.last_pos.get();\n                 r.peek_tok = next_token_inner(r);\n-                r.peek_span = codemap::mk_sp(start_bytepos, r.last_pos);\n+                r.peek_span = codemap::mk_sp(start_bytepos, r.last_pos.get());\n             };\n         }\n     }\n@@ -221,7 +221,7 @@ pub fn with_str_from<T>(\n                      start: BytePos,\n                      f: |s: &str| -> T)\n                      -> T {\n-    with_str_from_to(rdr, start, rdr.last_pos, f)\n+    with_str_from_to(rdr, start, rdr.last_pos.get(), f)\n }\n \n /// Calls `f` with astring slice of the source text spanning from `start`\n@@ -240,7 +240,7 @@ fn with_str_from_to<T>(\n // EFFECT: advance the StringReader by one character. If a newline is\n // discovered, add it to the FileMap's list of line start offsets.\n pub fn bump(rdr: &mut StringReader) {\n-    rdr.last_pos = rdr.pos.get();\n+    rdr.last_pos.set(rdr.pos.get());\n     let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if current_byte_offset < (rdr.src).len() {\n         assert!(rdr.curr != unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n@@ -251,7 +251,7 @@ pub fn bump(rdr: &mut StringReader) {\n         rdr.curr = next.ch;\n         rdr.col = rdr.col + CharPos(1u);\n         if last_char == '\\n' {\n-            rdr.filemap.next_line(rdr.last_pos);\n+            rdr.filemap.next_line(rdr.last_pos.get());\n             rdr.col = CharPos(0u);\n         }\n \n@@ -353,7 +353,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n             // we're at the beginning of the file...\n             let cmap = @CodeMap::new();\n             (*cmap).files.push(rdr.filemap);\n-            let loc = cmap.lookup_char_pos_adj(rdr.last_pos);\n+            let loc = cmap.lookup_char_pos_adj(rdr.last_pos.get());\n             if loc.line == 1u && loc.col == CharPos(0u) {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n@@ -382,7 +382,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n             } else {\n                 ~\"unterminated block comment\"\n             };\n-            fatal_span(rdr, start_bpos, rdr.last_pos, msg);\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(), msg);\n         } else if rdr.curr == '/' && nextch(rdr) == '*' {\n             level += 1;\n             bump(rdr);\n@@ -431,7 +431,7 @@ fn scan_exponent(rdr: @mut StringReader, start_bpos: BytePos) -> Option<~str> {\n         if exponent.len() > 0u {\n             return Some(rslt + exponent);\n         } else {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                        ~\"scan_exponent: bad fp literal\");\n         }\n     } else { return None::<~str>; }\n@@ -457,7 +457,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     let mut base = 10u;\n     let mut c = c;\n     let mut n = nextch(rdr);\n-    let start_bpos = rdr.last_pos;\n+    let start_bpos = rdr.last_pos.get();\n     if c == '0' && n == 'x' {\n         bump(rdr);\n         bump(rdr);\n@@ -506,12 +506,12 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n                       else { Unsigned(ast::ty_u64) };\n         }\n         if num_str.len() == 0u {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                        ~\"no valid digits found for number\");\n         }\n         let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n-            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+            None => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                                ~\"int literal is too large\")\n         };\n \n@@ -530,11 +530,11 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n     if is_float {\n         match base {\n-          16u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+          16u => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                             ~\"hexadecimal float literal is not supported\"),\n-          8u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+          8u => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"octal float literal is not supported\"),\n-          2u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+          2u => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"binary float literal is not supported\"),\n           _ => ()\n         }\n@@ -565,19 +565,20 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n             32-bit or 64-bit float, it won't be noticed till the\n             back-end.  */\n         } else {\n-            fatal_span(rdr, start_bpos, rdr.last_pos, ~\"expected `f32` or `f64` suffix\");\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n+                       ~\"expected `f32` or `f64` suffix\");\n         }\n     }\n     if is_float {\n         return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n         if num_str.len() == 0u {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                        ~\"no valid digits found for number\");\n         }\n         let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n-            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+            None => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                                ~\"int literal is too large\")\n         };\n \n@@ -589,11 +590,11 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n     let mut accum_int = 0;\n     let mut i = n_hex_digits;\n-    let start_bpos = rdr.last_pos;\n+    let start_bpos = rdr.last_pos.get();\n     while i != 0u {\n         let n = rdr.curr;\n         if !is_hex_digit(n) {\n-            fatal_span_char(rdr, rdr.last_pos, rdr.pos.get(),\n+            fatal_span_char(rdr, rdr.last_pos.get(), rdr.pos.get(),\n                             ~\"illegal character in numeric character escape\",\n                             n);\n         }\n@@ -604,7 +605,7 @@ fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n     }\n     match char::from_u32(accum_int as u32) {\n         Some(x) => x,\n-        None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+        None => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"illegal numeric character escape\")\n     }\n }\n@@ -633,7 +634,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         // Note: r as in r\" or r#\" is part of a raw string literal,\n         // not an identifier, and is handled further down.\n \n-        let start = rdr.last_pos;\n+        let start = rdr.last_pos.get();\n         while ident_continue(rdr.curr) {\n             bump(rdr);\n         }\n@@ -751,7 +752,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '\\'' => {\n         // Either a character constant 'a' OR a lifetime name 'abc\n         bump(rdr);\n-        let start = rdr.last_pos;\n+        let start = rdr.last_pos.get();\n         let mut c2 = rdr.curr;\n         bump(rdr);\n \n@@ -766,11 +767,12 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 let tok = &token::IDENT(ident, false);\n \n                 if token::is_keyword(token::keywords::Self, tok) {\n-                    fatal_span(rdr, start, rdr.last_pos,\n+                    fatal_span(rdr, start, rdr.last_pos.get(),\n                                ~\"invalid lifetime name: 'self is no longer a special lifetime\");\n                 } else if token::is_any_keyword(tok) &&\n                     !token::is_keyword(token::keywords::Static, tok) {\n-                    fatal_span(rdr, start, rdr.last_pos, ~\"invalid lifetime name\");\n+                    fatal_span(rdr, start, rdr.last_pos.get(),\n+                               ~\"invalid lifetime name\");\n                 } else {\n                     token::LIFETIME(ident)\n                 }\n@@ -782,7 +784,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             '\\\\' => {\n                 // '\\X' for some X must be a character constant:\n                 let escaped = rdr.curr;\n-                let escaped_pos = rdr.last_pos;\n+                let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n                     'n' => { c2 = '\\n'; }\n@@ -796,13 +798,13 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                     'u' => { c2 = scan_numeric_escape(rdr, 4u); }\n                     'U' => { c2 = scan_numeric_escape(rdr, 8u); }\n                     c2 => {\n-                        fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n+                        fatal_span_char(rdr, escaped_pos, rdr.last_pos.get(),\n                                         ~\"unknown character escape\", c2);\n                     }\n                 }\n             }\n             '\\t' | '\\n' | '\\r' | '\\'' => {\n-                fatal_span_char(rdr, start, rdr.last_pos,\n+                fatal_span_char(rdr, start, rdr.last_pos.get(),\n                                 ~\"character constant must be escaped\", c2);\n             }\n             _ => {}\n@@ -813,19 +815,19 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                                // character before position `start` is an\n                                // ascii single quote.\n                                start - BytePos(1),\n-                               rdr.last_pos,\n+                               rdr.last_pos.get(),\n                                ~\"unterminated character constant\");\n         }\n         bump(rdr); // advance curr past token\n         return token::LIT_CHAR(c2 as u32);\n       }\n       '\"' => {\n         let mut accum_str = ~\"\";\n-        let start_bpos = rdr.last_pos;\n+        let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n         while rdr.curr != '\"' {\n             if is_eof(rdr) {\n-                fatal_span(rdr, start_bpos, rdr.last_pos,\n+                fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated double quote string\");\n             }\n \n@@ -834,7 +836,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             match ch {\n               '\\\\' => {\n                 let escaped = rdr.curr;\n-                let escaped_pos = rdr.last_pos;\n+                let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n                   'n' => accum_str.push_char('\\n'),\n@@ -855,7 +857,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                     accum_str.push_char(scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 => {\n-                    fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n+                    fatal_span_char(rdr, escaped_pos, rdr.last_pos.get(),\n                                     ~\"unknown string escape\", c2);\n                   }\n                 }\n@@ -867,29 +869,29 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         return token::LIT_STR(str_to_ident(accum_str));\n       }\n       'r' => {\n-        let start_bpos = rdr.last_pos;\n+        let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n         let mut hash_count = 0u;\n         while rdr.curr == '#' {\n             bump(rdr);\n             hash_count += 1;\n         }\n         if rdr.curr != '\"' {\n-            fatal_span_char(rdr, start_bpos, rdr.last_pos,\n+            fatal_span_char(rdr, start_bpos, rdr.last_pos.get(),\n                             ~\"only `#` is allowed in raw string delimitation; \\\n                               found illegal character\",\n                             rdr.curr);\n         }\n         bump(rdr);\n-        let content_start_bpos = rdr.last_pos;\n+        let content_start_bpos = rdr.last_pos.get();\n         let mut content_end_bpos;\n         'outer: loop {\n             if is_eof(rdr) {\n-                fatal_span(rdr, start_bpos, rdr.last_pos,\n+                fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated raw string\");\n             }\n             if rdr.curr == '\"' {\n-                content_end_bpos = rdr.last_pos;\n+                content_end_bpos = rdr.last_pos.get();\n                 for _ in range(0, hash_count) {\n                     bump(rdr);\n                     if rdr.curr != '#' {\n@@ -933,7 +935,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '^' => { return binop(rdr, token::CARET); }\n       '%' => { return binop(rdr, token::PERCENT); }\n       c => {\n-          fatal_span_char(rdr, rdr.last_pos, rdr.pos.get(),\n+          fatal_span_char(rdr, rdr.last_pos.get(), rdr.pos.get(),\n                           ~\"unknown start of token\", c);\n       }\n     }\n@@ -979,15 +981,15 @@ mod test {\n             sp:Span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n         assert_eq!(tok1,tok2);\n         // the 'main' id is already read:\n-        assert_eq!(string_reader.last_pos.clone(), BytePos(28));\n+        assert_eq!(string_reader.last_pos.get().clone(), BytePos(28));\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n             tok:token::IDENT(str_to_ident(\"main\"), false),\n             sp:Span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n-        assert_eq!(string_reader.last_pos.clone(), BytePos(29))\n+        assert_eq!(string_reader.last_pos.get().clone(), BytePos(29))\n     }\n \n     // check that the given reader produces the desired stream"}]}