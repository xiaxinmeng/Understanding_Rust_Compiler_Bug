{"sha": "d021dbeb4fa837aa0a6ec65aa9391499d78897e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMjFkYmViNGZhODM3YWEwYTZlYzY1YWE5MzkxNDk5ZDc4ODk3ZTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-02T17:40:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-02T17:40:47Z"}, "message": "Merge #6393 #6399\n\n6393: Remove repetitive inlay hints (take 2) r=matklad a=lnicola\n\n\n\n6399: Keep generic annotations when qualifying things r=matklad a=Veykril\n\nThe `qualify_path` assists currently eats up already annotated generics in all but one cases which can be annoying if one already pre-fills generics of a type before it's been qualified.\n\nCo-authored-by: Matthew Sanetra <matthewsanetra@gmail.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e355ad802b0e7bdbf00d8c6d488b1e3cd3979712", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e355ad802b0e7bdbf00d8c6d488b1e3cd3979712"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d021dbeb4fa837aa0a6ec65aa9391499d78897e8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfoESfCRBK7hj4Ov3rIwAAdHIIAESUsfjLSZzYW5j37TpTzPab\nEOiN8442kIjDWVpXvZMf9kQhc/odeQVi2W+spbM0ZXCWFVgGadZTcSdoYJTRCCbP\nw8/HiXlzy9jLb7ijLJ/ujaeYEzS1ONJaUm+aIZ0aKlAwGZEPthn/4QjwwYkuMUst\nlmlYndOj+HZynvt7ZSq7uW9jIPOMjILd6Wbf3RL0yBFeLSGLdJ1bXwa3IZKKW3Ti\nBOu2IPgLPYUTnl1gASZdfyOK+XfLUbHGz93tYMQ7hN2q1GTvxxDsd219dMsM1zpR\nS5s98S5uBHO8itkBobei5ZZso+nFGVSMa5lkPi46GvF5Ei7dHlo53vVtlfCCi70=\n=lydn\n-----END PGP SIGNATURE-----\n", "payload": "tree e355ad802b0e7bdbf00d8c6d488b1e3cd3979712\nparent 2bd26e6afcdd7a75e1256987e5e3b460451dfff4\nparent 05723cb50ddf91a57109c4dae6c99ec15cdc3d30\nparent 042413c35f52286ae57e9add0a8e3fd53a981462\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1604338847 +0000\ncommitter GitHub <noreply@github.com> 1604338847 +0000\n\nMerge #6393 #6399\n\n6393: Remove repetitive inlay hints (take 2) r=matklad a=lnicola\n\n\n\n6399: Keep generic annotations when qualifying things r=matklad a=Veykril\n\nThe `qualify_path` assists currently eats up already annotated generics in all but one cases which can be annoying if one already pre-fills generics of a type before it's been qualified.\n\nCo-authored-by: Matthew Sanetra <matthewsanetra@gmail.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d021dbeb4fa837aa0a6ec65aa9391499d78897e8", "html_url": "https://github.com/rust-lang/rust/commit/d021dbeb4fa837aa0a6ec65aa9391499d78897e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d021dbeb4fa837aa0a6ec65aa9391499d78897e8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd26e6afcdd7a75e1256987e5e3b460451dfff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd26e6afcdd7a75e1256987e5e3b460451dfff4", "html_url": "https://github.com/rust-lang/rust/commit/2bd26e6afcdd7a75e1256987e5e3b460451dfff4"}, {"sha": "05723cb50ddf91a57109c4dae6c99ec15cdc3d30", "url": "https://api.github.com/repos/rust-lang/rust/commits/05723cb50ddf91a57109c4dae6c99ec15cdc3d30", "html_url": "https://github.com/rust-lang/rust/commit/05723cb50ddf91a57109c4dae6c99ec15cdc3d30"}, {"sha": "042413c35f52286ae57e9add0a8e3fd53a981462", "url": "https://api.github.com/repos/rust-lang/rust/commits/042413c35f52286ae57e9add0a8e3fd53a981462", "html_url": "https://github.com/rust-lang/rust/commit/042413c35f52286ae57e9add0a8e3fd53a981462"}], "stats": {"total": 290, "additions": 275, "deletions": 15}, "files": [{"sha": "d5bc4e574f180063989fb48e394cee275e78555c", "filename": "crates/assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 169, "deletions": 13, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/d021dbeb4fa837aa0a6ec65aa9391499d78897e8/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d021dbeb4fa837aa0a6ec65aa9391499d78897e8/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=d021dbeb4fa837aa0a6ec65aa9391499d78897e8", "patch": "@@ -56,12 +56,14 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         ImportCandidate::QualifierStart(_) => {\n             mark::hit!(qualify_path_qualifier_start);\n             let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n-            let segment = path.segment()?;\n-            QualifyCandidate::QualifierStart(segment)\n+            let (prev_segment, segment) = (path.qualifier()?.segment()?, path.segment()?);\n+            QualifyCandidate::QualifierStart(segment, prev_segment.generic_arg_list())\n         }\n         ImportCandidate::UnqualifiedName(_) => {\n             mark::hit!(qualify_path_unqualified_name);\n-            QualifyCandidate::UnqualifiedName\n+            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+            let generics = path.segment()?.generic_arg_list();\n+            QualifyCandidate::UnqualifiedName(generics)\n         }\n         ImportCandidate::TraitAssocItem(_) => {\n             mark::hit!(qualify_path_trait_assoc_item);\n@@ -96,22 +98,25 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n }\n \n enum QualifyCandidate<'db> {\n-    QualifierStart(ast::PathSegment),\n-    UnqualifiedName,\n+    QualifierStart(ast::PathSegment, Option<ast::GenericArgList>),\n+    UnqualifiedName(Option<ast::GenericArgList>),\n     TraitAssocItem(ast::Path, ast::PathSegment),\n     TraitMethod(&'db RootDatabase, ast::MethodCallExpr),\n }\n \n impl QualifyCandidate<'_> {\n     fn qualify(&self, mut replacer: impl FnMut(String), import: hir::ModPath, item: hir::ItemInNs) {\n+        let import = mod_path_to_ast(&import);\n         match self {\n-            QualifyCandidate::QualifierStart(segment) => {\n-                let import = mod_path_to_ast(&import);\n-                replacer(format!(\"{}::{}\", import, segment));\n+            QualifyCandidate::QualifierStart(segment, generics) => {\n+                let generics = generics.as_ref().map_or_else(String::new, ToString::to_string);\n+                replacer(format!(\"{}{}::{}\", import, generics, segment));\n+            }\n+            QualifyCandidate::UnqualifiedName(generics) => {\n+                let generics = generics.as_ref().map_or_else(String::new, ToString::to_string);\n+                replacer(format!(\"{}{}\", import.to_string(), generics));\n             }\n-            QualifyCandidate::UnqualifiedName => replacer(mod_path_to_ast(&import).to_string()),\n             QualifyCandidate::TraitAssocItem(qualifier, segment) => {\n-                let import = mod_path_to_ast(&import);\n                 replacer(format!(\"<{} as {}>::{}\", qualifier, import, segment));\n             }\n             &QualifyCandidate::TraitMethod(db, ref mcall_expr) => {\n@@ -124,25 +129,27 @@ impl QualifyCandidate<'_> {\n         db: &RootDatabase,\n         mcall_expr: &ast::MethodCallExpr,\n         mut replacer: impl FnMut(String),\n-        import: hir::ModPath,\n+        import: ast::Path,\n         item: hir::ItemInNs,\n     ) -> Option<()> {\n         let receiver = mcall_expr.receiver()?;\n         let trait_method_name = mcall_expr.name_ref()?;\n+        let generics =\n+            mcall_expr.generic_arg_list().as_ref().map_or_else(String::new, ToString::to_string);\n         let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n         let trait_ = item_as_trait(item)?;\n         let method = find_trait_method(db, trait_, &trait_method_name)?;\n         if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n-            let import = mod_path_to_ast(&import);\n             let receiver = match self_access {\n                 hir::Access::Shared => make::expr_ref(receiver, false),\n                 hir::Access::Exclusive => make::expr_ref(receiver, true),\n                 hir::Access::Owned => receiver,\n             };\n             replacer(format!(\n-                \"{}::{}{}\",\n+                \"{}::{}{}{}\",\n                 import,\n                 trait_method_name,\n+                generics,\n                 match arg_list.clone() {\n                     Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n                     None => make::arg_list(iter::once(receiver)),\n@@ -1045,4 +1052,153 @@ fn main() {\n \",\n         );\n     }\n+\n+    #[test]\n+    fn keep_generic_annotations() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+pub mod generic { pub struct Thing<'a, T>(&'a T); }\n+\n+//- /main.rs crate:main deps:dep\n+fn foo() -> Thin<|>g<'static, ()> {}\n+\n+fn main() {}\n+\",\n+            r\"\n+fn foo() -> dep::generic::Thing<'static, ()> {}\n+\n+fn main() {}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn keep_generic_annotations_leading_colon() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+pub mod generic { pub struct Thing<'a, T>(&'a T); }\n+\n+//- /main.rs crate:main deps:dep\n+fn foo() -> Thin<|>g::<'static, ()> {}\n+\n+fn main() {}\n+\",\n+            r\"\n+fn foo() -> dep::generic::Thing::<'static, ()> {}\n+\n+fn main() {}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_struct_const_generic() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct<T> {}\n+                impl<T> TestStruct<T> {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::<()>::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct<T> {}\n+                impl<T> TestStruct<T> {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::<()>::TEST_CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_trait_const_generic() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct<T> {}\n+                impl<T> TestTrait for TestStruct<T> {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::<()>::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct<T> {}\n+                impl<T> TestTrait for TestStruct<T> {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                <test_mod::TestStruct::<()> as test_mod::TestTrait>::TEST_CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_generic() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method<T>(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method<T>(&self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od::<()>()\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method<T>(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method<T>(&self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_mod::TestTrait::test_method::<()>(&test_struct)\n+            }\n+            \",\n+        );\n+    }\n }"}, {"sha": "ac704ae2178de8dd0f1c9f948a159810356f9a46", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 106, "deletions": 2, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d021dbeb4fa837aa0a6ec65aa9391499d78897e8/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d021dbeb4fa837aa0a6ec65aa9391499d78897e8/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=d021dbeb4fa837aa0a6ec65aa9391499d78897e8", "patch": "@@ -1,6 +1,6 @@\n use assists::utils::FamousDefs;\n use either::Either;\n-use hir::{known, HirDisplay, Semantics};\n+use hir::{known, Callable, HirDisplay, Semantics};\n use ide_db::RootDatabase;\n use stdx::to_lower_snake_case;\n use syntax::{\n@@ -170,7 +170,7 @@ fn get_param_name_hints(\n             };\n             Some((param_name, arg))\n         })\n-        .filter(|(param_name, arg)| should_show_param_name_hint(sema, &callable, &param_name, &arg))\n+        .filter(|(param_name, arg)| should_show_param_name_hint(sema, &callable, param_name, &arg))\n         .map(|(param_name, arg)| InlayHint {\n             range: arg.syntax().text_range(),\n             kind: InlayKind::ParameterHint,\n@@ -334,9 +334,11 @@ fn should_show_param_name_hint(\n         | hir::CallableKind::TupleEnumVariant(_)\n         | hir::CallableKind::Closure => None,\n     };\n+\n     if param_name.is_empty()\n         || Some(param_name) == fn_name.as_ref().map(|s| s.trim_start_matches('_'))\n         || is_argument_similar_to_param_name(sema, argument, param_name)\n+        || is_param_name_similar_to_fn_name(param_name, callable, fn_name.as_ref())\n         || param_name.starts_with(\"ra_fixture\")\n     {\n         return false;\n@@ -364,6 +366,26 @@ fn is_argument_similar_to_param_name(\n     }\n }\n \n+fn is_param_name_similar_to_fn_name(\n+    param_name: &str,\n+    callable: &Callable,\n+    fn_name: Option<&String>,\n+) -> bool {\n+    // if it's the only parameter, don't show it if:\n+    // - is the same as the function name, or\n+    // - the function ends with '_' + param_name\n+\n+    match (callable.n_params(), fn_name) {\n+        (1, Some(function)) => {\n+            function == param_name\n+                || (function.len() > param_name.len()\n+                    && function.ends_with(param_name)\n+                    && function[..function.len() - param_name.len()].ends_with('_'))\n+        }\n+        _ => false,\n+    }\n+}\n+\n fn is_enum_name_similar_to_param_name(\n     sema: &Semantics<RootDatabase>,\n     argument: &ast::Expr,\n@@ -456,6 +478,88 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn param_name_similar_to_fn_name_still_hints() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: true,\n+                type_hints: false,\n+                chaining_hints: false,\n+                max_length: None,\n+            },\n+            r#\"\n+fn max(x: i32, y: i32) -> i32 { x + y }\n+fn main() {\n+    let _x = max(\n+        4,\n+      //^ x\n+        4,\n+      //^ y\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_name_similar_to_fn_name() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: true,\n+                type_hints: false,\n+                chaining_hints: false,\n+                max_length: None,\n+            },\n+            r#\"\n+fn param_with_underscore(with_underscore: i32) -> i32 { with_underscore }\n+fn main() {\n+    let _x = param_with_underscore(\n+        4,\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_name_same_as_fn_name() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: true,\n+                type_hints: false,\n+                chaining_hints: false,\n+                max_length: None,\n+            },\n+            r#\"\n+fn foo(foo: i32) -> i32 { foo }\n+fn main() {\n+    let _x = foo(\n+        4,\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn never_hide_param_when_multiple_params() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: true,\n+                type_hints: false,\n+                chaining_hints: false,\n+                max_length: None,\n+            },\n+            r#\"\n+fn foo(bar: i32, baz: i32) -> i32 { bar + baz }\n+fn main() {\n+    let _x = foo(\n+        4,\n+      //^ bar\n+        8,\n+      //^ baz\n+    );\n+}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn hints_disabled() {\n         check_with_config("}]}