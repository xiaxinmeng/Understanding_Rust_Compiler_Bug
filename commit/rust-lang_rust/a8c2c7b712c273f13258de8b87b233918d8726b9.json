{"sha": "a8c2c7b712c273f13258de8b87b233918d8726b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YzJjN2I3MTJjMjczZjEzMjU4ZGU4Yjg3YjIzMzkxOGQ4NzI2Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-02T15:30:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-02T15:30:12Z"}, "message": "Auto merge of #7604 - flip1995:rustup, r=Manishearth\n\nRustup\n\nI'll write some TODOs later. This time I'll need a review for this Rustup\n\nr? `@ghost`  (for now)\n\nchangelog: none", "tree": {"sha": "ba63d39385762a2d8595410eade4174206623e55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba63d39385762a2d8595410eade4174206623e55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8c2c7b712c273f13258de8b87b233918d8726b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c2c7b712c273f13258de8b87b233918d8726b9", "html_url": "https://github.com/rust-lang/rust/commit/a8c2c7b712c273f13258de8b87b233918d8726b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8c2c7b712c273f13258de8b87b233918d8726b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "849f0a144b019f0484c557d19684233ea8eed186", "url": "https://api.github.com/repos/rust-lang/rust/commits/849f0a144b019f0484c557d19684233ea8eed186", "html_url": "https://github.com/rust-lang/rust/commit/849f0a144b019f0484c557d19684233ea8eed186"}, {"sha": "01b17af1083ffc0630255c7ac172d32812c610fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b17af1083ffc0630255c7ac172d32812c610fa", "html_url": "https://github.com/rust-lang/rust/commit/01b17af1083ffc0630255c7ac172d32812c610fa"}], "stats": {"total": 4076, "additions": 1520, "deletions": 2556}, "files": [{"sha": "d86414a87f4d159fbc70fa6514ba5f0fa8aa2558", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -964,7 +964,7 @@ Released 2020-11-19\n   [#5907](https://github.com/rust-lang/rust-clippy/pull/5907)\n * [`suspicious_arithmetic_impl`]: extend to implementations of `BitAnd`, `BitOr`, `BitXor`, `Rem`, `Shl`, and `Shr`\n   [#5884](https://github.com/rust-lang/rust-clippy/pull/5884)\n-* [`invalid_atomic_ordering`]: detect misuse of `compare_exchange`, `compare_exchange_weak`, and `fetch_update`\n+* `invalid_atomic_ordering`: detect misuse of `compare_exchange`, `compare_exchange_weak`, and `fetch_update`\n   [#6025](https://github.com/rust-lang/rust-clippy/pull/6025)\n * Avoid [`redundant_pattern_matching`] triggering in macros\n   [#6069](https://github.com/rust-lang/rust-clippy/pull/6069)\n@@ -1451,7 +1451,7 @@ Released 2020-03-12\n * [`option_as_ref_deref`] [#4945](https://github.com/rust-lang/rust-clippy/pull/4945)\n * [`wildcard_in_or_patterns`] [#4960](https://github.com/rust-lang/rust-clippy/pull/4960)\n * [`iter_nth_zero`] [#4966](https://github.com/rust-lang/rust-clippy/pull/4966)\n-* [`invalid_atomic_ordering`] [#4999](https://github.com/rust-lang/rust-clippy/pull/4999)\n+* `invalid_atomic_ordering` [#4999](https://github.com/rust-lang/rust-clippy/pull/4999)\n * [`skip_while_next`] [#5067](https://github.com/rust-lang/rust-clippy/pull/5067)\n \n ### Moves and Deprecations\n@@ -2712,7 +2712,6 @@ Released 2018-09-13\n [`integer_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_arithmetic\n [`integer_division`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_division\n [`into_iter_on_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_ref\n-[`invalid_atomic_ordering`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_atomic_ordering\n [`invalid_null_ptr_usage`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_null_ptr_usage\n [`invalid_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_regex\n [`invalid_upcast_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons"}, {"sha": "d834a1d317a0f1d7e9d3344fb764cc3a2ab866d4", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call};\n use if_chain::if_chain;\n@@ -116,7 +117,7 @@ enum AssertKind {\n /// where `message` is any expression and `c` is a constant bool.\n fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n-        if let ExprKind::If(cond, then, _) = expr.kind;\n+        if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n         if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);"}, {"sha": "cece28e8b3c3f110afa7a5d1c7224d9b26441efd", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,230 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::match_def_path;\n-use if_chain::if_chain;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usage of invalid atomic\n-    /// ordering in atomic loads/stores/exchanges/updates and\n-    /// memory fences.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using an invalid atomic ordering\n-    /// will cause a panic at run-time.\n-    ///\n-    /// ### Example\n-    /// ```rust,no_run\n-    /// # use std::sync::atomic::{self, AtomicU8, Ordering};\n-    ///\n-    /// let x = AtomicU8::new(0);\n-    ///\n-    /// // Bad: `Release` and `AcqRel` cannot be used for `load`.\n-    /// let _ = x.load(Ordering::Release);\n-    /// let _ = x.load(Ordering::AcqRel);\n-    ///\n-    /// // Bad: `Acquire` and `AcqRel` cannot be used for `store`.\n-    /// x.store(1, Ordering::Acquire);\n-    /// x.store(2, Ordering::AcqRel);\n-    ///\n-    /// // Bad: `Relaxed` cannot be used as a fence's ordering.\n-    /// atomic::fence(Ordering::Relaxed);\n-    /// atomic::compiler_fence(Ordering::Relaxed);\n-    ///\n-    /// // Bad: `Release` and `AcqRel` are both always invalid\n-    /// // for the failure ordering (the last arg).\n-    /// let _ = x.compare_exchange(1, 2, Ordering::SeqCst, Ordering::Release);\n-    /// let _ = x.compare_exchange_weak(2, 3, Ordering::AcqRel, Ordering::AcqRel);\n-    ///\n-    /// // Bad: The failure ordering is not allowed to be\n-    /// // stronger than the success order, and `SeqCst` is\n-    /// // stronger than `Relaxed`.\n-    /// let _ = x.fetch_update(Ordering::Relaxed, Ordering::SeqCst, |val| Some(val + val));\n-    /// ```\n-    pub INVALID_ATOMIC_ORDERING,\n-    correctness,\n-    \"usage of invalid atomic ordering in atomic operations and memory fences\"\n-}\n-\n-declare_lint_pass!(AtomicOrdering => [INVALID_ATOMIC_ORDERING]);\n-\n-const ATOMIC_TYPES: [&str; 12] = [\n-    \"AtomicBool\",\n-    \"AtomicI8\",\n-    \"AtomicI16\",\n-    \"AtomicI32\",\n-    \"AtomicI64\",\n-    \"AtomicIsize\",\n-    \"AtomicPtr\",\n-    \"AtomicU8\",\n-    \"AtomicU16\",\n-    \"AtomicU32\",\n-    \"AtomicU64\",\n-    \"AtomicUsize\",\n-];\n-\n-fn type_is_atomic(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.typeck_results().expr_ty(expr).kind() {\n-        ATOMIC_TYPES\n-            .iter()\n-            .any(|ty| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", ty]))\n-    } else {\n-        false\n-    }\n-}\n-\n-fn match_ordering_def_path(cx: &LateContext<'_>, did: DefId, orderings: &[&str]) -> bool {\n-    orderings\n-        .iter()\n-        .any(|ordering| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", \"Ordering\", ordering]))\n-}\n-\n-fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_path, _, args, _) = &expr.kind;\n-        let method = method_path.ident.name.as_str();\n-        if type_is_atomic(cx, &args[0]);\n-        if method == \"load\" || method == \"store\";\n-        let ordering_arg = if method == \"load\" { &args[1] } else { &args[2] };\n-        if let ExprKind::Path(ref ordering_qpath) = ordering_arg.kind;\n-        if let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n-        then {\n-            if method == \"load\" &&\n-                match_ordering_def_path(cx, ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n-                span_lint_and_help(\n-                    cx,\n-                    INVALID_ATOMIC_ORDERING,\n-                    ordering_arg.span,\n-                    \"atomic loads cannot have `Release` and `AcqRel` ordering\",\n-                    None,\n-                    \"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\"\n-                );\n-            } else if method == \"store\" &&\n-                match_ordering_def_path(cx, ordering_def_id, &[\"Acquire\", \"AcqRel\"]) {\n-                span_lint_and_help(\n-                    cx,\n-                    INVALID_ATOMIC_ORDERING,\n-                    ordering_arg.span,\n-                    \"atomic stores cannot have `Acquire` and `AcqRel` ordering\",\n-                    None,\n-                    \"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\"\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn check_memory_fence(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-    if_chain! {\n-        if let ExprKind::Call(func, args) = expr.kind;\n-        if let ExprKind::Path(ref func_qpath) = func.kind;\n-        if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n-        if [\"fence\", \"compiler_fence\"]\n-            .iter()\n-            .any(|func| match_def_path(cx, def_id, &[\"core\", \"sync\", \"atomic\", func]));\n-        if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n-        if let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n-        if match_ordering_def_path(cx, ordering_def_id, &[\"Relaxed\"]);\n-        then {\n-            span_lint_and_help(\n-                cx,\n-                INVALID_ATOMIC_ORDERING,\n-                args[0].span,\n-                \"memory fences cannot have `Relaxed` ordering\",\n-                None,\n-                \"consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\"\n-            );\n-        }\n-    }\n-}\n-\n-fn opt_ordering_defid(cx: &LateContext<'_>, ord_arg: &Expr<'_>) -> Option<DefId> {\n-    if let ExprKind::Path(ref ord_qpath) = ord_arg.kind {\n-        cx.qpath_res(ord_qpath, ord_arg.hir_id).opt_def_id()\n-    } else {\n-        None\n-    }\n-}\n-\n-fn check_atomic_compare_exchange(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_path, _, args, _) = &expr.kind;\n-        let method = method_path.ident.name.as_str();\n-        if type_is_atomic(cx, &args[0]);\n-        if method == \"compare_exchange\" || method == \"compare_exchange_weak\" || method == \"fetch_update\";\n-        let (success_order_arg, failure_order_arg) = if method == \"fetch_update\" {\n-            (&args[1], &args[2])\n-        } else {\n-            (&args[3], &args[4])\n-        };\n-        if let Some(fail_ordering_def_id) = opt_ordering_defid(cx, failure_order_arg);\n-        then {\n-            // Helper type holding on to some checking and error reporting data. Has\n-            // - (success ordering name,\n-            // - list of failure orderings forbidden by the success order,\n-            // - suggestion message)\n-            type OrdLintInfo = (&'static str, &'static [&'static str], &'static str);\n-            let relaxed: OrdLintInfo = (\"Relaxed\", &[\"SeqCst\", \"Acquire\"], \"ordering mode `Relaxed`\");\n-            let acquire: OrdLintInfo = (\"Acquire\", &[\"SeqCst\"], \"ordering modes `Acquire` or `Relaxed`\");\n-            let seq_cst: OrdLintInfo = (\"SeqCst\", &[], \"ordering modes `Acquire`, `SeqCst` or `Relaxed`\");\n-            let release = (\"Release\", relaxed.1, relaxed.2);\n-            let acqrel = (\"AcqRel\", acquire.1, acquire.2);\n-            let search = [relaxed, acquire, seq_cst, release, acqrel];\n-\n-            let success_lint_info = opt_ordering_defid(cx, success_order_arg)\n-                .and_then(|success_ord_def_id| -> Option<OrdLintInfo> {\n-                    search\n-                        .iter()\n-                        .find(|(ordering, ..)| {\n-                            match_def_path(cx, success_ord_def_id,\n-                                &[\"core\", \"sync\", \"atomic\", \"Ordering\", ordering])\n-                        })\n-                        .copied()\n-                });\n-\n-            if match_ordering_def_path(cx, fail_ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n-                // If we don't know the success order is, use what we'd suggest\n-                // if it were maximally permissive.\n-                let suggested = success_lint_info.unwrap_or(seq_cst).2;\n-                span_lint_and_help(\n-                    cx,\n-                    INVALID_ATOMIC_ORDERING,\n-                    failure_order_arg.span,\n-                    &format!(\n-                        \"{}'s failure ordering may not be `Release` or `AcqRel`\",\n-                        method,\n-                    ),\n-                    None,\n-                    &format!(\"consider using {} instead\", suggested),\n-                );\n-            } else if let Some((success_ord_name, bad_ords_given_success, suggested)) = success_lint_info {\n-                if match_ordering_def_path(cx, fail_ordering_def_id, bad_ords_given_success) {\n-                    span_lint_and_help(\n-                        cx,\n-                        INVALID_ATOMIC_ORDERING,\n-                        failure_order_arg.span,\n-                        &format!(\n-                            \"{}'s failure ordering may not be stronger than the success ordering of `{}`\",\n-                            method,\n-                            success_ord_name,\n-                        ),\n-                        None,\n-                        &format!(\"consider using {} instead\", suggested),\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for AtomicOrdering {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        check_atomic_load_store(cx, expr);\n-        check_memory_fence(cx, expr);\n-        check_atomic_compare_exchange(cx, expr);\n-    }\n-}"}, {"sha": "51d95cc6f0b10b485c2f94e3fd10b200e9bb8442", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n use clippy_utils::{differing_macro_contexts, get_parent_expr};\n@@ -92,7 +93,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        if let ExprKind::If(cond, _, _) = &expr.kind {\n+        if let Some(higher::If { cond, .. }) = higher::If::hir(expr) {\n             if let ExprKind::Block(block, _) = &cond.kind {\n                 if block.rules == BlockCheckMode::DefaultBlock {\n                     if block.stmts.is_empty() {"}, {"sha": "6f12d34e66b6eedaefad7da103120a03907e5804", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         // prevent folding of `cfg!` macros and the like\n         if !e.span.from_expansion() {\n             match &e.kind {\n-                ExprKind::Unary(UnOp::Not, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprKind::Unary(UnOp::Not, inner) => return Ok(Bool::Not(Box::new(self.run(inner)?))),\n                 ExprKind::Binary(binop, lhs, rhs) => match &binop.node {\n                     BinOpKind::Or => {\n                         return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?));"}, {"sha": "a4693fa213bc4a110470615ba12b9912754fe297", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 66, "deletions": 36, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n@@ -49,56 +50,86 @@ declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n \n impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n-            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n-                for arm in arms {\n-                    check_arm(arm, wild_arm, cx);\n+        match IfLetOrMatch::parse(cx, expr) {\n+            Some(IfLetOrMatch::Match(_, arms, _)) => {\n+                if let Some(els_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n+                    for arm in arms {\n+                        check_arm(cx, true, arm.pat, arm.body, arm.guard.as_ref(), Some(els_arm.body));\n+                    }\n                 }\n-            }\n+            },\n+            Some(IfLetOrMatch::IfLet(_, pat, body, els)) => {\n+                check_arm(cx, false, pat, body, None, els);\n+            },\n+            None => {},\n         }\n     }\n }\n \n-fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext<'tcx>) {\n-    let expr = strip_singleton_blocks(arm.body);\n+fn check_arm<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    outer_is_match: bool,\n+    outer_pat: &'tcx Pat<'tcx>,\n+    outer_then_body: &'tcx Expr<'tcx>,\n+    outer_guard: Option<&'tcx Guard<'tcx>>,\n+    outer_else_body: Option<&'tcx Expr<'tcx>>,\n+) {\n+    let inner_expr = strip_singleton_blocks(outer_then_body);\n     if_chain! {\n-        if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n-        // the outer arm pattern and the inner match\n-        if expr_in.span.ctxt() == arm.pat.span.ctxt();\n-        // there must be no more than two arms in the inner match for this lint\n-        if arms_inner.len() == 2;\n-        // no if guards on the inner match\n-        if arms_inner.iter().all(|arm| arm.guard.is_none());\n+        if let Some(inner) = IfLetOrMatch::parse(cx, inner_expr);\n+        if let Some((inner_scrutinee, inner_then_pat, inner_else_body)) = match inner {\n+            IfLetOrMatch::IfLet(scrutinee, pat, _, els) => Some((scrutinee, pat, els)),\n+            IfLetOrMatch::Match(scrutinee, arms, ..) => if_chain! {\n+                // if there are more than two arms, collapsing would be non-trivial\n+                if arms.len() == 2 && arms.iter().all(|a| a.guard.is_none());\n+                // one of the arms must be \"wild-like\"\n+                if let Some(wild_idx) = arms.iter().rposition(|a| arm_is_wild_like(cx, a));\n+                then {\n+                    let (then, els) = (&arms[1 - wild_idx], &arms[wild_idx]);\n+                    Some((scrutinee, then.pat, Some(els.body)))\n+                } else {\n+                    None\n+                }\n+            },\n+        };\n+        if outer_pat.span.ctxt() == inner_scrutinee.span.ctxt();\n         // match expression must be a local binding\n         // match <local> { .. }\n-        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, expr_in));\n-        // one of the branches must be \"wild-like\"\n-        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(cx, arm_inner));\n-        let (wild_inner_arm, non_wild_inner_arm) =\n-            (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n-        if !pat_contains_or(non_wild_inner_arm.pat);\n+        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, inner_scrutinee));\n+        if !pat_contains_or(inner_then_pat);\n         // the binding must come from the pattern of the containing match arm\n         // ..<local>.. => match <local> { .. }\n-        if let Some(binding_span) = find_pat_binding(arm.pat, binding_id);\n-        // the \"wild-like\" branches must be equal\n-        if SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, wild_outer_arm.body);\n+        if let Some(binding_span) = find_pat_binding(outer_pat, binding_id);\n+        // the \"else\" branches must be equal\n+        if match (outer_else_body, inner_else_body) {\n+            (None, None) => true,\n+            (None, Some(e)) | (Some(e), None) => is_unit_expr(e),\n+            (Some(a), Some(b)) => SpanlessEq::new(cx).eq_expr(a, b),\n+        };\n         // the binding must not be used in the if guard\n-        if match arm.guard {\n-            None => true,\n-            Some(Guard::If(expr) | Guard::IfLet(_, expr)) => !is_local_used(cx, expr, binding_id),\n+        if outer_guard.map_or(true, |(Guard::If(e) | Guard::IfLet(_, e))| !is_local_used(cx, *e, binding_id));\n+        // ...or anywhere in the inner expression\n+        if match inner {\n+            IfLetOrMatch::IfLet(_, _, body, els) => {\n+                !is_local_used(cx, body, binding_id) && els.map_or(true, |e| !is_local_used(cx, e, binding_id))\n+            },\n+            IfLetOrMatch::Match(_, arms, ..) => !arms.iter().any(|arm| is_local_used(cx, arm, binding_id)),\n         };\n-        // ...or anywhere in the inner match\n-        if !arms_inner.iter().any(|arm| is_local_used(cx, arm, binding_id));\n         then {\n+            let msg = format!(\n+                \"this `{}` can be collapsed into the outer `{}`\",\n+                if matches!(inner, IfLetOrMatch::Match(..)) { \"match\" } else { \"if let\" },\n+                if outer_is_match { \"match\" } else { \"if let\" },\n+            );\n             span_lint_and_then(\n                 cx,\n                 COLLAPSIBLE_MATCH,\n-                expr.span,\n-                \"unnecessary nested match\",\n+                inner_expr.span,\n+                &msg,\n                 |diag| {\n-                    let mut help_span = MultiSpan::from_spans(vec![binding_span, non_wild_inner_arm.pat.span]);\n+                    let mut help_span = MultiSpan::from_spans(vec![binding_span, inner_then_pat.span]);\n                     help_span.push_span_label(binding_span, \"replace this binding\".into());\n-                    help_span.push_span_label(non_wild_inner_arm.pat.span, \"with this pattern\".into());\n+                    help_span.push_span_label(inner_then_pat.span, \"with this pattern\".into());\n                     diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n                 },\n             );\n@@ -120,9 +151,8 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n     expr\n }\n \n-/// A \"wild-like\" pattern is wild (\"_\") or `None`.\n-/// For this lint to apply, both the outer and inner match expressions\n-/// must have \"wild-like\" branches that can be combined.\n+/// A \"wild-like\" arm has a wild (`_`) or `None` pattern and no guard. Such arms can be \"collapsed\"\n+/// into a single wild arm without any significant loss in semantics or readability.\n fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     if arm.guard.is_some() {\n         return false;"}, {"sha": "d58e49491203c1da290327d0af845d72d2018024", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -316,9 +316,10 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n     let mut start_eq = usize::MAX;\n     let mut end_eq = usize::MAX;\n     let mut expr_eq = true;\n-    for win in blocks.windows(2) {\n-        let l_stmts = win[0].stmts;\n-        let r_stmts = win[1].stmts;\n+    let mut iter = blocks.windows(2);\n+    while let Some(&[win0, win1]) = iter.next() {\n+        let l_stmts = win0.stmts;\n+        let r_stmts = win1.stmts;\n \n         // `SpanlessEq` now keeps track of the locals and is therefore context sensitive clippy#6752.\n         // The comparison therefore needs to be done in a way that builds the correct context.\n@@ -335,22 +336,22 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n             it1.zip(it2)\n                 .fold(0, |acc, (l, r)| if evaluator.eq_stmt(l, r) { acc + 1 } else { 0 })\n         };\n-        let block_expr_eq = both(&win[0].expr, &win[1].expr, |l, r| evaluator.eq_expr(l, r));\n+        let block_expr_eq = both(&win0.expr, &win1.expr, |l, r| evaluator.eq_expr(l, r));\n \n         // IF_SAME_THEN_ELSE\n         if_chain! {\n             if block_expr_eq;\n             if l_stmts.len() == r_stmts.len();\n             if l_stmts.len() == current_start_eq;\n-            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win[0].hir_id);\n-            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win[1].hir_id);\n+            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win0.hir_id);\n+            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win1.hir_id);\n             then {\n                 span_lint_and_note(\n                     cx,\n                     IF_SAME_THEN_ELSE,\n-                    win[0].span,\n+                    win0.span,\n                     \"this `if` has identical blocks\",\n-                    Some(win[1].span),\n+                    Some(win1.span),\n                     \"same as this\",\n                 );\n "}, {"sha": "7825e5f6ed52e45f9f715c0cb2b93fd55a4fc9ca", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -232,6 +232,7 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n         | ExprKind::If(..)\n         | ExprKind::Loop(..)\n         | ExprKind::Match(..)\n+        | ExprKind::Let(..)\n         | ExprKind::Closure(..)\n         | ExprKind::Block(..)\n         | ExprKind::Assign(..)"}, {"sha": "cb2b7f5be70addb065d7efb2196ec96290275fd2", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -578,8 +578,8 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 let filename = FileName::anon_source_code(&code);\n \n                 let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-                let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n-                let handler = Handler::with_emitter(false, None, box emitter);\n+                let emitter = EmitterWriter::new(Box::new(io::sink()), None, false, false, false, None, false);\n+                let handler = Handler::with_emitter(false, None, Box::new(emitter));\n                 let sess = ParseSess::with_span_handler(handler, sm);\n \n                 let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code) {"}, {"sha": "ac6824672f66cbf90c13b7f7d9e6dfab2d009d4d", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,10 +1,12 @@\n+use clippy_utils::higher;\n use clippy_utils::{\n     can_move_expr_to_closure_no_visit,\n     diagnostics::span_lint_and_sugg,\n     is_expr_final_block_expr, is_expr_used_or_unified, match_def_path, paths, peel_hir_expr_while,\n     source::{reindent_multiline, snippet_indent, snippet_with_applicability, snippet_with_context},\n     SpanlessEq,\n };\n+use core::fmt::Write;\n use rustc_errors::Applicability;\n use rustc_hir::{\n     hir_id::HirIdSet,\n@@ -14,7 +16,6 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n-use std::fmt::Write;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -63,10 +64,11 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (cond_expr, then_expr, else_expr) = match expr.kind {\n-            ExprKind::If(c, t, e) => (c, t, e),\n+        let (cond_expr, then_expr, else_expr) = match higher::If::hir(expr) {\n+            Some(higher::If { cond, then, r#else }) => (cond, then, r#else),\n             _ => return,\n         };\n+\n         let (map_ty, contains_expr) = match try_parse_contains(cx, cond_expr) {\n             Some(x) => x,\n             None => return,"}, {"sha": "ae66edc2a9e12c789a92898235d94afe5602d094", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -53,7 +53,7 @@ fn is_non_trait_box(ty: Ty<'_>) -> bool {\n struct EscapeDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     set: HirIdSet,\n-    trait_self_ty: Option<Ty<'a>>,\n+    trait_self_ty: Option<Ty<'tcx>>,\n     too_large_for_stack: u64,\n }\n \n@@ -171,7 +171,8 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                 // skip if there is a `self` parameter binding to a type\n                 // that contains `Self` (i.e.: `self: Box<Self>`), see #4804\n                 if let Some(trait_self_ty) = self.trait_self_ty {\n-                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(cmt.place.ty(), trait_self_ty) {\n+                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(self.cx.tcx, cmt.place.ty(), trait_self_ty)\n+                    {\n                         return;\n                     }\n                 }"}, {"sha": "f6a64a8ca6031f7a352595ed48d0f283ba8ea8da", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -100,7 +100,7 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n \n         if ex.span.ctxt() != expr.span.ctxt() {\n             if decl.inputs.is_empty() {\n-                if let Some(VecArgs::Vec(&[])) = higher::vec_macro(cx, ex) {\n+                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, ex) {\n                     // replace `|| vec![]` with `Vec::new`\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "a643b3eb8f1b8fa32495259cdf90edf613cd4647", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -3,6 +3,7 @@ use clippy_utils::consts::{\n     Constant::{Int, F32, F64},\n };\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::{eq_expr_value, get_parent_expr, numeric_literal, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -331,8 +332,6 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                         ),\n                         Applicability::MachineApplicable,\n                     );\n-\n-                    return;\n                 }\n             }\n         }\n@@ -545,11 +544,11 @@ fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a\n \n fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::If(cond, body, else_body) = expr.kind;\n-        if let ExprKind::Block(block, _) = body.kind;\n+        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n+        if let ExprKind::Block(block, _) = then.kind;\n         if block.stmts.is_empty();\n         if let Some(if_body_expr) = block.expr;\n-        if let Some(ExprKind::Block(else_block, _)) = else_body.map(|el| &el.kind);\n+        if let Some(ExprKind::Block(else_block, _)) = r#else.map(|el| &el.kind);\n         if else_block.stmts.is_empty();\n         if let Some(else_body_expr) = else_block.expr;\n         if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);"}, {"sha": "4dd0ffe77ea49fbff542b3c20a48ad053aa94650", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -164,7 +164,7 @@ fn check_unop(cx: &EarlyContext<'_>, expr: &Expr) {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion();\n         // span between BinOp LHS and RHS\n         let binop_span = lhs.span.between(rhs.span);\n-        // if RHS is a UnOp\n+        // if RHS is an UnOp\n         if let ExprKind::Unary(op, ref un_rhs) = rhs.kind;\n         // from UnOp operator to UnOp operand\n         let unop_operand_span = rhs.span.until(un_rhs.span);"}, {"sha": "77d08081c07f1d2bf07911b33de74f4a9f0148ef", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -26,7 +26,6 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            return;\n         } else if is_public && !is_proc_macro(cx.sess(), attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n             check_must_use_candidate(\n                 cx,"}, {"sha": "3e35ada7b2a1c909aaeb416f8e11d8be6bc85c31", "filename": "clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -93,7 +93,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n                                     infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred, _) = obligation.predicate.kind().skip_binder() {\n+                                    if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n                                         db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\",\n                                             trait_pred.self_ty(),"}, {"sha": "7dad1c31150e2cc49b6dfba66391a7f0dbce6062", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::SpanlessEq;\n use if_chain::if_chain;\n use rustc_hir::intravisit::{self as visit, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -42,7 +43,7 @@ declare_clippy_lint! {\n declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n \n impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         let mut arm_visit = ArmVisitor {\n             mutex_lock_called: false,\n             found_mutex: None,\n@@ -53,25 +54,23 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n             found_mutex: None,\n             cx,\n         };\n-        if let ExprKind::Match(\n-            op,\n-            arms,\n-            MatchSource::IfLetDesugar {\n-                contains_else_clause: true,\n-            },\n-        ) = ex.kind\n+        if let Some(higher::IfLet {\n+            let_expr,\n+            if_then,\n+            if_else: Some(if_else),\n+            ..\n+        }) = higher::IfLet::hir(cx, expr)\n         {\n-            op_visit.visit_expr(op);\n+            op_visit.visit_expr(let_expr);\n             if op_visit.mutex_lock_called {\n-                for arm in arms {\n-                    arm_visit.visit_arm(arm);\n-                }\n+                arm_visit.visit_expr(if_then);\n+                arm_visit.visit_expr(if_else);\n \n                 if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n                     span_lint_and_help(\n                         cx,\n                         IF_LET_MUTEX,\n-                        ex.span,\n+                        expr.span,\n                         \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n                         None,\n                         \"move the lock call outside of the `if let ...` expression\","}, {"sha": "33eba02dae063c54603a40d192bbb36281271bdc", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::method_chain_args;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource, PatKind, QPath};\n+use rustc_hir::{Expr, ExprKind, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -44,17 +45,17 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n-            if let ExprKind::Match(op, body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n-            if let ExprKind::MethodCall(_, ok_span, result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n-            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = body[0].pat.kind; //get operation\n-            if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n+            if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr);\n+            if let ExprKind::MethodCall(_, ok_span, result_types, _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n+            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym::result_type);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n-                let trimmed_ok = snippet_with_applicability(cx, op.span.until(ok_span), \"\", &mut applicability);\n+                let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_span), \"\", &mut applicability);\n                 let sugg = format!(\n                     \"if let Ok({}) = {}\",\n                     some_expr_string,\n@@ -63,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n                 span_lint_and_sugg(\n                     cx,\n                     IF_LET_SOME_RESULT,\n-                    expr.span.with_hi(op.span.hi()),\n+                    expr.span.with_hi(let_expr.span.hi()),\n                     \"matching on `Some` with `ok()` is redundant\",\n                     &format!(\"consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n                     sugg,"}, {"sha": "a2dac57454f2d3b7430d4127c70dec75b1952e64", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind};\n@@ -70,7 +70,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n         }\n \n         if_chain! {\n-            if let ExprKind::If(cond, then, Some(els)) = expr.kind;\n+            if let Some(higher::If { cond, then, r#else: Some(els) }) = higher::If::hir(expr);\n             if let ExprKind::Block(then_block, _) = then.kind;\n             if let Some(then_expr) = then_block.expr;\n             if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;"}, {"sha": "79d4d7ddcbcedfe8e0ad85116a98a76068dc6c46", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::{in_macro, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -42,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             return;\n         }\n         if_chain! {\n-            if let ExprKind::If(cond, then, None) = &expr.kind;\n+            if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n \n             // Check if the conditional expression is a binary operation\n             if let ExprKind::Binary(ref cond_op, cond_left, cond_right) = cond.kind;"}, {"sha": "f52f090d3872e11ab873ada16b9a0621620d299e", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(array, index) = &expr.kind {\n             let ty = cx.typeck_results().expr_ty(array).peel_refs();\n-            if let Some(range) = higher::range(index) {\n+            if let Some(range) = higher::Range::hir(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind() {\n                     let size: u128 = if let Some(size) = s.try_eval_usize(cx.tcx, cx.param_env) {"}, {"sha": "58646385def52412fad1a43941fd2df562029da7", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -172,7 +172,7 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 Finite\n             }\n         },\n-        ExprKind::Struct(..) => higher::range(expr).map_or(false, |r| r.end.is_none()).into(),\n+        ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }\n }"}, {"sha": "7f2c7b707f0b1290968371fbb65e45b4dd32b86d", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -64,8 +64,8 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::StmtKind::Local(local) = stmt.kind;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(if_) = expr.kind;\n-                if let hir::ExprKind::If(cond, then, ref else_) = if_.kind;\n-                if !is_local_used(cx, cond, canonical_id);\n+                if let hir::ExprKind::If(hir::Expr { kind: hir::ExprKind::DropTemps(cond), ..}, then, else_) = if_.kind;\n+                if !is_local_used(cx, *cond, canonical_id);\n                 if let hir::ExprKind::Block(then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n                 if !is_local_used(cx, value, canonical_id);\n@@ -78,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     );\n                     if has_interior_mutability { return; }\n \n-                    let (default_multi_stmts, default) = if let Some(else_) = *else_ {\n+                    let (default_multi_stmts, default) = if let Some(else_) = else_ {\n                         if let hir::ExprKind::Block(else_, _) = else_.kind {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)"}, {"sha": "89146b4dd2c9bd5f58b61a89a2cab4b61f7b6d76", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n             if let Some(init) = local.init;\n             then {\n                 let init_ty = cx.typeck_results().expr_ty(init);\n-                let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n+                let contains_sync_guard = init_ty.walk(cx.tcx).any(|inner| match inner.unpack() {\n                     GenericArgKind::Type(inner_ty) => {\n                         SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n                     },"}, {"sha": "2b76eacb7d61c473e2cda20e76ad8a728b1e1f5d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 248, "deletions": 253, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,7 +1,6 @@\n // error-pattern:cargo-clippy\n \n #![feature(box_patterns)]\n-#![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n@@ -165,7 +164,6 @@ mod asm_syntax;\n mod assertions_on_constants;\n mod assign_ops;\n mod async_yields_async;\n-mod atomic_ordering;\n mod attrs;\n mod await_holding_invalid;\n mod bit_mask;\n@@ -396,9 +394,9 @@ use crate::utils::conf::TryConf;\n /// Used in `./src/driver.rs`.\n pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore) {\n     // NOTE: Do not add any more pre-expansion passes. These should be removed eventually.\n-    store.register_pre_expansion_pass(|| box write::Write::default());\n-    store.register_pre_expansion_pass(|| box attrs::EarlyAttributes);\n-    store.register_pre_expansion_pass(|| box dbg_macro::DbgMacro);\n+    store.register_pre_expansion_pass(|| Box::new(write::Write::default()));\n+    store.register_pre_expansion_pass(|| Box::new(attrs::EarlyAttributes));\n+    store.register_pre_expansion_pass(|| Box::new(dbg_macro::DbgMacro));\n }\n \n #[doc(hidden)]\n@@ -539,7 +537,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         assign_ops::ASSIGN_OP_PATTERN,\n         assign_ops::MISREFACTORED_ASSIGN_OP,\n         async_yields_async::ASYNC_YIELDS_ASYNC,\n-        atomic_ordering::INVALID_ATOMIC_ORDERING,\n         attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n         attrs::DEPRECATED_CFG_ATTR,\n         attrs::DEPRECATED_SEMVER,\n@@ -1183,7 +1180,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(assign_ops::ASSIGN_OP_PATTERN),\n         LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n         LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n-        LintId::of(atomic_ordering::INVALID_ATOMIC_ORDERING),\n         LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(attrs::DEPRECATED_CFG_ATTR),\n         LintId::of(attrs::DEPRECATED_SEMVER),\n@@ -1681,7 +1677,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(approx_const::APPROX_CONSTANT),\n         LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n-        LintId::of(atomic_ordering::INVALID_ATOMIC_ORDERING),\n         LintId::of(attrs::DEPRECATED_SEMVER),\n         LintId::of(attrs::MISMATCHED_TARGET_OS),\n         LintId::of(attrs::USELESS_ATTRIBUTE),\n@@ -1826,70 +1821,70 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     #[cfg(feature = \"metadata-collector-lint\")]\n     {\n         if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n-            store.register_late_pass(|| box utils::internal_lints::metadata_collector::MetadataCollector::new());\n+            store.register_late_pass(|| Box::new(utils::internal_lints::metadata_collector::MetadataCollector::new()));\n             return;\n         }\n     }\n \n     // all the internal lints\n     #[cfg(feature = \"internal-lints\")]\n     {\n-        store.register_early_pass(|| box utils::internal_lints::ClippyLintsInternal);\n-        store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n-        store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n-        store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n-        store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n-        store.register_late_pass(|| box utils::internal_lints::IfChainStyle);\n-        store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n-        store.register_late_pass(|| box utils::internal_lints::InterningDefinedSymbol::default());\n-        store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n-        store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n-        store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n+        store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n+        store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n+        store.register_late_pass(|| Box::new(utils::inspector::DeepCodeInspector));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::CollapsibleCalls));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::IfChainStyle));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::InvalidPaths));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::InterningDefinedSymbol::default()));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::LintWithoutLintPass::default()));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::OuterExpnDataPass));\n     }\n \n-    store.register_late_pass(|| box utils::author::Author);\n-    store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n-    store.register_late_pass(|| box serde_api::SerdeApi);\n+    store.register_late_pass(|| Box::new(utils::author::Author));\n+    store.register_late_pass(|| Box::new(await_holding_invalid::AwaitHolding));\n+    store.register_late_pass(|| Box::new(serde_api::SerdeApi));\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n-    store.register_late_pass(move || box types::Types::new(\n+    store.register_late_pass(move || Box::new(types::Types::new(\n         vec_box_size_threshold,\n         type_complexity_threshold,\n         avoid_breaking_exported_api,\n-    ));\n-    store.register_late_pass(|| box booleans::NonminimalBool);\n-    store.register_late_pass(|| box needless_bitwise_bool::NeedlessBitwiseBool);\n-    store.register_late_pass(|| box eq_op::EqOp);\n-    store.register_late_pass(|| box enum_clike::UnportableVariant);\n-    store.register_late_pass(|| box float_literal::FloatLiteral);\n+    )));\n+    store.register_late_pass(|| Box::new(booleans::NonminimalBool));\n+    store.register_late_pass(|| Box::new(needless_bitwise_bool::NeedlessBitwiseBool));\n+    store.register_late_pass(|| Box::new(eq_op::EqOp));\n+    store.register_late_pass(|| Box::new(enum_clike::UnportableVariant));\n+    store.register_late_pass(|| Box::new(float_literal::FloatLiteral));\n     let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n-    store.register_late_pass(move || box bit_mask::BitMask::new(verbose_bit_mask_threshold));\n-    store.register_late_pass(|| box ptr::Ptr);\n-    store.register_late_pass(|| box ptr_eq::PtrEq);\n-    store.register_late_pass(|| box needless_bool::NeedlessBool);\n-    store.register_late_pass(|| box needless_bool::BoolComparison);\n-    store.register_late_pass(|| box needless_for_each::NeedlessForEach);\n-    store.register_late_pass(|| box approx_const::ApproxConstant);\n-    store.register_late_pass(|| box misc::MiscLints);\n-    store.register_late_pass(|| box eta_reduction::EtaReduction);\n-    store.register_late_pass(|| box identity_op::IdentityOp);\n-    store.register_late_pass(|| box erasing_op::ErasingOp);\n-    store.register_late_pass(|| box mut_mut::MutMut);\n-    store.register_late_pass(|| box mut_reference::UnnecessaryMutPassed);\n-    store.register_late_pass(|| box len_zero::LenZero);\n-    store.register_late_pass(|| box attrs::Attributes);\n-    store.register_late_pass(|| box blocks_in_if_conditions::BlocksInIfConditions);\n-    store.register_late_pass(|| box collapsible_match::CollapsibleMatch);\n-    store.register_late_pass(|| box unicode::Unicode);\n-    store.register_late_pass(|| box unit_return_expecting_ord::UnitReturnExpectingOrd);\n-    store.register_late_pass(|| box strings::StringAdd);\n-    store.register_late_pass(|| box implicit_return::ImplicitReturn);\n-    store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n-    store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback);\n-    store.register_late_pass(|| box inconsistent_struct_constructor::InconsistentStructConstructor);\n-    store.register_late_pass(|| box non_octal_unix_permissions::NonOctalUnixPermissions);\n-    store.register_early_pass(|| box unnecessary_self_imports::UnnecessarySelfImports);\n+    store.register_late_pass(move || Box::new(bit_mask::BitMask::new(verbose_bit_mask_threshold)));\n+    store.register_late_pass(|| Box::new(ptr::Ptr));\n+    store.register_late_pass(|| Box::new(ptr_eq::PtrEq));\n+    store.register_late_pass(|| Box::new(needless_bool::NeedlessBool));\n+    store.register_late_pass(|| Box::new(needless_bool::BoolComparison));\n+    store.register_late_pass(|| Box::new(needless_for_each::NeedlessForEach));\n+    store.register_late_pass(|| Box::new(approx_const::ApproxConstant));\n+    store.register_late_pass(|| Box::new(misc::MiscLints));\n+    store.register_late_pass(|| Box::new(eta_reduction::EtaReduction));\n+    store.register_late_pass(|| Box::new(identity_op::IdentityOp));\n+    store.register_late_pass(|| Box::new(erasing_op::ErasingOp));\n+    store.register_late_pass(|| Box::new(mut_mut::MutMut));\n+    store.register_late_pass(|| Box::new(mut_reference::UnnecessaryMutPassed));\n+    store.register_late_pass(|| Box::new(len_zero::LenZero));\n+    store.register_late_pass(|| Box::new(attrs::Attributes));\n+    store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n+    store.register_late_pass(|| Box::new(collapsible_match::CollapsibleMatch));\n+    store.register_late_pass(|| Box::new(unicode::Unicode));\n+    store.register_late_pass(|| Box::new(unit_return_expecting_ord::UnitReturnExpectingOrd));\n+    store.register_late_pass(|| Box::new(strings::StringAdd));\n+    store.register_late_pass(|| Box::new(implicit_return::ImplicitReturn));\n+    store.register_late_pass(|| Box::new(implicit_saturating_sub::ImplicitSaturatingSub));\n+    store.register_late_pass(|| Box::new(default_numeric_fallback::DefaultNumericFallback));\n+    store.register_late_pass(|| Box::new(inconsistent_struct_constructor::InconsistentStructConstructor));\n+    store.register_late_pass(|| Box::new(non_octal_unix_permissions::NonOctalUnixPermissions));\n+    store.register_early_pass(|| Box::new(unnecessary_self_imports::UnnecessarySelfImports));\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n@@ -1899,234 +1894,233 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n \n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n-    store.register_late_pass(move || box methods::Methods::new(avoid_breaking_exported_api, msrv));\n-    store.register_late_pass(move || box matches::Matches::new(msrv));\n-    store.register_early_pass(move || box manual_non_exhaustive::ManualNonExhaustive::new(msrv));\n-    store.register_late_pass(move || box manual_strip::ManualStrip::new(msrv));\n-    store.register_early_pass(move || box redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv));\n-    store.register_early_pass(move || box redundant_field_names::RedundantFieldNames::new(msrv));\n-    store.register_late_pass(move || box checked_conversions::CheckedConversions::new(msrv));\n-    store.register_late_pass(move || box mem_replace::MemReplace::new(msrv));\n-    store.register_late_pass(move || box ranges::Ranges::new(msrv));\n-    store.register_late_pass(move || box from_over_into::FromOverInto::new(msrv));\n-    store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n-    store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n-    store.register_late_pass(move || box needless_question_mark::NeedlessQuestionMark);\n-    store.register_late_pass(move || box casts::Casts::new(msrv));\n-    store.register_early_pass(move || box unnested_or_patterns::UnnestedOrPatterns::new(msrv));\n+    store.register_late_pass(move || Box::new(methods::Methods::new(avoid_breaking_exported_api, msrv)));\n+    store.register_late_pass(move || Box::new(matches::Matches::new(msrv)));\n+    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustive::new(msrv)));\n+    store.register_late_pass(move || Box::new(manual_strip::ManualStrip::new(msrv)));\n+    store.register_early_pass(move || Box::new(redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv)));\n+    store.register_early_pass(move || Box::new(redundant_field_names::RedundantFieldNames::new(msrv)));\n+    store.register_late_pass(move || Box::new(checked_conversions::CheckedConversions::new(msrv)));\n+    store.register_late_pass(move || Box::new(mem_replace::MemReplace::new(msrv)));\n+    store.register_late_pass(move || Box::new(ranges::Ranges::new(msrv)));\n+    store.register_late_pass(move || Box::new(from_over_into::FromOverInto::new(msrv)));\n+    store.register_late_pass(move || Box::new(use_self::UseSelf::new(msrv)));\n+    store.register_late_pass(move || Box::new(missing_const_for_fn::MissingConstForFn::new(msrv)));\n+    store.register_late_pass(move || Box::new(needless_question_mark::NeedlessQuestionMark));\n+    store.register_late_pass(move || Box::new(casts::Casts::new(msrv)));\n+    store.register_early_pass(move || Box::new(unnested_or_patterns::UnnestedOrPatterns::new(msrv)));\n \n-    store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n-    store.register_late_pass(|| box map_clone::MapClone);\n-    store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n-    store.register_late_pass(|| box shadow::Shadow);\n-    store.register_late_pass(|| box unit_types::UnitTypes);\n-    store.register_late_pass(|| box loops::Loops);\n-    store.register_late_pass(|| box main_recursion::MainRecursion::default());\n-    store.register_late_pass(|| box lifetimes::Lifetimes);\n-    store.register_late_pass(|| box entry::HashMapPass);\n-    store.register_late_pass(|| box minmax::MinMaxPass);\n-    store.register_late_pass(|| box open_options::OpenOptions);\n-    store.register_late_pass(|| box zero_div_zero::ZeroDiv);\n-    store.register_late_pass(|| box mutex_atomic::Mutex);\n-    store.register_late_pass(|| box needless_update::NeedlessUpdate);\n-    store.register_late_pass(|| box needless_borrow::NeedlessBorrow::default());\n-    store.register_late_pass(|| box needless_borrowed_ref::NeedlessBorrowedRef);\n-    store.register_late_pass(|| box no_effect::NoEffect);\n-    store.register_late_pass(|| box temporary_assignment::TemporaryAssignment);\n-    store.register_late_pass(|| box transmute::Transmute);\n+    store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n+    store.register_late_pass(|| Box::new(map_clone::MapClone));\n+    store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n+    store.register_late_pass(|| Box::new(shadow::Shadow));\n+    store.register_late_pass(|| Box::new(unit_types::UnitTypes));\n+    store.register_late_pass(|| Box::new(loops::Loops));\n+    store.register_late_pass(|| Box::new(main_recursion::MainRecursion::default()));\n+    store.register_late_pass(|| Box::new(lifetimes::Lifetimes));\n+    store.register_late_pass(|| Box::new(entry::HashMapPass));\n+    store.register_late_pass(|| Box::new(minmax::MinMaxPass));\n+    store.register_late_pass(|| Box::new(open_options::OpenOptions));\n+    store.register_late_pass(|| Box::new(zero_div_zero::ZeroDiv));\n+    store.register_late_pass(|| Box::new(mutex_atomic::Mutex));\n+    store.register_late_pass(|| Box::new(needless_update::NeedlessUpdate));\n+    store.register_late_pass(|| Box::new(needless_borrow::NeedlessBorrow::default()));\n+    store.register_late_pass(|| Box::new(needless_borrowed_ref::NeedlessBorrowedRef));\n+    store.register_late_pass(|| Box::new(no_effect::NoEffect));\n+    store.register_late_pass(|| Box::new(temporary_assignment::TemporaryAssignment));\n+    store.register_late_pass(|| Box::new(transmute::Transmute));\n     let cognitive_complexity_threshold = conf.cognitive_complexity_threshold;\n-    store.register_late_pass(move || box cognitive_complexity::CognitiveComplexity::new(cognitive_complexity_threshold));\n+    store.register_late_pass(move || Box::new(cognitive_complexity::CognitiveComplexity::new(cognitive_complexity_threshold)));\n     let too_large_for_stack = conf.too_large_for_stack;\n-    store.register_late_pass(move || box escape::BoxedLocal{too_large_for_stack});\n-    store.register_late_pass(move || box vec::UselessVec{too_large_for_stack});\n-    store.register_late_pass(|| box panic_unimplemented::PanicUnimplemented);\n-    store.register_late_pass(|| box strings::StringLitAsBytes);\n-    store.register_late_pass(|| box derive::Derive);\n-    store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n-    store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n-    store.register_late_pass(|| box empty_enum::EmptyEnum);\n-    store.register_late_pass(|| box absurd_extreme_comparisons::AbsurdExtremeComparisons);\n-    store.register_late_pass(|| box invalid_upcast_comparisons::InvalidUpcastComparisons);\n-    store.register_late_pass(|| box regex::Regex::default());\n-    store.register_late_pass(|| box copies::CopyAndPaste);\n-    store.register_late_pass(|| box copy_iterator::CopyIterator);\n-    store.register_late_pass(|| box format::UselessFormat);\n-    store.register_late_pass(|| box swap::Swap);\n-    store.register_late_pass(|| box overflow_check_conditional::OverflowCheckConditional);\n-    store.register_late_pass(|| box new_without_default::NewWithoutDefault::default());\n+    store.register_late_pass(move || Box::new(escape::BoxedLocal{too_large_for_stack}));\n+    store.register_late_pass(move || Box::new(vec::UselessVec{too_large_for_stack}));\n+    store.register_late_pass(|| Box::new(panic_unimplemented::PanicUnimplemented));\n+    store.register_late_pass(|| Box::new(strings::StringLitAsBytes));\n+    store.register_late_pass(|| Box::new(derive::Derive));\n+    store.register_late_pass(|| Box::new(get_last_with_len::GetLastWithLen));\n+    store.register_late_pass(|| Box::new(drop_forget_ref::DropForgetRef));\n+    store.register_late_pass(|| Box::new(empty_enum::EmptyEnum));\n+    store.register_late_pass(|| Box::new(absurd_extreme_comparisons::AbsurdExtremeComparisons));\n+    store.register_late_pass(|| Box::new(invalid_upcast_comparisons::InvalidUpcastComparisons));\n+    store.register_late_pass(|| Box::new(regex::Regex::default()));\n+    store.register_late_pass(|| Box::new(copies::CopyAndPaste));\n+    store.register_late_pass(|| Box::new(copy_iterator::CopyIterator));\n+    store.register_late_pass(|| Box::new(format::UselessFormat));\n+    store.register_late_pass(|| Box::new(swap::Swap));\n+    store.register_late_pass(|| Box::new(overflow_check_conditional::OverflowCheckConditional));\n+    store.register_late_pass(|| Box::new(new_without_default::NewWithoutDefault::default()));\n     let blacklisted_names = conf.blacklisted_names.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || box blacklisted_name::BlacklistedName::new(blacklisted_names.clone()));\n+    store.register_late_pass(move || Box::new(blacklisted_name::BlacklistedName::new(blacklisted_names.clone())));\n     let too_many_arguments_threshold = conf.too_many_arguments_threshold;\n     let too_many_lines_threshold = conf.too_many_lines_threshold;\n-    store.register_late_pass(move || box functions::Functions::new(too_many_arguments_threshold, too_many_lines_threshold));\n+    store.register_late_pass(move || Box::new(functions::Functions::new(too_many_arguments_threshold, too_many_lines_threshold)));\n     let doc_valid_idents = conf.doc_valid_idents.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || box doc::DocMarkdown::new(doc_valid_idents.clone()));\n-    store.register_late_pass(|| box neg_multiply::NegMultiply);\n-    store.register_late_pass(|| box mem_discriminant::MemDiscriminant);\n-    store.register_late_pass(|| box mem_forget::MemForget);\n-    store.register_late_pass(|| box arithmetic::Arithmetic::default());\n-    store.register_late_pass(|| box assign_ops::AssignOps);\n-    store.register_late_pass(|| box let_if_seq::LetIfSeq);\n-    store.register_late_pass(|| box eval_order_dependence::EvalOrderDependence);\n-    store.register_late_pass(|| box missing_doc::MissingDoc::new());\n-    store.register_late_pass(|| box missing_inline::MissingInline);\n-    store.register_late_pass(move || box exhaustive_items::ExhaustiveItems);\n-    store.register_late_pass(|| box if_let_some_result::OkIfLet);\n-    store.register_late_pass(|| box partialeq_ne_impl::PartialEqNeImpl);\n-    store.register_late_pass(|| box unused_io_amount::UnusedIoAmount);\n+    store.register_late_pass(move || Box::new(doc::DocMarkdown::new(doc_valid_idents.clone())));\n+    store.register_late_pass(|| Box::new(neg_multiply::NegMultiply));\n+    store.register_late_pass(|| Box::new(mem_discriminant::MemDiscriminant));\n+    store.register_late_pass(|| Box::new(mem_forget::MemForget));\n+    store.register_late_pass(|| Box::new(arithmetic::Arithmetic::default()));\n+    store.register_late_pass(|| Box::new(assign_ops::AssignOps));\n+    store.register_late_pass(|| Box::new(let_if_seq::LetIfSeq));\n+    store.register_late_pass(|| Box::new(eval_order_dependence::EvalOrderDependence));\n+    store.register_late_pass(|| Box::new(missing_doc::MissingDoc::new()));\n+    store.register_late_pass(|| Box::new(missing_inline::MissingInline));\n+    store.register_late_pass(move || Box::new(exhaustive_items::ExhaustiveItems));\n+    store.register_late_pass(|| Box::new(if_let_some_result::OkIfLet));\n+    store.register_late_pass(|| Box::new(partialeq_ne_impl::PartialEqNeImpl));\n+    store.register_late_pass(|| Box::new(unused_io_amount::UnusedIoAmount));\n     let enum_variant_size_threshold = conf.enum_variant_size_threshold;\n-    store.register_late_pass(move || box large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold));\n-    store.register_late_pass(|| box explicit_write::ExplicitWrite);\n-    store.register_late_pass(|| box needless_pass_by_value::NeedlessPassByValue);\n+    store.register_late_pass(move || Box::new(large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold)));\n+    store.register_late_pass(|| Box::new(explicit_write::ExplicitWrite));\n+    store.register_late_pass(|| Box::new(needless_pass_by_value::NeedlessPassByValue));\n     let pass_by_ref_or_value = pass_by_ref_or_value::PassByRefOrValue::new(\n         conf.trivial_copy_size_limit,\n         conf.pass_by_value_size_limit,\n         conf.avoid_breaking_exported_api,\n         &sess.target,\n     );\n-    store.register_late_pass(move || box pass_by_ref_or_value);\n-    store.register_late_pass(|| box ref_option_ref::RefOptionRef);\n-    store.register_late_pass(|| box try_err::TryErr);\n-    store.register_late_pass(|| box bytecount::ByteCount);\n-    store.register_late_pass(|| box infinite_iter::InfiniteIter);\n-    store.register_late_pass(|| box inline_fn_without_body::InlineFnWithoutBody);\n-    store.register_late_pass(|| box useless_conversion::UselessConversion::default());\n-    store.register_late_pass(|| box implicit_hasher::ImplicitHasher);\n-    store.register_late_pass(|| box fallible_impl_from::FallibleImplFrom);\n-    store.register_late_pass(|| box double_comparison::DoubleComparisons);\n-    store.register_late_pass(|| box question_mark::QuestionMark);\n-    store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);\n-    store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n-    store.register_late_pass(|| box map_unit_fn::MapUnit);\n-    store.register_late_pass(|| box inherent_impl::MultipleInherentImpl);\n-    store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n-    store.register_late_pass(|| box unwrap::Unwrap);\n-    store.register_late_pass(|| box duration_subsec::DurationSubsec);\n-    store.register_late_pass(|| box indexing_slicing::IndexingSlicing);\n-    store.register_late_pass(|| box non_copy_const::NonCopyConst);\n-    store.register_late_pass(|| box ptr_offset_with_cast::PtrOffsetWithCast);\n-    store.register_late_pass(|| box redundant_clone::RedundantClone);\n-    store.register_late_pass(|| box slow_vector_initialization::SlowVectorInit);\n-    store.register_late_pass(|| box unnecessary_sort_by::UnnecessarySortBy);\n-    store.register_late_pass(move || box unnecessary_wraps::UnnecessaryWraps::new(avoid_breaking_exported_api));\n-    store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n-    store.register_late_pass(|| box transmuting_null::TransmutingNull);\n-    store.register_late_pass(|| box path_buf_push_overwrite::PathBufPushOverwrite);\n-    store.register_late_pass(|| box integer_division::IntegerDivision);\n-    store.register_late_pass(|| box inherent_to_string::InherentToString);\n+    store.register_late_pass(move || Box::new(pass_by_ref_or_value));\n+    store.register_late_pass(|| Box::new(ref_option_ref::RefOptionRef));\n+    store.register_late_pass(|| Box::new(try_err::TryErr));\n+    store.register_late_pass(|| Box::new(bytecount::ByteCount));\n+    store.register_late_pass(|| Box::new(infinite_iter::InfiniteIter));\n+    store.register_late_pass(|| Box::new(inline_fn_without_body::InlineFnWithoutBody));\n+    store.register_late_pass(|| Box::new(useless_conversion::UselessConversion::default()));\n+    store.register_late_pass(|| Box::new(implicit_hasher::ImplicitHasher));\n+    store.register_late_pass(|| Box::new(fallible_impl_from::FallibleImplFrom));\n+    store.register_late_pass(|| Box::new(double_comparison::DoubleComparisons));\n+    store.register_late_pass(|| Box::new(question_mark::QuestionMark));\n+    store.register_early_pass(|| Box::new(suspicious_operation_groupings::SuspiciousOperationGroupings));\n+    store.register_late_pass(|| Box::new(suspicious_trait_impl::SuspiciousImpl));\n+    store.register_late_pass(|| Box::new(map_unit_fn::MapUnit));\n+    store.register_late_pass(|| Box::new(inherent_impl::MultipleInherentImpl));\n+    store.register_late_pass(|| Box::new(neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd));\n+    store.register_late_pass(|| Box::new(unwrap::Unwrap));\n+    store.register_late_pass(|| Box::new(duration_subsec::DurationSubsec));\n+    store.register_late_pass(|| Box::new(indexing_slicing::IndexingSlicing));\n+    store.register_late_pass(|| Box::new(non_copy_const::NonCopyConst));\n+    store.register_late_pass(|| Box::new(ptr_offset_with_cast::PtrOffsetWithCast));\n+    store.register_late_pass(|| Box::new(redundant_clone::RedundantClone));\n+    store.register_late_pass(|| Box::new(slow_vector_initialization::SlowVectorInit));\n+    store.register_late_pass(|| Box::new(unnecessary_sort_by::UnnecessarySortBy));\n+    store.register_late_pass(move || Box::new(unnecessary_wraps::UnnecessaryWraps::new(avoid_breaking_exported_api)));\n+    store.register_late_pass(|| Box::new(assertions_on_constants::AssertionsOnConstants));\n+    store.register_late_pass(|| Box::new(transmuting_null::TransmutingNull));\n+    store.register_late_pass(|| Box::new(path_buf_push_overwrite::PathBufPushOverwrite));\n+    store.register_late_pass(|| Box::new(integer_division::IntegerDivision));\n+    store.register_late_pass(|| Box::new(inherent_to_string::InherentToString));\n     let max_trait_bounds = conf.max_trait_bounds;\n-    store.register_late_pass(move || box trait_bounds::TraitBounds::new(max_trait_bounds));\n-    store.register_late_pass(|| box comparison_chain::ComparisonChain);\n-    store.register_late_pass(|| box mut_key::MutableKeyType);\n-    store.register_late_pass(|| box modulo_arithmetic::ModuloArithmetic);\n-    store.register_early_pass(|| box reference::DerefAddrOf);\n-    store.register_early_pass(|| box reference::RefInDeref);\n-    store.register_early_pass(|| box double_parens::DoubleParens);\n-    store.register_late_pass(|| box to_string_in_display::ToStringInDisplay::new());\n-    store.register_early_pass(|| box unsafe_removed_from_name::UnsafeNameRemoval);\n-    store.register_early_pass(|| box if_not_else::IfNotElse);\n-    store.register_early_pass(|| box else_if_without_else::ElseIfWithoutElse);\n-    store.register_early_pass(|| box int_plus_one::IntPlusOne);\n-    store.register_early_pass(|| box formatting::Formatting);\n-    store.register_early_pass(|| box misc_early::MiscEarlyLints);\n-    store.register_early_pass(|| box redundant_closure_call::RedundantClosureCall);\n-    store.register_late_pass(|| box redundant_closure_call::RedundantClosureCall);\n-    store.register_early_pass(|| box unused_unit::UnusedUnit);\n-    store.register_late_pass(|| box returns::Return);\n-    store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n-    store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n-    store.register_early_pass(|| box precedence::Precedence);\n-    store.register_early_pass(|| box needless_continue::NeedlessContinue);\n-    store.register_early_pass(|| box redundant_else::RedundantElse);\n-    store.register_late_pass(|| box create_dir::CreateDir);\n-    store.register_early_pass(|| box needless_arbitrary_self_type::NeedlessArbitrarySelfType);\n+    store.register_late_pass(move || Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n+    store.register_late_pass(|| Box::new(comparison_chain::ComparisonChain));\n+    store.register_late_pass(|| Box::new(mut_key::MutableKeyType));\n+    store.register_late_pass(|| Box::new(modulo_arithmetic::ModuloArithmetic));\n+    store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n+    store.register_early_pass(|| Box::new(reference::RefInDeref));\n+    store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n+    store.register_late_pass(|| Box::new(to_string_in_display::ToStringInDisplay::new()));\n+    store.register_early_pass(|| Box::new(unsafe_removed_from_name::UnsafeNameRemoval));\n+    store.register_early_pass(|| Box::new(if_not_else::IfNotElse));\n+    store.register_early_pass(|| Box::new(else_if_without_else::ElseIfWithoutElse));\n+    store.register_early_pass(|| Box::new(int_plus_one::IntPlusOne));\n+    store.register_early_pass(|| Box::new(formatting::Formatting));\n+    store.register_early_pass(|| Box::new(misc_early::MiscEarlyLints));\n+    store.register_early_pass(|| Box::new(redundant_closure_call::RedundantClosureCall));\n+    store.register_late_pass(|| Box::new(redundant_closure_call::RedundantClosureCall));\n+    store.register_early_pass(|| Box::new(unused_unit::UnusedUnit));\n+    store.register_late_pass(|| Box::new(returns::Return));\n+    store.register_early_pass(|| Box::new(collapsible_if::CollapsibleIf));\n+    store.register_early_pass(|| Box::new(items_after_statements::ItemsAfterStatements));\n+    store.register_early_pass(|| Box::new(precedence::Precedence));\n+    store.register_early_pass(|| Box::new(needless_continue::NeedlessContinue));\n+    store.register_early_pass(|| Box::new(redundant_else::RedundantElse));\n+    store.register_late_pass(|| Box::new(create_dir::CreateDir));\n+    store.register_early_pass(|| Box::new(needless_arbitrary_self_type::NeedlessArbitrarySelfType));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n-    store.register_late_pass(move || box cargo_common_metadata::CargoCommonMetadata::new(cargo_ignore_publish));\n-    store.register_late_pass(|| box multiple_crate_versions::MultipleCrateVersions);\n-    store.register_late_pass(|| box wildcard_dependencies::WildcardDependencies);\n+    store.register_late_pass(move || Box::new(cargo_common_metadata::CargoCommonMetadata::new(cargo_ignore_publish)));\n+    store.register_late_pass(|| Box::new(multiple_crate_versions::MultipleCrateVersions));\n+    store.register_late_pass(|| Box::new(wildcard_dependencies::WildcardDependencies));\n     let literal_representation_lint_fraction_readability = conf.unreadable_literal_lint_fractions;\n-    store.register_early_pass(move || box literal_representation::LiteralDigitGrouping::new(literal_representation_lint_fraction_readability));\n+    store.register_early_pass(move || Box::new(literal_representation::LiteralDigitGrouping::new(literal_representation_lint_fraction_readability)));\n     let literal_representation_threshold = conf.literal_representation_threshold;\n-    store.register_early_pass(move || box literal_representation::DecimalLiteralRepresentation::new(literal_representation_threshold));\n+    store.register_early_pass(move || Box::new(literal_representation::DecimalLiteralRepresentation::new(literal_representation_threshold)));\n     let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n-    store.register_late_pass(move || box enum_variants::EnumVariantNames::new(enum_variant_name_threshold, avoid_breaking_exported_api));\n-    store.register_early_pass(|| box tabs_in_doc_comments::TabsInDocComments);\n+    store.register_late_pass(move || Box::new(enum_variants::EnumVariantNames::new(enum_variant_name_threshold, avoid_breaking_exported_api)));\n+    store.register_early_pass(|| Box::new(tabs_in_doc_comments::TabsInDocComments));\n     let upper_case_acronyms_aggressive = conf.upper_case_acronyms_aggressive;\n-    store.register_late_pass(move || box upper_case_acronyms::UpperCaseAcronyms::new(avoid_breaking_exported_api, upper_case_acronyms_aggressive));\n-    store.register_late_pass(|| box default::Default::default());\n-    store.register_late_pass(|| box unused_self::UnusedSelf);\n-    store.register_late_pass(|| box mutable_debug_assertion::DebugAssertWithMutCall);\n-    store.register_late_pass(|| box exit::Exit);\n-    store.register_late_pass(|| box to_digit_is_some::ToDigitIsSome);\n+    store.register_late_pass(move || Box::new(upper_case_acronyms::UpperCaseAcronyms::new(avoid_breaking_exported_api, upper_case_acronyms_aggressive)));\n+    store.register_late_pass(|| Box::new(default::Default::default()));\n+    store.register_late_pass(|| Box::new(unused_self::UnusedSelf));\n+    store.register_late_pass(|| Box::new(mutable_debug_assertion::DebugAssertWithMutCall));\n+    store.register_late_pass(|| Box::new(exit::Exit));\n+    store.register_late_pass(|| Box::new(to_digit_is_some::ToDigitIsSome));\n     let array_size_threshold = conf.array_size_threshold;\n-    store.register_late_pass(move || box large_stack_arrays::LargeStackArrays::new(array_size_threshold));\n-    store.register_late_pass(move || box large_const_arrays::LargeConstArrays::new(array_size_threshold));\n-    store.register_late_pass(|| box floating_point_arithmetic::FloatingPointArithmetic);\n-    store.register_early_pass(|| box as_conversions::AsConversions);\n-    store.register_late_pass(|| box let_underscore::LetUnderscore);\n-    store.register_late_pass(|| box atomic_ordering::AtomicOrdering);\n-    store.register_early_pass(|| box single_component_path_imports::SingleComponentPathImports);\n+    store.register_late_pass(move || Box::new(large_stack_arrays::LargeStackArrays::new(array_size_threshold)));\n+    store.register_late_pass(move || Box::new(large_const_arrays::LargeConstArrays::new(array_size_threshold)));\n+    store.register_late_pass(|| Box::new(floating_point_arithmetic::FloatingPointArithmetic));\n+    store.register_early_pass(|| Box::new(as_conversions::AsConversions));\n+    store.register_late_pass(|| Box::new(let_underscore::LetUnderscore));\n+    store.register_early_pass(|| Box::new(single_component_path_imports::SingleComponentPathImports));\n     let max_fn_params_bools = conf.max_fn_params_bools;\n     let max_struct_bools = conf.max_struct_bools;\n-    store.register_early_pass(move || box excessive_bools::ExcessiveBools::new(max_struct_bools, max_fn_params_bools));\n-    store.register_early_pass(|| box option_env_unwrap::OptionEnvUnwrap);\n+    store.register_early_pass(move || Box::new(excessive_bools::ExcessiveBools::new(max_struct_bools, max_fn_params_bools)));\n+    store.register_early_pass(|| Box::new(option_env_unwrap::OptionEnvUnwrap));\n     let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n-    store.register_late_pass(move || box wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports));\n-    store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n-    store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n-    store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n-    store.register_late_pass(|| box dereference::Dereferencing::default());\n-    store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n-    store.register_late_pass(|| box future_not_send::FutureNotSend);\n-    store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n-    store.register_late_pass(|| box mut_mutex_lock::MutMutexLock);\n-    store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n-    store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n-    store.register_late_pass(|| box vec_resize_to_zero::VecResizeToZero);\n-    store.register_late_pass(|| box panic_in_result_fn::PanicInResultFn);\n+    store.register_late_pass(move || Box::new(wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports)));\n+    store.register_late_pass(|| Box::new(verbose_file_reads::VerboseFileReads));\n+    store.register_late_pass(|| Box::new(redundant_pub_crate::RedundantPubCrate::default()));\n+    store.register_late_pass(|| Box::new(unnamed_address::UnnamedAddress));\n+    store.register_late_pass(|| Box::new(dereference::Dereferencing::default()));\n+    store.register_late_pass(|| Box::new(option_if_let_else::OptionIfLetElse));\n+    store.register_late_pass(|| Box::new(future_not_send::FutureNotSend));\n+    store.register_late_pass(|| Box::new(if_let_mutex::IfLetMutex));\n+    store.register_late_pass(|| Box::new(mut_mutex_lock::MutMutexLock));\n+    store.register_late_pass(|| Box::new(match_on_vec_items::MatchOnVecItems));\n+    store.register_late_pass(|| Box::new(manual_async_fn::ManualAsyncFn));\n+    store.register_late_pass(|| Box::new(vec_resize_to_zero::VecResizeToZero));\n+    store.register_late_pass(|| Box::new(panic_in_result_fn::PanicInResultFn));\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n-    store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n+    store.register_early_pass(move || Box::new(non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold,\n-    });\n+    }));\n     let macro_matcher = conf.standard_macro_braces.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_early_pass(move || box nonstandard_macro_braces::MacroBraces::new(&macro_matcher));\n-    store.register_late_pass(|| box macro_use::MacroUseImports::default());\n-    store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n-    store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n-    store.register_late_pass(|| box repeat_once::RepeatOnce);\n-    store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n-    store.register_late_pass(|| box self_assignment::SelfAssignment);\n-    store.register_late_pass(|| box manual_unwrap_or::ManualUnwrapOr);\n-    store.register_late_pass(|| box manual_ok_or::ManualOkOr);\n-    store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n-    store.register_late_pass(|| box semicolon_if_nothing_returned::SemicolonIfNothingReturned);\n-    store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n+    store.register_early_pass(move || Box::new(nonstandard_macro_braces::MacroBraces::new(&macro_matcher)));\n+    store.register_late_pass(|| Box::new(macro_use::MacroUseImports::default()));\n+    store.register_late_pass(|| Box::new(pattern_type_mismatch::PatternTypeMismatch));\n+    store.register_late_pass(|| Box::new(stable_sort_primitive::StableSortPrimitive));\n+    store.register_late_pass(|| Box::new(repeat_once::RepeatOnce));\n+    store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n+    store.register_late_pass(|| Box::new(self_assignment::SelfAssignment));\n+    store.register_late_pass(|| Box::new(manual_unwrap_or::ManualUnwrapOr));\n+    store.register_late_pass(|| Box::new(manual_ok_or::ManualOkOr));\n+    store.register_late_pass(|| Box::new(float_equality_without_abs::FloatEqualityWithoutAbs));\n+    store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n+    store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));\n     let disallowed_methods = conf.disallowed_methods.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || box disallowed_method::DisallowedMethod::new(&disallowed_methods));\n-    store.register_early_pass(|| box asm_syntax::InlineAsmX86AttSyntax);\n-    store.register_early_pass(|| box asm_syntax::InlineAsmX86IntelSyntax);\n-    store.register_late_pass(|| box undropped_manually_drops::UndroppedManuallyDrops);\n-    store.register_late_pass(|| box strings::StrToString);\n-    store.register_late_pass(|| box strings::StringToString);\n-    store.register_late_pass(|| box zero_sized_map_values::ZeroSizedMapValues);\n-    store.register_late_pass(|| box vec_init_then_push::VecInitThenPush::default());\n-    store.register_late_pass(|| box case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons);\n-    store.register_late_pass(|| box redundant_slicing::RedundantSlicing);\n-    store.register_late_pass(|| box from_str_radix_10::FromStrRadix10);\n-    store.register_late_pass(|| box manual_map::ManualMap);\n-    store.register_late_pass(move || box if_then_some_else_none::IfThenSomeElseNone::new(msrv));\n-    store.register_late_pass(|| box bool_assert_comparison::BoolAssertComparison);\n-    store.register_early_pass(move || box module_style::ModStyle);\n-    store.register_late_pass(|| box unused_async::UnusedAsync);\n+    store.register_late_pass(move || Box::new(disallowed_method::DisallowedMethod::new(&disallowed_methods)));\n+    store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86AttSyntax));\n+    store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86IntelSyntax));\n+    store.register_late_pass(|| Box::new(undropped_manually_drops::UndroppedManuallyDrops));\n+    store.register_late_pass(|| Box::new(strings::StrToString));\n+    store.register_late_pass(|| Box::new(strings::StringToString));\n+    store.register_late_pass(|| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n+    store.register_late_pass(|| Box::new(vec_init_then_push::VecInitThenPush::default()));\n+    store.register_late_pass(|| Box::new(case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons));\n+    store.register_late_pass(|| Box::new(redundant_slicing::RedundantSlicing));\n+    store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n+    store.register_late_pass(|| Box::new(manual_map::ManualMap));\n+    store.register_late_pass(move || Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n+    store.register_late_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n+    store.register_early_pass(move || Box::new(module_style::ModStyle));\n+    store.register_late_pass(|| Box::new(unused_async::UnusedAsync));\n     let disallowed_types = conf.disallowed_types.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || box disallowed_type::DisallowedType::new(&disallowed_types));\n+    store.register_late_pass(move || Box::new(disallowed_type::DisallowedType::new(&disallowed_types)));\n     let import_renames = conf.enforced_import_renames.clone();\n-    store.register_late_pass(move || box missing_enforced_import_rename::ImportRename::new(import_renames.clone()));\n+    store.register_late_pass(move || Box::new(missing_enforced_import_rename::ImportRename::new(import_renames.clone())));\n     let scripts = conf.allowed_scripts.clone();\n-    store.register_early_pass(move || box disallowed_script_idents::DisallowedScriptIdents::new(&scripts));\n-    store.register_late_pass(|| box strlen_on_c_strings::StrlenOnCStrings);\n-    store.register_late_pass(move || box self_named_constructors::SelfNamedConstructors);\n-    store.register_late_pass(move || box feature_name::FeatureName);\n+    store.register_early_pass(move || Box::new(disallowed_script_idents::DisallowedScriptIdents::new(&scripts)));\n+    store.register_late_pass(|| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n+    store.register_late_pass(move || Box::new(self_named_constructors::SelfNamedConstructors));\n+    store.register_late_pass(move || Box::new(feature_name::FeatureName));\n }\n \n #[rustfmt::skip]\n@@ -2205,6 +2199,7 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::temporary_cstring_as_ptr\", \"temporary_cstring_as_ptr\");\n     ls.register_renamed(\"clippy::panic_params\", \"non_fmt_panics\");\n     ls.register_renamed(\"clippy::unknown_clippy_lints\", \"unknown_lints\");\n+    ls.register_renamed(\"clippy::invalid_atomic_ordering\", \"invalid_atomic_ordering\");\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "5b6e27085d580986bd892ac46552dc6b2d253e11", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,12 +1,13 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher;\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n-use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, StmtKind};\n+use rustc_hir::{Expr, ExprKind, Pat, PatKind, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n@@ -37,19 +38,18 @@ pub(super) fn check<'tcx>(\n \n         if_chain! {\n             if let Some(inner_expr) = inner_expr;\n-            if let ExprKind::Match(\n-                match_expr, [true_arm, _else_arm], MatchSource::IfLetDesugar{ contains_else_clause: false }\n-            ) = inner_expr.kind;\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n+                = higher::IfLet::hir(cx, inner_expr);\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-            if path_to_local_id(match_expr, pat_hir_id);\n+            if path_to_local_id(let_expr, pat_hir_id);\n             // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(ref qpath, _, _) = true_arm.pat.kind;\n+            if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n             let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n             let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n             // Ensure epxr in `if let` is not used afterwards\n-            if !is_local_used(cx, true_arm, pat_hir_id);\n+            if !is_local_used(cx, if_then, pat_hir_id);\n             then {\n                 let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n                 // Prepare the error message\n@@ -58,7 +58,7 @@ pub(super) fn check<'tcx>(\n                 // Prepare the help message\n                 let mut applicability = Applicability::MaybeIncorrect;\n                 let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n-                let copied = match cx.typeck_results().expr_ty(match_expr).kind() {\n+                let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n                     ty::Ref(_, inner, _) => match inner.kind() {\n                         ty::Ref(..) => \".copied()\",\n                         _ => \"\""}, {"sha": "df848e68802c552292a9147397fa313468d6d5de", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -27,7 +27,7 @@ pub(super) fn check<'tcx>(\n         start: Some(start),\n         end: Some(end),\n         limits,\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n@@ -265,7 +265,7 @@ impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     }\n }\n \n-/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n+/// a wrapper around `MinifyingSugg`, which carries an operator like currying\n /// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n struct Offset {\n     value: MinifyingSugg<'static>,"}, {"sha": "97cbe2c53ddac430fe000126fe49de44e0b776b7", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -551,7 +551,7 @@ declare_lint_pass!(Loops => [\n impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((pat, arg, body, span)) = higher::for_loop(expr) {\n+        if let Some(higher::ForLoop { pat, arg, body, span }) = higher::ForLoop::hir(expr) {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n             // since higher::for_loop expressions are marked as expansions\n@@ -580,8 +580,8 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some((cond, body)) = higher::while_loop(expr) {\n-            while_immutable_condition::check(cx, cond, body);\n+        if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n+            while_immutable_condition::check(cx, condition, body);\n         }\n \n         needless_collect::check(expr, cx);"}, {"sha": "344dc5074d369ff5e47e2751fbb46c79019963aa", "filename": "clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n         start: Some(start),\n         end: Some(end),\n         ..\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n         if mut_ids[0].is_some() || mut_ids[1].is_some() {"}, {"sha": "f17e76d9682c9e24d54bd659f941542ef67b6ae4", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -32,7 +32,7 @@ pub(super) fn check<'tcx>(\n         start: Some(start),\n         ref end,\n         limits,\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {"}, {"sha": "2c46971d5f741358eba4646be0997efb601c0aa5", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::NEVER_LOOP;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::higher;\n+use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, Node, Pat, Stmt, StmtKind};\n@@ -16,7 +16,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n                     if_chain! {\n                         if let LoopSource::ForLoop = source;\n                         if let Some((_, Node::Expr(parent_match))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-                        if let Some((pat, iterator, _, for_span)) = higher::for_loop(parent_match);\n+                        if let Some(ForLoop { arg: iterator, pat, span: for_span, .. }) = ForLoop::hir(parent_match);\n                         then {\n                             // Suggests using an `if let` instead. This is `Unspecified` because the\n                             // loop may (probably) contain `break` statements which would be invalid\n@@ -111,6 +111,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Unary(_, e)\n         | ExprKind::Cast(e, _)\n         | ExprKind::Type(e, _)\n+        | ExprKind::Let(_, e, _)\n         | ExprKind::Field(e, _)\n         | ExprKind::AddrOf(_, _, e)\n         | ExprKind::Struct(_, _, Some(e))\n@@ -128,7 +129,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n-        ExprKind::If(e, e2, ref e3) => {\n+        ExprKind::If(e, e2, e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n             let e3 = e3\n@@ -156,7 +157,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+        ExprKind::Break(_, e) | ExprKind::Ret(e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n             combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n         }),\n         ExprKind::InlineAsm(asm) => asm"}, {"sha": "545498a10478db9c623f979edee7a70bf3f54d37", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -49,7 +49,7 @@ pub(super) fn check<'tcx>(\n         if same_item_push_visitor.should_lint();\n         if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push;\n         let vec_ty = cx.typeck_results().expr_ty(vec);\n-        let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n+        let ty = vec_ty.walk(cx.tcx).nth(1).unwrap().expect_ty();\n         if cx\n             .tcx\n             .lang_items()"}, {"sha": "1848f5b5de2f2fca48c3f2c1d1d2ce00ce6a9d3a", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,8 +1,9 @@\n use super::WHILE_LET_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, MatchSource, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, MatchSource, Pat, StmtKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n \n@@ -11,41 +12,25 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n     let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n     // or extract the first expression (if any) from the block\n     if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n-        if let ExprKind::Match(matchexpr, arms, ref source) = inner.kind {\n-            // ensure \"if let\" compatible match structure\n-            match *source {\n-                MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n-                    if arms.len() == 2\n-                        && arms[0].guard.is_none()\n-                        && arms[1].guard.is_none()\n-                        && is_simple_break_expr(arms[1].body)\n-                    {\n-                        if in_external_macro(cx.sess(), expr.span) {\n-                            return;\n-                        }\n+        if let Some(higher::IfLet {\n+            let_pat,\n+            let_expr,\n+            if_else: Some(if_else),\n+            ..\n+        }) = higher::IfLet::hir(cx, inner)\n+        {\n+            if is_simple_break_expr(if_else) {\n+                could_be_while_let(cx, expr, let_pat, let_expr);\n+            }\n+        }\n \n-                        // NOTE: we used to build a body here instead of using\n-                        // ellipsis, this was removed because:\n-                        // 1) it was ugly with big bodies;\n-                        // 2) it was not indented properly;\n-                        // 3) it wasn\u2019t very smart (see #675).\n-                        let mut applicability = Applicability::HasPlaceholders;\n-                        span_lint_and_sugg(\n-                            cx,\n-                            WHILE_LET_LOOP,\n-                            expr.span,\n-                            \"this loop could be written as a `while let` loop\",\n-                            \"try\",\n-                            format!(\n-                                \"while let {} = {} {{ .. }}\",\n-                                snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability),\n-                                snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n-                            ),\n-                            applicability,\n-                        );\n-                    }\n-                },\n-                _ => (),\n+        if let ExprKind::Match(matchexpr, arms, MatchSource::Normal) = inner.kind {\n+            if arms.len() == 2\n+                && arms[0].guard.is_none()\n+                && arms[1].guard.is_none()\n+                && is_simple_break_expr(arms[1].body)\n+            {\n+                could_be_while_let(cx, expr, arms[0].pat, matchexpr);\n             }\n         }\n     }\n@@ -54,14 +39,12 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n /// If a block begins with a statement (possibly a `let` binding) and has an\n /// expression, return it.\n fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if block.stmts.is_empty() {\n-        return None;\n-    }\n-    if let StmtKind::Local(local) = block.stmts[0].kind {\n-        local.init //.map(|expr| expr)\n-    } else {\n-        None\n+    if let Some(first_stmt) = block.stmts.get(0) {\n+        if let StmtKind::Local(local) = first_stmt.kind {\n+            return local.init;\n+        }\n     }\n+    None\n }\n \n /// If a block begins with an expression (with or without semicolon), return it.\n@@ -86,3 +69,34 @@ fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n         _ => false,\n     }\n }\n+\n+fn could_be_while_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+) {\n+    if in_external_macro(cx.sess(), expr.span) {\n+        return;\n+    }\n+\n+    // NOTE: we used to build a body here instead of using\n+    // ellipsis, this was removed because:\n+    // 1) it was ugly with big bodies;\n+    // 2) it was not indented properly;\n+    // 3) it wasn\u2019t very smart (see #675).\n+    let mut applicability = Applicability::HasPlaceholders;\n+    span_lint_and_sugg(\n+        cx,\n+        WHILE_LET_LOOP,\n+        expr.span,\n+        \"this loop could be written as a `while let` loop\",\n+        \"try\",\n+        format!(\n+            \"while let {} = {} {{ .. }}\",\n+            snippet_with_applicability(cx, let_pat.span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability),\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "79527e3bfa92f1b4b790d88319de759db0d8de5d", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,33 +1,33 @@\n use super::WHILE_LET_ON_ITERATOR;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{\n     get_enclosing_loop_or_closure, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, MatchSource, Mutability, Node, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{symbol::sym, Span, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n-        if let ExprKind::Match(scrutinee_expr, [arm, _], MatchSource::WhileLetDesugar) = expr.kind;\n+        if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n-        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = arm.pat.kind;\n+        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n         if let Res::Def(_, pat_did) = pat_path.res;\n         if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n         // check for call to `Iterator::next`\n-        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = scrutinee_expr.kind;\n+        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;\n-        if is_trait_method(cx, scrutinee_expr, sym::Iterator);\n-        if let Some(iter_expr) = try_parse_iter_expr(cx, iter_expr);\n+        if is_trait_method(cx, let_expr, sym::Iterator);\n+        if let Some(iter_expr_struct) = try_parse_iter_expr(cx, iter_expr);\n         // get the loop containing the match expression\n-        if let Some((_, Node::Expr(loop_expr))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-        if !uses_iter(cx, &iter_expr, arm.body);\n+        if !uses_iter(cx, &iter_expr_struct, if_then);\n         then {\n-            (scrutinee_expr, iter_expr, some_pat, loop_expr)\n+            (let_expr, iter_expr_struct, some_pat, expr)\n         } else {\n             return;\n         }\n@@ -81,6 +81,7 @@ struct IterExpr {\n     /// The path being used.\n     path: Res,\n }\n+\n /// Parses any expression to find out which field of which variable is used. Will return `None` if\n /// the expression might have side effects.\n fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n@@ -285,6 +286,7 @@ fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr:\n     }\n     impl Visitor<'tcx> for NestedLoopVisitor<'a, 'b, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n+\n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n             NestedVisitorMap::None\n         }"}, {"sha": "b5f573cb104e914a6cde3eab296f7da9b7842b0c", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 147, "deletions": 154, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,5 +1,6 @@\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n@@ -10,7 +11,7 @@ use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind, Path, QPath,\n+    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -45,176 +46,168 @@ declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n impl LateLintPass<'_> for ManualMap {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(\n-            scrutinee,\n-            [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n-            match_kind,\n-        ) = expr.kind\n-        {\n-            if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-                return;\n-            }\n+        let (scrutinee, then_pat, then_body, else_pat, else_body) = match IfLetOrMatch::parse(cx, expr) {\n+            Some(IfLetOrMatch::IfLet(scrutinee, pat, body, Some(r#else))) => (scrutinee, pat, body, None, r#else),\n+            Some(IfLetOrMatch::Match(\n+                scrutinee,\n+                [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n+                _,\n+            )) => (scrutinee, arm1.pat, arm1.body, Some(arm2.pat), arm2.body),\n+            _ => return,\n+        };\n+        if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n+            return;\n+        }\n \n-            let (scrutinee_ty, ty_ref_count, ty_mutability) =\n-                peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-            if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n-                && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n-            {\n-                return;\n-            }\n+        let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+            peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+        if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n+        {\n+            return;\n+        }\n \n-            let expr_ctxt = expr.span.ctxt();\n-            let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-                try_parse_pattern(cx, arm1.pat, expr_ctxt),\n-                try_parse_pattern(cx, arm2.pat, expr_ctxt),\n-            ) {\n-                (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n-                    if is_none_expr(cx, arm1.body) =>\n-                {\n-                    (arm2.body, pattern, ref_count, true)\n-                },\n-                (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n-                    if is_none_expr(cx, arm1.body) =>\n-                {\n-                    (arm2.body, pattern, ref_count, false)\n-                },\n-                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n-                    if is_none_expr(cx, arm2.body) =>\n-                {\n-                    (arm1.body, pattern, ref_count, true)\n-                },\n-                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n-                    if is_none_expr(cx, arm2.body) =>\n-                {\n-                    (arm1.body, pattern, ref_count, false)\n-                },\n-                _ => return,\n-            };\n+        let expr_ctxt = expr.span.ctxt();\n+        let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+            try_parse_pattern(cx, then_pat, expr_ctxt),\n+            else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+        ) {\n+            (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+                (else_body, pattern, ref_count, true)\n+            },\n+            (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+                (else_body, pattern, ref_count, false)\n+            },\n+            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n+                (then_body, pattern, ref_count, true)\n+            },\n+            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n+                (then_body, pattern, ref_count, false)\n+            },\n+            _ => return,\n+        };\n \n-            // Top level or patterns aren't allowed in closures.\n-            if matches!(some_pat.kind, PatKind::Or(_)) {\n-                return;\n-            }\n+        // Top level or patterns aren't allowed in closures.\n+        if matches!(some_pat.kind, PatKind::Or(_)) {\n+            return;\n+        }\n \n-            let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n-                Some(expr) => expr,\n-                None => return,\n-            };\n+        let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n+            Some(expr) => expr,\n+            None => return,\n+        };\n \n-            // These two lints will go back and forth with each other.\n-            if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n-                && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-            {\n-                return;\n-            }\n+        // These two lints will go back and forth with each other.\n+        if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+            && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+        {\n+            return;\n+        }\n \n-            // `map` won't perform any adjustments.\n-            if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n-                return;\n-            }\n+        // `map` won't perform any adjustments.\n+        if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+            return;\n+        }\n \n-            // Determine which binding mode to use.\n-            let explicit_ref = some_pat.contains_explicit_ref_binding();\n-            let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+        // Determine which binding mode to use.\n+        let explicit_ref = some_pat.contains_explicit_ref_binding();\n+        let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n \n-            let as_ref_str = match binding_ref {\n-                Some(Mutability::Mut) => \".as_mut()\",\n-                Some(Mutability::Not) => \".as_ref()\",\n-                None => \"\",\n-            };\n+        let as_ref_str = match binding_ref {\n+            Some(Mutability::Mut) => \".as_mut()\",\n+            Some(Mutability::Not) => \".as_ref()\",\n+            None => \"\",\n+        };\n \n-            match can_move_expr_to_closure(cx, some_expr) {\n-                Some(captures) => {\n-                    // Check if captures the closure will need conflict with borrows made in the scrutinee.\n-                    // TODO: check all the references made in the scrutinee expression. This will require interacting\n-                    // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n-                    if let Some(binding_ref_mutability) = binding_ref {\n-                        let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n-                            ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n-                            _ => None,\n-                        });\n-                        if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n-                            match captures.get(l) {\n-                                Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n-                                Some(CaptureKind::Ref(Mutability::Not))\n-                                    if binding_ref_mutability == Mutability::Mut =>\n-                                {\n-                                    return;\n-                                }\n-                                Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n-                            }\n+        match can_move_expr_to_closure(cx, some_expr) {\n+            Some(captures) => {\n+                // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+                // TODO: check all the references made in the scrutinee expression. This will require interacting\n+                // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+                if let Some(binding_ref_mutability) = binding_ref {\n+                    let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                        ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                        _ => None,\n+                    });\n+                    if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                        match captures.get(l) {\n+                            Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                            Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                                return;\n+                            },\n+                            Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n                         }\n                     }\n-                },\n-                None => return,\n-            };\n-\n-            let mut app = Applicability::MachineApplicable;\n+                }\n+            },\n+            None => return,\n+        };\n \n-            // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-            // it's being passed by value.\n-            let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-            let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-            let scrutinee_str =\n-                if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-                    format!(\"({})\", scrutinee_str)\n-                } else {\n-                    scrutinee_str.into()\n-                };\n+        let mut app = Applicability::MachineApplicable;\n \n-            let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-                match can_pass_as_func(cx, id, some_expr) {\n-                    Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n-                        snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                    },\n-                    _ => {\n-                        if path_to_local_id(some_expr, id)\n-                            && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                            && binding_ref.is_some()\n-                        {\n-                            return;\n-                        }\n-\n-                        // `ref` and `ref mut` annotations were handled earlier.\n-                        let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                            \"mut \"\n-                        } else {\n-                            \"\"\n-                        };\n-                        format!(\n-                            \"|{}{}| {}\",\n-                            annotation,\n-                            some_binding,\n-                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                        )\n-                    },\n-                }\n-            } else if !is_wild_none && explicit_ref.is_none() {\n-                // TODO: handle explicit reference annotations.\n-                format!(\n-                    \"|{}| {}\",\n-                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n-                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                )\n+        // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+        // it's being passed by value.\n+        let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+        let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+        let scrutinee_str =\n+            if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+                format!(\"({})\", scrutinee_str)\n             } else {\n-                // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-                return;\n+                scrutinee_str.into()\n             };\n \n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_MAP,\n-                expr.span,\n-                \"manual implementation of `Option::map`\",\n-                \"try this\",\n-                if matches!(match_kind, MatchSource::IfLetDesugar { .. }) && is_else_clause(cx.tcx, expr) {\n-                    format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n-                } else {\n-                    format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n+        let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+            match can_pass_as_func(cx, id, some_expr) {\n+                Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n                 },\n-                app,\n-            );\n-        }\n+                _ => {\n+                    if path_to_local_id(some_expr, id)\n+                        && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                        && binding_ref.is_some()\n+                    {\n+                        return;\n+                    }\n+\n+                    // `ref` and `ref mut` annotations were handled earlier.\n+                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                        \"mut \"\n+                    } else {\n+                        \"\"\n+                    };\n+                    format!(\n+                        \"|{}{}| {}\",\n+                        annotation,\n+                        some_binding,\n+                        snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n+                    )\n+                },\n+            }\n+        } else if !is_wild_none && explicit_ref.is_none() {\n+            // TODO: handle explicit reference annotations.\n+            format!(\n+                \"|{}| {}\",\n+                snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n+            )\n+        } else {\n+            // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+            return;\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_MAP,\n+            expr.span,\n+            \"manual implementation of `Option::map`\",\n+            \"try this\",\n+            if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n+                format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+            } else {\n+                format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n+            },\n+            app,\n+        );\n     }\n }\n "}, {"sha": "4e040508b6bfbdc396c233c1df3222add7802ca1", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n         }\n \n         if_chain! {\n-            if let ExprKind::If(cond, then, _) = &expr.kind;\n+            if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n             if let ExprKind::MethodCall(_, _, [target_arg, pattern], _) = cond.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n             if let ExprKind::Path(target_path) = &target_arg.kind;\n@@ -212,7 +212,7 @@ fn find_stripping<'tcx>(\n                 if is_ref_str(self.cx, ex);\n                 let unref = peel_ref(ex);\n                 if let ExprKind::Index(indexed, index) = &unref.kind;\n-                if let Some(higher::Range { start, end, .. }) = higher::range(index);\n+                if let Some(higher::Range { start, end, .. }) = higher::Range::hir(index);\n                 if let ExprKind::Path(path) = &indexed.kind;\n                 if self.cx.qpath_res(path, ex.hir_id) == self.target;\n                 then {"}, {"sha": "2f1ff567e844f803c7e4f8930aefd1a5f1187eda", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 171, "deletions": 106, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -2,18 +2,21 @@ use clippy_utils::consts::{constant, miri_to_const, Constant};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n+use clippy_utils::higher;\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n-    get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_wild, meets_msrv, msrvs,\n-    path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks,\n-    strip_pat_refs,\n+    get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild,\n+    meets_msrv, msrvs, path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n+    remove_blocks, strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n+use core::array;\n+use core::iter::{once, ExactSizeIterator};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n+use rustc_ast::ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -629,7 +632,10 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             }\n         }\n         if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            check_match_ref_pats(cx, ex, arms, expr);\n+            check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n+        }\n+        if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr) {\n+            check_match_ref_pats(cx, let_expr, once(let_pat), expr);\n         }\n     }\n \n@@ -1177,39 +1183,40 @@ fn is_panic_block(block: &Block<'_>) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if has_only_ref_pats(arms) {\n-        let mut suggs = Vec::with_capacity(arms.len() + 1);\n-        let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n-            let span = ex.span.source_callsite();\n-            suggs.push((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n-            (\n-                \"you don't need to add `&` to both the expression and the patterns\",\n-                \"try\",\n-            )\n-        } else {\n-            let span = ex.span.source_callsite();\n-            suggs.push((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n-            (\n-                \"you don't need to add `&` to all patterns\",\n-                \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n-            )\n-        };\n-\n-        suggs.extend(arms.iter().filter_map(|a| {\n-            if let PatKind::Ref(refp, _) = a.pat.kind {\n-                Some((a.pat.span, snippet(cx, refp.span, \"..\").to_string()))\n-            } else {\n-                None\n-            }\n-        }));\n+fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n+where\n+    'b: 'a,\n+    I: Clone + Iterator<Item = &'a Pat<'b>>,\n+{\n+    if !has_only_ref_pats(pats.clone()) {\n+        return;\n+    }\n \n-        span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n-            if !expr.span.from_expansion() {\n-                multispan_sugg(diag, msg, suggs);\n-            }\n-        });\n+    let (first_sugg, msg, title);\n+    let span = ex.span.source_callsite();\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n+        msg = \"try\";\n+        title = \"you don't need to add `&` to both the expression and the patterns\";\n+    } else {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n+        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n+        title = \"you don't need to add `&` to all patterns\";\n     }\n+\n+    let remaining_suggs = pats.filter_map(|pat| {\n+        if let PatKind::Ref(refp, _) = pat.kind {\n+            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n+        if !expr.span.from_expansion() {\n+            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n+        }\n+    });\n }\n \n fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n@@ -1284,46 +1291,99 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n-        match match_source {\n-            MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n-            MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n-            _ => false,\n-        }\n-    } else {\n-        false\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        return find_matches_sugg(\n+            cx,\n+            let_expr,\n+            array::IntoIter::new([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n+            expr,\n+            true,\n+        );\n     }\n+\n+    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n+        return find_matches_sugg(\n+            cx,\n+            scrut,\n+            arms.iter().map(|arm| {\n+                (\n+                    cx.tcx.hir().attrs(arm.hir_id),\n+                    Some(arm.pat),\n+                    arm.body,\n+                    arm.guard.as_ref(),\n+                )\n+            }),\n+            expr,\n+            false,\n+        );\n+    }\n+\n+    false\n }\n \n-/// Lint a `match` or desugared `if let` for replacement by `matches!`\n-fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) -> bool {\n+/// Lint a `match` or `if let` for replacement by `matches!`\n+fn find_matches_sugg<'a, 'b, I>(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    mut iter: I,\n+    expr: &Expr<'_>,\n+    is_if_let: bool,\n+) -> bool\n+where\n+    'b: 'a,\n+    I: Clone\n+        + DoubleEndedIterator\n+        + ExactSizeIterator\n+        + Iterator<\n+            Item = (\n+                &'a [Attribute],\n+                Option<&'a Pat<'b>>,\n+                &'a Expr<'b>,\n+                Option<&'a Guard<'b>>,\n+            ),\n+        >,\n+{\n     if_chain! {\n-        if arms.len() >= 2;\n+        if iter.len() >= 2;\n         if cx.typeck_results().expr_ty(expr).is_bool();\n-        if let Some((b1_arm, b0_arms)) = arms.split_last();\n-        if let Some(b0) = find_bool_lit(&b0_arms[0].body.kind, desugared);\n-        if let Some(b1) = find_bool_lit(&b1_arm.body.kind, desugared);\n-        if is_wild(b1_arm.pat);\n+        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n+        let iter_without_last = iter.clone();\n+        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n+        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n+        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n         if b0 != b1;\n-        let if_guard = &b0_arms[0].guard;\n-        if if_guard.is_none() || b0_arms.len() == 1;\n-        if cx.tcx.hir().attrs(b0_arms[0].hir_id).is_empty();\n-        if b0_arms[1..].iter()\n+        if first_guard.is_none() || iter.len() == 0;\n+        if first_attrs.is_empty();\n+        if iter\n             .all(|arm| {\n-                find_bool_lit(&arm.body.kind, desugared).map_or(false, |b| b == b0) &&\n-                arm.guard.is_none() && cx.tcx.hir().attrs(arm.hir_id).is_empty()\n+                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n             });\n         then {\n+            if let Some(last_pat) = last_pat_opt {\n+                if !is_wild(last_pat) {\n+                    return false;\n+                }\n+            }\n+\n             // The suggestion may be incorrect, because some arms can have `cfg` attributes\n             // evaluated into `false` and so such arms will be stripped before.\n             let mut applicability = Applicability::MaybeIncorrect;\n             let pat = {\n                 use itertools::Itertools as _;\n-                b0_arms.iter()\n-                    .map(|arm| snippet_with_applicability(cx, arm.pat.span, \"..\", &mut applicability))\n+                iter_without_last\n+                    .filter_map(|arm| {\n+                        let pat_span = arm.1?.span;\n+                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n+                    })\n                     .join(\" | \")\n             };\n-            let pat_and_guard = if let Some(Guard::If(g)) = if_guard {\n+            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n                 format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n             } else {\n                 pat\n@@ -1340,7 +1400,7 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n                 cx,\n                 MATCH_LIKE_MATCHES_MACRO,\n                 expr.span,\n-                &format!(\"{} expression looks like `matches!` macro\", if desugared { \"if let .. else\" } else { \"match\" }),\n+                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n                 \"try this\",\n                 format!(\n                     \"{}matches!({}, {})\",\n@@ -1358,7 +1418,7 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n }\n \n /// Extract a `bool` or `{ bool }`\n-fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n+fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n     match ex {\n         ExprKind::Lit(Spanned {\n             node: LitKind::Bool(b), ..\n@@ -1370,7 +1430,7 @@ fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n                 ..\n             },\n             _,\n-        ) if desugared => {\n+        ) if is_if_let => {\n             if let ExprKind::Lit(Spanned {\n                 node: LitKind::Bool(b), ..\n             }) = exp.kind\n@@ -1610,14 +1670,6 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n         .collect()\n }\n \n-fn is_unit_expr(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Tup(v) if v.is_empty() => true,\n-        ExprKind::Block(b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n-        _ => false,\n-    }\n-}\n-\n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n@@ -1642,19 +1694,26 @@ fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotat\n     None\n }\n \n-fn has_only_ref_pats(arms: &[Arm<'_>]) -> bool {\n-    let mapped = arms\n-        .iter()\n-        .map(|a| {\n-            match a.pat.kind {\n-                PatKind::Ref(..) => Some(true), // &-patterns\n-                PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-                _ => None,                      // any other pattern is not fine\n+fn has_only_ref_pats<'a, 'b, I>(pats: I) -> bool\n+where\n+    'b: 'a,\n+    I: Iterator<Item = &'a Pat<'b>>,\n+{\n+    let mut at_least_one_is_true = false;\n+    for opt in pats.map(|pat| match pat.kind {\n+        PatKind::Ref(..) => Some(true), // &-patterns\n+        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+        _ => None,                      // any other pattern is not fine\n+    }) {\n+        if let Some(inner) = opt {\n+            if inner {\n+                at_least_one_is_true = true;\n             }\n-        })\n-        .collect::<Option<Vec<bool>>>();\n-    // look for Some(v) where there's at least one true element\n-    mapped.map_or(false, |v| v.iter().any(|el| *el))\n+        } else {\n+            return false;\n+        }\n+    }\n+    at_least_one_is_true\n }\n \n pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n@@ -1743,6 +1802,7 @@ where\n mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n+    use clippy_utils::higher;\n     use clippy_utils::source::{snippet, snippet_with_applicability};\n     use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n     use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n@@ -1753,22 +1813,27 @@ mod redundant_pattern_match {\n     use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n     use rustc_hir::{\n         intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, PatKind, QPath,\n+        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath,\n     };\n     use rustc_lint::LateContext;\n     use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n     use rustc_span::sym;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n-            match match_source {\n-                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { contains_else_clause } => {\n-                    find_sugg_for_if_let(cx, expr, op, &arms[0], \"if\", *contains_else_clause);\n-                },\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, &arms[0], \"while\", false),\n-                _ => {},\n-            }\n+        if let Some(higher::IfLet {\n+            if_else,\n+            let_pat,\n+            let_expr,\n+            ..\n+        }) = higher::IfLet::hir(cx, expr)\n+        {\n+            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n+        }\n+        if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n+            find_sugg_for_match(cx, expr, op, arms);\n+        }\n+        if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n         }\n     }\n \n@@ -1922,18 +1987,18 @@ mod redundant_pattern_match {\n     fn find_sugg_for_if_let<'tcx>(\n         cx: &LateContext<'tcx>,\n         expr: &'tcx Expr<'_>,\n-        op: &'tcx Expr<'tcx>,\n-        arm: &Arm<'_>,\n+        let_pat: &Pat<'_>,\n+        let_expr: &'tcx Expr<'_>,\n         keyword: &'static str,\n         has_else: bool,\n     ) {\n         // also look inside refs\n-        let mut kind = &arm.pat.kind;\n+        let mut kind = &let_pat.kind;\n         // if we have &None for example, peel it so we can detect \"if let None = x\"\n         if let PatKind::Ref(inner, _mutability) = kind {\n             kind = &inner.kind;\n         }\n-        let op_ty = cx.typeck_results().expr_ty(op);\n+        let op_ty = cx.typeck_results().expr_ty(let_expr);\n         // Determine which function should be used, and the type contained by the corresponding\n         // variant.\n         let (good_method, inner_ty) = match kind {\n@@ -1987,38 +2052,38 @@ mod redundant_pattern_match {\n         // scrutinee would be, so they have to be considered as well.\n         // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n         // for the duration if body.\n-        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, op);\n+        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n \n         // check that `while_let_on_iterator` lint does not trigger\n         if_chain! {\n             if keyword == \"while\";\n-            if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n+            if let ExprKind::MethodCall(method_path, _, _, _) = let_expr.kind;\n             if method_path.ident.name == sym::next;\n-            if is_trait_method(cx, op, sym::Iterator);\n+            if is_trait_method(cx, let_expr, sym::Iterator);\n             then {\n                 return;\n             }\n         }\n \n-        let result_expr = match &op.kind {\n+        let result_expr = match &let_expr.kind {\n             ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-            _ => op,\n+            _ => let_expr,\n         };\n         span_lint_and_then(\n             cx,\n             REDUNDANT_PATTERN_MATCHING,\n-            arm.pat.span,\n+            let_pat.span,\n             &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n             |diag| {\n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                 let expr_span = expr.span;\n \n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 //                 ^^^\n                 let op_span = result_expr.span.source_callsite();\n \n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 // ^^^^^^^^^^^^^^^^^^^\n                 let span = expr_span.until(op_span.shrink_to_hi());\n "}, {"sha": "6954da67e32c0fe3ae940abcaedd1b93c14005af", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n     // since it is already covered by `&loops::ITER_NEXT_LOOP`\n     let mut parent_expr_opt = get_parent_expr(cx, expr);\n     while let Some(parent_expr) = parent_expr_opt {\n-        if higher::for_loop(parent_expr).is_some() {\n+        if higher::ForLoop::hir(parent_expr).is_some() {\n             return;\n         }\n         parent_expr_opt = get_parent_expr(cx, parent_expr);\n@@ -29,7 +29,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n         if_chain! {\n             if let hir::ExprKind::Index(caller_var, index_expr) = &caller_expr.kind;\n             if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n-                = higher::range(index_expr);\n+                = higher::Range::hir(index_expr);\n             if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n             if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n             then {"}, {"sha": "e89b2d295b92345f4f1173e0e19911c559cc3bca", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -2013,10 +2013,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             // walk the return type and check for Self (this does not check associated types)\n             if let Some(self_adt) = self_ty.ty_adt_def() {\n-                if contains_adt_constructor(ret_ty, self_adt) {\n+                if contains_adt_constructor(cx.tcx, ret_ty, self_adt) {\n                     return;\n                 }\n-            } else if contains_ty(ret_ty, self_ty) {\n+            } else if contains_ty(cx.tcx, ret_ty, self_ty) {\n                 return;\n             }\n \n@@ -2027,10 +2027,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n                         // walk the associated type and check for Self\n                         if let Some(self_adt) = self_ty.ty_adt_def() {\n-                            if contains_adt_constructor(projection_predicate.ty, self_adt) {\n+                            if contains_adt_constructor(cx.tcx, projection_predicate.ty, self_adt) {\n                                 return;\n                             }\n-                        } else if contains_ty(projection_predicate.ty, self_ty) {\n+                        } else if contains_ty(cx.tcx, projection_predicate.ty, self_ty) {\n                             return;\n                         }\n                     }\n@@ -2079,7 +2079,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id());\n             let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty();\n-            if !contains_ty(ret_ty, self_ty);\n+            if !contains_ty(cx.tcx, ret_ty, self_ty);\n \n             then {\n                 span_lint("}, {"sha": "55d2e29e8bc1e89886496ca2177db3e4d9f0587f", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -137,6 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             },\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Struct(..)"}, {"sha": "667cdd8302528caec005ef878d7a8f2087d50e70", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -118,6 +118,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             },\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Struct(..)"}, {"sha": "80a930d0c547b368460ba8e0e965261b1f7da7d9", "filename": "clippy_lints/src/module_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmodule_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmodule_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodule_style.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -80,7 +80,7 @@ impl EarlyLintPass for ModStyle {\n \n         let files = cx.sess.source_map().files();\n \n-        let trim_to_src = if let RealFileName::LocalPath(p) = &cx.sess.working_dir {\n+        let trim_to_src = if let RealFileName::LocalPath(p) = &cx.sess.opts.working_dir {\n             p.to_string_lossy()\n         } else {\n             return;"}, {"sha": "610152a217f1e3dac93028b9b41a945f37b92468", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        if let Some((_, arg, body, _)) = higher::for_loop(expr) {\n+        if let Some(higher::ForLoop { arg, body, .. }) = higher::ForLoop::hir(expr) {\n             // A `for` loop lowers to:\n             // ```rust\n             // match ::std::iter::Iterator::next(&mut iter) {"}, {"sha": "c9dd94400efb96163f0d01028cc92cb91eef4ecc", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **warn** by default\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{is_else_clause, is_expn_of};\n@@ -77,10 +78,15 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::If(pred, then_block, Some(else_expr)) = e.kind {\n+        if let Some(higher::If {\n+            cond,\n+            then,\n+            r#else: Some(r#else),\n+        }) = higher::If::hir(e)\n+        {\n             let reduce = |ret, not| {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let snip = Sugg::hir_with_applicability(cx, pred, \"<predicate>\", &mut applicability);\n+                let snip = Sugg::hir_with_applicability(cx, cond, \"<predicate>\", &mut applicability);\n                 let mut snip = if not { !snip } else { snip };\n \n                 if ret {\n@@ -101,8 +107,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     applicability,\n                 );\n             };\n-            if let ExprKind::Block(then_block, _) = then_block.kind {\n-                match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n+            if let ExprKind::Block(then, _) = then.kind {\n+                match (fetch_bool_block(then), fetch_bool_expr(r#else)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n                             cx,"}, {"sha": "90b2aa16896267b3fd66d06d739a34a202d88db4", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -117,11 +117,11 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n \n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds().iter())\n-            .filter(|p| !p.is_global())\n+            .filter(|p| !p.is_global(cx.tcx))\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n                 match obligation.predicate.kind().no_bound_vars() {\n-                    Some(ty::PredicateKind::Trait(pred, _)) if pred.def_id() != sized_trait => Some(pred),\n+                    Some(ty::PredicateKind::Trait(pred)) if pred.def_id() != sized_trait => Some(pred),\n                     _ => None,\n                 }\n             })"}, {"sha": "2a85a67fa099cac9355d26e61ca5bdada9387994", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -122,7 +122,7 @@ fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n     // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n     // 'unfrozen'. However, this code causes a false negative in which\n-    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n+    // a type contains a layout-unknown type, but also an unsafe cell like `const CELL: Cell<T>`.\n     // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n     // since it works when a pointer indirection involves (`Cell<*const T>`).\n     // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n@@ -187,11 +187,7 @@ fn is_value_unfrozen_expr<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId, def_id: D\n \n     let result = cx.tcx.const_eval_resolve(\n         cx.param_env,\n-        ty::Unevaluated {\n-            def: ty::WithOptConstParam::unknown(def_id),\n-            substs,\n-            promoted: None,\n-        },\n+        ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs),\n         None,\n     );\n     is_value_unfrozen_raw(cx, result, ty)\n@@ -266,7 +262,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                 // in other words, lint consts whose value *could* be unfrozen, not definitely is.\n                 // This feels inconsistent with how the lint treats generic types,\n                 // which avoids linting types which potentially become unfrozen.\n-                // One could check whether a unfrozen type have a *frozen variant*\n+                // One could check whether an unfrozen type have a *frozen variant*\n                 // (like `body_id_opt.map_or_else(|| !has_frozen_variant(...), ...)`),\n                 // and do the same as the case of generic types at impl items.\n                 // Note that it isn't sufficient to check if it has an enum\n@@ -293,7 +289,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                 }) => {\n                     if_chain! {\n                         // Lint a trait impl item only when the definition is a generic type,\n-                        // assuming a assoc const is not meant to be a interior mutable type.\n+                        // assuming an assoc const is not meant to be an interior mutable type.\n                         if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n                         if let Some(of_assoc_item) = specialization_graph::Node::Trait(of_trait_def_id)\n                             .item(cx.tcx, impl_item.ident, AssocKind::Const, of_trait_def_id);"}, {"sha": "2ffc00b449d08b7e9c25282579618b98ee233912", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -316,8 +316,11 @@ impl<'a, 'b> SimilarNamesLocalVisitor<'a, 'b> {\n \n impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n     fn visit_local(&mut self, local: &'tcx Local) {\n-        if let Some(ref init) = local.init {\n-            self.apply(|this| walk_expr(this, &**init));\n+        if let Some((init, els)) = &local.kind.init_else_opt() {\n+            self.apply(|this| walk_expr(this, init));\n+            if let Some(els) = els {\n+                self.apply(|this| walk_block(this, els));\n+            }\n         }\n         // add the pattern after the expression because the bindings aren't available\n         // yet in the init"}, {"sha": "15f6dcae8870b498563190acabdb263ff9e49e17", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n@@ -8,9 +9,7 @@ use clippy_utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, Path, QPath, UnOp,\n-};\n+use rustc_hir::{def::Res, BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -88,20 +87,20 @@ struct OptionIfLetElseOccurence {\n \n /// Extracts the body of a given arm. If the arm contains only an expression,\n /// then it returns the expression. Otherwise, it returns the entire block\n-fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n+fn extract_body_from_expr<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n     if let ExprKind::Block(\n         Block {\n-            stmts: statements,\n-            expr: Some(expr),\n+            stmts: block_stmts,\n+            expr: Some(block_expr),\n             ..\n         },\n         _,\n-    ) = &arm.body.kind\n+    ) = expr.kind\n     {\n-        if let [] = statements {\n-            Some(expr)\n+        if let [] = block_stmts {\n+            Some(block_expr)\n         } else {\n-            Some(arm.body)\n+            Some(expr)\n         }\n     } else {\n         None\n@@ -125,46 +124,43 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n /// If this expression is the option if let/else construct we're detecting, then\n /// this function returns an `OptionIfLetElseOccurence` struct with details if\n /// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else<'tcx>(\n-    cx: &'_ LateContext<'tcx>,\n-    expr: &'_ Expr<'tcx>,\n-) -> Option<OptionIfLetElseOccurence> {\n+fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n         if !in_constant(cx, expr.hir_id);\n-        if let ExprKind::Match(cond_expr, [some_arm, none_arm], MatchSource::IfLetDesugar{contains_else_clause: true})\n-            = &expr.kind;\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n+            = higher::IfLet::hir(cx, expr);\n         if !is_else_clause(cx.tcx, expr);\n-        if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n-        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &some_arm.pat.kind;\n+        if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n+        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if let Some(some_captures) = can_move_expr_to_closure(cx, some_arm.body);\n-        if let Some(none_captures) = can_move_expr_to_closure(cx, none_arm.body);\n+        if let Some(some_captures) = can_move_expr_to_closure(cx, if_then);\n+        if let Some(none_captures) = can_move_expr_to_closure(cx, if_else);\n         if some_captures\n             .iter()\n             .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n             .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n-            let some_body = extract_body_from_arm(some_arm)?;\n-            let none_body = extract_body_from_arm(none_arm)?;\n+            let some_body = extract_body_from_expr(if_then)?;\n+            let none_body = extract_body_from_expr(if_else)?;\n             let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) {\n                 \"map_or\"\n             } else {\n                 \"map_or_else\"\n             };\n             let capture_name = id.name.to_ident_string();\n-            let (as_ref, as_mut) = match &cond_expr.kind {\n+            let (as_ref, as_mut) = match &let_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n                 _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n             };\n-            let cond_expr = match &cond_expr.kind {\n+            let cond_expr = match let_expr.kind {\n                 // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n                 ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n-                _ => cond_expr,\n+                _ => let_expr,\n             };\n             // Check if captures the closure will need conflict with borrows made in the scrutinee.\n             // TODO: check all the references made in the scrutinee expression. This will require interacting"}, {"sha": "e7bc24465908b43851b87e2af2483e6ac7758028", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -104,22 +104,25 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(expr, arms, source) = expr.kind {\n-            match source {\n-                MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n-                    if let Some(expr_ty) = cx.typeck_results().node_type_opt(expr.hir_id) {\n-                        'pattern_checks: for arm in arms {\n-                            let pat = &arm.pat;\n-                            if in_external_macro(cx.sess(), pat.span) {\n-                                continue 'pattern_checks;\n-                            }\n-                            if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n-                                break 'pattern_checks;\n-                            }\n-                        }\n+        if let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = expr.kind {\n+            if let Some(expr_ty) = cx.typeck_results().node_type_opt(scrutinee.hir_id) {\n+                'pattern_checks: for arm in arms {\n+                    let pat = &arm.pat;\n+                    if in_external_macro(cx.sess(), pat.span) {\n+                        continue 'pattern_checks;\n                     }\n-                },\n-                _ => (),\n+                    if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n+                        break 'pattern_checks;\n+                    }\n+                }\n+            }\n+        }\n+        if let ExprKind::Let(let_pat, let_expr, _) = expr.kind {\n+            if let Some(expr_ty) = cx.typeck_results().node_type_opt(let_expr.hir_id) {\n+                if in_external_macro(cx.sess(), let_pat.span) {\n+                    return;\n+                }\n+                apply_lint(cx, let_pat, expr_ty, DerefPossible::Possible);\n             }\n         }\n     }"}, {"sha": "3258c9fb3fed0ef244813e52bf47f6d3a65f9722", "filename": "clippy_lints/src/ptr_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_eq.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -74,7 +74,7 @@ impl LateLintPass<'_> for PtrEq {\n     }\n }\n \n-// If the given expression is a cast to an usize, return the lhs of the cast\n+// If the given expression is a cast to a usize, return the lhs of the cast\n // E.g., `foo as *const _ as usize` returns `foo as *const _`.\n fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {"}, {"sha": "e79cd7ed4ec4a969c95a2c0db407735712130d81", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n@@ -7,7 +8,7 @@ use clippy_utils::{eq_expr_value, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -50,20 +51,20 @@ impl QuestionMark {\n     /// If it matches, it will suggest to use the question mark operator instead\n     fn check_is_none_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::If(if_expr, body, else_) = &expr.kind;\n-            if let ExprKind::MethodCall(segment, _, args, _) = &if_expr.kind;\n+            if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n+            if let ExprKind::MethodCall(segment, _, args, _) = &cond.kind;\n             if segment.ident.name == sym!(is_none);\n-            if Self::expression_returns_none(cx, body);\n+            if Self::expression_returns_none(cx, then);\n             if let Some(subject) = args.get(0);\n             if Self::is_option(cx, subject);\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n                 let mut replacement: Option<String> = None;\n-                if let Some(else_) = else_ {\n+                if let Some(else_inner) = r#else {\n                     if_chain! {\n-                        if let ExprKind::Block(block, None) = &else_.kind;\n+                        if let ExprKind::Block(block, None) = &else_inner.kind;\n                         if block.stmts.is_empty();\n                         if let Some(block_expr) = &block.expr;\n                         if eq_expr_value(cx, subject, block_expr);\n@@ -96,25 +97,24 @@ impl QuestionMark {\n \n     fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Match(subject, arms, source) = &expr.kind;\n-            if *source == MatchSource::IfLetDesugar { contains_else_clause: true };\n-            if Self::is_option(cx, subject);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n+                = higher::IfLet::hir(cx, expr);\n+            if Self::is_option(cx, let_expr);\n \n-            if let PatKind::TupleStruct(path1, fields, None) = &arms[0].pat.kind;\n+            if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n             if is_lang_ctor(cx, path1, OptionSome);\n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n \n-            if let ExprKind::Block(block, None) = &arms[0].body.kind;\n+            if let ExprKind::Block(block, None) = if_then.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n             if path_to_local_id(trailing_expr, bind_id);\n \n-            if let PatKind::Wild = arms[1].pat.kind;\n-            if Self::expression_returns_none(cx, arms[1].body);\n+            if Self::expression_returns_none(cx, if_else);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let receiver_str = snippet_with_applicability(cx, subject.span, \"..\", &mut applicability);\n+                let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n                 let replacement = format!(\n                     \"{}{}?\",\n                     receiver_str,"}, {"sha": "87364a88ed0dcc8267c6e955c64e83874ab38aaf", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -51,7 +51,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// Will add unnecessary pair of parentheses when the\n-    /// expression is not wrapped in a pair but starts with a opening parenthesis\n+    /// expression is not wrapped in a pair but starts with an opening parenthesis\n     /// and ends with a closing one.\n     /// I.e., `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n     ///\n@@ -329,7 +329,7 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         if let ExprKind::MethodCall(iter_path, _, iter_args, _) = iter.kind;\n         if iter_path.ident.name == sym::iter;\n         // range expression in `.zip()` call: `0..x.len()`\n-        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n         if let ExprKind::MethodCall(len_path, _, len_args, _) = end.kind;\n@@ -356,7 +356,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             start,\n             end: Some(end),\n             limits: RangeLimits::HalfOpen\n-        }) = higher::range(expr);\n+        }) = higher::Range::hir(expr);\n         if let Some(y) = y_plus_one(cx, end);\n         then {\n             let span = if expr.span.from_expansion() {\n@@ -401,7 +401,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n // inclusive range minus one: `x..=(y-1)`\n fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(expr);\n+        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::Range::hir(expr);\n         if let Some(y) = y_minus_one(cx, end);\n         then {\n             span_lint_and_then(\n@@ -438,8 +438,8 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     fn is_for_loop_arg(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         let mut cur_expr = expr;\n         while let Some(parent_expr) = get_parent_expr(cx, cur_expr) {\n-            match higher::for_loop(parent_expr) {\n-                Some((_, args, _, _)) if args.hir_id == expr.hir_id => return true,\n+            match higher::ForLoop::hir(parent_expr) {\n+                Some(higher::ForLoop { arg, .. }) if arg.hir_id == expr.hir_id => return true,\n                 _ => cur_expr = parent_expr,\n             }\n         }\n@@ -455,7 +455,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n \n     if_chain! {\n-        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(expr);\n+        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::Range::hir(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind();\n         if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);"}, {"sha": "cfa12ef3a321dd7ba04fbd992c819aaa24436ed7", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::mir::{\n     visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor as _},\n     Mutability,\n };\n-use rustc_middle::ty::{self, fold::TypeVisitor, Ty};\n+use rustc_middle::ty::{self, fold::TypeVisitor, Ty, TyCtxt};\n use rustc_mir::dataflow::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n@@ -576,7 +576,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                 self.possible_borrower.add(borrowed.local, lhs);\n             },\n             other => {\n-                if ContainsRegion\n+                if ContainsRegion(self.cx.tcx)\n                     .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n                     .is_continue()\n                 {\n@@ -625,7 +625,10 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                 .flat_map(HybridBitSet::iter)\n                 .collect();\n \n-            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_break() {\n+            if ContainsRegion(self.cx.tcx)\n+                .visit_ty(self.body.local_decls[*dest].ty)\n+                .is_break()\n+            {\n                 mutable_variables.push(*dest);\n             }\n \n@@ -701,12 +704,15 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleOriginVisitor<'a, 'tcx> {\n     }\n }\n \n-struct ContainsRegion;\n+struct ContainsRegion<'tcx>(TyCtxt<'tcx>);\n \n-impl TypeVisitor<'_> for ContainsRegion {\n+impl<'tcx> TypeVisitor<'tcx> for ContainsRegion<'tcx> {\n     type BreakTy = ();\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.0)\n+    }\n \n-    fn visit_region(&mut self, _: ty::Region<'_>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_region(&mut self, _: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         ControlFlow::BREAK\n     }\n }"}, {"sha": "90e3c3f4b3e98f78121f2d23f43bc4a1c89148f6", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -51,9 +51,7 @@ impl ReturnVisitor {\n \n impl<'ast> ast_visit::Visitor<'ast> for ReturnVisitor {\n     fn visit_expr(&mut self, ex: &'ast ast::Expr) {\n-        if let ast::ExprKind::Ret(_) = ex.kind {\n-            self.found_return = true;\n-        } else if let ast::ExprKind::Try(_) = ex.kind {\n+        if let ast::ExprKind::Ret(_) | ast::ExprKind::Try(_) = ex.kind {\n             self.found_return = true;\n         }\n "}, {"sha": "341b5a61631dff896fb93510799316fb6cb324a3", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -206,21 +206,10 @@ fn check_final_expr<'tcx>(\n         // an if/if let expr, check both exprs\n         // note, if without else is going to be a type checking error anyways\n         // (except for unit type functions) so we don't match it\n-        ExprKind::Match(_, arms, source) => match source {\n-            MatchSource::Normal => {\n-                for arm in arms.iter() {\n-                    check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Block);\n-                }\n-            },\n-            MatchSource::IfLetDesugar {\n-                contains_else_clause: true,\n-            } => {\n-                if let ExprKind::Block(ifblock, _) = arms[0].body.kind {\n-                    check_block_return(cx, ifblock);\n-                }\n-                check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n-            },\n-            _ => (),\n+        ExprKind::Match(_, arms, MatchSource::Normal) => {\n+            for arm in arms.iter() {\n+                check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Block);\n+            }\n         },\n         ExprKind::DropTemps(expr) => check_final_expr(cx, expr, None, RetReplacement::Empty),\n         _ => (),\n@@ -296,7 +285,7 @@ impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n                 .fn_sig(def_id)\n                 .output()\n                 .skip_binder()\n-                .walk()\n+                .walk(self.cx.tcx)\n                 .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n         }\n "}, {"sha": "4ba5e1a0f5357829f95fad45aec80029882e8b88", "filename": "clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -62,10 +62,10 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n \n         // Ensure method is constructor-like\n         if let Some(self_adt) = self_ty.ty_adt_def() {\n-            if !contains_adt_constructor(ret_ty, self_adt) {\n+            if !contains_adt_constructor(cx.tcx, ret_ty, self_adt) {\n                 return;\n             }\n-        } else if !contains_ty(ret_ty, self_ty) {\n+        } else if !contains_ty(cx.tcx, ret_ty, self_ty) {\n             return;\n         }\n "}, {"sha": "b9e317a3cfd03af73f46ea09bc2f6997936fb107", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -74,7 +74,7 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for bindings that shadow other bindings already in\n-    /// scope, either without a initialization or with one that does not even use\n+    /// scope, either without an initialization or with one that does not even use\n     /// the original value.\n     ///\n     /// ### Why is this bad?"}, {"sha": "44d5ff0b63ad51a5fd2c014f44969d2858644df8", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -588,7 +588,7 @@ fn ident_difference_expr_with_base_location(\n         | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n         | (While(_, _, _), While(_, _, _))\n         | (If(_, _, _), If(_, _, _))\n-        | (Let(_, _), Let(_, _))\n+        | (Let(_, _, _), Let(_, _, _))\n         | (Type(_, _), Type(_, _))\n         | (Cast(_, _), Cast(_, _))\n         | (Lit(_), Lit(_))"}, {"sha": "db0f412f2a18c8ebc5302fe2c6419c957d0a9a09", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -45,7 +45,7 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n     let mut preds = Vec::new();\n     for (pred, _) in generics.predicates {\n         if_chain! {\n-            if let PredicateKind::Trait(poly_trait_pred, _) = pred.kind().skip_binder();\n+            if let PredicateKind::Trait(poly_trait_pred) = pred.kind().skip_binder();\n             let trait_pred = cx.tcx.erase_late_bound_regions(pred.kind().rebind(poly_trait_pred));\n             if let Some(trait_def_id) = trait_id;\n             if trait_def_id == trait_pred.trait_ref.def_id;\n@@ -127,7 +127,7 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n                 then {\n                     let data = stmt.span.data();\n                     // Make a span out of the semicolon for the help message\n-                    Some((span, Some(Span::new(data.hi-BytePos(1), data.hi, data.ctxt))))\n+                    Some((span, Some(data.with_lo(data.hi-BytePos(1)))))\n                 } else {\n                     Some((span, None))\n                 }"}, {"sha": "61670fe124e36f54055be9a58e1465e51ecfd9b1", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -218,7 +218,10 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n \n fn expr_borrows(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    matches!(ty.kind(), ty::Ref(..)) || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n+    matches!(ty.kind(), ty::Ref(..))\n+        || ty\n+            .walk(cx.tcx)\n+            .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n impl LateLintPass<'_> for UnnecessarySortBy {"}, {"sha": "d6cf7190abb04959099378856509d1ad4cbe0ea0", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -67,7 +67,7 @@ impl EarlyLintPass for UnnestedOrPatterns {\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if meets_msrv(self.msrv.as_ref(), &msrvs::OR_PATTERNS) {\n-            if let ast::ExprKind::Let(pat, _) = &e.kind {\n+            if let ast::ExprKind::Let(pat, _, _) = &e.kind {\n                 lint_unnested_or_patterns(cx, pat);\n             }\n         }"}, {"sha": "f4808682b69279dc1e4445d7c00770c030748866", "filename": "clippy_lints/src/unused_async.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_async.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, FnHeader, HirId, IsAsync, Item, ItemKind, YieldSource};\n+use rustc_hir::{Body, Expr, ExprKind, FnDecl, FnHeader, HirId, IsAsync, YieldSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -57,11 +57,6 @@ impl<'a, 'tcx> Visitor<'tcx> for AsyncFnVisitor<'a, 'tcx> {\n }\n \n impl<'tcx> LateLintPass<'tcx> for UnusedAsync {\n-    fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n-        if let ItemKind::Trait(..) = item.kind {\n-            return;\n-        }\n-    }\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'tcx>,"}, {"sha": "bffd9f3612b0a978ffb6426b9fc3932bfb728f87", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{differing_macro_contexts, usage::is_potentially_mutated};\n use if_chain::if_chain;\n@@ -160,11 +161,11 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         if in_external_macro(self.cx.tcx.sess, expr.span) {\n             return;\n         }\n-        if let ExprKind::If(cond, then, els) = &expr.kind {\n+        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr) {\n             walk_expr(self, cond);\n             self.visit_branch(cond, then, false);\n-            if let Some(els) = els {\n-                self.visit_branch(cond, els, true);\n+            if let Some(else_inner) = r#else {\n+                self.visit_branch(cond, else_inner, true);\n             }\n         } else {\n             // find `unwrap[_err]()` calls:"}, {"sha": "9ae50e47ca4c59ce899e0472b635f7d0e493a925", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -170,7 +170,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 //\n                 // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n                 for (impl_hir_ty, trait_sem_ty) in impl_inputs_outputs.zip(trait_method_sig.inputs_and_output) {\n-                    if trait_sem_ty.walk().any(|inner| inner == self_ty.into()) {\n+                    if trait_sem_ty.walk(cx.tcx).any(|inner| inner == self_ty.into()) {\n                         let mut visitor = SkipTyCollector::default();\n                         visitor.visit_ty(impl_hir_ty);\n                         types_to_skip.extend(visitor.types_to_skip);"}, {"sha": "f93d7782e2511bd0ad666ca1e2e6a08440c1dac7", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -208,6 +208,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.kind\", self.current);\n         match expr.kind {\n+            ExprKind::Let(pat, expr, _) => {\n+                let let_pat = self.next(\"pat\");\n+                let let_expr = self.next(\"expr\");\n+                println!(\"    Let(ref {}, ref {}, _) = {};\", let_pat, let_expr, current);\n+                self.current = let_expr;\n+                self.visit_expr(expr);\n+                self.current = let_pat;\n+                self.visit_pat(pat);\n+            },\n             ExprKind::Box(inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);"}, {"sha": "881dc3219308b6128fa4e5fde30bc5fc8807366a", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -194,7 +194,7 @@ define_Conf! {\n     (enum_variant_name_threshold: u64 = 3),\n     /// Lint: LARGE_ENUM_VARIANT.\n     ///\n-    /// The maximum size of a enum's variant to avoid box suggestion\n+    /// The maximum size of an enum's variant to avoid box suggestion\n     (enum_variant_size_threshold: u64 = 200),\n     /// Lint: VERBOSE_BIT_MASK.\n     ///"}, {"sha": "43590cc786236f2640c751f69877b3ee4f96ca6b", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -66,28 +66,6 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n             hir::ImplItemKind::TyAlias(_) => println!(\"associated type\"),\n         }\n     }\n-    // fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n-    // hir::TraitItem) {\n-    // if !has_attr(&item.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n-    // fn check_variant(&mut self, cx: &LateContext<'tcx>, var: &'tcx\n-    // hir::Variant, _:\n-    // &hir::Generics) {\n-    // if !has_attr(&var.node.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n-    // fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx\n-    // hir::FieldDef) {\n-    // if !has_attr(&field.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !has_attr(cx.sess(), cx.tcx.hir().attrs(expr.hir_id)) {\n@@ -127,13 +105,6 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n             hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) => print_expr(cx, e, 0),\n         }\n     }\n-    // fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n-    // hir::ForeignItem) {\n-    // if !has_attr(&item.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n }\n \n fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n@@ -171,6 +142,10 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n+        hir::ExprKind::Let(pat, expr, _) => {\n+            print_pat(cx, pat, indent + 1);\n+            print_expr(cx, expr, indent + 1);\n+        },\n         hir::ExprKind::MethodCall(path, _, args, _) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n@@ -406,6 +381,13 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n             let item_ty = cx.tcx.type_of(did);\n             println!(\"function of type {:#?}\", item_ty);\n         },\n+        hir::ItemKind::Macro(ref macro_def) => {\n+            if macro_def.macro_rules {\n+                println!(\"macro introduced by `macro_rules!`\");\n+            } else {\n+                println!(\"macro introduced by `macro`\");\n+            }\n+        },\n         hir::ItemKind::Mod(..) => println!(\"module\"),\n         hir::ItemKind::ForeignMod { abi, .. } => println!(\"foreign module with abi: {}\", abi),\n         hir::ItemKind::GlobalAsm(asm) => println!(\"global asm: {:?}\", asm),"}, {"sha": "42d51272279e2f9a78754ab3d20e828d407f0b9e", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::higher;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n@@ -17,8 +18,8 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Block, Crate, Expr, ExprKind, HirId, Item, Local, MatchSource, MutTy, Mutability, Node, Path, Stmt,\n-    StmtKind, Ty, TyKind, UnOp,\n+    BinOpKind, Block, Crate, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind, Ty,\n+    TyKind, UnOp,\n };\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -1106,16 +1107,10 @@ impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        let (cond, then, els) = match expr.kind {\n-            ExprKind::If(cond, then, els) => (Some(cond), then, els.is_some()),\n-            ExprKind::Match(\n-                _,\n-                [arm, ..],\n-                MatchSource::IfLetDesugar {\n-                    contains_else_clause: els,\n-                },\n-            ) => (None, arm.body, els),\n-            _ => return,\n+        let (cond, then, els) = if let Some(higher::IfOrIfLet { cond, r#else, then }) = higher::IfOrIfLet::hir(expr) {\n+            (cond, then, r#else.is_some())\n+        } else {\n+            return;\n         };\n         let then_block = match then.kind {\n             ExprKind::Block(block, _) => block,\n@@ -1131,7 +1126,6 @@ impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n         };\n         // check for `if a && b;`\n         if_chain! {\n-            if let Some(cond) = cond;\n             if let ExprKind::Binary(op, _, _) = cond.kind;\n             if op.node == BinOpKind::And;\n             if cx.sess().source_map().is_multiline(cond.span);\n@@ -1166,9 +1160,7 @@ fn check_nested_if_chains(\n         _ => return,\n     };\n     if_chain! {\n-        if matches!(tail.kind,\n-            ExprKind::If(_, _, None)\n-            | ExprKind::Match(.., MatchSource::IfLetDesugar { contains_else_clause: false }));\n+        if let Some(higher::IfOrIfLet { r#else: None, .. }) = higher::IfOrIfLet::hir(tail);\n         let sm = cx.sess().source_map();\n         if head\n             .iter()"}, {"sha": "188d0419c3993c9589b872ece99c6ee2e575a7e8", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -786,8 +786,6 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityResolver<'a, 'hir> {\n             }\n         };\n \n-        // TODO xFrednet 2021-03-01: support function arguments?\n-\n         intravisit::walk_expr(self, expr);\n     }\n }"}, {"sha": "85ff292c53a4d22fe1bb18ed5b1396a1893d696c", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -50,16 +50,16 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n             if let ty::Slice(..) = ty.kind();\n             if let ExprKind::AddrOf(BorrowKind::Ref, mutability, addressee) = expr.kind;\n-            if let Some(vec_args) = higher::vec_macro(cx, addressee);\n+            if let Some(vec_args) = higher::VecArgs::hir(cx, addressee);\n             then {\n                 self.check_vec_macro(cx, &vec_args, mutability, expr.span);\n             }\n         }\n \n         // search for `for _ in vec![\u2026]`\n         if_chain! {\n-            if let Some((_, arg, _, _)) = higher::for_loop(expr);\n-            if let Some(vec_args) = higher::vec_macro(cx, arg);\n+            if let Some(higher::ForLoop { arg, .. }) = higher::ForLoop::hir(expr);\n+            if let Some(vec_args) = higher::VecArgs::hir(cx, arg);\n             if is_copy(cx, vec_type(cx.typeck_results().expr_ty_adjusted(arg)));\n             then {\n                 // report the error around the `vec!` not inside `<std macros>:`"}, {"sha": "85d1f65c51f0911aaf1ab76ffb36ce496a759536", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -299,7 +299,7 @@ impl EarlyLintPass for Write {\n                     let nl_span = match (dest, only_nl) {\n                         // Special case of `write!(buf, \"\\n\")`: Mark everything from the end of\n                         // `buf` for removal so no trailing comma [`writeln!(buf, )`] remains.\n-                        (Some(dest_expr), true) => Span::new(dest_expr.span.hi(), nl_span.hi(), nl_span.ctxt()),\n+                        (Some(dest_expr), true) => nl_span.with_lo(dest_expr.span.hi()),\n                         _ => nl_span,\n                     };\n                     span_lint_and_then("}, {"sha": "133f6c29f7d2162d6300eca8c3d96d9f61af97d4", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -158,7 +158,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n         (Lit(l), Lit(r)) => l.kind == r.kind,\n         (Cast(l, lt), Cast(r, rt)) | (Type(l, lt), Type(r, rt)) => eq_expr(l, r) && eq_ty(lt, rt),\n-        (Let(lp, le), Let(rp, re)) => eq_pat(lp, rp) && eq_expr(le, re),\n+        (Let(lp, le, _), Let(rp, re, _)) => eq_pat(lp, rp) && eq_expr(le, re),\n         (If(lc, lt, le), If(rc, rt, re)) => eq_expr(lc, rc) && eq_block(lt, rt) && eq_expr_opt(le, re),\n         (While(lc, lt, ll), While(rc, rt, rl)) => eq_label(ll, rl) && eq_expr(lc, rc) && eq_block(lt, rt),\n         (ForLoop(lp, li, lt, ll), ForLoop(rp, ri, rt, rl)) => {\n@@ -221,7 +221,7 @@ pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n         (Local(l), Local(r)) => {\n             eq_pat(&l.pat, &r.pat)\n                 && both(&l.ty, &r.ty, |l, r| eq_ty(l, r))\n-                && eq_expr_opt(&l.init, &r.init)\n+                && eq_local_kind(&l.kind, &r.kind)\n                 && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n         },\n         (Item(l), Item(r)) => eq_item(l, r, eq_item_kind),\n@@ -234,6 +234,16 @@ pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n     }\n }\n \n+pub fn eq_local_kind(l: &LocalKind, r: &LocalKind) -> bool {\n+    use LocalKind::*;\n+    match (l, r) {\n+        (Decl, Decl) => true,\n+        (Init(l), Init(r)) => eq_expr(l, r),\n+        (InitElse(li, le), InitElse(ri, re)) => eq_expr(li, ri) && eq_block(le, re),\n+        _ => false,\n+    }\n+}\n+\n pub fn eq_item<K>(l: &Item<K>, r: &Item<K>, mut eq_kind: impl FnMut(&K, &K) -> bool) -> bool {\n     eq_id(l.ident, r.ident)\n         && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))"}, {"sha": "8bf31807d55d1441d74e503a42e29334aee365f0", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n     }\n \n-    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n+    /// Lookup a possibly constant expression from an `ExprKind::Path`.\n     fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n         let res = self.typeck_results.qpath_res(qpath, id);\n         match res {\n@@ -346,11 +346,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     .tcx\n                     .const_eval_resolve(\n                         self.param_env,\n-                        ty::Unevaluated {\n-                            def: ty::WithOptConstParam::unknown(def_id),\n-                            substs,\n-                            promoted: None,\n-                        },\n+                        ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs),\n                         None,\n                     )\n                     .ok()"}, {"sha": "29e2559fc6d603d45a05b8d0e91b142095f23f57", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -60,6 +60,7 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n         | ExprKind::MethodCall(..)\n         | ExprKind::Binary(..)\n         | ExprKind::Unary(..)\n+        | ExprKind::Let(..)\n         | ExprKind::Cast(..)\n         | ExprKind::Type(..)\n         | ExprKind::DropTemps(..)"}, {"sha": "05a4a0143195080328d5d06788bb9d1bd75ffdc8", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 423, "deletions": 160, "changes": 583, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,148 +1,261 @@\n-//! This module contains functions for retrieve the original AST from lowered\n-//! `hir`.\n+//! This module contains functions that retrieves specifiec elements.\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n+use rustc_hir::{Arm, Block, BorrowKind, Expr, ExprKind, LoopSource, MatchSource, Node, Pat, StmtKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n-/// Represent a range akin to `ast::ExprKind::Range`.\n-#[derive(Debug, Copy, Clone)]\n-pub struct Range<'a> {\n-    /// The lower bound of the range, or `None` for ranges such as `..X`.\n-    pub start: Option<&'a hir::Expr<'a>>,\n-    /// The upper bound of the range, or `None` for ranges such as `X..`.\n-    pub end: Option<&'a hir::Expr<'a>>,\n-    /// Whether the interval is open or closed.\n-    pub limits: ast::RangeLimits,\n+/// The essential nodes of a desugared for loop as well as the entire span:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n+pub struct ForLoop<'tcx> {\n+    /// `for` loop item\n+    pub pat: &'tcx hir::Pat<'tcx>,\n+    /// `IntoIterator` argument\n+    pub arg: &'tcx hir::Expr<'tcx>,\n+    /// `for` loop body\n+    pub body: &'tcx hir::Expr<'tcx>,\n+    /// entire `for` loop span\n+    pub span: Span,\n }\n \n-/// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n-pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n-    /// Finds the field named `name` in the field. Always return `Some` for\n-    /// convenience.\n-    fn get_field<'c>(name: &str, fields: &'c [hir::ExprField<'_>]) -> Option<&'c hir::Expr<'c>> {\n-        let expr = &fields.iter().find(|field| field.ident.name.as_str() == name)?.expr;\n-\n-        Some(expr)\n+impl<'tcx> ForLoop<'tcx> {\n+    #[inline]\n+    /// Parses a desugared `for` loop\n+    pub fn hir(expr: &Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+            if let Some(first_arm) = arms.get(0);\n+            if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n+            if let Some(first_arg) = iterargs.get(0);\n+            if iterargs.len() == 1 && arms.len() == 1 && first_arm.guard.is_none();\n+            if let hir::ExprKind::Loop(block, ..) = first_arm.body.kind;\n+            if block.expr.is_none();\n+            if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n+            if let hir::StmtKind::Local(local) = let_stmt.kind;\n+            if let hir::StmtKind::Expr(body_expr) = body.kind;\n+            then {\n+                return Some(Self {\n+                    pat: &*local.pat,\n+                    arg: first_arg,\n+                    body: body_expr,\n+                    span: first_arm.span\n+                });\n+            }\n+        }\n+        None\n     }\n+}\n \n-    match expr.kind {\n-        hir::ExprKind::Call(path, args)\n-            if matches!(\n-                path.kind,\n-                hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n-            ) =>\n+/// An `if` expression without `DropTemps`\n+pub struct If<'hir> {\n+    /// `if` condition\n+    pub cond: &'hir Expr<'hir>,\n+    /// `if` then expression\n+    pub then: &'hir Expr<'hir>,\n+    /// `else` expression\n+    pub r#else: Option<&'hir Expr<'hir>>,\n+}\n+\n+impl<'hir> If<'hir> {\n+    #[inline]\n+    /// Parses an `if` expression\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(\n+            Expr {\n+                kind: ExprKind::DropTemps(cond),\n+                ..\n+            },\n+            then,\n+            r#else,\n+        ) = expr.kind\n         {\n-            Some(Range {\n-                start: Some(&args[0]),\n-                end: Some(&args[1]),\n-                limits: ast::RangeLimits::Closed,\n-            })\n-        },\n-        hir::ExprKind::Struct(path, fields, None) => match path {\n-            hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n-                start: None,\n-                end: None,\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n-                start: Some(get_field(\"start\", fields)?),\n-                end: None,\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n-                start: Some(get_field(\"start\", fields)?),\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n-                start: None,\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::Closed,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n-                start: None,\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            _ => None,\n-        },\n-        _ => None,\n+            Some(Self { cond, then, r#else })\n+        } else {\n+            None\n+        }\n     }\n }\n \n-/// Checks if a `let` statement is from a `for` loop desugaring.\n-pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n-    // This will detect plain for-loops without an actual variable binding:\n-    //\n-    // ```\n-    // for x in some_vec {\n-    //     // do stuff\n-    // }\n-    // ```\n-    if_chain! {\n-        if let Some(expr) = local.init;\n-        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        then {\n-            return true;\n+/// An `if let` expression\n+pub struct IfLet<'hir> {\n+    /// `if let` pattern\n+    pub let_pat: &'hir Pat<'hir>,\n+    /// `if let` scrutinee\n+    pub let_expr: &'hir Expr<'hir>,\n+    /// `if let` then expression\n+    pub if_then: &'hir Expr<'hir>,\n+    /// `if let` else expression\n+    pub if_else: Option<&'hir Expr<'hir>>,\n+}\n+\n+impl<'hir> IfLet<'hir> {\n+    /// Parses an `if let` expression\n+    pub fn hir(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(\n+            Expr {\n+                kind: ExprKind::Let(let_pat, let_expr, _),\n+                ..\n+            },\n+            if_then,\n+            if_else,\n+        ) = expr.kind\n+        {\n+            let hir = cx.tcx.hir();\n+            let mut iter = hir.parent_iter(expr.hir_id);\n+            if let Some((_, Node::Block(Block { stmts: [], .. }))) = iter.next() {\n+                if let Some((\n+                    _,\n+                    Node::Expr(Expr {\n+                        kind: ExprKind::Loop(_, _, LoopSource::While, _),\n+                        ..\n+                    }),\n+                )) = iter.next()\n+                {\n+                    // while loop desugar\n+                    return None;\n+                }\n+            }\n+            return Some(Self {\n+                let_pat,\n+                let_expr,\n+                if_then,\n+                if_else,\n+            });\n         }\n+        None\n     }\n+}\n \n-    // This detects a variable binding in for loop to avoid `let_unit_value`\n-    // lint (see issue #1964).\n-    //\n-    // ```\n-    // for _ in vec![()] {\n-    //     // anything\n-    // }\n-    // ```\n-    if let hir::LocalSource::ForLoopDesugar = local.source {\n-        return true;\n+/// An `if let` or `match` expression. Useful for lints that trigger on one or the other.\n+pub enum IfLetOrMatch<'hir> {\n+    /// Any `match` expression\n+    Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n+    /// scrutinee, pattern, then block, else block\n+    IfLet(\n+        &'hir Expr<'hir>,\n+        &'hir Pat<'hir>,\n+        &'hir Expr<'hir>,\n+        Option<&'hir Expr<'hir>>,\n+    ),\n+}\n+\n+impl<'hir> IfLetOrMatch<'hir> {\n+    /// Parses an `if let` or `match` expression\n+    pub fn parse(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n+        match expr.kind {\n+            ExprKind::Match(expr, arms, source) => Some(Self::Match(expr, arms, source)),\n+            _ => IfLet::hir(cx, expr).map(\n+                |IfLet {\n+                     let_expr,\n+                     let_pat,\n+                     if_then,\n+                     if_else,\n+                 }| { Self::IfLet(let_expr, let_pat, if_then, if_else) },\n+            ),\n+        }\n     }\n+}\n \n-    false\n+/// An `if` or `if let` expression\n+pub struct IfOrIfLet<'hir> {\n+    /// `if` condition that is maybe a `let` expression\n+    pub cond: &'hir Expr<'hir>,\n+    /// `if` then expression\n+    pub then: &'hir Expr<'hir>,\n+    /// `else` expression\n+    pub r#else: Option<&'hir Expr<'hir>>,\n }\n \n-/// Recover the essential nodes of a desugared for loop as well as the entire span:\n-/// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n-pub fn for_loop<'tcx>(\n-    expr: &'tcx hir::Expr<'tcx>,\n-) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>, Span)> {\n-    if_chain! {\n-        if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n-        if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprKind::Loop(block, ..) = arms[0].body.kind;\n-        if block.expr.is_none();\n-        if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-        if let hir::StmtKind::Local(local) = let_stmt.kind;\n-        if let hir::StmtKind::Expr(expr) = body.kind;\n-        then {\n-            return Some((&*local.pat, &iterargs[0], expr, arms[0].span));\n+impl<'hir> IfOrIfLet<'hir> {\n+    #[inline]\n+    /// Parses an `if` or `if let` expression\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(cond, then, r#else) = expr.kind {\n+            if let ExprKind::DropTemps(new_cond) = cond.kind {\n+                return Some(Self {\n+                    cond: new_cond,\n+                    r#else,\n+                    then,\n+                });\n+            }\n+            if let ExprKind::Let(..) = cond.kind {\n+                return Some(Self { cond, then, r#else });\n+            }\n         }\n+        None\n     }\n-    None\n }\n \n-/// Recover the essential nodes of a desugared while loop:\n-/// `while cond { body }` becomes `(cond, body)`.\n-pub fn while_loop<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n-    if_chain! {\n-        if let hir::ExprKind::Loop(hir::Block { expr: Some(expr), .. }, _, hir::LoopSource::While, _) = &expr.kind;\n-        if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.kind;\n-        if let hir::ExprKind::DropTemps(cond) = &cond.kind;\n-        if let [hir::Arm { body, .. }, ..] = &arms[..];\n-        then {\n-            return Some((cond, body));\n+/// Represent a range akin to `ast::ExprKind::Range`.\n+#[derive(Debug, Copy, Clone)]\n+pub struct Range<'a> {\n+    /// The lower bound of the range, or `None` for ranges such as `..X`.\n+    pub start: Option<&'a hir::Expr<'a>>,\n+    /// The upper bound of the range, or `None` for ranges such as `X..`.\n+    pub end: Option<&'a hir::Expr<'a>>,\n+    /// Whether the interval is open or closed.\n+    pub limits: ast::RangeLimits,\n+}\n+\n+impl<'a> Range<'a> {\n+    /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n+    pub fn hir(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n+        /// Finds the field named `name` in the field. Always return `Some` for\n+        /// convenience.\n+        fn get_field<'c>(name: &str, fields: &'c [hir::ExprField<'_>]) -> Option<&'c hir::Expr<'c>> {\n+            let expr = &fields.iter().find(|field| field.ident.name.as_str() == name)?.expr;\n+            Some(expr)\n+        }\n+\n+        match expr.kind {\n+            hir::ExprKind::Call(path, args)\n+                if matches!(\n+                    path.kind,\n+                    hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n+                ) =>\n+            {\n+                Some(Range {\n+                    start: Some(&args[0]),\n+                    end: Some(&args[1]),\n+                    limits: ast::RangeLimits::Closed,\n+                })\n+            },\n+            hir::ExprKind::Struct(path, fields, None) => match &path {\n+                hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n+                    start: None,\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n+                    start: None,\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::Closed,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n+                    start: None,\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                _ => None,\n+            },\n+            _ => None,\n         }\n     }\n-    None\n }\n \n /// Represent the pre-expansion arguments of a `vec!` invocation.\n@@ -153,41 +266,154 @@ pub enum VecArgs<'a> {\n     Vec(&'a [hir::Expr<'a>]),\n }\n \n-/// Returns the arguments of the `vec!` macro if this expression was expanded\n-/// from `vec!`.\n-pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<VecArgs<'e>> {\n-    if_chain! {\n-        if let hir::ExprKind::Call(fun, args) = expr.kind;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if is_expn_of(fun.span, \"vec\").is_some();\n-        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n-        then {\n-            return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n-                // `vec![elem; size]` case\n-                Some(VecArgs::Repeat(&args[0], &args[1]))\n-            }\n-            else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n-                // `vec![a, b, c]` case\n-                if_chain! {\n-                    if let hir::ExprKind::Box(boxed) = args[0].kind;\n-                    if let hir::ExprKind::Array(args) = boxed.kind;\n-                    then {\n-                        return Some(VecArgs::Vec(&*args));\n-                    }\n+impl<'a> VecArgs<'a> {\n+    /// Returns the arguments of the `vec!` macro if this expression was expanded\n+    /// from `vec!`.\n+    pub fn hir(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) -> Option<VecArgs<'a>> {\n+        if_chain! {\n+            if let hir::ExprKind::Call(fun, args) = expr.kind;\n+            if let hir::ExprKind::Path(ref qpath) = fun.kind;\n+            if is_expn_of(fun.span, \"vec\").is_some();\n+            if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n+            then {\n+                return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+                    // `vec![elem; size]` case\n+                    Some(VecArgs::Repeat(&args[0], &args[1]))\n                 }\n+                else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n+                    // `vec![a, b, c]` case\n+                    if_chain! {\n+                        if let hir::ExprKind::Box(boxed) = args[0].kind;\n+                        if let hir::ExprKind::Array(args) = boxed.kind;\n+                        then {\n+                            return Some(VecArgs::Vec(args));\n+                        }\n+                    }\n \n-                None\n-            }\n-            else if match_def_path(cx, fun_def_id, &paths::VEC_NEW) && args.is_empty() {\n-                Some(VecArgs::Vec(&[]))\n+                    None\n+                }\n+                else if match_def_path(cx, fun_def_id, &paths::VEC_NEW) && args.is_empty() {\n+                    Some(VecArgs::Vec(&[]))\n+                }\n+                else {\n+                    None\n+                };\n             }\n-            else {\n-                None\n-            };\n         }\n+\n+        None\n     }\n+}\n \n-    None\n+/// A desugared `while` loop\n+pub struct While<'hir> {\n+    /// `while` loop condition\n+    pub condition: &'hir Expr<'hir>,\n+    /// `while` loop body\n+    pub body: &'hir Expr<'hir>,\n+}\n+\n+impl<'hir> While<'hir> {\n+    #[inline]\n+    /// Parses a desugared `while` loop\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::Loop(\n+            Block {\n+                expr:\n+                    Some(Expr {\n+                        kind:\n+                            ExprKind::If(\n+                                Expr {\n+                                    kind: ExprKind::DropTemps(condition),\n+                                    ..\n+                                },\n+                                body,\n+                                _,\n+                            ),\n+                        ..\n+                    }),\n+                ..\n+            },\n+            _,\n+            LoopSource::While,\n+            _,\n+        ) = expr.kind\n+        {\n+            return Some(Self { condition, body });\n+        }\n+        None\n+    }\n+}\n+\n+/// A desugared `while let` loop\n+pub struct WhileLet<'hir> {\n+    /// `while let` loop item pattern\n+    pub let_pat: &'hir Pat<'hir>,\n+    /// `while let` loop scrutinee\n+    pub let_expr: &'hir Expr<'hir>,\n+    /// `while let` loop body\n+    pub if_then: &'hir Expr<'hir>,\n+}\n+\n+impl<'hir> WhileLet<'hir> {\n+    #[inline]\n+    /// Parses a desugared `while let` loop\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::Loop(\n+            Block {\n+                expr:\n+                    Some(Expr {\n+                        kind:\n+                            ExprKind::If(\n+                                Expr {\n+                                    kind: ExprKind::Let(let_pat, let_expr, _),\n+                                    ..\n+                                },\n+                                if_then,\n+                                _,\n+                            ),\n+                        ..\n+                    }),\n+                ..\n+            },\n+            _,\n+            LoopSource::While,\n+            _,\n+        ) = expr.kind\n+        {\n+            return Some(Self {\n+                let_pat,\n+                let_expr,\n+                if_then,\n+            });\n+        }\n+        None\n+    }\n+}\n+\n+/// Converts a hir binary operator to the corresponding `ast` type.\n+#[must_use]\n+pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n+    match op {\n+        hir::BinOpKind::Eq => ast::BinOpKind::Eq,\n+        hir::BinOpKind::Ge => ast::BinOpKind::Ge,\n+        hir::BinOpKind::Gt => ast::BinOpKind::Gt,\n+        hir::BinOpKind::Le => ast::BinOpKind::Le,\n+        hir::BinOpKind::Lt => ast::BinOpKind::Lt,\n+        hir::BinOpKind::Ne => ast::BinOpKind::Ne,\n+        hir::BinOpKind::Or => ast::BinOpKind::Or,\n+        hir::BinOpKind::Add => ast::BinOpKind::Add,\n+        hir::BinOpKind::And => ast::BinOpKind::And,\n+        hir::BinOpKind::BitAnd => ast::BinOpKind::BitAnd,\n+        hir::BinOpKind::BitOr => ast::BinOpKind::BitOr,\n+        hir::BinOpKind::BitXor => ast::BinOpKind::BitXor,\n+        hir::BinOpKind::Div => ast::BinOpKind::Div,\n+        hir::BinOpKind::Mul => ast::BinOpKind::Mul,\n+        hir::BinOpKind::Rem => ast::BinOpKind::Rem,\n+        hir::BinOpKind::Shl => ast::BinOpKind::Shl,\n+        hir::BinOpKind::Shr => ast::BinOpKind::Shr,\n+        hir::BinOpKind::Sub => ast::BinOpKind::Sub,\n+    }\n }\n \n /// Extract args from an assert-like macro.\n@@ -218,8 +444,8 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n             if let StmtKind::Semi(matchexpr) = block.stmts.get(0)?.kind {\n                 // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n                 if_chain! {\n-                    if let ExprKind::If(clause, _, _)  = matchexpr.kind;\n-                    if let ExprKind::Unary(UnOp::Not, condition) = clause.kind;\n+                    if let Some(If { cond, .. }) = If::hir(matchexpr);\n+                    if let ExprKind::Unary(UnOp::Not, condition) = cond.kind;\n                     then {\n                         return Some(vec![condition]);\n                     }\n@@ -298,12 +524,28 @@ impl FormatArgsExpn<'tcx> {\n             if let ExpnKind::Macro(_, name) = expr.span.ctxt().outer_expn_data().kind;\n             let name = name.as_str();\n             if name.ends_with(\"format_args\") || name.ends_with(\"format_args_nl\");\n-            if let ExprKind::Call(_, args) = expr.kind;\n-            if let Some((strs_ref, args, fmt_expr)) = match args {\n+\n+            if let ExprKind::Match(inner_match, [arm], _) = expr.kind;\n+\n+            // `match match`, if you will\n+            if let ExprKind::Match(args, [inner_arm], _) = inner_match.kind;\n+            if let ExprKind::Tup(value_args) = args.kind;\n+            if let Some(value_args) = value_args\n+                .iter()\n+                .map(|e| match e.kind {\n+                    ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                })\n+                .collect();\n+            if let ExprKind::Array(args) = inner_arm.body.kind;\n+\n+            if let ExprKind::Block(Block { stmts: [], expr: Some(expr), .. }, _) = arm.body.kind;\n+            if let ExprKind::Call(_, call_args) = expr.kind;\n+            if let Some((strs_ref, fmt_expr)) = match call_args {\n                 // Arguments::new_v1\n-                [strs_ref, args] => Some((strs_ref, args, None)),\n+                [strs_ref, _] => Some((strs_ref, None)),\n                 // Arguments::new_v1_formatted\n-                [strs_ref, args, fmt_expr] => Some((strs_ref, args, Some(fmt_expr))),\n+                [strs_ref, _, fmt_expr] => Some((strs_ref, Some(fmt_expr))),\n                 _ => None,\n             };\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, strs_arr) = strs_ref.kind;\n@@ -319,17 +561,6 @@ impl FormatArgsExpn<'tcx> {\n                     None\n                 })\n                 .collect();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args.kind;\n-            if let ExprKind::Match(args, [arm], _) = args.kind;\n-            if let ExprKind::Tup(value_args) = args.kind;\n-            if let Some(value_args) = value_args\n-                .iter()\n-                .map(|e| match e.kind {\n-                    ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                })\n-                .collect();\n-            if let ExprKind::Array(args) = arm.body.kind;\n             then {\n                 Some(FormatArgsExpn {\n                     format_string_span: strs_ref.span,\n@@ -345,3 +576,35 @@ impl FormatArgsExpn<'tcx> {\n         }\n     }\n }\n+\n+/// Checks if a `let` statement is from a `for` loop desugaring.\n+pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n+    // This will detect plain for-loops without an actual variable binding:\n+    //\n+    // ```\n+    // for x in some_vec {\n+    //     // do stuff\n+    // }\n+    // ```\n+    if_chain! {\n+        if let Some(expr) = local.init;\n+        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    // This detects a variable binding in for loop to avoid `let_unit_value`\n+    // lint (see issue #1964).\n+    //\n+    // ```\n+    // for _ in vec![()] {\n+    //     // anything\n+    // }\n+    // ```\n+    if let hir::LocalSource::ForLoopDesugar = local.source {\n+        return true;\n+    }\n+\n+    false\n+}"}, {"sha": "6e9a1de21eef5cb010d32f668a82565ba1713a35", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -232,6 +232,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::If(lc, lt, ref le), &ExprKind::If(rc, rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n+            (&ExprKind::Let(lp, le, _), &ExprKind::Let(rp, re, _)) => self.eq_pat(lp, rp) && self.eq_expr(le, re),\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n             (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n@@ -665,6 +666,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                 }\n             },\n+            ExprKind::Let(pat, expr, _) => {\n+                self.hash_expr(expr);\n+                self.hash_pat(pat);\n+            },\n             ExprKind::LlvmInlineAsm(..) | ExprKind::Err => {},\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);"}, {"sha": "40d7963a5e545152d0e7ebb0be5e1b782509187f", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -259,6 +259,20 @@ pub fn in_macro(span: Span) -> bool {\n     }\n }\n \n+pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n+    matches!(\n+        expr.kind,\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: None,\n+                ..\n+            },\n+            _\n+        ) | ExprKind::Tup([])\n+    )\n+}\n+\n /// Checks if given pattern is a wildcard (`_`)\n pub fn is_wild(pat: &Pat<'_>) -> bool {\n     matches!(pat.kind, PatKind::Wild)\n@@ -588,7 +602,7 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n /// For example, if `e` represents the `v[0].a.b[x]`\n /// this method will return a tuple, composed of a `Vec`\n /// containing the `Expr`s for `v[0], v[0].a, v[0].a.b, v[0].a.b[x]`\n-/// and a `Expr` for root of them, `v`\n+/// and an `Expr` for root of them, `v`\n fn projection_stack<'a, 'hir>(mut e: &'a Expr<'hir>) -> (Vec<&'a Expr<'hir>>, &'a Expr<'hir>) {\n     let mut result = vec![];\n     let root = loop {\n@@ -794,6 +808,13 @@ pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind\n                         capture_expr_ty = e;\n                     }\n                 },\n+                ExprKind::Let(pat, ..) => {\n+                    let mutability = match pat_capture_kind(cx, pat) {\n+                        CaptureKind::Value => Mutability::Not,\n+                        CaptureKind::Ref(m) => m,\n+                    };\n+                    return CaptureKind::Ref(mutability);\n+                },\n                 ExprKind::Match(_, arms, _) => {\n                     let mut mutability = Mutability::Not;\n                     for capture in arms.iter().map(|arm| pat_capture_kind(cx, arm.pat)) {\n@@ -1098,7 +1119,7 @@ fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n     let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n     let line_no = source_map_and_line.line;\n     let line_start = source_map_and_line.sf.lines[line_no];\n-    Span::new(line_start, span.hi(), span.ctxt())\n+    span.with_lo(line_start)\n }\n \n /// Gets the parent node, if any.\n@@ -1182,17 +1203,6 @@ pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     let map = tcx.hir();\n     let mut iter = map.parent_iter(expr.hir_id);\n     match iter.next() {\n-        Some((arm_id, Node::Arm(..))) => matches!(\n-            iter.next(),\n-            Some((\n-                _,\n-                Node::Expr(Expr {\n-                    kind: ExprKind::Match(_, [_, else_arm], MatchSource::IfLetDesugar { .. }),\n-                    ..\n-                })\n-            ))\n-            if else_arm.hir_id == arm_id\n-        ),\n         Some((\n             _,\n             Node::Expr(Expr {\n@@ -1591,15 +1601,15 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     let mut conds = Vec::new();\n     let mut blocks: Vec<&Block<'_>> = Vec::new();\n \n-    while let ExprKind::If(cond, then_expr, ref else_expr) = expr.kind {\n-        conds.push(cond);\n-        if let ExprKind::Block(block, _) = then_expr.kind {\n+    while let Some(higher::IfOrIfLet { cond, then, r#else }) = higher::IfOrIfLet::hir(expr) {\n+        conds.push(&*cond);\n+        if let ExprKind::Block(block, _) = then.kind {\n             blocks.push(block);\n         } else {\n             panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n-        if let Some(else_expr) = *else_expr {\n+        if let Some(else_expr) = r#else {\n             expr = else_expr;\n         } else {\n             break;\n@@ -1809,7 +1819,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n         .predicates_of(did)\n         .predicates\n         .iter()\n-        .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+        .filter_map(|(p, _)| if p.is_global(cx.tcx) { Some(*p) } else { None });\n     traits::impossible_predicates(\n         cx.tcx,\n         traits::elaborate_predicates(cx.tcx, predicates)\n@@ -1855,15 +1865,15 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<S\n     if is_primitive {\n         // if we have wrappers like Array, Slice or Tuple, print these\n         // and get the type enclosed in the slice ref\n-        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind() {\n+        match expr_type.peel_refs().walk(cx.tcx).nth(1).unwrap().expect_ty().kind() {\n             rustc_ty::Slice(..) => return Some(\"slice\".into()),\n             rustc_ty::Array(..) => return Some(\"array\".into()),\n             rustc_ty::Tuple(..) => return Some(\"tuple\".into()),\n             _ => {\n                 // is_recursively_primitive_type() should have taken care\n                 // of the rest and we can rely on the type that is found\n                 let refs_peeled = expr_type.peel_refs();\n-                return Some(refs_peeled.walk().last().unwrap().to_string());\n+                return Some(refs_peeled.walk(cx.tcx).last().unwrap().to_string());\n             },\n         }\n     }"}, {"sha": "6cb2bd7f6efba33928d8aae0c09aba3ccbd4071b", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -36,7 +36,8 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&Ru\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n-                ty::PredicateKind::Trait(pred, _) => {\n+                ty::PredicateKind::Coerce(_) => panic!(\"coerce predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::Trait(pred) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n@@ -85,7 +86,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&Ru\n }\n \n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n-    for arg in ty.walk() {\n+    for arg in ty.walk(tcx) {\n         let ty = match arg.unpack() {\n             GenericArgKind::Type(ty) => ty,\n "}, {"sha": "ab05a0b423853f245ca00b5d2f940383da0d8ef9", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -116,7 +116,7 @@ impl<'a> Sugg<'a> {\n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n     fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n-        if let Some(range) = higher::range(expr) {\n+        if let Some(range) = higher::Range::hir(expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,\n                 ast::RangeLimits::Closed => AssocOp::DotDotEq,\n@@ -128,6 +128,7 @@ impl<'a> Sugg<'a> {\n             hir::ExprKind::AddrOf(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::If(..)\n+            | hir::ExprKind::Let(..)\n             | hir::ExprKind::Closure(..)\n             | hir::ExprKind::Unary(..)\n             | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n@@ -328,7 +329,7 @@ fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n     }\n }\n \n-// Copied from the rust standart library, and then edited\n+/// Copied from the rust standard library, and then edited\n macro_rules! forward_binop_impls_to_ref {\n     (impl $imp:ident, $method:ident for $t:ty, type Output = $o:ty) => {\n         impl $imp<$t> for &$t {\n@@ -433,7 +434,7 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n         matches!(op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n-    /// Returns `true` if the operator is a arithmetic operator\n+    /// Returns `true` if the operator is an arithmetic operator\n     /// (i.e., `+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: AssocOp) -> bool {\n         matches!("}, {"sha": "7f7fbdc9f21423feea5d974733fa0a75e8ed2c85", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TypeFoldable, UintTy};\n+use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n use rustc_span::sym;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n@@ -36,17 +36,17 @@ pub fn can_partially_move_ty(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n /// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n-pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n-    ty.walk().any(|inner| match inner.unpack() {\n+pub fn contains_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, other_ty: Ty<'tcx>) -> bool {\n+    ty.walk(tcx).any(|inner| match inner.unpack() {\n         GenericArgKind::Type(inner_ty) => ty::TyS::same_type(other_ty, inner_ty),\n         GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n     })\n }\n \n /// Walks into `ty` and returns `true` if any inner type is an instance of the given adt\n /// constructor.\n-pub fn contains_adt_constructor(ty: Ty<'_>, adt: &AdtDef) -> bool {\n-    ty.walk().any(|inner| match inner.unpack() {\n+pub fn contains_adt_constructor<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, adt: &'tcx AdtDef) -> bool {\n+    ty.walk(tcx).any(|inner| match inner.unpack() {\n         GenericArgKind::Type(inner_ty) => inner_ty.ty_adt_def() == Some(adt),\n         GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n     })\n@@ -157,7 +157,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n                     if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n@@ -209,7 +209,7 @@ fn is_normalizable_helper<'tcx>(\n                         .iter()\n                         .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n                 }),\n-                _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n+                _ => ty.walk(cx.tcx).all(|generic_arg| match generic_arg.unpack() {\n                     GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n                         is_normalizable_helper(cx, param_env, inner_ty, cache)\n                     },"}, {"sha": "8b0563eda6d1dc2f7eb6bc18c3d150cb1a56f7ef", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-08-12\"\n+channel = \"nightly-2021-09-02\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "cdbde79b19ebf53f8db58975f6258a9bd13e6abc", "filename": "tests/ui/atomic_ordering_bool.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_bool.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,25 +0,0 @@\n-#![warn(clippy::invalid_atomic_ordering)]\n-\n-use std::sync::atomic::{AtomicBool, Ordering};\n-\n-fn main() {\n-    let x = AtomicBool::new(true);\n-\n-    // Allowed load ordering modes\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-\n-    // Disallowed load ordering modes\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    // Allowed store ordering modes\n-    x.store(false, Ordering::Release);\n-    x.store(false, Ordering::SeqCst);\n-    x.store(false, Ordering::Relaxed);\n-\n-    // Disallowed store ordering modes\n-    x.store(false, Ordering::Acquire);\n-    x.store(false, Ordering::AcqRel);\n-}"}, {"sha": "397b893aed96478901847e26a6b0ae032b57ca51", "filename": "tests/ui/atomic_ordering_bool.stderr", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_bool.stderr?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,35 +0,0 @@\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_bool.rs:14:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_bool.rs:15:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_bool.rs:23:20\n-   |\n-LL |     x.store(false, Ordering::Acquire);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_bool.rs:24:20\n-   |\n-LL |     x.store(false, Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "1ddc12f9ab21341b5c93998a2ab12136a09b6e9a", "filename": "tests/ui/atomic_ordering_exchange.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_exchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_exchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_exchange.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,45 +0,0 @@\n-#![warn(clippy::invalid_atomic_ordering)]\n-\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-fn main() {\n-    // `compare_exchange` (not weak) testing\n-    let x = AtomicUsize::new(0);\n-\n-    // Allowed ordering combos\n-    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Relaxed);\n-    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::Acquire);\n-    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::Relaxed);\n-    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Relaxed);\n-    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::Acquire);\n-    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::Relaxed);\n-    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::Relaxed);\n-    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::Acquire);\n-    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::SeqCst);\n-\n-    // AcqRel is always forbidden as a failure ordering\n-    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::AcqRel);\n-    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::AcqRel);\n-    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::AcqRel);\n-    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::AcqRel);\n-    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::AcqRel);\n-\n-    // Release is always forbidden as a failure ordering\n-    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Release);\n-    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::Release);\n-    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Release);\n-    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::Release);\n-    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::Release);\n-\n-    // Release success order forbids failure order of Acquire or SeqCst\n-    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Acquire);\n-    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::SeqCst);\n-\n-    // Relaxed success order also forbids failure order of Acquire or SeqCst\n-    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::SeqCst);\n-    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Acquire);\n-\n-    // Acquire/AcqRel forbids failure order of SeqCst\n-    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::SeqCst);\n-    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::SeqCst);\n-}"}, {"sha": "4b9bfef79748ce66008ee19963669a5c943c7c17", "filename": "tests/ui/atomic_ordering_exchange.stderr", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_exchange.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_exchange.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_exchange.stderr?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,131 +0,0 @@\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:21:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::AcqRel);\n-   |                                                         ^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:22:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::AcqRel);\n-   |                                                         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:23:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::AcqRel);\n-   |                                                         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:24:56\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::AcqRel);\n-   |                                                        ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:25:56\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::AcqRel);\n-   |                                                        ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:28:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Release);\n-   |                                                         ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:29:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::Release);\n-   |                                                         ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:30:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Release);\n-   |                                                         ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:31:56\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::Release);\n-   |                                                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:32:56\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::Release);\n-   |                                                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be stronger than the success ordering of `Release`\n-  --> $DIR/atomic_ordering_exchange.rs:35:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Acquire);\n-   |                                                         ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be stronger than the success ordering of `Release`\n-  --> $DIR/atomic_ordering_exchange.rs:36:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::SeqCst);\n-   |                                                         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be stronger than the success ordering of `Relaxed`\n-  --> $DIR/atomic_ordering_exchange.rs:39:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::SeqCst);\n-   |                                                         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be stronger than the success ordering of `Relaxed`\n-  --> $DIR/atomic_ordering_exchange.rs:40:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Acquire);\n-   |                                                         ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be stronger than the success ordering of `Acquire`\n-  --> $DIR/atomic_ordering_exchange.rs:43:57\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::SeqCst);\n-   |                                                         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange's failure ordering may not be stronger than the success ordering of `AcqRel`\n-  --> $DIR/atomic_ordering_exchange.rs:44:56\n-   |\n-LL |     let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::SeqCst);\n-   |                                                        ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: aborting due to 16 previous errors\n-"}, {"sha": "5906990250728851196101c3da284ba9c7faedd0", "filename": "tests/ui/atomic_ordering_exchange_weak.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_exchange_weak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_exchange_weak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_exchange_weak.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,47 +0,0 @@\n-#![warn(clippy::invalid_atomic_ordering)]\n-\n-use std::sync::atomic::{AtomicPtr, Ordering};\n-\n-fn main() {\n-    let ptr = &mut 5;\n-    let ptr2 = &mut 10;\n-    // `compare_exchange_weak` testing\n-    let x = AtomicPtr::new(ptr);\n-\n-    // Allowed ordering combos\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Relaxed);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Acquire, Ordering::Acquire);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Acquire, Ordering::Relaxed);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Release, Ordering::Relaxed);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::AcqRel, Ordering::Acquire);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::AcqRel, Ordering::Relaxed);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::Relaxed);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::Acquire);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::SeqCst);\n-\n-    // AcqRel is always forbidden as a failure ordering\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Relaxed, Ordering::AcqRel);\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Acquire, Ordering::AcqRel);\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::AcqRel);\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::AcqRel, Ordering::AcqRel);\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::SeqCst, Ordering::AcqRel);\n-\n-    // Release is always forbidden as a failure ordering\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Release);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Acquire, Ordering::Release);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Release, Ordering::Release);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::AcqRel, Ordering::Release);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::Release);\n-\n-    // Release success order forbids failure order of Acquire or SeqCst\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::Acquire);\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::SeqCst);\n-\n-    // Relaxed success order also forbids failure order of Acquire or SeqCst\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::SeqCst);\n-    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Acquire);\n-\n-    // Acquire/AcqRel forbids failure order of SeqCst\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Acquire, Ordering::SeqCst);\n-    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::AcqRel, Ordering::SeqCst);\n-}"}, {"sha": "de7026f3ffafa1ecdc9c1bc7ddcfdd1ae445a3da", "filename": "tests/ui/atomic_ordering_exchange_weak.stderr", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_exchange_weak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_exchange_weak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_exchange_weak.stderr?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,131 +0,0 @@\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:23:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Relaxed, Ordering::AcqRel);\n-   |                                                                   ^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:24:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Acquire, Ordering::AcqRel);\n-   |                                                                   ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:25:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::AcqRel);\n-   |                                                                   ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:26:66\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::AcqRel, Ordering::AcqRel);\n-   |                                                                  ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:27:66\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::SeqCst, Ordering::AcqRel);\n-   |                                                                  ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:30:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Release);\n-   |                                                                   ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:31:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Acquire, Ordering::Release);\n-   |                                                                   ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:32:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Release, Ordering::Release);\n-   |                                                                   ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:33:66\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::AcqRel, Ordering::Release);\n-   |                                                                  ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:34:66\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::Release);\n-   |                                                                  ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Release`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:37:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::Acquire);\n-   |                                                                   ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Release`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:38:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::SeqCst);\n-   |                                                                   ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Relaxed`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:41:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::SeqCst);\n-   |                                                                   ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Relaxed`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:42:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Acquire);\n-   |                                                                   ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Acquire`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:45:67\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Acquire, Ordering::SeqCst);\n-   |                                                                   ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `AcqRel`\n-  --> $DIR/atomic_ordering_exchange_weak.rs:46:66\n-   |\n-LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::AcqRel, Ordering::SeqCst);\n-   |                                                                  ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: aborting due to 16 previous errors\n-"}, {"sha": "5ee5182ca051ade720278e764c4d9b5edb3d3d7a", "filename": "tests/ui/atomic_ordering_fence.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_fence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_fence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_fence.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,20 +0,0 @@\n-#![warn(clippy::invalid_atomic_ordering)]\n-\n-use std::sync::atomic::{compiler_fence, fence, Ordering};\n-\n-fn main() {\n-    // Allowed fence ordering modes\n-    fence(Ordering::Acquire);\n-    fence(Ordering::Release);\n-    fence(Ordering::AcqRel);\n-    fence(Ordering::SeqCst);\n-\n-    // Disallowed fence ordering modes\n-    fence(Ordering::Relaxed);\n-\n-    compiler_fence(Ordering::Acquire);\n-    compiler_fence(Ordering::Release);\n-    compiler_fence(Ordering::AcqRel);\n-    compiler_fence(Ordering::SeqCst);\n-    compiler_fence(Ordering::Relaxed);\n-}"}, {"sha": "3ceff27d9ad5e7164e95f565a9e906140e2b5550", "filename": "tests/ui/atomic_ordering_fence.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_fence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_fence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_fence.stderr?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,19 +0,0 @@\n-error: memory fences cannot have `Relaxed` ordering\n-  --> $DIR/atomic_ordering_fence.rs:13:11\n-   |\n-LL |     fence(Ordering::Relaxed);\n-   |           ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n-   = help: consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n-\n-error: memory fences cannot have `Relaxed` ordering\n-  --> $DIR/atomic_ordering_fence.rs:19:20\n-   |\n-LL |     compiler_fence(Ordering::Relaxed);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "550bdb001e4cd1270b3bc6d32fd5e53c04f28bfe", "filename": "tests/ui/atomic_ordering_fetch_update.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_fetch_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_fetch_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_fetch_update.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,45 +0,0 @@\n-#![warn(clippy::invalid_atomic_ordering)]\n-\n-use std::sync::atomic::{AtomicIsize, Ordering};\n-\n-fn main() {\n-    // `fetch_update` testing\n-    let x = AtomicIsize::new(0);\n-\n-    // Allowed ordering combos\n-    let _ = x.fetch_update(Ordering::Relaxed, Ordering::Relaxed, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Acquire, Ordering::Acquire, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Acquire, Ordering::Relaxed, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Release, Ordering::Relaxed, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::AcqRel, Ordering::Acquire, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::AcqRel, Ordering::Relaxed, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::SeqCst, Ordering::Relaxed, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::SeqCst, Ordering::Acquire, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |old| Some(old + 1));\n-\n-    // AcqRel is always forbidden as a failure ordering\n-    let _ = x.fetch_update(Ordering::Relaxed, Ordering::AcqRel, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Acquire, Ordering::AcqRel, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Release, Ordering::AcqRel, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::AcqRel, Ordering::AcqRel, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::SeqCst, Ordering::AcqRel, |old| Some(old + 1));\n-\n-    // Release is always forbidden as a failure ordering\n-    let _ = x.fetch_update(Ordering::Relaxed, Ordering::Release, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Acquire, Ordering::Release, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Release, Ordering::Release, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::AcqRel, Ordering::Release, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::SeqCst, Ordering::Release, |old| Some(old + 1));\n-\n-    // Release success order forbids failure order of Acquire or SeqCst\n-    let _ = x.fetch_update(Ordering::Release, Ordering::Acquire, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Release, Ordering::SeqCst, |old| Some(old + 1));\n-\n-    // Relaxed success order also forbids failure order of Acquire or SeqCst\n-    let _ = x.fetch_update(Ordering::Relaxed, Ordering::SeqCst, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::Relaxed, Ordering::Acquire, |old| Some(old + 1));\n-\n-    // Acquire/AcqRel forbids failure order of SeqCst\n-    let _ = x.fetch_update(Ordering::Acquire, Ordering::SeqCst, |old| Some(old + 1));\n-    let _ = x.fetch_update(Ordering::AcqRel, Ordering::SeqCst, |old| Some(old + 1));\n-}"}, {"sha": "694548ece97b250b52d756ee143437646e1a7353", "filename": "tests/ui/atomic_ordering_fetch_update.stderr", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_fetch_update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_fetch_update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_fetch_update.stderr?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,131 +0,0 @@\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:21:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Relaxed, Ordering::AcqRel, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:22:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Acquire, Ordering::AcqRel, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:23:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Release, Ordering::AcqRel, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:24:46\n-   |\n-LL |     let _ = x.fetch_update(Ordering::AcqRel, Ordering::AcqRel, |old| Some(old + 1));\n-   |                                              ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:25:46\n-   |\n-LL |     let _ = x.fetch_update(Ordering::SeqCst, Ordering::AcqRel, |old| Some(old + 1));\n-   |                                              ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:28:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Relaxed, Ordering::Release, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:29:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Acquire, Ordering::Release, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:30:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Release, Ordering::Release, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:31:46\n-   |\n-LL |     let _ = x.fetch_update(Ordering::AcqRel, Ordering::Release, |old| Some(old + 1));\n-   |                                              ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:32:46\n-   |\n-LL |     let _ = x.fetch_update(Ordering::SeqCst, Ordering::Release, |old| Some(old + 1));\n-   |                                              ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be stronger than the success ordering of `Release`\n-  --> $DIR/atomic_ordering_fetch_update.rs:35:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Release, Ordering::Acquire, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be stronger than the success ordering of `Release`\n-  --> $DIR/atomic_ordering_fetch_update.rs:36:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Release, Ordering::SeqCst, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be stronger than the success ordering of `Relaxed`\n-  --> $DIR/atomic_ordering_fetch_update.rs:39:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Relaxed, Ordering::SeqCst, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be stronger than the success ordering of `Relaxed`\n-  --> $DIR/atomic_ordering_fetch_update.rs:40:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Relaxed, Ordering::Acquire, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering mode `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be stronger than the success ordering of `Acquire`\n-  --> $DIR/atomic_ordering_fetch_update.rs:43:47\n-   |\n-LL |     let _ = x.fetch_update(Ordering::Acquire, Ordering::SeqCst, |old| Some(old + 1));\n-   |                                               ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: fetch_update's failure ordering may not be stronger than the success ordering of `AcqRel`\n-  --> $DIR/atomic_ordering_fetch_update.rs:44:46\n-   |\n-LL |     let _ = x.fetch_update(Ordering::AcqRel, Ordering::SeqCst, |old| Some(old + 1));\n-   |                                              ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n-\n-error: aborting due to 16 previous errors\n-"}, {"sha": "40a00ba3de3505435770d984a270a36bd98d88ae", "filename": "tests/ui/atomic_ordering_int.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_int.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,86 +0,0 @@\n-#![warn(clippy::invalid_atomic_ordering)]\n-\n-use std::sync::atomic::{AtomicI16, AtomicI32, AtomicI64, AtomicI8, AtomicIsize, Ordering};\n-\n-fn main() {\n-    // `AtomicI8` test cases\n-    let x = AtomicI8::new(0);\n-\n-    // Allowed load ordering modes\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-\n-    // Disallowed load ordering modes\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    // Allowed store ordering modes\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-\n-    // Disallowed store ordering modes\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-\n-    // `AtomicI16` test cases\n-    let x = AtomicI16::new(0);\n-\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-\n-    // `AtomicI32` test cases\n-    let x = AtomicI32::new(0);\n-\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-\n-    // `AtomicI64` test cases\n-    let x = AtomicI64::new(0);\n-\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-\n-    // `AtomicIsize` test cases\n-    let x = AtomicIsize::new(0);\n-\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-}"}, {"sha": "bbaf234d3c9f8d0ef3d5ba2a828d9bb05d2af2fb", "filename": "tests/ui/atomic_ordering_int.stderr", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_int.stderr?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,163 +0,0 @@\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:15:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:16:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:24:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:25:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:33:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:34:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:39:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:40:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:48:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:49:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:54:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:55:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:63:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:64:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:69:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:70:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:78:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:79:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:84:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_int.rs:85:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: aborting due to 20 previous errors\n-"}, {"sha": "ecbb05c7fbc39508e993bc56b5822fbedf5f03d8", "filename": "tests/ui/atomic_ordering_ptr.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_ptr.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,27 +0,0 @@\n-#![warn(clippy::invalid_atomic_ordering)]\n-\n-use std::sync::atomic::{AtomicPtr, Ordering};\n-\n-fn main() {\n-    let ptr = &mut 5;\n-    let other_ptr = &mut 10;\n-    let x = AtomicPtr::new(ptr);\n-\n-    // Allowed load ordering modes\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-\n-    // Disallowed load ordering modes\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    // Allowed store ordering modes\n-    x.store(other_ptr, Ordering::Release);\n-    x.store(other_ptr, Ordering::SeqCst);\n-    x.store(other_ptr, Ordering::Relaxed);\n-\n-    // Disallowed store ordering modes\n-    x.store(other_ptr, Ordering::Acquire);\n-    x.store(other_ptr, Ordering::AcqRel);\n-}"}, {"sha": "558ae55518d5a9e26e302a715d0976beeeb2593f", "filename": "tests/ui/atomic_ordering_ptr.stderr", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_ptr.stderr?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,35 +0,0 @@\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_ptr.rs:16:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_ptr.rs:17:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_ptr.rs:25:24\n-   |\n-LL |     x.store(other_ptr, Ordering::Acquire);\n-   |                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_ptr.rs:26:24\n-   |\n-LL |     x.store(other_ptr, Ordering::AcqRel);\n-   |                        ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "a0d5d7c401035d686cd18a90617d5d7c81c28a1e", "filename": "tests/ui/atomic_ordering_uint.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_uint.rs?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,86 +0,0 @@\n-#![warn(clippy::invalid_atomic_ordering)]\n-\n-use std::sync::atomic::{AtomicU16, AtomicU32, AtomicU64, AtomicU8, AtomicUsize, Ordering};\n-\n-fn main() {\n-    // `AtomicU8` test cases\n-    let x = AtomicU8::new(0);\n-\n-    // Allowed load ordering modes\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-\n-    // Disallowed load ordering modes\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    // Allowed store ordering modes\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-\n-    // Disallowed store ordering modes\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-\n-    // `AtomicU16` test cases\n-    let x = AtomicU16::new(0);\n-\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-\n-    // `AtomicU32` test cases\n-    let x = AtomicU32::new(0);\n-\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-\n-    // `AtomicU64` test cases\n-    let x = AtomicU64::new(0);\n-\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-\n-    // `AtomicUsize` test cases\n-    let x = AtomicUsize::new(0);\n-\n-    let _ = x.load(Ordering::Acquire);\n-    let _ = x.load(Ordering::SeqCst);\n-    let _ = x.load(Ordering::Relaxed);\n-    let _ = x.load(Ordering::Release);\n-    let _ = x.load(Ordering::AcqRel);\n-\n-    x.store(1, Ordering::Release);\n-    x.store(1, Ordering::SeqCst);\n-    x.store(1, Ordering::Relaxed);\n-    x.store(1, Ordering::Acquire);\n-    x.store(1, Ordering::AcqRel);\n-}"}, {"sha": "5703135bcf1e2a4bb613eba2bfa984f7002ae9b0", "filename": "tests/ui/atomic_ordering_uint.stderr", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_uint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/849f0a144b019f0484c557d19684233ea8eed186/tests%2Fui%2Fatomic_ordering_uint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_uint.stderr?ref=849f0a144b019f0484c557d19684233ea8eed186", "patch": "@@ -1,163 +0,0 @@\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:15:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:16:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:24:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:25:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:33:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:34:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:39:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:40:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:48:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:49:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:54:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:55:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:63:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:64:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:69:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:70:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:78:20\n-   |\n-LL |     let _ = x.load(Ordering::Release);\n-   |                    ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic loads cannot have `Release` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:79:20\n-   |\n-LL |     let _ = x.load(Ordering::AcqRel);\n-   |                    ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:84:16\n-   |\n-LL |     x.store(1, Ordering::Acquire);\n-   |                ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: atomic stores cannot have `Acquire` and `AcqRel` ordering\n-  --> $DIR/atomic_ordering_uint.rs:85:16\n-   |\n-LL |     x.store(1, Ordering::AcqRel);\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n-\n-error: aborting due to 20 previous errors\n-"}, {"sha": "1653de9a6f26d132e449cb48bcbff58f9fdd19d6", "filename": "tests/ui/author/if.stdout", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.stdout?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -12,7 +12,8 @@ if_chain! {\n     if let ExprKind::Lit(ref lit1) = right.kind;\n     if let LitKind::Int(2, _) = lit1.node;\n     if block.expr.is_none();\n-    if let ExprKind::Lit(ref lit2) = cond.kind;\n+    if let ExprKind::DropTemps(ref expr) = cond.kind;\n+    if let ExprKind::Lit(ref lit2) = expr.kind;\n     if let LitKind::Bool(true) = lit2.node;\n     if let ExprKind::Block(ref block1) = then.kind;\n     if block1.stmts.len() == 1;"}, {"sha": "4ce365cc7649ab0a405e472535caada9f65c5822", "filename": "tests/ui/collapsible_match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -98,6 +98,11 @@ fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>\n }\n \n fn negative_cases(res_opt: Result<Option<u32>, String>, res_res: Result<Result<u32, String>, String>) {\n+    while let Some(x) = make() {\n+        if let Some(1) = x {\n+            todo!();\n+        }\n+    }\n     // no wild pattern in outer match\n     match res_opt {\n         Ok(val) => match val {"}, {"sha": "c119570e8abd8eab585064870a28f3cfd8582938", "filename": "tests/ui/collapsible_match.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcollapsible_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcollapsible_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.stderr?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,4 +1,4 @@\n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:7:20\n    |\n LL |           Ok(val) => match val {\n@@ -17,7 +17,7 @@ LL |         Ok(val) => match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:16:20\n    |\n LL |           Ok(val) => match val {\n@@ -35,7 +35,7 @@ LL |         Ok(val) => match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `if let` can be collapsed into the outer `if let`\n   --> $DIR/collapsible_match.rs:25:9\n    |\n LL | /         if let Some(n) = val {\n@@ -51,7 +51,7 @@ LL |     if let Ok(val) = res_opt {\n LL |         if let Some(n) = val {\n    |                ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `if let` can be collapsed into the outer `if let`\n   --> $DIR/collapsible_match.rs:32:9\n    |\n LL | /         if let Some(n) = val {\n@@ -69,7 +69,7 @@ LL |     if let Ok(val) = res_opt {\n LL |         if let Some(n) = val {\n    |                ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `if let`\n   --> $DIR/collapsible_match.rs:43:9\n    |\n LL | /         match val {\n@@ -87,7 +87,7 @@ LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `if let` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:52:13\n    |\n LL | /             if let Some(n) = val {\n@@ -103,7 +103,7 @@ LL |         Ok(val) => {\n LL |             if let Some(n) = val {\n    |                    ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `if let`\n   --> $DIR/collapsible_match.rs:61:9\n    |\n LL | /         match val {\n@@ -121,7 +121,7 @@ LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `if let` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:72:13\n    |\n LL | /             if let Some(n) = val {\n@@ -139,7 +139,7 @@ LL |         Ok(val) => {\n LL |             if let Some(n) = val {\n    |                    ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:83:20\n    |\n LL |           Ok(val) => match val {\n@@ -157,7 +157,7 @@ LL |         Ok(val) => match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match.rs:92:22\n    |\n LL |           Some(val) => match val {"}, {"sha": "55e70dce208a0016bbf5acb560bb17161a832316", "filename": "tests/ui/collapsible_match2.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcollapsible_match2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcollapsible_match2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.stderr?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,4 +1,4 @@\n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:13:34\n    |\n LL |               Ok(val) if make() => match val {\n@@ -17,7 +17,7 @@ LL |             Ok(val) if make() => match val {\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:20:24\n    |\n LL |               Ok(val) => match val {\n@@ -35,7 +35,7 @@ LL |             Ok(val) => match val {\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:34:29\n    |\n LL |                       $pat => match $e {\n@@ -57,7 +57,7 @@ LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    |                            replace this binding\n    = note: this error originates in the macro `mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:51:20\n    |\n LL |           Some(s) => match *s {\n@@ -75,7 +75,7 @@ LL |         Some(s) => match *s {\n LL |             [n] => foo(n),\n    |             ^^^ with this pattern\n \n-error: unnecessary nested match\n+error: this `match` can be collapsed into the outer `match`\n   --> $DIR/collapsible_match2.rs:60:24\n    |\n LL |           Some(ref s) => match &*s {"}, {"sha": "9a89047f072777cd7f6bf3f5588083be74b7f6b0", "filename": "tests/ui/crashes/ice-3969.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fice-3969.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fice-3969.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-3969.stderr?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -6,7 +6,7 @@ LL |     for<'a> Dst<A + 'a>: Sized,\n    |\n    = note: `-D bare-trait-objects` implied by `-D warnings`\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n-   = note: for more information, see issue #80165 <https://github.com/rust-lang/rust/issues/80165>\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n \n error: trait objects without an explicit `dyn` are deprecated\n   --> $DIR/ice-3969.rs:27:16\n@@ -15,7 +15,7 @@ LL |     let x: Dst<A> = *(Box::new(Dst { x: 1 }) as Box<Dst<A>>);\n    |                ^ help: use `dyn`: `dyn A`\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n-   = note: for more information, see issue #80165 <https://github.com/rust-lang/rust/issues/80165>\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n \n error: trait objects without an explicit `dyn` are deprecated\n   --> $DIR/ice-3969.rs:27:57\n@@ -24,7 +24,7 @@ LL |     let x: Dst<A> = *(Box::new(Dst { x: 1 }) as Box<Dst<A>>);\n    |                                                         ^ help: use `dyn`: `dyn A`\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n-   = note: for more information, see issue #80165 <https://github.com/rust-lang/rust/issues/80165>\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n \n error: aborting due to 3 previous errors\n "}, {"sha": "405e3039e7d0c6f8487953b4296cb29ba075e4ac", "filename": "tests/ui/crashes/ice-4775.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fice-4775.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fice-4775.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-4775.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,6 +1,3 @@\n-#![feature(const_generics)]\n-#![allow(incomplete_features)]\n-\n pub struct ArrayWrapper<const N: usize>([usize; N]);\n \n impl<const N: usize> ArrayWrapper<{ N }> {"}, {"sha": "e3b3b27a6fc382c933c387a46ad43c98917e6ae5", "filename": "tests/ui/crashes/ice-5223.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fice-5223.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fice-5223.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-5223.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,7 +1,4 @@\n // Regression test for #5233\n-\n-#![feature(const_generics)]\n-#![allow(incomplete_features)]\n #![warn(clippy::indexing_slicing, clippy::iter_cloned_collect)]\n \n pub struct KotomineArray<T, const N: usize> {"}, {"sha": "85fa421032191505e9d76edd1cb2111d9c4bbce9", "filename": "tests/ui/crashes/ice-7410.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fice-7410.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fice-7410.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7410.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -4,6 +4,7 @@\n \n #![feature(lang_items, start, libc)]\n #![no_std]\n+#![allow(clippy::if_same_then_else)]\n #![allow(clippy::redundant_pattern_matching)]\n \n use core::panic::PanicInfo;"}, {"sha": "553c840f9b081420197e772d72f0bff2fd15dc4c", "filename": "tests/ui/crashes/issues_loop_mut_cond.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,3 +1,4 @@\n+#![allow(clippy::blocks_in_if_conditions)]\n #![allow(dead_code)]\n \n /// Issue: https://github.com/rust-lang/rust-clippy/issues/2596"}, {"sha": "256a336db821d8711c6c3f958e2b814784b2f701", "filename": "tests/ui/declare_interior_mutable_const/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -117,7 +117,7 @@ impl SelfType for AtomicUsize {\n     const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n }\n \n-// Even though a constant contains a generic type, if it also have a interior mutable type,\n+// Even though a constant contains a generic type, if it also have an interior mutable type,\n // it should be linted at the definition site.\n trait BothOfCellAndGeneric<T> {\n     // this is a false negative in the current implementation."}, {"sha": "1943d0092e6244851b9c5480a879116b788e56b9", "filename": "tests/ui/deprecated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -14,5 +14,6 @@\n #[warn(clippy::filter_map)]\n #[warn(clippy::pub_enum_variant_names)]\n #[warn(clippy::wrong_pub_self_convention)]\n+#[warn(clippy::invalid_atomic_ordering)]\n \n fn main() {}"}, {"sha": "51048e45c0677c208bb8e050edc7fa0169eb8a82", "filename": "tests/ui/deprecated.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.stderr?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -96,5 +96,11 @@ error: lint `clippy::wrong_pub_self_convention` has been removed: set the `avoid\n LL | #[warn(clippy::wrong_pub_self_convention)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 16 previous errors\n+error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n+  --> $DIR/deprecated.rs:17:8\n+   |\n+LL | #[warn(clippy::invalid_atomic_ordering)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "8b0c0f304fce0f8fc318e83f1e8d01dc90e77b1e", "filename": "tests/ui/doc/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc%2Fdoc.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -2,7 +2,7 @@\n \n #![allow(dead_code, incomplete_features)]\n #![warn(clippy::doc_markdown)]\n-#![feature(custom_inner_attributes, const_generics, const_evaluatable_checked, const_option)]\n+#![feature(custom_inner_attributes, generic_const_exprs, const_option)]\n #![rustfmt::skip]\n \n /// The foo_bar function does _nothing_. See also foo::bar. (note the dot there)\n@@ -203,7 +203,7 @@ fn issue_2343() {}\n /// __|_ _|__||_|\n fn pulldown_cmark_crash() {}\n \n-// issue #7033 - const_evaluatable_checked ICE\n+// issue #7033 - generic_const_exprs ICE\n struct S<T, const N: usize>\n where [(); N.checked_next_power_of_two().unwrap()]: {\n     arr: [T; N.checked_next_power_of_two().unwrap()],"}, {"sha": "1bddc47721e5a71037eb70ad49622519197a3392", "filename": "tests/ui/if_let_some_result.fixed", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fif_let_some_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fif_let_some_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_some_result.fixed?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::if_let_some_result)]\n+#![allow(dead_code)]\n \n fn str_to_int(x: &str) -> i32 {\n     if let Ok(y) = x.parse() { y } else { 0 }\n@@ -20,8 +21,8 @@ fn strange_some_no_else(x: &str) -> i32 {\n     }\n }\n \n-fn main() {\n-    let _ = str_to_int(\"1\");\n-    let _ = str_to_int_ok(\"2\");\n-    let _ = strange_some_no_else(\"3\");\n+fn negative() {\n+    while let Some(1) = \"\".parse().ok() {}\n }\n+\n+fn main() {}"}, {"sha": "d4a52ec9881d76f465d003af6f7c60b2a4107519", "filename": "tests/ui/if_let_some_result.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_some_result.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::if_let_some_result)]\n+#![allow(dead_code)]\n \n fn str_to_int(x: &str) -> i32 {\n     if let Some(y) = x.parse().ok() { y } else { 0 }\n@@ -20,8 +21,8 @@ fn strange_some_no_else(x: &str) -> i32 {\n     }\n }\n \n-fn main() {\n-    let _ = str_to_int(\"1\");\n-    let _ = str_to_int_ok(\"2\");\n-    let _ = strange_some_no_else(\"3\");\n+fn negative() {\n+    while let Some(1) = \"\".parse().ok() {}\n }\n+\n+fn main() {}"}, {"sha": "bc3a5e7698d749764f4c79e819586a6d72076ac6", "filename": "tests/ui/if_let_some_result.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fif_let_some_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fif_let_some_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_some_result.stderr?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,5 +1,5 @@\n error: matching on `Some` with `ok()` is redundant\n-  --> $DIR/if_let_some_result.rs:6:5\n+  --> $DIR/if_let_some_result.rs:7:5\n    |\n LL |     if let Some(y) = x.parse().ok() { y } else { 0 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -11,7 +11,7 @@ LL |     if let Ok(y) = x.parse() { y } else { 0 }\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: matching on `Some` with `ok()` is redundant\n-  --> $DIR/if_let_some_result.rs:16:9\n+  --> $DIR/if_let_some_result.rs:17:9\n    |\n LL |         if let Some(y) = x   .   parse()   .   ok   ()    {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e518b2677b7bf351d73e6941e236641433177d0a", "filename": "tests/ui/infinite_loop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,3 +1,5 @@\n+#![allow(clippy::blocks_in_if_conditions)]\n+\n fn fn_val(i: i32) -> i32 {\n     unimplemented!()\n }"}, {"sha": "2736753c14b6eccfc33acd4575f63efca21f89e5", "filename": "tests/ui/infinite_loop.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.stderr?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,5 +1,5 @@\n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:21:11\n+  --> $DIR/infinite_loop.rs:23:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^\n@@ -8,71 +8,71 @@ LL |     while y < 10 {\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:26:11\n+  --> $DIR/infinite_loop.rs:28:11\n    |\n LL |     while y < 10 && x < 3 {\n    |           ^^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:33:11\n+  --> $DIR/infinite_loop.rs:35:11\n    |\n LL |     while !cond {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:77:11\n+  --> $DIR/infinite_loop.rs:79:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:82:11\n+  --> $DIR/infinite_loop.rs:84:11\n    |\n LL |     while i < 3 && j > 0 {\n    |           ^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:86:11\n+  --> $DIR/infinite_loop.rs:88:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:101:11\n+  --> $DIR/infinite_loop.rs:103:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:106:11\n+  --> $DIR/infinite_loop.rs:108:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:172:15\n+  --> $DIR/infinite_loop.rs:174:15\n    |\n LL |         while self.count < n {\n    |               ^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:180:11\n+  --> $DIR/infinite_loop.rs:182:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^\n@@ -82,7 +82,7 @@ LL |     while y < 10 {\n    = help: rewrite it as `if cond { loop { } }`\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:187:11\n+  --> $DIR/infinite_loop.rs:189:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^"}, {"sha": "c84e31ea482a48e8fefc32c8d43912acb2e3b874", "filename": "tests/ui/match_overlapping_arm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmatch_overlapping_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmatch_overlapping_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_overlapping_arm.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -2,6 +2,7 @@\n #![feature(half_open_range_patterns)]\n #![warn(clippy::match_overlapping_arm)]\n #![allow(clippy::redundant_pattern_matching)]\n+#![allow(clippy::if_same_then_else)]\n \n /// Tests for match_overlapping_arm\n "}, {"sha": "359fa49f51be73735e65231454cc6bda7fbbbe89", "filename": "tests/ui/match_overlapping_arm.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmatch_overlapping_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmatch_overlapping_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_overlapping_arm.stderr?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,60 +1,60 @@\n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:12:9\n+  --> $DIR/match_overlapping_arm.rs:13:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^\n    |\n    = note: `-D clippy::match-overlapping-arm` implied by `-D warnings`\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:13:9\n+  --> $DIR/match_overlapping_arm.rs:14:9\n    |\n LL |         0..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:18:9\n+  --> $DIR/match_overlapping_arm.rs:19:9\n    |\n LL |         0..=5 => println!(\"0 ... 5\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:20:9\n+  --> $DIR/match_overlapping_arm.rs:21:9\n    |\n LL |         FOO..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:55:9\n+  --> $DIR/match_overlapping_arm.rs:56:9\n    |\n LL |         0..11 => println!(\"0 .. 11\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:56:9\n+  --> $DIR/match_overlapping_arm.rs:57:9\n    |\n LL |         0..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:80:9\n+  --> $DIR/match_overlapping_arm.rs:81:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:79:9\n+  --> $DIR/match_overlapping_arm.rs:80:9\n    |\n LL |         5..14 => println!(\"5 .. 14\"),\n    |         ^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:85:9\n+  --> $DIR/match_overlapping_arm.rs:86:9\n    |\n LL |         0..7 => println!(\"0 .. 7\"),\n    |         ^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:86:9\n+  --> $DIR/match_overlapping_arm.rs:87:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^"}, {"sha": "aa60d0504e5e60c1181351c9444736b62d740b5a", "filename": "tests/ui/missing_const_for_fn/cant_be_const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -5,8 +5,7 @@\n // aux-build:helper.rs\n \n #![warn(clippy::missing_const_for_fn)]\n-#![allow(incomplete_features)]\n-#![feature(start, const_generics)]\n+#![feature(start)]\n #![feature(custom_inner_attributes)]\n \n extern crate helper;"}, {"sha": "baa7eec05462ebad8baea0762ed76b51ae7dfa2d", "filename": "tests/ui/missing_const_for_fn/could_be_const.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.rs?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,6 +1,5 @@\n #![warn(clippy::missing_const_for_fn)]\n #![allow(incomplete_features, clippy::let_and_return)]\n-#![feature(const_generics)]\n #![feature(custom_inner_attributes)]\n \n use std::mem::transmute;"}, {"sha": "b89cc6451bb592c5f3f6fbbab1daa194953d5101", "filename": "tests/ui/missing_const_for_fn/could_be_const.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2c7b712c273f13258de8b87b233918d8726b9/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fcould_be_const.stderr?ref=a8c2c7b712c273f13258de8b87b233918d8726b9", "patch": "@@ -1,5 +1,5 @@\n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:14:5\n+  --> $DIR/could_be_const.rs:13:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         Self { guess: 42 }\n@@ -9,23 +9,23 @@ LL | |     }\n    = note: `-D clippy::missing-const-for-fn` implied by `-D warnings`\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:18:5\n+  --> $DIR/could_be_const.rs:17:5\n    |\n LL | /     fn const_generic_params<'a, T, const N: usize>(&self, b: &'a [T; N]) -> &'a [T; N] {\n LL | |         b\n LL | |     }\n    | |_____^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:24:1\n+  --> $DIR/could_be_const.rs:23:1\n    |\n LL | / fn one() -> i32 {\n LL | |     1\n LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:29:1\n+  --> $DIR/could_be_const.rs:28:1\n    |\n LL | / fn two() -> i32 {\n LL | |     let abc = 2;\n@@ -34,39 +34,39 @@ LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:35:1\n+  --> $DIR/could_be_const.rs:34:1\n    |\n LL | / fn string() -> String {\n LL | |     String::new()\n LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:40:1\n+  --> $DIR/could_be_const.rs:39:1\n    |\n LL | / unsafe fn four() -> i32 {\n LL | |     4\n LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:45:1\n+  --> $DIR/could_be_const.rs:44:1\n    |\n LL | / fn generic<T>(t: T) -> T {\n LL | |     t\n LL | | }\n    | |_^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:68:9\n+  --> $DIR/could_be_const.rs:67:9\n    |\n LL | /         pub fn b(self, a: &A) -> B {\n LL | |             B\n LL | |         }\n    | |_________^\n \n error: this could be a `const fn`\n-  --> $DIR/could_be_const.rs:78:5\n+  --> $DIR/could_be_const.rs:77:5\n    |\n LL | /     fn const_fn_stabilized_before_msrv(byte: u8) {\n LL | |         byte.is_ascii_digit();"}]}