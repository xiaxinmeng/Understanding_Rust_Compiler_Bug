{"sha": "fce4a174b9ffff71a66feecd9f4960f17fc9c331", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZTRhMTc0YjlmZmZmNzFhNjZmZWVjZDlmNDk2MGYxN2ZjOWMzMzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-03T07:19:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-09T22:41:49Z"}, "message": "Implement LTO\n\nThis commit implements LTO for rust leveraging LLVM's passes. What this means\nis:\n\n* When compiling an rlib, in addition to insdering foo.o into the archive, also\n  insert foo.bc (the LLVM bytecode) of the optimized module.\n\n* When the compiler detects the -Z lto option, it will attempt to perform LTO on\n  a staticlib or binary output. The compiler will emit an error if a dylib or\n  rlib output is being generated.\n\n* The actual act of performing LTO is as follows:\n\n    1. Force all upstream libraries to have an rlib version available.\n    2. Load the bytecode of each upstream library from the rlib.\n    3. Link all this bytecode into the current LLVM module (just using llvm\n       apis)\n    4. Run an internalization pass which internalizes all symbols except those\n       found reachable for the local crate of compilation.\n    5. Run the LLVM LTO pass manager over this entire module\n\n    6a. If assembling an archive, then add all upstream rlibs into the output\n        archive. This ignores all of the object/bitcode/metadata files rust\n        generated and placed inside the rlibs.\n    6b. If linking a binary, create copies of all upstream rlibs, remove the\n        rust-generated object-file, and then link everything as usual.\n\nAs I have explained in #10741, this process is excruciatingly slow, so this is\n*not* turned on by default, and it is also why I have decided to hide it behind\na -Z flag for now. The good news is that the binary sizes are about as small as\nthey can be as a result of LTO, so it's definitely working.\n\nCloses #10741\nCloses #10740", "tree": {"sha": "af1664c41213a1d7db2aaa740eda2ba6b901a776", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af1664c41213a1d7db2aaa740eda2ba6b901a776"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fce4a174b9ffff71a66feecd9f4960f17fc9c331", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fce4a174b9ffff71a66feecd9f4960f17fc9c331", "html_url": "https://github.com/rust-lang/rust/commit/fce4a174b9ffff71a66feecd9f4960f17fc9c331", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fce4a174b9ffff71a66feecd9f4960f17fc9c331/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52b835c5e7a68b32a8f0532f178c150d09be200d", "url": "https://api.github.com/repos/rust-lang/rust/commits/52b835c5e7a68b32a8f0532f178c150d09be200d", "html_url": "https://github.com/rust-lang/rust/commit/52b835c5e7a68b32a8f0532f178c150d09be200d"}], "stats": {"total": 556, "additions": 432, "deletions": 124}, "files": [{"sha": "eec15f798278d195e048932c1cf0ac5f4fd83016", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -42,7 +42,8 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n     }\n     let o = Process::new(ar, args.as_slice(), opts).finish_with_output();\n     if !o.status.success() {\n-        sess.err(format!(\"{} failed with: {}\", ar, o.status));\n+        sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n+                         o.status));\n         sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output)));\n         sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error)));\n         sess.abort_if_errors();\n@@ -88,16 +89,34 @@ impl Archive {\n \n     /// Adds all of the contents of the rlib at the specified path to this\n     /// archive.\n-    pub fn add_rlib(&mut self, rlib: &Path) {\n-        let name = rlib.filename_str().unwrap().split('-').next().unwrap();\n-        self.add_archive(rlib, name, [METADATA_FILENAME]);\n+    ///\n+    /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n+    /// then the object file also isn't added.\n+    pub fn add_rlib(&mut self, rlib: &Path, name: &str, lto: bool) {\n+        let object = format!(\"{}.o\", name);\n+        let bytecode = format!(\"{}.bc\", name);\n+        let mut ignore = ~[METADATA_FILENAME, bytecode.as_slice()];\n+        if lto {\n+            ignore.push(object.as_slice());\n+        }\n+        self.add_archive(rlib, name, ignore);\n     }\n \n     /// Adds an arbitrary file to this archive\n     pub fn add_file(&mut self, file: &Path) {\n         run_ar(self.sess, \"r\", None, [&self.dst, file]);\n     }\n \n+    /// Removes a file from this archive\n+    pub fn remove_file(&mut self, file: &str) {\n+        run_ar(self.sess, \"d\", None, [&self.dst, &Path::new(file)]);\n+    }\n+\n+    pub fn files(&self) -> ~[~str] {\n+        let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n+        str::from_utf8(output.output).lines().map(|s| s.to_owned()).collect()\n+    }\n+\n     fn add_archive(&mut self, archive: &Path, name: &str, skip: &[&str]) {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n@@ -109,11 +128,17 @@ impl Archive {\n         // The reason for this is that archives are keyed off the name of the\n         // files, so if two files have the same name they will override one\n         // another in the archive (bad).\n+        //\n+        // We skip any files explicitly desired for skipping, and we also skip\n+        // all SYMDEF files as these are just magical placeholders which get\n+        // re-created when we make a new archive anyway.\n         let files = fs::readdir(loc.path());\n         let mut inputs = ~[];\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n             if skip.iter().any(|s| *s == filename) { continue }\n+            if filename.contains(\".SYMDEF\") { continue }\n+\n             let filename = format!(\"r-{}-{}\", name, filename);\n             let new_filename = file.with_filename(filename);\n             fs::rename(file, &new_filename);"}, {"sha": "fdf47e2db737d6e4d28e994d003b7b259074320c", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 164, "deletions": 91, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -22,6 +22,7 @@ use metadata::{encoder, cstore, filesearch, csearch};\n use middle::trans::context::CrateContext;\n use middle::trans::common::gensym_name;\n use middle::ty;\n+use util::common::time;\n use util::ppaux;\n \n use std::c_str::ToCStr;\n@@ -33,6 +34,7 @@ use std::ptr;\n use std::run;\n use std::str;\n use std::io::fs;\n+use extra::tempfile::TempDir;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n@@ -85,6 +87,7 @@ pub fn WriteOutputFile(\n \n pub mod write {\n \n+    use back::lto;\n     use back::link::{WriteOutputFile, output_type};\n     use back::link::{output_type_assembly, output_type_bitcode};\n     use back::link::{output_type_exe, output_type_llvm_assembly};\n@@ -93,8 +96,9 @@ pub mod write {\n     use driver::session::Session;\n     use driver::session;\n     use lib::llvm::llvm;\n-    use lib::llvm::ModuleRef;\n+    use lib::llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n     use lib;\n+    use util::common::time;\n \n     use std::c_str::ToCStr;\n     use std::libc::{c_uint, c_int};\n@@ -194,19 +198,36 @@ pub mod write {\n             }\n \n             // Finally, run the actual optimization passes\n-            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n-            llvm::LLVMRunPassManager(mpm, llmod);\n+            time(sess.time_passes(), \"llvm function passes\", (), |()|\n+                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+            time(sess.time_passes(), \"llvm module passes\", (), |()|\n+                 llvm::LLVMRunPassManager(mpm, llmod));\n \n             // Deallocate managers that we're now done with\n             llvm::LLVMDisposePassManager(fpm);\n             llvm::LLVMDisposePassManager(mpm);\n \n-            if sess.opts.save_temps {\n+            // Emit the bytecode if we're either saving our temporaries or\n+            // emitting an rlib. Whenever an rlib is create, the bytecode is\n+            // inserted into the archive in order to allow LTO against it.\n+            if sess.opts.save_temps ||\n+               sess.outputs.iter().any(|&o| o == session::OutputRlib) {\n                 output.with_extension(\"bc\").with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 })\n             }\n \n+            if sess.lto() {\n+                time(sess.time_passes(), \"all lto passes\", (), |()|\n+                     lto::run(sess, llmod, tm, trans.reachable));\n+\n+                if sess.opts.save_temps {\n+                    output.with_extension(\"lto.bc\").with_c_str(|buf| {\n+                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                    })\n+                }\n+            }\n+\n             // A codegen-specific pass manager is used to generate object\n             // files for an LLVM module.\n             //\n@@ -217,41 +238,54 @@ pub mod write {\n             // used once.\n             fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n                             f: |PassManagerRef|) {\n-                let cpm = llvm::LLVMCreatePassManager();\n-                llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-                llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n-                f(cpm);\n-                llvm::LLVMDisposePassManager(cpm);\n-\n+                unsafe {\n+                    let cpm = llvm::LLVMCreatePassManager();\n+                    llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+                    llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n+                    f(cpm);\n+                    llvm::LLVMDisposePassManager(cpm);\n+                }\n             }\n \n-            match output_type {\n-                output_type_none => {}\n-                output_type_bitcode => {\n-                    output.with_c_str(|buf| {\n-                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                    })\n-                }\n-                output_type_llvm_assembly => {\n-                    output.with_c_str(|output| {\n-                        with_codegen(tm, llmod, |cpm| {\n-                            llvm::LLVMRustPrintModule(cpm, llmod, output);\n+            time(sess.time_passes(), \"codegen passes\", (), |()| {\n+                match output_type {\n+                    output_type_none => {}\n+                    output_type_bitcode => {\n+                        output.with_c_str(|buf| {\n+                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                         })\n-                    })\n-                }\n-                output_type_assembly => {\n-                    with_codegen(tm, llmod, |cpm| {\n-                        WriteOutputFile(sess, tm, cpm, llmod, output,\n-                                        lib::llvm::AssemblyFile);\n-                    });\n-\n-                    // windows will invoke this function with an assembly output\n-                    // type when it's actually generating an object file. This\n-                    // is because g++ is used to compile the assembly instead of\n-                    // having LLVM directly output an object file. Regardless,\n-                    // in this case, we're going to possibly need a metadata\n-                    // file.\n-                    if sess.opts.output_type != output_type_assembly {\n+                    }\n+                    output_type_llvm_assembly => {\n+                        output.with_c_str(|output| {\n+                            with_codegen(tm, llmod, |cpm| {\n+                                llvm::LLVMRustPrintModule(cpm, llmod, output);\n+                            })\n+                        })\n+                    }\n+                    output_type_assembly => {\n+                        with_codegen(tm, llmod, |cpm| {\n+                            WriteOutputFile(sess, tm, cpm, llmod, output,\n+                                            lib::llvm::AssemblyFile);\n+                        });\n+\n+                        // If we're not using the LLVM assembler, this function\n+                        // could be invoked specially with output_type_assembly,\n+                        // so in this case we still want the metadata object\n+                        // file.\n+                        if sess.opts.output_type != output_type_assembly {\n+                            with_codegen(tm, trans.metadata_module, |cpm| {\n+                                let out = output.with_extension(\"metadata.o\");\n+                                WriteOutputFile(sess, tm, cpm,\n+                                                trans.metadata_module, &out,\n+                                                lib::llvm::ObjectFile);\n+                            })\n+                        }\n+                    }\n+                    output_type_exe | output_type_object => {\n+                        with_codegen(tm, llmod, |cpm| {\n+                            WriteOutputFile(sess, tm, cpm, llmod, output,\n+                                            lib::llvm::ObjectFile);\n+                        });\n                         with_codegen(tm, trans.metadata_module, |cpm| {\n                             let out = output.with_extension(\"metadata.o\");\n                             WriteOutputFile(sess, tm, cpm,\n@@ -260,18 +294,7 @@ pub mod write {\n                         })\n                     }\n                 }\n-                output_type_exe | output_type_object => {\n-                    with_codegen(tm, llmod, |cpm| {\n-                        WriteOutputFile(sess, tm, cpm, llmod, output,\n-                                        lib::llvm::ObjectFile);\n-                    });\n-                    with_codegen(tm, trans.metadata_module, |cpm| {\n-                        WriteOutputFile(sess, tm, cpm, trans.metadata_module,\n-                                        &output.with_extension(\"metadata.o\"),\n-                                        lib::llvm::ObjectFile);\n-                    })\n-                }\n-            }\n+            });\n \n             llvm::LLVMRustDisposeTargetMachine(tm);\n             llvm::LLVMDisposeModule(trans.metadata_module);\n@@ -826,30 +849,12 @@ pub fn link_binary(sess: Session,\n                    trans: &CrateTranslation,\n                    obj_filename: &Path,\n                    out_filename: &Path) {\n+    // If we're generating a test executable, then ignore all other output\n+    // styles at all other locations\n     let outputs = if sess.opts.test {\n-        // If we're generating a test executable, then ignore all other output\n-        // styles at all other locations\n         ~[session::OutputExecutable]\n     } else {\n-        // Always generate whatever was specified on the command line, but also\n-        // look at what was in the crate file itself for generating output\n-        // formats.\n-        let mut outputs = sess.opts.outputs.clone();\n-        for ty in trans.crate_types.iter() {\n-            if \"bin\" == *ty {\n-                outputs.push(session::OutputExecutable);\n-            } else if \"dylib\" == *ty || \"lib\" == *ty {\n-                outputs.push(session::OutputDylib);\n-            } else if \"rlib\" == *ty {\n-                outputs.push(session::OutputRlib);\n-            } else if \"staticlib\" == *ty {\n-                outputs.push(session::OutputStaticlib);\n-            }\n-        }\n-        if outputs.len() == 0 {\n-            outputs.push(session::OutputExecutable);\n-        }\n-        outputs\n+        (*sess.outputs).clone()\n     };\n \n     for output in outputs.move_iter() {\n@@ -935,32 +940,61 @@ fn link_binary_output(sess: Session,\n // rlib primarily contains the object file of the crate, but it also contains\n // all of the object files from native libraries. This is done by unzipping\n // native libraries and inserting all of the contents into this archive.\n-//\n-// Instead of putting the metadata in an object file section, instead rlibs\n-// contain the metadata in a separate file.\n fn link_rlib(sess: Session,\n-             trans: Option<&CrateTranslation>, // None == no metadata\n+             trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n              obj_filename: &Path,\n              out_filename: &Path) -> Archive {\n     let mut a = Archive::create(sess, out_filename, obj_filename);\n \n+    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n+        match kind {\n+            cstore::NativeStatic => {\n+                a.add_native_library(l.as_slice());\n+            }\n+            cstore::NativeFramework | cstore::NativeUnknown => {}\n+        }\n+    }\n+\n+    // Note that it is important that we add all of our non-object \"magical\n+    // files\" *after* all of the object files in the archive. The reason for\n+    // this is as follows:\n+    //\n+    // * When performing LTO, this archive will be modified to remove\n+    //   obj_filename from above. The reason for this is described below.\n+    //\n+    // * When the system linker looks at an archive, it will attempt to\n+    //   determine the architecture of the archive in order to see whether its\n+    //   linkable.\n+    //\n+    //   The algorithm for this detections is: iterate over the files in the\n+    //   archive. Skip magical SYMDEF names. Interpret the first file as an\n+    //   object file. Read architecture from the object file.\n+    //\n+    // * As one can probably see, if \"metadata\" and \"foo.bc\" were placed\n+    //   before all of the objects, then the architecture of this archive would\n+    //   not be correctly inferred once 'foo.o' is removed.\n+    //\n+    // Basically, all this means is that this code should not move above the\n+    // code above.\n     match trans {\n         Some(trans) => {\n+            // Instead of putting the metadata in an object file section, rlibs\n+            // contain the metadata in a separate file.\n             let metadata = obj_filename.with_filename(METADATA_FILENAME);\n             fs::File::create(&metadata).write(trans.metadata);\n             a.add_file(&metadata);\n             fs::unlink(&metadata);\n-        }\n-        None => {}\n-    }\n \n-    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n-        match kind {\n-            cstore::NativeStatic => {\n-                a.add_native_library(l.as_slice());\n+            // For LTO purposes, the bytecode of this library is also inserted\n+            // into the archive.\n+            let bc = obj_filename.with_extension(\"bc\");\n+            a.add_file(&bc);\n+            if !sess.opts.save_temps {\n+                fs::unlink(&bc);\n             }\n-            cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n+\n+        None => {}\n     }\n     return a;\n }\n@@ -983,14 +1017,14 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n \n     let crates = cstore::get_used_crates(sess.cstore, cstore::RequireStatic);\n     for &(cnum, ref path) in crates.iter() {\n+        let name = cstore::get_crate_data(sess.cstore, cnum).name;\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n-                sess.err(format!(\"could not find rlib for: `{}`\",\n-                                 cstore::get_crate_data(sess.cstore, cnum).name));\n+                sess.err(format!(\"could not find rlib for: `{}`\", name));\n                 continue\n             }\n         };\n-        a.add_rlib(&p);\n+        a.add_rlib(&p, name, sess.lto());\n         let native_libs = csearch::get_native_libraries(sess.cstore, cnum);\n         for &(kind, ref lib) in native_libs.iter() {\n             let name = match kind {\n@@ -1009,10 +1043,12 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n // links to all upstream files as well.\n fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n                  out_filename: &Path) {\n+    let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n     // The invocations of cc share some flags across platforms\n     let cc_prog = get_cc_prog(sess);\n     let mut cc_args = sess.targ_cfg.target_strs.cc_args.clone();\n-    cc_args.push_all_move(link_args(sess, dylib, obj_filename, out_filename));\n+    cc_args.push_all_move(link_args(sess, dylib, tmpdir.path(),\n+                                    obj_filename, out_filename));\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n         println!(\"{} link args: '{}'\", cc_prog, cc_args.connect(\"' '\"));\n     }\n@@ -1022,7 +1058,8 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n \n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n-    let prog = run::process_output(cc_prog, cc_args);\n+    let prog = time(sess.time_passes(), \"running linker\", (), |()|\n+                    run::process_output(cc_prog, cc_args));\n \n     if !prog.status.success() {\n         sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n@@ -1043,6 +1080,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n \n fn link_args(sess: Session,\n              dylib: bool,\n+             tmpdir: &Path,\n              obj_filename: &Path,\n              out_filename: &Path) -> ~[~str] {\n \n@@ -1084,7 +1122,7 @@ fn link_args(sess: Session,\n     }\n \n     add_local_native_libraries(&mut args, sess);\n-    add_upstream_rust_crates(&mut args, sess, dylib);\n+    add_upstream_rust_crates(&mut args, sess, dylib, tmpdir);\n     add_upstream_native_libraries(&mut args, sess);\n \n     // # Telling the linker what we're doing\n@@ -1167,7 +1205,7 @@ fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n-                            dylib: bool) {\n+                            dylib: bool, tmpdir: &Path) {\n     // Converts a library file-stem into a cc -l argument\n     fn unlib(config: @session::config, stem: &str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n@@ -1192,14 +1230,49 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n         // dynamic libraries.\n         let crates = cstore::get_used_crates(cstore, cstore::RequireStatic);\n         if crates.iter().all(|&(_, ref p)| p.is_some()) {\n-            for (_, path) in crates.move_iter() {\n-                let path = path.unwrap();\n-                args.push(path.as_str().unwrap().to_owned());\n+            for (cnum, path) in crates.move_iter() {\n+                let cratepath = path.unwrap();\n+\n+                // When performing LTO on an executable output, all of the\n+                // bytecode from the upstream libraries has already been\n+                // included in our object file output. We need to modify all of\n+                // the upstream archives to remove their corresponding object\n+                // file to make sure we don't pull the same code in twice.\n+                //\n+                // We must continue to link to the upstream archives to be sure\n+                // to pull in native static dependencies. As the final caveat,\n+                // on linux it is apparently illegal to link to a blank archive,\n+                // so if an archive no longer has any object files in it after\n+                // we remove `lib.o`, then don't link against it at all.\n+                //\n+                // If we're not doing LTO, then our job is simply to just link\n+                // against the archive.\n+                if sess.lto() {\n+                    let name = cstore::get_crate_data(sess.cstore, cnum).name;\n+                    time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n+                         (), |()| {\n+                        let dst = tmpdir.join(cratepath.filename().unwrap());\n+                        fs::copy(&cratepath, &dst);\n+                        let dst_str = dst.as_str().unwrap().to_owned();\n+                        let mut archive = Archive::open(sess, dst);\n+                        archive.remove_file(format!(\"{}.o\", name));\n+                        let files = archive.files();\n+                        if files.iter().any(|s| s.ends_with(\".o\")) {\n+                            args.push(dst_str);\n+                        }\n+                    });\n+                } else {\n+                    args.push(cratepath.as_str().unwrap().to_owned());\n+                }\n             }\n             return;\n         }\n     }\n \n+    // If we're performing LTO, then it should have been previously required\n+    // that all upstream rust depenencies were available in an rlib format.\n+    assert!(!sess.lto());\n+\n     // This is a fallback of three different  cases of linking:\n     //\n     // * When creating a dynamic library, all inputs are required to be dynamic"}, {"sha": "7c8c6aabd7eab5cfccee33b9d44df98b2f57d185", "filename": "src/librustc/back/lto.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use back::archive::Archive;\n+use back::link;\n+use driver::session;\n+use lib::llvm::{ModuleRef, TargetMachineRef, llvm, True, False};\n+use metadata::cstore;\n+use util::common::time;\n+\n+use std::libc;\n+use std::vec;\n+\n+pub fn run(sess: session::Session, llmod: ModuleRef,\n+           tm: TargetMachineRef, reachable: &[~str]) {\n+    // Make sure we actually can run LTO\n+    for output in sess.outputs.iter() {\n+        match *output {\n+            session::OutputExecutable | session::OutputStaticlib => {}\n+            _ => {\n+                sess.fatal(\"lto can only be run for executables and \\\n+                            static library outputs\");\n+            }\n+        }\n+    }\n+\n+    // For each of our upstream dependencies, find the corresponding rlib and\n+    // load the bitcode from the archive. Then merge it into the current LLVM\n+    // module that we've got.\n+    let crates = cstore::get_used_crates(sess.cstore, cstore::RequireStatic);\n+    for (cnum, path) in crates.move_iter() {\n+        let name = cstore::get_crate_data(sess.cstore, cnum).name;\n+        let path = match path {\n+            Some(p) => p,\n+            None => {\n+                sess.fatal(format!(\"could not find rlib for: `{}`\", name));\n+            }\n+        };\n+\n+        let archive = Archive::open(sess, path);\n+        debug!(\"reading {}\", name);\n+        let bc = time(sess.time_passes(), format!(\"read {}.bc\", name), (), |_|\n+                      archive.read(format!(\"{}.bc\", name)));\n+        let ptr = vec::raw::to_ptr(bc);\n+        debug!(\"linking {}\", name);\n+        time(sess.time_passes(), format!(\"ll link {}\", name), (), |()| unsafe {\n+            if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n+                                                    ptr as *libc::c_char,\n+                                                    bc.len() as libc::size_t) {\n+                link::llvm_err(sess, format!(\"failed to load bc of `{}`\", name));\n+            }\n+        });\n+    }\n+\n+    // Internalize everything but the reachable symbols of the current module\n+    let cstrs = reachable.map(|s| s.to_c_str());\n+    let arr = cstrs.map(|c| c.with_ref(|p| p));\n+    let ptr = vec::raw::to_ptr(arr);\n+    unsafe {\n+        llvm::LLVMRustRunRestrictionPass(llmod, ptr as **libc::c_char,\n+                                         arr.len() as libc::size_t);\n+    }\n+\n+    // Now we have one massive module inside of llmod. Time to run the\n+    // LTO-specific optimization passes that LLVM provides.\n+    //\n+    // This code is based off the code found in llvm's LTO code generator:\n+    //      tools/lto/LTOCodeGenerator.cpp\n+    debug!(\"running the pass manager\");\n+    unsafe {\n+        let pm = llvm::LLVMCreatePassManager();\n+        llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n+        \"verify\".with_c_str(|s| llvm::LLVMRustAddPass(pm, s));\n+\n+        let builder = llvm::LLVMPassManagerBuilderCreate();\n+        llvm::LLVMPassManagerBuilderPopulateLTOPassManager(builder, pm,\n+            /* Internalize = */ False,\n+            /* RunInliner = */ True);\n+        llvm::LLVMPassManagerBuilderDispose(builder);\n+\n+        \"verify\".with_c_str(|s| llvm::LLVMRustAddPass(pm, s));\n+\n+        time(sess.time_passes(), \"LTO pases\", (), |()|\n+             llvm::LLVMRunPassManager(pm, llmod));\n+\n+        llvm::LLVMDisposePassManager(pm);\n+    }\n+    debug!(\"lto done\");\n+}"}, {"sha": "c0ee53da9705362d294cd1bcff193b120b410f90", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -165,10 +165,7 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     let time_passes = sess.time_passes();\n \n     *sess.building_library = session::building_library(sess.opts, &crate);\n-    let want_exe = sess.opts.outputs.iter().any(|&o| o == OutputExecutable);\n-    if *sess.building_library && want_exe {\n-        sess.err(\"cannot build both a library and an executable\");\n-    }\n+    *sess.outputs = session::collect_outputs(sess.opts, &crate);\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &crate));\n@@ -337,8 +334,8 @@ pub struct CrateTranslation {\n     module: ModuleRef,\n     metadata_module: ModuleRef,\n     link: LinkMeta,\n-    crate_types: ~[~str],\n     metadata: ~[u8],\n+    reachable: ~[~str],\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n@@ -837,7 +834,8 @@ pub fn build_session_(sopts: @session::options,\n         building_library: @mut false,\n         working_dir: os::getcwd(),\n         lints: @mut HashMap::new(),\n-        node_id: @mut 1\n+        node_id: @mut 1,\n+        outputs: @mut ~[],\n     }\n }\n "}, {"sha": "30d5b7780cf92c3b688893fa827193635489eddb", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -17,6 +17,7 @@ use metadata::filesearch;\n use metadata;\n use middle::lint;\n \n+use syntax::attr::AttrMetaMethods;\n use syntax::ast::NodeId;\n use syntax::ast::{int_ty, uint_ty};\n use syntax::codemap::Span;\n@@ -67,6 +68,7 @@ pub static use_softfp:              uint = 1 << 26;\n pub static gen_crate_map:           uint = 1 << 27;\n pub static prefer_dynamic:          uint = 1 << 28;\n pub static no_integrated_as:        uint = 1 << 29;\n+pub static lto:                     uint = 1 << 30;\n \n pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n     ~[(\"verbose\", \"in general, enable more debug printouts\", verbose),\n@@ -120,6 +122,7 @@ pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n      (\"prefer-dynamic\", \"Prefer dynamic linking to static linking\", prefer_dynamic),\n      (\"no-integrated-as\",\n       \"Use external assembler rather than LLVM's integrated one\", no_integrated_as),\n+     (\"lto\", \"Perform LLVM link-time optimizations\", lto),\n     ]\n }\n \n@@ -208,6 +211,7 @@ pub struct Session_ {\n     working_dir: Path,\n     lints: @mut HashMap<ast::NodeId, ~[(lint::lint, codemap::Span, ~str)]>,\n     node_id: @mut ast::NodeId,\n+    outputs: @mut ~[OutputStyle],\n }\n \n pub type Session = @Session_;\n@@ -341,6 +345,9 @@ impl Session_ {\n     pub fn no_integrated_as(&self) -> bool {\n         self.debugging_opt(no_integrated_as)\n     }\n+    pub fn lto(&self) -> bool {\n+        self.debugging_opt(lto)\n+    }\n \n     // pointless function, now...\n     pub fn str_of(&self, id: ast::Ident) -> @str {\n@@ -408,6 +415,29 @@ pub fn building_library(options: &options, crate: &ast::Crate) -> bool {\n     }\n }\n \n+pub fn collect_outputs(options: &options, crate: &ast::Crate) -> ~[OutputStyle] {\n+    let mut base = options.outputs.clone();\n+    let mut iter = crate.attrs.iter().filter_map(|a| {\n+        if \"crate_type\" == a.name() {\n+            match a.value_str() {\n+                Some(n) if \"rlib\" == n => Some(OutputRlib),\n+                Some(n) if \"dylib\" == n => Some(OutputDylib),\n+                Some(n) if \"lib\" == n => Some(OutputDylib),\n+                Some(n) if \"staticlib\" == n => Some(OutputStaticlib),\n+                Some(n) if \"bin\" == n => Some(OutputExecutable),\n+                _ => None\n+            }\n+        } else {\n+            None\n+        }\n+    });\n+    base.extend(&mut iter);\n+    if base.len() == 0 {\n+        base.push(OutputExecutable);\n+    }\n+    return base;\n+}\n+\n pub fn sess_os_to_meta_os(os: abi::Os) -> metadata::loader::Os {\n     use metadata::loader;\n "}, {"sha": "3de33e13ecc197fd0bf3e9242fef954cccd85c40", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -99,6 +99,7 @@ pub mod back {\n     pub mod x86_64;\n     pub mod rpath;\n     pub mod target_strs;\n+    pub mod lto;\n }\n \n pub mod metadata;"}, {"sha": "7039eced9769fbb52411f0c95585a559501ec3fd", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -1403,6 +1403,11 @@ pub mod llvm {\n         pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n             PMB: PassManagerBuilderRef,\n             PM: PassManagerRef);\n+        pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n+            PMB: PassManagerBuilderRef,\n+            PM: PassManagerRef,\n+            Internalize: Bool,\n+            RunInliner: Bool);\n \n         /** Destroys a memory buffer. */\n         pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n@@ -1736,6 +1741,12 @@ pub mod llvm {\n         pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *c_char);\n         pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n                                            AddLifetimes: bool);\n+        pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n+                                             bc: *c_char,\n+                                             len: size_t) -> bool;\n+        pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n+                                          syms: **c_char,\n+                                          len: size_t);\n     }\n }\n "}, {"sha": "8a89cd35d0e47e89a27343f821de7719c5e9dd88", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -2929,7 +2929,7 @@ pub fn symname(sess: session::Session, name: &str,\n }\n \n pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n-                      llmod: ModuleRef) -> ValueRef {\n+                      llmod: ModuleRef) -> (~str, ValueRef) {\n     let targ_cfg = sess.targ_cfg;\n     let int_type = Type::int(targ_cfg.arch);\n     let mut n_subcrates = 1;\n@@ -2963,7 +2963,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n         lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n     }\n \n-    return map;\n+    return (sym_name, map);\n }\n \n pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n@@ -3059,7 +3059,9 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n                         flate::deflate_bytes(metadata);\n     let llmeta = C_bytes(compressed);\n     let llconst = C_struct([llmeta], false);\n-    let mut llglobal = \"rust_metadata\".with_c_str(|buf| {\n+    let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.name,\n+                       cx.link_meta.vers, cx.link_meta.extras_hash);\n+    let llglobal = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.metadata_llmod, val_ty(llconst).to_ref(), buf)\n         }\n@@ -3069,16 +3071,6 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n         cx.sess.targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         });\n-        lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n-\n-        let t_ptr_i8 = Type::i8p();\n-        llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n-        let llvm_used = \"llvm.used\".with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.metadata_llmod,\n-                                Type::array(&t_ptr_i8, 1).to_ref(), buf)\n-        });\n-        lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n-        llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n     }\n     return metadata;\n }\n@@ -3181,20 +3173,27 @@ pub fn trans_crate(sess: session::Session,\n     let llcx = ccx.llcx;\n     let link_meta = ccx.link_meta;\n     let llmod = ccx.llmod;\n-    let crate_types = crate.attrs.iter().filter_map(|a| {\n-        if \"crate_type\" == a.name() {\n-            a.value_str()\n-        } else {\n-            None\n-        }\n-    }).map(|a| a.to_owned()).collect();\n+    let mut reachable = ccx.reachable.iter().filter_map(|id| {\n+        ccx.item_symbols.find(id).map(|s| s.to_owned())\n+    }).to_owned_vec();\n+\n+    // Make sure that some other crucial symbols are not eliminated from the\n+    // module. This includes the main function (main/amain elsewhere), the crate\n+    // map (used for debug log settings and I/O), and finally the curious\n+    // rust_stack_exhausted symbol. This symbol is required for use by the\n+    // libmorestack library that we link in, so we must ensure that this symbol\n+    // is not internalized (if defined in the crate).\n+    reachable.push(ccx.crate_map_name.to_owned());\n+    reachable.push(~\"main\");\n+    reachable.push(~\"amain\");\n+    reachable.push(~\"rust_stack_exhausted\");\n \n     return CrateTranslation {\n         context: llcx,\n         module: llmod,\n         link: link_meta,\n-        crate_types: crate_types,\n         metadata_module: ccx.metadata_llmod,\n         metadata: metadata,\n+        reachable: reachable,\n     };\n }"}, {"sha": "c483a0f48f8c9aab0ef20b456232355db4248724", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -111,6 +111,7 @@ pub struct CrateContext {\n      opaque_vec_type: Type,\n      builder: BuilderRef_res,\n      crate_map: ValueRef,\n+     crate_map_name: ~str,\n      // Set when at least one function uses GC. Needed so that\n      // decl_gc_metadata knows whether to link to the module metadata, which\n      // is not emitted by LLVM's GC pass when no functions use GC.\n@@ -167,7 +168,8 @@ impl CrateContext {\n             tn.associate_type(\"tydesc\", &tydesc_type);\n             tn.associate_type(\"str_slice\", &str_slice_ty);\n \n-            let crate_map = decl_crate_map(sess, link_meta, llmod);\n+            let (crate_map_name, crate_map) = decl_crate_map(sess, link_meta,\n+                                                             llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod, name.to_owned()))\n             } else {\n@@ -238,6 +240,7 @@ impl CrateContext {\n                   opaque_vec_type: opaque_vec_type,\n                   builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                   crate_map: crate_map,\n+                  crate_map_name: crate_map_name,\n                   uses_gc: false,\n                   dbg_cx: dbg_cx,\n                   do_not_commit_warning_issued: false"}, {"sha": "ee068d7e6a149ef5c3ac9f9077c52dc549924248", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -15,14 +15,23 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::hashmap::HashSet;\n+use std::local_data;\n use extra;\n \n pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n+    local_data_key!(depth: uint);\n     if !do_it { return f(u); }\n+\n+    let old = local_data::get(depth, |d| d.map(|a| *a).unwrap_or(0));\n+    local_data::set(depth, old + 1);\n+\n     let start = extra::time::precise_time_s();\n     let rv = f(u);\n     let end = extra::time::precise_time_s();\n-    println!(\"time: {:3.3f} s\\t{}\", end - start, what);\n+\n+    println!(\"{}time: {:3.3f} s\\t{}\", \"  \".repeat(old), end - start, what);\n+    local_data::set(depth, old);\n+\n     rv\n }\n "}, {"sha": "76e24faebd93b9bdeac3222f3532a02448df76fa", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -211,3 +211,11 @@ extern \"C\" void\n LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB, bool AddLifetimes) {\n     unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n }\n+\n+extern \"C\" void\n+LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols, size_t len) {\n+    PassManager passes;\n+    ArrayRef<const char*> ref(symbols, len);\n+    passes.add(llvm::createInternalizePass(ref));\n+    passes.run(*unwrap(M));\n+}"}, {"sha": "fb611dd15c227d4a542834788f59871b62dc5358", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -539,3 +539,22 @@ extern \"C\" char *LLVMTypeToString(LLVMTypeRef Type) {\n     unwrap<llvm::Type>(Type)->print(os);\n     return strdup(os.str().data());\n }\n+\n+extern \"C\" bool\n+LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n+    Module *Dst = unwrap(dst);\n+    MemoryBuffer* buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n+    std::string Err;\n+    Module *Src = llvm::getLazyBitcodeModule(buf, Dst->getContext(), &Err);\n+    if (Src == NULL) {\n+        LLVMRustError = Err.c_str();\n+        delete buf;\n+        return false;\n+    }\n+\n+    if (Linker::LinkModules(Dst, Src, Linker::DestroySource, &Err)) {\n+        LLVMRustError = Err.c_str();\n+        return false;\n+    }\n+    return true;\n+}"}, {"sha": "ee82fa80f8743bc6b9b457271d4f6713f28c58f8", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -629,3 +629,6 @@ LLVMTypeToString\n LLVMAddColdAttribute\n LLVMCreateMemoryBufferWithMemoryRange\n LLVMCreateMemoryBufferWithMemoryRangeCopy\n+LLVMPassManagerBuilderPopulateLTOPassManager\n+LLVMRustLinkInExternalBitcode\n+LLVMRustRunRestrictionPass"}, {"sha": "ef7199a6ca8cc18fb9a78f5ee3e6c24e7fd3121d", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -19,6 +19,7 @@\n #include \"llvm/Analysis/Verifier.h\"\n #include \"llvm/Analysis/Passes.h\"\n #include \"llvm/Analysis/Lint.h\"\n+#include \"llvm/ADT/ArrayRef.h\"\n #include \"llvm/ADT/Triple.h\"\n #include \"llvm/ADT/DenseSet.h\"\n #include \"llvm/Assembly/Parser.h\"\n@@ -47,6 +48,7 @@\n #include \"llvm/Transforms/Vectorize.h\"\n #include \"llvm/DebugInfo.h\"\n #include \"llvm/DIBuilder.h\"\n+#include \"llvm/Bitcode/ReaderWriter.h\"\n #include \"llvm-c/Core.h\"\n #include \"llvm-c/BitReader.h\"\n #include \"llvm-c/ExecutionEngine.h\""}, {"sha": "a491fda7dc232bc17517f1a490a9fd0cc52b50d7", "filename": "src/test/run-make/lto-smoke-c/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -0,0 +1,11 @@\n+-include ../tools.mk\n+\n+ifneq ($(shell uname),Darwin)\n+\tEXTRAFLAGS := -lm -lrt -ldl -lpthread\n+endif\n+\n+all:\n+\t$(RUSTC) foo.rs -Z gen-crate-map -Z lto\n+\tln -s $(call STATICLIB,foo-*) $(call STATICLIB,foo)\n+\t$(CC) bar.c -lfoo -o $(call RUN,bar) $(EXTRAFLAGS) -lstdc++\n+\t$(call RUN,bar)"}, {"sha": "bb4036b06e13b79a32ec78ae04db97590f54b2cc", "filename": "src/test/run-make/lto-smoke-c/bar.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke-c%2Fbar.c", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke-c%2Fbar.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke-c%2Fbar.c?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -0,0 +1,6 @@\n+void foo();\n+\n+int main() {\n+    foo();\n+    return 0;\n+}"}, {"sha": "3da09eb6bb6a87b0eca9600106ec86af9b37cd6c", "filename": "src/test/run-make/lto-smoke-c/foo.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke-c%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke-c%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke-c%2Ffoo.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -0,0 +1,4 @@\n+#[crate_type = \"staticlib\"];\n+\n+#[no_mangle]\n+pub extern \"C\" fn foo() {}"}, {"sha": "4652556d34401e0378d40f530b396b0d2dac7177", "filename": "src/test/run-make/lto-smoke/Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke%2FMakefile?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -0,0 +1,6 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) lib.rs\n+\t$(RUSTC) main.rs -Z lto\n+\t$(call RUN,main)"}, {"sha": "3cdacc96ee9e01f2d2e8fa0316e906581bdafd19", "filename": "src/test/run-make/lto-smoke/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke%2Flib.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -0,0 +1 @@\n+#[crate_type = \"rlib\"];"}, {"sha": "a3ed67729262b33cfb6216e561a5176fe11eccab", "filename": "src/test/run-make/lto-smoke/main.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4a174b9ffff71a66feecd9f4960f17fc9c331/src%2Ftest%2Frun-make%2Flto-smoke%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke%2Fmain.rs?ref=fce4a174b9ffff71a66feecd9f4960f17fc9c331", "patch": "@@ -0,0 +1,3 @@\n+extern mod lib;\n+\n+fn main() {}"}]}