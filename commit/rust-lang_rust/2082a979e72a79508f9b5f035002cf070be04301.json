{"sha": "2082a979e72a79508f9b5f035002cf070be04301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwODJhOTc5ZTcyYTc5NTA4ZjliNWYwMzUwMDJjZjA3MGJlMDQzMDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-10T17:49:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-10T17:52:11Z"}, "message": "remove modes from ty.rs", "tree": {"sha": "a90a3f67dbff98cd2f4f695b7f6c2dc14e0f212a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a90a3f67dbff98cd2f4f695b7f6c2dc14e0f212a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2082a979e72a79508f9b5f035002cf070be04301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2082a979e72a79508f9b5f035002cf070be04301", "html_url": "https://github.com/rust-lang/rust/commit/2082a979e72a79508f9b5f035002cf070be04301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2082a979e72a79508f9b5f035002cf070be04301/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1086b017596c7d21905adaf756010baecc0fb60", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1086b017596c7d21905adaf756010baecc0fb60", "html_url": "https://github.com/rust-lang/rust/commit/e1086b017596c7d21905adaf756010baecc0fb60"}], "stats": {"total": 300, "additions": 159, "deletions": 141}, "files": [{"sha": "d660a07584facabc66d45db8ba40eeac095b53f7", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -745,10 +745,10 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n       }\n-      ty::ty_class(did,substs) => {\n+      ty::ty_class(did, ref substs) => {\n         // Call the dtor if there is one\n         do option::map_default(ty::ty_dtor(bcx.tcx(), did), bcx) |dt_id| {\n-          trans_class_drop(bcx, v, dt_id, did, substs)\n+            trans_class_drop(bcx, v, dt_id, did, substs)\n         }\n       }\n       _ => bcx\n@@ -758,7 +758,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n                     class_did: ast::def_id,\n-                    substs: ty::substs) -> block {\n+                    substs: &ty::substs) -> block {\n   let drop_flag = GEPi(bcx, v0, ~[0u, 0u]);\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n     let mut bcx = cx;\n@@ -805,7 +805,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_unboxed_vec(_) => {\n         tvec::make_drop_glue_unboxed(bcx, v0, t)\n       }\n-      ty::ty_class(did, substs) => {\n+      ty::ty_class(did, ref substs) => {\n         let tcx = bcx.tcx();\n         match ty::ty_dtor(tcx, did) {\n           some(dtor) => {\n@@ -1081,7 +1081,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         }\n         return next_cx;\n       }\n-      ty::ty_class(did, substs) => {\n+      ty::ty_class(did, ref substs) => {\n           // Take the drop bit into account\n           let classptr = if is_some(ty::ty_dtor(cx.tcx(), did)) {\n                   GEPi(cx, av, ~[0u, 1u])\n@@ -1821,7 +1821,7 @@ fn autoderef(cx: block, e_id: ast::node_id,\n             t1 = mt.ty;\n             v1 = v;\n           }\n-          ty::ty_enum(did, substs) => {\n+          ty::ty_enum(did, ref substs) => {\n             let variants = ty::enum_variants(ccx.tcx, did);\n             if (*variants).len() != 1u || variants[0].args.len() != 1u {\n                 break;\n@@ -2034,7 +2034,7 @@ fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n       ty::ty_box(mt) => {\n         some(ty::mk_opaque_box(tcx))\n       }\n-      ty::ty_fn(fty) => {\n+      ty::ty_fn(ref fty) => {\n         some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n                              proto: fty.proto,\n                              bounds: @~[],\n@@ -2562,7 +2562,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n     let mut llderef = false;\n     let fields = match ty::get(ty).struct {\n        ty::ty_rec(fs) => fs,\n-       ty::ty_class(did, substs) => {\n+       ty::ty_class(did, ref substs) => {\n          if option::is_some(ty::ty_dtor(bcx.tcx(), did)) {\n            llderef = true;\n          }\n@@ -3505,7 +3505,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n     // Get the class ID and its fields.\n     let class_fields, class_id, substitutions;\n     match ty::get(struct_type).struct {\n-        ty::ty_class(existing_class_id, existing_substitutions) => {\n+        ty::ty_class(existing_class_id, ref existing_substitutions) => {\n             class_id = existing_class_id;\n             substitutions = existing_substitutions;\n             class_fields = ty::lookup_class_fields(type_context, class_id);\n@@ -4858,8 +4858,9 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   else { selfptr };\n \n   // initialize fields to zero\n+  let dsubsts = dummy_substs(psubsts.tys);\n   let fields = ty::class_items_as_mutable_fields(bcx_top.tcx(), parent_id,\n-                                         dummy_substs(psubsts.tys));\n+                                                 &dsubsts);\n   let mut bcx = bcx_top;\n   // Initialize fields to zero so init assignments can validly\n   // drop their LHS"}, {"sha": "0da00108cba818aff7707a927ef52818f71319f1", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -158,7 +158,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           let (bt, bv) = const_autoderef(cx, bt, bv);\n           let fields = match ty::get(bt).struct {\n               ty::ty_rec(fs) => fs,\n-              ty::ty_class(did, substs) =>\n+              ty::ty_class(did, ref substs) =>\n                   ty::class_items_as_mutable_fields(cx.tcx, did, substs),\n               _ => cx.sess.span_bug(e.span,\n                                     ~\"field access on unknown type in const\"),"}, {"sha": "ae93021583bc8aa19d72c0dd8d447ddd74c541f1", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -221,7 +221,7 @@ impl reflector {\n             self.visit(~\"leave_fn\", extra);\n           }\n \n-          ty::ty_class(did, substs) => {\n+          ty::ty_class(did, ref substs) => {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n             let fields = ty::class_items_as_fields(tcx, did, substs);\n@@ -241,7 +241,7 @@ impl reflector {\n           // not ideal. It'll work but will get costly on big enums. Maybe\n           // let the visitor tell us if it wants to visit only a particular\n           // variant?\n-          ty::ty_enum(did, substs) => {\n+          ty::ty_enum(did, ref substs) => {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n             let variants = ty::substd_enum_variants(tcx, did, substs);"}, {"sha": "4246defbe0f70d2e57d887a4fcd5d207857cfece", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -324,7 +324,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n         s\n       }\n       ty::ty_trait(_, _) => ~[shape_box_fn],\n-      ty::ty_class(did, substs) => {\n+      ty::ty_class(did, ref substs) => {\n         // same as records, unless there's a dtor\n         let tps = substs.tps;\n         let m_dtor_did = ty::ty_dtor(ccx.tcx, did);\n@@ -378,7 +378,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let mut enum_variants = ~[];\n     while i < ccx.shape_cx.tag_order.len() {\n         let {did, substs} = ccx.shape_cx.tag_order[i];\n-        let variants = @ty::substd_enum_variants(ccx.tcx, did, substs);\n+        let variants = @ty::substd_enum_variants(ccx.tcx, did, &substs);\n         do vec::iter(*variants) |v| {\n             offsets += ~[vec::len(data) as u16];\n \n@@ -678,7 +678,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(t) { return cx.enum_sizes.get(t); }\n     match ty::get(t).struct {\n-      ty::ty_enum(tid, substs) => {\n+      ty::ty_enum(tid, ref substs) => {\n         // Compute max(variant sizes).\n         let mut max_size = 0u;\n         let variants = ty::enum_variants(cx.tcx, tid);\n@@ -723,7 +723,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           }\n           // Reduce a class type to a record type in which all the fields are\n           // simplified\n-          ty::ty_class(did, substs) => {\n+          ty::ty_class(did, ref substs) => {\n             let simpl_fields = (if is_some(ty::ty_dtor(tcx, did)) {\n                 // remember the drop flag\n                   ~[{ident: @~\"drop\", mt: {ty:"}, {"sha": "d06862262f252f8aaa1640361372d75f6817bf9b", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -179,11 +179,11 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_enum(did, _) => {\n         fill_type_of_enum(cx, did, t, llty);\n       }\n-      ty::ty_class(did, ts) => {\n+      ty::ty_class(did, ref substs) => {\n         // Only instance vars are record fields at runtime.\n         let fields = ty::lookup_class_fields(cx.tcx, did);\n         let mut tys = do vec::map(fields) |f| {\n-            let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n+            let t = ty::lookup_field_type(cx.tcx, did, f.id, substs);\n             type_of(cx, t)\n         };\n "}, {"sha": "c21ad7c992b63d79bf6e721b8f88e1baa6d0fd72", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -140,7 +140,7 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n                     let seen = @cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n                         for vec::each(v.args) |aty| {\n-                            let t = ty::subst(cx.ccx.tcx, substs, aty);\n+                            let t = ty::subst(cx.ccx.tcx, &substs, aty);\n                             type_needs_inner(cx, use, t, seen);\n                         }\n                     }"}, {"sha": "90ea9b3a6b149d94fc2bcc09eccfe133751847ab", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 100, "deletions": 88, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -1,3 +1,6 @@\n+#[warn(deprecated_mode)];\n+#[warn(deprecated_pattern)];\n+\n import std::{map, smallintmap};\n import result::result;\n import std::map::hashmap;\n@@ -575,7 +578,7 @@ fn mk_ctxt(s: session::session,\n            region_map: middle::region::region_map,\n            region_paramd_items: middle::region::region_paramd_items) -> ctxt {\n     pure fn hash_intern_key(k: &intern_key) -> uint {\n-        hash_type_structure(k.struct) +\n+        hash_type_structure(&k.struct) +\n             option::map_default(k.o_def_id, 0u, |d| ast_util::hash_def(&d))\n     }\n     let interner = map::hashmap(hash_intern_key, sys::shape_eq);\n@@ -615,11 +618,11 @@ fn mk_ctxt(s: session::session,\n \n \n // Type constructors\n-fn mk_t(cx: ctxt, st: sty) -> t { mk_t_with_id(cx, st, none) }\n+fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, none) }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n+fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: option<ast::def_id>) -> t {\n     let key = {struct: st, o_def_id: o_def_id};\n     match cx.interner.find(key) {\n       some(t) => unsafe { return unsafe::reinterpret_cast(t); },\n@@ -634,7 +637,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n             }\n         }\n     }\n-    fn sflags(substs: substs) -> uint {\n+    fn sflags(substs: &substs) -> uint {\n         let mut f = 0u;\n         for substs.tps.each |tt| { f |= get(tt).flags; }\n         substs.self_r.iter(|r| f |= rflags(r));\n@@ -654,7 +657,8 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_param(_) => flags |= has_params as uint,\n       ty_var(_) | ty_var_integral(_) => flags |= needs_infer as uint,\n       ty_self => flags |= has_self as uint,\n-      ty_enum(_, substs) | ty_class(_, substs) | ty_trait(_, substs) => {\n+      ty_enum(_, ref substs) | ty_class(_, ref substs)\n+      | ty_trait(_, ref substs) => {\n         flags |= sflags(substs);\n       }\n       ty_box(m) | ty_uniq(m) | ty_evec(m, _) |\n@@ -667,7 +671,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       }\n       ty_rec(flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n       ty_tup(ts) => for ts.each |tt| { flags |= get(tt).flags; },\n-      ty_fn(f) => {\n+      ty_fn(ref f) => {\n         for f.inputs.each |a| { flags |= get(a.ty).flags; }\n         flags |= get(f.output).flags;\n       }\n@@ -718,7 +722,8 @@ fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))\n }\n \n-fn mk_enum(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n+fn mk_enum(cx: ctxt, did: ast::def_id, +substs: substs) -> t {\n+    // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n \n@@ -763,13 +768,16 @@ fn mk_rec(cx: ctxt, fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n-fn mk_fn(cx: ctxt, fty: fn_ty) -> t { mk_t(cx, ty_fn(fty)) }\n+// take a copy because we want to own the various vectors inside\n+fn mk_fn(cx: ctxt, +fty: fn_ty) -> t { mk_t(cx, ty_fn(fty)) }\n \n-fn mk_trait(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n+fn mk_trait(cx: ctxt, did: ast::def_id, +substs: substs) -> t {\n+    // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_trait(did, substs))\n }\n \n-fn mk_class(cx: ctxt, class_id: ast::def_id, substs: substs) -> t {\n+fn mk_class(cx: ctxt, class_id: ast::def_id, +substs: substs) -> t {\n+    // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_class(class_id, substs))\n }\n \n@@ -845,26 +853,26 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n         for fields.each |fl| { maybe_walk_ty(fl.mt.ty, f); }\n       }\n       ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(tt, f); } }\n-      ty_fn(ft) => {\n+      ty_fn(ref ft) => {\n         for ft.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.output, f);\n       }\n       ty_uniq(tm) => { maybe_walk_ty(tm.ty, f); }\n     }\n }\n \n-fn fold_sty_to_ty(tcx: ty::ctxt, sty: sty, foldop: fn(t) -> t) -> t {\n+fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: fn(t) -> t) -> t {\n     mk_t(tcx, fold_sty(sty, foldop))\n }\n \n-fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n-    fn fold_substs(substs: substs, fldop: fn(t) -> t) -> substs {\n+fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n+    fn fold_substs(substs: &substs, fldop: fn(t) -> t) -> substs {\n         {self_r: substs.self_r,\n          self_ty: substs.self_ty.map(|t| fldop(t)),\n          tps: substs.tps.map(|t| fldop(t))}\n     }\n \n-    match sty {\n+    match *sty {\n       ty_box(tm) => {\n         ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n       }\n@@ -880,10 +888,10 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       ty_evec(tm, vst) => {\n         ty_evec({ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n       }\n-      ty_enum(tid, substs) => {\n+      ty_enum(tid, ref substs) => {\n         ty_enum(tid, fold_substs(substs, fldop))\n       }\n-      ty_trait(did, substs) => {\n+      ty_trait(did, ref substs) => {\n         ty_trait(did, fold_substs(substs, fldop))\n       }\n       ty_rec(fields) => {\n@@ -898,32 +906,32 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n         let new_ts = vec::map(ts, |tt| fldop(tt));\n         ty_tup(new_ts)\n       }\n-      ty_fn(f) => {\n+      ty_fn(ref f) => {\n         let new_args = vec::map(f.inputs, |a| {\n             let new_ty = fldop(a.ty);\n             {mode: a.mode, ty: new_ty}\n         });\n         let new_output = fldop(f.output);\n-        ty_fn({inputs: new_args, output: new_output with f})\n+        ty_fn({inputs: new_args, output: new_output with *f})\n       }\n       ty_rptr(r, tm) => {\n         ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n       }\n-      ty_class(did, substs) => {\n+      ty_class(did, ref substs) => {\n         ty_class(did, fold_substs(substs, fldop))\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n       ty_opaque_box | ty_var(_) | ty_var_integral(_) |\n       ty_param(*) | ty_self => {\n-        sty\n+        *sty\n       }\n     }\n }\n \n // Folds types from the bottom up.\n fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n-    let sty = fold_sty(get(t0).struct, |t| fold_ty(cx, fldop(t), fldop));\n+    let sty = fold_sty(&get(t0).struct, |t| fold_ty(cx, fldop(t), fldop));\n     fldop(mk_t(cx, sty))\n }\n \n@@ -950,7 +958,7 @@ fn fold_regions_and_ty(\n     fldt: fn(t: t) -> t) -> t {\n \n     fn fold_substs(\n-        substs: substs,\n+        substs: &substs,\n         fldr: fn(r: region) -> region,\n         fldt: fn(t: t) -> t) -> substs {\n \n@@ -975,19 +983,19 @@ fn fold_regions_and_ty(\n         let m_t = fldt(mt.ty);\n         ty::mk_evec(cx, {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n       }\n-      ty_enum(def_id, substs) => {\n+      ty_enum(def_id, ref substs) => {\n         ty::mk_enum(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      ty_class(def_id, substs) => {\n+      ty_class(def_id, ref substs) => {\n         ty::mk_class(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      ty_trait(def_id, substs) => {\n+      ty_trait(def_id, ref substs) => {\n         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      sty @ ty_fn(_) => {\n+      ref sty @ ty_fn(_) => {\n         fold_sty_to_ty(cx, sty, |t| fldfnt(t))\n       }\n-      sty => {\n+      ref sty => {\n         fold_sty_to_ty(cx, sty, |t| fldt(t))\n       }\n     }\n@@ -1036,7 +1044,7 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n             // do not recurse into functions, which introduce fresh bindings\n             t0\n           }\n-          sty => {\n+          ref sty => {\n             do fold_sty_to_ty(cx, sty) |t| {\n                 do_fold(cx, t, under_r, fldop)\n             }\n@@ -1054,25 +1062,25 @@ fn subst_tps(cx: ctxt, tps: ~[t], typ: t) -> t {\n     if !tbox_has_flag(tb, has_params) { return typ; }\n     match tb.struct {\n       ty_param(p) => tps[p.idx],\n-      sty => fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, t))\n+      ref sty => fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, t))\n     }\n }\n \n-fn substs_is_noop(substs: substs) -> bool {\n+fn substs_is_noop(substs: &substs) -> bool {\n     substs.tps.len() == 0u &&\n         substs.self_r.is_none() &&\n         substs.self_ty.is_none()\n }\n \n-fn substs_to_str(cx: ctxt, substs: substs) -> ~str {\n+fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n     fmt!{\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n          substs.self_r.map_default(~\"none\", |r| region_to_str(cx, r)),\n          substs.self_ty.map_default(~\"none\", |t| ty_to_str(cx, t)),\n          substs.tps.map(|t| ty_to_str(cx, t))}\n }\n \n fn subst(cx: ctxt,\n-         substs: substs,\n+         substs: &substs,\n          typ: t) -> t {\n \n     debug!{\"subst(substs=%s, typ=%s)\",\n@@ -1085,7 +1093,7 @@ fn subst(cx: ctxt,\n     return r;\n \n     fn do_subst(cx: ctxt,\n-                substs: substs,\n+                substs: &substs,\n                 typ: t) -> t {\n         let tb = get(typ);\n         if !tbox_has_flag(tb, needs_subst) { return typ; }\n@@ -1273,7 +1281,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         }\n         accum\n       }\n-      ty_class(did, substs) => {\n+      ty_class(did, ref substs) => {\n          // Any class with a dtor needs a drop\n          option::is_some(ty_dtor(cx, did)) || {\n              for vec::each(ty::class_items_as_fields(cx, did, substs)) |f| {\n@@ -1286,7 +1294,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n           for elts.each |m| { if type_needs_drop(cx, m) { accum = true; } }\n         accum\n       }\n-      ty_enum(did, substs) => {\n+      ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n           for vec::each(*variants) |variant| {\n               for variant.args.each |aty| {\n@@ -1298,7 +1306,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         }\n         accum\n       }\n-      ty_fn(fty) => {\n+      ty_fn(ref fty) => {\n         match fty.proto {\n           proto_bare | proto_block => false,\n           _ => true\n@@ -1352,7 +1360,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n           ty_rec(_) | ty_tup(_) | ty_ptr(_) => {\n             true\n           }\n-          ty_enum(did, substs) => {\n+          ty_enum(did, ref substs) => {\n             for vec::each(*enum_variants(cx, did)) |v| {\n                 for v.args.each |aty| {\n                     let t = subst(cx, substs, aty);\n@@ -1621,7 +1629,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n \n       // functions depend on the protocol\n-      ty_fn(f) => proto_kind(f.proto),\n+      ty_fn(ref f) => proto_kind(f.proto),\n \n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n@@ -1682,7 +1690,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         lowest\n       }\n \n-      ty_class(did, substs) => {\n+      ty_class(did, ref substs) => {\n         // Classes are sendable if all their fields are sendable,\n         // likewise for copyable...\n         // also factor out this code, copied from the records case\n@@ -1707,7 +1715,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n \n       // Enums lower to the lowest of their variants.\n-      ty_enum(did, substs) => {\n+      ty_enum(did, ref substs) => {\n         let mut lowest = kind_top();\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 0u {\n@@ -1782,7 +1790,7 @@ fn type_size(cx: ctxt, ty: t) -> uint {\n         flds.foldl(0, |s, f| s + type_size(cx, f.mt.ty))\n       }\n \n-      ty_class(did, substs) => {\n+      ty_class(did, ref substs) => {\n         let flds = class_items_as_fields(cx, did, substs);\n         flds.foldl(0, |s, f| s + type_size(cx, f.mt.ty))\n       }\n@@ -1791,7 +1799,7 @@ fn type_size(cx: ctxt, ty: t) -> uint {\n         tys.foldl(0, |s, t| s + type_size(cx, t))\n       }\n \n-      ty_enum(did, substs) => {\n+      ty_enum(did, ref substs) => {\n         let variants = substd_enum_variants(cx, did, substs);\n         variants.foldl( // find max size of any variant\n             0,\n@@ -1885,7 +1893,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false\n           }\n \n-          ty_class(did, substs) => {\n+          ty_class(did, ref substs) => {\n             vec::push(*seen, did);\n             let r = vec::any(class_items_as_fields(cx, did, substs),\n                              |f| type_requires(cx, seen, r_ty, f.mt.ty));\n@@ -1901,7 +1909,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false\n           }\n \n-          ty_enum(did, substs) => {\n+          ty_enum(did, ref substs) => {\n             vec::push(*seen, did);\n             let vs = enum_variants(cx, did);\n             let r = vec::len(*vs) > 0u && vec::all(*vs, |variant| {\n@@ -1927,13 +1935,13 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     !subtypes_require(cx, seen, r_ty, r_ty)\n }\n \n-fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n+fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n    bool {\n-    let sty = get(ty).struct;\n+    let sty = &get(ty).struct;\n     debug!{\"type_structurally_contains: %s\", ty_to_str(cx, ty)};\n     if test(sty) { return true; }\n-    match sty {\n-      ty_enum(did, substs) => {\n+    match *sty {\n+      ty_enum(did, ref substs) => {\n         for vec::each(*enum_variants(cx, did)) |variant| {\n             for variant.args.each |aty| {\n                 let sty = subst(cx, substs, aty);\n@@ -1950,7 +1958,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n         }\n         return false;\n       }\n-      ty_class(did, substs) => {\n+      ty_class(did, ref substs) => {\n         for lookup_class_fields(cx, did).each |field| {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n             if type_structurally_contains(cx, ft, test) { return true; }\n@@ -1973,7 +1981,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n \n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n     return type_structurally_contains(cx, ty, |sty| {\n-        match sty {\n+        match *sty {\n           ty_uniq(_) |\n           ty_evec(_, vstore_uniq) |\n           ty_estr(vstore_uniq) => true,\n@@ -2021,7 +2029,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_evec(_, vstore_uniq) | ty_evec(_, vstore_box) |\n       ty_trait(_, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n       // Structural types\n-      ty_enum(did, substs) => {\n+      ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n         for vec::each(*variants) |variant| {\n             let tup_ty = mk_tup(cx, variant.args);\n@@ -2045,7 +2053,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       }\n       ty_param(_) => result = false,\n       ty_opaque_closure_ptr(_) => result = true,\n-      ty_class(did, substs) => {\n+      ty_class(did, ref substs) => {\n         result = vec::any(lookup_class_fields(cx, did), |f| {\n             let fty = ty::lookup_item_type(cx, f.id);\n             let sty = subst(cx, substs, fty.ty);\n@@ -2076,7 +2084,7 @@ fn type_is_enum(ty: t) -> bool {\n // constructors\n fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     match get(ty).struct {\n-      ty_enum(did, substs) => {\n+      ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n         let some_n_ary = vec::any(*variants, |v| vec::len(v.args) > 0u);\n         return !some_n_ary;\n@@ -2098,10 +2106,10 @@ fn type_param(ty: t) -> option<uint> {\n // The parameter `expl` indicates if this is an *explicit* dereference.  Some\n // types---notably unsafe ptrs---can only be dereferenced explicitly.\n fn deref(cx: ctxt, t: t, expl: bool) -> option<mt> {\n-    deref_sty(cx, get(t).struct, expl)\n+    deref_sty(cx, &get(t).struct, expl)\n }\n-fn deref_sty(cx: ctxt, sty: sty, expl: bool) -> option<mt> {\n-    match sty {\n+fn deref_sty(cx: ctxt, sty: &sty, expl: bool) -> option<mt> {\n+    match *sty {\n       ty_rptr(_, mt) | ty_box(mt) | ty_uniq(mt) => {\n         some(mt)\n       }\n@@ -2110,7 +2118,7 @@ fn deref_sty(cx: ctxt, sty: sty, expl: bool) -> option<mt> {\n         some(mt)\n       }\n \n-      ty_enum(did, substs) => {\n+      ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 1u && vec::len(variants[0].args) == 1u {\n             let v_t = subst(cx, substs, variants[0].args[0]);\n@@ -2136,11 +2144,11 @@ fn type_autoderef(cx: ctxt, t: t) -> t {\n \n // Returns the type and mutability of t[i]\n fn index(cx: ctxt, t: t) -> option<mt> {\n-    index_sty(cx, get(t).struct)\n+    index_sty(cx, &get(t).struct)\n }\n \n-fn index_sty(cx: ctxt, sty: sty) -> option<mt> {\n-    match sty {\n+fn index_sty(cx: ctxt, sty: &sty) -> option<mt> {\n+    match *sty {\n       ty_evec(mt, _) => some(mt),\n       ty_estr(_) => some({ty: mk_u8(cx), mutbl: ast::m_imm}),\n       _ => none\n@@ -2161,7 +2169,7 @@ fn br_hashmap<V:copy>() -> hashmap<bound_region, V> {\n }\n \n // Type hashing.\n-pure fn hash_type_structure(st: sty) -> uint {\n+pure fn hash_type_structure(st: &sty) -> uint {\n     pure fn hash_uint(id: uint, n: uint) -> uint { (id << 2u) + n }\n     pure fn hash_def(id: uint, did: ast::def_id) -> uint {\n         let h = (id << 2u) + (did.crate as uint);\n@@ -2185,11 +2193,11 @@ pure fn hash_type_structure(st: sty) -> uint {\n           re_bot        => 4u\n         }\n     }\n-    pure fn hash_substs(h: uint, substs: substs) -> uint {\n+    pure fn hash_substs(h: uint, substs: &substs) -> uint {\n         let h = hash_subtys(h, substs.tps);\n         h + substs.self_r.map_default(0u, |r| hash_region(&r))\n     }\n-    match st {\n+    match *st {\n       ty_nil => 0u,\n       ty_bool => 1u,\n       ty_int(t) => match t {\n@@ -2213,7 +2221,7 @@ pure fn hash_type_structure(st: sty) -> uint {\n         ast::ty_f64 => 15u\n       },\n       ty_estr(_) => 16u,\n-      ty_enum(did, substs) => {\n+      ty_enum(did, ref substs) => {\n         let mut h = hash_def(18u, did);\n         hash_substs(h, substs)\n       }\n@@ -2226,7 +2234,7 @@ pure fn hash_type_structure(st: sty) -> uint {\n         for vec::each(fields) |f| { h = hash_subty(h, f.mt.ty); }\n         h\n       }\n-      ty_fn(f) => {\n+      ty_fn(ref f) => {\n         let mut h = 27u;\n         for vec::each(f.inputs) |a| { h = hash_subty(h, a.ty); }\n         hash_subty(h, f.output)\n@@ -2239,15 +2247,15 @@ pure fn hash_type_structure(st: sty) -> uint {\n       ty_bot => 34u,\n       ty_ptr(mt) => hash_subty(35u, mt.ty),\n       ty_uniq(mt) => hash_subty(37u, mt.ty),\n-      ty_trait(did, substs) => {\n+      ty_trait(did, ref substs) => {\n         let mut h = hash_def(40u, did);\n         hash_substs(h, substs)\n       }\n       ty_opaque_closure_ptr(ck_block) => 41u,\n       ty_opaque_closure_ptr(ck_box) => 42u,\n       ty_opaque_closure_ptr(ck_uniq) => 43u,\n       ty_opaque_box => 44u,\n-      ty_class(did, substs) => {\n+      ty_class(did, ref substs) => {\n         let mut h = hash_def(45u, did);\n         hash_substs(h, substs)\n       }\n@@ -2280,28 +2288,28 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n // Type accessors for substructures of types\n fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).struct {\n-      ty_fn(f) => f.inputs,\n+      ty_fn(ref f) => f.inputs,\n       _ => fail ~\"ty_fn_args() called on non-fn type\"\n     }\n }\n \n fn ty_fn_proto(fty: t) -> ast::proto {\n     match get(fty).struct {\n-      ty_fn(f) => f.proto,\n+      ty_fn(ref f) => f.proto,\n       _ => fail ~\"ty_fn_proto() called on non-fn type\"\n     }\n }\n \n pure fn ty_fn_ret(fty: t) -> t {\n     match get(fty).struct {\n-      ty_fn(f) => f.output,\n+      ty_fn(ref f) => f.output,\n       _ => fail ~\"ty_fn_ret() called on non-fn type\"\n     }\n }\n \n fn ty_fn_ret_style(fty: t) -> ast::ret_style {\n     match get(fty).struct {\n-      ty_fn(f) => f.ret_style,\n+      ty_fn(ref f) => f.ret_style,\n       _ => fail ~\"ty_fn_ret_style() called on non-fn type\"\n     }\n }\n@@ -2321,7 +2329,7 @@ fn ty_region(ty: t) -> region {\n }\n \n // Returns a vec of all the input and output types of fty.\n-fn tys_in_fn_ty(fty: fn_ty) -> ~[t] {\n+fn tys_in_fn_ty(fty: &fn_ty) -> ~[t] {\n     vec::append_one(fty.inputs.map(|a| a.ty), fty.output)\n }\n \n@@ -2348,7 +2356,7 @@ fn ty_var_integral_id(typ: t) -> tvi_vid {\n }\n \n // Type accessors for AST nodes\n-fn block_ty(cx: ctxt, b: ast::blk) -> t {\n+fn block_ty(cx: ctxt, b: &ast::blk) -> t {\n     return node_id_to_type(cx, b.node.id);\n }\n \n@@ -2416,7 +2424,7 @@ fn get_fields(rec_ty:t) -> ~[field] {\n     }\n }\n \n-fn method_idx(id: ast::ident, meths: ~[method]) -> option<uint> {\n+fn method_idx(id: ast::ident, meths: &[method]) -> option<uint> {\n     let mut i = 0u;\n     for meths.each |m| { if m.ident == id { return some(i); } i += 1u; }\n     return none;\n@@ -2473,7 +2481,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n // Maintains a little union-set tree for inferred modes.  `canon()` returns\n // the current head value for `m0`.\n fn canon<T:copy>(tbl: hashmap<ast::node_id, ast::inferable<T>>,\n-                 m0: ast::inferable<T>) -> ast::inferable<T> {\n+                 +m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n       ast::infer(id) => match tbl.find(id) {\n         none => m0,\n@@ -2566,12 +2574,12 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     }\n }\n \n-fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n+fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     fn terr_vstore_kind_to_str(k: terr_vstore_kind) -> ~str {\n         match k { terr_vec => ~\"[]\", terr_str => ~\"str\" }\n     }\n \n-    match err {\n+    match *err {\n       terr_mismatch => return ~\"types differ\",\n       terr_ret_style_mismatch(expect, actual) => {\n         fn to_str(s: ast::ret_style) -> ~str {\n@@ -2635,7 +2643,7 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n                  vstore_to_str(cx, a_vs)};\n       }\n       terr_in_field(err, fname) => {\n-        return fmt!{\"in field `%s`, %s\", *fname, type_err_to_str(cx, *err)};\n+        return fmt!{\"in field `%s`, %s\", *fname, type_err_to_str(cx, err)};\n       }\n       terr_sorts(exp, act) => {\n         return fmt!{\"%s vs %s\", ty_sort_str(cx, exp), ty_sort_str(cx, act)};\n@@ -2731,7 +2739,7 @@ type variant_info = @{args: ~[t], ctor_ty: t, name: ast::ident,\n \n fn substd_enum_variants(cx: ctxt,\n                         id: ast::def_id,\n-                        substs: substs) -> ~[variant_info] {\n+                        substs: &substs) -> ~[variant_info] {\n     do vec::map(*enum_variants(cx, id)) |variant_info| {\n         let substd_args = vec::map(variant_info.args,\n                                    |aty| subst(cx, substs, aty));\n@@ -2930,7 +2938,7 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the class is generic\n fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n-                     substs: substs) -> ty::t {\n+                     substs: &substs) -> ty::t {\n \n     let t = if id.crate == ast::local_crate {\n         node_id_to_type(tcx, id.node)\n@@ -3056,23 +3064,27 @@ fn class_field_tys(items: ~[@class_member]) -> ~[field_ty] {\n // Keep in mind that this function reports that all fields are\n // mutable, regardless of how they were declared. It's meant to\n // be used in trans.\n-fn class_items_as_mutable_fields(cx:ctxt, did: ast::def_id,\n-                         substs: substs) -> ~[field] {\n+fn class_items_as_mutable_fields(cx:ctxt,\n+                                 did: ast::def_id,\n+                                 substs: &substs) -> ~[field] {\n     class_item_fields(cx, did, substs, |_mt| m_mutbl)\n }\n \n // Same as class_items_as_mutable_fields, but doesn't change\n // mutability.\n-fn class_items_as_fields(cx:ctxt, did: ast::def_id,\n-                         substs: substs) -> ~[field] {\n+fn class_items_as_fields(cx:ctxt,\n+                         did: ast::def_id,\n+                         substs: &substs) -> ~[field] {\n     class_item_fields(cx, did, substs, |mt| match mt {\n       class_mutable => m_mutbl,\n         class_immutable => m_imm })\n }\n \n \n-fn class_item_fields(cx:ctxt, did: ast::def_id,\n-  substs: substs, frob_mutability: fn(class_mutability) -> mutability)\n+fn class_item_fields(cx:ctxt,\n+                     did: ast::def_id,\n+                     substs: &substs,\n+                     frob_mutability: fn(class_mutability) -> mutability)\n     -> ~[field] {\n     let mut rslt = ~[];\n     for lookup_class_fields(cx, did).each |f| {\n@@ -3216,7 +3228,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n     // types, which isn't necessary after #2187\n     let t = mk_t(cx, mach_sty(cx.sess.targ_cfg, t));\n \n-    let sty = fold_sty(get(t).struct, |t| { normalize_ty(cx, t) });\n+    let sty = fold_sty(&get(t).struct, |t| { normalize_ty(cx, t) });\n     let t_norm = mk_t(cx, sty);\n     cx.normalized_cache.insert(t, t_norm);\n     return t_norm;"}, {"sha": "35ef1d5406e41351d1739797d8ef9880560a2f54", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -223,7 +223,7 @@ fn require_same_types(\n \n     match infer::mk_eqty(l_infcx, t1, t2) {\n       result::ok(()) => true,\n-      result::err(terr) => {\n+      result::err(ref terr) => {\n         l_tcx.sess.span_err(span, msg() + ~\": \" +\n             ty::type_err_to_str(l_tcx, terr));\n         false"}, {"sha": "fa9727e41222d364e86021fc41a3928fe724dd5b", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -125,7 +125,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, a_t));\n \n     let substs = {self_r:self_r, self_ty:none, tps:tps};\n-    {substs: substs, ty: ty::subst(tcx, substs, decl_ty)}\n+    {substs: substs, ty: ty::subst(tcx, &substs, decl_ty)}\n }\n \n fn ast_path_to_ty<AC: ast_conv, RS: region_scope copy owned>("}, {"sha": "8dea6d6cfba4ca18f3fd301db7c383a434b480d1", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -547,13 +547,13 @@ impl @fn_ctxt {\n         self.node_types.insert(node_id, ty);\n     }\n     fn write_substs(node_id: ast::node_id, +substs: ty::substs) {\n-        if !ty::substs_is_noop(substs) {\n+        if !ty::substs_is_noop(&substs) {\n             self.node_type_substs.insert(node_id, substs);\n         }\n     }\n     fn write_ty_substs(node_id: ast::node_id, ty: ty::t,\n                        +substs: ty::substs) {\n-        let ty = ty::subst(self.tcx(), substs, ty);\n+        let ty = ty::subst(self.tcx(), &substs, ty);\n         self.write_ty(node_id, ty);\n         self.write_substs(node_id, substs);\n     }\n@@ -604,7 +604,7 @@ impl @fn_ctxt {\n     }\n \n     fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n-                               err: ty::type_err) {\n+                               err: &ty::type_err) {\n         self.ccx.tcx.sess.span_err(\n             sp,\n             fmt!{\"mismatched types: expected `%s` but found `%s` (%s)\",\n@@ -694,7 +694,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n         }\n \n         // Otherwise, deref if type is derefable:\n-        match ty::deref_sty(fcx.ccx.tcx, sty, false) {\n+        match ty::deref_sty(fcx.ccx.tcx, &sty, false) {\n           none => return t1,\n           some(mt) => t1 = mt.ty\n         }\n@@ -782,15 +782,17 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n     let tps = fcx.infcx.next_ty_vars(n_tps);\n \n     let substs = {self_r: self_r, self_ty: none, tps: tps};\n-    let substd_ty = ty::subst(tcx, substs, raw_ty);\n+    let substd_ty = ty::subst(tcx, &substs, raw_ty);\n     {substs: substs, ty: substd_ty}\n }\n \n // Only for fields! Returns <none> for methods>\n // Indifferent to privacy flags\n-fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n-                   items:~[ty::field_ty], fieldname: ast::ident,\n-                   substs: ty::substs) -> option<ty::t> {\n+fn lookup_field_ty(tcx: ty::ctxt,\n+                   class_id: ast::def_id,\n+                   items: &[ty::field_ty],\n+                   fieldname: ast::ident,\n+                   substs: &ty::substs) -> option<ty::t> {\n \n     let o_field = vec::find(items, |f| f.ident == fieldname);\n     do option::map(o_field) |f| {\n@@ -1201,7 +1203,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               else {\n                   lookup_public_fields(tcx, base_id)\n               };\n-              match lookup_field_ty(tcx, base_id, cls_items, field, substs) {\n+              match lookup_field_ty(tcx, base_id, cls_items, field, &substs) {\n                  some(field_ty) => {\n                     // (2) look up what field's type is, and return it\n                      fcx.write_ty(expr.id, field_ty);\n@@ -1354,7 +1356,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               _ => { /*ok*/ }\n             }\n \n-            match ty::deref_sty(tcx, sty, true) {\n+            match ty::deref_sty(tcx, &sty, true) {\n               some(mt) => { oprnd_t = mt.ty }\n               none => {\n                 match sty {\n@@ -1773,7 +1775,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             tps: type_parameters\n         };\n \n-        let struct_type = ty::subst(tcx, substitutions, raw_type);\n+        let struct_type = ty::subst(tcx, &substitutions, raw_type);\n \n         // Look up the class fields and build up a map.\n         let class_fields = ty::lookup_class_fields(tcx, class_id);\n@@ -1802,7 +1804,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 some((field_id, false)) => {\n                     let expected_field_type =\n                         ty::lookup_field_type(tcx, class_id, field_id,\n-                                              substitutions);\n+                                              &substitutions);\n                     bot |= check_expr(fcx,\n                                       field.node.expr,\n                                       some(expected_field_type));\n@@ -1855,7 +1857,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let base_t = do_autoderef(fcx, expr.span, raw_base_t);\n         bot |= check_expr(fcx, idx, none);\n         let idx_t = fcx.expr_ty(idx);\n-        match ty::index_sty(tcx, structure_of(fcx, expr.span, base_t)) {\n+        let base_sty = structure_of(fcx, expr.span, base_t);\n+        match ty::index_sty(tcx, &base_sty) {\n           some(mt) => {\n             require_integral(fcx, idx.span, idx_t);\n             fcx.write_ty(id, mt.ty);\n@@ -2122,7 +2125,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     // Check that it is possible to represent this enum:\n     let mut outer = true, did = local_def(id);\n     if ty::type_structurally_contains(ccx.tcx, rty, |sty| {\n-        match sty {\n+        match *sty {\n           ty::ty_enum(id, _) if id == did => {\n             if outer { outer = false; false }\n             else { true }"}, {"sha": "32ddd84b60761c0ea84d2a7074802d48cd855371", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -67,7 +67,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n \n     // Take the enum type params out of `expected`.\n     match structure_of(pcx.fcx, pat.span, expected) {\n-      ty::ty_enum(_, expected_substs) => {\n+      ty::ty_enum(_, ref expected_substs) => {\n         // check that the type of the value being matched is a subtype\n         // of the type of the pattern:\n         let pat_ty = fcx.node_ty(pat.id);\n@@ -236,7 +236,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         // Grab the class data that we care about.\n         let class_fields, class_id, substitutions;\n         match structure_of(fcx, pat.span, expected) {\n-            ty::ty_class(cid, substs) => {\n+            ty::ty_class(cid, ref substs) => {\n                 class_id = cid;\n                 substitutions = substs;\n                 class_fields = ty::lookup_class_fields(tcx, class_id);"}, {"sha": "224de47f0ccae7e5cb115a7bc6607f14edfbb109", "filename": "src/rustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -8,7 +8,7 @@ fn suptype(fcx: @fn_ctxt, sp: span,\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx, actual, expected) {\n       result::ok(()) => { /* ok */ }\n-      result::err(err) => {\n+      result::err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, actual, err);\n       }\n     }\n@@ -19,7 +19,7 @@ fn eqtype(fcx: @fn_ctxt, sp: span,\n \n     match infer::mk_eqty(fcx.infcx, actual, expected) {\n       result::ok(()) => { /* ok */ }\n-      result::err(err) => {\n+      result::err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, actual, err);\n       }\n     }\n@@ -31,7 +31,7 @@ fn assign(fcx: @fn_ctxt, sp: span, borrow_lb: ast::node_id,\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, borrow_lb, expr_ty, expected) {\n       result::ok(()) => { /* ok */ }\n-      result::err(err) => {\n+      result::err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, expr_ty, err);\n       }\n     }"}, {"sha": "401b07031bef6e005a7b3800b8aaef5cc71f893e", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -20,7 +20,7 @@ fn replace_bound_regions_in_fn_ty(\n       none => none\n     };\n \n-    let mut all_tys = ty::tys_in_fn_ty(*fn_ty);\n+    let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n \n     for self_ty.each |t| { vec::push(all_tys, t) }\n \n@@ -35,7 +35,8 @@ fn replace_bound_regions_in_fn_ty(\n         debug!{\"br=%?\", br};\n         mapf(br)\n     };\n-    let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(*fn_ty), |t| {\n+    let ty_fn = ty::ty_fn(*fn_ty);\n+    let t_fn = ty::fold_sty_to_ty(tcx, &ty_fn, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n     let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, t));"}, {"sha": "c283b0cb96fe1ff6d8fe3cd05dc5491574df5269", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -10,8 +10,10 @@ fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     })\n }\n \n-fn lookup_vtables(fcx: @fn_ctxt, sp: span,\n-                  bounds: @~[ty::param_bounds], substs: ty::substs,\n+fn lookup_vtables(fcx: @fn_ctxt,\n+                  sp: span,\n+                  bounds: @~[ty::param_bounds],\n+                  substs: &ty::substs,\n                   allow_unsafe: bool) -> vtable_res {\n     let tcx = fcx.ccx.tcx;\n     let mut result = ~[], i = 0u;\n@@ -156,7 +158,7 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                                 of_ty %s\",\n                                fcx.infcx.ty_to_str(trait_ty),\n                                fcx.infcx.ty_to_str(of_ty)};\n-                        let of_ty = ty::subst(tcx, substs, of_ty);\n+                        let of_ty = ty::subst(tcx, &substs, of_ty);\n                         relate_trait_tys(fcx, sp, trait_ty, of_ty);\n \n                         // recursively process the bounds\n@@ -165,7 +167,7 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                                                     substs);\n                         connect_trait_tps(fcx, sp, substs_f.tps,\n                                           trait_tps, im.did);\n-                        let subres = lookup_vtables(fcx, sp, im_bs, substs_f,\n+                        let subres = lookup_vtables(fcx, sp, im_bs, &substs_f,\n                                                     false);\n                         vec::push(found,\n                                   vtable_static(im.did, substs_f.tps,\n@@ -229,7 +231,7 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n     match ex.node {\n       ast::expr_path(*) => {\n         match fcx.opt_node_ty_substs(ex.id) {\n-          some(substs) => {\n+          some(ref substs) => {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             if has_trait_bounds(*item_ty.bounds) {\n@@ -259,7 +261,7 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n                 cx.vtable_map.insert(callee_id, lookup_vtables(fcx,\n                                                                ex.span,\n                                                                bounds,\n-                                                               substs,\n+                                                               &substs,\n                                                                false));\n             }\n           }"}, {"sha": "e54238e6c6942bbc2395c4b3fa350c7f62fbb24b", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -410,7 +410,7 @@ class CoherenceChecker {\n             tps: type_parameters\n         };\n \n-        return subst(self.crate_context.tcx, substitutions, polytype.ty);\n+        return subst(self.crate_context.tcx, &substitutions, polytype.ty);\n     }\n \n     fn get_self_type_for_implementation(implementation: @Impl)"}, {"sha": "477ea6d0e344b1cf2a604145b8956676cf3b3be7", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2082a979e72a79508f9b5f035002cf070be04301/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2082a979e72a79508f9b5f035002cf070be04301", "patch": "@@ -186,8 +186,7 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id) {\n \n         let substs = { self_r: none, self_ty: some(self_param),\n                        tps: non_shifted_trait_tps + shifted_method_tps };\n-\n-        let ty = ty::subst(ccx.tcx, substs, ty::mk_fn(ccx.tcx, m.fty));\n+        let ty = ty::subst(ccx.tcx, &substs, ty::mk_fn(ccx.tcx, m.fty));\n         let trait_ty = ty::node_id_to_type(ccx.tcx, id);\n         let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n                        + *m.tps);\n@@ -293,7 +292,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n             tps: vec::append(trait_substs.tps, dummy_tps)\n         };\n         let trait_fty = ty::mk_fn(tcx, trait_m.fty);\n-        ty::subst(tcx, substs, trait_fty)\n+        ty::subst(tcx, &substs, trait_fty)\n     };\n     require_same_types(\n         tcx, none, sp, impl_fty, trait_fty,"}]}