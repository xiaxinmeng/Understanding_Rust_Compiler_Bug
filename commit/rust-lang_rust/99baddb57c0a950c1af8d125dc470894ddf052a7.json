{"sha": "99baddb57c0a950c1af8d125dc470894ddf052a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YmFkZGI1N2MwYTk1MGMxYWY4ZDEyNWRjNDcwODk0ZGRmMDUyYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-15T11:31:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-15T11:31:03Z"}, "message": "Auto merge of #78068 - RalfJung:union-safe-assign, r=nikomatsakis\n\nconsider assignments of union field of ManuallyDrop type safe\n\nAssigning to `Copy` union fields is safe because that assignment will never drop anything. However, with https://github.com/rust-lang/rust/pull/77547, unions may also have `ManuallyDrop` fields, and their assignments are currently still unsafe. That seems unnecessary though, as assigning `ManuallyDrop` does not drop anything either, and is thus safe even for union fields.\n\nI assume this will at least require FCP.", "tree": {"sha": "0167f584943b95073727c0c1fa4ab84aebde1e35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0167f584943b95073727c0c1fa4ab84aebde1e35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99baddb57c0a950c1af8d125dc470894ddf052a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99baddb57c0a950c1af8d125dc470894ddf052a7", "html_url": "https://github.com/rust-lang/rust/commit/99baddb57c0a950c1af8d125dc470894ddf052a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99baddb57c0a950c1af8d125dc470894ddf052a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e99a89c7c0b6865a680a2d6169847ec8acc001d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e99a89c7c0b6865a680a2d6169847ec8acc001d3", "html_url": "https://github.com/rust-lang/rust/commit/e99a89c7c0b6865a680a2d6169847ec8acc001d3"}, {"sha": "0bb82c4a059934f78a67ff0ff9e4517171ad1dab", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb82c4a059934f78a67ff0ff9e4517171ad1dab", "html_url": "https://github.com/rust-lang/rust/commit/0bb82c4a059934f78a67ff0ff9e4517171ad1dab"}], "stats": {"total": 278, "additions": 172, "deletions": 106}, "files": [{"sha": "ad48c3510484b03bb7a731443838809ec425fd57", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99baddb57c0a950c1af8d125dc470894ddf052a7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99baddb57c0a950c1af8d125dc470894ddf052a7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=99baddb57c0a950c1af8d125dc470894ddf052a7", "patch": "@@ -1756,6 +1756,21 @@ impl<'tcx> Place<'tcx> {\n     pub fn as_ref(&self) -> PlaceRef<'tcx> {\n         PlaceRef { local: self.local, projection: &self.projection }\n     }\n+\n+    /// Iterate over the projections in evaluation order, i.e., the first element is the base with\n+    /// its projection and then subsequently more projections are added.\n+    /// As a concrete example, given the place a.b.c, this would yield:\n+    /// - (a, .b)\n+    /// - (a.b, .c)\n+    /// Given a place without projections, the iterator is empty.\n+    pub fn iter_projections(\n+        self,\n+    ) -> impl Iterator<Item = (PlaceRef<'tcx>, PlaceElem<'tcx>)> + DoubleEndedIterator {\n+        self.projection.iter().enumerate().map(move |(i, proj)| {\n+            let base = PlaceRef { local: self.local, projection: &self.projection[..i] };\n+            (base, proj)\n+        })\n+    }\n }\n \n impl From<Local> for Place<'_> {"}, {"sha": "89a93096f1c22689727a164454c5bc7651996396", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99baddb57c0a950c1af8d125dc470894ddf052a7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99baddb57c0a950c1af8d125dc470894ddf052a7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=99baddb57c0a950c1af8d125dc470894ddf052a7", "patch": "@@ -46,7 +46,7 @@ pub enum UnsafetyViolationDetails {\n     UseOfMutableStatic,\n     UseOfExternStatic,\n     DerefOfRawPointer,\n-    AssignToNonCopyUnionField,\n+    AssignToDroppingUnionField,\n     AccessToUnionField,\n     MutationOfLayoutConstrainedField,\n     BorrowOfLayoutConstrainedField,\n@@ -94,8 +94,8 @@ impl UnsafetyViolationDetails {\n                 \"raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules \\\n                  and cause data races: all of these are undefined behavior\",\n             ),\n-            AssignToNonCopyUnionField => (\n-                \"assignment to non-`Copy` union field\",\n+            AssignToDroppingUnionField => (\n+                \"assignment to union field that might need dropping\",\n                 \"the previous content of the field will be dropped, which causes undefined \\\n                  behavior if the field was not properly initialized\",\n             ),"}, {"sha": "1b2c1076a6880317b30a613a889d8592e5a1b93c", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99baddb57c0a950c1af8d125dc470894ddf052a7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99baddb57c0a950c1af8d125dc470894ddf052a7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=99baddb57c0a950c1af8d125dc470894ddf052a7", "patch": "@@ -136,6 +136,15 @@ impl<'tcx> Place<'tcx> {\n     }\n }\n \n+impl<'tcx> PlaceRef<'tcx> {\n+    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n+    {\n+        Place::ty_from(self.local, &self.projection, local_decls, tcx)\n+    }\n+}\n+\n pub enum RvalueInitializationState {\n     Shallow,\n     Deep,"}, {"sha": "e64955c4986cee0f57fea664ac64d0990b9cd049", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 93, "deletions": 72, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/99baddb57c0a950c1af8d125dc470894ddf052a7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99baddb57c0a950c1af8d125dc470894ddf052a7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=99baddb57c0a950c1af8d125dc470894ddf052a7", "patch": "@@ -181,6 +181,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             self.check_mut_borrowing_layout_constrained_field(*place, context.is_mutating_use());\n         }\n \n+        // Check for borrows to packed fields.\n+        // `is_disaligned` already traverses the place to consider all projections after the last\n+        // `Deref`, so this only needs to be called once at the top level.\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 self.require_unsafe(\n@@ -190,87 +193,105 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n         }\n \n-        for (i, elem) in place.projection.iter().enumerate() {\n-            let proj_base = &place.projection[..i];\n-            if context.is_borrow() {\n-                if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n+        // Some checks below need the extra metainfo of the local declaration.\n+        let decl = &self.body.local_decls[place.local];\n+\n+        // Check the base local: it might be an unsafe-to-access static. We only check derefs of the\n+        // temporary holding the static pointer to avoid duplicate errors\n+        // <https://github.com/rust-lang/rust/pull/78068#issuecomment-731753506>.\n+        if decl.internal && place.projection.first() == Some(&ProjectionElem::Deref) {\n+            // If the projection root is an artifical local that we introduced when\n+            // desugaring `static`, give a more specific error message\n+            // (avoid the general \"raw pointer\" clause below, that would only be confusing).\n+            if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n+                if self.tcx.is_mutable_static(def_id) {\n                     self.require_unsafe(\n-                        UnsafetyViolationKind::BorrowPacked,\n-                        UnsafetyViolationDetails::BorrowOfPackedField,\n+                        UnsafetyViolationKind::General,\n+                        UnsafetyViolationDetails::UseOfMutableStatic,\n                     );\n+                    return;\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::General,\n+                        UnsafetyViolationDetails::UseOfExternStatic,\n+                    );\n+                    return;\n                 }\n             }\n-            let source_info = self.source_info;\n-            if let [] = proj_base {\n-                let decl = &self.body.local_decls[place.local];\n-                if decl.internal {\n-                    // If the projection root is an artifical local that we introduced when\n-                    // desugaring `static`, give a more specific error message\n-                    // (avoid the general \"raw pointer\" clause below, that would only be confusing).\n-                    if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n-                        if self.tcx.is_mutable_static(def_id) {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::General,\n-                                UnsafetyViolationDetails::UseOfMutableStatic,\n-                            );\n-                            return;\n-                        } else if self.tcx.is_foreign_item(def_id) {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::General,\n-                                UnsafetyViolationDetails::UseOfExternStatic,\n-                            );\n-                            return;\n-                        }\n-                    } else {\n-                        // Internal locals are used in the `move_val_init` desugaring.\n-                        // We want to check unsafety against the source info of the\n-                        // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.body.local_decls[place.local].source_info;\n-                    }\n+        }\n+\n+        // Check for raw pointer `Deref`.\n+        for (base, proj) in place.iter_projections() {\n+            if proj == ProjectionElem::Deref {\n+                let source_info = self.source_info; // Backup source_info so we can restore it later.\n+                if base.projection.is_empty() && decl.internal {\n+                    // Internal locals are used in the `move_val_init` desugaring.\n+                    // We want to check unsafety against the source info of the\n+                    // desugaring, rather than the source info of the RHS.\n+                    self.source_info = self.body.local_decls[place.local].source_info;\n+                }\n+                let base_ty = base.ty(self.body, self.tcx).ty;\n+                if base_ty.is_unsafe_ptr() {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::GeneralAndConstFn,\n+                        UnsafetyViolationDetails::DerefOfRawPointer,\n+                    )\n                 }\n+                self.source_info = source_info; // Restore backed-up source_info.\n             }\n-            let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n-            match base_ty.kind() {\n-                ty::RawPtr(..) => self.require_unsafe(\n-                    UnsafetyViolationKind::GeneralAndConstFn,\n-                    UnsafetyViolationDetails::DerefOfRawPointer,\n-                ),\n-                ty::Adt(adt, _) => {\n-                    if adt.is_union() {\n-                        if context == PlaceContext::MutatingUse(MutatingUseContext::Store)\n-                            || context == PlaceContext::MutatingUse(MutatingUseContext::Drop)\n-                            || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n-                        {\n-                            let elem_ty = match elem {\n-                                ProjectionElem::Field(_, ty) => ty,\n-                                _ => span_bug!(\n-                                    self.source_info.span,\n-                                    \"non-field projection {:?} from union?\",\n-                                    place\n-                                ),\n-                            };\n-                            if !elem_ty.is_copy_modulo_regions(\n-                                self.tcx.at(self.source_info.span),\n-                                self.param_env,\n-                            ) {\n-                                self.require_unsafe(\n-                                    UnsafetyViolationKind::GeneralAndConstFn,\n-                                    UnsafetyViolationDetails::AssignToNonCopyUnionField,\n-                                )\n-                            } else {\n-                                // write to non-move union, safe\n-                            }\n-                        } else {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::GeneralAndConstFn,\n-                                UnsafetyViolationDetails::AccessToUnionField,\n-                            )\n-                        }\n+        }\n+\n+        // Check for union fields. For this we traverse right-to-left, as the last `Deref` changes\n+        // whether we *read* the union field or potentially *write* to it (if this place is being assigned to).\n+        let mut saw_deref = false;\n+        for (base, proj) in place.iter_projections().rev() {\n+            if proj == ProjectionElem::Deref {\n+                saw_deref = true;\n+                continue;\n+            }\n+\n+            let base_ty = base.ty(self.body, self.tcx).ty;\n+            if base_ty.ty_adt_def().map_or(false, |adt| adt.is_union()) {\n+                // If we did not hit a `Deref` yet and the overall place use is an assignment, the\n+                // rules are different.\n+                let assign_to_field = !saw_deref\n+                    && matches!(\n+                        context,\n+                        PlaceContext::MutatingUse(\n+                            MutatingUseContext::Store\n+                                | MutatingUseContext::Drop\n+                                | MutatingUseContext::AsmOutput\n+                        )\n+                    );\n+                // If this is just an assignment, determine if the assigned type needs dropping.\n+                if assign_to_field {\n+                    // We have to check the actual type of the assignment, as that determines if the\n+                    // old value is being dropped.\n+                    let assigned_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n+                    // To avoid semver hazard, we only consider `Copy` and `ManuallyDrop` non-dropping.\n+                    let manually_drop = assigned_ty\n+                        .ty_adt_def()\n+                        .map_or(false, |adt_def| adt_def.is_manually_drop());\n+                    let nodrop = manually_drop\n+                        || assigned_ty.is_copy_modulo_regions(\n+                            self.tcx.at(self.source_info.span),\n+                            self.param_env,\n+                        );\n+                    if !nodrop {\n+                        self.require_unsafe(\n+                            UnsafetyViolationKind::GeneralAndConstFn,\n+                            UnsafetyViolationDetails::AssignToDroppingUnionField,\n+                        );\n+                    } else {\n+                        // write to non-drop union field, safe\n                     }\n+                } else {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::GeneralAndConstFn,\n+                        UnsafetyViolationDetails::AccessToUnionField,\n+                    )\n                 }\n-                _ => {}\n             }\n-            self.source_info = source_info;\n         }\n     }\n }"}, {"sha": "6adf0ac59b93ce518c60660290803fdcab1aa93e", "filename": "src/test/ui/union/union-unsafe.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/99baddb57c0a950c1af8d125dc470894ddf052a7/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99baddb57c0a950c1af8d125dc470894ddf052a7/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs?ref=99baddb57c0a950c1af8d125dc470894ddf052a7", "patch": "@@ -1,4 +1,6 @@\n+#![feature(untagged_unions)]\n use std::mem::ManuallyDrop;\n+use std::cell::RefCell;\n \n union U1 {\n     a: u8\n@@ -16,9 +18,28 @@ union U4<T: Copy> {\n     a: T\n }\n \n+union URef {\n+    p: &'static mut i32,\n+}\n+\n+union URefCell { // field that does not drop but is not `Copy`, either\n+    a: (RefCell<i32>, i32),\n+}\n+\n+fn deref_union_field(mut u: URef) {\n+    // Not an assignment but an access to the union field!\n+    *(u.p) = 13; //~ ERROR access to union field is unsafe\n+}\n+\n+fn assign_noncopy_union_field(mut u: URefCell) {\n+    u.a = (RefCell::new(0), 1); //~ ERROR assignment to union field that might need dropping\n+    u.a.0 = RefCell::new(0); //~ ERROR assignment to union field that might need dropping\n+    u.a.1 = 1; // OK\n+}\n+\n fn generic_noncopy<T: Default>() {\n     let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n-    u3.a = ManuallyDrop::new(T::default()); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    u3.a = ManuallyDrop::new(T::default()); // OK (assignment does not drop)\n     *u3.a = T::default(); //~ ERROR access to union field is unsafe\n }\n \n@@ -41,14 +62,14 @@ fn main() {\n     // let U1 { .. } = u1; // OK\n \n     let mut u2 = U2 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n-    u2.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    u2.a = ManuallyDrop::new(String::from(\"new\")); // OK (assignment does not drop)\n     *u2.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n \n     let mut u3 = U3 { a: ManuallyDrop::new(0) }; // OK\n     u3.a = ManuallyDrop::new(1); // OK\n     *u3.a = 1; //~ ERROR access to union field is unsafe\n \n     let mut u3 = U3 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n-    u3.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    u3.a = ManuallyDrop::new(String::from(\"new\")); // OK (assignment does not drop)\n     *u3.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n }"}, {"sha": "a25c09144f7420abe9333d3bb53d724cc89c953a", "filename": "src/test/ui/union/union-unsafe.stderr", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/99baddb57c0a950c1af8d125dc470894ddf052a7/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99baddb57c0a950c1af8d125dc470894ddf052a7/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr?ref=99baddb57c0a950c1af8d125dc470894ddf052a7", "patch": "@@ -1,85 +1,85 @@\n-error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:21:5\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:31:5\n+   |\n+LL |     *(u.p) = 13;\n+   |     ^^^^^^^^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: assignment to union field that might need dropping is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:35:5\n    |\n-LL |     u3.a = ManuallyDrop::new(T::default());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n+LL |     u.a = (RefCell::new(0), 1);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to union field that might need dropping\n+   |\n+   = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n+\n+error[E0133]: assignment to union field that might need dropping is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:36:5\n+   |\n+LL |     u.a.0 = RefCell::new(0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ assignment to union field that might need dropping\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:22:6\n+  --> $DIR/union-unsafe.rs:43:6\n    |\n LL |     *u3.a = T::default();\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:28:6\n+  --> $DIR/union-unsafe.rs:49:6\n    |\n LL |     *u3.a = T::default();\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:36:13\n+  --> $DIR/union-unsafe.rs:57:13\n    |\n LL |     let a = u1.a;\n    |             ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:39:14\n+  --> $DIR/union-unsafe.rs:60:14\n    |\n LL |     let U1 { a } = u1;\n    |              ^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:40:20\n+  --> $DIR/union-unsafe.rs:61:20\n    |\n LL |     if let U1 { a: 12 } = u1 {}\n    |                    ^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:44:5\n-   |\n-LL |     u2.a = ManuallyDrop::new(String::from(\"new\"));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n-   |\n-   = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n-\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:45:6\n+  --> $DIR/union-unsafe.rs:66:6\n    |\n LL |     *u2.a = String::from(\"new\");\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:49:6\n+  --> $DIR/union-unsafe.rs:70:6\n    |\n LL |     *u3.a = 1;\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:52:5\n-   |\n-LL |     u3.a = ManuallyDrop::new(String::from(\"new\"));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n-   |\n-   = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n-\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:53:6\n+  --> $DIR/union-unsafe.rs:74:6\n    |\n LL |     *u3.a = String::from(\"new\");\n    |      ^^^^ access to union field"}]}