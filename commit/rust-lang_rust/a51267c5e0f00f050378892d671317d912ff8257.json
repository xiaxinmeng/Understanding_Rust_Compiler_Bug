{"sha": "a51267c5e0f00f050378892d671317d912ff8257", "node_id": "C_kwDOAAsO6NoAKGE1MTI2N2M1ZTBmMDBmMDUwMzc4ODkyZDY3MTMxN2Q5MTJmZjgyNTc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-05T14:04:46Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-05T14:04:46Z"}, "message": "Allocate traits in scope upfront when type checking instead of recollecting them everytime", "tree": {"sha": "596026d4d1c1814b06e671b55518c42253ee434b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/596026d4d1c1814b06e671b55518c42253ee434b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a51267c5e0f00f050378892d671317d912ff8257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a51267c5e0f00f050378892d671317d912ff8257", "html_url": "https://github.com/rust-lang/rust/commit/a51267c5e0f00f050378892d671317d912ff8257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a51267c5e0f00f050378892d671317d912ff8257/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8606e536347d21fa13768354f17048c54d7d89d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8606e536347d21fa13768354f17048c54d7d89d", "html_url": "https://github.com/rust-lang/rust/commit/a8606e536347d21fa13768354f17048c54d7d89d"}], "stats": {"total": 116, "additions": 66, "deletions": 50}, "files": [{"sha": "57af92172a7823ec0cd9d81bd55c19fa5613c5f1", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a51267c5e0f00f050378892d671317d912ff8257/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51267c5e0f00f050378892d671317d912ff8257/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=a51267c5e0f00f050378892d671317d912ff8257", "patch": "@@ -449,6 +449,15 @@ impl Resolver {\n         traits\n     }\n \n+    pub fn traits_in_scope_from_block_scopes(&self) -> impl Iterator<Item = TraitId> + '_ {\n+        self.scopes()\n+            .filter_map(|scope| match scope {\n+                Scope::BlockScope(m) => Some(m.def_map[m.module_id].scope.traits()),\n+                _ => None,\n+            })\n+            .flatten()\n+    }\n+\n     pub fn module(&self) -> ModuleId {\n         let (def_map, local_id) = self.item_scope();\n         def_map.module_id(local_id)"}, {"sha": "869b39ab37d26aba2d9a770f9f51605163c93447", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a51267c5e0f00f050378892d671317d912ff8257/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51267c5e0f00f050378892d671317d912ff8257/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=a51267c5e0f00f050378892d671317d912ff8257", "patch": "@@ -33,7 +33,7 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n use la_arena::ArenaMap;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::always;\n \n use crate::{\n@@ -423,6 +423,8 @@ pub(crate) struct InferenceContext<'a> {\n     pub(crate) resolver: Resolver,\n     table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n+    /// The traits in scope, disregarding block modules. This is used for caching purposes.\n+    traits_in_scope: FxHashSet<TraitId>,\n     pub(crate) result: InferenceResult,\n     /// The return type of the function being inferred, the closure or async block if we're\n     /// currently within one.\n@@ -505,6 +507,7 @@ impl<'a> InferenceContext<'a> {\n             db,\n             owner,\n             body,\n+            traits_in_scope: resolver.traits_in_scope(db.upcast()),\n             resolver,\n             diverges: Diverges::Maybe,\n             breakables: Vec::new(),\n@@ -1056,6 +1059,15 @@ impl<'a> InferenceContext<'a> {\n         let struct_ = self.resolve_lang_item(LangItem::VaList)?.as_struct()?;\n         Some(struct_.into())\n     }\n+\n+    fn get_traits_in_scope(&self) -> Either<FxHashSet<TraitId>, &FxHashSet<TraitId>> {\n+        let mut b_traits = self.resolver.traits_in_scope_from_block_scopes().peekable();\n+        if b_traits.peek().is_some() {\n+            Either::Left(self.traits_in_scope.iter().copied().chain(b_traits).collect())\n+        } else {\n+            Either::Right(&self.traits_in_scope)\n+        }\n+    }\n }\n \n /// When inferring an expression, we propagate downward whatever type hint we"}, {"sha": "cca84488c94c83e3846296e12da8a769003f7556", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a51267c5e0f00f050378892d671317d912ff8257/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51267c5e0f00f050378892d671317d912ff8257/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a51267c5e0f00f050378892d671317d912ff8257", "patch": "@@ -1349,14 +1349,14 @@ impl<'a> InferenceContext<'a> {\n             None => {\n                 // no field found,\n                 let method_with_same_name_exists = {\n-                    let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n-                    let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n+                    self.get_traits_in_scope();\n \n+                    let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n                     method_resolution::lookup_method(\n                         self.db,\n                         &canonicalized_receiver.value,\n                         self.trait_env.clone(),\n-                        &traits_in_scope,\n+                        self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n                         VisibleFromModule::Filter(self.resolver.module()),\n                         name,\n                     )\n@@ -1385,13 +1385,11 @@ impl<'a> InferenceContext<'a> {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n         let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n \n-        let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n-\n         let resolved = method_resolution::lookup_method(\n             self.db,\n             &canonicalized_receiver.value,\n             self.trait_env.clone(),\n-            &traits_in_scope,\n+            self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n             VisibleFromModule::Filter(self.resolver.module()),\n             method_name,\n         );"}, {"sha": "d4d0d08196802c33e8d625a8f22227b909dd0720", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a51267c5e0f00f050378892d671317d912ff8257/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51267c5e0f00f050378892d671317d912ff8257/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=a51267c5e0f00f050378892d671317d912ff8257", "patch": "@@ -205,6 +205,7 @@ impl<'a> InferenceContext<'a> {\n         Some((def, Some(trait_ref.substitution)))\n     }\n \n+    // FIXME: Change sig to -> Option<(ValueNs, Substitution)>, subs aren't optional from here anymore\n     fn resolve_ty_assoc_item(\n         &mut self,\n         ty: Ty,\n@@ -220,70 +221,66 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         let canonical_ty = self.canonicalize(ty.clone());\n-        let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         let mut not_visible = None;\n         let res = method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n             self.table.trait_env.clone(),\n-            &traits_in_scope,\n+            self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n             VisibleFromModule::Filter(self.resolver.module()),\n             Some(name),\n             method_resolution::LookupMode::Path,\n             |_ty, item, visible| {\n-                let (def, container) = match item {\n-                    AssocItemId::FunctionId(f) => {\n-                        (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n-                    }\n-                    AssocItemId::ConstId(c) => {\n-                        (ValueNs::ConstId(c), c.lookup(self.db.upcast()).container)\n-                    }\n-                    AssocItemId::TypeAliasId(_) => unreachable!(),\n-                };\n-                let substs = match container {\n-                    ItemContainerId::ImplId(impl_id) => {\n-                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n-                            .fill_with_inference_vars(&mut self.table)\n-                            .build();\n-                        let impl_self_ty =\n-                            self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n-                        self.unify(&impl_self_ty, &ty);\n-                        impl_substs\n-                    }\n-                    ItemContainerId::TraitId(trait_) => {\n-                        // we're picking this method\n-                        let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n-                            .push(ty.clone())\n-                            .fill_with_inference_vars(&mut self.table)\n-                            .build();\n-                        self.push_obligation(trait_ref.clone().cast(Interner));\n-                        trait_ref.substitution\n-                    }\n-                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                        never!(\"assoc item contained in module/extern block\");\n-                        return None;\n-                    }\n-                };\n-\n                 if visible {\n-                    Some((def, item, Some(substs), true))\n+                    Some((item, true))\n                 } else {\n                     if not_visible.is_none() {\n-                        not_visible = Some((def, item, Some(substs), false));\n+                        not_visible = Some((item, false));\n                     }\n                     None\n                 }\n             },\n         );\n         let res = res.or(not_visible);\n-        if let Some((_, item, Some(ref substs), visible)) = res {\n-            self.write_assoc_resolution(id, item, substs.clone());\n-            if !visible {\n-                self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item })\n+        let (item, visible) = res?;\n+\n+        let (def, container) = match item {\n+            AssocItemId::FunctionId(f) => {\n+                (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n             }\n+            AssocItemId::ConstId(c) => (ValueNs::ConstId(c), c.lookup(self.db.upcast()).container),\n+            AssocItemId::TypeAliasId(_) => unreachable!(),\n+        };\n+        let substs = match container {\n+            ItemContainerId::ImplId(impl_id) => {\n+                let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n+                    .fill_with_inference_vars(&mut self.table)\n+                    .build();\n+                let impl_self_ty = self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n+                self.unify(&impl_self_ty, &ty);\n+                impl_substs\n+            }\n+            ItemContainerId::TraitId(trait_) => {\n+                // we're picking this method\n+                let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n+                    .push(ty.clone())\n+                    .fill_with_inference_vars(&mut self.table)\n+                    .build();\n+                self.push_obligation(trait_ref.clone().cast(Interner));\n+                trait_ref.substitution\n+            }\n+            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                never!(\"assoc item contained in module/extern block\");\n+                return None;\n+            }\n+        };\n+\n+        self.write_assoc_resolution(id, item, substs.clone());\n+        if !visible {\n+            self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item });\n         }\n-        res.map(|(def, _, substs, _)| (def, substs))\n+        Some((def, Some(substs)))\n     }\n \n     fn resolve_enum_variant_on_ty("}]}