{"sha": "6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "node_id": "C_kwDOAAsO6NoAKDZmMGM0YTZjNWMzNmYxZjhmNDMzYTEyZTEwYTI5OTE4ZjNkNDBhMzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-11T08:50:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-11T08:50:35Z"}, "message": "Auto merge of #101673 - crlf0710:generator_clone, r=oli-obk\n\nAllow generators to impl Clone/Copy\n\nRevives #95137. It's a pity that the original pr didn't land because the implementation is almost complete! All credits goes to `@canndrew,` and i just resolved the merge conflicts and updated the feature gate version number.\n\nr? `@oli-obk`", "tree": {"sha": "46e11551aafcf2cbb76f40229c5353000f65e258", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46e11551aafcf2cbb76f40229c5353000f65e258"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "html_url": "https://github.com/rust-lang/rust/commit/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c3f8eb277dcfd7f8624a9deb00fc4f74e5b6bf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c3f8eb277dcfd7f8624a9deb00fc4f74e5b6bf1", "html_url": "https://github.com/rust-lang/rust/commit/4c3f8eb277dcfd7f8624a9deb00fc4f74e5b6bf1"}, {"sha": "4e9bcb5d54d8cba113ebd9c94d293f376ac040ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9bcb5d54d8cba113ebd9c94d293f376ac040ef", "html_url": "https://github.com/rust-lang/rust/commit/4e9bcb5d54d8cba113ebd9c94d293f376ac040ef"}], "stats": {"total": 677, "additions": 642, "deletions": 35}, "files": [{"sha": "5377ebde1683feae818195af646b67f22d17216d", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -394,6 +394,8 @@ declare_features! (\n     (active, ffi_returns_twice, \"1.34.0\", Some(58314), None),\n     /// Allows using `#[repr(align(...))]` on function items\n     (active, fn_align, \"1.53.0\", Some(82232), None),\n+    /// Allows generators to be cloned.\n+    (active, generator_clone, \"CURRENT_RUSTC_VERSION\", Some(95360), None),\n     /// Allows defining generators.\n     (active, generators, \"1.21.0\", Some(43122), None),\n     /// Infer generic args for both consts and types."}, {"sha": "8821362002943d6e196e1cff8e87a5f94c113ef6", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 92, "deletions": 32, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_middle::mir::*;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n-use rustc_middle::ty::{self, EarlyBinder, Ty, TyCtxt};\n+use rustc_middle::ty::{self, EarlyBinder, GeneratorSubsts, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::{Idx, IndexVec};\n@@ -323,6 +323,9 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n             builder.tuple_like_shim(dest, src, substs.as_closure().upvar_tys())\n         }\n         ty::Tuple(..) => builder.tuple_like_shim(dest, src, self_ty.tuple_fields()),\n+        ty::Generator(gen_def_id, substs, hir::Movability::Movable) => {\n+            builder.generator_shim(dest, src, *gen_def_id, substs.as_generator())\n+        }\n         _ => bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty),\n     };\n \n@@ -388,7 +391,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n     /// offset=0 will give you the index of the next BasicBlock,\n     /// offset=1 will give the index of the next-to-next block,\n     /// offset=-1 will give you the index of the last-created block\n-    fn block_index_offset(&mut self, offset: usize) -> BasicBlock {\n+    fn block_index_offset(&self, offset: usize) -> BasicBlock {\n         BasicBlock::new(self.blocks.len() + offset)\n     }\n \n@@ -461,49 +464,106 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n         );\n     }\n \n-    fn tuple_like_shim<I>(&mut self, dest: Place<'tcx>, src: Place<'tcx>, tys: I)\n+    fn clone_fields<I>(\n+        &mut self,\n+        dest: Place<'tcx>,\n+        src: Place<'tcx>,\n+        target: BasicBlock,\n+        mut unwind: BasicBlock,\n+        tys: I,\n+    ) -> BasicBlock\n     where\n         I: IntoIterator<Item = Ty<'tcx>>,\n     {\n-        let mut previous_field = None;\n+        // For an iterator of length n, create 2*n + 1 blocks.\n         for (i, ity) in tys.into_iter().enumerate() {\n+            // Each iteration creates two blocks, referred to here as block 2*i and block 2*i + 1.\n+            //\n+            // Block 2*i attempts to clone the field. If successful it branches to 2*i + 2 (the\n+            // next clone block). If unsuccessful it branches to the previous unwind block, which\n+            // is initially the `unwind` argument passed to this function.\n+            //\n+            // Block 2*i + 1 is the unwind block for this iteration. It drops the cloned value\n+            // created by block 2*i. We store this block in `unwind` so that the next clone block\n+            // will unwind to it if cloning fails.\n+\n             let field = Field::new(i);\n             let src_field = self.tcx.mk_place_field(src, field, ity);\n \n             let dest_field = self.tcx.mk_place_field(dest, field, ity);\n \n-            // #(2i + 1) is the cleanup block for the previous clone operation\n-            let cleanup_block = self.block_index_offset(1);\n-            // #(2i + 2) is the next cloning block\n-            // (or the Return terminator if this is the last block)\n+            let next_unwind = self.block_index_offset(1);\n             let next_block = self.block_index_offset(2);\n+            self.make_clone_call(dest_field, src_field, ity, next_block, unwind);\n+            self.block(\n+                vec![],\n+                TerminatorKind::Drop { place: dest_field, target: unwind, unwind: None },\n+                true,\n+            );\n+            unwind = next_unwind;\n+        }\n+        // If all clones succeed then we end up here.\n+        self.block(vec![], TerminatorKind::Goto { target }, false);\n+        unwind\n+    }\n \n-            // BB #(2i)\n-            // `dest.i = Clone::clone(&src.i);`\n-            // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n-            self.make_clone_call(dest_field, src_field, ity, next_block, cleanup_block);\n-\n-            // BB #(2i + 1) (cleanup)\n-            if let Some((previous_field, previous_cleanup)) = previous_field.take() {\n-                // Drop previous field and goto previous cleanup block.\n-                self.block(\n-                    vec![],\n-                    TerminatorKind::Drop {\n-                        place: previous_field,\n-                        target: previous_cleanup,\n-                        unwind: None,\n-                    },\n-                    true,\n-                );\n-            } else {\n-                // Nothing to drop, just resume.\n-                self.block(vec![], TerminatorKind::Resume, true);\n-            }\n+    fn tuple_like_shim<I>(&mut self, dest: Place<'tcx>, src: Place<'tcx>, tys: I)\n+    where\n+        I: IntoIterator<Item = Ty<'tcx>>,\n+    {\n+        self.block(vec![], TerminatorKind::Goto { target: self.block_index_offset(3) }, false);\n+        let unwind = self.block(vec![], TerminatorKind::Resume, true);\n+        let target = self.block(vec![], TerminatorKind::Return, false);\n \n-            previous_field = Some((dest_field, cleanup_block));\n-        }\n+        let _final_cleanup_block = self.clone_fields(dest, src, target, unwind, tys);\n+    }\n \n-        self.block(vec![], TerminatorKind::Return, false);\n+    fn generator_shim(\n+        &mut self,\n+        dest: Place<'tcx>,\n+        src: Place<'tcx>,\n+        gen_def_id: DefId,\n+        substs: GeneratorSubsts<'tcx>,\n+    ) {\n+        self.block(vec![], TerminatorKind::Goto { target: self.block_index_offset(3) }, false);\n+        let unwind = self.block(vec![], TerminatorKind::Resume, true);\n+        // This will get overwritten with a switch once we know the target blocks\n+        let switch = self.block(vec![], TerminatorKind::Unreachable, false);\n+        let unwind = self.clone_fields(dest, src, switch, unwind, substs.upvar_tys());\n+        let target = self.block(vec![], TerminatorKind::Return, false);\n+        let unreachable = self.block(vec![], TerminatorKind::Unreachable, false);\n+        let mut cases = Vec::with_capacity(substs.state_tys(gen_def_id, self.tcx).count());\n+        for (index, state_tys) in substs.state_tys(gen_def_id, self.tcx).enumerate() {\n+            let variant_index = VariantIdx::new(index);\n+            let dest = self.tcx.mk_place_downcast_unnamed(dest, variant_index);\n+            let src = self.tcx.mk_place_downcast_unnamed(src, variant_index);\n+            let clone_block = self.block_index_offset(1);\n+            let start_block = self.block(\n+                vec![self.make_statement(StatementKind::SetDiscriminant {\n+                    place: Box::new(Place::return_place()),\n+                    variant_index,\n+                })],\n+                TerminatorKind::Goto { target: clone_block },\n+                false,\n+            );\n+            cases.push((index as u128, start_block));\n+            let _final_cleanup_block = self.clone_fields(dest, src, target, unwind, state_tys);\n+        }\n+        let discr_ty = substs.discr_ty(self.tcx);\n+        let temp = self.make_place(Mutability::Mut, discr_ty);\n+        let rvalue = Rvalue::Discriminant(src);\n+        let statement = self.make_statement(StatementKind::Assign(Box::new((temp, rvalue))));\n+        match &mut self.blocks[switch] {\n+            BasicBlockData { statements, terminator: Some(Terminator { kind, .. }), .. } => {\n+                statements.push(statement);\n+                *kind = TerminatorKind::SwitchInt {\n+                    discr: Operand::Move(temp),\n+                    switch_ty: discr_ty,\n+                    targets: SwitchTargets::new(cases.into_iter(), unreachable),\n+                };\n+            }\n+            BasicBlockData { terminator: None, .. } => unreachable!(),\n+        }\n     }\n }\n "}, {"sha": "5bddcd3481974b88f7d80f178fb449d5b8ead76a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -763,6 +763,7 @@ symbols! {\n         gen_future,\n         gen_kill,\n         generator,\n+        generator_clone,\n         generator_state,\n         generators,\n         generic_arg_infer,"}, {"sha": "3ab9b7f4083b8ffe6a132d5f474d00ab27bb456a", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -1928,8 +1928,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Dynamic(..)\n             | ty::Str\n             | ty::Slice(..)\n-            | ty::Generator(..)\n-            | ty::GeneratorWitness(..)\n+            | ty::Generator(_, _, hir::Movability::Static)\n             | ty::Foreign(..)\n             | ty::Ref(_, _, hir::Mutability::Mut) => None,\n \n@@ -1938,6 +1937,43 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Where(obligation.predicate.rebind(tys.iter().collect()))\n             }\n \n+            ty::Generator(_, substs, hir::Movability::Movable) => {\n+                if self.tcx().features().generator_clone {\n+                    let resolved_upvars =\n+                        self.infcx.shallow_resolve(substs.as_generator().tupled_upvars_ty());\n+                    let resolved_witness =\n+                        self.infcx.shallow_resolve(substs.as_generator().witness());\n+                    if resolved_upvars.is_ty_var() || resolved_witness.is_ty_var() {\n+                        // Not yet resolved.\n+                        Ambiguous\n+                    } else {\n+                        let all = substs\n+                            .as_generator()\n+                            .upvar_tys()\n+                            .chain(iter::once(substs.as_generator().witness()))\n+                            .collect::<Vec<_>>();\n+                        Where(obligation.predicate.rebind(all))\n+                    }\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            ty::GeneratorWitness(binder) => {\n+                let witness_tys = binder.skip_binder();\n+                for witness_ty in witness_tys.iter() {\n+                    let resolved = self.infcx.shallow_resolve(witness_ty);\n+                    if resolved.is_ty_var() {\n+                        return Ambiguous;\n+                    }\n+                }\n+                // (*) binder moved here\n+                let all_vars = self.tcx().mk_bound_variable_kinds(\n+                    obligation.predicate.bound_vars().iter().chain(binder.bound_vars().iter()),\n+                );\n+                Where(ty::Binder::bind_with_vars(witness_tys.to_vec(), all_vars))\n+            }\n+\n             ty::Closure(_, substs) => {\n                 // (*) binder moved here\n                 let ty = self.infcx.shallow_resolve(substs.as_closure().tupled_upvars_ty());"}, {"sha": "edf47403c0d655486a5da0ca06d6417e8adb876a", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -263,7 +263,10 @@ fn resolve_associated_item<'tcx>(\n                     let is_copy = self_ty.is_copy_modulo_regions(tcx.at(DUMMY_SP), param_env);\n                     match self_ty.kind() {\n                         _ if is_copy => (),\n-                        ty::Closure(..) | ty::Tuple(..) => {}\n+                        ty::Generator(..)\n+                        | ty::GeneratorWitness(..)\n+                        | ty::Closure(..)\n+                        | ty::Tuple(..) => {}\n                         _ => return Ok(None),\n                     };\n "}, {"sha": "83c51526b7b0984db21adbcb89c8961bffe3b120", "filename": "src/test/ui/generator/clone-impl-async.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-async.rs?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -0,0 +1,71 @@\n+// edition:2021\n+// gate-test-generator_clone\n+// Verifies that feature(generator_clone) doesn't allow async blocks to be cloned/copied.\n+\n+#![feature(generators, generator_clone)]\n+\n+use std::future::ready;\n+\n+struct NonClone;\n+\n+fn main() {\n+    let inner_non_clone = async {\n+        let non_clone = NonClone;\n+        let () = ready(()).await;\n+        drop(non_clone);\n+    };\n+    check_copy(&inner_non_clone);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+    check_clone(&inner_non_clone);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+\n+    let non_clone = NonClone;\n+    let outer_non_clone = async move {\n+        drop(non_clone);\n+    };\n+    check_copy(&outer_non_clone);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+    check_clone(&outer_non_clone);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+\n+    let maybe_copy_clone = async move {};\n+    check_copy(&maybe_copy_clone);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+    check_clone(&maybe_copy_clone);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+\n+    let inner_non_clone_fn = the_inner_non_clone_fn();\n+    check_copy(&inner_non_clone_fn);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+    check_clone(&inner_non_clone_fn);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+\n+    let outer_non_clone_fn = the_outer_non_clone_fn(NonClone);\n+    check_copy(&outer_non_clone_fn);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+    check_clone(&outer_non_clone_fn);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+\n+    let maybe_copy_clone_fn = the_maybe_copy_clone_fn();\n+    check_copy(&maybe_copy_clone_fn);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+    check_clone(&maybe_copy_clone_fn);\n+    //~^ ERROR the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+}\n+\n+async fn the_inner_non_clone_fn() {\n+    let non_clone = NonClone;\n+    let () = ready(()).await;\n+    drop(non_clone);\n+}\n+\n+async fn the_outer_non_clone_fn(non_clone: NonClone) {\n+    let () = ready(()).await;\n+    drop(non_clone);\n+}\n+\n+async fn the_maybe_copy_clone_fn() {\n+}\n+\n+fn check_copy<T: Copy>(_x: &T) {}\n+fn check_clone<T: Clone>(_x: &T) {}"}, {"sha": "cbb58d2af18e7acdce2e98811c0115f37279603f", "filename": "src/test/ui/generator/clone-impl-async.stderr", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-async.stderr?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -0,0 +1,171 @@\n+error[E0277]: the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+  --> $DIR/clone-impl-async.rs:17:16\n+   |\n+LL |     check_copy(&inner_non_clone);\n+   |     ---------- ^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl-async.rs:70:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+  --> $DIR/clone-impl-async.rs:19:17\n+   |\n+LL |     check_clone(&inner_non_clone);\n+   |     ----------- ^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_clone`\n+  --> $DIR/clone-impl-async.rs:71:19\n+   |\n+LL | fn check_clone<T: Clone>(_x: &T) {}\n+   |                   ^^^^^ required by this bound in `check_clone`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+  --> $DIR/clone-impl-async.rs:26:16\n+   |\n+LL |     check_copy(&outer_non_clone);\n+   |     ---------- ^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl-async.rs:70:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+  --> $DIR/clone-impl-async.rs:28:17\n+   |\n+LL |     check_clone(&outer_non_clone);\n+   |     ----------- ^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_clone`\n+  --> $DIR/clone-impl-async.rs:71:19\n+   |\n+LL | fn check_clone<T: Clone>(_x: &T) {}\n+   |                   ^^^^^ required by this bound in `check_clone`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+  --> $DIR/clone-impl-async.rs:32:16\n+   |\n+LL |     check_copy(&maybe_copy_clone);\n+   |     ---------- ^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl-async.rs:70:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+  --> $DIR/clone-impl-async.rs:34:17\n+   |\n+LL |     check_clone(&maybe_copy_clone);\n+   |     ----------- ^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_clone`\n+  --> $DIR/clone-impl-async.rs:71:19\n+   |\n+LL | fn check_clone<T: Clone>(_x: &T) {}\n+   |                   ^^^^^ required by this bound in `check_clone`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+  --> $DIR/clone-impl-async.rs:38:16\n+   |\n+LL |     check_copy(&inner_non_clone_fn);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl-async.rs:70:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+  --> $DIR/clone-impl-async.rs:40:17\n+   |\n+LL |     check_clone(&inner_non_clone_fn);\n+   |     ----------- ^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_clone`\n+  --> $DIR/clone-impl-async.rs:71:19\n+   |\n+LL | fn check_clone<T: Clone>(_x: &T) {}\n+   |                   ^^^^^ required by this bound in `check_clone`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+  --> $DIR/clone-impl-async.rs:44:16\n+   |\n+LL |     check_copy(&outer_non_clone_fn);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl-async.rs:70:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+  --> $DIR/clone-impl-async.rs:46:17\n+   |\n+LL |     check_clone(&outer_non_clone_fn);\n+   |     ----------- ^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_clone`\n+  --> $DIR/clone-impl-async.rs:71:19\n+   |\n+LL | fn check_clone<T: Clone>(_x: &T) {}\n+   |                   ^^^^^ required by this bound in `check_clone`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Copy` is not satisfied\n+  --> $DIR/clone-impl-async.rs:50:16\n+   |\n+LL |     check_copy(&maybe_copy_clone_fn);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl-async.rs:70:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Clone` is not satisfied\n+  --> $DIR/clone-impl-async.rs:52:17\n+   |\n+LL |     check_clone(&maybe_copy_clone_fn);\n+   |     ----------- ^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_clone`\n+  --> $DIR/clone-impl-async.rs:71:19\n+   |\n+LL | fn check_clone<T: Clone>(_x: &T) {}\n+   |                   ^^^^^ required by this bound in `check_clone`\n+\n+error: aborting due to 12 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "55ed0f281e0505288fdad75b93ac95ef7d9c20ea", "filename": "src/test/ui/generator/clone-impl-static.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-static.rs?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -0,0 +1,17 @@\n+// gate-test-generator_clone\n+// Verifies that static generators cannot be cloned/copied.\n+\n+#![feature(generators, generator_clone)]\n+\n+fn main() {\n+    let gen = static move || {\n+        yield;\n+    };\n+    check_copy(&gen);\n+    //~^ ERROR Copy` is not satisfied\n+    check_clone(&gen);\n+    //~^ ERROR Clone` is not satisfied\n+}\n+\n+fn check_copy<T: Copy>(_x: &T) {}\n+fn check_clone<T: Clone>(_x: &T) {}"}, {"sha": "cbadf6f156a9f9df6886aa517974a77dcd3917f6", "filename": "src/test/ui/generator/clone-impl-static.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl-static.stderr?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -0,0 +1,31 @@\n+error[E0277]: the trait bound `[static generator@$DIR/clone-impl-static.rs:7:15: 7:29]: Copy` is not satisfied\n+  --> $DIR/clone-impl-static.rs:10:16\n+   |\n+LL |     check_copy(&gen);\n+   |     ---------- ^^^^ the trait `Copy` is not implemented for `[static generator@$DIR/clone-impl-static.rs:7:15: 7:29]`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl-static.rs:16:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `[static generator@$DIR/clone-impl-static.rs:7:15: 7:29]: Clone` is not satisfied\n+  --> $DIR/clone-impl-static.rs:12:17\n+   |\n+LL |     check_clone(&gen);\n+   |     ----------- ^^^^ the trait `Clone` is not implemented for `[static generator@$DIR/clone-impl-static.rs:7:15: 7:29]`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check_clone`\n+  --> $DIR/clone-impl-static.rs:17:19\n+   |\n+LL | fn check_clone<T: Clone>(_x: &T) {}\n+   |                   ^^^^^ required by this bound in `check_clone`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "cbfd65a530998d3f426dfdd17b01da8b3b66fed7", "filename": "src/test/ui/generator/clone-impl.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl.rs?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -0,0 +1,73 @@\n+// gate-test-generator_clone\n+// Verifies that non-static generators can be cloned/copied if all their upvars and locals held\n+// across awaits can be cloned/copied.\n+\n+#![feature(generators, generator_clone)]\n+\n+struct NonClone;\n+\n+fn main() {\n+    let copyable: u32 = 123;\n+    let clonable_0: Vec<u32> = Vec::new();\n+    let clonable_1: Vec<u32> = Vec::new();\n+    let non_clonable: NonClone = NonClone;\n+\n+    let gen_copy_0 = move || {\n+        yield;\n+        drop(copyable);\n+    };\n+    check_copy(&gen_copy_0);\n+    check_clone(&gen_copy_0);\n+    let gen_copy_1 = move || {\n+        /*\n+        let v = vec!['a'];\n+        let n = NonClone;\n+        drop(v);\n+        drop(n);\n+        */\n+        yield;\n+        let v = vec!['a'];\n+        let n = NonClone;\n+        drop(n);\n+        drop(copyable);\n+    };\n+    check_copy(&gen_copy_1);\n+    check_clone(&gen_copy_1);\n+    let gen_clone_0 = move || {\n+        let v = vec!['a'];\n+        yield;\n+        drop(v);\n+        drop(clonable_0);\n+    };\n+    check_copy(&gen_clone_0);\n+    //~^ ERROR the trait bound `Vec<u32>: Copy` is not satisfied\n+    //~| ERROR the trait bound `Vec<char>: Copy` is not satisfied\n+    check_clone(&gen_clone_0);\n+    let gen_clone_1 = move || {\n+        let v = vec!['a'];\n+        /*\n+        let n = NonClone;\n+        drop(n);\n+        */\n+        yield;\n+        let n = NonClone;\n+        drop(n);\n+        drop(v);\n+        drop(clonable_1);\n+    };\n+    check_copy(&gen_clone_1);\n+    //~^ ERROR the trait bound `Vec<u32>: Copy` is not satisfied\n+    //~| ERROR the trait bound `Vec<char>: Copy` is not satisfied\n+    check_clone(&gen_clone_1);\n+    let gen_non_clone = move || {\n+        yield;\n+        drop(non_clonable);\n+    };\n+    check_copy(&gen_non_clone);\n+    //~^ ERROR the trait bound `NonClone: Copy` is not satisfied\n+    check_clone(&gen_non_clone);\n+    //~^ ERROR the trait bound `NonClone: Clone` is not satisfied\n+}\n+\n+fn check_copy<T: Copy>(_x: &T) {}\n+fn check_clone<T: Clone>(_x: &T) {}"}, {"sha": "a92646b198cf4a55e26b7e418d950b5face95df5", "filename": "src/test/ui/generator/clone-impl.stderr", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fclone-impl.stderr?ref=6f0c4a6c5c36f1f8f433a12e10a29918f3d40a31", "patch": "@@ -0,0 +1,142 @@\n+error[E0277]: the trait bound `Vec<u32>: Copy` is not satisfied in `[generator@$DIR/clone-impl.rs:36:23: 36:30]`\n+  --> $DIR/clone-impl.rs:42:16\n+   |\n+LL |     let gen_clone_0 = move || {\n+   |                       ------- within this `[generator@$DIR/clone-impl.rs:36:23: 36:30]`\n+...\n+LL |     check_copy(&gen_clone_0);\n+   |                ^^^^^^^^^^^^ within `[generator@$DIR/clone-impl.rs:36:23: 36:30]`, the trait `Copy` is not implemented for `Vec<u32>`\n+   |\n+note: captured value does not implement `Copy`\n+  --> $DIR/clone-impl.rs:40:14\n+   |\n+LL |         drop(clonable_0);\n+   |              ^^^^^^^^^^ has type `Vec<u32>` which does not implement `Copy`\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl.rs:72:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `Vec<char>: Copy` is not satisfied in `[generator@$DIR/clone-impl.rs:36:23: 36:30]`\n+  --> $DIR/clone-impl.rs:42:16\n+   |\n+LL |     let gen_clone_0 = move || {\n+   |                       ------- within this `[generator@$DIR/clone-impl.rs:36:23: 36:30]`\n+...\n+LL |     check_copy(&gen_clone_0);\n+   |                ^^^^^^^^^^^^ within `[generator@$DIR/clone-impl.rs:36:23: 36:30]`, the trait `Copy` is not implemented for `Vec<char>`\n+   |\n+note: generator does not implement `Copy` as this value is used across a yield\n+  --> $DIR/clone-impl.rs:38:9\n+   |\n+LL |         let v = vec!['a'];\n+   |             - has type `Vec<char>` which does not implement `Copy`\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `v` maybe used later\n+...\n+LL |     };\n+   |     - `v` is later dropped here\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl.rs:72:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `Vec<u32>: Copy` is not satisfied in `[generator@$DIR/clone-impl.rs:46:23: 46:30]`\n+  --> $DIR/clone-impl.rs:58:16\n+   |\n+LL |     let gen_clone_1 = move || {\n+   |                       ------- within this `[generator@$DIR/clone-impl.rs:46:23: 46:30]`\n+...\n+LL |     check_copy(&gen_clone_1);\n+   |                ^^^^^^^^^^^^ within `[generator@$DIR/clone-impl.rs:46:23: 46:30]`, the trait `Copy` is not implemented for `Vec<u32>`\n+   |\n+note: captured value does not implement `Copy`\n+  --> $DIR/clone-impl.rs:56:14\n+   |\n+LL |         drop(clonable_1);\n+   |              ^^^^^^^^^^ has type `Vec<u32>` which does not implement `Copy`\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl.rs:72:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `Vec<char>: Copy` is not satisfied in `[generator@$DIR/clone-impl.rs:46:23: 46:30]`\n+  --> $DIR/clone-impl.rs:58:16\n+   |\n+LL |     let gen_clone_1 = move || {\n+   |                       ------- within this `[generator@$DIR/clone-impl.rs:46:23: 46:30]`\n+...\n+LL |     check_copy(&gen_clone_1);\n+   |                ^^^^^^^^^^^^ within `[generator@$DIR/clone-impl.rs:46:23: 46:30]`, the trait `Copy` is not implemented for `Vec<char>`\n+   |\n+note: generator does not implement `Copy` as this value is used across a yield\n+  --> $DIR/clone-impl.rs:52:9\n+   |\n+LL |         let v = vec!['a'];\n+   |             - has type `Vec<char>` which does not implement `Copy`\n+...\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `v` maybe used later\n+...\n+LL |     };\n+   |     - `v` is later dropped here\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl.rs:72:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+\n+error[E0277]: the trait bound `NonClone: Copy` is not satisfied in `[generator@$DIR/clone-impl.rs:62:25: 62:32]`\n+  --> $DIR/clone-impl.rs:66:16\n+   |\n+LL |     let gen_non_clone = move || {\n+   |                         ------- within this `[generator@$DIR/clone-impl.rs:62:25: 62:32]`\n+...\n+LL |     check_copy(&gen_non_clone);\n+   |                ^^^^^^^^^^^^^^ within `[generator@$DIR/clone-impl.rs:62:25: 62:32]`, the trait `Copy` is not implemented for `NonClone`\n+   |\n+note: captured value does not implement `Copy`\n+  --> $DIR/clone-impl.rs:64:14\n+   |\n+LL |         drop(non_clonable);\n+   |              ^^^^^^^^^^^^ has type `NonClone` which does not implement `Copy`\n+note: required by a bound in `check_copy`\n+  --> $DIR/clone-impl.rs:72:18\n+   |\n+LL | fn check_copy<T: Copy>(_x: &T) {}\n+   |                  ^^^^ required by this bound in `check_copy`\n+help: consider annotating `NonClone` with `#[derive(Copy)]`\n+   |\n+LL | #[derive(Copy)]\n+   |\n+\n+error[E0277]: the trait bound `NonClone: Clone` is not satisfied in `[generator@$DIR/clone-impl.rs:62:25: 62:32]`\n+  --> $DIR/clone-impl.rs:68:17\n+   |\n+LL |     let gen_non_clone = move || {\n+   |                         ------- within this `[generator@$DIR/clone-impl.rs:62:25: 62:32]`\n+...\n+LL |     check_clone(&gen_non_clone);\n+   |                 ^^^^^^^^^^^^^^ within `[generator@$DIR/clone-impl.rs:62:25: 62:32]`, the trait `Clone` is not implemented for `NonClone`\n+   |\n+note: captured value does not implement `Clone`\n+  --> $DIR/clone-impl.rs:64:14\n+   |\n+LL |         drop(non_clonable);\n+   |              ^^^^^^^^^^^^ has type `NonClone` which does not implement `Clone`\n+note: required by a bound in `check_clone`\n+  --> $DIR/clone-impl.rs:73:19\n+   |\n+LL | fn check_clone<T: Clone>(_x: &T) {}\n+   |                   ^^^^^ required by this bound in `check_clone`\n+help: consider annotating `NonClone` with `#[derive(Clone)]`\n+   |\n+LL | #[derive(Clone)]\n+   |\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}