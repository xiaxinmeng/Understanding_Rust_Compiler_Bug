{"sha": "a39629b88f6c1f2044326d94aced180a4015541c", "node_id": "C_kwDOAAsO6NoAKGEzOTYyOWI4OGY2YzFmMjA0NDMyNmQ5NGFjZWQxODBhNDAxNTU0MWM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-20T20:18:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-20T22:02:06Z"}, "message": "slight refactoring", "tree": {"sha": "5db3efd3c985504a0d8d6e69093595ed8bd91769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5db3efd3c985504a0d8d6e69093595ed8bd91769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a39629b88f6c1f2044326d94aced180a4015541c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a39629b88f6c1f2044326d94aced180a4015541c", "html_url": "https://github.com/rust-lang/rust/commit/a39629b88f6c1f2044326d94aced180a4015541c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a39629b88f6c1f2044326d94aced180a4015541c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e56e773de74891291eb242f89a07d9c60a80949", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e56e773de74891291eb242f89a07d9c60a80949", "html_url": "https://github.com/rust-lang/rust/commit/7e56e773de74891291eb242f89a07d9c60a80949"}], "stats": {"total": 615, "additions": 310, "deletions": 305}, "files": [{"sha": "791931901e2a96765ba3ca11f8cce9cf33cfe03e", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=a39629b88f6c1f2044326d94aced180a4015541c", "patch": "@@ -0,0 +1,204 @@\n+use std::collections::VecDeque;\n+use std::num::NonZeroU32;\n+\n+use rustc_index::vec::Idx;\n+\n+use super::sync::EvalContextExtPriv;\n+use super::thread::MachineCallback;\n+use super::vector_clock::VClock;\n+use crate::*;\n+\n+declare_id!(InitOnceId);\n+\n+/// A thread waiting on an InitOnce object.\n+struct InitOnceWaiter<'mir, 'tcx> {\n+    /// The thread that is waiting.\n+    thread: ThreadId,\n+    /// The callback that should be executed, after the thread has been woken up.\n+    callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n+}\n+\n+impl<'mir, 'tcx> std::fmt::Debug for InitOnceWaiter<'mir, 'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"InitOnce\")\n+            .field(\"thread\", &self.thread)\n+            .field(\"callback\", &\"dyn MachineCallback\")\n+            .finish()\n+    }\n+}\n+\n+#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\n+/// The current status of a one time initialization.\n+pub enum InitOnceStatus {\n+    #[default]\n+    Uninitialized,\n+    Begun,\n+    Complete,\n+}\n+\n+/// The one time initialization state.\n+#[derive(Default, Debug)]\n+pub(super) struct InitOnce<'mir, 'tcx> {\n+    status: InitOnceStatus,\n+    waiters: VecDeque<InitOnceWaiter<'mir, 'tcx>>,\n+    data_race: VClock,\n+}\n+\n+impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for waiter in self.waiters.iter() {\n+            waiter.callback.visit_tags(visit);\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn init_once_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, InitOnceId> {\n+        let this = self.eval_context_mut();\n+        this.init_once_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n+    }\n+\n+    /// Provides the closure with the next InitOnceId. Creates that InitOnce if the closure returns None,\n+    /// otherwise returns the value from the closure.\n+    #[inline]\n+    fn init_once_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, InitOnceId>\n+    where\n+        F: FnOnce(\n+            &mut MiriInterpCx<'mir, 'tcx>,\n+            InitOnceId,\n+        ) -> InterpResult<'tcx, Option<InitOnceId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.init_onces.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.init_onces.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n+    #[inline]\n+    fn init_once_status(&mut self, id: InitOnceId) -> InitOnceStatus {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.init_onces[id].status\n+    }\n+\n+    /// Put the thread into the queue waiting for the initialization.\n+    #[inline]\n+    fn init_once_enqueue_and_block(\n+        &mut self,\n+        id: InitOnceId,\n+        thread: ThreadId,\n+        callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n+    ) {\n+        let this = self.eval_context_mut();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_ne!(init_once.status, InitOnceStatus::Complete, \"queueing on complete init once\");\n+        init_once.waiters.push_back(InitOnceWaiter { thread, callback });\n+        this.block_thread(thread);\n+    }\n+\n+    /// Begin initializing this InitOnce. Must only be called after checking that it is currently\n+    /// uninitialized.\n+    #[inline]\n+    fn init_once_begin(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Uninitialized,\n+            \"begining already begun or complete init once\"\n+        );\n+        init_once.status = InitOnceStatus::Begun;\n+    }\n+\n+    #[inline]\n+    fn init_once_complete(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Begun,\n+            \"completing already complete or uninit init once\"\n+        );\n+\n+        init_once.status = InitOnceStatus::Complete;\n+\n+        // Each complete happens-before the end of the wait\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+        }\n+\n+        // Wake up everyone.\n+        // need to take the queue to avoid having `this` be borrowed multiple times\n+        for waiter in std::mem::take(&mut init_once.waiters) {\n+            // End of the wait happens-before woken-up thread.\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_acquire(\n+                    &this.machine.threads.sync.init_onces[id].data_race,\n+                    waiter.thread,\n+                );\n+            }\n+\n+            this.unblock_thread(waiter.thread);\n+\n+            // Call callback, with the woken-up thread as `current`.\n+            this.set_active_thread(waiter.thread);\n+            waiter.callback.call(this)?;\n+            this.set_active_thread(current_thread);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn init_once_fail(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Begun,\n+            \"failing already completed or uninit init once\"\n+        );\n+\n+        // Each complete happens-before the end of the wait\n+        // FIXME: should this really induce synchronization? If we think of it as a lock, then yes,\n+        // but the docs don't talk about such details.\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+        }\n+\n+        // Wake up one waiting thread, so they can go ahead and try to init this.\n+        if let Some(waiter) = init_once.waiters.pop_front() {\n+            // End of the wait happens-before woken-up thread.\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_acquire(\n+                    &this.machine.threads.sync.init_onces[id].data_race,\n+                    waiter.thread,\n+                );\n+            }\n+\n+            this.unblock_thread(waiter.thread);\n+\n+            // Call callback, with the woken-up thread as `current`.\n+            this.set_active_thread(waiter.thread);\n+            waiter.callback.call(this)?;\n+            this.set_active_thread(current_thread);\n+        } else {\n+            // Nobody there to take this, so go back to 'uninit'\n+            init_once.status = InitOnceStatus::Uninitialized;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "45903107f17104d86585317e4b803d3c9bbd1014", "filename": "src/tools/miri/src/concurrency/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs?ref=a39629b88f6c1f2044326d94aced180a4015541c", "patch": "@@ -1,6 +1,8 @@\n pub mod data_race;\n mod range_object_map;\n+#[macro_use]\n pub mod sync;\n+pub mod init_once;\n pub mod thread;\n mod vector_clock;\n pub mod weak_memory;"}, {"sha": "e76610e7302804c76478e49f9389df4473863ee7", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 20, "deletions": 229, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=a39629b88f6c1f2044326d94aced180a4015541c", "patch": "@@ -7,13 +7,13 @@ use log::trace;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::{Idx, IndexVec};\n \n-use super::thread::MachineCallback;\n+use super::init_once::InitOnce;\n use super::vector_clock::VClock;\n use crate::*;\n \n pub trait SyncId {\n     fn from_u32(id: u32) -> Self;\n-    fn to_u32_scalar(&self) -> Scalar<Provenance>;\n+    fn to_u32(&self) -> u32;\n }\n \n /// We cannot use the `newtype_index!` macro because we have to use 0 as a\n@@ -32,8 +32,8 @@ macro_rules! declare_id {\n             fn from_u32(id: u32) -> Self {\n                 Self(NonZeroU32::new(id).unwrap())\n             }\n-            fn to_u32_scalar(&self) -> Scalar<Provenance> {\n-                Scalar::from_u32(self.0.get())\n+            fn to_u32(&self) -> u32 {\n+                self.0.get()\n             }\n         }\n \n@@ -158,55 +158,14 @@ struct FutexWaiter {\n     bitset: u32,\n }\n \n-declare_id!(InitOnceId);\n-\n-struct InitOnceWaiter<'mir, 'tcx> {\n-    thread: ThreadId,\n-    callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n-}\n-\n-impl<'mir, 'tcx> std::fmt::Debug for InitOnceWaiter<'mir, 'tcx> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        f.debug_struct(\"InitOnce\")\n-            .field(\"thread\", &self.thread)\n-            .field(\"callback\", &\"dyn MachineCallback\")\n-            .finish()\n-    }\n-}\n-\n-#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\n-/// The current status of a one time initialization.\n-pub enum InitOnceStatus {\n-    #[default]\n-    Uninitialized,\n-    Begun,\n-    Complete,\n-}\n-\n-/// The one time initialization state.\n-#[derive(Default, Debug)]\n-struct InitOnce<'mir, 'tcx> {\n-    status: InitOnceStatus,\n-    waiters: VecDeque<InitOnceWaiter<'mir, 'tcx>>,\n-    data_race: VClock,\n-}\n-\n-impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        for waiter in self.waiters.iter() {\n-            waiter.callback.visit_tags(visit);\n-        }\n-    }\n-}\n-\n /// The state of all synchronization variables.\n #[derive(Default, Debug)]\n pub(crate) struct SynchronizationState<'mir, 'tcx> {\n     mutexes: IndexVec<MutexId, Mutex>,\n     rwlocks: IndexVec<RwLockId, RwLock>,\n     condvars: IndexVec<CondvarId, Condvar>,\n     futexes: FxHashMap<u64, Futex>,\n-    init_onces: IndexVec<InitOnceId, InitOnce<'mir, 'tcx>>,\n+    pub(super) init_onces: IndexVec<InitOnceId, InitOnce<'mir, 'tcx>>,\n }\n \n impl<'mir, 'tcx> VisitTags for SynchronizationState<'mir, 'tcx> {\n@@ -219,7 +178,9 @@ impl<'mir, 'tcx> VisitTags for SynchronizationState<'mir, 'tcx> {\n \n // Private extension trait for local helper methods\n impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+pub(super) trait EvalContextExtPriv<'mir, 'tcx: 'mir>:\n+    crate::MiriInterpCxExt<'mir, 'tcx>\n+{\n     #[inline]\n     // Miri sync structures contain zero-initialized ids stored at some offset behind a pointer\n     fn get_or_create_id<Id: SyncId>(\n@@ -236,8 +197,8 @@ trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             .atomic_compare_exchange_scalar(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, this.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n+                Scalar::from_u32(next_id.to_u32()),\n+                AtomicRwOrd::Relaxed, // deliberately *no* synchronization\n                 AtomicReadOrd::Relaxed,\n                 false,\n             )?\n@@ -306,7 +267,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         offset: u64,\n     ) -> InterpResult<'tcx, MutexId> {\n         let this = self.eval_context_mut();\n-        this.mutex_get_or_create(|ecx, next_id| Ok(ecx.get_or_create_id(next_id, lock_op, offset)?))\n+        this.mutex_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n     }\n \n     fn rwlock_get_or_create_id(\n@@ -327,22 +288,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.condvar_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n     }\n \n-    fn init_once_get_or_create_id(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Provenance>,\n-        offset: u64,\n-    ) -> InterpResult<'tcx, InitOnceId> {\n-        let this = self.eval_context_mut();\n-        this.init_once_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n-    }\n-\n-    #[inline]\n-    /// Create state for a new mutex.\n-    fn mutex_create(&mut self) -> MutexId {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.mutexes.push(Default::default())\n-    }\n-\n     #[inline]\n     /// Provides the closure with the next MutexId. Creates that mutex if the closure returns None,\n     /// otherwise returns the value from the closure\n@@ -427,25 +372,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Put the thread into the queue waiting for the mutex.\n+    #[inline]\n     fn mutex_enqueue_and_block(&mut self, id: MutexId, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.mutex_is_locked(id), \"queing on unlocked mutex\");\n         this.machine.threads.sync.mutexes[id].queue.push_back(thread);\n         this.block_thread(thread);\n     }\n \n-    #[inline]\n-    /// Create state for a new read write lock.\n-    fn rwlock_create(&mut self) -> RwLockId {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks.push(Default::default())\n-    }\n-\n-    #[inline]\n     /// Provides the closure with the next RwLockId. Creates that RwLock if the closure returns None,\n     /// otherwise returns the value from the closure\n+    #[inline]\n     fn rwlock_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, RwLockId>\n     where\n         F: FnOnce(&mut MiriInterpCx<'mir, 'tcx>, RwLockId) -> InterpResult<'tcx, Option<RwLockId>>,\n@@ -475,8 +413,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         rwlock.writer.is_some() || rwlock.readers.is_empty().not()\n     }\n \n-    #[inline]\n     /// Check if write locked.\n+    #[inline]\n     fn rwlock_is_write_locked(&self, id: RwLockId) -> bool {\n         let this = self.eval_context_ref();\n         let rwlock = &this.machine.threads.sync.rwlocks[id];\n@@ -533,17 +471,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         true\n     }\n \n-    #[inline]\n     /// Put the reader in the queue waiting for the lock and block it.\n+    #[inline]\n     fn rwlock_enqueue_and_block_reader(&mut self, id: RwLockId, reader: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_write_locked(id), \"read-queueing on not write locked rwlock\");\n         this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n         this.block_thread(reader);\n     }\n \n-    #[inline]\n     /// Lock by setting the writer that owns the lock.\n+    #[inline]\n     fn rwlock_writer_lock(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(!this.rwlock_is_locked(id), \"the rwlock is already locked\");\n@@ -555,8 +493,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Try to unlock by removing the writer.\n+    #[inline]\n     fn rwlock_writer_unlock(&mut self, id: RwLockId, expected_writer: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n@@ -593,25 +531,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Put the writer in the queue waiting for the lock.\n+    #[inline]\n     fn rwlock_enqueue_and_block_writer(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_locked(id), \"write-queueing on unlocked rwlock\");\n         this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n         this.block_thread(writer);\n     }\n \n-    #[inline]\n-    /// Create state for a new conditional variable.\n-    fn condvar_create(&mut self) -> CondvarId {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.condvars.push(Default::default())\n-    }\n-\n-    #[inline]\n     /// Provides the closure with the next CondvarId. Creates that Condvar if the closure returns None,\n     /// otherwise returns the value from the closure\n+    #[inline]\n     fn condvar_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, CondvarId>\n     where\n         F: FnOnce(\n@@ -630,8 +561,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Is the conditional variable awaited?\n+    #[inline]\n     fn condvar_is_awaited(&mut self, id: CondvarId) -> bool {\n         let this = self.eval_context_mut();\n         !this.machine.threads.sync.condvars[id].waiters.is_empty()\n@@ -707,144 +638,4 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             futex.waiters.retain(|waiter| waiter.thread != thread);\n         }\n     }\n-\n-    #[inline]\n-    /// Create state for a new one time initialization.\n-    fn init_once_create(&mut self) -> InitOnceId {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.init_onces.push(Default::default())\n-    }\n-\n-    #[inline]\n-    /// Provides the closure with the next InitOnceId. Creates that InitOnce if the closure returns None,\n-    /// otherwise returns the value from the closure\n-    fn init_once_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, InitOnceId>\n-    where\n-        F: FnOnce(\n-            &mut MiriInterpCx<'mir, 'tcx>,\n-            InitOnceId,\n-        ) -> InterpResult<'tcx, Option<InitOnceId>>,\n-    {\n-        let this = self.eval_context_mut();\n-        let next_index = this.machine.threads.sync.init_onces.next_index();\n-        if let Some(old) = existing(this, next_index)? {\n-            Ok(old)\n-        } else {\n-            let new_index = this.machine.threads.sync.init_onces.push(Default::default());\n-            assert_eq!(next_index, new_index);\n-            Ok(new_index)\n-        }\n-    }\n-\n-    #[inline]\n-    fn init_once_status(&mut self, id: InitOnceId) -> InitOnceStatus {\n-        let this = self.eval_context_ref();\n-        this.machine.threads.sync.init_onces[id].status\n-    }\n-\n-    #[inline]\n-    /// Put the thread into the queue waiting for the initialization.\n-    fn init_once_enqueue_and_block(\n-        &mut self,\n-        id: InitOnceId,\n-        thread: ThreadId,\n-        callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n-    ) {\n-        let this = self.eval_context_mut();\n-        let init_once = &mut this.machine.threads.sync.init_onces[id];\n-        assert_ne!(init_once.status, InitOnceStatus::Complete, \"queueing on complete init once\");\n-        init_once.waiters.push_back(InitOnceWaiter { thread, callback });\n-        this.block_thread(thread);\n-    }\n-\n-    #[inline]\n-    fn init_once_begin(&mut self, id: InitOnceId) {\n-        let this = self.eval_context_mut();\n-        let init_once = &mut this.machine.threads.sync.init_onces[id];\n-        assert_eq!(\n-            init_once.status,\n-            InitOnceStatus::Uninitialized,\n-            \"begining already begun or complete init once\"\n-        );\n-        init_once.status = InitOnceStatus::Begun;\n-    }\n-\n-    #[inline]\n-    fn init_once_complete(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let current_thread = this.get_active_thread();\n-        let init_once = &mut this.machine.threads.sync.init_onces[id];\n-\n-        assert_eq!(\n-            init_once.status,\n-            InitOnceStatus::Begun,\n-            \"completing already complete or uninit init once\"\n-        );\n-\n-        init_once.status = InitOnceStatus::Complete;\n-\n-        // Each complete happens-before the end of the wait\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n-        }\n-\n-        // need to take the queue to avoid having `this` be borrowed multiple times\n-        for waiter in std::mem::take(&mut init_once.waiters) {\n-            this.unblock_thread(waiter.thread);\n-\n-            this.set_active_thread(waiter.thread);\n-            waiter.callback.call(this)?;\n-            this.set_active_thread(current_thread);\n-\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn init_once_fail(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let current_thread = this.get_active_thread();\n-        let init_once = &mut this.machine.threads.sync.init_onces[id];\n-        assert_eq!(\n-            init_once.status,\n-            InitOnceStatus::Begun,\n-            \"failing already completed or uninit init once\"\n-        );\n-\n-        // Each complete happens-before the end of the wait\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n-        }\n-\n-        // the behavior of failing the initialization is left vague by the docs\n-        // it had to be determined experimentally\n-        if let Some(waiter) = init_once.waiters.pop_front() {\n-            // try initializing again on a different thread\n-            init_once.status = InitOnceStatus::Begun;\n-\n-            this.unblock_thread(waiter.thread);\n-\n-            this.set_active_thread(waiter.thread);\n-            waiter.callback.call(this)?;\n-            this.set_active_thread(current_thread);\n-\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-        } else {\n-            init_once.status = InitOnceStatus::Uninitialized;\n-        }\n-\n-        Ok(())\n-    }\n }"}, {"sha": "479353bb9839e9ea991a5c2c5a22d69df9242577", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=a39629b88f6c1f2044326d94aced180a4015541c", "patch": "@@ -83,34 +83,28 @@ pub use crate::shims::EvalContextExt as _;\n \n pub use crate::clock::{Clock, Instant};\n pub use crate::concurrency::{\n-    data_race::{\n-        AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n-        EvalContextExt as DataRaceEvalContextExt,\n-    },\n-    sync::{CondvarId, EvalContextExt as SyncEvalContextExt, InitOnceId, MutexId, RwLockId, SyncId},\n-    thread::{\n-        EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager,\n-        ThreadState, Time,\n-    },\n+    data_race::{AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, EvalContextExt as _},\n+    init_once::{EvalContextExt as _, InitOnceId},\n+    sync::{CondvarId, EvalContextExt as _, MutexId, RwLockId, SyncId},\n+    thread::{EvalContextExt as _, SchedulingAction, ThreadId, ThreadManager, ThreadState, Time},\n };\n pub use crate::diagnostics::{\n-    report_error, EvalContextExt as DiagnosticsEvalContextExt, NonHaltingDiagnostic,\n-    TerminationInfo,\n+    report_error, EvalContextExt as _, NonHaltingDiagnostic, TerminationInfo,\n };\n pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n-pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n+pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n     AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind, Provenance,\n     ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n-pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n+pub use crate::operator::EvalContextExt as _;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n+    CallId, EvalContextExt as _, Item, Permission, SbTag, Stack, Stacks,\n };\n pub use crate::tag_gc::{EvalContextExt as _, VisitTags};\n "}, {"sha": "bf6c1f8756290528017b55b3204fc546f99479d1", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=a39629b88f6c1f2044326d94aced180a4015541c", "patch": "@@ -274,15 +274,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n                 this.update_environ()?;\n             }\n-            Ok(Scalar::from_i32(1)) // return non-zero on success\n+            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n         } else {\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n             let var_ptr = alloc_env_var_as_wide_str(&name, &value, this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n-            Ok(Scalar::from_i32(1)) // return non-zero on success\n+            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n         }\n     }\n \n@@ -411,14 +411,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.reject_in_isolation(\"`SetCurrentDirectoryW`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n-            return Ok(Scalar::from_i32(0));\n+            return this.eval_windows(\"c\", \"FALSE\");\n         }\n \n         match env::set_current_dir(path) {\n-            Ok(()) => Ok(Scalar::from_i32(1)),\n+            Ok(()) => this.eval_windows(\"c\", \"TRUE\"),\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n-                Ok(Scalar::from_i32(0))\n+                this.eval_windows(\"c\", \"FALSE\")\n             }\n         }\n     }"}, {"sha": "3e1e34c5dbe7bd3921114afea8fdaed10a1728e6", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=a39629b88f6c1f2044326d94aced180a4015541c", "patch": "@@ -19,6 +19,10 @@ use crate::*;\n /// in `pthread_mutexattr_settype` function.\n const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n+const MUTEX_ID_OFFSET: u64 = 4;\n+const RWLOCK_ID_OFFSET: u64 = 4;\n+const CONDVAR_ID_OFFSET: u64 = 4;\n+\n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: Scalar<Provenance>,\n@@ -354,7 +358,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, 4)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -394,7 +398,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, 4)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -430,7 +434,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, 4)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread) {\n@@ -464,7 +468,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.mutex_get_or_create_id(mutex_op, 4)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n \n         if this.mutex_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked mutex\");\n@@ -487,7 +491,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -505,7 +509,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -522,7 +526,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -552,7 +556,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -569,7 +573,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         #[allow(clippy::if_same_then_else)]\n@@ -588,7 +592,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n \n         if this.rwlock_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked rwlock\");\n@@ -691,7 +695,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n         if let Some((thread, mutex)) = this.condvar_signal(id) {\n             post_cond_signal(this, thread, mutex)?;\n         }\n@@ -704,7 +708,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         cond_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n \n         while let Some((thread, mutex)) = this.condvar_signal(id) {\n             post_cond_signal(this, thread, mutex)?;\n@@ -720,8 +724,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n-        let mutex_id = this.mutex_get_or_create_id(mutex_op, 4)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n@@ -741,8 +745,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.check_no_isolation(\"`pthread_cond_timedwait`\")?;\n \n-        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n-        let mutex_id = this.mutex_get_or_create_id(mutex_op, 4)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         // Extract the timeout.\n@@ -818,7 +822,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n         if this.condvar_is_awaited(id) {\n             throw_ub_format!(\"destroying an awaited conditional variable\");\n         }"}, {"sha": "8064ca566755cc9bbc4c219d7563bf5d77e6a3de", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39629b88f6c1f2044326d94aced180a4015541c/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=a39629b88f6c1f2044326d94aced180a4015541c", "patch": "@@ -1,14 +1,17 @@\n-use crate::concurrency::sync::InitOnceStatus;\n+use crate::concurrency::init_once::InitOnceStatus;\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n+const SRWLOCK_ID_OFFSET: u64 = 0;\n+const INIT_ONCE_ID_OFFSET: u64 = 0;\n+\n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n \n #[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -32,7 +35,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         lock_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -46,7 +49,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn ReleaseSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_writer_unlock(id, active_thread) {\n@@ -61,7 +64,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn AcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -78,7 +81,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         lock_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -91,7 +94,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn ReleaseSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_reader_unlock(id, active_thread) {\n@@ -114,7 +117,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();\n \n-        let id = this.init_once_get_or_create_id(init_once_op, 0)?;\n+        let id = this.init_once_get_or_create_id(init_once_op, INIT_ONCE_ID_OFFSET)?;\n         let flags = this.read_scalar(flags_op)?.to_u32()?;\n         let pending_place = this.deref_operand(pending_op)?.into();\n         let context = this.read_pointer(context_op)?;\n@@ -127,49 +130,56 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             throw_unsup_format!(\"non-null `lpContext` in `InitOnceBeginInitialize`\");\n         }\n \n-        struct Callback<'tcx> {\n-            init_once_id: InitOnceId,\n-            pending_place: PlaceTy<'tcx, Provenance>,\n-        }\n-\n-        impl<'tcx> VisitTags for Callback<'tcx> {\n-            fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-                let Callback { init_once_id: _, pending_place } = self;\n-                pending_place.visit_tags(visit);\n-            }\n-        }\n-\n-        impl<'mir, 'tcx> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n-            fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n-                let pending = match this.init_once_status(self.init_once_id) {\n-                    InitOnceStatus::Uninitialized =>\n-                        unreachable!(\"status should have either been set to begun or complete\"),\n-                    InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\")?,\n-                    InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\")?,\n-                };\n-\n-                this.write_scalar(pending, &self.pending_place)?;\n-\n-                Ok(())\n-            }\n-        }\n-\n         match this.init_once_status(id) {\n             InitOnceStatus::Uninitialized => {\n                 this.init_once_begin(id);\n                 this.write_scalar(this.eval_windows(\"c\", \"TRUE\")?, &pending_place)?;\n             }\n-            InitOnceStatus::Begun =>\n+            InitOnceStatus::Begun => {\n+                // Someone else is already on it.\n+                // Block this thread until they are done.\n+                // When we are woken up, set the `pending` flag accordingly.\n+                struct Callback<'tcx> {\n+                    init_once_id: InitOnceId,\n+                    pending_place: PlaceTy<'tcx, Provenance>,\n+                }\n+\n+                impl<'tcx> VisitTags for Callback<'tcx> {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                        let Callback { init_once_id: _, pending_place } = self;\n+                        pending_place.visit_tags(visit);\n+                    }\n+                }\n+\n+                impl<'mir, 'tcx> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                    fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                        let pending = match this.init_once_status(self.init_once_id) {\n+                            InitOnceStatus::Uninitialized =>\n+                                unreachable!(\n+                                    \"status should have either been set to begun or complete\"\n+                                ),\n+                            InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\")?,\n+                            InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\")?,\n+                        };\n+\n+                        this.write_scalar(pending, &self.pending_place)?;\n+\n+                        Ok(())\n+                    }\n+                }\n+\n                 this.init_once_enqueue_and_block(\n                     id,\n                     active_thread,\n                     Box::new(Callback { init_once_id: id, pending_place }),\n-                ),\n+                )\n+            }\n             InitOnceStatus::Complete =>\n                 this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?,\n         }\n \n-        Ok(Scalar::from_i32(1))\n+        // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock).\n+        this.eval_windows(\"c\", \"TRUE\")\n     }\n \n     fn InitOnceComplete(\n@@ -180,7 +190,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let id = this.init_once_get_or_create_id(init_once_op, 0)?;\n+        let id = this.init_once_get_or_create_id(init_once_op, INIT_ONCE_ID_OFFSET)?;\n         let flags = this.read_scalar(flags_op)?.to_u32()?;\n         let context = this.read_pointer(context_op)?;\n \n@@ -209,6 +219,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.init_once_fail(id)?;\n         }\n \n-        Ok(Scalar::from_i32(1))\n+        this.eval_windows(\"c\", \"TRUE\")\n     }\n }"}]}