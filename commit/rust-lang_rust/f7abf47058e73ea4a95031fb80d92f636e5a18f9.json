{"sha": "f7abf47058e73ea4a95031fb80d92f636e5a18f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YWJmNDcwNThlNzNlYTRhOTUwMzFmYjgwZDkyZjYzNmU1YTE4Zjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T08:51:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-03T12:00:51Z"}, "message": "Re-introduce `McResult<>` as a way of aborting mem-categorization (and\nexpr-use-visitor) early.  Turns out I was wrong to remove this; it\ncauses a lot of pain trying to run EUV etc during typeck without\nICEing on erroneous programs.", "tree": {"sha": "d0bb9e145ab3ed2c82ad58cf755eeeca9b8f63c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0bb9e145ab3ed2c82ad58cf755eeeca9b8f63c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7abf47058e73ea4a95031fb80d92f636e5a18f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7abf47058e73ea4a95031fb80d92f636e5a18f9", "html_url": "https://github.com/rust-lang/rust/commit/f7abf47058e73ea4a95031fb80d92f636e5a18f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7abf47058e73ea4a95031fb80d92f636e5a18f9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2ba13939aa9672d886beb06efde7aeda2d5f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2ba13939aa9672d886beb06efde7aeda2d5f7f", "html_url": "https://github.com/rust-lang/rust/commit/fc2ba13939aa9672d886beb06efde7aeda2d5f7f"}], "stats": {"total": 305, "additions": 175, "deletions": 130}, "files": [{"sha": "06815266266a5071127cf652364c2e51fc6bdf4e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f7abf47058e73ea4a95031fb80d92f636e5a18f9", "patch": "@@ -300,6 +300,20 @@ pub struct ExprUseVisitor<'d,'t,'tcx:'t,TYPER:'t> {\n     mc: mc::MemCategorizationContext<'t,TYPER>,\n     delegate: &'d mut (Delegate<'tcx>+'d),\n     param_env: &'t ParameterEnvironment<'tcx>,\n+// If the TYPER results in an error, it's because the type check\n+// failed (or will fail, when the error is uncovered and reported\n+// during writeback). In this case, we just ignore this part of the\n+// code.\n+//\n+// Note that this macro appears similar to try!(), but, unlike try!(),\n+// it does not propagate the error.\n+macro_rules! return_if_err {\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => v,\n+            Err(()) => return\n+        }\n+    )\n }\n \n /// Whether the elements of an overloaded operation are passed by value or by reference\n@@ -332,7 +346,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                          decl: &ast::FnDecl,\n                          body: &ast::Block) {\n         for arg in decl.inputs.iter() {\n-            let arg_ty = self.typer.node_ty(arg.pat.id);\n+            let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n \n             let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -369,7 +383,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn consume_expr(&mut self, expr: &ast::Expr) {\n         debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n \n-        let cmt = self.mc.cat_expr(expr);\n+        let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(expr.id, expr.span, cmt);\n         self.walk_expr(expr);\n     }\n@@ -378,7 +392,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                    assignment_expr: &ast::Expr,\n                    expr: &ast::Expr,\n                    mode: MutateMode) {\n-        let cmt = self.mc.cat_expr(expr);\n+        let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.mutate(assignment_expr.id, assignment_expr.span, cmt, mode);\n         self.walk_expr(expr);\n     }\n@@ -391,7 +405,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"borrow_expr(expr={}, r={}, bk={})\",\n                expr.repr(self.tcx()), r.repr(self.tcx()), bk.repr(self.tcx()));\n \n-        let cmt = self.mc.cat_expr(expr);\n+        let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n \n         // Note: Unlike consume, we can ignore ExprParen. cat_expr\n@@ -491,7 +505,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprMatch(ref discr, ref arms, _) => {\n-                let discr_cmt = self.mc.cat_expr(&**discr);\n+                let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n                 self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n@@ -509,7 +523,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ast::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n-                let expr_ty = ty::expr_ty(self.tcx(), expr);\n+                let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n                 let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n                 let bk = ty::BorrowKind::from_mutbl(m);\n                 self.borrow_expr(&**base, r, bk, AddrOf);\n@@ -550,7 +564,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Fetch the type of the value that the iteration yields to\n                 // produce the pattern's categorized mutable type.\n-                let pattern_type = self.typer.node_ty(pat.id);\n+                let pattern_type = return_if_err!(self.typer.node_ty(pat.id));\n                 let blk_scope = region::CodeExtent::from_node_id(blk.id);\n                 let pat_cmt = self.mc.cat_rvalue(pat.id,\n                                                  pat.span,\n@@ -638,7 +652,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n-        let callee_ty = self.typer.expr_ty_adjusted(callee);\n+        let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={} callee_ty={}\",\n                callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n         let call_scope = region::CodeExtent::from_node_id(call.id);\n@@ -735,7 +749,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n                 self.walk_expr(&**expr);\n-                let init_cmt = self.mc.cat_expr(&**expr);\n+                let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n                 self.walk_irrefutable_pat(init_cmt, &*local.pat);\n             }\n         }\n@@ -769,7 +783,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             None => { return; }\n         };\n \n-        let with_cmt = self.mc.cat_expr(&*with_expr);\n+        let with_cmt = return_if_err!(self.mc.cat_expr(&*with_expr));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -824,7 +838,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // rvalue.\n                         debug!(\"walk_adjustment(AutoAddEnv|AdjustReifyFnPointer)\");\n                         let cmt_unadjusted =\n-                            self.mc.cat_expr_unadjusted(expr);\n+                            return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                     }\n                     ty::AdjustDerefRef(ty::AutoDerefRef {\n@@ -858,7 +872,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             match self.typer.node_method_ty(deref_id) {\n                 None => {}\n                 Some(method_ty) => {\n-                    let cmt = self.mc.cat_expr_autoderefd(expr, i);\n+                    let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n                     let self_ty = ty::ty_fn_args(method_ty)[0];\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n@@ -888,14 +902,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n                                          AutoRefs, found: {}\", n));\n                 let cmt_unadjusted =\n-                    self.mc.cat_expr_unadjusted(expr);\n+                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                 self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 return;\n             }\n             _ => {}\n         }\n \n-        let cmt_derefd = self.mc.cat_expr_autoderefd(expr, n);\n+        let cmt_derefd = return_if_err!(\n+            self.mc.cat_expr_autoderefd(expr, n));\n         debug!(\"walk_adjustment: cmt_derefd={}\",\n                cmt_derefd.repr(self.tcx()));\n \n@@ -988,7 +1003,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                mode: &mut TrackMatchMode<Span>) {\n         debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n-        self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n+        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n             let tcx = self.typer.tcx();\n             let def_map = &self.typer.tcx().def_map;\n             if pat_util::pat_is_binding(def_map, pat) {\n@@ -1011,7 +1026,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     }\n                 }\n             }\n-        });\n+        }));\n     }\n \n     /// The core driver for walking a pattern; `match_mode` must be\n@@ -1028,8 +1043,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         let typer = self.typer;\n         let def_map = &self.typer.tcx().def_map;\n         let delegate = &mut self.delegate;\n-        let param_env = self.param_env;\n-        mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n@@ -1039,7 +1053,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = typer.node_ty(pat.id);\n+                let pat_ty = return_if_err!(typer.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n@@ -1080,7 +1094,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // matched.\n \n                         let (slice_cmt, slice_mutbl, slice_r) =\n-                            mc.cat_slice_pattern(cmt_pat, &**slice_pat);\n+                            return_if_err!(mc.cat_slice_pattern(cmt_pat, &**slice_pat));\n \n                         // Note: We declare here that the borrow\n                         // occurs upon entering the `[...]`\n@@ -1110,13 +1124,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     _ => { }\n                 }\n             }\n-        });\n+        }));\n \n         // Do a second pass over the pattern, calling `matched_pat` on\n         // the interior nodes (enum variants and structs), as opposed\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n-        mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             let def_map = def_map.borrow();\n             let tcx = typer.tcx();\n \n@@ -1197,7 +1211,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     // cases either.\n                 }\n             }\n-        });\n+        }));\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n@@ -1221,9 +1235,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let id_var = freevar.def.def_id().node;\n-            let cmt_var = self.cat_captured_var(closure_expr.id,\n-                                                closure_expr.span,\n-                                                freevar.def);\n+            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n+                                                               closure_expr.span,\n+                                                               freevar.def));\n \n             // Lookup the kind of borrow the callee requires, as\n             // inferred by regionbk\n@@ -1244,11 +1258,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                               closure_expr: &ast::Expr,\n                               freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n-            let cmt_var = self.cat_captured_var(closure_expr.id,\n-                                                closure_expr.span,\n-                                                freevar.def);\n-            let mode = copy_or_move(self.tcx(), cmt_var.ty,\n-                                    self.param_env, CaptureMove);\n+            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n+                                                               closure_expr.span,\n+                                                               freevar.def));\n+            let mode = copy_or_move(self.typer, &cmt_var, CaptureMove);\n             self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n         }\n     }\n@@ -1257,11 +1270,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n                         upvar_def: def::Def)\n-                        -> mc::cmt<'tcx> {\n+                        -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.def_id().node;\n-        let var_ty = self.typer.node_ty(var_id);\n+        let var_ty = try!(self.typer.node_ty(var_id));\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }"}, {"sha": "dbe005ea63d5f3ad607c85af7f60e3727d5b787a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 87, "deletions": 80, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f7abf47058e73ea4a95031fb80d92f636e5a18f9", "patch": "@@ -75,7 +75,7 @@ use middle::def;\n use middle::region;\n use middle::ty::{mod, Ty};\n use util::nodemap::{NodeMap};\n-use util::ppaux::{ty_to_string, Repr};\n+use util::ppaux::{Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n@@ -264,6 +264,8 @@ pub struct MemCategorizationContext<'t,TYPER:'t> {\n \n impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n \n+pub type McResult<T> = Result<T, ()>;\n+\n /// The `Typer` trait provides the interface for the mem-categorization\n /// module to the results of the type check. It can be used to query\n /// the type assigned to an expression node, to inquire after adjustments,\n@@ -282,8 +284,10 @@ impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n /// can be sure that only `Ok` results will occur.\n pub trait Typer<'tcx> : ty::UnboxedClosureTyper<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx>;\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx>;\n+    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool;\n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>;\n@@ -382,22 +386,22 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn expr_ty(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n-        let unadjusted_ty = self.expr_ty(expr);\n-        ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                      self.typer.adjustments().borrow().get(&expr.id),\n-                      |method_call| self.typer.node_method_ty(method_call))\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+        let unadjusted_ty = try!(self.expr_ty(expr));\n+        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n+                         self.typer.adjustments().borrow().get(&expr.id),\n+                         |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: &ast::Pat) -> Ty<'tcx> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n         let tcx = self.typer.tcx();\n         let base_ty = self.typer.node_ty(pat.id);\n         // FIXME (Issue #18207): This code detects whether we are\n@@ -420,7 +424,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         ret_ty\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> cmt<'tcx> {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n         match self.typer.adjustments().borrow().get(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -434,8 +438,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                expr.repr(self.tcx()));\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n-                        let expr_ty = self.expr_ty_adjusted(expr);\n-                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                        let expr_ty = try!(self.expr_ty_adjusted(expr));\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n                     ty::AdjustDerefRef(\n@@ -445,8 +449,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                expr.repr(self.tcx()));\n                         // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n-                        let expr_ty = self.expr_ty_adjusted(expr);\n-                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                        let expr_ty = try!(self.expr_ty_adjusted(expr));\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n                     ty::AdjustDerefRef(\n@@ -463,46 +467,46 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n                                autoderefs: uint)\n-                               -> cmt<'tcx> {\n-        let mut cmt = self.cat_expr_unadjusted(expr);\n+                               -> McResult<cmt<'tcx>> {\n+        let mut cmt = try!(self.cat_expr_unadjusted(expr));\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n                cmt.repr(self.tcx()));\n         for deref in range(1u, autoderefs + 1) {\n-            cmt = self.cat_deref(expr, cmt, deref, false);\n+            cmt = try!(self.cat_deref(expr, cmt, deref, false));\n         }\n-        return cmt;\n+        return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> cmt<'tcx> {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n         debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n-        let expr_ty = self.expr_ty(expr);\n+        let expr_ty = try!(self.expr_ty(expr));\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, ref e_base) => {\n-            let base_cmt = self.cat_expr(&**e_base);\n+            let base_cmt = try!(self.cat_expr(&**e_base));\n             self.cat_deref(expr, base_cmt, 0, false)\n           }\n \n           ast::ExprField(ref base, f_name) => {\n-            let base_cmt = self.cat_expr(&**base);\n+            let base_cmt = try!(self.cat_expr(&**base));\n             debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n                    expr.id,\n                    expr.repr(self.tcx()),\n                    base_cmt.repr(self.tcx()));\n-            self.cat_field(expr, base_cmt, f_name.node.name, expr_ty)\n+            Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n           }\n \n           ast::ExprTupField(ref base, idx) => {\n-            let base_cmt = self.cat_expr(&**base);\n-            self.cat_tup_field(expr, base_cmt, idx.node, expr_ty)\n+            let base_cmt = try!(self.cat_expr(&**base));\n+            Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }\n \n           ast::ExprIndex(ref base, ref idx) => {\n             match idx.node {\n                 ast::ExprRange(..) => {\n                     // Slicing syntax special case (KILLME).\n-                    self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                    Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                 }\n                 _ => {\n                     let method_call = ty::MethodCall::expr(expr.id());\n@@ -517,7 +521,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                                                 ret_ty), 1, true)\n                         }\n                         None => {\n-                            self.cat_index(expr, self.cat_expr(&**base))\n+                            self.cat_index(expr, try!(self.cat_expr(&**base)))\n                         }\n                     }\n                 }\n@@ -545,7 +549,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n           ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n           ast::ExprForLoop(..) => {\n-            self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+            Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n \n           ast::ExprIfLet(..) => {\n@@ -562,43 +566,43 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n                    def: def::Def)\n-                   -> cmt<'tcx> {\n+                   -> McResult<cmt<'tcx>> {\n         debug!(\"cat_def: id={} expr={} def={}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefFn(..) |\n           def::DefStaticMethod(..) | def::DefConst(..) => {\n-                self.cat_rvalue_node(id, span, expr_ty)\n+                Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) |\n           def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {\n-              Rc::new(cmt_ {\n+              Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n                   ty:expr_ty,\n                   note: NoteNone\n-              })\n+              }))\n           }\n \n           def::DefStatic(_, mutbl) => {\n-              Rc::new(cmt_ {\n+              Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty,\n                   note: NoteNone\n-              })\n+              }))\n           }\n \n           def::DefUpvar(var_id, fn_node_id, _) => {\n-              let ty = self.node_ty(fn_node_id);\n+              let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n                   ty::ty_closure(ref closure_ty) => {\n                       // Translate old closure type info into unboxed\n@@ -635,14 +639,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           def::DefLocal(vid) => {\n-            Rc::new(cmt_ {\n+            Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n                 ty: expr_ty,\n                 note: NoteNone\n-            })\n+            }))\n           }\n         }\n     }\n@@ -657,7 +661,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  kind: ty::UnboxedClosureKind,\n                  mode: ast::CaptureClause,\n                  is_unboxed: bool)\n-                 -> cmt<'tcx> {\n+                 -> McResult<cmt<'tcx>> {\n         // An upvar can have up to 3 components.  The base is a\n         // `cat_upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n@@ -679,7 +683,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // FnOnce         | copied               | upvar -> &'up bk\n         // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n         // old proc/once  | copied               | N/A\n-        let var_ty = self.node_ty(var_id);\n+        let var_ty = try!(self.node_ty(var_id));\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n@@ -727,7 +731,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         });\n \n         // First, switch by capture mode\n-        match mode {\n+        Ok(match mode {\n             ast::CaptureByValue => {\n                 let mut base = cmt_ {\n                     id: id,\n@@ -809,7 +813,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteUpvarRef(upvar_id)\n                 })\n             }\n-        }\n+        })\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -882,7 +886,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                              base_cmt: cmt<'tcx>,\n                              deref_cnt: uint,\n                              implicit: bool)\n-                             -> cmt<'tcx> {\n+                             -> McResult<cmt<'tcx>> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => ty::AutoObject,\n             _ if deref_cnt != 0 => ty::AutoDeref(deref_cnt),\n@@ -896,7 +900,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let method_ty = self.typer.node_method_ty(method_call);\n \n         debug!(\"cat_deref: method_call={} method_ty={}\",\n-            method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n+               method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n@@ -922,8 +926,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                     deref_cnt: uint,\n                                     deref_ty: Ty<'tcx>,\n                                     implicit: bool)\n-                                    -> cmt<'tcx> {\n-        let (m, cat) = match deref_kind(self.tcx(), base_cmt.ty) {\n+                                    -> McResult<cmt<'tcx>>\n+    {\n+        let (m, cat) = match try!(deref_kind(base_cmt.ty)) {\n             deref_ptr(ptr) => {\n                 let ptr = if implicit {\n                     match ptr {\n@@ -943,20 +948,20 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n         };\n-        Rc::new(cmt_ {\n+        Ok(Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             cat: cat,\n             mutbl: m,\n             ty: deref_ty,\n             note: NoteNone\n-        })\n+        }))\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n                                  mut base_cmt: cmt<'tcx>)\n-                                 -> cmt<'tcx> {\n+                                 -> McResult<cmt<'tcx>> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -1021,15 +1026,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn deref_vec<N:ast_node>(&self,\n                              elt: &N,\n                              base_cmt: cmt<'tcx>)\n-                             -> cmt<'tcx> {\n-        match deref_kind(self.tcx(), base_cmt.ty) {\n+                             -> McResult<cmt<'tcx>>\n+    {\n+        match try!(deref_kind(base_cmt.ty)) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n                 // the deref is explicit in the resulting cmt\n-                Rc::new(cmt_ {\n+                Ok(Rc::new(cmt_ {\n                     id:elt.id(),\n                     span:elt.span(),\n                     cat:cat_deref(base_cmt.clone(), 0, ptr),\n@@ -1039,11 +1045,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n                     },\n                     note: NoteNone\n-                })\n+                }))\n             }\n \n             deref_interior(_) => {\n-                base_cmt\n+                Ok(base_cmt)\n             }\n         }\n     }\n@@ -1058,13 +1064,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt<'tcx>,\n                              slice_pat: &ast::Pat)\n-                             -> (cmt<'tcx>, ast::Mutability, ty::Region) {\n-        let slice_ty = self.node_ty(slice_pat.id);\n+                             -> McResult<(cmt<'tcx>, ast::Mutability, ty::Region)> {\n+        let slice_ty = try!(self.node_ty(slice_pat.id));\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n                                                     slice_ty);\n-        let cmt_slice = self.cat_index(slice_pat, self.deref_vec(slice_pat, vec_cmt));\n-        return (cmt_slice, slice_mutbl, slice_r);\n+        let cmt_slice = try!(self.cat_index(slice_pat, try!(self.deref_vec(slice_pat, vec_cmt))));\n+        return Ok((cmt_slice, slice_mutbl, slice_r));\n \n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n@@ -1119,15 +1125,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         })\n     }\n \n-    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) where\n-        F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) -> McResult<()>\n+        where F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F) where\n-        F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F)\n+                       -> McResult<()>\n+        where F : FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1208,29 +1215,29 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 Some(&def::DefVariant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n+                        let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern_(subcmt, &**subpat, op);\n+                        try!(self.cat_pattern_(subcmt, &**subpat, op));\n                     }\n                 }\n                 Some(&def::DefStruct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n+                        let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern_(cmt_field, &**subpat, op);\n+                        try!(self.cat_pattern_(cmt_field, &**subpat, op));\n                     }\n                 }\n                 Some(&def::DefConst(..)) => {\n                     for subpat in subpats.iter() {\n-                        self.cat_pattern_(cmt.clone(), &**subpat, op);\n+                        try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }\n                 }\n                 _ => {\n@@ -1242,7 +1249,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatIdent(_, _, Some(ref subpat)) => {\n-              self.cat_pattern_(cmt, &**subpat, op);\n+              try!(self.cat_pattern_(cmt, &**subpat, op));\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -1252,42 +1259,42 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = self.pat_ty(&*fp.node.pat); // see (*2)\n+                let field_ty = try!(self.pat_ty(&*fp.node.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n-                self.cat_pattern_(cmt_field, &*fp.node.pat, op);\n+                try!(self.cat_pattern_(cmt_field, &*fp.node.pat, op));\n             }\n           }\n \n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n+                let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern_(subcmt, &**subpat, op);\n+                try!(self.cat_pattern_(subcmt, &**subpat, op));\n             }\n           }\n \n           ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n             // @p1, ~p1, ref p1\n-            let subcmt = self.cat_deref(pat, cmt, 0, false);\n-            self.cat_pattern_(subcmt, &**subpat, op);\n+            let subcmt = try!(self.cat_deref(pat, cmt, 0, false));\n+              try!(self.cat_pattern_(subcmt, &**subpat, op));\n           }\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n-              let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n+              let elt_cmt = try!(self.cat_index(pat, try!(self.deref_vec(pat, cmt))));\n               for before_pat in before.iter() {\n-                  self.cat_pattern_(elt_cmt.clone(), &**before_pat, op);\n+                  try!(self.cat_pattern_(elt_cmt.clone(), &**before_pat, op));\n               }\n               for slice_pat in slice.iter() {\n-                  let slice_ty = self.pat_ty(&**slice_pat);\n+                  let slice_ty = try!(self.pat_ty(&**slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  self.cat_pattern_(slice_cmt, &**slice_pat, op);\n+                  try!(self.cat_pattern_(slice_cmt, &**slice_pat, op));\n               }\n               for after_pat in after.iter() {\n-                  self.cat_pattern_(elt_cmt.clone(), &**after_pat, op);\n+                  try!(self.cat_pattern_(elt_cmt.clone(), &**after_pat, op));\n               }\n           }\n "}, {"sha": "079972eff6791bf4e2718b23182377f9af36aed9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f7abf47058e73ea4a95031fb80d92f636e5a18f9", "patch": "@@ -5708,7 +5708,10 @@ pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n             freevars.iter()\n                     .map(|freevar| {\n                         let freevar_def_id = freevar.def.def_id();\n-                        let freevar_ty = typer.node_ty(freevar_def_id.node);\n+                        let freevar_ty = match typer.node_ty(freevar_def_id.node) {\n+                            Ok(t) => { t }\n+                            Err(()) => { return None; }\n+                        };\n                         let freevar_ty = freevar_ty.subst(tcx, substs);\n \n                         match capture_mode {"}, {"sha": "189798a1390c2cfb530628ab1140451b1f6edf27", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f7abf47058e73ea4a95031fb80d92f636e5a18f9", "patch": "@@ -289,12 +289,17 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.ccx.tcx\n     }\n     fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         let ty = self.node_ty(id);\n-        self.infcx().resolve_type_vars_if_possible(&ty)\n+        self.resolve_type_vars_or_error(&ty)\n     }\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n-        let ty = self.expr_ty_adjusted(expr);\n-        self.infcx().resolve_type_vars_if_possible(&ty)\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+        let ty = self.adjust_expr_ty(expr, self.inh.adjustments.borrow().get(&expr.id));\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+        let ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        traits::type_known_to_meet_builtin_bound(self.infcx(), self, ty, ty::BoundCopy, span)\n     }\n     fn node_method_ty(&self, method_call: ty::MethodCall)\n                       -> Option<Ty<'tcx>> {\n@@ -1671,6 +1676,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n+    /// Resolves all type variables in `t` and then, if any were left\n+    /// unresolved, substitutes an error type. This is used after the\n+    /// main checking when doing a second pass before writeback. The\n+    /// justification is that writeback will produce an error for\n+    /// these unconstrained type variables.\n+    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n+        let t = self.infcx().resolve_type_vars_if_possible(t);\n+        if ty::type_has_ty_infer(t) || ty::type_is_error(t) { Err(()) } else { Ok(t) }\n+    }\n+\n     pub fn tag(&self) -> String {\n         format!(\"{}\", self as *const FnCtxt)\n     }"}, {"sha": "0631b0edb4fa7e65ca4152547bc5a753f46d9f29", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7abf47058e73ea4a95031fb80d92f636e5a18f9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f7abf47058e73ea4a95031fb80d92f636e5a18f9", "patch": "@@ -140,6 +140,10 @@ use std::collections::hash_map::Entry::{Vacant, Occupied};\n use self::RepeatingScope::Repeating;\n use self::SubjectNode::Subject;\n \n+// a variation on try that just returns unit\n+macro_rules! ignore_err {\n+    ($e:expr) => (match $e { Ok(e) => e, Err(_) => return () })\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -1027,7 +1031,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                     // While we're here, link the closure's region with a unique\n                     // immutable borrow (gathered later in borrowck)\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-                    let expr_cmt = mc.cat_expr(callee_expr);\n+                    let expr_cmt = ignore_err!(mc.cat_expr(callee_expr));\n                     link_region(rcx, callee_expr.span, call_region,\n                                 ty::UniqueImmBorrow, expr_cmt);\n                     r\n@@ -1136,7 +1140,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-                    let self_cmt = mc.cat_expr_autoderefd(deref_expr, i);\n+                    let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     link_region(rcx, deref_expr.span, *r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n@@ -1232,7 +1236,7 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-        mc.cat_expr(base)\n+        ignore_err!(mc.cat_expr(base))\n     };\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n@@ -1247,7 +1251,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n         Some(ref expr) => &**expr,\n     };\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let discr_cmt = mc.cat_expr(init_expr);\n+    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n \n@@ -1257,7 +1261,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let discr_cmt = mc.cat_expr(discr);\n+    let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n     for arm in arms.iter() {\n         for root_pat in arm.pats.iter() {\n@@ -1303,11 +1307,14 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // `[_, ..slice, _]` pattern\n                 ast::PatVec(_, Some(ref slice_pat), _) => {\n-                    let (slice_cmt, slice_mutbl, slice_r) =\n-                        mc.cat_slice_pattern(sub_cmt, &**slice_pat);\n-                    link_region(rcx, sub_pat.span, slice_r,\n-                                ty::BorrowKind::from_mutbl(slice_mutbl),\n-                                slice_cmt);\n+                    match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n+                        Ok((slice_cmt, slice_mutbl, slice_r)) => {\n+                            link_region(rcx, sub_pat.span, slice_r,\n+                                        ty::BorrowKind::from_mutbl(slice_mutbl),\n+                                        slice_cmt);\n+                        }\n+                        Err(()) => {}\n+                    }\n                 }\n                 _ => {}\n             }\n@@ -1323,7 +1330,7 @@ fn link_autoref(rcx: &Rcx,\n \n     debug!(\"link_autoref(autoref={})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let expr_cmt = mc.cat_expr_autoderefd(expr, autoderefs);\n+    let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n@@ -1345,7 +1352,7 @@ fn link_by_ref(rcx: &Rcx,\n     debug!(\"link_by_ref(expr={}, callee_scope={})\",\n            expr.repr(tcx), callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let expr_cmt = mc.cat_expr(expr);\n+    let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n     link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n }"}]}