{"sha": "611b74e1fe48410c534c5d5a6a0832b810d8ccda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMWI3NGUxZmU0ODQxMGM1MzRjNWQ1YTZhMDgzMmI4MTBkOGNjZGE=", "commit": {"author": {"name": "Ryan Levick", "email": "ryan.levick@gmail.com", "date": "2020-12-10T12:20:07Z"}, "committer": {"name": "Ryan Levick", "email": "me@ryanlevick.com", "date": "2021-06-10T11:18:41Z"}, "message": "Add support for using qualified paths with structs in expression and pattern\nposition.", "tree": {"sha": "1bcd90c934567b774aa8ced3bc9bbf049ff52b7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bcd90c934567b774aa8ced3bc9bbf049ff52b7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/611b74e1fe48410c534c5d5a6a0832b810d8ccda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/611b74e1fe48410c534c5d5a6a0832b810d8ccda", "html_url": "https://github.com/rust-lang/rust/commit/611b74e1fe48410c534c5d5a6a0832b810d8ccda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/611b74e1fe48410c534c5d5a6a0832b810d8ccda/comments", "author": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "626dc5945b93a48a263193ceb39aaf5d015c0144", "url": "https://api.github.com/repos/rust-lang/rust/commits/626dc5945b93a48a263193ceb39aaf5d015c0144", "html_url": "https://github.com/rust-lang/rust/commit/626dc5945b93a48a263193ceb39aaf5d015c0144"}], "stats": {"total": 39, "additions": 25, "deletions": 14}, "files": [{"sha": "2201cf56d52ab357c287633b45c8e3d0b8dbcc7e", "filename": "clippy_lints/src/misc_early/unneeded_field_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs?ref=611b74e1fe48410c534c5d5a6a0832b810d8ccda", "patch": "@@ -5,7 +5,7 @@ use rustc_lint::{EarlyContext, LintContext};\n use super::UNNEEDED_FIELD_PATTERN;\n \n pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::Struct(ref npat, ref pfields, _) = pat.kind {\n+    if let PatKind::Struct(_, ref npat, ref pfields, _) = pat.kind {\n         let mut wilds = 0;\n         let type_name = npat\n             .segments"}, {"sha": "df044538fe19d36b825bcd5d858c9833a6308961", "filename": "clippy_lints/src/misc_early/unneeded_wildcard_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs?ref=611b74e1fe48410c534c5d5a6a0832b810d8ccda", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::Span;\n use super::UNNEEDED_WILDCARD_PATTERN;\n \n pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::TupleStruct(_, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n+    if let PatKind::TupleStruct(_, _, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n         if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n             if let Some((left_index, left_pat)) = patterns[..rest_index]\n                 .iter()"}, {"sha": "1a23e6afe283d52c642406bd97f547440914ca68", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=611b74e1fe48410c534c5d5a6a0832b810d8ccda", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                     self.check_ident(ident);\n                 }\n             },\n-            PatKind::Struct(_, ref fields, _) => {\n+            PatKind::Struct(_, _, ref fields, _) => {\n                 for field in fields {\n                     if !field.is_shorthand {\n                         self.visit_pat(&field.pat);"}, {"sha": "1b3c457b01adb64650f9965d352eabedee6d54d9", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=611b74e1fe48410c534c5d5a6a0832b810d8ccda", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::wildcard_imports, clippy::enum_glob_use)]\n \n-use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path};\n+use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path, eq_maybe_qself};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{meets_msrv, msrvs, over};\n use rustc_ast::mut_visit::*;\n@@ -273,16 +273,16 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n             |k| always_pat!(k, Tuple(ps) => ps),\n         ),\n         // Transform `S(pre, x, post) | ... | S(pre, y, post)` into `S(pre, x | y, post)`.\n-        TupleStruct(path1, ps1) => extend_with_matching_product(\n+        TupleStruct(qself1, path1, ps1) => extend_with_matching_product(\n             ps1, start, alternatives,\n             |k, ps1, idx| matches!(\n                 k,\n-                TupleStruct(path2, ps2) if eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n+                TupleStruct(qself2, path2, ps2) if eq_maybe_qself(qself1, qself2) && eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n             ),\n-            |k| always_pat!(k, TupleStruct(_, ps) => ps),\n+            |k| always_pat!(k, TupleStruct(_, _, ps) => ps),\n         ),\n         // Transform a record pattern `S { fp_0, ..., fp_n }`.\n-        Struct(path1, fps1, rest1) => extend_with_struct_pat(path1, fps1, *rest1, start, alternatives),\n+        Struct(qself1, path1, fps1, rest1) => extend_with_struct_pat(qself1, path1, fps1, *rest1, start, alternatives),\n     };\n \n     alternatives[focus_idx].kind = focus_kind;\n@@ -294,6 +294,7 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n /// So when we fixate on some `ident_k: pat_k`, we try to find `ident_k` in the other pattern\n /// and check that all `fp_i` where `i \u2208 ((0...n) \\ k)` between two patterns are equal.\n fn extend_with_struct_pat(\n+    qself1: &Option<ast::QSelf>,\n     path1: &ast::Path,\n     fps1: &mut Vec<ast::PatField>,\n     rest1: bool,\n@@ -306,8 +307,9 @@ fn extend_with_struct_pat(\n             start,\n             alternatives,\n             |k| {\n-                matches!(k, Struct(path2, fps2, rest2)\n+                matches!(k, Struct(qself2, path2, fps2, rest2)\n                 if rest1 == *rest2 // If one struct pattern has `..` so must the other.\n+                && eq_maybe_qself(qself1, qself2)\n                 && eq_path(path1, path2)\n                 && fps1.len() == fps2.len()\n                 && fps1.iter().enumerate().all(|(idx_1, fp1)| {\n@@ -323,7 +325,7 @@ fn extend_with_struct_pat(\n                 }))\n             },\n             // Extract `p2_k`.\n-            |k| always_pat!(k, Struct(_, mut fps, _) => fps.swap_remove(pos_in_2.take().unwrap()).pat),\n+            |k| always_pat!(k, Struct(_, _, mut fps, _) => fps.swap_remove(pos_in_2.take().unwrap()).pat),\n         );\n         extend_with_tail_or(&mut fps1[idx].pat, tail_or)\n     })"}, {"sha": "e6d84bc7560ba9cc9ae8d2d76c633d938d896a77", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=611b74e1fe48410c534c5d5a6a0832b810d8ccda", "patch": "@@ -47,9 +47,9 @@ pub fn eq_pat(l: &Pat, r: &Pat) -> bool {\n         | (Ref(l, Mutability::Mut), Ref(r, Mutability::Mut)) => eq_pat(l, r),\n         (Tuple(l), Tuple(r)) | (Slice(l), Slice(r)) => over(l, r, |l, r| eq_pat(l, r)),\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n-        (TupleStruct(lp, lfs), TupleStruct(rp, rfs)) => eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r)),\n-        (Struct(lp, lfs, lr), Struct(rp, rfs, rr)) => {\n-            lr == rr && eq_path(lp, rp) && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n+        (TupleStruct(lqself, lp, lfs), TupleStruct(rqself, rp, rfs)) => eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r)),\n+        (Struct(lqself, lp, lfs, lr), Struct(rqself, rp, rfs, rr)) => {\n+            lr == rr && eq_maybe_qself(lqself, rqself) &&eq_path(lp, rp) && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n         },\n         (Or(ls), Or(rs)) => unordered_over(ls, rs, |l, r| eq_pat(l, r)),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -78,6 +78,14 @@ pub fn eq_qself(l: &QSelf, r: &QSelf) -> bool {\n     l.position == r.position && eq_ty(&l.ty, &r.ty)\n }\n \n+pub fn eq_maybe_qself(l: &Option<QSelf>, r: &Option<QSelf>) -> bool {\n+    match (l, r) {\n+        (Some(l), Some(r)) => eq_qself(l, r),\n+        (None, None) => true,\n+        _ => false\n+    }\n+}\n+\n pub fn eq_path(l: &Path, r: &Path) -> bool {\n     over(&l.segments, &r.segments, |l, r| eq_path_seg(l, r))\n }\n@@ -170,7 +178,8 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         (Struct(lse), Struct(rse)) => {\n-            eq_path(&lse.path, &rse.path)\n+            eq_maybe_qself(&lse.qself, &rse.qself) \n+                && eq_path(&lse.path, &rse.path)\n                 && eq_struct_rest(&lse.rest, &rse.rest)\n                 && unordered_over(&lse.fields, &rse.fields, |l, r| eq_field(l, r))\n         },"}]}