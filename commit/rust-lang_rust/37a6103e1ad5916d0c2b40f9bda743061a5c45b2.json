{"sha": "37a6103e1ad5916d0c2b40f9bda743061a5c45b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YTYxMDNlMWFkNTkxNmQwYzJiNDBmOWJkYTc0MzA2MWE1YzQ1YjI=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-02T20:35:11Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-15T10:58:32Z"}, "message": "introduce the query `opt_const_param_of`", "tree": {"sha": "a3f96596c063f781745f4b7bcd5c9aa7a86c7af4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3f96596c063f781745f4b7bcd5c9aa7a86c7af4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37a6103e1ad5916d0c2b40f9bda743061a5c45b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37a6103e1ad5916d0c2b40f9bda743061a5c45b2", "html_url": "https://github.com/rust-lang/rust/commit/37a6103e1ad5916d0c2b40f9bda743061a5c45b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37a6103e1ad5916d0c2b40f9bda743061a5c45b2/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2111d6f2768911a8449df93ea5c826801e1dbf79", "url": "https://api.github.com/repos/rust-lang/rust/commits/2111d6f2768911a8449df93ea5c826801e1dbf79", "html_url": "https://github.com/rust-lang/rust/commit/2111d6f2768911a8449df93ea5c826801e1dbf79"}], "stats": {"total": 294, "additions": 169, "deletions": 125}, "files": [{"sha": "d53b8d33262b5fad603a7cd564974c713a078e9b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/37a6103e1ad5916d0c2b40f9bda743061a5c45b2/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a6103e1ad5916d0c2b40f9bda743061a5c45b2/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=37a6103e1ad5916d0c2b40f9bda743061a5c45b2", "patch": "@@ -89,6 +89,25 @@ rustc_queries! {\n             desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n+        /// Computes the `DefId` of the corresponding const parameter in case the `key` is a\n+        /// const argument and returns `None` otherwise.\n+        ///\n+        /// ```rust\n+        /// let a = foo::<7>();\n+        /// //            ^ Calling `opt_const_param_of` for this argument,\n+        ///\n+        /// fn foo<const N: usize>()\n+        /// //           ^ returns this `DefId`.\n+        ///\n+        /// fn bar() {\n+        /// // ^ While calling `opt_const_param_of` for other bodies returns `None`.\n+        /// }\n+        /// ```\n+        query opt_const_param_of(key: LocalDefId) -> Option<DefId> {\n+            desc { |tcx| \"computing the optional const parameter of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            // FIXME: consider storing this query on disk.\n+        }\n+\n         /// Records the type of every item.\n         query type_of(key: DefId) -> Ty<'tcx> {\n             desc { |tcx| \"computing type of `{}`\", tcx.def_path_str(key) }"}, {"sha": "4354996614b2ae86a92cadb32c77cce8afd2e095", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37a6103e1ad5916d0c2b40f9bda743061a5c45b2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a6103e1ad5916d0c2b40f9bda743061a5c45b2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=37a6103e1ad5916d0c2b40f9bda743061a5c45b2", "patch": "@@ -64,6 +64,7 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n+        opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,\n         generics_of,\n         predicates_of,"}, {"sha": "c265fadb82f9490d61b86355384acb9b1affe0c0", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 149, "deletions": 125, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/37a6103e1ad5916d0c2b40f9bda743061a5c45b2/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a6103e1ad5916d0c2b40f9bda743061a5c45b2/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=37a6103e1ad5916d0c2b40f9bda743061a5c45b2", "patch": "@@ -17,29 +17,141 @@ use rustc_trait_selection::traits;\n use super::ItemCtxt;\n use super::{bad_placeholder_type, is_suggestable_infer_ty};\n \n+/// Computes the relevant generic parameter for a potential generic const argument.\n+///\n+/// This should be called using the query `tcx.opt_const_param_of`.\n+pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<DefId> {\n+    use hir::*;\n+\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+\n+    if let Node::AnonConst(_) = tcx.hir().get(hir_id) {\n+        let parent_node_id = tcx.hir().get_parent_node(hir_id);\n+        let parent_node = tcx.hir().get(parent_node_id);\n+\n+        match parent_node {\n+            Node::Expr(&Expr {\n+                kind:\n+                    ExprKind::MethodCall(segment, ..) | ExprKind::Path(QPath::TypeRelative(_, segment)),\n+                ..\n+            }) => {\n+                let body_owner = tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n+                let tables = tcx.typeck_tables_of(body_owner);\n+                // This may fail in case the method/path does not actually exist.\n+                // As there is no relevant param for `def_id`, we simply return\n+                // `None` here.\n+                let type_dependent_def = tables.type_dependent_def_id(parent_node_id)?;\n+                let idx = segment\n+                    .args\n+                    .and_then(|args| {\n+                        args.args\n+                            .iter()\n+                            .filter(|arg| arg.is_const())\n+                            .position(|arg| arg.id() == hir_id)\n+                    })\n+                    .unwrap_or_else(|| {\n+                        bug!(\"no arg matching AnonConst in segment\");\n+                    });\n+\n+                tcx.generics_of(type_dependent_def)\n+                    .params\n+                    .iter()\n+                    .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Const))\n+                    .nth(idx)\n+                    .map(|param| param.def_id)\n+            }\n+\n+            Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n+            | Node::Expr(&Expr { kind: ExprKind::Struct(..), .. })\n+            | Node::Expr(&Expr { kind: ExprKind::Path(_), .. })\n+            | Node::TraitRef(..) => {\n+                let path = match parent_node {\n+                    Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n+                    | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n+                    Node::Expr(&Expr {\n+                        kind:\n+                            ExprKind::Path(QPath::Resolved(_, path))\n+                            | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n+                        ..\n+                    }) => {\n+                        let body_owner =\n+                            tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n+                        let _tables = tcx.typeck_tables_of(body_owner);\n+                        &*path\n+                    }\n+                    _ => span_bug!(DUMMY_SP, \"unexpected const parent path {:?}\", parent_node),\n+                };\n+\n+                // We've encountered an `AnonConst` in some path, so we need to\n+                // figure out which generic parameter it corresponds to and return\n+                // the relevant type.\n+\n+                let (arg_index, segment) = path\n+                    .segments\n+                    .iter()\n+                    .filter_map(|seg| seg.args.map(|args| (args.args, seg)))\n+                    .find_map(|(args, seg)| {\n+                        args.iter()\n+                            .filter(|arg| arg.is_const())\n+                            .position(|arg| arg.id() == hir_id)\n+                            .map(|index| (index, seg))\n+                    })\n+                    .unwrap_or_else(|| {\n+                        bug!(\"no arg matching AnonConst in path\");\n+                    });\n+\n+                // Try to use the segment resolution if it is valid, otherwise we\n+                // default to the path resolution.\n+                let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n+                let generics = match res {\n+                    Res::Def(DefKind::Ctor(..), def_id) => {\n+                        tcx.generics_of(tcx.parent(def_id).unwrap())\n+                    }\n+                    Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                    Res::Err => {\n+                        tcx.sess.delay_span_bug(tcx.def_span(def_id), \"anon const with Res::Err\");\n+                        return None;\n+                    }\n+                    _ => span_bug!(\n+                        DUMMY_SP,\n+                        \"unexpected anon const res {:?} in path: {:?}\",\n+                        res,\n+                        path,\n+                    ),\n+                };\n+\n+                generics\n+                    .params\n+                    .iter()\n+                    .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Const))\n+                    .nth(arg_index)\n+                    .map(|param| param.def_id)\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+    let def_id = def_id.expect_local();\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n \n-    let icx = ItemCtxt::new(tcx, def_id);\n+    let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n \n     match tcx.hir().get(hir_id) {\n         Node::TraitItem(item) => match item.kind {\n             TraitItemKind::Fn(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n             TraitItemKind::Const(ref ty, body_id) => body_id\n                 .and_then(|body_id| {\n                     if is_suggestable_infer_ty(ty) {\n-                        Some(infer_placeholder_type(\n-                            tcx,\n-                            def_id.expect_local(),\n-                            body_id,\n-                            ty.span,\n-                            item.ident,\n-                        ))\n+                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n                     } else {\n                         None\n                     }\n@@ -53,12 +165,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n         Node::ImplItem(item) => match item.kind {\n             ImplItemKind::Fn(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n             ImplItemKind::Const(ref ty, body_id) => {\n                 if is_suggestable_infer_ty(ty) {\n-                    infer_placeholder_type(tcx, def_id.expect_local(), body_id, ty.span, item.ident)\n+                    infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                 } else {\n                     icx.to_ty(ty)\n                 }\n@@ -76,13 +188,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             match item.kind {\n                 ItemKind::Static(ref ty, .., body_id) | ItemKind::Const(ref ty, body_id) => {\n                     if is_suggestable_infer_ty(ty) {\n-                        infer_placeholder_type(\n-                            tcx,\n-                            def_id.expect_local(),\n-                            body_id,\n-                            ty.span,\n-                            item.ident,\n-                        )\n+                        infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                     } else {\n                         icx.to_ty(ty)\n                     }\n@@ -91,26 +197,26 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     icx.to_ty(self_ty)\n                 }\n                 ItemKind::Fn(..) => {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs)\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                    tcx.mk_fn_def(def_id.to_def_id(), substs)\n                 }\n                 ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) => {\n                     let def = tcx.adt_def(def_id);\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                     tcx.mk_adt(def, substs)\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::Binding, .. }) => {\n-                    let_position_impl_trait_type(tcx, def_id.expect_local())\n+                    let_position_impl_trait_type(tcx, def_id)\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n-                    find_opaque_ty_constraints(tcx, def_id.expect_local())\n+                    find_opaque_ty_constraints(tcx, def_id)\n                 }\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n                     let concrete_ty = tcx\n                         .mir_borrowck(owner.expect_local())\n                         .concrete_opaque_types\n-                        .get(&def_id)\n+                        .get(&def_id.to_def_id())\n                         .map(|opaque| opaque.concrete_type)\n                         .unwrap_or_else(|| {\n                             tcx.sess.delay_span_bug(\n@@ -132,8 +238,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 // resolves to itself. Return the non-revealed\n                                 // type, which should result in E0720.\n                                 tcx.mk_opaque(\n-                                    def_id,\n-                                    InternalSubsts::identity_for_item(tcx, def_id),\n+                                    def_id.to_def_id(),\n+                                    InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n                                 )\n                             }\n                         });\n@@ -158,35 +264,41 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n         Node::ForeignItem(foreign_item) => match foreign_item.kind {\n             ForeignItemKind::Fn(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n             ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n-            ForeignItemKind::Type => tcx.mk_foreign(def_id),\n+            ForeignItemKind::Type => tcx.mk_foreign(def_id.to_def_id()),\n         },\n \n         Node::Ctor(&ref def) | Node::Variant(Variant { data: ref def, .. }) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n                 tcx.type_of(tcx.hir().get_parent_did(hir_id).to_def_id())\n             }\n             VariantData::Tuple(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n         },\n \n         Node::Field(field) => icx.to_ty(&field.ty),\n \n         Node::Expr(&Expr { kind: ExprKind::Closure(.., gen), .. }) => {\n-            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n             if let Some(movability) = gen {\n-                tcx.mk_generator(def_id, substs, movability)\n+                tcx.mk_generator(def_id.to_def_id(), substs, movability)\n             } else {\n-                tcx.mk_closure(def_id, substs)\n+                tcx.mk_closure(def_id.to_def_id(), substs)\n             }\n         }\n \n         Node::AnonConst(_) => {\n+            if let Some(param) = tcx.opt_const_param_of(def_id) {\n+                // We defer to `type_of` of the corresponding parameter\n+                // for generic arguments.\n+                return tcx.type_of(param);\n+            }\n+\n             let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n             match parent_node {\n                 Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n@@ -203,94 +315,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     .discr_type()\n                     .to_ty(tcx),\n \n-                Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n-                | Node::Expr(&Expr { kind: ExprKind::Struct(..) | ExprKind::Path(_), .. })\n-                | Node::TraitRef(..) => {\n-                    let path = match parent_node {\n-                        Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n-                        | Node::Expr(&Expr {\n-                            kind:\n-                                ExprKind::Path(QPath::Resolved(_, path))\n-                                | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n-                            ..\n-                        })\n-                        | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n-                        _ => {\n-                            return tcx.ty_error_with_message(\n-                                DUMMY_SP,\n-                                &format!(\"unexpected const parent path {:?}\", parent_node),\n-                            );\n-                        }\n-                    };\n-\n-                    // We've encountered an `AnonConst` in some path, so we need to\n-                    // figure out which generic parameter it corresponds to and return\n-                    // the relevant type.\n-\n-                    let (arg_index, segment) = path\n-                        .segments\n-                        .iter()\n-                        .filter_map(|seg| seg.args.as_ref().map(|args| (args.args, seg)))\n-                        .find_map(|(args, seg)| {\n-                            args.iter()\n-                                .filter(|arg| arg.is_const())\n-                                .enumerate()\n-                                .filter(|(_, arg)| arg.id() == hir_id)\n-                                .map(|(index, _)| (index, seg))\n-                                .next()\n-                        })\n-                        .unwrap_or_else(|| {\n-                            bug!(\"no arg matching AnonConst in path\");\n-                        });\n-\n-                    // Try to use the segment resolution if it is valid, otherwise we\n-                    // default to the path resolution.\n-                    let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-                    let generics = match res {\n-                        Res::Def(DefKind::Ctor(..), def_id) => {\n-                            tcx.generics_of(tcx.parent(def_id).unwrap())\n-                        }\n-                        Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                        res => {\n-                            return tcx.ty_error_with_message(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"unexpected anon const res {:?} in path: {:?}\",\n-                                    res, path,\n-                                ),\n-                                );\n-                        }\n-                    };\n-\n-                    let ty = generics\n-                        .params\n-                        .iter()\n-                        .filter(|param| {\n-                            if let ty::GenericParamDefKind::Const = param.kind {\n-                                true\n-                            } else {\n-                                false\n-                            }\n-                        })\n-                        .nth(arg_index)\n-                        .map(|param| tcx.type_of(param.def_id));\n-\n-                    if let Some(ty) = ty {\n-                        ty\n-                    } else {\n-                        // This is no generic parameter associated with the arg. This is\n-                        // probably from an extra arg where one is not needed.\n-                        tcx.ty_error_with_message(\n-                            DUMMY_SP,\n-                            &format!(\n-                                \"missing generic parameter for `AnonConst`, \\\n-                                 parent: {:?}, res: {:?}\",\n-                                parent_node, res\n-                            ),\n-                        )\n-                    }\n-                }\n-\n                 x => tcx.ty_error_with_message(\n                     DUMMY_SP,\n                     &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),"}]}