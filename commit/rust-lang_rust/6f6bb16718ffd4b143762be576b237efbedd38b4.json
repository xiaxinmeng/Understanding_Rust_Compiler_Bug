{"sha": "6f6bb16718ffd4b143762be576b237efbedd38b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNmJiMTY3MThmZmQ0YjE0Mzc2MmJlNTc2YjIzN2VmYmVkZDM4YjQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-09-16T12:28:21Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-09-16T12:32:32Z"}, "message": "Merge sys_common::rt into rt", "tree": {"sha": "c55c9d40eb3d92ddf79a6caf9db1cdb17b20be47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c55c9d40eb3d92ddf79a6caf9db1cdb17b20be47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f6bb16718ffd4b143762be576b237efbedd38b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f6bb16718ffd4b143762be576b237efbedd38b4", "html_url": "https://github.com/rust-lang/rust/commit/6f6bb16718ffd4b143762be576b237efbedd38b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f6bb16718ffd4b143762be576b237efbedd38b4/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "html_url": "https://github.com/rust-lang/rust/commit/2b5ddf36fdc784106b3a064d93dd054c32b1f10f"}], "stats": {"total": 181, "additions": 89, "deletions": 92}, "files": [{"sha": "6380631cf0d8ba325e35e501daf21945f3125032", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f6bb16718ffd4b143762be576b237efbedd38b4/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6bb16718ffd4b143762be576b237efbedd38b4/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=6f6bb16718ffd4b143762be576b237efbedd38b4", "patch": "@@ -518,8 +518,12 @@ pub mod task {\n     pub use alloc::task::*;\n }\n \n-// Platform-abstraction modules\n+// The runtime entry point and a few unstable public functions used by the\n+// compiler\n #[macro_use]\n+pub mod rt;\n+\n+// Platform-abstraction modules\n mod sys_common;\n mod sys;\n \n@@ -528,10 +532,6 @@ pub mod alloc;\n // Private support modules\n mod panicking;\n \n-// The runtime entry point and a few unstable public functions used by the\n-// compiler\n-pub mod rt;\n-\n #[path = \"../../backtrace/src/lib.rs\"]\n #[allow(dead_code, unused_attributes)]\n mod backtrace_rs;"}, {"sha": "5c68400114d49744de3e73b1663db7555664b021", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f6bb16718ffd4b143762be576b237efbedd38b4/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6bb16718ffd4b143762be576b237efbedd38b4/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=6f6bb16718ffd4b143762be576b237efbedd38b4", "patch": "@@ -1907,7 +1907,7 @@ impl Child {\n /// [platform-specific behavior]: #platform-specific-behavior\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn exit(code: i32) -> ! {\n-    crate::sys_common::rt::cleanup();\n+    crate::rt::cleanup();\n     crate::sys::os::exit(code)\n }\n "}, {"sha": "8e38f98105b1f152cf4129fd945a2ef32b4f8fb8", "filename": "library/std/src/rt.rs", "status": "modified", "additions": 83, "deletions": 3, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6f6bb16718ffd4b143762be576b237efbedd38b4/library%2Fstd%2Fsrc%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6bb16718ffd4b143762be576b237efbedd38b4/library%2Fstd%2Fsrc%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Frt.rs?ref=6f6bb16718ffd4b143762be576b237efbedd38b4", "patch": "@@ -13,10 +13,90 @@\n     issue = \"none\"\n )]\n #![doc(hidden)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n+#![allow(unused_macros)]\n \n // Re-export some of our utilities which are expected by other crates.\n pub use crate::panicking::{begin_panic, begin_panic_fmt, panic_count};\n \n+use crate::sync::Once;\n+use crate::sys;\n+use crate::sys_common::thread_info;\n+use crate::thread::Thread;\n+\n+// One-time runtime initialization.\n+// Runs before `main`.\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+#[cfg_attr(test, allow(dead_code))]\n+unsafe fn init(argc: isize, argv: *const *const u8) {\n+    unsafe {\n+        sys::init(argc, argv);\n+\n+        let main_guard = sys::thread::guard::init();\n+        // Next, set up the current Thread with the guard information we just\n+        // created. Note that this isn't necessary in general for new threads,\n+        // but we just do this to name the main thread and to give it correct\n+        // info about the stack bounds.\n+        let thread = Thread::new(Some(\"main\".to_owned()));\n+        thread_info::set(main_guard, thread);\n+    }\n+}\n+\n+// One-time runtime cleanup.\n+// Runs after `main` or at program exit.\n+// NOTE: this is not guaranteed to run, for example when the program aborts.\n+pub(crate) fn cleanup() {\n+    static CLEANUP: Once = Once::new();\n+    CLEANUP.call_once(|| unsafe {\n+        // Flush stdout and disable buffering.\n+        crate::io::cleanup();\n+        // SAFETY: Only called once during runtime cleanup.\n+        sys::cleanup();\n+    });\n+}\n+\n+// Prints to the \"panic output\", depending on the platform this may be:\n+// - the standard error output\n+// - some dedicated platform specific output\n+// - nothing (so this macro is a no-op)\n+macro_rules! rtprintpanic {\n+    ($($t:tt)*) => {\n+        if let Some(mut out) = crate::sys::stdio::panic_output() {\n+            let _ = crate::io::Write::write_fmt(&mut out, format_args!($($t)*));\n+        }\n+    }\n+}\n+\n+macro_rules! rtabort {\n+    ($($t:tt)*) => {\n+        {\n+            rtprintpanic!(\"fatal runtime error: {}\\n\", format_args!($($t)*));\n+            crate::sys::abort_internal();\n+        }\n+    }\n+}\n+\n+macro_rules! rtassert {\n+    ($e:expr) => {\n+        if !$e {\n+            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n+        }\n+    };\n+}\n+\n+macro_rules! rtunwrap {\n+    ($ok:ident, $e:expr) => {\n+        match $e {\n+            $ok(v) => v,\n+            ref err => {\n+                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n+                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n+            }\n+        }\n+    };\n+}\n+\n // To reduce the generated code of the new `lang_start`, this function is doing\n // the real work.\n #[cfg(not(test))]\n@@ -25,7 +105,7 @@ fn lang_start_internal(\n     argc: isize,\n     argv: *const *const u8,\n ) -> Result<isize, !> {\n-    use crate::{mem, panic, sys, sys_common};\n+    use crate::{mem, panic};\n     let rt_abort = move |e| {\n         mem::forget(e);\n         rtabort!(\"initialization or cleanup bug\");\n@@ -41,14 +121,14 @@ fn lang_start_internal(\n     // prevent libstd from accidentally introducing a panic to these functions. Another is from\n     // user code from `main` or, more nefariously, as described in e.g. issue #86030.\n     // SAFETY: Only called once during runtime initialization.\n-    panic::catch_unwind(move || unsafe { sys_common::rt::init(argc, argv) }).map_err(rt_abort)?;\n+    panic::catch_unwind(move || unsafe { init(argc, argv) }).map_err(rt_abort)?;\n     let ret_code = panic::catch_unwind(move || panic::catch_unwind(main).unwrap_or(101) as isize)\n         .map_err(move |e| {\n             mem::forget(e);\n             rtprintpanic!(\"drop of the panic payload panicked\");\n             sys::abort_internal()\n         });\n-    panic::catch_unwind(sys_common::rt::cleanup).map_err(rt_abort)?;\n+    panic::catch_unwind(cleanup).map_err(rt_abort)?;\n     ret_code\n }\n "}, {"sha": "5a5913ebd79a35bbe657c15c524119e6248fd2ea", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f6bb16718ffd4b143762be576b237efbedd38b4/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6bb16718ffd4b143762be576b237efbedd38b4/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=6f6bb16718ffd4b143762be576b237efbedd38b4", "patch": "@@ -28,8 +28,6 @@ pub mod memchr;\n pub mod mutex;\n pub mod process;\n pub mod remutex;\n-#[macro_use]\n-pub mod rt;\n pub mod rwlock;\n pub mod thread;\n pub mod thread_info;"}, {"sha": "02013ecc4ced6b8769f3a4f7c8b6b1c2ecfaf8b7", "filename": "library/std/src/sys_common/rt.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -1,81 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-#![allow(unused_macros)]\n-\n-use crate::sync::Once;\n-use crate::sys;\n-use crate::sys_common::thread_info;\n-use crate::thread::Thread;\n-\n-// One-time runtime initialization.\n-// Runs before `main`.\n-// SAFETY: must be called only once during runtime initialization.\n-// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n-#[cfg_attr(test, allow(dead_code))]\n-pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-    unsafe {\n-        sys::init(argc, argv);\n-\n-        let main_guard = sys::thread::guard::init();\n-        // Next, set up the current Thread with the guard information we just\n-        // created. Note that this isn't necessary in general for new threads,\n-        // but we just do this to name the main thread and to give it correct\n-        // info about the stack bounds.\n-        let thread = Thread::new(Some(\"main\".to_owned()));\n-        thread_info::set(main_guard, thread);\n-    }\n-}\n-\n-// One-time runtime cleanup.\n-// Runs after `main` or at program exit.\n-// NOTE: this is not guaranteed to run, for example when the program aborts.\n-#[cfg_attr(test, allow(dead_code))]\n-pub fn cleanup() {\n-    static CLEANUP: Once = Once::new();\n-    CLEANUP.call_once(|| unsafe {\n-        // Flush stdout and disable buffering.\n-        crate::io::cleanup();\n-        // SAFETY: Only called once during runtime cleanup.\n-        sys::cleanup();\n-    });\n-}\n-\n-// Prints to the \"panic output\", depending on the platform this may be:\n-// - the standard error output\n-// - some dedicated platform specific output\n-// - nothing (so this macro is a no-op)\n-macro_rules! rtprintpanic {\n-    ($($t:tt)*) => {\n-        if let Some(mut out) = crate::sys::stdio::panic_output() {\n-            let _ = crate::io::Write::write_fmt(&mut out, format_args!($($t)*));\n-        }\n-    }\n-}\n-\n-macro_rules! rtabort {\n-    ($($t:tt)*) => {\n-        {\n-            rtprintpanic!(\"fatal runtime error: {}\\n\", format_args!($($t)*));\n-            crate::sys::abort_internal();\n-        }\n-    }\n-}\n-\n-macro_rules! rtassert {\n-    ($e:expr) => {\n-        if !$e {\n-            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n-        }\n-    };\n-}\n-\n-macro_rules! rtunwrap {\n-    ($ok:ident, $e:expr) => {\n-        match $e {\n-            $ok(v) => v,\n-            ref err => {\n-                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n-                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n-            }\n-        }\n-    };\n-}"}]}