{"sha": "f2c39d0cdf708d6178740385f58d6b2b657e411a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYzM5ZDBjZGY3MDhkNjE3ODc0MDM4NWY1OGQ2YjJiNjU3ZTQxMWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-15T14:08:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-15T14:08:26Z"}, "message": "Merge #8020\n\n8020: Power up goto_implementation r=matklad a=Veykril\n\nby allowing it to be invoked on references of names, now showing all (trait)\r\nimplementations of the given type in all crates instead of just the defining\r\ncrate as well as including support for builtin types\r\n\r\n![image](https://user-images.githubusercontent.com/3757771/111144403-52bb0700-8587-11eb-9205-7a2a5b8b75a3.png)\r\nExample screenshot of `impl`s of Box in `log`, `alloc`, `std` and the current crate. Before you had to invoke it on the definition where it would only show the `impls` in `alloc`.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "83ed009ee98b3c1cfe1cbcc203c1c419c914569e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83ed009ee98b3c1cfe1cbcc203c1c419c914569e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2c39d0cdf708d6178740385f58d6b2b657e411a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgT2paCRBK7hj4Ov3rIwAAdHIIADQXBvjT1zPVWdHvJLn37Fa9\nwyleiYaeqSaQPaNht4LRPMNmIVxuoymIbTaXbkbTFsaOzFqmYpEwz1WeheVJjUKk\n771PyPX8TdaZ1E1ApZiTywn9pwOBeYyzuEeGQwbxpB4cUIAQYPGVLp3OcM6kkPwl\nKZPKuooMPivG+IHLmskYHb7NmB5ceMtQ9pTUYugZR6cHAis9Qhc0QGfbHX0+nl+C\n0tdBiPspI2W7PJoddOK9Lx43iXUDNzXyBdcgODW+Z1Z9EQCtDMZocLO3ojSjkf0W\nGqyhrTZ0D5ibA87EhNEbSAMGT+jhPlg9zPsd2UGL0FjEYGX/VZpr6MItQbEaiWU=\n=44Wx\n-----END PGP SIGNATURE-----\n", "payload": "tree 83ed009ee98b3c1cfe1cbcc203c1c419c914569e\nparent 3962b0d53c8da6e3f95f54395d266cb99562bd47\nparent 79561b9d2e901e2624f94ffa7bc6017f0249f23d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615817306 +0000\ncommitter GitHub <noreply@github.com> 1615817306 +0000\n\nMerge #8020\n\n8020: Power up goto_implementation r=matklad a=Veykril\n\nby allowing it to be invoked on references of names, now showing all (trait)\r\nimplementations of the given type in all crates instead of just the defining\r\ncrate as well as including support for builtin types\r\n\r\n![image](https://user-images.githubusercontent.com/3757771/111144403-52bb0700-8587-11eb-9205-7a2a5b8b75a3.png)\r\nExample screenshot of `impl`s of Box in `log`, `alloc`, `std` and the current crate. Before you had to invoke it on the definition where it would only show the `impls` in `alloc`.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c39d0cdf708d6178740385f58d6b2b657e411a", "html_url": "https://github.com/rust-lang/rust/commit/f2c39d0cdf708d6178740385f58d6b2b657e411a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2c39d0cdf708d6178740385f58d6b2b657e411a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3962b0d53c8da6e3f95f54395d266cb99562bd47", "url": "https://api.github.com/repos/rust-lang/rust/commits/3962b0d53c8da6e3f95f54395d266cb99562bd47", "html_url": "https://github.com/rust-lang/rust/commit/3962b0d53c8da6e3f95f54395d266cb99562bd47"}, {"sha": "79561b9d2e901e2624f94ffa7bc6017f0249f23d", "url": "https://api.github.com/repos/rust-lang/rust/commits/79561b9d2e901e2624f94ffa7bc6017f0249f23d", "html_url": "https://github.com/rust-lang/rust/commit/79561b9d2e901e2624f94ffa7bc6017f0249f23d"}], "stats": {"total": 200, "additions": 136, "deletions": 64}, "files": [{"sha": "c5161dadd89ed6704547d2920279820e73e5b576", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f2c39d0cdf708d6178740385f58d6b2b657e411a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c39d0cdf708d6178740385f58d6b2b657e411a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f2c39d0cdf708d6178740385f58d6b2b657e411a", "patch": "@@ -51,7 +51,8 @@ use hir_expand::{diagnostics::DiagnosticSink, name::name, MacroDefKind};\n use hir_ty::{\n     autoderef,\n     display::{write_bounds_like_dyn_trait_with_prefix, HirDisplayError, HirFormatter},\n-    method_resolution, to_assoc_type_id,\n+    method_resolution::{self, TyFingerprint},\n+    to_assoc_type_id,\n     traits::{FnTrait, Solution, SolutionVariables},\n     AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, DebruijnIndex, GenericPredicate,\n     InEnvironment, Interner, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, Ty,\n@@ -695,8 +696,8 @@ impl Adt {\n         }\n     }\n \n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n+    pub fn krate(self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n     }\n \n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n@@ -1018,8 +1019,8 @@ impl TypeAlias {\n         Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n     }\n \n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n+    pub fn krate(self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n     }\n \n     pub fn type_ref(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n@@ -1482,9 +1483,44 @@ impl Impl {\n \n         inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()\n     }\n-    pub fn for_trait(db: &dyn HirDatabase, krate: Crate, trait_: Trait) -> Vec<Impl> {\n-        let impls = db.trait_impls_in_crate(krate.id);\n-        impls.for_trait(trait_.id).map(Self::from).collect()\n+\n+    pub fn all_for_type(db: &dyn HirDatabase, Type { krate, ty }: Type) -> Vec<Impl> {\n+        let def_crates = match ty.value.def_crates(db, krate) {\n+            Some(def_crates) => def_crates,\n+            None => return Vec::new(),\n+        };\n+\n+        let filter = |impl_def: &Impl| {\n+            let target_ty = impl_def.target_ty(db);\n+            let rref = target_ty.remove_ref();\n+            ty.value.equals_ctor(rref.as_ref().map_or(&target_ty.ty.value, |it| &it.ty.value))\n+        };\n+\n+        let mut all = Vec::new();\n+        def_crates.into_iter().for_each(|id| {\n+            all.extend(db.inherent_impls_in_crate(id).all_impls().map(Self::from).filter(filter))\n+        });\n+        let fp = TyFingerprint::for_impl(&ty.value);\n+        for id in db.crate_graph().iter() {\n+            match fp {\n+                Some(fp) => all.extend(\n+                    db.trait_impls_in_crate(id).for_self_ty(fp).map(Self::from).filter(filter),\n+                ),\n+                None => all\n+                    .extend(db.trait_impls_in_crate(id).all_impls().map(Self::from).filter(filter)),\n+            }\n+        }\n+        all\n+    }\n+\n+    pub fn all_for_trait(db: &dyn HirDatabase, trait_: Trait) -> Vec<Impl> {\n+        let krate = trait_.module(db).krate();\n+        let mut all = Vec::new();\n+        for Crate { id } in krate.reverse_dependencies(db).into_iter().chain(Some(krate)) {\n+            let impls = db.trait_impls_in_crate(id);\n+            all.extend(impls.for_trait(trait_.id).map(Self::from))\n+        }\n+        all\n     }\n \n     // FIXME: the return type is wrong. This should be a hir version of\n@@ -1932,12 +1968,6 @@ impl Type {\n         self.ty.value.associated_type_parent_trait(db).map(Into::into)\n     }\n \n-    // FIXME: provide required accessors such that it becomes implementable from outside.\n-    pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n-        let rref = other.remove_ref();\n-        self.ty.value.equals_ctor(rref.as_ref().map_or(&other.ty.value, |it| &it.ty.value))\n-    }\n-\n     fn derived(&self, ty: Ty) -> Type {\n         Type {\n             krate: self.krate,"}, {"sha": "be72c4a1c589287c6d4151b481ab328df5a057ff", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2c39d0cdf708d6178740385f58d6b2b657e411a/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c39d0cdf708d6178740385f58d6b2b657e411a/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=f2c39d0cdf708d6178740385f58d6b2b657e411a", "patch": "@@ -44,7 +44,7 @@ impl TyFingerprint {\n     /// Creates a TyFingerprint for looking up an impl. Only certain types can\n     /// have impls: if we have some `struct S`, we can have an `impl S`, but not\n     /// `impl &S`. Hence, this will return `None` for reference types and such.\n-    pub(crate) fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n+    pub fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n         let fp = match *ty.interned(&Interner) {\n             TyKind::Str => TyFingerprint::Str,\n             TyKind::Never => TyFingerprint::Never,\n@@ -141,6 +141,14 @@ impl TraitImpls {\n         }\n     }\n \n+    /// Queries all trait impls for the given type.\n+    pub fn for_self_ty(&self, fp: TyFingerprint) -> impl Iterator<Item = ImplId> + '_ {\n+        self.map\n+            .values()\n+            .flat_map(move |impls| impls.get(&None).into_iter().chain(impls.get(&Some(fp))))\n+            .flat_map(|it| it.iter().copied())\n+    }\n+\n     /// Queries all impls of the given trait.\n     pub fn for_trait(&self, trait_: TraitId) -> impl Iterator<Item = ImplId> + '_ {\n         self.map"}, {"sha": "f4d7c14a62e11c2cd48db7865c9cc203fe6cd060", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/f2c39d0cdf708d6178740385f58d6b2b657e411a/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c39d0cdf708d6178740385f58d6b2b657e411a/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=f2c39d0cdf708d6178740385f58d6b2b657e411a", "patch": "@@ -1,6 +1,9 @@\n-use hir::{Crate, Impl, Semantics};\n-use ide_db::RootDatabase;\n-use syntax::{algo::find_node_at_offset, ast, AstNode};\n+use hir::{Impl, Semantics};\n+use ide_db::{\n+    defs::{Definition, NameClass, NameRefClass},\n+    RootDatabase,\n+};\n+use syntax::{ast, AstNode};\n \n use crate::{display::TryToNav, FilePosition, NavigationTarget, RangeInfo};\n \n@@ -21,55 +24,42 @@ pub(crate) fn goto_implementation(\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax().clone();\n \n-    let krate = sema.to_module_def(position.file_id)?.krate();\n-\n-    if let Some(nominal_def) = find_node_at_offset::<ast::Adt>(&syntax, position.offset) {\n-        return Some(RangeInfo::new(\n-            nominal_def.syntax().text_range(),\n-            impls_for_def(&sema, &nominal_def, krate)?,\n-        ));\n-    } else if let Some(trait_def) = find_node_at_offset::<ast::Trait>(&syntax, position.offset) {\n-        return Some(RangeInfo::new(\n-            trait_def.syntax().text_range(),\n-            impls_for_trait(&sema, &trait_def, krate)?,\n-        ));\n-    }\n-\n-    None\n-}\n-\n-fn impls_for_def(\n-    sema: &Semantics<RootDatabase>,\n-    node: &ast::Adt,\n-    krate: Crate,\n-) -> Option<Vec<NavigationTarget>> {\n-    let ty = match node {\n-        ast::Adt::Struct(def) => sema.to_def(def)?.ty(sema.db),\n-        ast::Adt::Enum(def) => sema.to_def(def)?.ty(sema.db),\n-        ast::Adt::Union(def) => sema.to_def(def)?.ty(sema.db),\n+    let node = sema.find_node_at_offset_with_descend(&syntax, position.offset)?;\n+    let def = match &node {\n+        ast::NameLike::Name(name) => {\n+            NameClass::classify(&sema, name).map(|class| class.referenced_or_defined(sema.db))\n+        }\n+        ast::NameLike::NameRef(name_ref) => {\n+            NameRefClass::classify(&sema, name_ref).map(|class| class.referenced(sema.db))\n+        }\n+        ast::NameLike::Lifetime(_) => None,\n+    }?;\n+    let def = match def {\n+        Definition::ModuleDef(def) => def,\n+        _ => return None,\n     };\n-\n-    let impls = Impl::all_in_crate(sema.db, krate);\n-\n-    Some(\n-        impls\n-            .into_iter()\n-            .filter(|impl_def| ty.is_equal_for_find_impls(&impl_def.target_ty(sema.db)))\n-            .filter_map(|imp| imp.try_to_nav(sema.db))\n-            .collect(),\n-    )\n+    let navs = match def {\n+        hir::ModuleDef::Trait(trait_) => impls_for_trait(&sema, trait_),\n+        hir::ModuleDef::Adt(adt) => impls_for_ty(&sema, adt.ty(sema.db)),\n+        hir::ModuleDef::TypeAlias(alias) => impls_for_ty(&sema, alias.ty(sema.db)),\n+        hir::ModuleDef::BuiltinType(builtin) => {\n+            let module = sema.to_module_def(position.file_id)?;\n+            impls_for_ty(&sema, builtin.ty(sema.db, module))\n+        }\n+        _ => return None,\n+    };\n+    Some(RangeInfo { range: node.syntax().text_range(), info: navs })\n }\n \n-fn impls_for_trait(\n-    sema: &Semantics<RootDatabase>,\n-    node: &ast::Trait,\n-    krate: Crate,\n-) -> Option<Vec<NavigationTarget>> {\n-    let tr = sema.to_def(node)?;\n-\n-    let impls = Impl::for_trait(sema.db, krate, tr);\n+fn impls_for_ty(sema: &Semantics<RootDatabase>, ty: hir::Type) -> Vec<NavigationTarget> {\n+    Impl::all_for_type(sema.db, ty).into_iter().filter_map(|imp| imp.try_to_nav(sema.db)).collect()\n+}\n \n-    Some(impls.into_iter().filter_map(|imp| imp.try_to_nav(sema.db)).collect())\n+fn impls_for_trait(sema: &Semantics<RootDatabase>, trait_: hir::Trait) -> Vec<NavigationTarget> {\n+    Impl::all_for_trait(sema.db, trait_)\n+        .into_iter()\n+        .filter_map(|imp| imp.try_to_nav(sema.db))\n+        .collect()\n }\n \n #[cfg(test)]\n@@ -223,6 +213,50 @@ mod marker {\n }\n #[rustc_builtin_macro]\n macro Copy {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_implementation_type_alias() {\n+        check(\n+            r#\"\n+struct Foo;\n+\n+type Bar$0 = Foo;\n+\n+impl Foo {}\n+   //^^^\n+impl Bar {}\n+   //^^^\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_implementation_adt_generic() {\n+        check(\n+            r#\"\n+struct Foo$0<T>;\n+\n+impl<T> Foo<T> {}\n+      //^^^^^^\n+impl Foo<str> {}\n+   //^^^^^^^^\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_implementation_builtin() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:main deps:core\n+fn foo(_: bool$0) {{}}\n+//- /libcore.rs crate:core\n+#[lang = \"bool\"]\n+impl bool {}\n+   //^^^^\n \"#,\n         );\n     }"}, {"sha": "16c04eeeeece33b273681c0435a71644adf522ce", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c39d0cdf708d6178740385f58d6b2b657e411a/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c39d0cdf708d6178740385f58d6b2b657e411a/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=f2c39d0cdf708d6178740385f58d6b2b657e411a", "patch": "@@ -219,7 +219,7 @@ fn hint_iterator(\n     let strukt = std::iter::successors(Some(ty.clone()), |ty| ty.remove_ref())\n         .last()\n         .and_then(|strukt| strukt.as_adt())?;\n-    let krate = strukt.krate(db)?;\n+    let krate = strukt.krate(db);\n     if krate != famous_defs.core()? {\n         return None;\n     }"}]}