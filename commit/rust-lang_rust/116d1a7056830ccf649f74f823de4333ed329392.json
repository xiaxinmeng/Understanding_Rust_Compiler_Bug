{"sha": "116d1a7056830ccf649f74f823de4333ed329392", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNmQxYTcwNTY4MzBjY2Y2NDlmNzRmODIzZGU0MzMzZWQzMjkzOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-13T11:11:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-13T11:11:34Z"}, "message": "Auto merge of #80824 - cuviper:heap-clones, r=kennytm\n\nTry to avoid locals when cloning into Box/Rc/Arc\n\nFor generic `T: Clone`, we can allocate an uninitialized box beforehand,\nwhich gives the optimizer a chance to create the clone directly in the\nheap. For `T: Copy`, we can go further and do a simple memory copy,\nregardless of optimization level.\n\nThe same applies to `Rc`/`Arc::make_mut` when they must clone the data.", "tree": {"sha": "af2be022f429fafc9be420f0c1c10aba57d406c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af2be022f429fafc9be420f0c1c10aba57d406c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/116d1a7056830ccf649f74f823de4333ed329392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/116d1a7056830ccf649f74f823de4333ed329392", "html_url": "https://github.com/rust-lang/rust/commit/116d1a7056830ccf649f74f823de4333ed329392", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/116d1a7056830ccf649f74f823de4333ed329392/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f3998b4aa9d0eea3249fdd48b8b719185673d16", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3998b4aa9d0eea3249fdd48b8b719185673d16", "html_url": "https://github.com/rust-lang/rust/commit/9f3998b4aa9d0eea3249fdd48b8b719185673d16"}, {"sha": "1f1a3b48572961e8ab1ec00dd57c2d1e94c75348", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f1a3b48572961e8ab1ec00dd57c2d1e94c75348", "html_url": "https://github.com/rust-lang/rust/commit/1f1a3b48572961e8ab1ec00dd57c2d1e94c75348"}], "stats": {"total": 88, "additions": 65, "deletions": 23}, "files": [{"sha": "cb9daaea0001b5281fc21d4b3599be6a4d59455d", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/116d1a7056830ccf649f74f823de4333ed329392/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116d1a7056830ccf649f74f823de4333ed329392/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=116d1a7056830ccf649f74f823de4333ed329392", "patch": "@@ -397,3 +397,26 @@ pub mod __alloc_error_handler {\n         unsafe { oom_impl(layout) }\n     }\n }\n+\n+/// Specialize clones into pre-allocated, uninitialized memory.\n+/// Used by `Box::clone` and `Rc`/`Arc::make_mut`.\n+pub(crate) trait WriteCloneIntoRaw: Sized {\n+    unsafe fn write_clone_into_raw(&self, target: *mut Self);\n+}\n+\n+impl<T: Clone> WriteCloneIntoRaw for T {\n+    #[inline]\n+    default unsafe fn write_clone_into_raw(&self, target: *mut Self) {\n+        // Having allocated *first* may allow the optimizer to create\n+        // the cloned value in-place, skipping the local and move.\n+        unsafe { target.write(self.clone()) };\n+    }\n+}\n+\n+impl<T: Copy> WriteCloneIntoRaw for T {\n+    #[inline]\n+    unsafe fn write_clone_into_raw(&self, target: *mut Self) {\n+        // We can always copy in-place, without ever involving a local value.\n+        unsafe { target.copy_from_nonoverlapping(self, 1) };\n+    }\n+}"}, {"sha": "0aa52b35ced453bb777c3a32827cb378a8c0c832", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/116d1a7056830ccf649f74f823de4333ed329392/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116d1a7056830ccf649f74f823de4333ed329392/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=116d1a7056830ccf649f74f823de4333ed329392", "patch": "@@ -151,7 +151,7 @@ use core::pin::Pin;\n use core::ptr::{self, Unique};\n use core::task::{Context, Poll};\n \n-use crate::alloc::{handle_alloc_error, AllocError, Allocator, Global, Layout};\n+use crate::alloc::{handle_alloc_error, AllocError, Allocator, Global, Layout, WriteCloneIntoRaw};\n use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -1014,10 +1014,14 @@ impl<T: Clone, A: Allocator + Clone> Clone for Box<T, A> {\n     /// // But they are unique objects\n     /// assert_ne!(&*x as *const i32, &*y as *const i32);\n     /// ```\n-    #[rustfmt::skip]\n     #[inline]\n     fn clone(&self) -> Self {\n-        Self::new_in((**self).clone(), self.1.clone())\n+        // Pre-allocate memory to allow writing the cloned value directly.\n+        let mut boxed = Self::new_uninit_in(self.1.clone());\n+        unsafe {\n+            (**self).write_clone_into_raw(boxed.as_mut_ptr());\n+            boxed.assume_init()\n+        }\n     }\n \n     /// Copies `source`'s contents into `self` without creating a new allocation."}, {"sha": "0973a6e362bc2900d483d67498fee2b386fe4e29", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/116d1a7056830ccf649f74f823de4333ed329392/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116d1a7056830ccf649f74f823de4333ed329392/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=116d1a7056830ccf649f74f823de4333ed329392", "patch": "@@ -263,7 +263,9 @@ use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocError, Allocator, Global, Layout};\n+use crate::alloc::{\n+    box_free, handle_alloc_error, AllocError, Allocator, Global, Layout, WriteCloneIntoRaw,\n+};\n use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n@@ -1037,18 +1039,26 @@ impl<T: Clone> Rc<T> {\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn make_mut(this: &mut Self) -> &mut T {\n         if Rc::strong_count(this) != 1 {\n-            // Gotta clone the data, there are other Rcs\n-            *this = Rc::new((**this).clone())\n+            // Gotta clone the data, there are other Rcs.\n+            // Pre-allocate memory to allow writing the cloned value directly.\n+            let mut rc = Self::new_uninit();\n+            unsafe {\n+                let data = Rc::get_mut_unchecked(&mut rc);\n+                (**this).write_clone_into_raw(data.as_mut_ptr());\n+                *this = rc.assume_init();\n+            }\n         } else if Rc::weak_count(this) != 0 {\n             // Can just steal the data, all that's left is Weaks\n+            let mut rc = Self::new_uninit();\n             unsafe {\n-                let mut swap = Rc::new(ptr::read(&this.ptr.as_ref().value));\n-                mem::swap(this, &mut swap);\n-                swap.inner().dec_strong();\n+                let data = Rc::get_mut_unchecked(&mut rc);\n+                data.as_mut_ptr().copy_from_nonoverlapping(&**this, 1);\n+\n+                this.inner().dec_strong();\n                 // Remove implicit strong-weak ref (no need to craft a fake\n                 // Weak here -- we know other Weaks can clean up for us)\n-                swap.inner().dec_weak();\n-                forget(swap);\n+                this.inner().dec_weak();\n+                ptr::write(this, rc.assume_init());\n             }\n         }\n         // This unsafety is ok because we're guaranteed that the pointer"}, {"sha": "05bfeccbda13294a60c8ad5c9583fbee187b2d69", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/116d1a7056830ccf649f74f823de4333ed329392/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116d1a7056830ccf649f74f823de4333ed329392/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=116d1a7056830ccf649f74f823de4333ed329392", "patch": "@@ -22,7 +22,9 @@ use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocError, Allocator, Global, Layout};\n+use crate::alloc::{\n+    box_free, handle_alloc_error, AllocError, Allocator, Global, Layout, WriteCloneIntoRaw,\n+};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n@@ -1369,8 +1371,14 @@ impl<T: Clone> Arc<T> {\n         // weak count, there's no chance the ArcInner itself could be\n         // deallocated.\n         if this.inner().strong.compare_exchange(1, 0, Acquire, Relaxed).is_err() {\n-            // Another strong pointer exists; clone\n-            *this = Arc::new((**this).clone());\n+            // Another strong pointer exists, so we must clone.\n+            // Pre-allocate memory to allow writing the cloned value directly.\n+            let mut arc = Self::new_uninit();\n+            unsafe {\n+                let data = Arc::get_mut_unchecked(&mut arc);\n+                (**this).write_clone_into_raw(data.as_mut_ptr());\n+                *this = arc.assume_init();\n+            }\n         } else if this.inner().weak.load(Relaxed) != 1 {\n             // Relaxed suffices in the above because this is fundamentally an\n             // optimization: we are always racing with weak pointers being\n@@ -1386,17 +1394,14 @@ impl<T: Clone> Arc<T> {\n \n             // Materialize our own implicit weak pointer, so that it can clean\n             // up the ArcInner as needed.\n-            let weak = Weak { ptr: this.ptr };\n+            let _weak = Weak { ptr: this.ptr };\n \n-            // mark the data itself as already deallocated\n+            // Can just steal the data, all that's left is Weaks\n+            let mut arc = Self::new_uninit();\n             unsafe {\n-                // there is no data race in the implicit write caused by `read`\n-                // here (due to zeroing) because data is no longer accessed by\n-                // other threads (due to there being no more strong refs at this\n-                // point).\n-                let mut swap = Arc::new(ptr::read(&weak.ptr.as_ref().data));\n-                mem::swap(this, &mut swap);\n-                mem::forget(swap);\n+                let data = Arc::get_mut_unchecked(&mut arc);\n+                data.as_mut_ptr().copy_from_nonoverlapping(&**this, 1);\n+                ptr::write(this, arc.assume_init());\n             }\n         } else {\n             // We were the sole reference of either kind; bump back up the"}]}