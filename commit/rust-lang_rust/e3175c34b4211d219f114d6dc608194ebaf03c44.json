{"sha": "e3175c34b4211d219f114d6dc608194ebaf03c44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMTc1YzM0YjQyMTFkMjE5ZjExNGQ2ZGM2MDgxOTRlYmFmMDNjNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-16T14:58:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-16T14:58:05Z"}, "message": "Auto merge of #61754 - nikomatsakis:trait-caching-perf-3, r=pnkfelix\n\ncreate a \"provisional cache\" to restore performance in the case of cycles\n\nIntroduce a \"provisional cache\" that caches the results of auto trait resolutions but keeps them from entering the *main* cache until everything is ready. This turned out a bit more complex than I hoped, but I don't see another short term fix -- happy to take suggestions! In the meantime, it's very clear we need to rework the trait solver. This resolves the extreme performance slowdown experienced in #60846 -- I plan to add a perf.rust-lang.org regression test to track this.\n\nCaveat: I've not run `x.py test` in full yet.\n\nr? @pnkfelix\ncc @arielb1\n\nFixes #60846", "tree": {"sha": "564893b6b6114d8cf403a70cb76304ecb8cbab8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/564893b6b6114d8cf403a70cb76304ecb8cbab8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3175c34b4211d219f114d6dc608194ebaf03c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3175c34b4211d219f114d6dc608194ebaf03c44", "html_url": "https://github.com/rust-lang/rust/commit/e3175c34b4211d219f114d6dc608194ebaf03c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3175c34b4211d219f114d6dc608194ebaf03c44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "url": "https://api.github.com/repos/rust-lang/rust/commits/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "html_url": "https://github.com/rust-lang/rust/commit/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06"}, {"sha": "0baa9258dd2f901a24d744705f514fa678e64940", "url": "https://api.github.com/repos/rust-lang/rust/commits/0baa9258dd2f901a24d744705f514fa678e64940", "html_url": "https://github.com/rust-lang/rust/commit/0baa9258dd2f901a24d744705f514fa678e64940"}], "stats": {"total": 494, "additions": 409, "deletions": 85}, "files": [{"sha": "2ee63647aaded3ac79a7f20cc587ff3f9d2ce9a7", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3175c34b4211d219f114d6dc608194ebaf03c44/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3175c34b4211d219f114d6dc608194ebaf03c44/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=e3175c34b4211d219f114d6dc608194ebaf03c44", "patch": "@@ -64,7 +64,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             Err(OverflowError) => {\n                 let mut selcx =\n                     SelectionContext::with_query_mode(&self, TraitQueryMode::Standard);\n-                selcx.evaluate_obligation_recursively(obligation)\n+                selcx.evaluate_root_obligation(obligation)\n                     .unwrap_or_else(|r| {\n                         span_bug!(\n                             obligation.cause.span,"}, {"sha": "5aa7a120957cfd8767ea57349d8e27d45e0d728d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 405, "deletions": 81, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/e3175c34b4211d219f114d6dc608194ebaf03c44/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3175c34b4211d219f114d6dc608194ebaf03c44/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=e3175c34b4211d219f114d6dc608194ebaf03c44", "patch": "@@ -43,7 +43,7 @@ use crate::hir;\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt::{self, Display};\n use std::iter;\n@@ -151,12 +151,12 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-    /// Starts out as false -- if, during evaluation, we encounter a\n-    /// cycle, then we will set this flag to true for all participants\n-    /// in the cycle (apart from the \"head\" node). These participants\n-    /// will then forego caching their results. This is not the most\n-    /// efficient solution, but it addresses #60010. The problem we\n-    /// are trying to prevent:\n+    /// Starts out equal to `depth` -- if, during evaluation, we\n+    /// encounter a cycle, then we will set this flag to the minimum\n+    /// depth of that cycle for all participants in the cycle. These\n+    /// participants will then forego caching their results. This is\n+    /// not the most efficient solution, but it addresses #60010. The\n+    /// problem we are trying to prevent:\n     ///\n     /// - If you have `A: AutoTrait` requires `B: AutoTrait` and `C: NonAutoTrait`\n     /// - `B: AutoTrait` requires `A: AutoTrait` (coinductive cycle, ok)\n@@ -179,9 +179,16 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// evaluate each member of a cycle up to N times, where N is the\n     /// length of the cycle. This means the performance impact is\n     /// bounded and we shouldn't have any terrible worst-cases.\n-    in_cycle: Cell<bool>,\n+    reached_depth: Cell<usize>,\n \n     previous: TraitObligationStackList<'prev, 'tcx>,\n+\n+    /// Number of parent frames plus one -- so the topmost frame has depth 1.\n+    depth: usize,\n+\n+    /// Depth-first number of this node in the search graph -- a\n+    /// pre-order index.  Basically a freshly incremented counter.\n+    dfn: usize,\n }\n \n #[derive(Clone, Default)]\n@@ -600,7 +607,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"select({:?})\", obligation);\n         debug_assert!(!obligation.predicate.has_escaping_bound_vars());\n \n-        let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n+        let pec = &ProvisionalEvaluationCache::default();\n+        let stack = self.push_stack(TraitObligationStackList::empty(pec), obligation);\n \n         let candidate = match self.candidate_from_obligation(&stack) {\n             Err(SelectionError::Overflow) => {\n@@ -646,20 +654,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // where we do not expect overflow to be propagated.\n         assert!(self.query_mode == TraitQueryMode::Standard);\n \n-        self.evaluate_obligation_recursively(obligation)\n+        self.evaluate_root_obligation(obligation)\n             .expect(\"Overflow should be caught earlier in standard query mode\")\n             .may_apply()\n     }\n \n-    /// Evaluates whether the obligation `obligation` can be satisfied and returns\n-    /// an `EvaluationResult`.\n-    pub fn evaluate_obligation_recursively(\n+    /// Evaluates whether the obligation `obligation` can be satisfied\n+    /// and returns an `EvaluationResult`. This is meant for the\n+    /// *initial* call.\n+    pub fn evaluate_root_obligation(\n         &mut self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n-            this.evaluate_predicate_recursively(TraitObligationStackList::empty(),\n-                obligation.clone())\n+            this.evaluate_predicate_recursively(\n+                TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n+                obligation.clone(),\n+            )\n         })\n     }\n \n@@ -865,23 +876,131 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(result);\n         }\n \n+        if let Some(result) = stack.cache().get_provisional(fresh_trait_ref) {\n+            debug!(\"PROVISIONAL CACHE HIT: EVAL({:?})={:?}\", fresh_trait_ref, result);\n+            stack.update_reached_depth(stack.cache().current_reached_depth());\n+            return Ok(result);\n+        }\n+\n+        // Check if this is a match for something already on the\n+        // stack. If so, we don't want to insert the result into the\n+        // main cache (it is cycle dependent) nor the provisional\n+        // cache (which is meant for things that have completed but\n+        // for a \"backedge\" -- this result *is* the backedge).\n+        if let Some(cycle_result) = self.check_evaluation_cycle(&stack) {\n+            return Ok(cycle_result);\n+        }\n+\n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n         let result = result?;\n \n-        if !stack.in_cycle.get() {\n+        if !result.must_apply_modulo_regions() {\n+            stack.cache().on_failure(stack.dfn);\n+        }\n+\n+        let reached_depth = stack.reached_depth.get();\n+        if reached_depth >= stack.depth {\n             debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n             self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+\n+            stack.cache().on_completion(stack.depth, |fresh_trait_ref, provisional_result| {\n+                self.insert_evaluation_cache(\n+                    obligation.param_env,\n+                    fresh_trait_ref,\n+                    dep_node,\n+                    provisional_result.max(result),\n+                );\n+            });\n         } else {\n+            debug!(\"PROVISIONAL: {:?}={:?}\", fresh_trait_ref, result);\n             debug!(\n-                \"evaluate_trait_predicate_recursively: skipping cache because {:?} \\\n-                 is a cycle participant\",\n+                \"evaluate_trait_predicate_recursively: caching provisionally because {:?} \\\n+                 is a cycle participant (at depth {}, reached depth {})\",\n+                fresh_trait_ref,\n+                stack.depth,\n+                reached_depth,\n+            );\n+\n+            stack.cache().insert_provisional(\n+                stack.dfn,\n+                reached_depth,\n                 fresh_trait_ref,\n+                result,\n             );\n         }\n \n+\n         Ok(result)\n     }\n \n+    /// If there is any previous entry on the stack that precisely\n+    /// matches this obligation, then we can assume that the\n+    /// obligation is satisfied for now (still all other conditions\n+    /// must be met of course). One obvious case this comes up is\n+    /// marker traits like `Send`. Think of a linked list:\n+    ///\n+    ///    struct List<T> { data: T, next: Option<Box<List<T>>> }\n+    ///\n+    /// `Box<List<T>>` will be `Send` if `T` is `Send` and\n+    /// `Option<Box<List<T>>>` is `Send`, and in turn\n+    /// `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n+    /// `Send`.\n+    ///\n+    /// Note that we do this comparison using the `fresh_trait_ref`\n+    /// fields. Because these have all been freshened using\n+    /// `self.freshener`, we can be sure that (a) this will not\n+    /// affect the inferencer state and (b) that if we see two\n+    /// fresh regions with the same index, they refer to the same\n+    /// unbound type variable.\n+    fn check_evaluation_cycle(\n+        &mut self,\n+        stack: &TraitObligationStack<'_, 'tcx>,\n+    ) -> Option<EvaluationResult> {\n+        if let Some(cycle_depth) = stack.iter()\n+            .skip(1) // skip top-most frame\n+            .find(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n+                  stack.fresh_trait_ref == prev.fresh_trait_ref)\n+            .map(|stack| stack.depth)\n+        {\n+            debug!(\n+                \"evaluate_stack({:?}) --> recursive at depth {}\",\n+                stack.fresh_trait_ref,\n+                cycle_depth,\n+            );\n+\n+            // If we have a stack like `A B C D E A`, where the top of\n+            // the stack is the final `A`, then this will iterate over\n+            // `A, E, D, C, B` -- i.e., all the participants apart\n+            // from the cycle head. We mark them as participating in a\n+            // cycle. This suppresses caching for those nodes. See\n+            // `in_cycle` field for more details.\n+            stack.update_reached_depth(cycle_depth);\n+\n+            // Subtle: when checking for a coinductive cycle, we do\n+            // not compare using the \"freshened trait refs\" (which\n+            // have erased regions) but rather the fully explicit\n+            // trait refs. This is important because it's only a cycle\n+            // if the regions match exactly.\n+            let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n+            let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n+            if self.coinductive_match(cycle) {\n+                debug!(\n+                    \"evaluate_stack({:?}) --> recursive, coinductive\",\n+                    stack.fresh_trait_ref\n+                );\n+                Some(EvaluatedToOk)\n+            } else {\n+                debug!(\n+                    \"evaluate_stack({:?}) --> recursive, inductive\",\n+                    stack.fresh_trait_ref\n+                );\n+                Some(EvaluatedToRecur)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn evaluate_stack<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n@@ -958,65 +1077,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(EvaluatedToUnknown);\n         }\n \n-        // If there is any previous entry on the stack that precisely\n-        // matches this obligation, then we can assume that the\n-        // obligation is satisfied for now (still all other conditions\n-        // must be met of course). One obvious case this comes up is\n-        // marker traits like `Send`. Think of a linked list:\n-        //\n-        //    struct List<T> { data: T, next: Option<Box<List<T>>> }\n-        //\n-        // `Box<List<T>>` will be `Send` if `T` is `Send` and\n-        // `Option<Box<List<T>>>` is `Send`, and in turn\n-        // `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n-        // `Send`.\n-        //\n-        // Note that we do this comparison using the `fresh_trait_ref`\n-        // fields. Because these have all been freshened using\n-        // `self.freshener`, we can be sure that (a) this will not\n-        // affect the inferencer state and (b) that if we see two\n-        // fresh regions with the same index, they refer to the same\n-        // unbound type variable.\n-        if let Some(rec_index) = stack.iter()\n-                 .skip(1) // skip top-most frame\n-                 .position(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n-                                  stack.fresh_trait_ref == prev.fresh_trait_ref)\n-        {\n-            debug!(\"evaluate_stack({:?}) --> recursive\", stack.fresh_trait_ref);\n-\n-            // If we have a stack like `A B C D E A`, where the top of\n-            // the stack is the final `A`, then this will iterate over\n-            // `A, E, D, C, B` -- i.e., all the participants apart\n-            // from the cycle head. We mark them as participating in a\n-            // cycle. This suppresses caching for those nodes. See\n-            // `in_cycle` field for more details.\n-            for item in stack.iter().take(rec_index + 1) {\n-                debug!(\"evaluate_stack: marking {:?} as cycle participant\", item.fresh_trait_ref);\n-                item.in_cycle.set(true);\n-            }\n-\n-            // Subtle: when checking for a coinductive cycle, we do\n-            // not compare using the \"freshened trait refs\" (which\n-            // have erased regions) but rather the fully explicit\n-            // trait refs. This is important because it's only a cycle\n-            // if the regions match exactly.\n-            let cycle = stack.iter().skip(1).take(rec_index + 1);\n-            let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n-            if self.coinductive_match(cycle) {\n-                debug!(\n-                    \"evaluate_stack({:?}) --> recursive, coinductive\",\n-                    stack.fresh_trait_ref\n-                );\n-                return Ok(EvaluatedToOk);\n-            } else {\n-                debug!(\n-                    \"evaluate_stack({:?}) --> recursive, inductive\",\n-                    stack.fresh_trait_ref\n-                );\n-                return Ok(EvaluatedToRecur);\n-            }\n-        }\n-\n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n             Ok(None) => Ok(EvaluatedToAmbig),\n@@ -1219,6 +1279,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // If no match, compute result and insert into cache.\n+        //\n+        // FIXME(nikomatsakis) -- this cache is not taking into\n+        // account cycles that may have occurred in forming the\n+        // candidate. I don't know of any specific problems that\n+        // result but it seems awfully suspicious.\n         let (candidate, dep_node) =\n             self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n \n@@ -3734,11 +3799,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .to_poly_trait_ref()\n             .fold_with(&mut self.freshener);\n \n+        let dfn = previous_stack.cache.next_dfn();\n+        let depth = previous_stack.depth() + 1;\n         TraitObligationStack {\n             obligation,\n             fresh_trait_ref,\n-            in_cycle: Cell::new(false),\n+            reached_depth: Cell::new(depth),\n             previous: previous_stack,\n+            dfn,\n+            depth,\n         }\n     }\n \n@@ -3931,28 +4000,283 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n         TraitObligationStackList::with(self)\n     }\n \n+    fn cache(&self) -> &'o ProvisionalEvaluationCache<'tcx> {\n+        self.previous.cache\n+    }\n+\n     fn iter(&'o self) -> TraitObligationStackList<'o, 'tcx> {\n         self.list()\n     }\n+\n+    /// Indicates that attempting to evaluate this stack entry\n+    /// required accessing something from the stack at depth `reached_depth`.\n+    fn update_reached_depth(&self, reached_depth: usize) {\n+        assert!(\n+            self.depth > reached_depth,\n+            \"invoked `update_reached_depth` with something under this stack: \\\n+             self.depth={} reached_depth={}\",\n+            self.depth,\n+            reached_depth,\n+        );\n+        debug!(\"update_reached_depth(reached_depth={})\", reached_depth);\n+        let mut p = self;\n+        while reached_depth < p.depth {\n+            debug!(\"update_reached_depth: marking {:?} as cycle participant\", p.fresh_trait_ref);\n+            p.reached_depth.set(p.reached_depth.get().min(reached_depth));\n+            p = p.previous.head.unwrap();\n+        }\n+    }\n+}\n+\n+/// The \"provisional evaluation cache\" is used to store intermediate cache results\n+/// when solving auto traits. Auto traits are unusual in that they can support\n+/// cycles. So, for example, a \"proof tree\" like this would be ok:\n+///\n+/// - `Foo<T>: Send` :-\n+///   - `Bar<T>: Send` :-\n+///     - `Foo<T>: Send` -- cycle, but ok\n+///   - `Baz<T>: Send`\n+///\n+/// Here, to prove `Foo<T>: Send`, we have to prove `Bar<T>: Send` and\n+/// `Baz<T>: Send`. Proving `Bar<T>: Send` in turn required `Foo<T>: Send`.\n+/// For non-auto traits, this cycle would be an error, but for auto traits (because\n+/// they are coinductive) it is considered ok.\n+///\n+/// However, there is a complication: at the point where we have\n+/// \"proven\" `Bar<T>: Send`, we have in fact only proven it\n+/// *provisionally*. In particular, we proved that `Bar<T>: Send`\n+/// *under the assumption* that `Foo<T>: Send`. But what if we later\n+/// find out this assumption is wrong?  Specifically, we could\n+/// encounter some kind of error proving `Baz<T>: Send`. In that case,\n+/// `Bar<T>: Send` didn't turn out to be true.\n+///\n+/// In Issue #60010, we found a bug in rustc where it would cache\n+/// these intermediate results. This was fixed in #60444 by disabling\n+/// *all* caching for things involved in a cycle -- in our example,\n+/// that would mean we don't cache that `Bar<T>: Send`.  But this led\n+/// to large slowdowns.\n+///\n+/// Specifically, imagine this scenario, where proving `Baz<T>: Send`\n+/// first requires proving `Bar<T>: Send` (which is true:\n+///\n+/// - `Foo<T>: Send` :-\n+///   - `Bar<T>: Send` :-\n+///     - `Foo<T>: Send` -- cycle, but ok\n+///   - `Baz<T>: Send`\n+///     - `Bar<T>: Send` -- would be nice for this to be a cache hit!\n+///     - `*const T: Send` -- but what if we later encounter an error?\n+///\n+/// The *provisional evaluation cache* resolves this issue. It stores\n+/// cache results that we've proven but which were involved in a cycle\n+/// in some way. We track the minimal stack depth (i.e., the\n+/// farthest from the top of the stack) that we are dependent on.\n+/// The idea is that the cache results within are all valid -- so long as\n+/// none of the nodes in between the current node and the node at that minimum\n+/// depth result in an error (in which case the cached results are just thrown away).\n+///\n+/// During evaluation, we consult this provisional cache and rely on\n+/// it. Accessing a cached value is considered equivalent to accessing\n+/// a result at `reached_depth`, so it marks the *current* solution as\n+/// provisional as well. If an error is encountered, we toss out any\n+/// provisional results added from the subtree that encountered the\n+/// error.  When we pop the node at `reached_depth` from the stack, we\n+/// can commit all the things that remain in the provisional cache.\n+struct ProvisionalEvaluationCache<'tcx> {\n+    /// next \"depth first number\" to issue -- just a counter\n+    dfn: Cell<usize>,\n+\n+    /// Stores the \"coldest\" depth (bottom of stack) reached by any of\n+    /// the evaluation entries. The idea here is that all things in the provisional\n+    /// cache are always dependent on *something* that is colder in the stack:\n+    /// therefore, if we add a new entry that is dependent on something *colder still*,\n+    /// we have to modify the depth for all entries at once.\n+    ///\n+    /// Example:\n+    ///\n+    /// Imagine we have a stack `A B C D E` (with `E` being the top of\n+    /// the stack).  We cache something with depth 2, which means that\n+    /// it was dependent on C.  Then we pop E but go on and process a\n+    /// new node F: A B C D F.  Now F adds something to the cache with\n+    /// depth 1, meaning it is dependent on B.  Our original cache\n+    /// entry is also dependent on B, because there is a path from E\n+    /// to C and then from C to F and from F to B.\n+    reached_depth: Cell<usize>,\n+\n+    /// Map from cache key to the provisionally evaluated thing.\n+    /// The cache entries contain the result but also the DFN in which they\n+    /// were added. The DFN is used to clear out values on failure.\n+    ///\n+    /// Imagine we have a stack like:\n+    ///\n+    /// - `A B C` and we add a cache for the result of C (DFN 2)\n+    /// - Then we have a stack `A B D` where `D` has DFN 3\n+    /// - We try to solve D by evaluating E: `A B D E` (DFN 4)\n+    /// - `E` generates various cache entries which have cyclic dependices on `B`\n+    ///   - `A B D E F` and so forth\n+    ///   - the DFN of `F` for example would be 5\n+    /// - then we determine that `E` is in error -- we will then clear\n+    ///   all cache values whose DFN is >= 4 -- in this case, that\n+    ///   means the cached value for `F`.\n+    map: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ProvisionalEvaluation>>,\n+}\n+\n+/// A cache value for the provisional cache: contains the depth-first\n+/// number (DFN) and result.\n+#[derive(Copy, Clone, Debug)]\n+struct ProvisionalEvaluation {\n+    from_dfn: usize,\n+    result: EvaluationResult,\n+}\n+\n+impl<'tcx> Default for ProvisionalEvaluationCache<'tcx> {\n+    fn default() -> Self {\n+        Self {\n+            dfn: Cell::new(0),\n+            reached_depth: Cell::new(std::usize::MAX),\n+            map: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n+    /// Get the next DFN in sequence (basically a counter).\n+    fn next_dfn(&self) -> usize {\n+        let result = self.dfn.get();\n+        self.dfn.set(result + 1);\n+        result\n+    }\n+\n+    /// Check the provisional cache for any result for\n+    /// `fresh_trait_ref`. If there is a hit, then you must consider\n+    /// it an access to the stack slots at depth\n+    /// `self.current_reached_depth()` and above.\n+    fn get_provisional(&self, fresh_trait_ref: ty::PolyTraitRef<'tcx>) -> Option<EvaluationResult> {\n+        debug!(\n+            \"get_provisional(fresh_trait_ref={:?}) = {:#?} with reached-depth {}\",\n+            fresh_trait_ref,\n+            self.map.borrow().get(&fresh_trait_ref),\n+            self.reached_depth.get(),\n+        );\n+        Some(self.map.borrow().get(&fresh_trait_ref)?.result)\n+    }\n+\n+    /// Current value of the `reached_depth` counter -- all the\n+    /// provisional cache entries are dependent on the item at this\n+    /// depth.\n+    fn current_reached_depth(&self) -> usize {\n+        self.reached_depth.get()\n+    }\n+\n+    /// Insert a provisional result into the cache. The result came\n+    /// from the node with the given DFN. It accessed a minimum depth\n+    /// of `reached_depth` to compute. It evaluated `fresh_trait_ref`\n+    /// and resulted in `result`.\n+    fn insert_provisional(\n+        &self,\n+        from_dfn: usize,\n+        reached_depth: usize,\n+        fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n+        result: EvaluationResult,\n+    ) {\n+        debug!(\n+            \"insert_provisional(from_dfn={}, reached_depth={}, fresh_trait_ref={:?}, result={:?})\",\n+            from_dfn,\n+            reached_depth,\n+            fresh_trait_ref,\n+            result,\n+        );\n+        let r_d = self.reached_depth.get();\n+        self.reached_depth.set(r_d.min(reached_depth));\n+\n+        debug!(\"insert_provisional: reached_depth={:?}\", self.reached_depth.get());\n+\n+        self.map.borrow_mut().insert(fresh_trait_ref, ProvisionalEvaluation { from_dfn, result });\n+    }\n+\n+    /// Invoked when the node with dfn `dfn` does not get a successful\n+    /// result.  This will clear out any provisional cache entries\n+    /// that were added since `dfn` was created. This is because the\n+    /// provisional entries are things which must assume that the\n+    /// things on the stack at the time of their creation succeeded --\n+    /// since the failing node is presently at the top of the stack,\n+    /// these provisional entries must either depend on it or some\n+    /// ancestor of it.\n+    fn on_failure(&self, dfn: usize) {\n+        debug!(\n+            \"on_failure(dfn={:?})\",\n+            dfn,\n+        );\n+        self.map.borrow_mut().retain(|key, eval| {\n+            if !eval.from_dfn >= dfn {\n+                debug!(\"on_failure: removing {:?}\", key);\n+                false\n+            } else {\n+                true\n+            }\n+        });\n+    }\n+\n+    /// Invoked when the node at depth `depth` completed without\n+    /// depending on anything higher in the stack (if that completion\n+    /// was a failure, then `on_failure` should have been invoked\n+    /// already). The callback `op` will be invoked for each\n+    /// provisional entry that we can now confirm.\n+    fn on_completion(\n+        &self,\n+        depth: usize,\n+        mut op: impl FnMut(ty::PolyTraitRef<'tcx>, EvaluationResult),\n+    ) {\n+        debug!(\n+            \"on_completion(depth={}, reached_depth={})\",\n+            depth,\n+            self.reached_depth.get(),\n+        );\n+\n+        if self.reached_depth.get() < depth {\n+            debug!(\"on_completion: did not yet reach depth to complete\");\n+            return;\n+        }\n+\n+        for (fresh_trait_ref, eval) in self.map.borrow_mut().drain() {\n+            debug!(\n+                \"on_completion: fresh_trait_ref={:?} eval={:?}\",\n+                fresh_trait_ref,\n+                eval,\n+            );\n+\n+            op(fresh_trait_ref, eval.result);\n+        }\n+\n+        self.reached_depth.set(std::usize::MAX);\n+    }\n }\n \n #[derive(Copy, Clone)]\n struct TraitObligationStackList<'o, 'tcx: 'o> {\n+    cache: &'o ProvisionalEvaluationCache<'tcx>,\n     head: Option<&'o TraitObligationStack<'o, 'tcx>>,\n }\n \n impl<'o, 'tcx> TraitObligationStackList<'o, 'tcx> {\n-    fn empty() -> TraitObligationStackList<'o, 'tcx> {\n-        TraitObligationStackList { head: None }\n+    fn empty(cache: &'o ProvisionalEvaluationCache<'tcx>) -> TraitObligationStackList<'o, 'tcx> {\n+        TraitObligationStackList { cache, head: None }\n     }\n \n     fn with(r: &'o TraitObligationStack<'o, 'tcx>) -> TraitObligationStackList<'o, 'tcx> {\n-        TraitObligationStackList { head: Some(r) }\n+        TraitObligationStackList { cache: r.cache(), head: Some(r) }\n     }\n \n     fn head(&self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {\n         self.head\n     }\n+\n+    fn depth(&self) -> usize {\n+        if let Some(head) = self.head {\n+            head.depth\n+        } else {\n+            0\n+        }\n+    }\n }\n \n impl<'o, 'tcx> Iterator for TraitObligationStackList<'o, 'tcx> {"}, {"sha": "30a1814d0f83ef697d6a1fdc26ed779718ac3765", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3175c34b4211d219f114d6dc608194ebaf03c44/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3175c34b4211d219f114d6dc608194ebaf03c44/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=e3175c34b4211d219f114d6dc608194ebaf03c44", "patch": "@@ -29,7 +29,7 @@ fn evaluate_obligation<'tcx>(\n             let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n             let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n \n-            selcx.evaluate_obligation_recursively(&obligation)\n+            selcx.evaluate_root_obligation(&obligation)\n         },\n     )\n }"}, {"sha": "cd906bb282b7e3f942f7ef19041829602edd903a", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3175c34b4211d219f114d6dc608194ebaf03c44/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3175c34b4211d219f114d6dc608194ebaf03c44/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=e3175c34b4211d219f114d6dc608194ebaf03c44", "patch": "@@ -65,9 +65,9 @@ where\n // bounds without them.\n // FIXME: Remove these impls when the compiler can compute the bounds quickly again.\n // See https://github.com/rust-lang/rust/issues/60846\n-#[cfg(parallel_compiler)]\n+#[cfg(all(bootstrap, parallel_compiler))]\n unsafe impl Send for TokenTree {}\n-#[cfg(parallel_compiler)]\n+#[cfg(all(bootstrap, parallel_compiler))]\n unsafe impl Sync for TokenTree {}\n \n impl TokenTree {"}]}