{"sha": "7bc827b34b3836245270025183096d9abebb8659", "node_id": "C_kwDOAAsO6NoAKDdiYzgyN2IzNGIzODM2MjQ1MjcwMDI1MTgzMDk2ZDlhYmViYjg2NTk", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-11-05T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-11-05T20:31:18Z"}, "message": "Refactor single variant `Candidate` enum into a struct\n\n`Candidate` enum has only a single `Ref` variant.  Refactor it into a\nstruct and reduce overall indentation of the code by two levels.\n\nNo functional changes.", "tree": {"sha": "548ec438c853b80da3def0e8128d1215eae2d761", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/548ec438c853b80da3def0e8128d1215eae2d761"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc827b34b3836245270025183096d9abebb8659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc827b34b3836245270025183096d9abebb8659", "html_url": "https://github.com/rust-lang/rust/commit/7bc827b34b3836245270025183096d9abebb8659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc827b34b3836245270025183096d9abebb8659/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "045612b8b97b344d55c13b9aad3cfb3e98405b77", "url": "https://api.github.com/repos/rust-lang/rust/commits/045612b8b97b344d55c13b9aad3cfb3e98405b77", "html_url": "https://github.com/rust-lang/rust/commit/045612b8b97b344d55c13b9aad3cfb3e98405b77"}], "stats": {"total": 177, "additions": 82, "deletions": 95}, "files": [{"sha": "da0c10dc4ee960236efd3329e0d952cac9651783", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 82, "deletions": 95, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/7bc827b34b3836245270025183096d9abebb8659/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc827b34b3836245270025183096d9abebb8659/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=7bc827b34b3836245270025183096d9abebb8659", "patch": "@@ -93,16 +93,13 @@ impl TempState {\n /// returned value in a promoted MIR, unless it's a subset\n /// of a larger candidate.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum Candidate {\n-    /// Borrow of a constant temporary, candidate for lifetime extension.\n-    Ref(Location),\n+pub struct Candidate {\n+    location: Location,\n }\n \n impl Candidate {\n     fn source_info(&self, body: &Body<'_>) -> SourceInfo {\n-        match self {\n-            Candidate::Ref(location) => *body.source_info(*location),\n-        }\n+        *body.source_info(self.location)\n     }\n }\n \n@@ -167,7 +164,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n \n         match *rvalue {\n             Rvalue::Ref(..) => {\n-                self.candidates.push(Candidate::Ref(location));\n+                self.candidates.push(Candidate { location });\n             }\n             _ => {}\n         }\n@@ -209,36 +206,33 @@ struct Unpromotable;\n \n impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n-        match candidate {\n-            Candidate::Ref(loc) => {\n-                let statement = &self.body[loc.block].statements[loc.statement_index];\n-                match &statement.kind {\n-                    StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n-                        // We can only promote interior borrows of promotable temps (non-temps\n-                        // don't get promoted anyway).\n-                        self.validate_local(place.local)?;\n-\n-                        // The reference operation itself must be promotable.\n-                        // (Needs to come after `validate_local` to avoid ICEs.)\n-                        self.validate_ref(*kind, place)?;\n-\n-                        // We do not check all the projections (they do not get promoted anyway),\n-                        // but we do stay away from promoting anything involving a dereference.\n-                        if place.projection.contains(&ProjectionElem::Deref) {\n-                            return Err(Unpromotable);\n-                        }\n+        let loc = candidate.location;\n+        let statement = &self.body[loc.block].statements[loc.statement_index];\n+        match &statement.kind {\n+            StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n+                // We can only promote interior borrows of promotable temps (non-temps\n+                // don't get promoted anyway).\n+                self.validate_local(place.local)?;\n+\n+                // The reference operation itself must be promotable.\n+                // (Needs to come after `validate_local` to avoid ICEs.)\n+                self.validate_ref(*kind, place)?;\n \n-                        // We cannot promote things that need dropping, since the promoted value\n-                        // would not get dropped.\n-                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n-                            return Err(Unpromotable);\n-                        }\n+                // We do not check all the projections (they do not get promoted anyway),\n+                // but we do stay away from promoting anything involving a dereference.\n+                if place.projection.contains(&ProjectionElem::Deref) {\n+                    return Err(Unpromotable);\n+                }\n \n-                        Ok(())\n-                    }\n-                    _ => bug!(),\n+                // We cannot promote things that need dropping, since the promoted value\n+                // would not get dropped.\n+                if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n+                    return Err(Unpromotable);\n                 }\n+\n+                Ok(())\n             }\n+            _ => bug!(),\n         }\n     }\n \n@@ -871,58 +865,55 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 }))\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n-            match candidate {\n-                Candidate::Ref(loc) => {\n-                    let statement = &mut blocks[loc.block].statements[loc.statement_index];\n-                    match statement.kind {\n-                        StatementKind::Assign(box (\n-                            _,\n-                            Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n-                        )) => {\n-                            // Use the underlying local for this (necessarily interior) borrow.\n-                            let ty = local_decls.local_decls()[place.local].ty;\n-                            let span = statement.source_info.span;\n-\n-                            let ref_ty = tcx.mk_ref(\n-                                tcx.lifetimes.re_erased,\n-                                ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n-                            );\n-\n-                            *region = tcx.lifetimes.re_erased;\n-\n-                            let mut projection = vec![PlaceElem::Deref];\n-                            projection.extend(place.projection);\n-                            place.projection = tcx.intern_place_elems(&projection);\n-\n-                            // Create a temp to hold the promoted reference.\n-                            // This is because `*r` requires `r` to be a local,\n-                            // otherwise we would use the `promoted` directly.\n-                            let mut promoted_ref = LocalDecl::new(ref_ty, span);\n-                            promoted_ref.source_info = statement.source_info;\n-                            let promoted_ref = local_decls.push(promoted_ref);\n-                            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n-\n-                            let promoted_ref_statement = Statement {\n-                                source_info: statement.source_info,\n-                                kind: StatementKind::Assign(Box::new((\n-                                    Place::from(promoted_ref),\n-                                    Rvalue::Use(promoted_operand(ref_ty, span)),\n-                                ))),\n-                            };\n-                            self.extra_statements.push((loc, promoted_ref_statement));\n-\n-                            Rvalue::Ref(\n-                                tcx.lifetimes.re_erased,\n-                                borrow_kind,\n-                                Place {\n-                                    local: mem::replace(&mut place.local, promoted_ref),\n-                                    projection: List::empty(),\n-                                },\n-                            )\n-                        }\n-                        _ => bug!(),\n-                    }\n+            let loc = candidate.location;\n+            let statement = &mut blocks[loc.block].statements[loc.statement_index];\n+            match statement.kind {\n+                StatementKind::Assign(box (\n+                    _,\n+                    Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n+                )) => {\n+                    // Use the underlying local for this (necessarily interior) borrow.\n+                    let ty = local_decls.local_decls()[place.local].ty;\n+                    let span = statement.source_info.span;\n+\n+                    let ref_ty = tcx.mk_ref(\n+                        tcx.lifetimes.re_erased,\n+                        ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n+                    );\n+\n+                    *region = tcx.lifetimes.re_erased;\n+\n+                    let mut projection = vec![PlaceElem::Deref];\n+                    projection.extend(place.projection);\n+                    place.projection = tcx.intern_place_elems(&projection);\n+\n+                    // Create a temp to hold the promoted reference.\n+                    // This is because `*r` requires `r` to be a local,\n+                    // otherwise we would use the `promoted` directly.\n+                    let mut promoted_ref = LocalDecl::new(ref_ty, span);\n+                    promoted_ref.source_info = statement.source_info;\n+                    let promoted_ref = local_decls.push(promoted_ref);\n+                    assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n+\n+                    let promoted_ref_statement = Statement {\n+                        source_info: statement.source_info,\n+                        kind: StatementKind::Assign(Box::new((\n+                            Place::from(promoted_ref),\n+                            Rvalue::Use(promoted_operand(ref_ty, span)),\n+                        ))),\n+                    };\n+                    self.extra_statements.push((loc, promoted_ref_statement));\n+\n+                    Rvalue::Ref(\n+                        tcx.lifetimes.re_erased,\n+                        borrow_kind,\n+                        Place {\n+                            local: mem::replace(&mut place.local, promoted_ref),\n+                            projection: List::empty(),\n+                        },\n+                    )\n                 }\n+                _ => bug!(),\n             }\n         };\n \n@@ -964,17 +955,13 @@ pub fn promote_candidates<'tcx>(\n \n     let mut extra_statements = vec![];\n     for candidate in candidates.into_iter().rev() {\n-        match candidate {\n-            Candidate::Ref(Location { block, statement_index }) => {\n-                if let StatementKind::Assign(box (place, _)) =\n-                    &body[block].statements[statement_index].kind\n-                {\n-                    if let Some(local) = place.as_local() {\n-                        if temps[local] == TempState::PromotedOut {\n-                            // Already promoted.\n-                            continue;\n-                        }\n-                    }\n+        let Location { block, statement_index } = candidate.location;\n+        if let StatementKind::Assign(box (place, _)) = &body[block].statements[statement_index].kind\n+        {\n+            if let Some(local) = place.as_local() {\n+                if temps[local] == TempState::PromotedOut {\n+                    // Already promoted.\n+                    continue;\n                 }\n             }\n         }"}]}