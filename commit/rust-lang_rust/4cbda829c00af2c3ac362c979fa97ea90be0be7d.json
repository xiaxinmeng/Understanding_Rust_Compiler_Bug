{"sha": "4cbda829c00af2c3ac362c979fa97ea90be0be7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYmRhODI5YzAwYWYyYzNhYzM2MmM5NzlmYTk3ZWE5MGJlMGJlN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-01T14:30:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-01T14:30:02Z"}, "message": "Auto merge of #74967 - Aaron1011:feature/incr-def-path-table, r=pnkfelix\n\nImplement lazy decoding of DefPathTable during incremental compilation\n\nPR https://github.com/rust-lang/rust/pull/75813 implemented lazy decoding of the `DefPathTable` from crate metadata. However, it requires decoding the entire `DefPathTable` when incremental compilation is active, so that we can map a decoded `DefPathHash` to a `DefId` from an arbitrary crate.\n\nThis PR adds support for lazy decoding of dependency `DefPathTable`s when incremental compilation si active.\n\nWhen we load the incremental cache and dep\ngraph, we need the ability to map a `DefPathHash` to a `DefId` in the\ncurrent compilation session (if the corresponding definition still\nexists).\n\nThis is accomplished by storing the old `DefId` (that is, the `DefId`\nfrom the previous compilation session) for each `DefPathHash` we need to\nremap. Since a `DefPathHash` includes the owning crate, the old crate is\nguaranteed to be the right one (if the definition still exists). We then\nuse the old `DefIndex` as an initial guess, which we validate by\ncomparing the expected and actual `DefPathHash`es. In most cases,\nforeign crates will be completely unchanged, which means that we our\nguess will be correct. If our guess is wrong, we fall back to decoding\nthe entire `DefPathTable` for the foreign crate. This still represents\nan improvement over the status quo, since we can skip decoding the\nentire `DefPathTable` for other crates (where all of our guesses were\ncorrect).", "tree": {"sha": "b75723e959bdda25ac83d5acf2f01bbb3cd32acb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75723e959bdda25ac83d5acf2f01bbb3cd32acb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cbda829c00af2c3ac362c979fa97ea90be0be7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbda829c00af2c3ac362c979fa97ea90be0be7d", "html_url": "https://github.com/rust-lang/rust/commit/4cbda829c00af2c3ac362c979fa97ea90be0be7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cbda829c00af2c3ac362c979fa97ea90be0be7d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2dd82929b5b956972446d9720ceabdee171d405", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2dd82929b5b956972446d9720ceabdee171d405", "html_url": "https://github.com/rust-lang/rust/commit/b2dd82929b5b956972446d9720ceabdee171d405"}, {"sha": "7a9aa4f9808fe37afb581ba54884612df2034a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9aa4f9808fe37afb581ba54884612df2034a75", "html_url": "https://github.com/rust-lang/rust/commit/7a9aa4f9808fe37afb581ba54884612df2034a75"}], "stats": {"total": 329, "additions": 289, "deletions": 40}, "files": [{"sha": "35428dc8d84e5e00c0bf681cca74e0de25d8b194", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -1,6 +1,7 @@\n //! Code to save/load the dep-graph from files.\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::definitions::Definitions;\n use rustc_middle::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::query::OnDiskCache;\n use rustc_middle::ty::TyCtxt;\n@@ -204,7 +205,10 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n /// If we are not in incremental compilation mode, returns `None`.\n /// Otherwise, tries to load the query result cache from disk,\n /// creating an empty cache if it could not be loaded.\n-pub fn load_query_result_cache(sess: &Session) -> Option<OnDiskCache<'_>> {\n+pub fn load_query_result_cache<'a>(\n+    sess: &'a Session,\n+    definitions: &Definitions,\n+) -> Option<OnDiskCache<'a>> {\n     if sess.opts.incremental.is_none() {\n         return None;\n     }\n@@ -217,7 +221,7 @@ pub fn load_query_result_cache(sess: &Session) -> Option<OnDiskCache<'_>> {\n         sess.is_nightly_build(),\n     ) {\n         LoadResult::Ok { data: (bytes, start_pos) } => {\n-            Some(OnDiskCache::new(sess, bytes, start_pos))\n+            Some(OnDiskCache::new(sess, bytes, start_pos, definitions))\n         }\n         _ => Some(OnDiskCache::new_empty(sess.source_map())),\n     }"}, {"sha": "c13d26c79d738c89c8edc0a102b2c10e81f7cc41", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -747,7 +747,7 @@ pub fn create_global_ctxt<'tcx>(\n         Definitions::new(crate_name, sess.local_crate_disambiguator()),\n     ));\n \n-    let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n+    let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess, defs);\n \n     let codegen_backend = compiler.codegen_backend();\n     let mut local_providers = *DEFAULT_QUERY_PROVIDERS;"}, {"sha": "f53a40278062cb95fa63ac8531d3b655fbaee1b6", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -77,6 +77,10 @@ crate struct CrateMetadata {\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n     source_map_import_info: OnceCell<Vec<ImportedSourceFile>>,\n+    /// For every definition in this crate, maps its `DefPathHash` to its\n+    /// `DefIndex`. See `raw_def_id_to_def_id` for more details about how\n+    /// this is used.\n+    def_path_hash_map: OnceCell<FxHashMap<DefPathHash, DefIndex>>,\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     alloc_decoding_state: AllocDecodingState,\n     /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n@@ -1519,6 +1523,53 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .or_insert_with(|| self.root.tables.def_keys.get(self, index).unwrap().decode(self))\n     }\n \n+    /// Finds the corresponding `DefId` for the provided `DefPathHash`, if it exists.\n+    /// This is used by incremental compilation to map a serialized `DefPathHash` to\n+    /// its `DefId` in the current session.\n+    /// Normally, only one 'main' crate will change between incremental compilation sessions:\n+    /// all dependencies will be completely unchanged. In this case, we can avoid\n+    /// decoding every `DefPathHash` in the crate, since the `DefIndex` from the previous\n+    /// session will still be valid. If our 'guess' is wrong (the `DefIndex` no longer exists,\n+    /// or has a different `DefPathHash`, then we need to decode all `DefPathHashes` to determine\n+    /// the correct mapping).\n+    fn def_path_hash_to_def_id(\n+        &self,\n+        krate: CrateNum,\n+        index_guess: u32,\n+        hash: DefPathHash,\n+    ) -> Option<DefId> {\n+        let def_index_guess = DefIndex::from_u32(index_guess);\n+        let old_hash = self\n+            .root\n+            .tables\n+            .def_path_hashes\n+            .get(self, def_index_guess)\n+            .map(|lazy| lazy.decode(self));\n+\n+        // Fast path: the definition and its index is unchanged from the\n+        // previous compilation session. There is no need to decode anything\n+        // else\n+        if old_hash == Some(hash) {\n+            return Some(DefId { krate, index: def_index_guess });\n+        }\n+\n+        // Slow path: We need to find out the new `DefIndex` of the provided\n+        // `DefPathHash`, if its still exists. This requires decoding every `DefPathHash`\n+        // stored in this crate.\n+        let map = self.cdata.def_path_hash_map.get_or_init(|| {\n+            let end_id = self.root.tables.def_path_hashes.size() as u32;\n+            let mut map = FxHashMap::with_capacity_and_hasher(end_id as usize, Default::default());\n+            for i in 0..end_id {\n+                let def_index = DefIndex::from_u32(i);\n+                let hash =\n+                    self.root.tables.def_path_hashes.get(self, def_index).unwrap().decode(self);\n+                map.insert(hash, def_index);\n+            }\n+            map\n+        });\n+        map.get(&hash).map(|index| DefId { krate, index: *index })\n+    }\n+\n     // Returns the path leading to the thing with this `id`.\n     fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n@@ -1797,6 +1848,7 @@ impl CrateMetadata {\n             trait_impls,\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n+            def_path_hash_map: Default::default(),\n             alloc_decoding_state,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n             cnum,"}, {"sha": "2ffd239b2f06c397ac411dbb247db0824ff3ef93", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -506,6 +506,16 @@ impl CrateStore for CStore {\n         self.get_crate_data(cnum).num_def_ids()\n     }\n \n+    // See `CrateMetadataRef::def_path_hash_to_def_id` for more details\n+    fn def_path_hash_to_def_id(\n+        &self,\n+        cnum: CrateNum,\n+        index_guess: u32,\n+        hash: DefPathHash,\n+    ) -> Option<DefId> {\n+        self.get_crate_data(cnum).def_path_hash_to_def_id(cnum, index_guess, hash)\n+    }\n+\n     fn crates_untracked(&self) -> Vec<CrateNum> {\n         let mut result = vec![];\n         self.iter_crate_data(|cnum, _| result.push(cnum));"}, {"sha": "d954c8ab5fb9c3e5cf247bb55470f733d0d7d06d", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -252,8 +252,7 @@ macro_rules! define_dep_nodes {\n             /// has been removed.\n             fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n                 if self.kind.can_reconstruct_query_key() {\n-                    let def_path_hash = DefPathHash(self.hash.into());\n-                    tcx.def_path_hash_to_def_id.as_ref()?.get(&def_path_hash).cloned()\n+                    tcx.queries.on_disk_cache.as_ref()?.def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into()))\n                 } else {\n                     None\n                 }\n@@ -320,7 +319,17 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n     }\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n-        tcx.def_path_hash(*self).0\n+        let hash = tcx.def_path_hash(*self);\n+        // If this is a foreign `DefId`, store its current value\n+        // in the incremental cache. When we decode the cache,\n+        // we will use the old DefIndex as an initial guess for\n+        // a lookup into the crate metadata.\n+        if !self.is_local() {\n+            if let Some(cache) = &tcx.queries.on_disk_cache {\n+                cache.store_foreign_def_id_hash(*self, hash);\n+            }\n+        }\n+        hash.0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n@@ -359,7 +368,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n-        tcx.def_path_hash(def_id).0\n+        def_id.to_fingerprint(tcx)\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {"}, {"sha": "a94f6d25fc71ee8a8783a9382fe368ddfef7bf66", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::def_id::{DefPathHash, LocalDefId};\n \n mod dep_node;\n \n@@ -91,6 +91,12 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     type DepKind = DepKind;\n     type StableHashingContext = StableHashingContext<'tcx>;\n \n+    fn register_reused_dep_path_hash(&self, hash: DefPathHash) {\n+        if let Some(cache) = self.queries.on_disk_cache.as_ref() {\n+            cache.register_reused_dep_path_hash(hash)\n+        }\n+    }\n+\n     fn create_stable_hashing_context(&self) -> Self::StableHashingContext {\n         TyCtxt::create_stable_hashing_context(*self)\n     }"}, {"sha": "bd7121ca1d70f7ea43f20a69420930215e8a0a8d", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -191,6 +191,12 @@ pub trait CrateStore {\n     fn def_path_hash(&self, def: DefId) -> DefPathHash;\n     fn all_def_path_hashes_and_def_ids(&self, cnum: CrateNum) -> Vec<(DefPathHash, DefId)>;\n     fn num_def_ids(&self, cnum: CrateNum) -> usize;\n+    fn def_path_hash_to_def_id(\n+        &self,\n+        cnum: CrateNum,\n+        index_guess: u32,\n+        hash: DefPathHash,\n+    ) -> Option<DefId>;\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;"}, {"sha": "f078bbacfe96cd08c9a7b4f369aef37b8b337295", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -1,7 +1,7 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::{self, DepConstructor, DepGraph};\n+use crate::dep_graph::{self, DepGraph, DepKind, DepNode, DepNodeExt};\n use crate::hir::exports::ExportMap;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n@@ -34,12 +34,12 @@ use rustc_data_structures::stable_hasher::{\n };\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n-use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefPathHash, Definitions};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n@@ -945,10 +945,6 @@ pub struct GlobalCtxt<'tcx> {\n     pub(crate) untracked_crate: &'tcx hir::Crate<'tcx>,\n     pub(crate) definitions: &'tcx Definitions,\n \n-    /// A map from `DefPathHash` -> `DefId`. Includes `DefId`s from the local crate\n-    /// as well as all upstream crates. Only populated in incremental mode.\n-    pub def_path_hash_to_def_id: Option<UnhashMap<DefPathHash, DefId>>,\n-\n     pub queries: query::Queries<'tcx>,\n \n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n@@ -1113,21 +1109,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n \n-        let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n-            let capacity = definitions.def_path_table().num_def_ids()\n-                + crates.iter().map(|cnum| cstore.num_def_ids(*cnum)).sum::<usize>();\n-            let mut map = UnhashMap::with_capacity_and_hasher(capacity, Default::default());\n-\n-            map.extend(definitions.def_path_table().all_def_path_hashes_and_def_ids(LOCAL_CRATE));\n-            for cnum in &crates {\n-                map.extend(cstore.all_def_path_hashes_and_def_ids(*cnum).into_iter());\n-            }\n-\n-            Some(map)\n-        } else {\n-            None\n-        };\n-\n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (hir_id, v) in krate.trait_map.iter() {\n             let map = trait_map.entry(hir_id.owner).or_default();\n@@ -1155,7 +1136,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             extern_prelude: resolutions.extern_prelude,\n             untracked_crate: krate,\n             definitions,\n-            def_path_hash_to_def_id,\n             queries: query::Queries::new(providers, extern_providers, on_disk_query_result_cache),\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),\n@@ -1329,7 +1309,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         // We cannot use the query versions of crates() and crate_hash(), since\n         // those would need the DepNodes that we are allocating here.\n         for cnum in self.cstore.crates_untracked() {\n-            let dep_node = DepConstructor::CrateMetadata(self, cnum);\n+            let def_path_hash = self.def_path_hash(DefId { krate: cnum, index: CRATE_DEF_INDEX });\n+            let dep_node = DepNode::from_def_path_hash(def_path_hash, DepKind::CrateMetadata);\n             let crate_hash = self.cstore.crate_hash_untracked(cnum);\n             self.dep_graph.with_task(\n                 dep_node,"}, {"sha": "898cc24992ba8f98d83b1bdfcb7a5f1a1d6e0004", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 172, "deletions": 7, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -11,6 +11,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n+use rustc_hir::definitions::Definitions;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_session::{CrateDisambiguator, Session};\n@@ -21,6 +22,8 @@ use rustc_span::hygiene::{\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, ExpnData, SourceFile, Span, DUMMY_SP};\n+use std::collections::hash_map::Entry;\n+use std::iter::FromIterator;\n use std::mem;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n@@ -80,6 +83,31 @@ pub struct OnDiskCache<'sess> {\n     expn_data: FxHashMap<u32, AbsoluteBytePos>,\n     // Additional information used when decoding hygiene data.\n     hygiene_context: HygieneDecodeContext,\n+    // Maps `DefPathHash`es to their `RawDefId`s from the *previous*\n+    // compilation session. This is used as an initial 'guess' when\n+    // we try to map a `DefPathHash` to its `DefId` in the current compilation\n+    // session.\n+    foreign_def_path_hashes: FxHashMap<DefPathHash, RawDefId>,\n+\n+    // The *next* compilation sessison's `foreign_def_path_hashes` - at\n+    // the end of our current compilation session, this will get written\n+    // out to the `foreign_def_path_hashes` field of the `Footer`, which\n+    // will become `foreign_def_path_hashes` of the next compilation session.\n+    // This stores any `DefPathHash` that we may need to map to a `DefId`\n+    // during the next compilation session.\n+    latest_foreign_def_path_hashes: Lock<FxHashMap<DefPathHash, RawDefId>>,\n+\n+    // Maps `DefPathHashes` to their corresponding `LocalDefId`s for all\n+    // local items in the current compilation session. This is only populated\n+    // when we are in incremental mode and have loaded a pre-existing cache\n+    // from disk, since this map is only used when deserializing a `DefPathHash`\n+    // from the incremental cache.\n+    local_def_path_hash_to_def_id: FxHashMap<DefPathHash, LocalDefId>,\n+    // Caches all lookups of `DefPathHashes`, both for local and foreign\n+    // definitions. A definition from the previous compilation session\n+    // may no longer exist in the current compilation session, so\n+    // we use `Option<DefId>` so that we can cache a lookup failure.\n+    def_path_hash_to_def_id_cache: Lock<FxHashMap<DefPathHash, Option<DefId>>>,\n }\n \n // This type is used only for serialization and deserialization.\n@@ -95,6 +123,7 @@ struct Footer {\n     syntax_contexts: FxHashMap<u32, AbsoluteBytePos>,\n     // See `OnDiskCache.expn_data`\n     expn_data: FxHashMap<u32, AbsoluteBytePos>,\n+    foreign_def_path_hashes: FxHashMap<DefPathHash, RawDefId>,\n }\n \n type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n@@ -118,9 +147,36 @@ impl AbsoluteBytePos {\n     }\n }\n \n+/// Represents a potentially invalid `DefId`. This is used during incremental\n+/// compilation to represent a `DefId` from the *previous* compilation session,\n+/// which may no longer be valid. This is used to help map a `DefPathHash`\n+/// to a `DefId` in the current compilation session.\n+#[derive(Encodable, Decodable, Copy, Clone, Debug)]\n+crate struct RawDefId {\n+    // We deliberately do not use `CrateNum` and `DefIndex`\n+    // here, since a crate/index from the previous compilation\n+    // session may no longer exist.\n+    pub krate: u32,\n+    pub index: u32,\n+}\n+\n+fn make_local_def_path_hash_map(definitions: &Definitions) -> FxHashMap<DefPathHash, LocalDefId> {\n+    FxHashMap::from_iter(\n+        definitions\n+            .def_path_table()\n+            .all_def_path_hashes_and_def_ids(LOCAL_CRATE)\n+            .map(|(hash, def_id)| (hash, def_id.as_local().unwrap())),\n+    )\n+}\n+\n impl<'sess> OnDiskCache<'sess> {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n-    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n+    pub fn new(\n+        sess: &'sess Session,\n+        data: Vec<u8>,\n+        start_pos: usize,\n+        definitions: &Definitions,\n+    ) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n         // Wrap in a scope so we can borrow `data`.\n@@ -155,6 +211,10 @@ impl<'sess> OnDiskCache<'sess> {\n             syntax_contexts: footer.syntax_contexts,\n             expn_data: footer.expn_data,\n             hygiene_context: Default::default(),\n+            foreign_def_path_hashes: footer.foreign_def_path_hashes,\n+            latest_foreign_def_path_hashes: Default::default(),\n+            local_def_path_hash_to_def_id: make_local_def_path_hash_map(definitions),\n+            def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }\n \n@@ -173,6 +233,10 @@ impl<'sess> OnDiskCache<'sess> {\n             syntax_contexts: FxHashMap::default(),\n             expn_data: FxHashMap::default(),\n             hygiene_context: Default::default(),\n+            foreign_def_path_hashes: Default::default(),\n+            latest_foreign_def_path_hashes: Default::default(),\n+            local_def_path_hash_to_def_id: Default::default(),\n+            def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }\n \n@@ -200,6 +264,15 @@ impl<'sess> OnDiskCache<'sess> {\n                 (file_to_file_index, file_index_to_stable_id)\n             };\n \n+            // Load everything into memory so we can write it out to the on-disk\n+            // cache. The vast majority of cacheable query results should already\n+            // be in memory, so this should be a cheap operation.\n+            // Do this *before* we clone 'latest_foreign_def_path_hashes', since\n+            // loading existing queries may cause us to create new DepNodes, which\n+            // may in turn end up invoking `store_foreign_def_id_hash`\n+            tcx.dep_graph.exec_cache_promotions(tcx);\n+\n+            let latest_foreign_def_path_hashes = self.latest_foreign_def_path_hashes.lock().clone();\n             let hygiene_encode_context = HygieneEncodeContext::default();\n \n             let mut encoder = CacheEncoder {\n@@ -211,13 +284,9 @@ impl<'sess> OnDiskCache<'sess> {\n                 source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n                 file_to_file_index,\n                 hygiene_context: &hygiene_encode_context,\n+                latest_foreign_def_path_hashes,\n             };\n \n-            // Load everything into memory so we can write it out to the on-disk\n-            // cache. The vast majority of cacheable query results should already\n-            // be in memory, so this should be a cheap operation.\n-            tcx.dep_graph.exec_cache_promotions(tcx);\n-\n             // Encode query results.\n             let mut query_result_index = EncodedQueryResultIndex::new();\n \n@@ -312,6 +381,9 @@ impl<'sess> OnDiskCache<'sess> {\n                 },\n             )?;\n \n+            let foreign_def_path_hashes =\n+                std::mem::take(&mut encoder.latest_foreign_def_path_hashes);\n+\n             // `Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n             encoder.encode_tagged(\n@@ -324,6 +396,7 @@ impl<'sess> OnDiskCache<'sess> {\n                     interpret_alloc_index,\n                     syntax_contexts,\n                     expn_data: expn_ids,\n+                    foreign_def_path_hashes,\n                 },\n             )?;\n \n@@ -374,6 +447,31 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_assert!(prev.is_none());\n     }\n \n+    fn get_raw_def_id(&self, hash: &DefPathHash) -> Option<RawDefId> {\n+        self.foreign_def_path_hashes.get(hash).copied()\n+    }\n+\n+    fn try_remap_cnum(&self, tcx: TyCtxt<'_>, cnum: u32) -> Option<CrateNum> {\n+        let cnum_map =\n+            self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n+\n+        cnum_map[CrateNum::from_u32(cnum)]\n+    }\n+\n+    pub(crate) fn store_foreign_def_id_hash(&self, def_id: DefId, hash: DefPathHash) {\n+        // We may overwrite an existing entry, but it will have the same value,\n+        // so it's fine\n+        self.latest_foreign_def_path_hashes\n+            .lock()\n+            .insert(hash, RawDefId { krate: def_id.krate.as_u32(), index: def_id.index.as_u32() });\n+    }\n+\n+    pub fn register_reused_dep_path_hash(&self, hash: DefPathHash) {\n+        if let Some(old_id) = self.foreign_def_path_hashes.get(&hash) {\n+            self.latest_foreign_def_path_hashes.lock().insert(hash, *old_id);\n+        }\n+    }\n+\n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     crate fn try_load_query_result<'tcx, T>(\n@@ -481,6 +579,53 @@ impl<'sess> OnDiskCache<'sess> {\n             map\n         })\n     }\n+\n+    /// Converts a `DefPathHash` to its corresponding `DefId` in the current compilation\n+    /// session, if it still exists. This is used during incremental compilation to\n+    /// turn a deserialized `DefPathHash` into its current `DefId`.\n+    pub(crate) fn def_path_hash_to_def_id(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        hash: DefPathHash,\n+    ) -> Option<DefId> {\n+        let mut cache = self.def_path_hash_to_def_id_cache.lock();\n+        match cache.entry(hash) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => {\n+                // Check if the `DefPathHash` corresponds to a definition in the current\n+                // crate\n+                if let Some(def_id) = self.local_def_path_hash_to_def_id.get(&hash).cloned() {\n+                    let def_id = def_id.to_def_id();\n+                    e.insert(Some(def_id));\n+                    return Some(def_id);\n+                }\n+                // This `raw_def_id` represents the `DefId` of this `DefPathHash` in\n+                // the *previous* compliation session. The `DefPathHash` includes the\n+                // owning crate, so if the corresponding definition still exists in the\n+                // current compilation session, the crate is guaranteed to be the same\n+                // (otherwise, we would compute a different `DefPathHash`).\n+                let raw_def_id = self.get_raw_def_id(&hash)?;\n+                // If the owning crate no longer exists, the corresponding definition definitely\n+                // no longer exists.\n+                let krate = self.try_remap_cnum(tcx, raw_def_id.krate)?;\n+                // If our `DefPathHash` corresponded to a definition in the local crate,\n+                // we should have either found it in `local_def_path_hash_to_def_id`, or\n+                // never attempted to load it in the first place. Any query result or `DepNode`\n+                // that references a local `DefId` should depend on some HIR-related `DepNode`.\n+                // If a local definition is removed/modified such that its old `DefPathHash`\n+                // no longer has a corresponding definition, that HIR-related `DepNode` should\n+                // end up red. This should prevent us from ever calling\n+                // `tcx.def_path_hash_to_def_id`, since we'll end up recomputing any\n+                // queries involved.\n+                debug_assert_ne!(krate, LOCAL_CRATE);\n+                // Try to find a definition in the current session, using the previous `DefIndex`\n+                // as an initial guess.\n+                let opt_def_id = tcx.cstore.def_path_hash_to_def_id(krate, raw_def_id.index, hash);\n+                e.insert(opt_def_id);\n+                opt_def_id\n+            }\n+        }\n+    }\n }\n \n //- DECODING -------------------------------------------------------------------\n@@ -713,7 +858,17 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n         let def_path_hash = DefPathHash::decode(d)?;\n \n         // Using the `DefPathHash`, we can lookup the new `DefId`.\n-        Ok(d.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n+        // Subtle: We only encode a `DefId` as part of a query result.\n+        // If we get to this point, then all of the query inputs were green,\n+        // which means that the definition with this hash is guaranteed to\n+        // still exist in the current compilation session.\n+        Ok(d.tcx()\n+            .queries\n+            .on_disk_cache\n+            .as_ref()\n+            .unwrap()\n+            .def_path_hash_to_def_id(d.tcx(), def_path_hash)\n+            .unwrap())\n     }\n }\n \n@@ -773,6 +928,7 @@ struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     source_map: CachingSourceMapView<'tcx>,\n     file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n     hygiene_context: &'a HygieneEncodeContext,\n+    latest_foreign_def_path_hashes: FxHashMap<DefPathHash, RawDefId>,\n }\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n@@ -895,6 +1051,15 @@ where\n {\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n         let def_path_hash = s.tcx.def_path_hash(*self);\n+        // Store additional information when we encode a foreign `DefId`,\n+        // so that we can map its `DefPathHash` back to a `DefId` in the next\n+        // compilation session.\n+        if !self.is_local() {\n+            s.latest_foreign_def_path_hashes.insert(\n+                def_path_hash,\n+                RawDefId { krate: self.krate.as_u32(), index: self.index.as_u32() },\n+            );\n+        }\n         def_path_hash.encode(s)\n     }\n }"}, {"sha": "ac37b296b533bcec11777f47dfa8330c8dcf64dd", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_span::def_id::DefPathHash;\n \n use parking_lot::{Condvar, Mutex};\n use smallvec::{smallvec, SmallVec};\n@@ -699,6 +700,18 @@ impl<K: DepKind> DepGraph<K> {\n             data.current.intern_node(*dep_node, current_deps, fingerprint)\n         };\n \n+        // We have just loaded a deserialized `DepNode` from the previous\n+        // compilation session into the current one. If this was a foreign `DefId`,\n+        // then we stored additional information in the incr comp cache when we\n+        // initially created its fingerprint (see `DepNodeParams::to_fingerprint`)\n+        // We won't be calling `to_fingerprint` again for this `DepNode` (we no longer\n+        // have the original value), so we need to copy over this additional information\n+        // from the old incremental cache into the new cache that we serialize\n+        // and the end of this compilation session.\n+        if dep_node.kind.can_reconstruct_query_key() {\n+            tcx.register_reused_dep_path_hash(DefPathHash(dep_node.hash.into()));\n+        }\n+\n         // ... emitting any stored diagnostic ...\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere"}, {"sha": "3b4b62ad6be88982f9320efeabc800de2ff8732d", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbda829c00af2c3ac362c979fa97ea90be0be7d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=4cbda829c00af2c3ac362c979fa97ea90be0be7d", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n+use rustc_span::def_id::DefPathHash;\n \n use std::fmt;\n use std::hash::Hash;\n@@ -32,6 +33,8 @@ pub trait DepContext: Copy {\n     /// Try to force a dep node to execute and see if it's green.\n     fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n \n+    fn register_reused_dep_path_hash(&self, hash: DefPathHash);\n+\n     /// Return whether the current session is tainted by errors.\n     fn has_errors_or_delayed_span_bugs(&self) -> bool;\n "}]}