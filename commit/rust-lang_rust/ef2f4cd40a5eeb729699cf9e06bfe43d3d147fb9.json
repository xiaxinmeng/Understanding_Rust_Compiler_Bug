{"sha": "ef2f4cd40a5eeb729699cf9e06bfe43d3d147fb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMmY0Y2Q0MGE1ZWViNzI5Njk5Y2Y5ZTA2YmZlNDNkM2QxNDdmYjk=", "commit": {"author": {"name": "Tshepang Lekhonkhobe", "email": "tshepang@gmail.com", "date": "2015-07-17T19:28:25Z"}, "committer": {"name": "Tshepang Lekhonkhobe", "email": "tshepang@gmail.com", "date": "2015-07-19T06:33:03Z"}, "message": "doc: use 'index' and 'value' in place of 'i' and 't'", "tree": {"sha": "3b49abeb8c9efa5d91fb5cff18e97da800c129f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b49abeb8c9efa5d91fb5cff18e97da800c129f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef2f4cd40a5eeb729699cf9e06bfe43d3d147fb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef2f4cd40a5eeb729699cf9e06bfe43d3d147fb9", "html_url": "https://github.com/rust-lang/rust/commit/ef2f4cd40a5eeb729699cf9e06bfe43d3d147fb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef2f4cd40a5eeb729699cf9e06bfe43d3d147fb9/comments", "author": {"login": "tshepang", "id": 588486, "node_id": "MDQ6VXNlcjU4ODQ4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/588486?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tshepang", "html_url": "https://github.com/tshepang", "followers_url": "https://api.github.com/users/tshepang/followers", "following_url": "https://api.github.com/users/tshepang/following{/other_user}", "gists_url": "https://api.github.com/users/tshepang/gists{/gist_id}", "starred_url": "https://api.github.com/users/tshepang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tshepang/subscriptions", "organizations_url": "https://api.github.com/users/tshepang/orgs", "repos_url": "https://api.github.com/users/tshepang/repos", "events_url": "https://api.github.com/users/tshepang/events{/privacy}", "received_events_url": "https://api.github.com/users/tshepang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tshepang", "id": 588486, "node_id": "MDQ6VXNlcjU4ODQ4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/588486?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tshepang", "html_url": "https://github.com/tshepang", "followers_url": "https://api.github.com/users/tshepang/followers", "following_url": "https://api.github.com/users/tshepang/following{/other_user}", "gists_url": "https://api.github.com/users/tshepang/gists{/gist_id}", "starred_url": "https://api.github.com/users/tshepang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tshepang/subscriptions", "organizations_url": "https://api.github.com/users/tshepang/orgs", "repos_url": "https://api.github.com/users/tshepang/repos", "events_url": "https://api.github.com/users/tshepang/events{/privacy}", "received_events_url": "https://api.github.com/users/tshepang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d460c5517799d484a8ed71e03a1a680d74d1de9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d460c5517799d484a8ed71e03a1a680d74d1de9", "html_url": "https://github.com/rust-lang/rust/commit/9d460c5517799d484a8ed71e03a1a680d74d1de9"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "7bdc10cfb64fa83c9a8b15b14d85197818b63a55", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ef2f4cd40a5eeb729699cf9e06bfe43d3d147fb9/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2f4cd40a5eeb729699cf9e06bfe43d3d147fb9/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=ef2f4cd40a5eeb729699cf9e06bfe43d3d147fb9", "patch": "@@ -108,8 +108,8 @@ impl<T> VecDeque<T> {\n \n     /// Writes an element into the buffer, moving it.\n     #[inline]\n-    unsafe fn buffer_write(&mut self, off: usize, t: T) {\n-        ptr::write(self.ptr().offset(off as isize), t);\n+    unsafe fn buffer_write(&mut self, off: usize, value: T) {\n+        ptr::write(self.ptr().offset(off as isize), value);\n     }\n \n     /// Returns true if and only if the buffer is at capacity\n@@ -234,9 +234,9 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, i: usize) -> Option<&T> {\n-        if i < self.len() {\n-            let idx = self.wrap_add(self.tail, i);\n+    pub fn get(&self, index: usize) -> Option<&T> {\n+        if index < self.len() {\n+            let idx = self.wrap_add(self.tail, index);\n             unsafe { Some(&*self.ptr().offset(idx as isize)) }\n         } else {\n             None\n@@ -261,9 +261,9 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf[1], 7);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self, i: usize) -> Option<&mut T> {\n-        if i < self.len() {\n-            let idx = self.wrap_add(self.tail, i);\n+    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n+        if index < self.len() {\n+            let idx = self.wrap_add(self.tail, index);\n             unsafe { Some(&mut *self.ptr().offset(idx as isize)) }\n         } else {\n             None\n@@ -768,7 +768,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(d.front(), Some(&2));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push_front(&mut self, t: T) {\n+    pub fn push_front(&mut self, value: T) {\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n@@ -778,7 +778,7 @@ impl<T> VecDeque<T> {\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n-        unsafe { self.buffer_write(tail, t); }\n+        unsafe { self.buffer_write(tail, value); }\n     }\n \n     /// Appends an element to the back of a buffer\n@@ -794,7 +794,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push_back(&mut self, t: T) {\n+    pub fn push_back(&mut self, value: T) {\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n@@ -804,7 +804,7 @@ impl<T> VecDeque<T> {\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n-        unsafe { self.buffer_write(head, t) }\n+        unsafe { self.buffer_write(head, value) }\n     }\n \n     /// Removes the last element from a buffer and returns it, or `None` if\n@@ -905,13 +905,13 @@ impl<T> VecDeque<T> {\n         self.pop_front()\n     }\n \n-    /// Inserts an element at position `i` within the `VecDeque`. Whichever\n+    /// Inserts an element at `index` within the `VecDeque`. Whichever\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `i` is greater than `VecDeque`'s length\n+    /// Panics if `index` is greater than `VecDeque`'s length\n     ///\n     /// # Examples\n     /// ```\n@@ -924,8 +924,8 @@ impl<T> VecDeque<T> {\n     /// buf.insert(1, 11);\n     /// assert_eq!(Some(&11), buf.get(1));\n     /// ```\n-    pub fn insert(&mut self, i: usize, t: T) {\n-        assert!(i <= self.len(), \"index out of bounds\");\n+    pub fn insert(&mut self, index: usize, value: T) {\n+        assert!(index <= self.len(), \"index out of bounds\");\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n@@ -955,15 +955,15 @@ impl<T> VecDeque<T> {\n         //      A - The element that should be after the insertion point\n         //      M - Indicates element was moved\n \n-        let idx = self.wrap_add(self.tail, i);\n+        let idx = self.wrap_add(self.tail, index);\n \n-        let distance_to_tail = i;\n-        let distance_to_head = self.len() - i;\n+        let distance_to_tail = index;\n+        let distance_to_head = self.len() - index;\n \n         let contiguous = self.is_contiguous();\n \n         match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n-            (true, true, _) if i == 0 => {\n+            (true, true, _) if index == 0 => {\n                 // push_front\n                 //\n                 //       T\n@@ -999,8 +999,8 @@ impl<T> VecDeque<T> {\n                 let new_tail = self.wrap_sub(self.tail, 1);\n \n                 self.copy(new_tail, self.tail, 1);\n-                // Already moved the tail, so we only copy `i - 1` elements.\n-                self.copy(self.tail, self.tail + 1, i - 1);\n+                // Already moved the tail, so we only copy `index - 1` elements.\n+                self.copy(self.tail, self.tail + 1, index - 1);\n \n                 self.tail = new_tail;\n             },\n@@ -1027,7 +1027,7 @@ impl<T> VecDeque<T> {\n                 //      [o o o o o o . . . . o o I A o o]\n                 //                           M M\n \n-                self.copy(self.tail - 1, self.tail, i);\n+                self.copy(self.tail - 1, self.tail, index);\n                 self.tail -= 1;\n             },\n             (false, false, true) => unsafe {\n@@ -1107,16 +1107,16 @@ impl<T> VecDeque<T> {\n         }\n \n         // tail might've been changed so we need to recalculate\n-        let new_idx = self.wrap_add(self.tail, i);\n+        let new_idx = self.wrap_add(self.tail, index);\n         unsafe {\n-            self.buffer_write(new_idx, t);\n+            self.buffer_write(new_idx, value);\n         }\n     }\n \n-    /// Removes and returns the element at position `i` from the `VecDeque`.\n+    /// Removes and returns the element at `index` from the `VecDeque`.\n     /// Whichever end is closer to the removal point will be moved to make\n     /// room, and all the affected elements will be moved to new positions.\n-    /// Returns `None` if `i` is out of bounds.\n+    /// Returns `None` if `index` is out of bounds.\n     ///\n     /// # Examples\n     /// ```\n@@ -1131,8 +1131,8 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, i: usize) -> Option<T> {\n-        if self.is_empty() || self.len() <= i {\n+    pub fn remove(&mut self, index: usize) -> Option<T> {\n+        if self.is_empty() || self.len() <= index {\n             return None;\n         }\n \n@@ -1154,14 +1154,14 @@ impl<T> VecDeque<T> {\n         //      R - Indicates element that is being removed\n         //      M - Indicates element was moved\n \n-        let idx = self.wrap_add(self.tail, i);\n+        let idx = self.wrap_add(self.tail, index);\n \n         let elem = unsafe {\n             Some(self.buffer_read(idx))\n         };\n \n-        let distance_to_tail = i;\n-        let distance_to_head = self.len() - i;\n+        let distance_to_tail = index;\n+        let distance_to_head = self.len() - index;\n \n         let contiguous = self.is_contiguous();\n \n@@ -1176,7 +1176,7 @@ impl<T> VecDeque<T> {\n                 //      [. . . . o o o o o o . . . . . .]\n                 //               M M\n \n-                self.copy(self.tail + 1, self.tail, i);\n+                self.copy(self.tail + 1, self.tail, index);\n                 self.tail += 1;\n             },\n             (true, false, _) => unsafe {\n@@ -1202,7 +1202,7 @@ impl<T> VecDeque<T> {\n                 //      [o o o o o o . . . . . . o o o o]\n                 //                               M M\n \n-                self.copy(self.tail + 1, self.tail, i);\n+                self.copy(self.tail + 1, self.tail, index);\n                 self.tail = self.wrap_add(self.tail, 1);\n             },\n             (false, false, false) => unsafe {\n@@ -1700,16 +1700,16 @@ impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n     #[inline]\n-    fn index(&self, i: usize) -> &A {\n-        self.get(i).expect(\"Out of bounds access\")\n+    fn index(&self, index: usize) -> &A {\n+        self.get(index).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<usize> for VecDeque<A> {\n     #[inline]\n-    fn index_mut(&mut self, i: usize) -> &mut A {\n-        self.get_mut(i).expect(\"Out of bounds access\")\n+    fn index_mut(&mut self, index: usize) -> &mut A {\n+        self.get_mut(index).expect(\"Out of bounds access\")\n     }\n }\n "}]}