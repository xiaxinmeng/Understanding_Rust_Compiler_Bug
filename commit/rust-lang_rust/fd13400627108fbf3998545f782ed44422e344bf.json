{"sha": "fd13400627108fbf3998545f782ed44422e344bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMTM0MDA2MjcxMDhmYmYzOTk4NTQ1Zjc4MmVkNDQ0MjJlMzQ0YmY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:09:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:09:05Z"}, "message": "rollup merge of #23538: aturon/conversion\n\nConflicts:\n\tsrc/librustc_back/rpath.rs", "tree": {"sha": "209af0ca5850ae4c2add0da4b278fa908032be63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/209af0ca5850ae4c2add0da4b278fa908032be63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd13400627108fbf3998545f782ed44422e344bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd13400627108fbf3998545f782ed44422e344bf", "html_url": "https://github.com/rust-lang/rust/commit/fd13400627108fbf3998545f782ed44422e344bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd13400627108fbf3998545f782ed44422e344bf/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c77af69a3793bc0c3c49b05ceffb15dccf5ed4d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c77af69a3793bc0c3c49b05ceffb15dccf5ed4d0", "html_url": "https://github.com/rust-lang/rust/commit/c77af69a3793bc0c3c49b05ceffb15dccf5ed4d0"}, {"sha": "8389253df0431e58bfe0a8e0e3949d58ebe7400f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8389253df0431e58bfe0a8e0e3949d58ebe7400f", "html_url": "https://github.com/rust-lang/rust/commit/8389253df0431e58bfe0a8e0e3949d58ebe7400f"}], "stats": {"total": 860, "additions": 665, "deletions": 195}, "files": [{"sha": "1ee5917ac9c91b7dbdc734d4f114ed9b2dea7454", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -20,6 +20,8 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(path_ext)]\n+#![feature(convert)]\n+#![feature(str_char)]\n \n #![deny(warnings)]\n \n@@ -115,7 +117,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> PathBuf {\n         match m.opt_str(nm) {\n-            Some(s) => PathBuf::new(&s),\n+            Some(s) => PathBuf::from(&s),\n             None => panic!(\"no option (=path) found for {}\", nm),\n         }\n     }\n@@ -130,18 +132,18 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: matches.opt_str(\"clang-path\").map(|s| PathBuf::new(&s)),\n+        clang_path: matches.opt_str(\"clang-path\").map(|s| PathBuf::from(&s)),\n         valgrind_path: matches.opt_str(\"valgrind-path\"),\n         force_valgrind: matches.opt_present(\"force-valgrind\"),\n-        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| PathBuf::new(&s)),\n+        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| PathBuf::from(&s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n         mode: matches.opt_str(\"mode\").unwrap().parse().ok().expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n-        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::new(&s)),\n+        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s)),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),"}, {"sha": "e1ad66c69e44a27d72d525b9089751c366b6d6a9", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -328,10 +328,10 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<PathBuf> {\n     match parse_name_value_directive(line, \"pp-exact\") {\n-      Some(s) => Some(PathBuf::new(&s)),\n+      Some(s) => Some(PathBuf::from(&s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n-            testfile.file_name().map(|s| PathBuf::new(s))\n+            testfile.file_name().map(|s| PathBuf::from(s))\n         } else {\n             None\n         }"}, {"sha": "319248cb8107d60ca3c18e59cf4f9eae31648285", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -1440,7 +1440,7 @@ fn aux_output_dir_name(config: &Config, testfile: &Path) -> PathBuf {\n }\n \n fn output_testname(testfile: &Path) -> PathBuf {\n-    PathBuf::new(testfile.file_stem().unwrap())\n+    PathBuf::from(testfile.file_stem().unwrap())\n }\n \n fn output_base_name(config: &Config, testfile: &Path) -> PathBuf {"}, {"sha": "88d59f699d183030c7c2f665ee3ecd2bd813813a", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -14,6 +14,7 @@\n \n use core::clone::Clone;\n use core::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use core::convert::AsRef;\n use core::hash::{Hash, Hasher};\n use core::marker::Sized;\n use core::ops::Deref;\n@@ -291,10 +292,9 @@ impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n }\n \n /// Trait for moving into a `Cow`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\")]\n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     /// Moves `self` into `Cow`\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_cow(self) -> Cow<'a, B>;\n }\n \n@@ -304,3 +304,10 @@ impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n         self\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: Clone> AsRef<T> for Cow<'a, T> {\n+    fn as_ref(&self) -> &T {\n+        self\n+    }\n+}"}, {"sha": "156c90f1e84012e552f4754453b1c2d81dcf5c6d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -36,6 +36,7 @@\n #![feature(unsafe_no_drop_flag)]\n #![feature(step_by)]\n #![feature(str_char)]\n+#![feature(convert)]\n #![cfg_attr(test, feature(rand, rustc_private, test))]\n #![cfg_attr(test, allow(deprecated))] // rand\n "}, {"sha": "0a0307aef322e093dbd8b4ad7491edec6a085770", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -88,6 +88,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n+use core::convert::AsRef;\n use core::clone::Clone;\n use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n@@ -1088,23 +1089,23 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n     fn connect(&self, sep: &T) -> U;\n }\n \n-impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n+impl<T: Clone, V: AsRef<[T]>> SliceConcatExt<T, Vec<T>> for [V] {\n     fn concat(&self) -> Vec<T> {\n-        let size = self.iter().fold(0, |acc, v| acc + v.as_slice().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.as_ref().len());\n         let mut result = Vec::with_capacity(size);\n         for v in self {\n-            result.push_all(v.as_slice())\n+            result.push_all(v.as_ref())\n         }\n         result\n     }\n \n     fn connect(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0, |acc, v| acc + v.as_slice().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.as_ref().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self {\n             if first { first = false } else { result.push(sep.clone()) }\n-            result.push_all(v.as_slice())\n+            result.push_all(v.as_ref())\n         }\n         result\n     }"}, {"sha": "ebd55aa7ce7048ee95b441a08250720e43775a6c", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -61,10 +61,10 @@ use core::iter::AdditiveIterator;\n use core::iter::{Iterator, IteratorExt, Extend};\n use core::option::Option::{self, Some, None};\n use core::result::Result;\n-use core::slice::AsSlice;\n use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n+use core::convert::AsRef;\n use vec_deque::VecDeque;\n use borrow::{Borrow, ToOwned};\n use string::String;\n@@ -86,51 +86,47 @@ pub use core::str::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n Section: Creating a string\n */\n \n-impl<S: Str> SliceConcatExt<str, String> for [S] {\n+impl<S: AsRef<str>> SliceConcatExt<str, String> for [S] {\n     fn concat(&self) -> String {\n-        let s = self.as_slice();\n-\n-        if s.is_empty() {\n+        if self.is_empty() {\n             return String::new();\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = s.iter().map(|s| s.as_slice().len()).sum();\n+        let len = self.iter().map(|s| s.as_ref().len()).sum();\n         let mut result = String::with_capacity(len);\n \n-        for s in s {\n-            result.push_str(s.as_slice())\n+        for s in self {\n+            result.push_str(s.as_ref())\n         }\n \n         result\n     }\n \n     fn connect(&self, sep: &str) -> String {\n-        let s = self.as_slice();\n-\n-        if s.is_empty() {\n+        if self.is_empty() {\n             return String::new();\n         }\n \n         // concat is faster\n         if sep.is_empty() {\n-            return s.concat();\n+            return self.concat();\n         }\n \n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (s.len() - 1)\n-            + s.iter().map(|s| s.as_slice().len()).sum();\n+        let len = sep.len() * (self.len() - 1)\n+            + self.iter().map(|s| s.as_ref().len()).sum();\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n-        for s in s {\n+        for s in self {\n             if first {\n                 first = false;\n             } else {\n                 result.push_str(sep);\n             }\n-            result.push_str(s.as_slice());\n+            result.push_str(s.as_ref());\n         }\n         result\n     }"}, {"sha": "6463949ac8aae60707d1ac3965d07fc4f5d6134a", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -814,6 +814,7 @@ impl<'a, 'b> PartialEq<Cow<'a, str>> for &'b str {\n }\n \n #[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n+#[allow(deprecated)]\n impl Str for String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -973,6 +974,27 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for String {\n+    fn from(s: &'a str) -> String {\n+        s.to_string()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Into<Vec<u8>> for String {\n+    fn into(self) -> Vec<u8> {\n+        self.into_bytes()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl IntoCow<'static, str> for String {\n     #[inline]\n@@ -989,6 +1011,7 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'a> Str for Cow<'a, str> {\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {"}, {"sha": "85833c34049fe9dd5ad52de8deca059b6f7956d2", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -1369,7 +1369,7 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, _index: &ops::RangeFull) -> &[T] {\n-        self.as_slice()\n+        self\n     }\n }\n \n@@ -1406,7 +1406,13 @@ impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n-    fn deref(&self) -> &[T] { self.as_slice() }\n+    fn deref(&self) -> &[T] {\n+        unsafe {\n+            let p = *self.ptr;\n+            assume(p != 0 as *mut T);\n+            slice::from_raw_parts(p, self.len)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1548,6 +1554,7 @@ impl<T: Ord> Ord for Vec<T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<T> AsSlice<T> for Vec<T> {\n     /// Returns a slice into `self`.\n     ///\n@@ -1562,11 +1569,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice(&self) -> &[T] {\n-        unsafe {\n-            let p = *self.ptr;\n-            assume(p != 0 as *mut T);\n-            slice::from_raw_parts(p, self.len)\n-        }\n+        self\n     }\n }\n \n@@ -1614,6 +1617,41 @@ impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> AsRef<Vec<T>> for Vec<T> {\n+    fn as_ref(&self) -> &Vec<T> {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Into<Vec<T>> for Vec<T> {\n+    fn into(self) -> Vec<T> {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> AsRef<[T]> for Vec<T> {\n+    fn as_ref(&self) -> &[T] {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n+    fn from(s: &'a [T]) -> Vec<T> {\n+        s.to_vec()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for Vec<u8> {\n+    fn from(s: &'a str) -> Vec<u8> {\n+        s.as_bytes().to_vec()\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "65a226d37cbc038c80f38c3ef532bc66a2c27ac6", "filename": "src/libcore/convert.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Traits for conversions between types.\n+//!\n+//! The traits in this module provide a general way to talk about\n+//! conversions from one type to another. They follow the standard\n+//! Rust conventions of `as`/`to`/`into`/`from`.\n+\n+#![unstable(feature = \"convert\",\n+            reason = \"recently added, experimental traits\")]\n+\n+use marker::Sized;\n+\n+/// A cheap, reference-to-reference conversion.\n+pub trait AsRef<T: ?Sized> {\n+    /// Perform the conversion.\n+    fn as_ref(&self) -> &T;\n+}\n+\n+/// A cheap, mutable reference-to-mutable reference conversion.\n+pub trait AsMut<T: ?Sized> {\n+    /// Perform the conversion.\n+    fn as_mut(&mut self) -> &mut T;\n+}\n+\n+/// A conversion that consumes `self`, which may or may not be\n+/// expensive.\n+pub trait Into<T>: Sized {\n+    /// Perform the conversion.\n+    fn into(self) -> T;\n+}\n+\n+/// Construct `Self` via a conversion.\n+pub trait From<T> {\n+    /// Perform the conversion.\n+    fn from(T) -> Self;\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// GENERIC IMPLS\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// As implies Into\n+impl<'a, T: ?Sized, U: ?Sized> Into<&'a U> for &'a T where T: AsRef<U> {\n+    fn into(self) -> &'a U {\n+        self.as_ref()\n+    }\n+}\n+\n+// As lifts over &\n+impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U> {\n+    fn as_ref(&self) -> &U {\n+        <T as AsRef<U>>::as_ref(*self)\n+    }\n+}\n+\n+// As lifts over &mut\n+impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> {\n+    fn as_ref(&self) -> &U {\n+        <T as AsRef<U>>::as_ref(*self)\n+    }\n+}\n+\n+// AsMut implies Into\n+impl<'a, T: ?Sized, U: ?Sized> Into<&'a mut U> for &'a mut T where T: AsMut<U> {\n+    fn into(self) -> &'a mut U {\n+        (*self).as_mut()\n+    }\n+}\n+\n+// AsMut lifts over &mut\n+impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> {\n+    fn as_mut(&mut self) -> &mut U {\n+        (*self).as_mut()\n+    }\n+}\n+\n+// From implies Into\n+impl<T, U> Into<U> for T where U: From<T> {\n+    fn into(self) -> U {\n+        U::from(self)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// CONCRETE IMPLS\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl<T> AsRef<[T]> for [T] {\n+    fn as_ref(&self) -> &[T] {\n+        self\n+    }\n+}\n+\n+impl<T> AsMut<[T]> for [T] {\n+    fn as_mut(&mut self) -> &mut [T] {\n+        self\n+    }\n+}\n+\n+impl AsRef<str> for str {\n+    fn as_ref(&self) -> &str {\n+        self\n+    }\n+}"}, {"sha": "e31542c183a69122a65c3b8d0caa9e2c1179159d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -125,6 +125,7 @@ pub mod ops;\n pub mod cmp;\n pub mod clone;\n pub mod default;\n+pub mod convert;\n \n /* Core types and methods on primitives */\n "}, {"sha": "4a1e24c1f406d03b72d0f96f189ce518269c45ba", "filename": "src/libcore/option.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -154,6 +154,7 @@ use mem;\n use ops::{Deref, FnOnce};\n use result::Result::{Ok, Err};\n use result::Result;\n+#[allow(deprecated)]\n use slice::AsSlice;\n use slice;\n \n@@ -701,6 +702,19 @@ impl<T> Option<T> {\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n+\n+    /// Convert from `Option<T>` to `&[T]` (without copying)\n+    #[inline]\n+    #[unstable(feature = \"as_slice\", since = \"unsure of the utility here\")]\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        match *self {\n+            Some(ref x) => slice::ref_slice(x),\n+            None => {\n+                let result: &[_] = &[];\n+                result\n+            }\n+        }\n+    }\n }\n \n impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n@@ -752,6 +766,9 @@ impl<T: Default> Option<T> {\n \n #[unstable(feature = \"core\",\n            reason = \"waiting on the stability of the trait itself\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use the inherent method instead\")]\n+#[allow(deprecated)]\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]"}, {"sha": "424829939b92e89fbea8898bdcb7b71ff09dba54", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -36,6 +36,7 @@ pub use mem::drop;\n pub use char::CharExt;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+pub use convert::{AsRef, AsMut, Into, From};\n pub use iter::{Extend, IteratorExt};\n pub use iter::{Iterator, DoubleEndedIterator};\n pub use iter::{ExactSizeIterator};"}, {"sha": "4b3cda46c1df3c84e3a0e13406946d3917d43dc6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -240,6 +240,7 @@ use iter::{Iterator, IteratorExt, DoubleEndedIterator,\n            FromIterator, ExactSizeIterator, IntoIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n+#[allow(deprecated)]\n use slice::AsSlice;\n use slice;\n \n@@ -408,6 +409,20 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n+    /// Convert from `Result<T, E>` to `&[T]` (without copying)\n+    #[inline]\n+    #[unstable(feature = \"as_slice\", since = \"unsure of the utility here\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        match *self {\n+            Ok(ref x) => slice::ref_slice(x),\n+            Err(_) => {\n+                // work around lack of implicit coercion from fixed-size array to slice\n+                let emp: &[_] = &[];\n+                emp\n+            }\n+        }\n+    }\n+\n     /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n     ///\n     /// ```\n@@ -788,10 +803,14 @@ impl<T: fmt::Debug, E> Result<T, E> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n+#[unstable(feature = \"core\",\n+           reason = \"waiting on the stability of the trait itself\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use inherent method instead\")]\n+#[allow(deprecated)]\n impl<T, E> AsSlice<T> for Result<T, E> {\n     /// Convert from `Result<T, E>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Ok(ref x) => slice::ref_slice(x),"}, {"sha": "e7535ae1d17b6090f6a8dc2aea28502d5e56dbf8", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -596,24 +596,29 @@ impl<T> ops::IndexMut<RangeFull> for [T] {\n /// Data that is viewable as a slice.\n #[unstable(feature = \"core\",\n            reason = \"will be replaced by slice syntax\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use std::convert::AsRef<[T]> instead\")]\n pub trait AsSlice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }"}, {"sha": "fe75b76dc113ad9d4ff6e93c59c079ec3c3f0f9e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -1364,16 +1364,20 @@ mod traits {\n            reason = \"Instead of taking this bound generically, this trait will be \\\n                      replaced with one of slicing syntax (&foo[..]), deref coercions, or \\\n                      a more generic conversion trait\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use std::convert::AsRef<str> instead\")]\n pub trait Str {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n }\n \n+#[allow(deprecated)]\n impl Str for str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { self }\n }\n \n+#[allow(deprecated)]\n impl<'a, S: ?Sized> Str for &'a S where S: Str {\n     #[inline]\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }"}, {"sha": "6d95d5e07247c1f07209cb55a1da6e00e92d2b98", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -280,6 +280,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(int_uint)]\n #![feature(collections)]\n+#![feature(into_cow)]\n \n use self::LabelText::*;\n "}, {"sha": "793eff6a9da6fc9763c02e68a72ee7ccecd5a5f6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -43,6 +43,8 @@\n #![feature(path_ext)]\n #![feature(str_words)]\n #![feature(str_char)]\n+#![feature(convert)]\n+#![feature(into_cow)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "dc9d1e11e8e9c595db9a09230f4854f7d14d8419", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -243,7 +243,7 @@ impl crate_metadata {\n impl MetadataBlob {\n     pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n         let slice = match *self {\n-            MetadataVec(ref vec) => vec.as_slice(),\n+            MetadataVec(ref vec) => &vec[..],\n             MetadataArchive(ref ar) => ar.as_slice(),\n         };\n         if slice.len() < 4 {"}, {"sha": "284e76b328a6912323692c82f0f6180e8f29f97e", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -156,7 +156,7 @@ impl<'a> FileSearch<'a> {\n \n     // Returns a list of directories where target-specific tool binaries are located.\n     pub fn get_tools_search_paths(&self) -> Vec<PathBuf> {\n-        let mut p = PathBuf::new(self.sysroot);\n+        let mut p = PathBuf::from(self.sysroot);\n         p.push(&find_libdir(self.sysroot));\n         p.push(&rustlibdir());\n         p.push(&self.triple);\n@@ -166,7 +166,7 @@ impl<'a> FileSearch<'a> {\n }\n \n pub fn relative_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n-    let mut p = PathBuf::new(&find_libdir(sysroot));\n+    let mut p = PathBuf::from(&find_libdir(sysroot));\n     assert!(p.is_relative());\n     p.push(&rustlibdir());\n     p.push(target_triple);\n@@ -224,7 +224,7 @@ pub fn rust_path() -> Vec<PathBuf> {\n         Some(env_path) => {\n             let env_path_components =\n                 env_path.split(PATH_ENTRY_SEPARATOR);\n-            env_path_components.map(|s| PathBuf::new(s)).collect()\n+            env_path_components.map(|s| PathBuf::from(s)).collect()\n         }\n         None => Vec::new()\n     };"}, {"sha": "7854db811466517bbd3f675ab3ac0e80b9edc643", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -628,7 +628,7 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let locs = locs.iter().map(|l| PathBuf::new(&l[..])).filter(|loc| {\n+            let locs = locs.iter().map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display()));"}, {"sha": "882caecb3822ec617698955acf3ef7e2d1b6327a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -1762,7 +1762,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match obligations {\n             Ok(mut obls) => {\n-                obls.push_all(normalized.obligations.as_slice());\n+                obls.push_all(&normalized.obligations);\n                 obls\n             },\n             Err(ErrorReported) => Vec::new()"}, {"sha": "a7c67a0863182e6af468f5e4ba104a01b3c5a50c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -907,7 +907,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let cg = build_codegen_options(matches);\n \n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::new(&m));\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));\n     let target = matches.opt_str(\"target\").unwrap_or(\n         host_triple().to_string());\n     let opt_level = {"}, {"sha": "3dc31f9524effe1e5b32668c7c7d707bbf9ce1fb", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -54,7 +54,7 @@ impl SearchPaths {\n         if path.is_empty() {\n             early_error(\"empty search path given via `-L`\");\n         }\n-        self.paths.push((kind, PathBuf::new(path)));\n+        self.paths.push((kind, PathBuf::from(path)));\n     }\n \n     pub fn iter(&self, kind: PathKind) -> Iter {"}, {"sha": "2cc51a723f2370c96a362fb87b2de0e83ecd18ed", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -319,7 +319,7 @@ impl<'a> ArchiveBuilder<'a> {\n             };\n             let new_filename = self.work_dir.path().join(&filename[..]);\n             try!(fs::rename(&file, &new_filename));\n-            self.members.push(PathBuf::new(&filename));\n+            self.members.push(PathBuf::from(filename));\n         }\n         Ok(())\n     }"}, {"sha": "6d8891dd4fe078f058ed3ed958ede8b891013147", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -19,7 +19,7 @@ use std::path::{Path, PathBuf};\n pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n     let old = old_path::Path::new(original.to_str().unwrap());\n     match old_realpath(&old) {\n-        Ok(p) => Ok(PathBuf::new(p.as_str().unwrap())),\n+        Ok(p) => Ok(PathBuf::from(p.as_str().unwrap())),\n         Err(e) => Err(io::Error::new(io::ErrorKind::Other,\n                                      \"realpath error\",\n                                      Some(e.to_string())))"}, {"sha": "086742f740cdb362e0394a7658a4eb7a5d4cc9ea", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -49,6 +49,7 @@\n #![feature(std_misc)]\n #![feature(path_relative_from)]\n #![feature(step_by)]\n+#![feature(convert)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "c464658f447acd973d1568b93dca9285c59dd21b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -393,11 +393,11 @@ impl Target {\n         let path = {\n             let mut target = target.to_string();\n             target.push_str(\".json\");\n-            PathBuf::new(&target)\n+            PathBuf::from(target)\n         };\n \n         let target_path = env::var_os(\"RUST_TARGET_PATH\")\n-                              .unwrap_or(OsString::from_str(\"\"));\n+                              .unwrap_or(OsString::new());\n \n         // FIXME 16351: add a sane default search path?\n "}, {"sha": "e927ea5b86cdd27bc3416ced57069c96bf3b5e22", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -28,6 +28,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(unsafe_destructor)]\n+#![feature(into_cow)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "4c654cbf27de05fd5bfecd79ba31d0b91a3a857e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -468,7 +468,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             // dependent dlls. Note that this uses cfg!(windows) as opposed to\n             // targ_cfg because syntax extensions are always loaded for the host\n             // compiler, not for the target.\n-            let mut _old_path = OsString::from_str(\"\");\n+            let mut _old_path = OsString::new();\n             if cfg!(windows) {\n                 _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n@@ -752,7 +752,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    let old_path = env::var_os(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n+    let old_path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n     new_path.extend(env::split_paths(&old_path));\n     env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n@@ -927,7 +927,7 @@ pub fn build_output_filenames(input: &Input,\n             // We want to toss everything after the final '.'\n             let dirpath = match *odir {\n                 Some(ref d) => d.clone(),\n-                None => PathBuf::new(\"\")\n+                None => PathBuf::new()\n             };\n \n             // If a crate name is present, we use it as the link name"}, {"sha": "5e6f2fb835bb2a01787ebf36f027bcf5e1a4ed58", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -39,6 +39,7 @@\n #![feature(io)]\n #![feature(set_stdio)]\n #![feature(unicode)]\n+#![feature(convert)]\n \n extern crate arena;\n extern crate flate;\n@@ -163,8 +164,8 @@ pub fn run_compiler<'a>(args: &[String],\n \n // Extract output directory and file from matches.\n fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n-    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::new(&o));\n-    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::new(&o));\n+    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));\n+    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::from(&o));\n     (odir, ofile)\n }\n \n@@ -177,7 +178,7 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n             io::stdin().read_to_string(&mut src).unwrap();\n             Some((Input::Str(src), None))\n         } else {\n-            Some((Input::File(PathBuf::new(ifile)), Some(PathBuf::new(ifile))))\n+            Some((Input::File(PathBuf::from(ifile)), Some(PathBuf::from(ifile))))\n         }\n     } else {\n         None\n@@ -858,9 +859,9 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     use syntax::diagnostics::registry::Registry;\n \n     let all_errors = Vec::new() +\n-        rustc::diagnostics::DIAGNOSTICS.as_slice() +\n-        rustc_typeck::diagnostics::DIAGNOSTICS.as_slice() +\n-        rustc_resolve::diagnostics::DIAGNOSTICS.as_slice();\n+        &rustc::diagnostics::DIAGNOSTICS[..] +\n+        &rustc_typeck::diagnostics::DIAGNOSTICS[..] +\n+        &rustc_resolve::diagnostics::DIAGNOSTICS[..];\n \n     Registry::new(&*all_errors)\n }"}, {"sha": "7958dabe74e42c37aad7c51bc8c4c721f9561bc1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -2056,15 +2056,15 @@ impl LintPass for InvalidNoMangleItems {\n                 }\n             },\n             ast::ItemStatic(..) => {\n-                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") &&\n+                if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n                                       it.ident);\n                     cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);\n                 }\n             },\n             ast::ItemConst(..) => {\n-                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") {\n+                if attr::contains_name(&it.attrs, \"no_mangle\") {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     let msg = \"const items should never be #[no_mangle], consider instead using \\"}, {"sha": "c0a2e24d6f566b2fff3159051836f2a69c54272c", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -877,7 +877,7 @@ fn link_args(cmd: &mut Command,\n         if t.options.is_like_osx {\n             let morestack = lib_path.join(\"libmorestack.a\");\n \n-            let mut v = OsString::from_str(\"-Wl,-force_load,\");\n+            let mut v = OsString::from(\"-Wl,-force_load,\");\n             v.push(&morestack);\n             cmd.arg(&v);\n         } else {\n@@ -1002,7 +1002,7 @@ fn link_args(cmd: &mut Command,\n             cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n \n             if sess.opts.cg.rpath {\n-                let mut v = OsString::from_str(\"-Wl,-install_name,@rpath/\");\n+                let mut v = OsString::from(\"-Wl,-install_name,@rpath/\");\n                 v.push(out_filename.file_name().unwrap());\n                 cmd.arg(&v);\n             }\n@@ -1020,7 +1020,7 @@ fn link_args(cmd: &mut Command,\n         let mut get_install_prefix_lib_path = || {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n-            let mut path = PathBuf::new(install_prefix);\n+            let mut path = PathBuf::from(install_prefix);\n             path.push(&tlib);\n \n             path\n@@ -1102,7 +1102,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                                             &sess.target.target.options.staticlib_suffix,\n                                             &search_path[..],\n                                             &sess.diagnostic().handler);\n-            let mut v = OsString::from_str(\"-Wl,-force_load,\");\n+            let mut v = OsString::from(\"-Wl,-force_load,\");\n             v.push(&lib);\n             cmd.arg(&v);\n         }"}, {"sha": "176e3805a311f3a0865b8b6cb65caba291ba9930", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -41,6 +41,7 @@\n #![feature(path_ext)]\n #![feature(fs)]\n #![feature(hash)]\n+#![feature(convert)]\n #![feature(path_relative_from)]\n \n extern crate arena;"}, {"sha": "765e93f5b8294618d3c9ff3c47aa0873f0fc6461", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -1509,10 +1509,10 @@ pub fn process_crate(sess: &Session,\n \n     // find a path to dump our data to\n     let mut root_path = match env::var_os(\"DXR_RUST_TEMP_FOLDER\") {\n-        Some(val) => PathBuf::new(&val),\n+        Some(val) => PathBuf::from(val),\n         None => match odir {\n             Some(val) => val.join(\"dxr\"),\n-            None => PathBuf::new(\"dxr-temp\"),\n+            None => PathBuf::from(\"dxr-temp\"),\n         },\n     };\n "}, {"sha": "b9c59a0bc78d671f59e3b8a13b74a8b4612f9931", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -1695,7 +1695,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let name = CString::new(name.as_bytes()).unwrap();\n-    match (variable_access, [].as_slice()) {\n+    match (variable_access, &[][..]) {\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {\n             let metadata = unsafe {"}, {"sha": "f1352cacae487cf9627eb0f2d6e1c94c1465aeba", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -690,7 +690,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn as_refsociated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      container: ImplOrTraitItemContainer,\n                                      ident: ast::Ident,\n                                      id: ast::NodeId,\n@@ -835,7 +835,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n-                        convert_associated_type(ccx, ImplContainer(local_def(it.id)),\n+                        as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n                                                 impl_item.ident, impl_item.id, impl_item.vis);\n \n                         let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n@@ -917,7 +917,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 match trait_item.node {\n                     ast::MethodTraitItem(..) => {}\n                     ast::TypeTraitItem(..) => {\n-                        convert_associated_type(ccx, TraitContainer(local_def(it.id)),\n+                        as_refsociated_type(ccx, TraitContainer(local_def(it.id)),\n                                                 trait_item.ident, trait_item.id, ast::Public);\n                     }\n                 }\n@@ -1987,7 +1987,7 @@ fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx>,\n         builtin_bounds,\n         trait_bounds,\n         region_bounds\n-    } = astconv::partition_bounds(tcx, span, ast_bounds.as_slice());\n+    } = astconv::partition_bounds(tcx, span, &ast_bounds);\n \n     let mut projection_bounds = Vec::new();\n "}, {"sha": "8e9408c9ebc48e3d111431fbadab122279935d2a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         let src = match cx.input {\n             Input::File(ref path) => path.clone(),\n-            Input::Str(_) => PathBuf::new(\"\") // FIXME: this is wrong\n+            Input::Str(_) => PathBuf::new() // FIXME: this is wrong\n         };\n \n         Crate {"}, {"sha": "57cb87e1b2d011fb7a4c08147bfc1a491e687f8c", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -47,7 +47,7 @@ pub fn load_string(input: &Path) -> io::Result<Option<String>> {\n macro_rules! load_or_return {\n     ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n         {\n-            let input = PathBuf::new($input);\n+            let input = PathBuf::from(&$input[..]);\n             match ::externalfiles::load_string(&input) {\n                 Err(e) => {\n                     let _ = writeln!(&mut io::stderr(),"}, {"sha": "d9b40fb6ba6ef3d10b11f1a9311362431cece9e8", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -300,7 +300,7 @@ pub fn run(mut krate: clean::Crate,\n            passes: HashSet<String>) -> io::Result<()> {\n     let src_root = match krate.src.parent() {\n         Some(p) => p.to_path_buf(),\n-        None => PathBuf::new(\"\"),\n+        None => PathBuf::new(),\n     };\n     let mut cx = Context {\n         dst: dst,\n@@ -784,7 +784,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n-        let p = PathBuf::new(filename);\n+        let p = PathBuf::from(filename);\n \n         // If we couldn't open this file, then just returns because it\n         // probably means that it's some standard library macro thing and we\n@@ -819,7 +819,7 @@ impl<'a> SourceCollector<'a> {\n         let mut fname = p.file_name().expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n-        cur.push(&fname);\n+        cur.push(&fname[..]);\n         let mut w = BufWriter::new(try!(File::create(&cur)));\n \n         let title = format!(\"{} -- source\", cur.file_name().unwrap()"}, {"sha": "12baa849cc94d10086e6722cea4a362f7ac38398", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -38,6 +38,7 @@\n #![feature(file_path)]\n #![feature(path_ext)]\n #![feature(path_relative_from)]\n+#![feature(convert)]\n \n extern crate arena;\n extern crate getopts;\n@@ -251,7 +252,7 @@ pub fn main_args(args: &[String]) -> int {\n     let should_test = matches.opt_present(\"test\");\n     let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n \n-    let output = matches.opt_str(\"o\").map(|s| PathBuf::new(&s));\n+    let output = matches.opt_str(\"o\").map(|s| PathBuf::from(&s));\n     let cfgs = matches.opt_strs(\"cfg\");\n \n     let external_html = match ExternalHtml::load(\n@@ -271,7 +272,7 @@ pub fn main_args(args: &[String]) -> int {\n             return test::run(input, cfgs, libs, externs, test_args, crate_name)\n         }\n         (false, true) => return markdown::render(input,\n-                                                 output.unwrap_or(PathBuf::new(\"doc\")),\n+                                                 output.unwrap_or(PathBuf::from(\"doc\")),\n                                                  &matches, &external_html,\n                                                  !matches.opt_present(\"markdown-no-toc\")),\n         (false, false) => {}\n@@ -289,15 +290,15 @@ pub fn main_args(args: &[String]) -> int {\n     match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n             match html::render::run(krate, &external_html,\n-                                    output.unwrap_or(PathBuf::new(\"doc\")),\n+                                    output.unwrap_or(PathBuf::from(\"doc\")),\n                                     passes.into_iter().collect()) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to generate documentation: {}\", e),\n             }\n         }\n         Some(\"json\") => {\n             match json_output(krate, json_plugins,\n-                              output.unwrap_or(PathBuf::new(\"doc.json\"))) {\n+                              output.unwrap_or(PathBuf::from(\"doc.json\"))) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to write json: {}\", e),\n             }\n@@ -376,7 +377,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");\n \n-    let cr = PathBuf::new(cratefile);\n+    let cr = PathBuf::from(cratefile);\n     info!(\"starting to run rustc\");\n \n     let (tx, rx) = channel();"}, {"sha": "0b79fa7970dfd745e19a73df778d155cb4804141", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -46,7 +46,7 @@ pub fn run(input: &str,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>)\n            -> int {\n-    let input_path = PathBuf::new(input);\n+    let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n \n     let sessopts = config::Options {"}, {"sha": "f320f723c2ed6286bf6656819729de2c2ba57cdb", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -37,6 +37,7 @@ Core encoding and decoding interfaces.\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(str_char)]\n+#![feature(convert)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "5e9baa9b9e903557236e407db817a01b0790fe3b", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -579,7 +579,7 @@ impl Encodable for path::PathBuf {\n impl Decodable for path::PathBuf {\n     fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> {\n         let bytes: String = try!(Decodable::decode(d));\n-        Ok(path::PathBuf::new(&bytes))\n+        Ok(path::PathBuf::from(bytes))\n     }\n }\n "}, {"sha": "9d6933ce9c89c673d008f103e9bbca800e853280", "filename": "src/libstd/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -23,7 +23,7 @@ use error::Error;\n use ffi::{OsString, AsOsStr};\n use fmt;\n use io;\n-use path::{AsPath, PathBuf};\n+use path::{self, Path, PathBuf};\n use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n use sync::{StaticMutex, MUTEX_INIT};\n use sys::os as os_imp;\n@@ -67,8 +67,8 @@ pub fn current_dir() -> io::Result<PathBuf> {\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn set_current_dir<P: AsPath + ?Sized>(p: &P) -> io::Result<()> {\n-    os_imp::chdir(p.as_path())\n+pub fn set_current_dir<P: AsRef<Path> + ?Sized>(p: &P) -> io::Result<()> {\n+    os_imp::chdir(p.as_ref())\n }\n \n static ENV_LOCK: StaticMutex = MUTEX_INIT;"}, {"sha": "1760445a0fcd4ec7c4693150f734711dc4ec1967", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -10,6 +10,7 @@\n \n #![unstable(feature = \"std_misc\")]\n \n+use convert::Into;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use error::{Error, FromError};\n use fmt;\n@@ -130,6 +131,8 @@ pub struct NulError(usize, Vec<u8>);\n \n /// A conversion trait used by the constructor of `CString` for types that can\n /// be converted to a vector of bytes.\n+#[deprecated(since = \"1.0.0\", reason = \"use std::convert::Into<Vec<u8>> instead\")]\n+#[unstable(feature = \"std_misc\")]\n pub trait IntoBytes {\n     /// Consumes this container, returning a vector of bytes.\n     fn into_bytes(self) -> Vec<u8>;\n@@ -163,8 +166,8 @@ impl CString {\n     /// internal 0 byte. The error returned will contain the bytes as well as\n     /// the position of the nul byte.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new<T: IntoBytes>(t: T) -> Result<CString, NulError> {\n-        let bytes = t.into_bytes();\n+    pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n+        let bytes = t.into();\n         match bytes.iter().position(|x| *x == 0) {\n             Some(i) => Err(NulError(i, bytes)),\n             None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n@@ -433,15 +436,19 @@ pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char)\n     slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n }\n \n+#[allow(deprecated)]\n impl<'a> IntoBytes for &'a str {\n     fn into_bytes(self) -> Vec<u8> { self.as_bytes().to_vec() }\n }\n+#[allow(deprecated)]\n impl<'a> IntoBytes for &'a [u8] {\n     fn into_bytes(self) -> Vec<u8> { self.to_vec() }\n }\n+#[allow(deprecated)]\n impl IntoBytes for String {\n     fn into_bytes(self) -> Vec<u8> { self.into_bytes() }\n }\n+#[allow(deprecated)]\n impl IntoBytes for Vec<u8> {\n     fn into_bytes(self) -> Vec<u8> { self }\n }"}, {"sha": "4d4110466328fbbea152dae0e0998c7651e9c22e", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -63,16 +63,18 @@ pub struct OsStr {\n impl OsString {\n     /// Constructs an `OsString` at no cost by consuming a `String`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `from` instead\")]\n     pub fn from_string(s: String) -> OsString {\n-        OsString { inner: Buf::from_string(s) }\n+        OsString::from(s)\n     }\n \n     /// Constructs an `OsString` by copying from a `&str` slice.\n     ///\n     /// Equivalent to: `OsString::from_string(String::from_str(s))`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `from` instead\")]\n     pub fn from_str(s: &str) -> OsString {\n-        OsString { inner: Buf::from_str(s) }\n+        OsString::from(s)\n     }\n \n     /// Constructs a new empty `OsString`.\n@@ -98,8 +100,36 @@ impl OsString {\n \n     /// Extend the string with the given `&OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push<T: AsOsStr + ?Sized>(&mut self, s: &T) {\n-        self.inner.push_slice(&s.as_os_str().inner)\n+    pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n+        self.inner.push_slice(&s.as_ref().inner)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl From<String> for OsString {\n+    fn from(s: String) -> OsString {\n+        OsString { inner: Buf::from_string(s) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a String> for OsString {\n+    fn from(s: &'a String) -> OsString {\n+        OsString { inner: Buf::from_str(s) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for OsString {\n+    fn from(s: &'a str) -> OsString {\n+        OsString { inner: Buf::from_str(s) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a OsStr> for OsString {\n+    fn from(s: &'a OsStr) -> OsString {\n+        OsString { inner: s.inner.to_owned() }\n     }\n }\n \n@@ -316,37 +346,76 @@ impl ToOwned for OsStr {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl<'a, T: AsOsStr + ?Sized> AsOsStr for &'a T {\n     fn as_os_str(&self) -> &OsStr {\n         (*self).as_os_str()\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for OsStr {\n     fn as_os_str(&self) -> &OsStr {\n         self\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for OsString {\n     fn as_os_str(&self) -> &OsStr {\n         &self[..]\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for str {\n     fn as_os_str(&self) -> &OsStr {\n         OsStr::from_str(self)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for String {\n     fn as_os_str(&self) -> &OsStr {\n         OsStr::from_str(&self[..])\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for OsStr {\n+    fn as_ref(&self) -> &OsStr {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for OsString {\n+    fn as_ref(&self) -> &OsStr {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for str {\n+    fn as_ref(&self) -> &OsStr {\n+        OsStr::from_str(self)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for String {\n+    fn as_ref(&self) -> &OsStr {\n+        OsStr::from_str(&self[..])\n+    }\n+}\n+\n #[allow(deprecated)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for Path {\n     #[cfg(unix)]\n     fn as_os_str(&self) -> &OsStr {"}, {"sha": "ab65004f5d1f9984d7f869857db0f6e4964e21c7", "filename": "src/libstd/fs/mod.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -20,7 +20,7 @@\n use core::prelude::*;\n \n use io::{self, Error, ErrorKind, SeekFrom, Seek, Read, Write};\n-use path::{AsPath, Path, PathBuf};\n+use path::{Path, PathBuf};\n use sys::fs2 as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n use vec::Vec;\n@@ -129,7 +129,7 @@ impl File {\n     /// This function will return an error if `path` does not already exist.\n     /// Other errors may also be returned according to `OpenOptions::open`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn open<P: AsPath>(path: P) -> io::Result<File> {\n+    pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> {\n         OpenOptions::new().read(true).open(path)\n     }\n \n@@ -140,7 +140,7 @@ impl File {\n     ///\n     /// See the `OpenOptions::open` function for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn create<P: AsPath>(path: P) -> io::Result<File> {\n+    pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> {\n         OpenOptions::new().write(true).create(true).truncate(true).open(path)\n     }\n \n@@ -302,8 +302,8 @@ impl OpenOptions {\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn open<P: AsPath>(&self, path: P) -> io::Result<File> {\n-        let path = path.as_path();\n+    pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> {\n+        let path = path.as_ref();\n         let inner = try!(fs_imp::File::open(path, &self.0));\n         Ok(File { path: path.to_path_buf(), inner: inner })\n     }\n@@ -415,8 +415,8 @@ impl DirEntry {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_file<P: AsPath>(path: P) -> io::Result<()> {\n-    fs_imp::unlink(path.as_path())\n+pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    fs_imp::unlink(path.as_ref())\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -443,8 +443,8 @@ pub fn remove_file<P: AsPath>(path: P) -> io::Result<()> {\n /// permissions to perform a `metadata` call on the given `path` or if there\n /// is no entry in the filesystem at the provided path.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn metadata<P: AsPath>(path: P) -> io::Result<Metadata> {\n-    fs_imp::stat(path.as_path()).map(Metadata)\n+pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n+    fs_imp::stat(path.as_ref()).map(Metadata)\n }\n \n /// Rename a file or directory to a new name.\n@@ -464,8 +464,8 @@ pub fn metadata<P: AsPath>(path: P) -> io::Result<Metadata> {\n /// reside on separate filesystems, or if some other intermittent I/O error\n /// occurs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn rename<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<()> {\n-    fs_imp::rename(from.as_path(), to.as_path())\n+pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()> {\n+    fs_imp::rename(from.as_ref(), to.as_ref())\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -494,9 +494,9 @@ pub fn rename<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<()> {\n /// * The current process does not have the permission rights to access\n ///   `from` or write `to`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn copy<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<u64> {\n-    let from = from.as_path();\n-    let to = to.as_path();\n+pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n+    let from = from.as_ref();\n+    let to = to.as_ref();\n     if !from.is_file() {\n         return Err(Error::new(ErrorKind::InvalidInput,\n                               \"the source path is not an existing file\",\n@@ -517,16 +517,16 @@ pub fn copy<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<u64> {\n /// The `dst` path will be a link pointing to the `src` path. Note that systems\n /// often require these two paths to both be located on the same filesystem.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn hard_link<P: AsPath, Q: AsPath>(src: P, dst: Q) -> io::Result<()> {\n-    fs_imp::link(src.as_path(), dst.as_path())\n+pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n+    fs_imp::link(src.as_ref(), dst.as_ref())\n }\n \n /// Creates a new soft link on the filesystem.\n ///\n /// The `dst` path will be a soft link pointing to the `src` path.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn soft_link<P: AsPath, Q: AsPath>(src: P, dst: Q) -> io::Result<()> {\n-    fs_imp::symlink(src.as_path(), dst.as_path())\n+pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n+    fs_imp::symlink(src.as_ref(), dst.as_ref())\n }\n \n /// Reads a soft link, returning the file that the link points to.\n@@ -537,8 +537,8 @@ pub fn soft_link<P: AsPath, Q: AsPath>(src: P, dst: Q) -> io::Result<()> {\n /// reading a file that does not exist or reading a file that is not a soft\n /// link.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn read_link<P: AsPath>(path: P) -> io::Result<PathBuf> {\n-    fs_imp::readlink(path.as_path())\n+pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n+    fs_imp::readlink(path.as_ref())\n }\n \n /// Create a new, empty directory at the provided path\n@@ -556,8 +556,8 @@ pub fn read_link<P: AsPath>(path: P) -> io::Result<PathBuf> {\n /// This function will return an error if the user lacks permissions to make a\n /// new directory at the provided `path`, or if the directory already exists.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn create_dir<P: AsPath>(path: P) -> io::Result<()> {\n-    fs_imp::mkdir(path.as_path())\n+pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    fs_imp::mkdir(path.as_ref())\n }\n \n /// Recursively create a directory and all of its parent components if they\n@@ -570,8 +570,8 @@ pub fn create_dir<P: AsPath>(path: P) -> io::Result<()> {\n /// error conditions for when a directory is being created (after it is\n /// determined to not exist) are outlined by `fs::create_dir`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn create_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n-    let path = path.as_path();\n+pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    let path = path.as_ref();\n     if path.is_dir() { return Ok(()) }\n     if let Some(p) = path.parent() { try!(create_dir_all(p)) }\n     create_dir(path)\n@@ -592,8 +592,8 @@ pub fn create_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n /// This function will return an error if the user lacks permissions to remove\n /// the directory at the provided `path`, or if the directory isn't empty.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_dir<P: AsPath>(path: P) -> io::Result<()> {\n-    fs_imp::rmdir(path.as_path())\n+pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    fs_imp::rmdir(path.as_ref())\n }\n \n /// Removes a directory at this path, after removing all its contents. Use\n@@ -606,8 +606,8 @@ pub fn remove_dir<P: AsPath>(path: P) -> io::Result<()> {\n ///\n /// See `file::remove_file` and `fs::remove_dir`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n-    let path = path.as_path();\n+pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    let path = path.as_ref();\n     for child in try!(read_dir(path)) {\n         let child = try!(child).path();\n         let stat = try!(lstat(&*child));\n@@ -659,8 +659,8 @@ pub fn remove_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn read_dir<P: AsPath>(path: P) -> io::Result<ReadDir> {\n-    fs_imp::readdir(path.as_path()).map(ReadDir)\n+pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n+    fs_imp::readdir(path.as_ref()).map(ReadDir)\n }\n \n /// Returns an iterator that will recursively walk the directory structure\n@@ -675,7 +675,7 @@ pub fn read_dir<P: AsPath>(path: P) -> io::Result<ReadDir> {\n            reason = \"the precise semantics and defaults for a recursive walk \\\n                      may change and this may end up accounting for files such \\\n                      as symlinks differently\")]\n-pub fn walk_dir<P: AsPath>(path: P) -> io::Result<WalkDir> {\n+pub fn walk_dir<P: AsRef<Path>>(path: P) -> io::Result<WalkDir> {\n     let start = try!(read_dir(path));\n     Ok(WalkDir { cur: Some(start), stack: Vec::new() })\n }\n@@ -761,9 +761,9 @@ impl PathExt for Path {\n            reason = \"the argument type of u64 is not quite appropriate for \\\n                      this function and may change if the standard library \\\n                      gains a type to represent a moment in time\")]\n-pub fn set_file_times<P: AsPath>(path: P, accessed: u64,\n+pub fn set_file_times<P: AsRef<Path>>(path: P, accessed: u64,\n                                  modified: u64) -> io::Result<()> {\n-    fs_imp::utimes(path.as_path(), accessed, modified)\n+    fs_imp::utimes(path.as_ref(), accessed, modified)\n }\n \n /// Changes the permissions found on a file or a directory.\n@@ -790,8 +790,8 @@ pub fn set_file_times<P: AsPath>(path: P, accessed: u64,\n            reason = \"a more granual ability to set specific permissions may \\\n                      be exposed on the Permissions structure itself and this \\\n                      method may not always exist\")]\n-pub fn set_permissions<P: AsPath>(path: P, perm: Permissions) -> io::Result<()> {\n-    fs_imp::set_perm(path.as_path(), perm.0)\n+pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result<()> {\n+    fs_imp::set_perm(path.as_ref(), perm.0)\n }\n \n #[cfg(test)]"}, {"sha": "a9717e36323392a74e55325916a306f9b52bd503", "filename": "src/libstd/fs/tempdir.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -18,7 +18,7 @@ use prelude::v1::*;\n use env;\n use io::{self, Error, ErrorKind};\n use fs;\n-use path::{self, PathBuf, AsPath};\n+use path::{self, PathBuf};\n use rand::{thread_rng, Rng};\n \n /// A wrapper for a path to temporary directory implementing automatic\n@@ -43,10 +43,9 @@ impl TempDir {\n     ///\n     /// If no directory can be created, `Err` is returned.\n     #[allow(deprecated)] // rand usage\n-    pub fn new_in<P: AsPath + ?Sized>(tmpdir: &P, prefix: &str)\n-                                      -> io::Result<TempDir> {\n+    pub fn new_in<P: AsRef<path::Path>>(tmpdir: P, prefix: &str) -> io::Result<TempDir> {\n         let storage;\n-        let mut tmpdir = tmpdir.as_path();\n+        let mut tmpdir = tmpdir.as_ref();\n         if !tmpdir.is_absolute() {\n             let cur_dir = try!(env::current_dir());\n             storage = cur_dir.join(tmpdir);"}, {"sha": "1488c7969f678cb79052b6dd75002100d313700b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -126,8 +126,10 @@\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(unique)]\n+#![feature(convert)]\n #![feature(allow_internal_unstable)]\n #![feature(str_char)]\n+#![feature(into_cow)]\n #![cfg_attr(test, feature(test, rustc_private))]\n \n // Don't link to std. We are std.\n@@ -169,6 +171,7 @@ pub use core::any;\n pub use core::cell;\n pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n+pub use core::convert;\n pub use core::default;\n #[allow(deprecated)]\n pub use core::finally;"}, {"sha": "d737ad17ff8ecf7220cdb3d894b735ef3246b151", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -374,7 +374,6 @@ impl fmt::Display for Ipv6Addr {\n                             .iter()\n                             .map(|&seg| format!(\"{:x}\", seg))\n                             .collect::<Vec<String>>()\n-                            .as_slice()\n                             .connect(\":\")\n                     }\n "}, {"sha": "72f9338b456718faa8610acbd52d4a5f9929d7cf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -38,6 +38,7 @@ use self::MapError::*;\n \n use boxed::Box;\n use clone::Clone;\n+use convert::From;\n use env;\n use error::{FromError, Error};\n use ffi::{OsString, OsStr};\n@@ -79,12 +80,12 @@ fn err2old(new: ::io::Error) -> IoError {\n \n #[cfg(windows)]\n fn path2new(path: &Path) -> PathBuf {\n-    PathBuf::new(path.as_str().unwrap())\n+    PathBuf::from(path.as_str().unwrap())\n }\n #[cfg(unix)]\n fn path2new(path: &Path) -> PathBuf {\n     use os::unix::prelude::*;\n-    PathBuf::new(<OsStr as OsStrExt>::from_bytes(path.as_vec()))\n+    PathBuf::from(<OsStr as OsStrExt>::from_bytes(path.as_vec()))\n }\n \n #[cfg(unix)]"}, {"sha": "8ee33e94fe7276f9404a65b2e5cdb202a340b9bb", "filename": "src/libstd/path.rs", "status": "modified", "additions": 173, "deletions": 27, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -106,6 +106,7 @@ use cmp;\n use iter::{self, IntoIterator};\n use mem;\n use ops::{self, Deref};\n+use string::String;\n use vec::Vec;\n use fmt;\n \n@@ -527,6 +528,13 @@ impl<'a> Component<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<OsStr> for Component<'a> {\n+    fn as_ref(&self) -> &OsStr {\n+        self.as_os_str()\n+    }\n+}\n+\n /// The core iterator giving the components of a path.\n ///\n /// See the module documentation for an in-depth explanation of components and\n@@ -601,6 +609,7 @@ impl<'a> Components<'a> {\n     }\n \n     /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         let mut comps = self.clone();\n         if comps.front == State::Body { comps.trim_left(); }\n@@ -695,6 +704,20 @@ impl<'a> Components<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<Path> for Components<'a> {\n+    fn as_ref(&self) -> &Path {\n+        self.as_path()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<OsStr> for Components<'a> {\n+    fn as_ref(&self) -> &OsStr {\n+        self.as_path().as_os_str()\n+    }\n+}\n+\n impl<'a> Iter<'a> {\n     /// Extract a slice corresponding to the portion of the path remaining for iteration.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -703,6 +726,20 @@ impl<'a> Iter<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<Path> for Iter<'a> {\n+    fn as_ref(&self) -> &Path {\n+        self.as_path()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<OsStr> for Iter<'a> {\n+    fn as_ref(&self) -> &OsStr {\n+        self.as_path().as_os_str()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Iter<'a> {\n     type Item = &'a OsStr;\n@@ -873,11 +910,10 @@ impl PathBuf {\n         unsafe { mem::transmute(self) }\n     }\n \n-    /// Allocate a `PathBuf` with initial contents given by the\n-    /// argument.\n+    /// Allocate an empty `PathBuf`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new<S: AsOsStr>(s: S) -> PathBuf {\n-        PathBuf { inner: s.as_os_str().to_os_string() }\n+    pub fn new() -> PathBuf {\n+        PathBuf { inner: OsString::new() }\n     }\n \n     /// Extend `self` with `path`.\n@@ -890,8 +926,8 @@ impl PathBuf {\n     ///   replaces everything except for the prefix (if any) of `self`.\n     /// * if `path` has a prefix but no root, it replaces `self.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push<P: AsPath>(&mut self, path: P) {\n-        let path = path.as_path();\n+    pub fn push<P: AsRef<Path>>(&mut self, path: P) {\n+        let path = path.as_ref();\n \n         // in general, a separator is needed if the rightmost byte is not a separator\n         let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n@@ -958,12 +994,12 @@ impl PathBuf {\n     /// assert!(buf == PathBuf::new(\"/baz.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set_file_name<S: AsOsStr>(&mut self, file_name: S) {\n+    pub fn set_file_name<S: AsRef<OsStr>>(&mut self, file_name: S) {\n         if self.file_name().is_some() {\n             let popped = self.pop();\n             debug_assert!(popped);\n         }\n-        self.push(file_name.as_os_str());\n+        self.push(file_name.as_ref());\n     }\n \n     /// Updates `self.extension()` to `extension`.\n@@ -973,15 +1009,15 @@ impl PathBuf {\n     /// Otherwise, returns `true`; if `self.extension()` is `None`, the extension\n     /// is added; otherwise it is replaced.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set_extension<S: AsOsStr>(&mut self, extension: S) -> bool {\n+    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool {\n         if self.file_name().is_none() { return false; }\n \n         let mut stem = match self.file_stem() {\n             Some(stem) => stem.to_os_string(),\n-            None => OsString::from_str(\"\"),\n+            None => OsString::new(),\n         };\n \n-        let extension = extension.as_os_str();\n+        let extension = extension.as_ref();\n         if os_str_as_u8_slice(extension).len() > 0 {\n             stem.push(\".\");\n             stem.push(extension);\n@@ -999,16 +1035,65 @@ impl PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<P: AsPath> iter::FromIterator<P> for PathBuf {\n+impl<'a> From<&'a Path> for PathBuf {\n+    fn from(s: &'a Path) -> PathBuf {\n+        s.to_path_buf()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for PathBuf {\n+    fn from(s: &'a str) -> PathBuf {\n+        PathBuf::from(OsString::from(s))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a String> for PathBuf {\n+    fn from(s: &'a String) -> PathBuf {\n+        PathBuf::from(OsString::from(s))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl From<String> for PathBuf {\n+    fn from(s: String) -> PathBuf {\n+        PathBuf::from(OsString::from(s))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a OsStr> for PathBuf {\n+    fn from(s: &'a OsStr) -> PathBuf {\n+        PathBuf::from(OsString::from(s))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a OsString> for PathBuf {\n+    fn from(s: &'a OsString) -> PathBuf {\n+        PathBuf::from(s.to_os_string())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl From<OsString> for PathBuf {\n+    fn from(s: OsString) -> PathBuf {\n+        PathBuf { inner: s }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n     fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {\n-        let mut buf = PathBuf::new(\"\");\n+        let mut buf = PathBuf::new();\n         buf.extend(iter);\n         buf\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<P: AsPath> iter::Extend<P> for PathBuf {\n+impl<P: AsRef<Path>> iter::Extend<P> for PathBuf {\n     fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) {\n         for p in iter {\n             self.push(p)\n@@ -1084,12 +1169,27 @@ impl cmp::Ord for PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for PathBuf {\n+    fn as_ref(&self) -> &OsStr {\n+        &self.inner[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for PathBuf {\n     fn as_os_str(&self) -> &OsStr {\n         &self.inner[..]\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Into<OsString> for PathBuf {\n+    fn into(self) -> OsString {\n+        self.inner\n+    }\n+}\n+\n /// A slice of a path (akin to `str`).\n ///\n /// This type supports a number of operations for inspecting a path, including\n@@ -1133,8 +1233,14 @@ impl Path {\n     ///\n     /// This is a cost-free conversion.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> &Path {\n-        unsafe { mem::transmute(s.as_os_str()) }\n+    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {\n+        unsafe { mem::transmute(s.as_ref()) }\n+    }\n+\n+    /// Yield the underlying `OsStr` slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn as_os_str(&self) -> &OsStr {\n+        &self.inner\n     }\n \n     /// Yield a `&str` slice if the `Path` is valid unicode.\n@@ -1156,7 +1262,7 @@ impl Path {\n     /// Convert a `Path` to an owned `PathBuf`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_path_buf(&self) -> PathBuf {\n-        PathBuf::new(self)\n+        PathBuf::from(self.inner.to_os_string())\n     }\n \n     /// A path is *absolute* if it is independent of the current directory.\n@@ -1247,22 +1353,21 @@ impl Path {\n     /// If `base` is not a prefix of `self` (i.e. `starts_with`\n     /// returns false), then `relative_from` returns `None`.\n     #[unstable(feature = \"path_relative_from\", reason = \"see #23284\")]\n-    pub fn relative_from<'a, P: ?Sized>(&'a self, base: &'a P) -> Option<&Path> where\n-        P: AsPath\n+    pub fn relative_from<'a, P: ?Sized + AsRef<Path>>(&'a self, base: &'a P) -> Option<&Path>\n     {\n-        iter_after(self.components(), base.as_path().components()).map(|c| c.as_path())\n+        iter_after(self.components(), base.as_ref().components()).map(|c| c.as_path())\n     }\n \n     /// Determines whether `base` is a prefix of `self`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with<P: AsPath>(&self, base: P) -> bool {\n-        iter_after(self.components(), base.as_path().components()).is_some()\n+    pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n+        iter_after(self.components(), base.as_ref().components()).is_some()\n     }\n \n     /// Determines whether `child` is a suffix of `self`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with<P: AsPath>(&self, child: P) -> bool {\n-        iter_after(self.components().rev(), child.as_path().components().rev()).is_some()\n+    pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool {\n+        iter_after(self.components().rev(), child.as_ref().components().rev()).is_some()\n     }\n \n     /// Extract the stem (non-extension) portion of `self.file()`.\n@@ -1295,7 +1400,7 @@ impl Path {\n     ///\n     /// See `PathBuf::push` for more details on what it means to adjoin a path.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn join<P: AsPath>(&self, path: P) -> PathBuf {\n+    pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.push(path);\n         buf\n@@ -1305,7 +1410,7 @@ impl Path {\n     ///\n     /// See `PathBuf::set_file_name` for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_file_name<S: AsOsStr>(&self, file_name: S) -> PathBuf {\n+    pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.set_file_name(file_name);\n         buf\n@@ -1315,7 +1420,7 @@ impl Path {\n     ///\n     /// See `PathBuf::set_extension` for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_extension<S: AsOsStr>(&self, extension: S) -> PathBuf {\n+    pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.set_extension(extension);\n         buf\n@@ -1349,6 +1454,14 @@ impl Path {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for Path {\n+    fn as_ref(&self) -> &OsStr {\n+        &self.inner\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for Path {\n     fn as_os_str(&self) -> &OsStr {\n         &self.inner\n@@ -1408,17 +1521,50 @@ impl cmp::Ord for Path {\n \n /// Freely convertible to a `Path`.\n #[unstable(feature = \"std_misc\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::convert::AsRef<Path> instead\")]\n pub trait AsPath {\n     /// Convert to a `Path`.\n     #[unstable(feature = \"std_misc\")]\n     fn as_path(&self) -> &Path;\n }\n \n #[unstable(feature = \"std_misc\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::convert::AsRef<Path> instead\")]\n+#[allow(deprecated)]\n impl<T: AsOsStr + ?Sized> AsPath for T {\n     fn as_path(&self) -> &Path { Path::new(self.as_os_str()) }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for Path {\n+    fn as_ref(&self) -> &Path { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for OsStr {\n+    fn as_ref(&self) -> &Path { Path::new(self) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for OsString {\n+    fn as_ref(&self) -> &Path { Path::new(self) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for str {\n+    fn as_ref(&self) -> &Path { Path::new(self) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for String {\n+    fn as_ref(&self) -> &Path { Path::new(self) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for PathBuf {\n+    fn as_ref(&self) -> &Path { self }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "6e12ac1a226592b864354231aed50703fd0f8e4f", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -29,6 +29,8 @@\n #[doc(no_inline)] pub use clone::Clone;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+#[unstable(feature = \"convert\")]\n+#[doc(no_inline)] pub use convert::{AsRef, AsMut, Into, From};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -40,8 +42,10 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n #[doc(no_inline)] pub use slice::{SliceConcatExt, AsSlice};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n #[doc(no_inline)] pub use str::Str;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use string::{String, ToString};"}, {"sha": "d11c3d221445f3220aedc8881d494a770c1c35df", "filename": "src/libstd/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -19,8 +19,8 @@ use io::prelude::*;\n use ffi::AsOsStr;\n use fmt;\n use io::{self, Error, ErrorKind};\n-use path::AsPath;\n use libc;\n+use path;\n use sync::mpsc::{channel, Receiver};\n use sys::pipe2::{self, AnonPipe};\n use sys::process2::Process as ProcessImp;\n@@ -198,8 +198,8 @@ impl Command {\n \n     /// Set the working directory for the child process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn current_dir<P: AsPath>(&mut self, dir: P) -> &mut Command {\n-        self.inner.cwd(dir.as_path().as_os_str());\n+    pub fn current_dir<P: AsRef<path::Path>>(&mut self, dir: P) -> &mut Command {\n+        self.inner.cwd(dir.as_ref().as_os_str());\n         self\n     }\n "}, {"sha": "202e5ddaec42bd01c77eda25d11acdba21c902fd", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -338,8 +338,7 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n         }));\n         buf.set_len(n as usize);\n     }\n-    let s: OsString = OsStringExt::from_vec(buf);\n-    Ok(PathBuf::new(&s))\n+    Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {"}, {"sha": "6c191689255bc123ac0517fa676300ef5051f128", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -36,7 +36,7 @@ const BUF_BYTES: usize = 2048;\n const TMPBUF_SZ: usize = 128;\n \n fn bytes2path(b: &[u8]) -> PathBuf {\n-    PathBuf::new(<OsStr as OsStrExt>::from_bytes(b))\n+    PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n }\n \n fn os2path(os: OsString) -> PathBuf {\n@@ -253,7 +253,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n         if err != 0 { return Err(io::Error::last_os_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Ok(PathBuf::new(OsString::from_vec(v)))\n+        Ok(PathBuf::from(OsString::from_vec(v)))\n     }\n }\n \n@@ -466,9 +466,9 @@ pub fn page_size() -> usize {\n pub fn temp_dir() -> PathBuf {\n     getenv(\"TMPDIR\".as_os_str()).map(os2path).unwrap_or_else(|| {\n         if cfg!(target_os = \"android\") {\n-            PathBuf::new(\"/data/local/tmp\")\n+            PathBuf::from(\"/data/local/tmp\")\n         } else {\n-            PathBuf::new(\"/tmp\")\n+            PathBuf::from(\"/tmp\")\n         }\n     })\n }"}, {"sha": "1abe8d0a3c1b1352e77100adb0f246b130981a04", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -351,8 +351,7 @@ impl Encodable for FileMap {\n                         let max_line_length = if lines.len() == 1 {\n                             0\n                         } else {\n-                            lines.as_slice()\n-                                 .windows(2)\n+                            lines.windows(2)\n                                  .map(|w| w[1] - w[0])\n                                  .map(|bp| bp.to_usize())\n                                  .max()"}, {"sha": "31d8b207bb9f080134fcbc582391391b1924c726", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -194,7 +194,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> PathBuf {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n-        let mut cu = PathBuf::new(&cx.codemap().span_to_filename(sp));\n+        let mut cu = PathBuf::from(&cx.codemap().span_to_filename(sp));\n         cu.pop();\n         cu.push(arg);\n         cu"}, {"sha": "9af7b9ab633116619c2e9ff3cc12b4ad28e5ad74", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -39,6 +39,8 @@\n #![feature(unicode)]\n #![feature(path_ext)]\n #![feature(str_char)]\n+#![feature(convert)]\n+#![feature(into_cow)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "e77786c134707567abb3bb38f34611ff6de0d0bb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -5064,8 +5064,8 @@ impl<'a> Parser<'a> {\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n-        let mut prefix = PathBuf::new(&self.sess.span_diagnostic.cm\n-                                           .span_to_filename(self.span));\n+        let mut prefix = PathBuf::from(&self.sess.span_diagnostic.cm\n+                                            .span_to_filename(self.span));\n         prefix.pop();\n         let mut dir_path = prefix;\n         for part in &self.mod_path_stack {"}, {"sha": "8e3c00bb805fe30aaefd92ac2ba9f1e3f0d14cd9", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -62,6 +62,7 @@\n #![feature(std_misc)]\n #![feature(str_char)]\n #![feature(path_ext)]\n+#![feature(convert)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "66ee2b1ba87cbee6337302ff195d21093564ae41", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -31,7 +31,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n \n     // Find search directory\n     match env::var_os(\"TERMINFO\") {\n-        Some(dir) => dirs_to_search.push(PathBuf::new(&dir)),\n+        Some(dir) => dirs_to_search.push(PathBuf::from(dir)),\n         None => {\n             if homedir.is_some() {\n                 // ncurses compatibility;\n@@ -40,19 +40,19 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n             match env::var(\"TERMINFO_DIRS\") {\n                 Ok(dirs) => for i in dirs.split(':') {\n                     if i == \"\" {\n-                        dirs_to_search.push(PathBuf::new(\"/usr/share/terminfo\"));\n+                        dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n                     } else {\n-                        dirs_to_search.push(PathBuf::new(i));\n+                        dirs_to_search.push(PathBuf::from(i));\n                     }\n                 },\n                 // Found nothing in TERMINFO_DIRS, use the default paths:\n                 // According to  /etc/terminfo/README, after looking at\n                 // ~/.terminfo, ncurses will search /etc/terminfo, then\n                 // /lib/terminfo, and eventually /usr/share/terminfo.\n                 Err(..) => {\n-                    dirs_to_search.push(PathBuf::new(\"/etc/terminfo\"));\n-                    dirs_to_search.push(PathBuf::new(\"/lib/terminfo\"));\n-                    dirs_to_search.push(PathBuf::new(\"/usr/share/terminfo\"));\n+                    dirs_to_search.push(PathBuf::from(\"/etc/terminfo\"));\n+                    dirs_to_search.push(PathBuf::from(\"/lib/terminfo\"));\n+                    dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n                 }\n             }\n         }"}, {"sha": "94944453eda07d50368ccc410060e6189f3d1245", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -45,6 +45,7 @@\n #![feature(libc)]\n #![feature(set_stdio)]\n #![feature(os)]\n+#![feature(convert)]\n \n extern crate getopts;\n extern crate serialize;\n@@ -382,7 +383,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let run_ignored = matches.opt_present(\"ignored\");\n \n     let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map(|s| PathBuf::new(&s));\n+    let logfile = logfile.map(|s| PathBuf::from(&s));\n \n     let run_benchmarks = matches.opt_present(\"bench\");\n     let run_tests = ! run_benchmarks ||\n@@ -696,7 +697,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::Res\n     match tests.iter().max_by(|t|len_if_padded(*t)) {\n         Some(t) => {\n             let n = t.desc.name.as_slice();\n-            st.max_name_len = n.as_slice().len();\n+            st.max_name_len = n.len();\n         },\n         None => {}\n     }"}, {"sha": "a08481f8be94e0473c8cfc6b77167bf83d7aa4c1", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -102,8 +102,8 @@ pub fn parse_summary(input: &mut Read, src: &Path) -> Result<Book, Vec<String>>\n     // always include the introduction\n     top_items.push(BookItem {\n         title: \"Introduction\".to_string(),\n-        path: PathBuf::new(\"README.md\"),\n-        path_to_root: PathBuf::new(\".\"),\n+        path: PathBuf::from(\"README.md\"),\n+        path_to_root: PathBuf::from(\".\"),\n         children: vec!(),\n     });\n \n@@ -133,10 +133,10 @@ pub fn parse_summary(input: &mut Read, src: &Path) -> Result<Book, Vec<String>>\n                 errors.push(format!(\"paths in SUMMARY.md must be relative, \\\n                                      but path '{}' for section '{}' is not.\",\n                                      given_path, title));\n-                PathBuf::new(\"\")\n+                PathBuf::new()\n             }\n         };\n-        let path_to_root = PathBuf::new(&iter::repeat(\"../\")\n+        let path_to_root = PathBuf::from(&iter::repeat(\"../\")\n                                          .take(path_from_root.components().count() - 1)\n                                          .collect::<String>());\n         let item = BookItem {"}, {"sha": "f06290b27cb2809583269f159f4b3313de5745ee", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -87,7 +87,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         if env::args().len() < 3 {\n             src = env::current_dir().unwrap().clone();\n         } else {\n-            src = PathBuf::new(&env::args().nth(2).unwrap());\n+            src = PathBuf::from(&env::args().nth(2).unwrap());\n         }\n         // preprocess the markdown, rerouting markdown references to html references\n         let mut markdown_data = String::new();\n@@ -164,13 +164,13 @@ impl Subcommand for Build {\n         if env::args().len() < 3 {\n             src = cwd.clone();\n         } else {\n-            src = PathBuf::new(&env::args().nth(2).unwrap());\n+            src = PathBuf::from(&env::args().nth(2).unwrap());\n         }\n \n         if env::args().len() < 4 {\n             tgt = cwd.join(\"_book\");\n         } else {\n-            tgt = PathBuf::new(&env::args().nth(3).unwrap());\n+            tgt = PathBuf::from(&env::args().nth(3).unwrap());\n         }\n \n         try!(fs::create_dir(&tgt));"}, {"sha": "4a652f846ed58bd0112c54e609a64737c8dad74f", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -15,6 +15,7 @@\n #![feature(rustdoc)]\n #![feature(rustc_private)]\n #![feature(path_relative_from)]\n+#![feature(convert)]\n \n extern crate rustdoc;\n extern crate rustc_back;"}, {"sha": "cd6147504512873f74d225b04d3474c0e6b299eb", "filename": "src/test/run-pass/env-home-dir.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd13400627108fbf3998545f782ed44422e344bf/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd13400627108fbf3998545f782ed44422e344bf/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs?ref=fd13400627108fbf3998545f782ed44422e344bf", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(convert)]\n+\n use std::env::*;\n use std::path::PathBuf;\n \n@@ -16,7 +18,7 @@ fn main() {\n     let oldhome = var(\"HOME\");\n \n     set_var(\"HOME\", \"/home/MountainView\");\n-    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::from(\"/home/MountainView\")));\n \n     remove_var(\"HOME\");\n     if cfg!(target_os = \"android\") {\n@@ -37,14 +39,14 @@ fn main() {\n     assert!(home_dir().is_some());\n \n     set_var(\"HOME\", \"/home/MountainView\");\n-    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::from(\"/home/MountainView\")));\n \n     remove_var(\"HOME\");\n \n     set_var(\"USERPROFILE\", \"/home/MountainView\");\n-    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::from(\"/home/MountainView\")));\n \n     set_var(\"HOME\", \"/home/MountainView\");\n     set_var(\"USERPROFILE\", \"/home/PaloAlto\");\n-    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::from(\"/home/MountainView\")));\n }"}]}