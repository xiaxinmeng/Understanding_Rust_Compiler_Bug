{"sha": "da42e6b7a0fcadcca819d221738894dcb6c4b76d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNDJlNmI3YTBmY2FkY2NhODE5ZDIyMTczODg5NGRjYjZjNGI3NmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-15T10:07:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-15T10:07:05Z"}, "message": "auto merge of #7133 : kballard/rust/terminfo-parm, r=thestinger\n\nImplement conditional support in terminfo, along with a few other related operators.\r\n\r\nFix implementation of non-commutative arithmetic operators.\r\n\r\nRemove all known cases of task failure from `terminfo::parm::expand`, and change the method signature.\r\n\r\nFix some other miscellaneous issues.", "tree": {"sha": "748b47c869b046a4918f734b4bced05d706ae950", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748b47c869b046a4918f734b4bced05d706ae950"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da42e6b7a0fcadcca819d221738894dcb6c4b76d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da42e6b7a0fcadcca819d221738894dcb6c4b76d", "html_url": "https://github.com/rust-lang/rust/commit/da42e6b7a0fcadcca819d221738894dcb6c4b76d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da42e6b7a0fcadcca819d221738894dcb6c4b76d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83d44f87e5fe8935c1f8a5f26409a99286675650", "url": "https://api.github.com/repos/rust-lang/rust/commits/83d44f87e5fe8935c1f8a5f26409a99286675650", "html_url": "https://github.com/rust-lang/rust/commit/83d44f87e5fe8935c1f8a5f26409a99286675650"}, {"sha": "da4e614742ea67677ed122985c1730590748d788", "url": "https://api.github.com/repos/rust-lang/rust/commits/da4e614742ea67677ed122985c1730590748d788", "html_url": "https://github.com/rust-lang/rust/commit/da4e614742ea67677ed122985c1730590748d788"}], "stats": {"total": 418, "additions": 321, "deletions": 97}, "files": [{"sha": "17d80ded47f81b09825d5aa95e8e538911e56709", "filename": "src/libextra/term.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da42e6b7a0fcadcca819d221738894dcb6c4b76d/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42e6b7a0fcadcca819d221738894dcb6c4b76d/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=da42e6b7a0fcadcca819d221738894dcb6c4b76d", "patch": "@@ -20,7 +20,7 @@ use core::os;\n use terminfo::*;\n use terminfo::searcher::open;\n use terminfo::parser::compiled::parse;\n-use terminfo::parm::{expand, Number};\n+use terminfo::parm::{expand, Number, Variables};\n \n // FIXME (#2807): Windows support.\n \n@@ -84,7 +84,7 @@ impl Terminal {\n     pub fn fg(&self, color: u8) {\n         if self.color_supported {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n-                           [Number(color as int)], [], []);\n+                           [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n                 self.out.write(s.get());\n             } else {\n@@ -95,7 +95,7 @@ impl Terminal {\n     pub fn bg(&self, color: u8) {\n         if self.color_supported {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n-                           [Number(color as int)], [], []);\n+                           [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n                 self.out.write(s.get());\n             } else {\n@@ -105,7 +105,8 @@ impl Terminal {\n     }\n     pub fn reset(&self) {\n         if self.color_supported {\n-            let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], [], []);\n+            let mut vars = Variables::new();\n+            let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], &mut vars);\n             if s.is_ok() {\n                 self.out.write(s.get());\n             } else {"}, {"sha": "c395b57219c2c8da77f7a3e25862f3d2044c9578", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 316, "deletions": 93, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/da42e6b7a0fcadcca819d221738894dcb6c4b76d/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42e6b7a0fcadcca819d221738894dcb6c4b76d/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=da42e6b7a0fcadcca819d221738894dcb6c4b76d", "patch": "@@ -12,6 +12,7 @@\n \n use core::prelude::*;\n use core::{char, int, vec};\n+use core::iterator::IteratorUtil;\n \n #[deriving(Eq)]\n enum States {\n@@ -23,190 +24,412 @@ enum States {\n     CharConstant,\n     CharClose,\n     IntConstant,\n-    IfCond,\n-    IfBody\n+    SeekIfElse(int),\n+    SeekIfElsePercent(int),\n+    SeekIfEnd(int),\n+    SeekIfEndPercent(int)\n }\n \n /// Types of parameters a capability can use\n pub enum Param {\n     String(~str),\n-    Char(char),\n     Number(int)\n }\n \n+/// Container for static and dynamic variable arrays\n+pub struct Variables {\n+    /// Static variables A-Z\n+    sta: [Param, ..26],\n+    /// Dynamic variables a-z\n+    dyn: [Param, ..26]\n+}\n+\n+impl Variables {\n+    /// Return a new zero-initialized Variables\n+    pub fn new() -> Variables {\n+        Variables{ sta: [Number(0), ..26], dyn: [Number(0), ..26] }\n+    }\n+}\n+\n /**\n   Expand a parameterized capability\n \n   # Arguments\n   * `cap`    - string to expand\n   * `params` - vector of params for %p1 etc\n-  * `sta`    - vector of params corresponding to static variables\n-  * `dyn`    - vector of params corresponding to stativ variables\n+  * `vars`   - Variables struct for %Pa etc\n \n-  To be compatible with ncurses, `sta` and `dyn` should be the same between calls to `expand` for\n+  To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n   multiple capabilities for the same terminal.\n   */\n-pub fn expand(cap: &[u8], params: &mut [Param], sta: &mut [Param], dyn: &mut [Param])\n+pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     -> Result<~[u8], ~str> {\n-    assert!(cap.len() != 0, \"expanding an empty capability makes no sense\");\n-    assert!(params.len() <= 9, \"only 9 parameters are supported by capability strings\");\n-\n-    assert!(sta.len() <= 26, \"only 26 static vars are able to be used by capability strings\");\n-    assert!(dyn.len() <= 26, \"only 26 dynamic vars are able to be used by capability strings\");\n-\n     let mut state = Nothing;\n-    let mut i = 0;\n \n-    // expanded cap will only rarely be smaller than the cap itself\n+    // expanded cap will only rarely be larger than the cap itself\n     let mut output = vec::with_capacity(cap.len());\n \n-    let mut cur;\n-\n     let mut stack: ~[Param] = ~[];\n \n     let mut intstate = ~[];\n \n-    while i < cap.len() {\n-        cur = cap[i] as char;\n+    // Copy parameters into a local vector for mutability\n+    let mut mparams = [Number(0), ..9];\n+    for mparams.mut_iter().zip(params.iter()).advance |(dst, &src)| {\n+        *dst = src;\n+    }\n+\n+    for cap.iter().transform(|&x| x).advance |c| {\n+        let cur = c as char;\n         let mut old_state = state;\n         match state {\n             Nothing => {\n                 if cur == '%' {\n                     state = Percent;\n                 } else {\n-                    output.push(cap[i]);\n+                    output.push(c);\n                 }\n             },\n             Percent => {\n                 match cur {\n-                    '%' => { output.push(cap[i]); state = Nothing },\n-                    'c' => match stack.pop() {\n-                        Char(c) => output.push(c as u8),\n-                        _       => return Err(~\"a non-char was used with %c\")\n-                    },\n-                    's' => match stack.pop() {\n-                        String(s) => output.push_all(s.as_bytes()),\n-                        _         => return Err(~\"a non-str was used with %s\")\n-                    },\n-                    'd' => match stack.pop() {\n-                        Number(x) => {\n-                            let s = x.to_str();\n-                            output.push_all(s.as_bytes())\n+                    '%' => { output.push(c); state = Nothing },\n+                    'c' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            // if c is 0, use 0200 (128) for ncurses compatibility\n+                            Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n+                            _       => return Err(~\"a non-char was used with %c\")\n                         }\n-                        _         => return Err(~\"a non-number was used with %d\")\n-                    },\n+                    } else { return Err(~\"stack is empty\") },\n+                    's' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => output.push_all(s.as_bytes()),\n+                            _         => return Err(~\"a non-str was used with %s\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'd' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => {\n+                                let s = x.to_str();\n+                                output.push_all(s.as_bytes())\n+                            }\n+                            _         => return Err(~\"a non-number was used with %d\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant,\n-                    'l' => match stack.pop() {\n-                        String(s) => stack.push(Number(s.len() as int)),\n-                        _         => return Err(~\"a non-str was used with %l\")\n-                    },\n-                    '+' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x + y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with +\")\n-                    },\n-                    '-' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x - y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with -\")\n-                    },\n-                    '*' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x * y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with *\")\n-                    },\n-                    '/' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x / y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with /\")\n-                    },\n-                    'm' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x % y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with %\")\n-                    },\n-                    '&' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x & y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with &\")\n-                    },\n-                    '|' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x | y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with |\")\n-                    },\n-                    'A' => return Err(~\"logical operations unimplemented\"),\n-                    'O' => return Err(~\"logical operations unimplemented\"),\n-                    '!' => return Err(~\"logical operations unimplemented\"),\n-                    '~' => match stack.pop() {\n-                        Number(x) => stack.push(Number(!x)),\n-                        _         => return Err(~\"non-number on stack with %~\")\n-                    },\n-                    'i' => match (copy params[0], copy params[1]) {\n-                        (Number(x), Number(y)) => {\n-                            params[0] = Number(x + 1);\n-                            params[1] = Number(y + 1);\n+                    'l' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => stack.push(Number(s.len() as int)),\n+                            _         => return Err(~\"a non-str was used with %l\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '+' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x + y)),\n+                            _ => return Err(~\"non-numbers on stack with +\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '-' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x - y)),\n+                            _ => return Err(~\"non-numbers on stack with -\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '*' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x * y)),\n+                            _ => return Err(~\"non-numbers on stack with *\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '/' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x / y)),\n+                            _ => return Err(~\"non-numbers on stack with /\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'm' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x % y)),\n+                            _ => return Err(~\"non-numbers on stack with %\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '&' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x & y)),\n+                            _ => return Err(~\"non-numbers on stack with &\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '|' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x | y)),\n+                            _ => return Err(~\"non-numbers on stack with |\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '^' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n+                            _ => return Err(~\"non-numbers on stack with ^\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '=' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with =\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '>' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with >\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '<' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with <\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'A' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(_)) => stack.push(Number(0)),\n+                            (Number(_), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical and\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'O' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical or\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '!' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(0) => stack.push(Number(1)),\n+                            Number(_) => stack.push(Number(0)),\n+                            _ => return Err(~\"non-number on stack with logical not\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '~' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => stack.push(Number(!x)),\n+                            _         => return Err(~\"non-number on stack with %~\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'i' => match (copy mparams[0], copy mparams[1]) {\n+                        (Number(ref mut x), Number(ref mut y)) => {\n+                            *x += 1;\n+                            *y += 1;\n                         },\n                         (_, _) => return Err(~\"first two params not numbers with %i\")\n                     },\n-                    '?' => state = return Err(fmt!(\"if expressions unimplemented (%?)\", cap)),\n+\n+                    // conditionals\n+                    '?' => (),\n+                    't' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(0) => state = SeekIfElse(0),\n+                            Number(_) => (),\n+                            _         => return Err(~\"non-number on stack with conditional\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'e' => state = SeekIfEnd(0),\n+                    ';' => (),\n+\n                     _ => return Err(fmt!(\"unrecognized format option %c\", cur))\n                 }\n             },\n             PushParam => {\n                 // params are 1-indexed\n-                stack.push(copy params[char::to_digit(cur, 10).expect(\"bad param number\") - 1]);\n+                stack.push(copy mparams[match char::to_digit(cur, 10) {\n+                    Some(d) => d - 1,\n+                    None => return Err(~\"bad param number\")\n+                }]);\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n-                    let idx = (cur as u8) - ('A' as u8);\n-                    sta[idx] = stack.pop();\n+                    if stack.len() > 0 {\n+                        let idx = (cur as u8) - ('A' as u8);\n+                        vars.sta[idx] = stack.pop();\n+                    } else { return Err(~\"stack is empty\") }\n                 } else if cur >= 'a' && cur <= 'z' {\n-                    let idx = (cur as u8) - ('a' as u8);\n-                    dyn[idx] = stack.pop();\n+                    if stack.len() > 0 {\n+                        let idx = (cur as u8) - ('a' as u8);\n+                        vars.dyn[idx] = stack.pop();\n+                    } else { return Err(~\"stack is empty\") }\n                 } else {\n                     return Err(~\"bad variable name in %P\");\n                 }\n             },\n             GetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     let idx = (cur as u8) - ('A' as u8);\n-                    stack.push(copy sta[idx]);\n+                    stack.push(copy vars.sta[idx]);\n                 } else if cur >= 'a' && cur <= 'z' {\n                     let idx = (cur as u8) - ('a' as u8);\n-                    stack.push(copy dyn[idx]);\n+                    stack.push(copy vars.dyn[idx]);\n                 } else {\n                     return Err(~\"bad variable name in %g\");\n                 }\n             },\n             CharConstant => {\n-                stack.push(Char(cur));\n+                stack.push(Number(c as int));\n                 state = CharClose;\n             },\n             CharClose => {\n-                assert!(cur == '\\'', \"malformed character constant\");\n+                if cur != '\\'' {\n+                    return Err(~\"malformed character constant\");\n+                }\n             },\n             IntConstant => {\n                 if cur == '}' {\n-                    stack.push(Number(int::parse_bytes(intstate, 10).expect(\"bad int constant\")));\n+                    stack.push(match int::parse_bytes(intstate, 10) {\n+                        Some(n) => Number(n),\n+                        None => return Err(~\"bad int constant\")\n+                    });\n+                    intstate.clear();\n+                    state = Nothing;\n+                } else {\n+                    intstate.push(cur as u8);\n+                    old_state = Nothing;\n+                }\n+            }\n+            SeekIfElse(level) => {\n+                if cur == '%' {\n+                    state = SeekIfElsePercent(level);\n+                }\n+                old_state = Nothing;\n+            }\n+            SeekIfElsePercent(level) => {\n+                if cur == ';' {\n+                    if level == 0 {\n+                        state = Nothing;\n+                    } else {\n+                        state = SeekIfElse(level-1);\n+                    }\n+                } else if cur == 'e' && level == 0 {\n                     state = Nothing;\n+                } else if cur == '?' {\n+                    state = SeekIfElse(level+1);\n+                } else {\n+                    state = SeekIfElse(level);\n+                }\n+            }\n+            SeekIfEnd(level) => {\n+                if cur == '%' {\n+                    state = SeekIfEndPercent(level);\n                 }\n-                intstate.push(cur as u8);\n                 old_state = Nothing;\n             }\n-            _ => return Err(~\"unimplemented state\")\n+            SeekIfEndPercent(level) => {\n+                if cur == ';' {\n+                    if level == 0 {\n+                        state = Nothing;\n+                    } else {\n+                        state = SeekIfEnd(level-1);\n+                    }\n+                } else if cur == '?' {\n+                    state = SeekIfEnd(level+1);\n+                } else {\n+                    state = SeekIfEnd(level);\n+                }\n+            }\n         }\n         if state == old_state {\n             state = Nothing;\n         }\n-        i += 1;\n     }\n     Ok(output)\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n+\n     #[test]\n     fn test_basic_setabf() {\n         let s = bytes!(\"\\\\E[48;5;%p1%dm\");\n-        assert_eq!(expand(s, [Number(1)], [], []).unwrap(), bytes!(\"\\\\E[48;5;1m\").to_owned());\n+        assert_eq!(expand(s, [Number(1)], &mut Variables::new()).unwrap(),\n+                   bytes!(\"\\\\E[48;5;1m\").to_owned());\n+    }\n+\n+    #[test]\n+    fn test_multiple_int_constants() {\n+        assert_eq!(expand(bytes!(\"%{1}%{2}%d%d\"), [], &mut Variables::new()).unwrap(),\n+                   bytes!(\"21\").to_owned());\n+    }\n+\n+    #[test]\n+    fn test_param_stack_failure_conditions() {\n+        let mut varstruct = Variables::new();\n+        let vars = &mut varstruct;\n+        let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n+        for caps.iter().advance |cap| {\n+            let res = expand(cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Op %s succeeded incorrectly with 0 stack entries\", *cap);\n+            let p = if *cap == \"%s\" || *cap == \"%l\" { String(~\"foo\") } else { Number(97) };\n+            let res = expand((bytes!(\"%p1\")).to_owned() + cap.as_bytes(), [p], vars);\n+            assert!(res.is_ok(),\n+                    \"Op %s failed with 1 stack entry: %s\", *cap, res.unwrap_err());\n+        }\n+        let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n+        for caps.iter().advance |cap| {\n+            let res = expand(cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Binop %s succeeded incorrectly with 0 stack entries\", *cap);\n+            let res = expand((bytes!(\"%{1}\")).to_owned() + cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Binop %s succeeded incorrectly with 1 stack entry\", *cap);\n+            let res = expand((bytes!(\"%{1}%{2}\")).to_owned() + cap.as_bytes(), [], vars);\n+            assert!(res.is_ok(),\n+                    \"Binop %s failed with 2 stack entries: %s\", *cap, res.unwrap_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_push_bad_param() {\n+        assert!(expand(bytes!(\"%pa\"), [], &mut Variables::new()).is_err());\n+    }\n+\n+    #[test]\n+    fn test_comparison_ops() {\n+        let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n+        for v.iter().advance |&(op, bs)| {\n+            let s = fmt!(\"%%{1}%%{2}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[0]]);\n+            let s = fmt!(\"%%{1}%%{1}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[1]]);\n+            let s = fmt!(\"%%{2}%%{1}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[2]]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_conditionals() {\n+        let mut vars = Variables::new();\n+        let s = bytes!(\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\");\n+        let res = expand(s, [Number(1)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[31m\").to_owned());\n+        let res = expand(s, [Number(8)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[90m\").to_owned());\n+        let res = expand(s, [Number(42)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[38;5;42m\").to_owned());\n     }\n }"}]}