{"sha": "d91151c3b1af6d4e4c29f5f82df8566b046266e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MTE1MWMzYjFhZjZkNGU0YzI5ZjVmODJkZjg1NjZiMDQ2MjY2ZTM=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2021-03-14T04:30:14Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2021-03-15T12:38:19Z"}, "message": "update algorithm for determining expected type of completion", "tree": {"sha": "de655e58fa1fdb4f335ac049465dd786ea71104e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de655e58fa1fdb4f335ac049465dd786ea71104e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d91151c3b1af6d4e4c29f5f82df8566b046266e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d91151c3b1af6d4e4c29f5f82df8566b046266e3", "html_url": "https://github.com/rust-lang/rust/commit/d91151c3b1af6d4e4c29f5f82df8566b046266e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d91151c3b1af6d4e4c29f5f82df8566b046266e3/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4446cdd06caa32e1e9e255312a15feb770d4935", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4446cdd06caa32e1e9e255312a15feb770d4935", "html_url": "https://github.com/rust-lang/rust/commit/b4446cdd06caa32e1e9e255312a15feb770d4935"}], "stats": {"total": 312, "additions": 286, "deletions": 26}, "files": [{"sha": "89e9bda7839290a465f92d6b306c1febe4f5c72f", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 283, "deletions": 14, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/d91151c3b1af6d4e4c29f5f82df8566b046266e3/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91151c3b1af6d4e4c29f5f82df8566b046266e3/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=d91151c3b1af6d4e4c29f5f82df8566b046266e3", "patch": "@@ -35,6 +35,7 @@ pub(crate) struct CompletionContext<'a> {\n     /// The token before the cursor, in the macro-expanded file.\n     pub(super) token: SyntaxToken,\n     pub(super) krate: Option<hir::Crate>,\n+    pub(super) expected_name: Option<String>,\n     pub(super) expected_type: Option<Type>,\n     pub(super) name_ref_syntax: Option<ast::NameRef>,\n     pub(super) function_syntax: Option<ast::Fn>,\n@@ -135,6 +136,7 @@ impl<'a> CompletionContext<'a> {\n             original_token,\n             token,\n             krate,\n+            expected_name: None,\n             expected_type: None,\n             name_ref_syntax: None,\n             function_syntax: None,\n@@ -290,23 +292,96 @@ impl<'a> CompletionContext<'a> {\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n     ) {\n-        // FIXME: this is wrong in at least two cases:\n-        //  * when there's no token `foo($0)`\n-        //  * when there is a token, but it happens to have type of it's own\n-        self.expected_type = self\n-            .token\n-            .ancestors()\n-            .find_map(|node| {\n-                let ty = match_ast! {\n+        let expected = {\n+            let mut node = self.token.parent();\n+            loop {\n+                let ret = match_ast! {\n                     match node {\n-                        ast::Pat(it) => self.sema.type_of_pat(&it),\n-                        ast::Expr(it) => self.sema.type_of_expr(&it),\n-                        _ => return None,\n+                        ast::LetStmt(it) => {\n+                            cov_mark::hit!(expected_type_let_with_leading_char);\n+                            cov_mark::hit!(expected_type_let_without_leading_char);\n+                            let ty = it.pat()\n+                                .and_then(|pat| self.sema.type_of_pat(&pat));\n+                            let name = if let Some(ast::Pat::IdentPat(ident)) = it.pat() {\n+                                Some(ident.syntax().text().to_string())\n+                            } else {\n+                                None\n+                            };\n+\n+                            (ty, name)\n+                        },\n+                        ast::ArgList(it) => {\n+                            cov_mark::hit!(expected_type_fn_param_with_leading_char);\n+                            cov_mark::hit!(expected_type_fn_param_without_leading_char);\n+                            ActiveParameter::at_token(\n+                                &self.sema,\n+                                self.token.clone(),\n+                            ).map(|ap| (Some(ap.ty), Some(ap.name)))\n+                            .unwrap_or((None, None))\n+                        },\n+                        ast::RecordExprFieldList(it) => {\n+                            cov_mark::hit!(expected_type_struct_field_without_leading_char);\n+                            self.token.prev_sibling_or_token()\n+                                .and_then(|se| se.into_node())\n+                                .and_then(|node| ast::RecordExprField::cast(node))\n+                                .and_then(|rf| self.sema.resolve_record_field(&rf))\n+                                .map(|f|(\n+                                    Some(f.0.signature_ty(self.db)),\n+                                    Some(f.0.name(self.db).to_string()),\n+                                ))\n+                                .unwrap_or((None, None))\n+                        },\n+                        ast::RecordExprField(it) => {\n+                            cov_mark::hit!(expected_type_struct_field_with_leading_char);\n+                            self.sema\n+                                .resolve_record_field(&it)\n+                                .map(|f|(\n+                                    Some(f.0.signature_ty(self.db)),\n+                                    Some(f.0.name(self.db).to_string()),\n+                                ))\n+                                .unwrap_or((None, None))\n+                        },\n+                        ast::MatchExpr(it) => {\n+                            cov_mark::hit!(expected_type_match_arm_without_leading_char);\n+                            let ty = it.expr()\n+                                .and_then(|e| self.sema.type_of_expr(&e));\n+\n+                            (ty, None)\n+                        },\n+                        ast::IdentPat(it) => {\n+                            cov_mark::hit!(expected_type_if_let_with_leading_char);\n+                            cov_mark::hit!(expected_type_if_let_without_leading_char);\n+                            cov_mark::hit!(expected_type_match_arm_with_leading_char);\n+                            let ty = self.sema.type_of_pat(&ast::Pat::from(it));\n+\n+                            (ty, None)\n+                        },\n+                        ast::Fn(it) => {\n+                            cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n+                            cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n+                            let ty = self.token.ancestors()\n+                                .find_map(|ancestor| ast::Expr::cast(ancestor))\n+                                .and_then(|expr| self.sema.type_of_expr(&expr));\n+\n+                            (ty, None)\n+                        },\n+                        _ => {\n+                            match node.parent() {\n+                                Some(n) => {\n+                                    node = n;\n+                                    continue;\n+                                },\n+                                None => (None, None),\n+                            }\n+                        },\n                     }\n                 };\n-                Some(ty)\n-            })\n-            .flatten();\n+\n+                break ret;\n+            }\n+        };\n+        self.expected_type = expected.0;\n+        self.expected_name = expected.1;\n         self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n \n         // First, let's try to complete a reference to some declaration.\n@@ -535,3 +610,197 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<ast::Path> {\n     let use_tree = use_tree_list.syntax().parent().and_then(ast::UseTree::cast)?;\n     use_tree.path()\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+    use hir::HirDisplay;\n+\n+    use crate::test_utils::{position, TEST_CONFIG};\n+\n+    use super::CompletionContext;\n+\n+    fn check_expected_type_and_name(ra_fixture: &str, expect: Expect) {\n+        let (db, pos) = position(ra_fixture);\n+        let completion_context = CompletionContext::new(&db, pos, &TEST_CONFIG).unwrap();\n+\n+        let ty = completion_context\n+            .expected_type\n+            .map(|t| t.display_test(&db).to_string())\n+            .unwrap_or(\"?\".to_owned());\n+\n+        let name = completion_context.expected_name.unwrap_or(\"?\".to_owned());\n+\n+        expect.assert_eq(&format!(\"ty: {}, name: {}\", ty, name));\n+    }\n+\n+    #[test]\n+    fn expected_type_let_without_leading_char() {\n+        cov_mark::check!(expected_type_let_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() {\n+    let x: u32 = $0;\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: x\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_let_with_leading_char() {\n+        cov_mark::check!(expected_type_let_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() {\n+    let x: u32 = c$0;\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: x\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_param_without_leading_char() {\n+        cov_mark::check!(expected_type_fn_param_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() {\n+    bar($0);\n+}\n+\n+fn bar(x: u32) {}\n+\"#,\n+            expect![[r#\"ty: u32, name: x\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_param_with_leading_char() {\n+        cov_mark::check!(expected_type_fn_param_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() {\n+    bar(c$0);\n+}\n+\n+fn bar(x: u32) {}\n+\"#,\n+            expect![[r#\"ty: u32, name: x\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_struct_field_without_leading_char() {\n+        cov_mark::check!(expected_type_struct_field_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: $0 };\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: a\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn expected_type_struct_field_with_leading_char() {\n+        cov_mark::check!(expected_type_struct_field_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: c$0 };\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: a\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_match_arm_without_leading_char() {\n+        cov_mark::check!(expected_type_match_arm_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+enum E { X }\n+fn foo() {\n+   match E::X { $0 }\n+}\n+\"#,\n+            expect![[r#\"ty: E, name: ?\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_match_arm_with_leading_char() {\n+        cov_mark::check!(expected_type_match_arm_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+enum E { X }\n+fn foo() {\n+   match E::X { c$0 }\n+}\n+\"#,\n+            expect![[r#\"ty: E, name: ?\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_if_let_without_leading_char() {\n+        cov_mark::check!(expected_type_if_let_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+enum Foo { Bar, Baz, Quux }\n+\n+fn foo() {\n+    let f = Foo::Quux;\n+    if let $0 = f { }\n+}\n+\"#,\n+            expect![[r#\"ty: (), name: ?\"#]],\n+        ) // FIXME should be `ty: u32, name: ?`\n+    }\n+\n+    #[test]\n+    fn expected_type_if_let_with_leading_char() {\n+        cov_mark::check!(expected_type_if_let_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+enum Foo { Bar, Baz, Quux }\n+\n+fn foo() {\n+    let f = Foo::Quux;\n+    if let c$0 = f { }\n+}\n+\"#,\n+            expect![[r#\"ty: Foo, name: ?\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_ret_without_leading_char() {\n+        cov_mark::check!(expected_type_fn_ret_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() -> u32 {\n+    $0\n+}\n+\"#,\n+            expect![[r#\"ty: (), name: ?\"#]],\n+        ) // FIXME this should be `ty: u32, name: ?`\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_ret_with_leading_char() {\n+        cov_mark::check!(expected_type_fn_ret_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() -> u32 {\n+    c$0\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: ?\"#]],\n+        )\n+    }\n+}"}, {"sha": "3e1bff4d66673ccaa9dd54092bf8920a8a1c29a7", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d91151c3b1af6d4e4c29f5f82df8566b046266e3/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91151c3b1af6d4e4c29f5f82df8566b046266e3/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=d91151c3b1af6d4e4c29f5f82df8566b046266e3", "patch": "@@ -119,17 +119,10 @@ impl<'a> RenderContext<'a> {\n         node.docs(self.db())\n     }\n \n+    // FIXME delete this method in favor of directly using the fields\n+    // on CompletionContext\n     fn expected_name_and_type(&self) -> Option<(String, Type)> {\n-        if let Some(record_field) = &self.completion.record_field_syntax {\n-            cov_mark::hit!(record_field_type_match);\n-            let (struct_field, _local) = self.completion.sema.resolve_record_field(record_field)?;\n-            Some((struct_field.name(self.db()).to_string(), struct_field.signature_ty(self.db())))\n-        } else if let Some(active_parameter) = &self.completion.active_parameter {\n-            cov_mark::hit!(active_param_type_match);\n-            Some((active_parameter.name.clone(), active_parameter.ty.clone()))\n-        } else {\n-            None\n-        }\n+        Some((self.completion.expected_name.clone()?, self.completion.expected_type.clone()?))\n     }\n }\n \n@@ -852,7 +845,6 @@ fn foo(xs: Vec<i128>)\n \n     #[test]\n     fn active_param_relevance() {\n-        cov_mark::check!(active_param_type_match);\n         check_relevance(\n             r#\"\n struct S { foo: i64, bar: u32, baz: u32 }\n@@ -869,7 +861,6 @@ fn foo(s: S) { test(s.$0) }\n \n     #[test]\n     fn record_field_relevances() {\n-        cov_mark::check!(record_field_type_match);\n         check_relevance(\n             r#\"\n struct A { foo: i64, bar: u32, baz: u32 }"}]}