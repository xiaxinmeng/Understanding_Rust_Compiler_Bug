{"sha": "f130e7d9db5834908a8457d6287f7e95addc2d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMzBlN2Q5ZGI1ODM0OTA4YTg0NTdkNjI4N2Y3ZTk1YWRkYzJkMjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-18T14:55:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-19T14:39:00Z"}, "message": "revamp the Compiler Process section to be more up to date", "tree": {"sha": "1a309ab5853a00fce6e46b4977b1169c7e4ed6d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a309ab5853a00fce6e46b4977b1169c7e4ed6d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f130e7d9db5834908a8457d6287f7e95addc2d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f130e7d9db5834908a8457d6287f7e95addc2d21", "html_url": "https://github.com/rust-lang/rust/commit/f130e7d9db5834908a8457d6287f7e95addc2d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f130e7d9db5834908a8457d6287f7e95addc2d21/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70db841aa075aed5b988ff126bf34a1f43b314f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/70db841aa075aed5b988ff126bf34a1f43b314f7", "html_url": "https://github.com/rust-lang/rust/commit/70db841aa075aed5b988ff126bf34a1f43b314f7"}], "stats": {"total": 190, "additions": 74, "deletions": 116}, "files": [{"sha": "e72acb43fba5e4bf44423b8cbdcac56a4bd403d6", "filename": "src/librustc/README.md", "status": "modified", "additions": 74, "deletions": 116, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/f130e7d9db5834908a8457d6287f7e95addc2d21/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f130e7d9db5834908a8457d6287f7e95addc2d21/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=f130e7d9db5834908a8457d6287f7e95addc2d21", "patch": "@@ -91,121 +91,69 @@ better than others).\n The compiler process\n ====================\n \n-The Rust compiler is comprised of six main compilation phases.\n-\n-1. Parsing input\n-2. Configuration & expanding (cfg rules & syntax extension expansion)\n-3. Running analysis passes\n-4. Translation to LLVM\n-5. LLVM passes\n-6. Linking\n-\n-Phase one is responsible for parsing & lexing the input to the compiler. The\n-output of this phase is an abstract syntax tree (AST). The AST at this point\n-includes all macro uses & attributes. This means code which will be later\n-expanded and/or removed due to `cfg` attributes is still present in this\n-version of the AST. Parsing abstracts away details about individual files which\n-have been read into the AST.\n-\n-Phase two handles configuration and macro expansion. You can think of this\n-phase as a function acting on the AST from the previous phase. The input for\n-this phase is the unexpanded AST from phase one, and the output is an expanded\n-version of the same AST. This phase will expand all macros & syntax\n-extensions and will evaluate all `cfg` attributes, potentially removing some\n-code. The resulting AST will not contain any macros or `macro_use` statements.\n-\n-The code for these first two phases is in [`libsyntax`][libsyntax].\n-\n-After this phase, the compiler allocates IDs to each node in the AST\n-(technically not every node, but most of them). If we are writing out\n-dependencies, that happens now.\n-\n-The third phase is analysis. This is the most complex phase in the compiler,\n-and makes up much of the code. This phase included name resolution, type\n-checking, borrow checking, type & lifetime inference, trait selection, method\n-selection, linting and so on. Most of the error detection in the compiler comes\n-from this phase (with the exception of parse errors which arise during\n-parsing). The \"output\" of this phase is a set of side tables containing\n-semantic information about the source program. The analysis code is in\n-[`librustc`][rustc] and some other crates with the `librustc_` prefix.\n-\n-The fourth phase is translation. This phase translates the AST (and the side\n-tables from the previous phase) into LLVM IR (intermediate representation).\n-This is achieved by calling into the LLVM libraries. The code for this is in\n-[`librustc_trans`][trans].\n-\n-Phase five runs the LLVM backend. This runs LLVM's optimization passes on the\n-generated IR and generates machine code resulting in object files. This phase\n-is not really part of the Rust compiler, as LLVM carries out all the work.\n-The interface between LLVM and Rust is in [`librustc_llvm`][llvm].\n-\n-The final phase, phase six, links the object files into an executable. This is\n-again outsourced to other tools and not performed by the Rust compiler\n-directly. The interface is in [`librustc_back`][back] (which also contains some\n-things used primarily during translation).\n-\n-A module called the driver coordinates all these phases. It handles all the\n-highest level coordination of compilation from parsing command line arguments\n-all the way to invoking the linker to produce an executable.\n-\n-Modules in the librustc crate\n-=============================\n-\n-The librustc crate itself consists of the following submodules\n-(mostly, but not entirely, in their own directories):\n-\n-- session: options and data that pertain to the compilation session as\n-  a whole\n-- middle: middle-end: name resolution, typechecking, LLVM code\n-  generation\n-- metadata: encoder and decoder for data required by separate\n-  compilation\n-- plugin: infrastructure for compiler plugins\n-- lint: infrastructure for compiler warnings\n-- util: ubiquitous types and helper functions\n-- lib: bindings to LLVM\n-\n-The entry-point for the compiler is main() in the [`librustc_driver`][driver]\n-crate.\n-\n-The 3 central data structures:\n-------------------------------\n-\n-1. `./../libsyntax/ast.rs` defines the AST. The AST is treated as\n-   immutable after parsing, but it depends on mutable context data\n-   structures (mainly hash maps) to give it meaning.\n-\n-   - Many \u2013 though not all \u2013 nodes within this data structure are\n-     wrapped in the type `spanned<T>`, meaning that the front-end has\n-     marked the input coordinates of that node. The member `node` is\n-     the data itself, the member `span` is the input location (file,\n-     line, column; both low and high).\n-\n-   - Many other nodes within this data structure carry a\n-     `def_id`. These nodes represent the 'target' of some name\n-     reference elsewhere in the tree. When the AST is resolved, by\n-     `middle/resolve.rs`, all names wind up acquiring a def that they\n-     point to. So anything that can be pointed-to by a name winds\n-     up with a `def_id`.\n-\n-2. `middle/ty.rs` defines the datatype `sty`. This is the type that\n-   represents types after they have been resolved and normalized by\n-   the middle-end. The typeck phase converts every ast type to a\n-   `ty::sty`, and the latter is used to drive later phases of\n-   compilation. Most variants in the `ast::ty` tag have a\n-   corresponding variant in the `ty::sty` tag.\n-\n-3. `./../librustc_llvm/lib.rs` defines the exported types\n-   `ValueRef`, `TypeRef`, `BasicBlockRef`, and several others.\n-   Each of these is an opaque pointer to an LLVM type,\n-   manipulated through the `lib::llvm` interface.\n-\n-[libsyntax]: https://github.com/rust-lang/rust/tree/master/src/libsyntax/\n-[trans]: https://github.com/rust-lang/rust/tree/master/src/librustc_trans/\n-[llvm]: https://github.com/rust-lang/rust/tree/master/src/librustc_llvm/\n-[back]: https://github.com/rust-lang/rust/tree/master/src/librustc_back/\n-[rustc]: https://github.com/rust-lang/rust/tree/master/src/librustc/\n-[driver]: https://github.com/rust-lang/rust/tree/master/src/librustc_driver\n+The Rust compiler is in a bit of transition right now. It used to be a\n+purely \"pass-based\" compiler, where we ran a number of passes over the\n+entire program, and each did a particular check of transformation.\n+\n+We are gradually replacing this pass-based code with an alternative\n+setup based on on-demand **queries**. In the query-model, we work\n+backwards, executing a *query* that expresses our ultimate goal (e.g.,\n+\"compiler this crate\"). This query in turn may make other queries\n+(e.g., \"get me a list of all modules in the crate\"). Those queries\n+make other queries that ultimately bottom out in the base operations,\n+like parsing the input, running the type-checker, and so forth. This\n+on-demand model permits us to do exciting things like only do the\n+minimal amount of work needed to type-check a single function. It also\n+helps with incremental compilation. (For details on defining queries,\n+check out `src/librustc/ty/maps/README.md`.)\n+\n+Regardless of the general setup, the basic operations that the\n+compiler must perform are the same. The only thing that changes is\n+whether these operations are invoked front-to-back, or on demand.  In\n+order to compile a Rust crate, these are the general steps that we\n+take:\n+\n+1. **Parsing input**\n+    - this processes the `.rs` files and produces the AST (\"abstract syntax tree\")\n+    - the AST is defined in `syntax/ast.rs`. It is intended to match the lexical\n+      syntax of the Rust language quite closely.\n+2. **Name resolution, macro expansion, and configuration**\n+    - once parsing is complete, we process the AST recursively, resolving paths\n+      and expanding macros. This same process also processes `#[cfg]` nodes, and hence\n+      may strip things out of the AST as well.\n+3. **Lowering to HIR**\n+    - Once name resolution completes, we convert the AST into the HIR,\n+      or \"high-level IR\". The HIR is defined in `src/librustc/hir/`; that module also includes\n+      the lowering code.\n+    - The HIR is a lightly desugared variant of the AST. It is more processed than the\n+      AST and more suitable for the analyses that follow. It is **not** required to match\n+      the syntax of the Rust language.\n+    - As a simple example, in the **AST**, we preserve the parentheses\n+      that the user wrote, so `((1 + 2) + 3)` and `1 + 2 + 3` parse\n+      into distinct trees, even though they are equivalent. In the\n+      HIR, however, parentheses nodes are removed, and those two\n+      expressions are represented in the same way.\n+3. **Type-checking and subsequent analyses**\n+    - An important step in processing the HIR is to perform type\n+      checking. This process assigns types to every HIR expression,\n+      for example, and also is responsible for resolving some\n+      \"type-dependent\" paths, such as field accesses (`x.f` -- we\n+      can't know what field `f` is being accessed until we know the\n+      type of `x`) and associated type references (`T::Item` -- we\n+      can't know what type `Item` is until we know what `T` is).\n+    - Type checking creates \"side-tables\" (`TypeckTables`) that include\n+      the types of expressions, the way to resolve methods, and so forth.\n+    - After type-checking, we can do other analyses, such as privacy checking.\n+4. **Lowering to MIR and post-processing**\n+    - Once type-checking is done, we can lower the HIR into MIR (\"middle IR\"), which\n+      is a **very** desugared version of Rust, well suited to the borrowck but also\n+      certain high-level optimizations. \n+5. **Translation to LLVM and LLVM optimizations**\n+    - From MIR, we can produce LLVM IR.\n+    - LLVM then runs its various optimizations, which produces a number of `.o` files\n+      (one for each \"codegen unit\").\n+6. **Linking**\n+    - Finally, those `.o` files are linke together.\n \n Glossary\n ========\n@@ -215,9 +163,15 @@ things. This glossary attempts to list them and give you a few\n pointers for understanding them better.\n \n - AST -- the **abstract syntax tree** produced the `syntax` crate; reflects user syntax\n-  very closely.\n+  very closely. \n+- codegen unit -- when we produce LLVM IR, we group the Rust code into a number of codegen\n+  units. Each of these units is processed by LLVM independently from one another,\n+  enabling parallelism. They are also the unit of incremental re-use. \n - cx -- we tend to use \"cx\" as an abbrevation for context. See also tcx, infcx, etc.\n+- `DefId` -- an index identifying a **definition** (see `librustc/hir/def_id.rs`).\n - HIR -- the **High-level IR**, created by lowering and desugaring the AST. See `librustc/hir`.\n+- `HirId` -- identifies a particular node in the HIR by combining a\n+  def-id with an \"intra-definition offset\".\n - `'gcx` -- the lifetime of the global arena (see `librustc/ty`).\n - generics -- the set of generic type parameters defined on a type or item\n - infcx -- the inference context (see `librustc/infer`)\n@@ -226,9 +180,13 @@ pointers for understanding them better.\n   found in `src/librustc_mir`.\n - obligation -- something that must be proven by the trait system; see `librustc/traits`.\n - local crate -- the crate currently being compiled.\n+- node-id or `NodeId` -- an index identifying a particular node in the\n+  AST or HIR; gradually being phased out.\n - query -- perhaps some sub-computation during compilation; see `librustc/maps`.\n - provider -- the function that executes a query; see `librustc/maps`.\n - sess -- the **compiler session**, which stores global data used throughout compilation\n+- side tables -- because the AST and HIR are immutable once created, we often carry extra\n+  information about them in the form of hashtables, indexed by the id of a particular node.\n - substs -- the **substitutions** for a given generic type or item\n   (e.g., the `i32, u32` in `HashMap<i32, u32>`)\n - tcx -- the \"typing context\", main data structure of the compiler (see `librustc/ty`)."}]}