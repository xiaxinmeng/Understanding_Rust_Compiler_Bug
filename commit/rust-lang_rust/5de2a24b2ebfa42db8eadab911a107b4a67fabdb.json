{"sha": "5de2a24b2ebfa42db8eadab911a107b4a67fabdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZTJhMjRiMmViZmE0MmRiOGVhZGFiOTExYTEwN2I0YTY3ZmFiZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-03T03:23:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-03T03:23:35Z"}, "message": "Auto merge of #39287 - wesleywiser:move_cell, r=aturon\n\nExtend Cell to work with non-Copy types\n\nI'm not sure that I did this right but all of the tests pass.\n\nI also had to move the `new()` function so that `Cell`s with non-`Copy` `T`s could be created. That wasn't in the RFC but I assume it needed to be done?", "tree": {"sha": "801d474d204637340ba30ed2521d68f2c9abdf63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/801d474d204637340ba30ed2521d68f2c9abdf63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5de2a24b2ebfa42db8eadab911a107b4a67fabdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5de2a24b2ebfa42db8eadab911a107b4a67fabdb", "html_url": "https://github.com/rust-lang/rust/commit/5de2a24b2ebfa42db8eadab911a107b4a67fabdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f294e4c186b461ee8fc28c75d4216822a535d7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f294e4c186b461ee8fc28c75d4216822a535d7a", "html_url": "https://github.com/rust-lang/rust/commit/7f294e4c186b461ee8fc28c75d4216822a535d7a"}, {"sha": "8b947a37c8bf396cf80c3790f68253c97d435250", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b947a37c8bf396cf80c3790f68253c97d435250", "html_url": "https://github.com/rust-lang/rust/commit/8b947a37c8bf396cf80c3790f68253c97d435250"}], "stats": {"total": 193, "additions": 147, "deletions": 46}, "files": [{"sha": "17741cac10b78c88fd3cdabc30ef24b6fd9429b8", "filename": "src/doc/book/choosing-your-guarantees.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md?ref=5de2a24b2ebfa42db8eadab911a107b4a67fabdb", "patch": "@@ -118,7 +118,8 @@ These types are _generally_ found in struct fields, but they may be found elsewh\n \n ## `Cell<T>`\n \n-[`Cell<T>`][cell] is a type that provides zero-cost interior mutability, but only for `Copy` types.\n+[`Cell<T>`][cell] is a type that provides zero-cost interior mutability by moving data in and\n+out of the cell.\n Since the compiler knows that all the data owned by the contained value is on the stack, there's\n no worry of leaking any data behind references (or worse!) by simply replacing the data.\n \n@@ -160,24 +161,25 @@ This relaxes the &ldquo;no aliasing with mutability&rdquo; restriction in places\n unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your\n invariants depend on data stored within `Cell`, you should be careful.\n \n-This is useful for mutating primitives and other `Copy` types when there is no easy way of\n+This is useful for mutating primitives and other types when there is no easy way of\n doing it in line with the static rules of `&` and `&mut`.\n \n `Cell` does not let you obtain interior references to the data, which makes it safe to freely\n mutate.\n \n #### Cost\n \n-There is no runtime cost to using `Cell<T>`, however if you are using it to wrap larger (`Copy`)\n+There is no runtime cost to using `Cell<T>`, however if you are using it to wrap larger\n structs, it might be worthwhile to instead wrap individual fields in `Cell<T>` since each write is\n otherwise a full copy of the struct.\n \n \n ## `RefCell<T>`\n \n-[`RefCell<T>`][refcell] also provides interior mutability, but isn't restricted to `Copy` types.\n+[`RefCell<T>`][refcell] also provides interior mutability, but doesn't move data in and out of the\n+cell.\n \n-Instead, it has a runtime cost. `RefCell<T>` enforces the read-write lock pattern at runtime (it's\n+However, it has a runtime cost. `RefCell<T>` enforces the read-write lock pattern at runtime (it's\n like a single-threaded mutex), unlike `&T`/`&mut T` which do so at compile time. This is done by the\n `borrow()` and `borrow_mut()` functions, which modify an internal reference count and return smart\n pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when"}, {"sha": "ab44342ebf02fda0daf228f3f1abc524c9106c54", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 108, "deletions": 41, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=5de2a24b2ebfa42db8eadab911a107b4a67fabdb", "patch": "@@ -15,10 +15,18 @@\n //! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\n //! with typical Rust types that exhibit 'inherited mutability'.\n //!\n-//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` provides `get` and `set`\n-//! methods that change the interior value with a single method call. `Cell<T>` though is only\n-//! compatible with types that implement `Copy`. For other types, one must use the `RefCell<T>`\n-//! type, acquiring a write lock before mutating.\n+//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` implements interior\n+//! mutability by moving values in and out of the `Cell<T>`. To use references instead of values,\n+//! one must use the `RefCell<T>` type, acquiring a write lock before mutating. `Cell<T>` provides\n+//! methods to retrieve and change the current interior value:\n+//!\n+//!  - For types that implement `Copy`, the `get` method retrieves the current interior value.\n+//!  - For types that implement `Default`, the `take` method replaces the current interior value\n+//!    with `Default::default()` and returns the replaced value.\n+//!  - For all types, the `replace` method replaces the current interior value and returns the\n+//!    replaced value and the `into_inner` method consumes the `Cell<T>` and returns the interior\n+//!    value. Additionally, the `set` method replaces the interior value, dropping the replaced\n+//!    value.\n //!\n //! `RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can\n //! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n@@ -176,9 +184,10 @@\n use cmp::Ordering;\n use fmt::{self, Debug, Display};\n use marker::Unsize;\n+use mem;\n use ops::{Deref, DerefMut, CoerceUnsized};\n \n-/// A mutable memory location that admits only `Copy` data.\n+/// A mutable memory location.\n ///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -187,23 +196,6 @@ pub struct Cell<T> {\n }\n \n impl<T:Copy> Cell<T> {\n-    /// Creates a new `Cell` containing the given value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub const fn new(value: T) -> Cell<T> {\n-        Cell {\n-            value: UnsafeCell::new(value),\n-        }\n-    }\n-\n     /// Returns a copy of the contained value.\n     ///\n     /// # Examples\n@@ -221,25 +213,6 @@ impl<T:Copy> Cell<T> {\n         unsafe{ *self.value.get() }\n     }\n \n-    /// Sets the contained value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    ///\n-    /// c.set(10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set(&self, value: T) {\n-        unsafe {\n-            *self.value.get() = value;\n-        }\n-    }\n-\n     /// Returns a reference to the underlying `UnsafeCell`.\n     ///\n     /// # Examples\n@@ -378,6 +351,100 @@ impl<T: Copy> From<T> for Cell<T> {\n     }\n }\n \n+impl<T> Cell<T> {\n+    /// Creates a new `Cell` containing the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub const fn new(value: T) -> Cell<T> {\n+        Cell {\n+            value: UnsafeCell::new(value),\n+        }\n+    }\n+\n+    /// Sets the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// c.set(10);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn set(&self, val: T) {\n+        let old = self.replace(val);\n+        drop(old);\n+    }\n+\n+    /// Replaces the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(move_cell)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let old = c.replace(10);\n+    ///\n+    /// assert_eq!(5, old);\n+    /// ```\n+    #[unstable(feature = \"move_cell\", issue = \"39264\")]\n+    pub fn replace(&self, val: T) -> T {\n+        mem::replace(unsafe { &mut *self.value.get() }, val)\n+    }\n+\n+    /// Unwraps the value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(move_cell)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let five = c.into_inner();\n+    ///\n+    /// assert_eq!(five, 5);\n+    /// ```\n+    #[unstable(feature = \"move_cell\", issue = \"39264\")]\n+    pub fn into_inner(self) -> T {\n+        unsafe { self.value.into_inner() }\n+    }\n+}\n+\n+impl<T: Default> Cell<T> {\n+    /// Takes the value of the cell, leaving `Default::default()` in its place.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(move_cell)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let five = c.take();\n+    ///\n+    /// assert_eq!(five, 5);\n+    /// assert_eq!(c.into_inner(), 0);\n+    /// ```\n+    #[unstable(feature = \"move_cell\", issue = \"39264\")]\n+    pub fn take(&self) -> T {\n+        self.replace(Default::default())\n+    }\n+}\n+\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<Cell<U>> for Cell<T> {}\n "}, {"sha": "8585f2f08711332a3e5af0fa53145df9e1b657ec", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=5de2a24b2ebfa42db8eadab911a107b4a67fabdb", "patch": "@@ -209,6 +209,37 @@ fn cell_default() {\n     assert_eq!(0, cell.get());\n }\n \n+#[test]\n+fn cell_set() {\n+    let cell = Cell::new(10);\n+    cell.set(20);\n+    assert_eq!(20, cell.get());\n+\n+    let cell = Cell::new(\"Hello\".to_owned());\n+    cell.set(\"World\".to_owned());\n+    assert_eq!(\"World\".to_owned(), cell.into_inner());\n+}\n+\n+#[test]\n+fn cell_replace() {\n+    let cell = Cell::new(10);\n+    assert_eq!(10, cell.replace(20));\n+    assert_eq!(20, cell.get());\n+\n+    let cell = Cell::new(\"Hello\".to_owned());\n+    assert_eq!(\"Hello\".to_owned(), cell.replace(\"World\".to_owned()));\n+    assert_eq!(\"World\".to_owned(), cell.into_inner());\n+}\n+\n+#[test]\n+fn cell_into_inner() {\n+    let cell = Cell::new(10);\n+    assert_eq!(10, cell.into_inner());\n+\n+    let cell = Cell::new(\"Hello world\".to_owned());\n+    assert_eq!(\"Hello world\".to_owned(), cell.into_inner());\n+}\n+\n #[test]\n fn refcell_default() {\n     let cell: RefCell<u64> = Default::default();"}, {"sha": "87f3afd6889d332b5941a2e17510a27994e67f07", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de2a24b2ebfa42db8eadab911a107b4a67fabdb/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=5de2a24b2ebfa42db8eadab911a107b4a67fabdb", "patch": "@@ -33,6 +33,7 @@\n #![feature(unique)]\n #![feature(ordering_chaining)]\n #![feature(ptr_unaligned)]\n+#![feature(move_cell)]\n \n extern crate core;\n extern crate test;"}]}