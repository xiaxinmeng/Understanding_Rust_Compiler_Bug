{"sha": "8d272321417df3a954802e42a66adda87ade5a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMjcyMzIxNDE3ZGYzYTk1NDgwMmU0MmE2NmFkZGE4N2FkZTVhNDk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-30T05:08:39Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-08-14T15:53:25Z"}, "message": "librustc: Tie up loose ends in unboxed closures.\n\nThis patch primarily does two things: (1) it prevents lifetimes from\nleaking out of unboxed closures; (2) it allows unboxed closure type\nnotation, call notation, and construction notation to construct closures\nmatching any of the three traits.\n\nThis breaks code that looked like:\n\n    let mut f;\n    {\n        let x = &5i;\n        f = |&mut:| *x + 10;\n    }\n\nChange this code to avoid having a reference escape. For example:\n\n    {\n        let x = &5i;\n        let mut f; // <-- move here to avoid dangling reference\n        f = |&mut:| *x + 10;\n    }\n\nI believe this is enough to consider unboxed closures essentially\nimplemented. Further issues (for example, higher-rank lifetimes) should\nbe filed as followups.\n\nCloses #14449.\n\n[breaking-change]", "tree": {"sha": "bb73f130dbe32e8a4714319e5c793702a02a53e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb73f130dbe32e8a4714319e5c793702a02a53e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d272321417df3a954802e42a66adda87ade5a49", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d272321417df3a954802e42a66adda87ade5a49", "html_url": "https://github.com/rust-lang/rust/commit/8d272321417df3a954802e42a66adda87ade5a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d272321417df3a954802e42a66adda87ade5a49/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "html_url": "https://github.com/rust-lang/rust/commit/9d45d63d0d18f21f74c8a2a4e5367a785932f64e"}], "stats": {"total": 1133, "additions": 835, "deletions": 298}, "files": [{"sha": "fdfbdea245bb20226ec11b5a8b511e9da02590e1", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -314,7 +314,7 @@ impl<'a> Visitor<()> for Context<'a> {\n \n             },\n             ast::TyBox(_) => { self.gate_box(t.span); }\n-            ast::TyUnboxedFn(_) => {\n+            ast::TyUnboxedFn(..) => {\n                 self.gate_feature(\"unboxed_closure_sugar\",\n                                   t.span,\n                                   \"unboxed closure trait sugar is experimental\");"}, {"sha": "7d0a21b2f8e428d6cb4425f9fd5cfe3601dd0f4e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -139,7 +139,7 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_adjustments = 0x51,\n     tag_table_moves_map = 0x52,\n     tag_table_capture_map = 0x53,\n-    tag_table_unboxed_closure_type = 0x54,\n+    tag_table_unboxed_closures = 0x54,\n     tag_table_upvar_borrow_map = 0x55,\n     tag_table_capture_modes = 0x56,\n }\n@@ -229,9 +229,11 @@ pub static tag_region_param_def_index: uint = 0x94;\n pub static tag_unboxed_closures: uint = 0x95;\n pub static tag_unboxed_closure: uint = 0x96;\n pub static tag_unboxed_closure_type: uint = 0x97;\n+pub static tag_unboxed_closure_kind: uint = 0x98;\n \n-pub static tag_struct_fields: uint = 0x98;\n-pub static tag_struct_field: uint = 0x99;\n-pub static tag_struct_field_id: uint = 0x9a;\n+pub static tag_struct_fields: uint = 0x99;\n+pub static tag_struct_field: uint = 0x9a;\n+pub static tag_struct_field_id: uint = 0x9b;\n+\n+pub static tag_attribute_is_sugared_doc: uint = 0x9c;\n \n-pub static tag_attribute_is_sugared_doc: uint = 0x9b;"}, {"sha": "1b47227fea403878800fbef0a22eb869c7887067", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -630,6 +630,18 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: Visibility) {\n     rbml_w.end_tag();\n }\n \n+fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n+                               kind: ty::UnboxedClosureKind) {\n+    rbml_w.start_tag(tag_unboxed_closure_kind);\n+    let ch = match kind {\n+        ty::FnUnboxedClosureKind => 'f',\n+        ty::FnMutUnboxedClosureKind => 'm',\n+        ty::FnOnceUnboxedClosureKind => 'o',\n+    };\n+    rbml_w.wr_str(ch.to_string().as_slice());\n+    rbml_w.end_tag();\n+}\n+\n fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n     rbml_w.start_tag(tag_item_trait_method_explicit_self);\n@@ -1629,17 +1641,20 @@ fn encode_unboxed_closures<'a>(\n                            ecx: &'a EncodeContext,\n                            rbml_w: &'a mut Encoder) {\n     rbml_w.start_tag(tag_unboxed_closures);\n-    for (unboxed_closure_id, unboxed_closure_type) in\n-            ecx.tcx.unboxed_closure_types.borrow().iter() {\n+    for (unboxed_closure_id, unboxed_closure) in ecx.tcx\n+                                                    .unboxed_closures\n+                                                    .borrow()\n+                                                    .iter() {\n         if unboxed_closure_id.krate != LOCAL_CRATE {\n             continue\n         }\n \n         rbml_w.start_tag(tag_unboxed_closure);\n         encode_def_id(rbml_w, *unboxed_closure_id);\n         rbml_w.start_tag(tag_unboxed_closure_type);\n-        write_closure_type(ecx, rbml_w, unboxed_closure_type);\n+        write_closure_type(ecx, rbml_w, &unboxed_closure.closure_type);\n         rbml_w.end_tag();\n+        encode_unboxed_closure_kind(rbml_w, unboxed_closure.kind);\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();"}, {"sha": "e6e7d8bf8d1a63de55d13de394233fef1cea65fc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -432,7 +432,8 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'k' => {\n           let did = parse_def(st, NominalType, |x,y| conv(x,y));\n-          return ty::mk_unboxed_closure(st.tcx, did);\n+          let region = parse_region(st, conv);\n+          return ty::mk_unboxed_closure(st.tcx, did, region);\n       }\n       'e' => {\n           return ty::mk_err();"}, {"sha": "fc5e267aa90500fdf16700f92e8642c73464622a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -285,8 +285,9 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_unboxed_closure(def) => {\n+        ty::ty_unboxed_closure(def, region) => {\n             mywrite!(w, \"k{}\", (cx.ds)(def));\n+            enc_region(w, cx, region);\n         }\n         ty::ty_err => {\n             mywrite!(w, \"e\");"}, {"sha": "b1ce2ece4afe853ffa18392e4d1ec9d1a633dd5b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 62, "deletions": 19, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -689,10 +689,35 @@ pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n     }).unwrap()\n }\n \n+pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n+                                   kind: ty::UnboxedClosureKind) {\n+    ebml_w.emit_enum(\"UnboxedClosureKind\", |ebml_w| {\n+        match kind {\n+            ty::FnUnboxedClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnUnboxedClosureKind\", 0, 3, |_| {\n+                    Ok(())\n+                })\n+            }\n+            ty::FnMutUnboxedClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnMutUnboxedClosureKind\", 1, 3, |_| {\n+                    Ok(())\n+                })\n+            }\n+            ty::FnOnceUnboxedClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnOnceUnboxedClosureKind\",\n+                                         2,\n+                                         3,\n+                                         |_| {\n+                    Ok(())\n+                })\n+            }\n+        }\n+    }).unwrap()\n+}\n \n pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n-                        rbml_w: &mut Encoder,\n-                        vtable_origin: &typeck::vtable_origin) {\n+                            rbml_w: &mut Encoder,\n+                            vtable_origin: &typeck::vtable_origin) {\n     rbml_w.emit_enum(\"vtable_origin\", |rbml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref substs, ref vtable_res) => {\n@@ -1210,14 +1235,15 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for unboxed_closure_type in tcx.unboxed_closure_types\n-                                   .borrow()\n-                                   .find(&ast_util::local_def(id))\n-                                   .iter() {\n-        rbml_w.tag(c::tag_table_unboxed_closure_type, |rbml_w| {\n+    for unboxed_closure in tcx.unboxed_closures\n+                              .borrow()\n+                              .find(&ast_util::local_def(id))\n+                              .iter() {\n+        rbml_w.tag(c::tag_table_unboxed_closures, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_closure_type(ecx, *unboxed_closure_type)\n+                rbml_w.emit_closure_type(ecx, &unboxed_closure.closure_type);\n+                encode_unboxed_closure_kind(rbml_w, unboxed_closure.kind)\n             })\n         })\n     }\n@@ -1244,8 +1270,8 @@ trait rbml_decoder_decoder_helpers {\n                      -> ty::Polytype;\n     fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs;\n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n-    fn read_unboxed_closure_type(&mut self, xcx: &ExtendedDecodeContext)\n-                                 -> ty::ClosureTy;\n+    fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n+                            -> ty::UnboxedClosure;\n     fn convert_def_id(&mut self,\n                       xcx: &ExtendedDecodeContext,\n                       source: DefIdSource,\n@@ -1418,16 +1444,33 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure_type(&mut self, xcx: &ExtendedDecodeContext)\n-                                 -> ty::ClosureTy {\n-        self.read_opaque(|this, doc| {\n+    fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n+                            -> ty::UnboxedClosure {\n+        let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data(\n                 doc.data,\n                 xcx.dcx.cdata.cnum,\n                 doc.start,\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a)))\n-        }).unwrap()\n+        }).unwrap();\n+        let variants = [\n+            \"FnUnboxedClosureKind\",\n+            \"FnMutUnboxedClosureKind\",\n+            \"FnOnceUnboxedClosureKind\"\n+        ];\n+        let kind = self.read_enum_variant(variants, |_, i| {\n+            Ok(match i {\n+                0 => ty::FnUnboxedClosureKind,\n+                1 => ty::FnMutUnboxedClosureKind,\n+                2 => ty::FnOnceUnboxedClosureKind,\n+                _ => fail!(\"bad enum variant for ty::UnboxedClosureKind\"),\n+            })\n+        }).unwrap();\n+        ty::UnboxedClosure {\n+            closure_type: closure_type,\n+            kind: kind,\n+        }\n     }\n \n     fn convert_def_id(&mut self,\n@@ -1566,14 +1609,14 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(xcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n-                    c::tag_table_unboxed_closure_type => {\n-                        let unboxed_closure_type =\n-                            val_dsr.read_unboxed_closure_type(xcx);\n+                    c::tag_table_unboxed_closures => {\n+                        let unboxed_closure =\n+                            val_dsr.read_unboxed_closure(xcx);\n                         dcx.tcx\n-                           .unboxed_closure_types\n+                           .unboxed_closures\n                            .borrow_mut()\n                            .insert(ast_util::local_def(id),\n-                                   unboxed_closure_type);\n+                                   unboxed_closure);\n                     }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug("}, {"sha": "77dd7ed1c4204f1d8d25398a85d84c092d44d630", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -290,8 +290,9 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                     tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n-            ast::ExprProc(_decl, block) |\n-            ast::ExprFnBlock(_, _decl, block) => { block.id }\n+            ast::ExprProc(_, block) |\n+            ast::ExprFnBlock(_, _, block) |\n+            ast::ExprUnboxedFn(_, _, _, block) => { block.id }\n             _ => fail!(\"encountered non-closure id: {}\", closure_id)\n         },\n         _ => fail!(\"encountered non-expr id: {}\", closure_id)"}, {"sha": "12841fb20d26fdcf4161644f6bb63a538e6a68bf", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -48,7 +48,7 @@ impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n             }\n             ast::ExprFnBlock(_, _, ref b) |\n             ast::ExprProc(_, ref b) |\n-            ast::ExprUnboxedFn(_, _, ref b) => {\n+            ast::ExprUnboxedFn(_, _, _, ref b) => {\n                 self.visit_block(&**b, Closure);\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", cx, e.span),"}, {"sha": "1a2d21baa210a20e20a0f103f8dbb597177252a5", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -74,7 +74,7 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n                 self.capture_mode_map.insert(expr.id, capture_mode);\n                 visit::walk_expr(self, expr, depth + 1)\n             }\n-            ast::ExprUnboxedFn(capture_clause, _, _) => {\n+            ast::ExprUnboxedFn(capture_clause, _, _, _) => {\n                 let capture_mode = match capture_clause {\n                     ast::CaptureByValue => CaptureByValue,\n                     ast::CaptureByRef => CaptureByRef,"}, {"sha": "17b2c69f4531629bf9ca6e0260cd6a21585208e6", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -225,7 +225,7 @@ fn with_appropriate_checker(cx: &Context,\n             b(check_for_bare)\n         }\n \n-        ty::ty_unboxed_closure(_) => {}\n+        ty::ty_unboxed_closure(..) => {}\n \n         ref s => {\n             cx.tcx.sess.bug(format!(\"expect fn type in kind checker, not \\"}, {"sha": "baac68904d553308cc69f260806d4b1232018f8a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -967,7 +967,7 @@ impl<'a> Liveness<'a> {\n \n           ExprFnBlock(_, _, ref blk) |\n           ExprProc(_, ref blk) |\n-          ExprUnboxedFn(_, _, ref blk) => {\n+          ExprUnboxedFn(_, _, _, ref blk) => {\n               debug!(\"{} is an ExprFnBlock, ExprProc, or ExprUnboxedFn\",\n                      expr_to_string(expr));\n "}, {"sha": "ef1e0515156c038811fc4d6346b486bb049ccb41", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -66,7 +66,7 @@ use middle::def;\n use middle::freevars;\n use middle::ty;\n use middle::typeck;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{DefIdMap, NodeMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n@@ -273,6 +273,8 @@ pub trait Typer {\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> freevars::CaptureMode;\n+    fn unboxed_closures<'a>(&'a self)\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>>;\n }\n \n impl MutabilityCategory {\n@@ -598,13 +600,22 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                           }))\n                       }\n                   }\n-                  ty::ty_unboxed_closure(_) => {\n+                  ty::ty_unboxed_closure(closure_id, _) => {\n+                      let unboxed_closures = self.typer\n+                                                 .unboxed_closures()\n+                                                 .borrow();\n+                      let kind = unboxed_closures.get(&closure_id).kind;\n+                      let onceness = match kind {\n+                          ty::FnUnboxedClosureKind |\n+                          ty::FnMutUnboxedClosureKind => ast::Many,\n+                          ty::FnOnceUnboxedClosureKind => ast::Once,\n+                      };\n                       Ok(Rc::new(cmt_ {\n                           id: id,\n                           span: span,\n                           cat: cat_copied_upvar(CopiedUpvar {\n                               upvar_id: var_id,\n-                              onceness: ast::Many,\n+                              onceness: onceness,\n                               capturing_proc: fn_node_id,\n                           }),\n                           mutbl: MutabilityCategory::from_def(&def),"}, {"sha": "13a29842fcbb3f3331d399d033a7c4fd38814829", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -5289,7 +5289,7 @@ impl<'a> Resolver<'a> {\n \n             ExprFnBlock(_, fn_decl, block) |\n             ExprProc(fn_decl, block) |\n-            ExprUnboxedFn(_, fn_decl, block) => {\n+            ExprUnboxedFn(_, _, fn_decl, block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n                                       Some(fn_decl), NoTypeParameters,\n                                       block);"}, {"sha": "9c68631baa44c6f94a8032e6ebe3d0a2eda8ca26", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -170,7 +170,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n \n             return Univariant(mk_struct(cx, ftys.as_slice(), packed), dtor)\n         }\n-        ty::ty_unboxed_closure(def_id) => {\n+        ty::ty_unboxed_closure(def_id, _) => {\n             let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             return Univariant(mk_struct(cx, upvar_types.as_slice(), false),"}, {"sha": "16ba3ddbd70764af6d6bcc0b5f96473ea67ee8c6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -45,8 +45,8 @@ use middle::trans::adt;\n use middle::trans::build::*;\n use middle::trans::builder::{Builder, noname};\n use middle::trans::callee;\n+use middle::trans::cleanup::{CleanupMethods, ScopeId};\n use middle::trans::cleanup;\n-use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::controlflow;\n@@ -252,6 +252,31 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n     f\n }\n \n+pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n+                                     closure_id: ast::DefId)\n+                                     -> ty::t {\n+    let unboxed_closure_type = ty::mk_unboxed_closure(ccx.tcx(),\n+                                                      closure_id,\n+                                                      ty::ReStatic);\n+    let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+    let unboxed_closure = unboxed_closures.get(&closure_id);\n+    match unboxed_closure.kind {\n+        ty::FnUnboxedClosureKind => {\n+            ty::mk_imm_rptr(&ccx.tcx, ty::ReStatic, unboxed_closure_type)\n+        }\n+        ty::FnMutUnboxedClosureKind => {\n+            ty::mk_mut_rptr(&ccx.tcx, ty::ReStatic, unboxed_closure_type)\n+        }\n+        ty::FnOnceUnboxedClosureKind => unboxed_closure_type,\n+    }\n+}\n+\n+pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n+                                -> ty::UnboxedClosureKind {\n+    let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+    unboxed_closures.get(&closure_id).kind\n+}\n+\n pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     let (inputs, output, abi, env) = match ty::get(fn_ty).sty {\n         ty::ty_bare_fn(ref f) => {\n@@ -260,12 +285,12 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n         ty::ty_closure(ref f) => {\n             (f.sig.inputs.clone(), f.sig.output, f.abi, Some(Type::i8p(ccx)))\n         }\n-        ty::ty_unboxed_closure(closure_did) => {\n-            let unboxed_closure_types = ccx.tcx\n-                                           .unboxed_closure_types\n-                                           .borrow();\n-            let function_type = unboxed_closure_types.get(&closure_did);\n-            let llenvironment_type = type_of(ccx, fn_ty).ptr_to();\n+        ty::ty_unboxed_closure(closure_did, _) => {\n+            let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+            let unboxed_closure = unboxed_closures.get(&closure_did);\n+            let function_type = unboxed_closure.closure_type.clone();\n+            let self_type = self_type_for_unboxed_closure(ccx, closure_did);\n+            let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n             (function_type.sig.inputs.clone(),\n              function_type.sig.output,\n              RustCall,\n@@ -691,7 +716,7 @@ pub fn iter_structural_ty<'r,\n               }\n           })\n       }\n-      ty::ty_unboxed_closure(def_id) => {\n+      ty::ty_unboxed_closure(def_id, _) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n           for (i, upvar) in upvars.iter().enumerate() {\n@@ -1308,7 +1333,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n             match e.node {\n                 ast::ExprFnBlock(_, _, blk) |\n                 ast::ExprProc(_, blk) |\n-                ast::ExprUnboxedFn(_, _, blk) => {\n+                ast::ExprUnboxedFn(_, _, _, blk) => {\n                     let mut explicit = CheckForNestedReturnsVisitor { found: false };\n                     let mut implicit = CheckForNestedReturnsVisitor { found: false };\n                     visit::walk_expr(&mut explicit, &*e, false);\n@@ -1460,6 +1485,8 @@ pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n /// Creates rvalue datums for each of the incoming function arguments and\n /// tuples the arguments. These will later be stored into appropriate lvalue\n /// datums.\n+///\n+/// FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n fn create_datums_for_fn_args_under_call_abi<\n         'a>(\n         mut bcx: &'a Block<'a>,\n@@ -1708,7 +1735,8 @@ pub fn trans_closure(ccx: &CrateContext,\n                      abi: Abi,\n                      has_env: bool,\n                      is_unboxed_closure: IsUnboxedClosureFlag,\n-                     maybe_load_env: <'a> |&'a Block<'a>| -> &'a Block<'a>) {\n+                     maybe_load_env: <'a>|&'a Block<'a>, ScopeId|\n+                                         -> &'a Block<'a>) {\n     ccx.stats.n_closures.set(ccx.stats.n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1773,7 +1801,7 @@ pub fn trans_closure(ccx: &CrateContext,\n         }\n     };\n \n-    bcx = maybe_load_env(bcx);\n+    bcx = maybe_load_env(bcx, cleanup::CustomScope(arg_scope));\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n@@ -1854,7 +1882,7 @@ pub fn trans_fn(ccx: &CrateContext,\n                   abi,\n                   false,\n                   NotUnboxedClosure,\n-                  |bcx| bcx);\n+                  |bcx, _| bcx);\n }\n \n pub fn trans_enum_variant(ccx: &CrateContext,\n@@ -2188,11 +2216,11 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n     let (fn_sig, abi, has_env) = match ty::get(fn_ty).sty {\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n-        ty::ty_unboxed_closure(closure_did) => {\n-            let unboxed_closure_types = ccx.tcx\n-                                           .unboxed_closure_types\n-                                           .borrow();\n-            let function_type = unboxed_closure_types.get(&closure_did);\n+        ty::ty_unboxed_closure(closure_did, _) => {\n+            let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+            let function_type = unboxed_closures.get(&closure_did)\n+                                                .closure_type\n+                                                .clone();\n             (function_type.sig.clone(), RustCall, true)\n         }\n         _ => fail!(\"expected closure or function.\")"}, {"sha": "17f1b6ca52669c07dfb0ec39b19358160f6cc48b", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -19,6 +19,7 @@ use middle::lang_items::ClosureExchangeMallocFnLangItem;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n+use middle::trans::cleanup::{CleanupMethods, ScopeId};\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, DatumBlock, Expr, Lvalue, rvalue_scratch_datum};\n use middle::trans::debuginfo;\n@@ -306,19 +307,41 @@ fn load_environment<'a>(bcx: &'a Block<'a>,\n \n fn load_unboxed_closure_environment<'a>(\n                                     bcx: &'a Block<'a>,\n-                                    freevars: &Vec<freevars::freevar_entry>)\n+                                    arg_scope_id: ScopeId,\n+                                    freevars: &Vec<freevars::freevar_entry>,\n+                                    closure_id: ast::DefId)\n                                     -> &'a Block<'a> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     if freevars.len() == 0 {\n         return bcx\n     }\n \n-    let llenv = bcx.fcx.llenv.unwrap();\n+    // Special case for small by-value selfs.\n+    let self_type = self_type_for_unboxed_closure(bcx.ccx(), closure_id);\n+    let kind = kind_for_unboxed_closure(bcx.ccx(), closure_id);\n+    let llenv = if kind == ty::FnOnceUnboxedClosureKind &&\n+            !arg_is_indirect(bcx.ccx(), self_type) {\n+        let datum = rvalue_scratch_datum(bcx,\n+                                         self_type,\n+                                         \"unboxed_closure_env\");\n+        store_ty(bcx, bcx.fcx.llenv.unwrap(), datum.val, self_type);\n+        assert!(freevars.len() <= 1);\n+        datum.val\n+    } else {\n+        bcx.fcx.llenv.unwrap()\n+    };\n+\n     for (i, freevar) in freevars.iter().enumerate() {\n         let upvar_ptr = GEPi(bcx, llenv, [0, i]);\n         let def_id = freevar.def.def_id();\n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n+\n+        if kind == ty::FnOnceUnboxedClosureKind {\n+            bcx.fcx.schedule_drop_mem(arg_scope_id,\n+                                      upvar_ptr,\n+                                      node_id_type(bcx, def_id.node))\n+        }\n     }\n \n     bcx\n@@ -394,7 +417,7 @@ pub fn trans_expr_fn<'a>(\n                   ty::ty_fn_abi(fty),\n                   true,\n                   NotUnboxedClosure,\n-                  |bcx| load_environment(bcx, cdata_ty, &freevars, store));\n+                  |bcx, _| load_environment(bcx, cdata_ty, &freevars, store));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n }\n@@ -404,7 +427,7 @@ pub fn trans_expr_fn<'a>(\n pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n                                                     closure_id: ast::DefId)\n                                                     -> Option<ValueRef> {\n-    if !ccx.tcx.unboxed_closure_types.borrow().contains_key(&closure_id) {\n+    if !ccx.tcx.unboxed_closures.borrow().contains_key(&closure_id) {\n         // Not an unboxed closure.\n         return None\n     }\n@@ -418,7 +441,9 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n         None => {}\n     }\n \n-    let function_type = ty::mk_unboxed_closure(&ccx.tcx, closure_id);\n+    let function_type = ty::mk_unboxed_closure(&ccx.tcx,\n+                                               closure_id,\n+                                               ty::ReStatic);\n     let symbol = ccx.tcx.map.with_path(closure_id.node, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n@@ -453,19 +478,10 @@ pub fn trans_unboxed_closure<'a>(\n         bcx.ccx(),\n         closure_id).unwrap();\n \n-    // Untuple the arguments.\n-    let unboxed_closure_types = bcx.tcx().unboxed_closure_types.borrow();\n-    let /*mut*/ function_type = (*unboxed_closure_types.get(&closure_id)).clone();\n-    /*function_type.sig.inputs =\n-        match ty::get(*function_type.sig.inputs.get(0)).sty {\n-            ty::ty_tup(ref tuple_types) => {\n-                tuple_types.iter().map(|x| (*x).clone()).collect()\n-            }\n-            _ => {\n-                bcx.tcx().sess.span_bug(body.span,\n-                                        \"unboxed closure wasn't a tuple?!\")\n-            }\n-        };*/\n+    let unboxed_closures = bcx.tcx().unboxed_closures.borrow();\n+    let function_type = unboxed_closures.get(&closure_id)\n+                                        .closure_type\n+                                        .clone();\n     let function_type = ty::mk_closure(bcx.tcx(), function_type);\n \n     let freevars: Vec<freevars::freevar_entry> =\n@@ -486,7 +502,12 @@ pub fn trans_unboxed_closure<'a>(\n                   ty::ty_fn_abi(function_type),\n                   true,\n                   IsUnboxedClosure,\n-                  |bcx| load_unboxed_closure_environment(bcx, freevars_ptr));\n+                  |bcx, arg_scope| {\n+                      load_unboxed_closure_environment(bcx,\n+                                                       arg_scope,\n+                                                       freevars_ptr,\n+                                                       closure_id)\n+                  });\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size unboxed closure (in which case dest will be\n@@ -502,13 +523,13 @@ pub fn trans_unboxed_closure<'a>(\n     let repr = adt::represent_type(bcx.ccx(), node_id_type(bcx, id));\n \n     // Create the closure.\n-    for freevar in freevars_ptr.iter() {\n+    for (i, freevar) in freevars_ptr.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(bcx,\n                                                    &*repr,\n                                                    dest_addr,\n                                                    0,\n-                                                   0);\n+                                                   i);\n         bcx = datum.store_to(bcx, upvar_slot_dest);\n     }\n     adt::trans_set_discr(bcx, &*repr, dest_addr, 0);"}, {"sha": "300e7ecf81f43dfaaccd530d006cc65ec0991cce", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -32,7 +32,7 @@ use middle::trans::type_of;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{DefIdMap, NodeMap};\n \n use arena::TypedArena;\n use std::collections::HashMap;\n@@ -514,6 +514,11 @@ impl<'a> mc::Typer for Block<'a> {\n         self.tcx().region_maps.temporary_scope(rvalue_id)\n     }\n \n+    fn unboxed_closures<'a>(&'a self)\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+        &self.tcx().unboxed_closures\n+    }\n+\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n         self.tcx().upvar_borrow_map.borrow().get_copy(&upvar_id)\n     }"}, {"sha": "96b8acbfb404ae70d7e3cebefe7b4a96d48d86d5", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -1152,7 +1152,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             match expr.node {\n                 ast::ExprFnBlock(_, fn_decl, top_level_block) |\n                 ast::ExprProc(fn_decl, top_level_block) |\n-                ast::ExprUnboxedFn(_, fn_decl, top_level_block) => {\n+                ast::ExprUnboxedFn(_, _, fn_decl, top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name.as_slice());\n                     (name, fn_decl,\n@@ -3620,7 +3620,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n             ast::ExprFnBlock(_, ref decl, ref block) |\n             ast::ExprProc(ref decl, ref block) |\n-            ast::ExprUnboxedFn(_, ref decl, ref block) => {\n+            ast::ExprUnboxedFn(_, _, ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n@@ -3895,7 +3895,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 push_debuginfo_type_name(cx, sig.output, true, output);\n             }\n         },\n-        ty::ty_unboxed_closure(_) => {\n+        ty::ty_unboxed_closure(..) => {\n             output.push_str(\"closure\");\n         }\n         ty::ty_err      |"}, {"sha": "576bdb8b8c0b8ab3278f6d279b2ce33f5866100d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -790,7 +790,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                    expr_to_string(expr), expr_ty.repr(tcx));\n             closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n         }\n-        ast::ExprUnboxedFn(_, decl, body) => {\n+        ast::ExprUnboxedFn(_, _, decl, body) => {\n             closure::trans_unboxed_closure(bcx, &*decl, &*body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {"}, {"sha": "3ae4c552b84e813c6cca346339f878a25e4fb500", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -446,7 +446,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n fn get_callee_substitutions_for_unboxed_closure(bcx: &Block,\n                                                 def_id: ast::DefId)\n                                                 -> subst::Substs {\n-    let self_ty = ty::mk_unboxed_closure(bcx.tcx(), def_id);\n+    let self_ty = ty::mk_unboxed_closure(bcx.tcx(), def_id, ty::ReStatic);\n     subst::Substs::erased(\n         VecPerParamSpace::new(Vec::new(),\n                               vec!["}, {"sha": "8a445fc48398ee21feeb051de4e2ca587e33af0b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -273,7 +273,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         let name = llvm_type_name(cx, an_enum, did, tps);\n         adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n-      ty::ty_unboxed_closure(did) => {\n+      ty::ty_unboxed_closure(did, _) => {\n         // Only create the named struct, but don't fill it in. We\n         // fill it in *after* placing it into the type cache.\n         let repr = adt::represent_type(cx, t);"}, {"sha": "f03c982bb083f59f6fb5e2777758fbe3b7859ab9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -373,7 +373,7 @@ pub struct ctxt {\n \n     /// Records the type of each unboxed closure. The def ID is the ID of the\n     /// expression defining the unboxed closure.\n-    pub unboxed_closure_types: RefCell<DefIdMap<ClosureTy>>,\n+    pub unboxed_closures: RefCell<DefIdMap<UnboxedClosure>>,\n \n     pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::LintId),\n                                           lint::LevelSource>>,\n@@ -745,7 +745,7 @@ pub enum sty {\n     ty_closure(Box<ClosureTy>),\n     ty_trait(Box<TyTrait>),\n     ty_struct(DefId, Substs),\n-    ty_unboxed_closure(DefId),\n+    ty_unboxed_closure(DefId, Region),\n     ty_tup(Vec<t>),\n \n     ty_param(ParamTy), // type parameter\n@@ -1056,6 +1056,21 @@ pub type type_cache = RefCell<DefIdMap<Polytype>>;\n \n pub type node_type_table = RefCell<HashMap<uint,t>>;\n \n+/// Records information about each unboxed closure.\n+pub struct UnboxedClosure {\n+    /// The type of the unboxed closure.\n+    pub closure_type: ClosureTy,\n+    /// The kind of unboxed closure this is.\n+    pub kind: UnboxedClosureKind,\n+}\n+\n+#[deriving(PartialEq, Eq)]\n+pub enum UnboxedClosureKind {\n+    FnUnboxedClosureKind,\n+    FnMutUnboxedClosureKind,\n+    FnOnceUnboxedClosureKind,\n+}\n+\n pub fn mk_ctxt(s: Session,\n                dm: resolve::DefMap,\n                named_region_map: resolve_lifetime::NamedRegionMap,\n@@ -1117,7 +1132,7 @@ pub fn mk_ctxt(s: Session,\n         method_map: RefCell::new(FnvHashMap::new()),\n         vtable_map: RefCell::new(FnvHashMap::new()),\n         dependency_formats: RefCell::new(HashMap::new()),\n-        unboxed_closure_types: RefCell::new(DefIdMap::new()),\n+        unboxed_closures: RefCell::new(DefIdMap::new()),\n         node_lint_levels: RefCell::new(HashMap::new()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n@@ -1177,7 +1192,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     }\n     match &st {\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n-      &ty_str | &ty_unboxed_closure(_) => {}\n+      &ty_str => {}\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n       // rid of the has_ty_err flag -- likewise for ty_bot (with\n@@ -1194,6 +1209,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n               flags |= has_params as uint;\n           }\n       }\n+      &ty_unboxed_closure(_, ref region) => flags |= rflags(*region),\n       &ty_infer(_) => flags |= needs_infer as uint,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags |= sflags(substs);\n@@ -1442,8 +1458,9 @@ pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: Substs) -> t {\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_unboxed_closure(cx: &ctxt, closure_id: ast::DefId) -> t {\n-    mk_t(cx, ty_unboxed_closure(closure_id))\n+pub fn mk_unboxed_closure(cx: &ctxt, closure_id: ast::DefId, region: Region)\n+                          -> t {\n+    mk_t(cx, ty_unboxed_closure(closure_id, region))\n }\n \n pub fn mk_var(cx: &ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n@@ -1476,8 +1493,8 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(_) | ty_err => {\n-        }\n+        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(..) |\n+        ty_err => {}\n         ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_vec(ref tm, _) => {\n             maybe_walk_ty(tm.ty, f);\n@@ -1584,7 +1601,7 @@ pub fn type_is_vec(ty: t) -> bool {\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) |\n-      ty_vec(_, Some(_)) | ty_unboxed_closure(_) => true,\n+      ty_vec(_, Some(_)) | ty_unboxed_closure(..) => true,\n       _ => type_is_slice(ty) | type_is_trait(ty)\n     }\n }\n@@ -2099,10 +2116,13 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_unboxed_closure(did) => {\n+            ty_unboxed_closure(did, r) => {\n+                // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n+                // unboxed closure.\n                 let upvars = unboxed_closure_upvars(cx, did);\n                 TypeContents::union(upvars.as_slice(),\n-                                    |f| tc_ty(cx, f.ty, cache))\n+                                    |f| tc_ty(cx, f.ty, cache)) |\n+                    borrowed_contents(r, MutMutable)\n             }\n \n             ty_tup(ref tys) => {\n@@ -2349,7 +2369,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n                 r\n             }\n \n-            ty_unboxed_closure(did) => {\n+            ty_unboxed_closure(did, _) => {\n                 let upvars = unboxed_closure_upvars(cx, did);\n                 upvars.iter().any(|f| type_requires(cx, seen, r_ty, f.ty))\n             }\n@@ -2477,7 +2497,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n                 r\n             }\n \n-            ty_unboxed_closure(did) => {\n+            ty_unboxed_closure(did, _) => {\n                 let upvars = unboxed_closure_upvars(cx, did);\n                 find_nonrepresentable(cx,\n                                       sp,\n@@ -2718,7 +2738,7 @@ pub fn ty_fn_args(fty: t) -> Vec<t> {\n pub fn ty_closure_store(fty: t) -> TraitStore {\n     match get(fty).sty {\n         ty_closure(ref f) => f.store,\n-        ty_unboxed_closure(_) => {\n+        ty_unboxed_closure(..) => {\n             // Close enough for the purposes of all the callers of this\n             // function (which is soon to be deprecated anyhow).\n             UniqTraitStore\n@@ -3318,7 +3338,7 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n         ty_struct(id, _) => {\n             format!(\"struct {}\", item_path_str(cx, id))\n         }\n-        ty_unboxed_closure(_) => \"closure\".to_string(),\n+        ty_unboxed_closure(..) => \"closure\".to_string(),\n         ty_tup(_) => \"tuple\".to_string(),\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n@@ -3687,7 +3707,7 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n         ty_trait(box TyTrait { def_id: id, .. }) |\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n-        ty_unboxed_closure(id) => Some(id),\n+        ty_unboxed_closure(id, _) => Some(id),\n         _ => None\n     }\n }\n@@ -4717,9 +4737,10 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             }\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n-            ty_unboxed_closure(d) => {\n+            ty_unboxed_closure(d, r) => {\n                 byte!(24);\n                 did(&mut state, d);\n+                region(&mut state, r);\n             }\n         }\n     });\n@@ -4873,6 +4894,11 @@ impl mc::Typer for ty::ctxt {\n                     -> freevars::CaptureMode {\n         self.capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n+\n+    fn unboxed_closures<'a>(&'a self)\n+                        -> &'a RefCell<DefIdMap<UnboxedClosure>> {\n+        &self.unboxed_closures\n+    }\n }\n \n /// The category of explicit self.\n@@ -4914,6 +4940,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                     UniqTraitStore => {}\n                 }\n             }\n+            ty_unboxed_closure(_, ref region) => accumulator.push(*region),\n             ty_nil |\n             ty_bot |\n             ty_bool |\n@@ -4930,7 +4957,6 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_tup(_) |\n             ty_param(_) |\n             ty_infer(_) |\n-            ty_unboxed_closure(_) |\n             ty_err => {}\n         }\n     })"}, {"sha": "9f475bfd9d5d06dbba4ec703350517e0311ecba5", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -392,8 +392,8 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_struct(did, ref substs) => {\n             ty::ty_struct(did, substs.fold_with(this))\n         }\n-        ty::ty_unboxed_closure(did) => {\n-            ty::ty_unboxed_closure(did)\n+        ty::ty_unboxed_closure(did, ref region) => {\n+            ty::ty_unboxed_closure(did, region.fold_with(this))\n         }\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |"}, {"sha": "c317f98a25afef408b00a99abf6d67227d4851c0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -51,7 +51,8 @@\n \n use middle::const_eval;\n use middle::def;\n-use middle::lang_items::FnMutTraitLangItem;\n+use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n+use middle::lang_items::{FnOnceTraitLangItem};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty;\n@@ -544,16 +545,17 @@ fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(this: &AC,\n \n pub fn trait_ref_for_unboxed_function<AC:AstConv,\n                                       RS:RegionScope>(\n-                                          this: &AC,\n-                                          rscope: &RS,\n-                                          unboxed_function: &ast::UnboxedFnTy,\n-                                          self_ty: Option<ty::t>)\n-    -> ty::TraitRef\n-{\n-    let fn_mut_trait_did = this.tcx()\n-                               .lang_items\n-                               .require(FnMutTraitLangItem)\n-                               .unwrap();\n+                                      this: &AC,\n+                                      rscope: &RS,\n+                                      unboxed_function: &ast::UnboxedFnTy,\n+                                      self_ty: Option<ty::t>)\n+                                      -> ty::TraitRef {\n+    let lang_item = match unboxed_function.kind {\n+        ast::FnUnboxedClosureKind => FnTraitLangItem,\n+        ast::FnMutUnboxedClosureKind => FnMutTraitLangItem,\n+        ast::FnOnceUnboxedClosureKind => FnOnceTraitLangItem,\n+    };\n+    let trait_did = this.tcx().lang_items.require(lang_item).unwrap();\n     let input_types =\n         unboxed_function.decl\n                         .inputs\n@@ -574,7 +576,7 @@ pub fn trait_ref_for_unboxed_function<AC:AstConv,\n     }\n \n     ty::TraitRef {\n-        def_id: fn_mut_trait_did,\n+        def_id: trait_did,\n         substs: substs,\n     }\n }\n@@ -810,7 +812,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n-            ast::TyUnboxedFn(_) => {\n+            ast::TyUnboxedFn(..) => {\n                 tcx.sess.span_err(ast_ty.span,\n                                   \"cannot use unboxed functions here\");\n                 ty::mk_err()"}, {"sha": "dfcde8ca9b9bcadcc043ce336a8daa04fd681d71", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -444,7 +444,7 @@ impl<'a> LookupContext<'a> {\n                 },\n                 ty_enum(did, _) |\n                 ty_struct(did, _) |\n-                ty_unboxed_closure(did) => {\n+                ty_unboxed_closure(did, _) => {\n                     if self.check_traits == CheckTraitsAndInherentMethods {\n                         self.push_inherent_impl_candidates_for_type(did);\n                     }\n@@ -468,7 +468,7 @@ impl<'a> LookupContext<'a> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n                 }\n-                ty_unboxed_closure(closure_did) => {\n+                ty_unboxed_closure(closure_did, _) => {\n                     self.push_unboxed_closure_call_candidates_if_applicable(\n                         closure_did);\n                 }\n@@ -531,8 +531,11 @@ impl<'a> LookupContext<'a> {\n         let arguments_type = *closure_function_type.sig.inputs.get(0);\n         let return_type = closure_function_type.sig.output;\n \n+        let closure_region =\n+            vcx.infcx.next_region_var(MiscVariable(self.span));\n         let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),\n-                                                          closure_did);\n+                                                          closure_did,\n+                                                          closure_region);\n         self.extension_candidates.push(Candidate {\n             rcvr_match_condition:\n                 RcvrMatchesIfSubtype(unboxed_closure_type),\n@@ -548,39 +551,38 @@ impl<'a> LookupContext<'a> {\n     fn push_unboxed_closure_call_candidates_if_applicable(\n             &mut self,\n             closure_did: DefId) {\n-        // FIXME(pcwalton): Try `Fn` and `FnOnce` too.\n-        let trait_did = match self.tcx().lang_items.fn_mut_trait() {\n-            Some(trait_did) => trait_did,\n-            None => return,\n-        };\n-\n-        match self.tcx()\n-                  .unboxed_closure_types\n-                  .borrow()\n-                  .find(&closure_did) {\n-            None => {}  // Fall through to try inherited.\n-            Some(closure_function_type) => {\n-                self.push_unboxed_closure_call_candidate_if_applicable(\n-                    trait_did,\n-                    closure_did,\n-                    closure_function_type);\n-                return\n+        let trait_dids = [\n+            self.tcx().lang_items.fn_trait(),\n+            self.tcx().lang_items.fn_mut_trait(),\n+            self.tcx().lang_items.fn_once_trait()\n+        ];\n+        for optional_trait_did in trait_dids.iter() {\n+            let trait_did = match *optional_trait_did {\n+                Some(trait_did) => trait_did,\n+                None => continue,\n+            };\n+\n+            match self.tcx().unboxed_closures.borrow().find(&closure_did) {\n+                None => {}  // Fall through to try inherited.\n+                Some(closure) => {\n+                    self.push_unboxed_closure_call_candidate_if_applicable(\n+                        trait_did,\n+                        closure_did,\n+                        &closure.closure_type);\n+                    return\n+                }\n             }\n-        }\n \n-        match self.fcx\n-                  .inh\n-                  .unboxed_closure_types\n-                  .borrow()\n-                  .find(&closure_did) {\n-            Some(closure_function_type) => {\n-                self.push_unboxed_closure_call_candidate_if_applicable(\n-                    trait_did,\n-                    closure_did,\n-                    closure_function_type);\n-                return\n+            match self.fcx.inh.unboxed_closures.borrow().find(&closure_did) {\n+                Some(closure) => {\n+                    self.push_unboxed_closure_call_candidate_if_applicable(\n+                        trait_did,\n+                        closure_did,\n+                        &closure.closure_type);\n+                    return\n+                }\n+                None => {}\n             }\n-            None => {}\n         }\n \n         self.tcx().sess.bug(\"didn't find unboxed closure type in tcx map or \\"}, {"sha": "aa5a358515885abba3a941e3f5180548aa4be3c2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -168,7 +168,7 @@ pub struct Inherited<'a> {\n     method_map: MethodMap,\n     vtable_map: vtable_map,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n-    unboxed_closure_types: RefCell<DefIdMap<ty::ClosureTy>>,\n+    unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure>>,\n }\n \n /// When type-checking an expression, we propagate downward\n@@ -275,7 +275,7 @@ impl<'a> Inherited<'a> {\n             method_map: RefCell::new(FnvHashMap::new()),\n             vtable_map: RefCell::new(FnvHashMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n-            unboxed_closure_types: RefCell::new(DefIdMap::new()),\n+            unboxed_closures: RefCell::new(DefIdMap::new()),\n         }\n     }\n }\n@@ -1271,7 +1271,7 @@ impl<'a> FnCtxt<'a> {\n         VtableContext {\n             infcx: self.infcx(),\n             param_env: &self.inh.param_env,\n-            unboxed_closure_types: &self.inh.unboxed_closure_types,\n+            unboxed_closures: &self.inh.unboxed_closures,\n         }\n     }\n }\n@@ -2618,6 +2618,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn check_unboxed_closure(fcx: &FnCtxt,\n                              expr: &ast::Expr,\n+                             kind: ast::UnboxedClosureKind,\n                              decl: &ast::FnDecl,\n                              body: ast::P<ast::Block>) {\n         // The `RegionTraitStore` is a lie, but we ignore it so it doesn't\n@@ -2635,8 +2636,16 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             abi::RustCall,\n             None);\n \n+        let region = match fcx.infcx().anon_regions(expr.span, 1) {\n+            Err(_) => {\n+                fcx.ccx.tcx.sess.span_bug(expr.span,\n+                                          \"can't make anon regions here?!\")\n+            }\n+            Ok(regions) => *regions.get(0),\n+        };\n         let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n-                                                  local_def(expr.id));\n+                                                  local_def(expr.id),\n+                                                  region);\n         fcx.write_ty(expr.id, closure_type);\n \n         check_fn(fcx.ccx,\n@@ -2648,13 +2657,24 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                  fcx.inh);\n \n         // Tuple up the arguments and insert the resulting function type into\n-        // the `unboxed_closure_types` table.\n+        // the `unboxed_closures` table.\n         fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n \n+        let kind = match kind {\n+            ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n+            ast::FnMutUnboxedClosureKind => ty::FnMutUnboxedClosureKind,\n+            ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n+        };\n+\n+        let unboxed_closure = ty::UnboxedClosure {\n+            closure_type: fn_ty,\n+            kind: kind,\n+        };\n+\n         fcx.inh\n-           .unboxed_closure_types\n+           .unboxed_closures\n            .borrow_mut()\n-           .insert(local_def(expr.id), fn_ty);\n+           .insert(local_def(expr.id), unboxed_closure);\n     }\n \n     fn check_expr_fn(fcx: &FnCtxt,\n@@ -3402,9 +3422,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                       body.clone(),\n                       expected);\n       }\n-      ast::ExprUnboxedFn(_, ref decl, ref body) => {\n+      ast::ExprUnboxedFn(_, kind, ref decl, ref body) => {\n         check_unboxed_closure(fcx,\n                               expr,\n+                              kind,\n                               &**decl,\n                               *body);\n       }"}, {"sha": "0acf6e91831641a71bfa10e095e3c2189992e0d8", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -132,7 +132,7 @@ use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::MethodCall;\n use middle::pat_util;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{DefIdMap, NodeMap};\n use util::ppaux::{ty_to_string, region_to_string, Repr};\n \n use syntax::ast;\n@@ -295,6 +295,11 @@ impl<'fcx> mc::Typer for Rcx<'fcx> {\n                     -> freevars::CaptureMode {\n         self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n     }\n+\n+    fn unboxed_closures<'a>(&'a self)\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+        &self.fcx.inh.unboxed_closures\n+    }\n }\n \n pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n@@ -594,7 +599,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprFnBlock(_, _, ref body) |\n         ast::ExprProc(_, ref body) |\n-        ast::ExprUnboxedFn(_, _, ref body) => {\n+        ast::ExprUnboxedFn(_, _, _, ref body) => {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n \n@@ -660,6 +665,17 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 }\n             });\n         }\n+        ty::ty_unboxed_closure(_, region) => {\n+            freevars::with_freevars(tcx, expr.id, |freevars| {\n+                // No free variables means that there is no environment and\n+                // hence the closure has static lifetime. Otherwise, the\n+                // closure must not outlive the variables it closes over\n+                // by-reference.\n+                if !freevars.is_empty() {\n+                    constrain_free_variables(rcx, region, expr, freevars);\n+                }\n+            })\n+        }\n         _ => ()\n     }\n "}, {"sha": "850d5c5a8f07d03a110608fdd7db132f8fd5abcd", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -71,7 +71,7 @@ use syntax::visit::Visitor;\n pub struct VtableContext<'a> {\n     pub infcx: &'a infer::InferCtxt<'a>,\n     pub param_env: &'a ty::ParameterEnvironment,\n-    pub unboxed_closure_types: &'a RefCell<DefIdMap<ty::ClosureTy>>,\n+    pub unboxed_closures: &'a RefCell<DefIdMap<ty::UnboxedClosure>>,\n }\n \n impl<'a> VtableContext<'a> {\n@@ -309,31 +309,42 @@ fn search_for_unboxed_closure_vtable(vcx: &VtableContext,\n                                      -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n     let closure_def_id = match ty::get(ty).sty {\n-        ty::ty_unboxed_closure(closure_def_id) => closure_def_id,\n+        ty::ty_unboxed_closure(closure_def_id, _) => closure_def_id,\n         _ => return None,\n     };\n \n     let fn_traits = [\n-        tcx.lang_items.fn_trait(),\n-        tcx.lang_items.fn_mut_trait(),\n-        tcx.lang_items.fn_once_trait()\n+        (ty::FnUnboxedClosureKind, tcx.lang_items.fn_trait()),\n+        (ty::FnMutUnboxedClosureKind, tcx.lang_items.fn_mut_trait()),\n+        (ty::FnOnceUnboxedClosureKind, tcx.lang_items.fn_once_trait()),\n     ];\n-    for fn_trait in fn_traits.iter() {\n-        match *fn_trait {\n-            Some(ref fn_trait) if *fn_trait == trait_ref.def_id => {}\n+    for tuple in fn_traits.iter() {\n+        let kind = match tuple {\n+            &(kind, Some(ref fn_trait)) if *fn_trait == trait_ref.def_id => {\n+                kind\n+            }\n             _ => continue,\n         };\n \n         // Check to see whether the argument and return types match.\n-        let unboxed_closure_types = tcx.unboxed_closure_types.borrow();\n-        let closure_type = match unboxed_closure_types.find(&closure_def_id) {\n-            Some(closure_type) => (*closure_type).clone(),\n+        let unboxed_closures = tcx.unboxed_closures.borrow();\n+        let closure_type = match unboxed_closures.find(&closure_def_id) {\n+            Some(closure) => {\n+                if closure.kind != kind {\n+                    continue\n+                }\n+                closure.closure_type.clone()\n+            }\n             None => {\n                 // Try the inherited unboxed closure type map.\n-                let unboxed_closure_types = vcx.unboxed_closure_types\n-                                               .borrow();\n-                match unboxed_closure_types.find(&closure_def_id) {\n-                    Some(closure_type) => (*closure_type).clone(),\n+                let unboxed_closures = vcx.unboxed_closures.borrow();\n+                match unboxed_closures.find(&closure_def_id) {\n+                    Some(closure) => {\n+                        if closure.kind != kind {\n+                            continue\n+                        }\n+                        closure.closure_type.clone()\n+                    }\n                     None => {\n                         tcx.sess.span_bug(span,\n                                           \"didn't find unboxed closure type \\\n@@ -881,11 +892,11 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n     debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(tcx));\n \n     let infcx = &infer::new_infer_ctxt(tcx);\n-    let unboxed_closure_types = RefCell::new(DefIdMap::new());\n+    let unboxed_closures = RefCell::new(DefIdMap::new());\n     let vcx = VtableContext {\n         infcx: infcx,\n         param_env: &param_env,\n-        unboxed_closure_types: &unboxed_closure_types,\n+        unboxed_closures: &unboxed_closures,\n     };\n \n     // Resolve the vtables for the trait reference on the impl.  This\n@@ -934,11 +945,11 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n                             substs: &subst::Substs) -> vtable_res {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n-    let unboxed_closure_types = RefCell::new(DefIdMap::new());\n+    let unboxed_closures = RefCell::new(DefIdMap::new());\n     let vcx = VtableContext {\n         infcx: &infer::new_infer_ctxt(tcx),\n         param_env: &ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id),\n-        unboxed_closure_types: &unboxed_closure_types,\n+        unboxed_closures: &unboxed_closures,\n     };\n \n     lookup_vtables(&vcx,"}, {"sha": "892a62249ac3b5aa47b8e4778aca710783a3ca96", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -43,7 +43,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     let mut wbcx = WritebackCx::new(fcx);\n     wbcx.visit_expr(e, ());\n     wbcx.visit_upvar_borrow_map();\n-    wbcx.visit_unboxed_closure_types();\n+    wbcx.visit_unboxed_closures();\n }\n \n pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n@@ -62,7 +62,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n         }\n     }\n     wbcx.visit_upvar_borrow_map();\n-    wbcx.visit_unboxed_closure_types();\n+    wbcx.visit_unboxed_closures();\n }\n \n pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n@@ -134,7 +134,7 @@ impl<'cx> Visitor<()> for WritebackCx<'cx> {\n         match e.node {\n             ast::ExprFnBlock(_, ref decl, _) |\n             ast::ExprProc(ref decl, _) |\n-            ast::ExprUnboxedFn(_, ref decl, _) => {\n+            ast::ExprUnboxedFn(_, _, ref decl, _) => {\n                 for input in decl.inputs.iter() {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);\n@@ -211,23 +211,27 @@ impl<'cx> WritebackCx<'cx> {\n         }\n     }\n \n-    fn visit_unboxed_closure_types(&self) {\n+    fn visit_unboxed_closures(&self) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n-        for (def_id, closure_ty) in self.fcx\n-                                        .inh\n-                                        .unboxed_closure_types\n-                                        .borrow()\n-                                        .iter() {\n-            let closure_ty = self.resolve(closure_ty,\n+        for (def_id, unboxed_closure) in self.fcx\n+                                             .inh\n+                                             .unboxed_closures\n+                                             .borrow()\n+                                             .iter() {\n+            let closure_ty = self.resolve(&unboxed_closure.closure_type,\n                                           ResolvingUnboxedClosure(*def_id));\n+            let unboxed_closure = ty::UnboxedClosure {\n+                closure_type: closure_ty,\n+                kind: unboxed_closure.kind,\n+            };\n             self.fcx\n                 .tcx()\n-                .unboxed_closure_types\n+                .unboxed_closures\n                 .borrow_mut()\n-                .insert(*def_id, closure_ty);\n+                .insert(*def_id, unboxed_closure);\n         }\n     }\n "}, {"sha": "76af54ba4d15ce7977b1738dc2b1d98b31619b41", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -109,7 +109,7 @@ fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n             ty_struct(def_id, _) |\n-            ty_unboxed_closure(def_id) => {\n+            ty_unboxed_closure(def_id, _) => {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     found_nominal = true;\n                 }\n@@ -153,7 +153,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n             match get(base_type).sty {\n                 ty_enum(def_id, _) |\n                 ty_struct(def_id, _) |\n-                ty_unboxed_closure(def_id) => {\n+                ty_unboxed_closure(def_id, _) => {\n                     Some(def_id)\n                 }\n                 ty_rptr(_, ty::mt {ty, ..}) | ty_uniq(ty) => match ty::get(ty).sty {\n@@ -687,7 +687,7 @@ impl<'a> CoherenceChecker<'a> {\n             match ty::get(self_type.ty).sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n-                ty::ty_unboxed_closure(type_def_id) => {\n+                ty::ty_unboxed_closure(type_def_id, _) => {\n                     tcx.destructor_for_type.borrow_mut().insert(type_def_id,\n                                                                 method_def_id);\n                     tcx.destructors.borrow_mut().insert(method_def_id);"}, {"sha": "d99d55d4d873dfba386a001b099dd1092af61b74", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -492,9 +492,11 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n             Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n-      (&ty::ty_unboxed_closure(a_id), &ty::ty_unboxed_closure(b_id))\n+      (&ty::ty_unboxed_closure(a_id, a_region),\n+       &ty::ty_unboxed_closure(b_id, b_region))\n       if a_id == b_id => {\n-          Ok(ty::mk_unboxed_closure(tcx, a_id))\n+          let region = if_ok!(this.regions(a_region, b_region));\n+          Ok(ty::mk_unboxed_closure(tcx, a_id, region))\n       }\n \n       (&ty::ty_box(a_inner), &ty::ty_box(b_inner)) => {"}, {"sha": "54b9ce035348db0e3cbb4d0f8649fd3bba281d7c", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -722,10 +722,15 @@ impl<'a> ConstraintContext<'a> {\n         match ty::get(ty).sty {\n             ty::ty_nil | ty::ty_bot | ty::ty_bool |\n             ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n-            ty::ty_float(_) | ty::ty_str | ty::ty_unboxed_closure(..) => {\n+            ty::ty_float(_) | ty::ty_str => {\n                 /* leaf type -- noop */\n             }\n \n+            ty::ty_unboxed_closure(_, region) => {\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(region, contra);\n+            }\n+\n             ty::ty_rptr(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(region, contra);"}, {"sha": "7d9a23e91bae93638070133d3683b0ad86be205f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -528,7 +528,7 @@ pub enum Expr_ {\n     ExprMatch(Gc<Expr>, Vec<Arm>),\n     ExprFnBlock(CaptureClause, P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n-    ExprUnboxedFn(CaptureClause, P<FnDecl>, P<Block>),\n+    ExprUnboxedFn(CaptureClause, UnboxedClosureKind, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(Gc<Expr>, Gc<Expr>),\n@@ -900,6 +900,7 @@ pub struct BareFnTy {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct UnboxedFnTy {\n+    pub kind: UnboxedClosureKind,\n     pub decl: P<FnDecl>,\n }\n \n@@ -1297,6 +1298,13 @@ pub enum ForeignItem_ {\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n }\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum UnboxedClosureKind {\n+    FnUnboxedClosureKind,\n+    FnMutUnboxedClosureKind,\n+    FnOnceUnboxedClosureKind,\n+}\n+\n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans."}, {"sha": "cebe186252825f8abd55b32fb9db2263df310ba2", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -368,6 +368,7 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n         TyUnboxedFn(ref f) => {\n             TyUnboxedFn(box(GC) UnboxedFnTy {\n                 decl: fld.fold_fn_decl(&*f.decl),\n+                kind: f.kind,\n             })\n         }\n         TyTup(ref tys) => TyTup(tys.iter().map(|&ty| fld.fold_ty(ty)).collect()),\n@@ -641,6 +642,7 @@ pub fn noop_fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n         UnboxedFnTyParamBound(ref unboxed_function_type) => {\n             UnboxedFnTyParamBound(UnboxedFnTy {\n                 decl: fld.fold_fn_decl(&*unboxed_function_type.decl),\n+                kind: unboxed_function_type.kind,\n             })\n         }\n         OtherRegionTyParamBound(s) => OtherRegionTyParamBound(s)\n@@ -1103,8 +1105,9 @@ pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n             ExprProc(folder.fold_fn_decl(&**decl),\n                      folder.fold_block(body.clone()))\n         }\n-        ExprUnboxedFn(capture_clause, ref decl, ref body) => {\n+        ExprUnboxedFn(capture_clause, kind, ref decl, ref body) => {\n             ExprUnboxedFn(capture_clause,\n+                          kind,\n                           folder.fold_fn_decl(&**decl),\n                           folder.fold_block(*body))\n         }"}, {"sha": "f6db577a00453866c67b83391234cf6e19cc915c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 96, "deletions": 71, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -30,6 +30,8 @@ use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n use ast::{ExprVec, ExprVstore, ExprVstoreSlice};\n use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, Field, FnDecl};\n use ast::{ExprVstoreUniq, Once, Many};\n+use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n+use ast::{FnOnceUnboxedClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n use ast::{Ident, NormalFn, Inherited, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n@@ -53,7 +55,8 @@ use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyRptr};\n use ast::{TyTup, TyU32, TyUnboxedFn, TyUniq, TyVec, UnUniq};\n-use ast::{UnboxedFnTy, UnboxedFnTyParamBound, UnnamedField, UnsafeBlock};\n+use ast::{UnboxedClosureKind, UnboxedFnTy, UnboxedFnTyParamBound};\n+use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::Visibility;\n@@ -1087,6 +1090,34 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// Parses an optional unboxed closure kind (`&:`, `&mut:`, or `:`).\n+    pub fn parse_optional_unboxed_closure_kind(&mut self)\n+                                               -> Option<UnboxedClosureKind> {\n+        if self.token == token::BINOP(token::AND) &&\n+                    self.look_ahead(1, |t| {\n+                        token::is_keyword(keywords::Mut, t)\n+                    }) &&\n+                    self.look_ahead(2, |t| *t == token::COLON) {\n+            self.bump();\n+            self.bump();\n+            self.bump();\n+            return Some(FnMutUnboxedClosureKind)\n+        }\n+\n+        if self.token == token::BINOP(token::AND) &&\n+                    self.look_ahead(1, |t| *t == token::COLON) {\n+            self.bump();\n+            self.bump();\n+            return Some(FnUnboxedClosureKind)\n+        }\n+\n+        if self.eat(&token::COLON) {\n+            return Some(FnOnceUnboxedClosureKind)\n+        }\n+\n+        return None\n+    }\n+\n     /// Parse a TyClosure type\n     pub fn parse_ty_closure(&mut self) -> Ty_ {\n         /*\n@@ -1115,27 +1146,19 @@ impl<'a> Parser<'a> {\n             Vec::new()\n         };\n \n-        let (is_unboxed, inputs) = if self.eat(&token::OROR) {\n-            (false, Vec::new())\n+        let (optional_unboxed_closure_kind, inputs) = if self.eat(&token::OROR) {\n+            (None, Vec::new())\n         } else {\n             self.expect_or();\n \n-            let is_unboxed = self.token == token::BINOP(token::AND) &&\n-                self.look_ahead(1, |t| {\n-                    token::is_keyword(keywords::Mut, t)\n-                }) &&\n-                self.look_ahead(2, |t| *t == token::COLON);\n-            if is_unboxed {\n-                self.bump();\n-                self.bump();\n-                self.bump();\n-            }\n+            let optional_unboxed_closure_kind =\n+                self.parse_optional_unboxed_closure_kind();\n \n             let inputs = self.parse_seq_to_before_or(\n                 &token::COMMA,\n                 |p| p.parse_arg_general(false));\n             self.expect_or();\n-            (is_unboxed, inputs)\n+            (optional_unboxed_closure_kind, inputs)\n         };\n \n         let (region, bounds) = {\n@@ -1155,18 +1178,22 @@ impl<'a> Parser<'a> {\n             variadic: false\n         });\n \n-        if is_unboxed {\n-            TyUnboxedFn(box(GC) UnboxedFnTy {\n-                decl: decl,\n-            })\n-        } else {\n-            TyClosure(box(GC) ClosureTy {\n-                fn_style: fn_style,\n-                onceness: onceness,\n-                bounds: bounds,\n-                decl: decl,\n-                lifetimes: lifetime_defs,\n-            }, region)\n+        match optional_unboxed_closure_kind {\n+            Some(unboxed_closure_kind) => {\n+                TyUnboxedFn(box(GC) UnboxedFnTy {\n+                    kind: unboxed_closure_kind,\n+                    decl: decl,\n+                })\n+            }\n+            None => {\n+                TyClosure(box(GC) ClosureTy {\n+                    fn_style: fn_style,\n+                    onceness: onceness,\n+                    bounds: bounds,\n+                    decl: decl,\n+                    lifetimes: lifetime_defs,\n+                }, region)\n+            }\n         }\n     }\n \n@@ -2703,7 +2730,8 @@ impl<'a> Parser<'a> {\n     pub fn parse_lambda_expr(&mut self, capture_clause: CaptureClause)\n                              -> Gc<Expr> {\n         let lo = self.span.lo;\n-        let (decl, is_unboxed) = self.parse_fn_block_decl();\n+        let (decl, optional_unboxed_closure_kind) =\n+            self.parse_fn_block_decl();\n         let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n             view_items: Vec::new(),\n@@ -2714,14 +2742,20 @@ impl<'a> Parser<'a> {\n             span: body.span,\n         });\n \n-        if is_unboxed {\n-            self.mk_expr(lo,\n-                         body.span.hi,\n-                         ExprUnboxedFn(capture_clause, decl, fakeblock))\n-        } else {\n-            self.mk_expr(lo,\n-                         body.span.hi,\n-                         ExprFnBlock(capture_clause, decl, fakeblock))\n+        match optional_unboxed_closure_kind {\n+            Some(unboxed_closure_kind) => {\n+                self.mk_expr(lo,\n+                             body.span.hi,\n+                             ExprUnboxedFn(capture_clause,\n+                                           unboxed_closure_kind,\n+                                           decl,\n+                                           fakeblock))\n+            }\n+            None => {\n+                self.mk_expr(lo,\n+                             body.span.hi,\n+                             ExprFnBlock(capture_clause, decl, fakeblock))\n+            }\n         }\n     }\n \n@@ -3553,28 +3587,22 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_unboxed_function_type(&mut self) -> UnboxedFnTy {\n-        let inputs = if self.eat(&token::OROR) {\n-            Vec::new()\n-        } else {\n-            self.expect_or();\n+        let (optional_unboxed_closure_kind, inputs) =\n+            if self.eat(&token::OROR) {\n+                (None, Vec::new())\n+            } else {\n+                self.expect_or();\n \n-            if self.token == token::BINOP(token::AND) &&\n-                    self.look_ahead(1, |t| {\n-                        token::is_keyword(keywords::Mut, t)\n-                    }) &&\n-                    self.look_ahead(2, |t| *t == token::COLON) {\n-                self.bump();\n-                self.bump();\n-                self.bump();\n-            }\n+                let optional_unboxed_closure_kind =\n+                    self.parse_optional_unboxed_closure_kind();\n \n-            let inputs = self.parse_seq_to_before_or(&token::COMMA,\n-                                                     |p| {\n-                p.parse_arg_general(false)\n-            });\n-            self.expect_or();\n-            inputs\n-        };\n+                let inputs = self.parse_seq_to_before_or(&token::COMMA,\n+                                                         |p| {\n+                    p.parse_arg_general(false)\n+                });\n+                self.expect_or();\n+                (optional_unboxed_closure_kind, inputs)\n+            };\n \n         let (return_style, output) = self.parse_ret_ty();\n         UnboxedFnTy {\n@@ -3583,7 +3611,11 @@ impl<'a> Parser<'a> {\n                 output: output,\n                 cf: return_style,\n                 variadic: false,\n-            })\n+            }),\n+            kind: match optional_unboxed_closure_kind {\n+                Some(kind) => kind,\n+                None => FnMutUnboxedClosureKind,\n+            },\n         }\n     }\n \n@@ -4026,29 +4058,22 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&mut self) -> (P<FnDecl>, bool) {\n-        let (is_unboxed, inputs_captures) = {\n+    fn parse_fn_block_decl(&mut self)\n+                           -> (P<FnDecl>, Option<UnboxedClosureKind>) {\n+        let (optional_unboxed_closure_kind, inputs_captures) = {\n             if self.eat(&token::OROR) {\n-                (false, Vec::new())\n+                (None, Vec::new())\n             } else {\n                 self.expect(&token::BINOP(token::OR));\n-                let is_unboxed = self.token == token::BINOP(token::AND) &&\n-                    self.look_ahead(1, |t| {\n-                        token::is_keyword(keywords::Mut, t)\n-                    }) &&\n-                    self.look_ahead(2, |t| *t == token::COLON);\n-                if is_unboxed {\n-                    self.bump();\n-                    self.bump();\n-                    self.bump();\n-                }\n+                let optional_unboxed_closure_kind =\n+                    self.parse_optional_unboxed_closure_kind();\n                 let args = self.parse_seq_to_before_end(\n                     &token::BINOP(token::OR),\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_fn_block_arg()\n                 );\n                 self.bump();\n-                (is_unboxed, args)\n+                (optional_unboxed_closure_kind, args)\n             }\n         };\n         let output = if self.eat(&token::RARROW) {\n@@ -4066,7 +4091,7 @@ impl<'a> Parser<'a> {\n             output: output,\n             cf: Return,\n             variadic: false\n-        }), is_unboxed)\n+        }), optional_unboxed_closure_kind)\n     }\n \n     /// Parses the `(arg, arg) -> return_type` header on a procedure."}, {"sha": "4ee73406f0340aff2a14f92bea25331cdc3306b5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n use abi;\n-use ast::{P, StaticRegionTyParamBound, OtherRegionTyParamBound};\n-use ast::{TraitTyParamBound, UnboxedFnTyParamBound, Required, Provided};\n+use ast::{FnMutUnboxedClosureKind, FnOnceUnboxedClosureKind};\n+use ast::{FnUnboxedClosureKind, P, OtherRegionTyParamBound};\n+use ast::{StaticRegionTyParamBound, TraitTyParamBound, UnboxedClosureKind};\n+use ast::{UnboxedFnTyParamBound, Required, Provided};\n use ast;\n use ast_util;\n use owned_slice::OwnedSlice;\n@@ -228,7 +230,7 @@ pub fn method_to_string(p: &ast::Method) -> String {\n }\n \n pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n-    $to_string(|s| s.print_fn_block_args(p, false))\n+    $to_string(|s| s.print_fn_block_args(p, None))\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n@@ -594,7 +596,7 @@ impl<'a> State<'a> {\n                                       &None,\n                                       Some(&generics),\n                                       None,\n-                                      false));\n+                                      None));\n             }\n             ast::TyClosure(f, ref region) => {\n                 let generics = ast::Generics {\n@@ -611,7 +613,7 @@ impl<'a> State<'a> {\n                                       &f.bounds,\n                                       Some(&generics),\n                                       None,\n-                                      false));\n+                                      None));\n             }\n             ast::TyProc(ref f) => {\n                 let generics = ast::Generics {\n@@ -628,7 +630,7 @@ impl<'a> State<'a> {\n                                       &f.bounds,\n                                       Some(&generics),\n                                       None,\n-                                      false));\n+                                      None));\n             }\n             ast::TyUnboxedFn(f) => {\n                 try!(self.print_ty_fn(None,\n@@ -641,7 +643,7 @@ impl<'a> State<'a> {\n                                       &None,\n                                       None,\n                                       None,\n-                                      true));\n+                                      Some(f.kind)));\n             }\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n@@ -1054,7 +1056,7 @@ impl<'a> State<'a> {\n                               &None,\n                               Some(&m.generics),\n                               Some(m.explicit_self.node),\n-                              false));\n+                              None));\n         word(&mut self.s, \";\")\n     }\n \n@@ -1481,7 +1483,7 @@ impl<'a> State<'a> {\n                 // we are inside.\n                 //\n                 // if !decl.inputs.is_empty() {\n-                try!(self.print_fn_block_args(&**decl, false));\n+                try!(self.print_fn_block_args(&**decl, None));\n                 try!(space(&mut self.s));\n                 // }\n \n@@ -1505,15 +1507,15 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprUnboxedFn(capture_clause, ref decl, ref body) => {\n+            ast::ExprUnboxedFn(capture_clause, kind, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n                 // in do/for blocks we don't want to show an empty\n                 // argument list, but at this point we don't know which\n                 // we are inside.\n                 //\n                 // if !decl.inputs.is_empty() {\n-                try!(self.print_fn_block_args(&**decl, true));\n+                try!(self.print_fn_block_args(&**decl, Some(kind)));\n                 try!(space(&mut self.s));\n                 // }\n \n@@ -2052,13 +2054,17 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_fn_block_args(&mut self,\n-                               decl: &ast::FnDecl,\n-                               is_unboxed: bool)\n-                               -> IoResult<()> {\n+    pub fn print_fn_block_args(\n+            &mut self,\n+            decl: &ast::FnDecl,\n+            unboxed_closure_kind: Option<UnboxedClosureKind>)\n+            -> IoResult<()> {\n         try!(word(&mut self.s, \"|\"));\n-        if is_unboxed {\n-            try!(self.word_space(\"&mut:\"));\n+        match unboxed_closure_kind {\n+            None => {}\n+            Some(FnUnboxedClosureKind) => try!(self.word_space(\"&:\")),\n+            Some(FnMutUnboxedClosureKind) => try!(self.word_space(\"&mut:\")),\n+            Some(FnOnceUnboxedClosureKind) => try!(self.word_space(\":\")),\n         }\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n@@ -2148,7 +2154,7 @@ impl<'a> State<'a> {\n                                          &None,\n                                          None,\n                                          None,\n-                                         true)\n+                                         Some(unboxed_function_type.kind))\n                     }\n                     OtherRegionTyParamBound(_) => Ok(())\n                 })\n@@ -2366,7 +2372,8 @@ impl<'a> State<'a> {\n                        opt_bounds: &Option<OwnedSlice<ast::TyParamBound>>,\n                        generics: Option<&ast::Generics>,\n                        opt_explicit_self: Option<ast::ExplicitSelf_>,\n-                       is_unboxed: bool)\n+                       opt_unboxed_closure_kind:\n+                        Option<ast::UnboxedClosureKind>)\n                        -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n \n@@ -2383,7 +2390,7 @@ impl<'a> State<'a> {\n             try!(self.print_fn_style(fn_style));\n             try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n             try!(self.print_onceness(onceness));\n-            if !is_unboxed {\n+            if opt_unboxed_closure_kind.is_none() {\n                 try!(word(&mut self.s, \"fn\"));\n             }\n         }\n@@ -2399,20 +2406,30 @@ impl<'a> State<'a> {\n         match generics { Some(g) => try!(self.print_generics(g)), _ => () }\n         try!(zerobreak(&mut self.s));\n \n-        if is_unboxed || opt_sigil == Some('&') {\n+        if opt_unboxed_closure_kind.is_some() || opt_sigil == Some('&') {\n             try!(word(&mut self.s, \"|\"));\n         } else {\n             try!(self.popen());\n         }\n \n-        if is_unboxed {\n-            try!(word(&mut self.s, \"&mut\"));\n-            try!(self.word_space(\":\"));\n+        match opt_unboxed_closure_kind {\n+            Some(ast::FnUnboxedClosureKind) => {\n+                try!(word(&mut self.s, \"&\"));\n+                try!(self.word_space(\":\"));\n+            }\n+            Some(ast::FnMutUnboxedClosureKind) => {\n+                try!(word(&mut self.s, \"&mut\"));\n+                try!(self.word_space(\":\"));\n+            }\n+            Some(ast::FnOnceUnboxedClosureKind) => {\n+                try!(self.word_space(\":\"));\n+            }\n+            None => {}\n         }\n \n         try!(self.print_fn_args(decl, opt_explicit_self));\n \n-        if is_unboxed || opt_sigil == Some('&') {\n+        if opt_unboxed_closure_kind.is_some() || opt_sigil == Some('&') {\n             try!(word(&mut self.s, \"|\"));\n         } else {\n             if decl.variadic {"}, {"sha": "79a870422a68be191662b4b535775a82cf1f9325", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -795,7 +795,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n                              expression.id,\n                              env.clone())\n         }\n-        ExprUnboxedFn(_, ref function_declaration, ref body) => {\n+        ExprUnboxedFn(_, _, ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n                              &**function_declaration,\n                              &**body,"}, {"sha": "d822bb22e2a72f1023acf0db5502cbbe196ac931", "filename": "src/test/compile-fail/borrowck-unboxed-closures.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls)]\n+\n+fn a<F:|&: int, int| -> int>(mut f: F) {\n+    let g = &mut f;\n+    f(1, 2);    //~ ERROR cannot borrow `f` as immutable\n+    //~^ ERROR cannot borrow `f` as immutable\n+}\n+\n+fn b<F:|&mut: int, int| -> int>(f: F) {\n+    f(1, 2);    //~ ERROR cannot borrow immutable argument\n+}\n+\n+fn c<F:|: int, int| -> int>(f: F) {\n+    f(1, 2);\n+    f(1, 2);    //~ ERROR use of moved value\n+}\n+\n+fn main() {}\n+"}, {"sha": "1c590db11e3992a370a69640508763d3d89e43c1", "filename": "src/test/compile-fail/regionck-unboxed-closure-lifetimes.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closure_sugar, unboxed_closures, overloaded_calls)]\n+\n+use std::ops::FnMut;\n+\n+fn main() {\n+    let mut f;\n+    {\n+        let c = 1;\n+        let c_ref = &c;\n+        f = |&mut: a: int, b: int| { a + b + *c_ref };\n+        //~^ ERROR cannot infer an appropriate lifetime\n+    }\n+}\n+"}, {"sha": "50d90c6200e12efef860ef946ca59e580eb072f3", "filename": "src/test/compile-fail/unboxed-closures-wrong-trait.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(lang_items, overloaded_calls, unboxed_closures)]\n+\n+fn c<F:|: int, int| -> int>(f: F) -> int {\n+    f(5, 6)\n+}\n+\n+fn main() {\n+    let z: int = 7;\n+    assert_eq!(c(|&: x: int, y| x + y + z), 10);\n+    //~^ ERROR failed to find an implementation\n+}\n+"}, {"sha": "c362a83e60c4ad6f0c13962eb1e78bda2352faaf", "filename": "src/test/run-pass/unboxed-closures-all-traits.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(lang_items, overloaded_calls, unboxed_closures)]\n+\n+fn a<F:|&: int, int| -> int>(f: F) -> int {\n+    f(1, 2)\n+}\n+\n+fn b<F:|&mut: int, int| -> int>(mut f: F) -> int {\n+    f(3, 4)\n+}\n+\n+fn c<F:|: int, int| -> int>(f: F) -> int {\n+    f(5, 6)\n+}\n+\n+fn main() {\n+    let z: int = 7;\n+    assert_eq!(a(|&: x: int, y| x + y + z), 10);\n+    assert_eq!(b(|&mut: x: int, y| x + y + z), 14);\n+    assert_eq!(c(|: x: int, y| x + y + z), 18);\n+}\n+"}, {"sha": "f20dddcae54b3de238089d0b381505dcb8be9bfc", "filename": "src/test/run-pass/unboxed-closures-drop.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A battery of tests to ensure destructors of unboxed closure environments\n+// run at the right times.\n+\n+#![feature(overloaded_calls, unboxed_closures)]\n+\n+static mut DROP_COUNT: uint = 0;\n+\n+fn drop_count() -> uint {\n+    unsafe {\n+        DROP_COUNT\n+    }\n+}\n+\n+struct Droppable {\n+    x: int,\n+}\n+\n+impl Droppable {\n+    fn new() -> Droppable {\n+        Droppable {\n+            x: 1\n+        }\n+    }\n+}\n+\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        unsafe {\n+            DROP_COUNT += 1\n+        }\n+    }\n+}\n+\n+fn a<F:|&: int, int| -> int>(f: F) -> int {\n+    f(1, 2)\n+}\n+\n+fn b<F:|&mut: int, int| -> int>(mut f: F) -> int {\n+    f(3, 4)\n+}\n+\n+fn c<F:|: int, int| -> int>(f: F) -> int {\n+    f(5, 6)\n+}\n+\n+fn test_fn() {\n+    {\n+        a(|&: a: int, b| { a + b });\n+    }\n+    assert_eq!(drop_count(), 0);\n+\n+    {\n+        let z = &Droppable::new();\n+        a(|&: a: int, b| { z; a + b });\n+        assert_eq!(drop_count(), 0);\n+    }\n+    assert_eq!(drop_count(), 1);\n+\n+    {\n+        let z = &Droppable::new();\n+        let zz = &Droppable::new();\n+        a(|&: a: int, b| { z; zz; a + b });\n+        assert_eq!(drop_count(), 1);\n+    }\n+    assert_eq!(drop_count(), 3);\n+}\n+\n+fn test_fn_mut() {\n+    {\n+        b(|&mut: a: int, b| { a + b });\n+    }\n+    assert_eq!(drop_count(), 3);\n+\n+    {\n+        let z = &Droppable::new();\n+        b(|&mut: a: int, b| { z; a + b });\n+        assert_eq!(drop_count(), 3);\n+    }\n+    assert_eq!(drop_count(), 4);\n+\n+    {\n+        let z = &Droppable::new();\n+        let zz = &Droppable::new();\n+        b(|&mut: a: int, b| { z; zz; a + b });\n+        assert_eq!(drop_count(), 4);\n+    }\n+    assert_eq!(drop_count(), 6);\n+}\n+\n+fn test_fn_once() {\n+    {\n+        c(|: a: int, b| { a + b });\n+    }\n+    assert_eq!(drop_count(), 6);\n+\n+    {\n+        let z = Droppable::new();\n+        c(|: a: int, b| { z; a + b });\n+        assert_eq!(drop_count(), 7);\n+    }\n+    assert_eq!(drop_count(), 7);\n+\n+    {\n+        let z = Droppable::new();\n+        let zz = Droppable::new();\n+        c(|: a: int, b| { z; zz; a + b });\n+        assert_eq!(drop_count(), 9);\n+    }\n+    assert_eq!(drop_count(), 9);\n+}\n+\n+fn main() {\n+    test_fn();\n+    test_fn_mut();\n+    test_fn_once();\n+}\n+"}, {"sha": "754b1f706444bedef7dc8a36eba482b446e01a89", "filename": "src/test/run-pass/unboxed-closures-single-word-env.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d272321417df3a954802e42a66adda87ade5a49/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs?ref=8d272321417df3a954802e42a66adda87ade5a49", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensures that single-word environments work right in unboxed closures.\n+// These take a different path in codegen.\n+\n+#![feature(overloaded_calls, unboxed_closures)]\n+\n+fn a<F:|&: int, int| -> int>(f: F) -> int {\n+    f(1, 2)\n+}\n+\n+fn b<F:|&mut: int, int| -> int>(mut f: F) -> int {\n+    f(3, 4)\n+}\n+\n+fn c<F:|: int, int| -> int>(f: F) -> int {\n+    f(5, 6)\n+}\n+\n+fn main() {\n+    let z = 10;\n+    assert_eq!(a(|&: x: int, y| x + y + z), 13);\n+    assert_eq!(b(|&mut: x: int, y| x + y + z), 17);\n+    assert_eq!(c(|: x: int, y| x + y + z), 21);\n+}\n+"}]}