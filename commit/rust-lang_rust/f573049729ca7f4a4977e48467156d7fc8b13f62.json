{"sha": "f573049729ca7f4a4977e48467156d7fc8b13f62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NzMwNDk3MjljYTdmNGE0OTc3ZTQ4NDY3MTU2ZDdmYzhiMTNmNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-24T00:24:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-24T00:24:16Z"}, "message": "Auto merge of #58232 - ljedrz:HirIdification_continued, r=Zoxc\n\nHirId-ify intravisit\n\nA big step towards https://github.com/rust-lang/rust/pull/57578.\n\nThis affects mostly `hir::{collector, intravisit}` and `rustc::lint`.", "tree": {"sha": "f1e32eff18bb9243c5a3b05ae74b1432d8a86ace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1e32eff18bb9243c5a3b05ae74b1432d8a86ace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f573049729ca7f4a4977e48467156d7fc8b13f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f573049729ca7f4a4977e48467156d7fc8b13f62", "html_url": "https://github.com/rust-lang/rust/commit/f573049729ca7f4a4977e48467156d7fc8b13f62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f573049729ca7f4a4977e48467156d7fc8b13f62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aadbc459bd97a0325897e2ff94999efbec6a499c", "url": "https://api.github.com/repos/rust-lang/rust/commits/aadbc459bd97a0325897e2ff94999efbec6a499c", "html_url": "https://github.com/rust-lang/rust/commit/aadbc459bd97a0325897e2ff94999efbec6a499c"}, {"sha": "404e6435d0bbe3d4baf2e37bd225530d60bed6a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/404e6435d0bbe3d4baf2e37bd225530d60bed6a7", "html_url": "https://github.com/rust-lang/rust/commit/404e6435d0bbe3d4baf2e37bd225530d60bed6a7"}], "stats": {"total": 508, "additions": 254, "deletions": 254}, "files": [{"sha": "0bc40da7e4f2c0c0cf9841624494a9c73a397abe", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -31,7 +31,7 @@\n //! This order consistency is required in a few places in rustc, for\n //! example generator inference, and possibly also HIR borrowck.\n \n-use syntax::ast::{NodeId, CRATE_NODE_ID, Ident, Name, Attribute};\n+use syntax::ast::{Ident, Name, Attribute};\n use syntax_pos::Span;\n use crate::hir::*;\n use crate::hir::def::Def;\n@@ -225,7 +225,7 @@ pub trait Visitor<'v> : Sized {\n \n     ///////////////////////////////////////////////////////////////////////////\n \n-    fn visit_id(&mut self, _node_id: NodeId) {\n+    fn visit_id(&mut self, _hir_id: HirId) {\n         // Nothing to do.\n     }\n     fn visit_def_mention(&mut self, _def: Def) {\n@@ -237,7 +237,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_ident(&mut self, ident: Ident) {\n         walk_ident(self, ident)\n     }\n-    fn visit_mod(&mut self, m: &'v Mod, _s: Span, n: NodeId) {\n+    fn visit_mod(&mut self, m: &'v Mod, _s: Span, n: HirId) {\n         walk_mod(self, m, n)\n     }\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) {\n@@ -279,11 +279,11 @@ pub trait Visitor<'v> : Sized {\n     fn visit_fn_decl(&mut self, fd: &'v FnDecl) {\n         walk_fn_decl(self, fd)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: BodyId, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: BodyId, s: Span, id: HirId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n-    fn visit_use(&mut self, path: &'v Path, id: NodeId, hir_id: HirId) {\n-        walk_use(self, path, id, hir_id)\n+    fn visit_use(&mut self, path: &'v Path, hir_id: HirId) {\n+        walk_use(self, path, hir_id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n         walk_trait_item(self, ti)\n@@ -310,7 +310,7 @@ pub trait Visitor<'v> : Sized {\n                           s: &'v VariantData,\n                           _: Name,\n                           _: &'v Generics,\n-                          _parent_id: NodeId,\n+                          _parent_id: HirId,\n                           _: Span) {\n         walk_struct_def(self, s)\n     }\n@@ -320,11 +320,11 @@ pub trait Visitor<'v> : Sized {\n     fn visit_enum_def(&mut self,\n                       enum_definition: &'v EnumDef,\n                       generics: &'v Generics,\n-                      item_id: NodeId,\n+                      item_id: HirId,\n                       _: Span) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: HirId) {\n         walk_variant(self, v, g, item_id)\n     }\n     fn visit_label(&mut self, label: &'v Label) {\n@@ -373,27 +373,27 @@ pub trait Visitor<'v> : Sized {\n \n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n-    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n+    visitor.visit_mod(&krate.module, krate.span, CRATE_HIR_ID);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n     walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n }\n \n pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n-    visitor.visit_id(macro_def.id);\n+    visitor.visit_id(macro_def.hir_id);\n     visitor.visit_name(macro_def.span, macro_def.name);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_node_id: NodeId) {\n-    visitor.visit_id(mod_node_id);\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_hir_id: HirId) {\n+    visitor.visit_id(mod_hir_id);\n     for &item_id in &module.item_ids {\n         visitor.visit_nested_item(item_id);\n     }\n }\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n     for argument in &body.arguments {\n-        visitor.visit_id(argument.id);\n+        visitor.visit_id(argument.hir_id);\n         visitor.visit_pat(&argument.pat);\n     }\n     visitor.visit_expr(&body.value);\n@@ -404,7 +404,7 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n     walk_list!(visitor, visit_attribute, local.attrs.iter());\n-    visitor.visit_id(local.id);\n+    visitor.visit_id(local.hir_id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n }\n@@ -418,7 +418,7 @@ pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n }\n \n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n-    visitor.visit_id(lifetime.id);\n+    visitor.visit_id(lifetime.hir_id);\n     match lifetime.name {\n         LifetimeName::Param(ParamName::Plain(ident)) => {\n             visitor.visit_ident(ident);\n@@ -444,7 +444,7 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n     where V: Visitor<'v>\n {\n-    visitor.visit_id(trait_ref.ref_id);\n+    visitor.visit_id(trait_ref.hir_ref_id);\n     visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n }\n \n@@ -453,17 +453,17 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.ident);\n     match item.node {\n         ItemKind::ExternCrate(orig_name) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n             if let Some(orig_name) = orig_name {\n                 visitor.visit_name(item.span, orig_name);\n             }\n         }\n         ItemKind::Use(ref path, _) => {\n-            visitor.visit_use(path, item.id, item.hir_id);\n+            visitor.visit_use(path, item.hir_id);\n         }\n         ItemKind::Static(ref typ, _, body) |\n         ItemKind::Const(ref typ, body) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n@@ -476,26 +476,26 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                              declaration,\n                              body_id,\n                              item.span,\n-                             item.id)\n+                             item.hir_id)\n         }\n         ItemKind::Mod(ref module) => {\n-            // `visit_mod()` takes care of visiting the `Item`'s `NodeId`.\n-            visitor.visit_mod(module, item.span, item.id)\n+            // `visit_mod()` takes care of visiting the `Item`'s `HirId`.\n+            visitor.visit_mod(module, item.span, item.hir_id)\n         }\n         ItemKind::ForeignMod(ref foreign_module) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n         ItemKind::GlobalAsm(_) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n         }\n         ItemKind::Ty(ref typ, ref type_parameters) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n         ItemKind::Existential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             if let Some(impl_trait_fn) = impl_trait_fn {\n@@ -504,8 +504,8 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n-            // `visit_enum_def()` takes care of visiting the `Item`'s `NodeId`.\n-            visitor.visit_enum_def(enum_definition, type_parameters, item.id, item.span)\n+            // `visit_enum_def()` takes care of visiting the `Item`'s `HirId`.\n+            visitor.visit_enum_def(enum_definition, type_parameters, item.hir_id, item.span)\n         }\n         ItemKind::Impl(\n             ..,\n@@ -514,7 +514,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             ref typ,\n             ref impl_item_refs\n         ) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n@@ -523,18 +523,18 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         ItemKind::Struct(ref struct_definition, ref generics) |\n         ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_id(item.id);\n-            visitor.visit_variant_data(struct_definition, item.ident.name, generics, item.id,\n+            visitor.visit_id(item.hir_id);\n+            visitor.visit_variant_data(struct_definition, item.ident.name, generics, item.hir_id,\n                                        item.span);\n         }\n         ItemKind::Trait(.., ref generics, ref bounds, ref trait_item_refs) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n         ItemKind::TraitAlias(ref generics, ref bounds) => {\n-            visitor.visit_id(item.id);\n+            visitor.visit_id(item.hir_id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n@@ -544,16 +544,15 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n \n pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V,\n                                     path: &'v Path,\n-                                    item_id: NodeId,\n                                     hir_id: HirId) {\n-    visitor.visit_id(item_id);\n+    visitor.visit_id(hir_id);\n     visitor.visit_path(path, hir_id);\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n                                          generics: &'v Generics,\n-                                         item_id: NodeId) {\n+                                         item_id: HirId) {\n     visitor.visit_id(item_id);\n     walk_list!(visitor,\n                visit_variant,\n@@ -565,7 +564,7 @@ pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n                                         generics: &'v Generics,\n-                                        parent_item_id: NodeId) {\n+                                        parent_item_id: HirId) {\n     visitor.visit_ident(variant.node.ident);\n     visitor.visit_variant_data(&variant.node.data,\n                                variant.node.ident.name,\n@@ -577,7 +576,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n-    visitor.visit_id(typ.id);\n+    visitor.visit_id(typ.hir_id);\n \n     match typ.node {\n         TyKind::Slice(ref ty) => {\n@@ -648,7 +647,7 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n     visitor.visit_ident(segment.ident);\n-    if let Some(id) = segment.id {\n+    if let Some(id) = segment.hir_id {\n         visitor.visit_id(id);\n     }\n     if let Some(ref args) = segment.args {\n@@ -665,13 +664,13 @@ pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n-    visitor.visit_id(type_binding.id);\n+    visitor.visit_id(type_binding.hir_id);\n     visitor.visit_ident(type_binding.ident);\n     visitor.visit_ty(&type_binding.ty);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n-    visitor.visit_id(pattern.id);\n+    visitor.visit_id(pattern.hir_id);\n     match pattern.node {\n         PatKind::TupleStruct(ref qpath, ref children, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n@@ -683,7 +682,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Struct(ref qpath, ref fields, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n             for field in fields {\n-                visitor.visit_id(field.node.id);\n+                visitor.visit_id(field.node.hir_id);\n                 visitor.visit_ident(field.node.ident);\n                 visitor.visit_pat(&field.node.pat)\n             }\n@@ -715,7 +714,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n }\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem) {\n-    visitor.visit_id(foreign_item.id);\n+    visitor.visit_id(foreign_item.hir_id);\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.ident);\n \n@@ -744,7 +743,7 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericB\n }\n \n pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam) {\n-    visitor.visit_id(param.id);\n+    visitor.visit_id(param.hir_id);\n     walk_list!(visitor, visit_attribute, &param.attrs);\n     match param.name {\n         ParamName::Plain(ident) => visitor.visit_ident(ident),\n@@ -760,7 +759,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n     walk_list!(visitor, visit_generic_param, &generics.params);\n-    visitor.visit_id(generics.where_clause.id);\n+    visitor.visit_id(generics.where_clause.hir_id);\n     walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n }\n \n@@ -783,11 +782,11 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n             visitor.visit_lifetime(lifetime);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n-        &WherePredicate::EqPredicate(WhereEqPredicate{id,\n+        &WherePredicate::EqPredicate(WhereEqPredicate{hir_id,\n                                                       ref lhs_ty,\n                                                       ref rhs_ty,\n                                                       ..}) => {\n-            visitor.visit_id(id);\n+            visitor.visit_id(hir_id);\n             visitor.visit_ty(lhs_ty);\n             visitor.visit_ty(rhs_ty);\n         }\n@@ -822,7 +821,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_declaration: &'v FnDecl,\n                                    body_id: BodyId,\n                                    _span: Span,\n-                                   id: NodeId) {\n+                                   id: HirId) {\n     visitor.visit_id(id);\n     visitor.visit_fn_decl(function_declaration);\n     walk_fn_kind(visitor, function_kind);\n@@ -835,12 +834,12 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.node {\n         TraitItemKind::Const(ref ty, default) => {\n-            visitor.visit_id(trait_item.id);\n+            visitor.visit_id(trait_item.hir_id);\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_nested_body, default);\n         }\n         TraitItemKind::Method(ref sig, TraitMethod::Required(ref param_names)) => {\n-            visitor.visit_id(trait_item.id);\n+            visitor.visit_id(trait_item.hir_id);\n             visitor.visit_fn_decl(&sig.decl);\n             for &param_name in param_names {\n                 visitor.visit_ident(param_name);\n@@ -854,10 +853,10 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n                              &sig.decl,\n                              body_id,\n                              trait_item.span,\n-                             trait_item.id);\n+                             trait_item.hir_id);\n         }\n         TraitItemKind::Type(ref bounds, ref default) => {\n-            visitor.visit_id(trait_item.id);\n+            visitor.visit_id(trait_item.hir_id);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n@@ -894,7 +893,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     visitor.visit_generics(generics);\n     match *node {\n         ImplItemKind::Const(ref ty, body) => {\n-            visitor.visit_id(impl_item.id);\n+            visitor.visit_id(impl_item.hir_id);\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(body);\n         }\n@@ -906,14 +905,14 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n                              &sig.decl,\n                              body_id,\n                              impl_item.span,\n-                             impl_item.id);\n+                             impl_item.hir_id);\n         }\n         ImplItemKind::Type(ref ty) => {\n-            visitor.visit_id(impl_item.id);\n+            visitor.visit_id(impl_item.hir_id);\n             visitor.visit_ty(ty);\n         }\n         ImplItemKind::Existential(ref bounds) => {\n-            visitor.visit_id(impl_item.id);\n+            visitor.visit_id(impl_item.hir_id);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n     }\n@@ -931,26 +930,26 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n \n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n-    visitor.visit_id(struct_definition.id());\n+    visitor.visit_id(struct_definition.hir_id());\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField) {\n-    visitor.visit_id(struct_field.id);\n+    visitor.visit_id(struct_field.hir_id);\n     visitor.visit_vis(&struct_field.vis);\n     visitor.visit_ident(struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n-    visitor.visit_id(block.id);\n+    visitor.visit_id(block.hir_id);\n     walk_list!(visitor, visit_stmt, &block.stmts);\n     walk_list!(visitor, visit_expr, &block.expr);\n }\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n-    visitor.visit_id(statement.id);\n+    visitor.visit_id(statement.hir_id);\n     match statement.node {\n         StmtKind::Local(ref local) => visitor.visit_local(local),\n         StmtKind::Item(item) => visitor.visit_nested_item(item),\n@@ -962,12 +961,12 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n }\n \n pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n-    visitor.visit_id(constant.id);\n+    visitor.visit_id(constant.hir_id);\n     visitor.visit_nested_body(constant.body);\n }\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n-    visitor.visit_id(expression.id);\n+    visitor.visit_id(expression.hir_id);\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n     match expression.node {\n         ExprKind::Box(ref subexpression) => {\n@@ -983,7 +982,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::Struct(ref qpath, ref fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n             for field in fields {\n-                visitor.visit_id(field.id);\n+                visitor.visit_id(field.hir_id);\n                 visitor.visit_ident(field.ident);\n                 visitor.visit_expr(&field.expr)\n             }\n@@ -1035,7 +1034,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                              function_declaration,\n                              body,\n                              expression.span,\n-                             expression.id)\n+                             expression.hir_id)\n         }\n         ExprKind::Block(ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n@@ -1104,8 +1103,8 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n-    if let VisibilityKind::Restricted { ref path, id, hir_id } = vis.node {\n-        visitor.visit_id(id);\n+    if let VisibilityKind::Restricted { ref path, id: _, hir_id } = vis.node {\n+        visitor.visit_id(hir_id);\n         visitor.visit_path(path, hir_id)\n     }\n }"}, {"sha": "d55f62d3e1a59d6caeb197915fdddb2e3ea625e4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -3301,7 +3301,9 @@ impl<'a> LoweringContext<'a> {\n         let mut path = path.clone();\n         for seg in path.segments.iter_mut() {\n             if seg.id.is_some() {\n-                seg.id = Some(self.next_id().node_id);\n+                let next_id = self.next_id();\n+                seg.id = Some(next_id.node_id);\n+                seg.hir_id = Some(next_id.hir_id);\n             }\n         }\n         path"}, {"sha": "04eec88004aa6fade46a7b55ab874faae3853873", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -27,9 +27,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The node map\n     map: Vec<Option<Entry<'hir>>>,\n     /// The parent of this node\n-    parent_node: NodeId,\n-\n-    parent_hir: hir::HirId,\n+    parent_node: hir::HirId,\n \n     // These fields keep track of the currently relevant DepNodes during\n     // the visitor's traversal.\n@@ -40,6 +38,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n \n     dep_graph: &'a DepGraph,\n     definitions: &'a definitions::Definitions,\n+    hir_to_node_id: &'a FxHashMap<HirId, NodeId>,\n \n     hcx: StableHashingContext<'a>,\n \n@@ -100,6 +99,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                        krate: &'hir Crate,\n                        dep_graph: &'a DepGraph,\n                        definitions: &'a definitions::Definitions,\n+                       hir_to_node_id: &'a FxHashMap<HirId, NodeId>,\n                        mut hcx: StableHashingContext<'a>)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n@@ -147,14 +147,14 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             krate,\n             source_map: sess.source_map(),\n             map: repeat(None).take(sess.current_node_id_count()).collect(),\n-            parent_node: CRATE_NODE_ID,\n-            parent_hir: hir::CRATE_HIR_ID,\n+            parent_node: hir::CRATE_HIR_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n             current_dep_node_owner: CRATE_DEF_INDEX,\n             currently_in_body: false,\n             dep_graph,\n             definitions,\n+            hir_to_node_id,\n             hcx,\n             hir_body_nodes,\n         };\n@@ -228,10 +228,10 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.map[id.as_usize()] = Some(entry);\n     }\n \n-    fn insert(&mut self, span: Span, id: NodeId, node: Node<'hir>) {\n+    fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n         let entry = Entry {\n-            parent: self.parent_node,\n-            parent_hir: self.parent_hir,\n+            parent: self.hir_to_node_id[&self.parent_node],\n+            parent_hir: self.parent_node,\n             dep_node: if self.currently_in_body {\n                 self.current_full_dep_index\n             } else {\n@@ -240,21 +240,23 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             node,\n         };\n \n+        let node_id = self.hir_to_node_id[&hir_id];\n+\n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-            let hir_id = self.definitions.node_to_hir_id(id);\n+           assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n \n             if hir_id.owner != self.current_dep_node_owner {\n-                let node_str = match self.definitions.opt_def_index(id) {\n+                let node_str = match self.definitions.opt_def_index(node_id) {\n                     Some(def_index) => {\n                         self.definitions.def_path(def_index).to_string_no_crate()\n                     }\n                     None => format!(\"{:?}\", node)\n                 };\n \n                 let forgot_str = if hir_id == crate::hir::DUMMY_HIR_ID {\n-                    format!(\"\\nMaybe you forgot to lower the node id {:?}?\", id)\n+                    format!(\"\\nMaybe you forgot to lower the node id {:?}?\", node_id)\n                 } else {\n                     String::new()\n                 };\n@@ -276,12 +278,16 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             }\n         }\n \n-        self.insert_entry(id, entry);\n+        self.insert_entry(node_id, entry);\n     }\n \n-    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_id: NodeId, f: F) {\n+    fn with_parent<F: FnOnce(&mut Self)>(\n+        &mut self,\n+        parent_node_id: HirId,\n+        f: F,\n+    ) {\n         let parent_node = self.parent_node;\n-        self.parent_node = parent_id;\n+        self.parent_node = parent_node_id;\n         f(self);\n         self.parent_node = parent_node;\n     }\n@@ -352,12 +358,12 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n-            this.insert(i.span, i.id, Node::Item(i));\n-            this.with_parent(i.id, |this| {\n+            this.insert(i.span, i.hir_id, Node::Item(i));\n+            this.with_parent(i.hir_id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.node {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n-                        this.insert(i.span, struct_def.id(), Node::StructCtor(struct_def));\n+                        this.insert(i.span, struct_def.hir_id(), Node::StructCtor(struct_def));\n                     }\n                 }\n                 intravisit::walk_item(this, i);\n@@ -366,25 +372,25 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n-        self.insert(foreign_item.span, foreign_item.id, Node::ForeignItem(foreign_item));\n+        self.insert(foreign_item.span, foreign_item.hir_id, Node::ForeignItem(foreign_item));\n \n-        self.with_parent(foreign_item.id, |this| {\n+        self.with_parent(foreign_item.hir_id, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        self.insert(param.span, param.id, Node::GenericParam(param));\n+        self.insert(param.span, param.hir_id, Node::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n-            this.insert(ti.span, ti.id, Node::TraitItem(ti));\n+            this.insert(ti.span, ti.hir_id, Node::TraitItem(ti));\n \n-            this.with_parent(ti.id, |this| {\n+            this.with_parent(ti.hir_id, |this| {\n                 intravisit::walk_trait_item(this, ti);\n             });\n         });\n@@ -394,9 +400,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n-            this.insert(ii.span, ii.id, Node::ImplItem(ii));\n+            this.insert(ii.span, ii.hir_id, Node::ImplItem(ii));\n \n-            this.with_parent(ii.id, |this| {\n+            this.with_parent(ii.hir_id, |this| {\n                 intravisit::walk_impl_item(this, ii);\n             });\n         });\n@@ -408,93 +414,92 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         } else {\n             Node::Pat(pat)\n         };\n-        self.insert(pat.span, pat.id, node);\n+        self.insert(pat.span, pat.hir_id, node);\n \n-        self.with_parent(pat.id, |this| {\n+        self.with_parent(pat.hir_id, |this| {\n             intravisit::walk_pat(this, pat);\n         });\n     }\n \n     fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n-        self.insert(DUMMY_SP, constant.id, Node::AnonConst(constant));\n+        self.insert(DUMMY_SP, constant.hir_id, Node::AnonConst(constant));\n \n-        self.with_parent(constant.id, |this| {\n+        self.with_parent(constant.hir_id, |this| {\n             intravisit::walk_anon_const(this, constant);\n         });\n     }\n \n     fn visit_expr(&mut self, expr: &'hir Expr) {\n-        self.insert(expr.span, expr.id, Node::Expr(expr));\n+        self.insert(expr.span, expr.hir_id, Node::Expr(expr));\n \n-        self.with_parent(expr.id, |this| {\n+        self.with_parent(expr.hir_id, |this| {\n             intravisit::walk_expr(this, expr);\n         });\n     }\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n-        let id = stmt.id;\n-        self.insert(stmt.span, id, Node::Stmt(stmt));\n+        self.insert(stmt.span, stmt.hir_id, Node::Stmt(stmt));\n \n-        self.with_parent(id, |this| {\n+        self.with_parent(stmt.hir_id, |this| {\n             intravisit::walk_stmt(this, stmt);\n         });\n     }\n \n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment) {\n-        if let Some(id) = path_segment.id {\n-            self.insert(path_span, id, Node::PathSegment(path_segment));\n+        if let Some(hir_id) = path_segment.hir_id {\n+            self.insert(path_span, hir_id, Node::PathSegment(path_segment));\n         }\n         intravisit::walk_path_segment(self, path_span, path_segment);\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty) {\n-        self.insert(ty.span, ty.id, Node::Ty(ty));\n+        self.insert(ty.span, ty.hir_id, Node::Ty(ty));\n \n-        self.with_parent(ty.id, |this| {\n+        self.with_parent(ty.hir_id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n-        self.insert(tr.path.span, tr.ref_id, Node::TraitRef(tr));\n+        self.insert(tr.path.span, tr.hir_ref_id, Node::TraitRef(tr));\n \n-        self.with_parent(tr.ref_id, |this| {\n+        self.with_parent(tr.hir_ref_id, |this| {\n             intravisit::walk_trait_ref(this, tr);\n         });\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'hir>, fd: &'hir FnDecl,\n-                b: BodyId, s: Span, id: NodeId) {\n+                b: BodyId, s: Span, id: HirId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n \n     fn visit_block(&mut self, block: &'hir Block) {\n-        self.insert(block.span, block.id, Node::Block(block));\n-        self.with_parent(block.id, |this| {\n+        self.insert(block.span, block.hir_id, Node::Block(block));\n+        self.with_parent(block.hir_id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n     fn visit_local(&mut self, l: &'hir Local) {\n-        self.insert(l.span, l.id, Node::Local(l));\n-        self.with_parent(l.id, |this| {\n+        self.insert(l.span, l.hir_id, Node::Local(l));\n+        self.with_parent(l.hir_id, |this| {\n             intravisit::walk_local(this, l)\n         })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.span, lifetime.id, Node::Lifetime(lifetime));\n+        self.insert(lifetime.span, lifetime.hir_id, Node::Lifetime(lifetime));\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n         match visibility.node {\n             VisibilityKind::Public |\n             VisibilityKind::Crate(_) |\n             VisibilityKind::Inherited => {}\n-            VisibilityKind::Restricted { id, .. } => {\n-                self.insert(visibility.span, id, Node::Visibility(visibility));\n-                self.with_parent(id, |this| {\n+            VisibilityKind::Restricted { hir_id, .. } => {\n+                self.insert(visibility.span, hir_id, Node::Visibility(visibility));\n+                self.with_parent(hir_id, |this| {\n                     intravisit::walk_vis(this, visibility);\n                 });\n             }\n@@ -505,21 +510,20 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n-            this.insert(macro_def.span, macro_def.id, Node::MacroDef(macro_def));\n+            this.insert(macro_def.span, macro_def.hir_id, Node::MacroDef(macro_def));\n         });\n     }\n \n-    fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n-        let id = v.node.data.id();\n-        self.insert(v.span, id, Node::Variant(v));\n-        self.with_parent(id, |this| {\n+    fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: HirId) {\n+        self.insert(v.span, v.node.data.hir_id(), Node::Variant(v));\n+        self.with_parent(v.node.data.hir_id(), |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, field: &'hir StructField) {\n-        self.insert(field.span, field.id, Node::Field(field));\n-        self.with_parent(field.id, |this| {\n+        self.insert(field.span, field.hir_id, Node::Field(field));\n+        self.with_parent(field.hir_id, |this| {\n             intravisit::walk_struct_field(this, field);\n         });\n     }"}, {"sha": "fafe671b9eb8b6970ebdb060dc27889efcaf925d", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -2,7 +2,7 @@ use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use crate::hir::{self, intravisit, HirId, ItemLocalId};\n use syntax::ast::NodeId;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{Lock, ParallelIterator, par_iter};\n \n pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n@@ -30,7 +30,7 @@ pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n struct HirIdValidator<'a, 'hir: 'a> {\n     hir_map: &'a hir::map::Map<'hir>,\n     owner_def_index: Option<DefIndex>,\n-    hir_ids_seen: FxHashMap<ItemLocalId, NodeId>,\n+    hir_ids_seen: FxHashSet<ItemLocalId>,\n     errors: &'a Lock<Vec<String>>,\n }\n \n@@ -55,17 +55,17 @@ impl<'a, 'hir: 'a> OuterVisitor<'a, 'hir> {\n impl<'a, 'hir: 'a> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir hir::Item) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.id, |this| intravisit::walk_item(this, i));\n+        inner_visitor.check(i.hir_id, |this| intravisit::walk_item(this, i));\n     }\n \n     fn visit_trait_item(&mut self, i: &'hir hir::TraitItem) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.id, |this| intravisit::walk_trait_item(this, i));\n+        inner_visitor.check(i.hir_id, |this| intravisit::walk_trait_item(this, i));\n     }\n \n     fn visit_impl_item(&mut self, i: &'hir hir::ImplItem) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.id, |this| intravisit::walk_impl_item(this, i));\n+        inner_visitor.check(i.hir_id, |this| intravisit::walk_impl_item(this, i));\n     }\n }\n \n@@ -77,10 +77,10 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n     }\n \n     fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self,\n-                                                       node_id: NodeId,\n+                                                       hir_id: HirId,\n                                                        walk: F) {\n         assert!(self.owner_def_index.is_none());\n-        let owner_def_index = self.hir_map.local_def_id(node_id).index;\n+        let owner_def_index = self.hir_map.local_def_id_from_hir_id(hir_id).index;\n         self.owner_def_index = Some(owner_def_index);\n         walk(self);\n \n@@ -90,15 +90,15 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n \n         // There's always at least one entry for the owning item itself\n         let max = self.hir_ids_seen\n-                      .keys()\n+                      .iter()\n                       .map(|local_id| local_id.as_usize())\n                       .max()\n                       .expect(\"owning item has no entry\");\n \n         if max != self.hir_ids_seen.len() - 1 {\n             // Collect the missing ItemLocalIds\n             let missing: Vec<_> = (0 ..= max as u32)\n-              .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId::from_u32(i)))\n+              .filter(|&i| !self.hir_ids_seen.contains(&ItemLocalId::from_u32(i)))\n               .collect();\n \n             // Try to map those to something more useful\n@@ -133,8 +133,12 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                 max,\n                 missing_items,\n                 self.hir_ids_seen\n-                    .values()\n-                    .map(|n| format!(\"({:?} {})\", n, self.hir_map.node_to_string(*n)))\n+                    .iter()\n+                    .map(|&local_id| HirId {\n+                        owner: owner_def_index,\n+                        local_id,\n+                    })\n+                    .map(|h| format!(\"({:?} {})\", h, self.hir_map.hir_to_string(h)))\n                     .collect::<Vec<_>>()));\n         }\n     }\n@@ -147,35 +151,24 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         intravisit::NestedVisitorMap::OnlyBodies(self.hir_map)\n     }\n \n-    fn visit_id(&mut self, node_id: NodeId) {\n+    fn visit_id(&mut self, hir_id: HirId) {\n         let owner = self.owner_def_index.expect(\"no owner_def_index\");\n-        let stable_id = self.hir_map.definitions().node_to_hir_id[node_id];\n \n-        if stable_id == hir::DUMMY_HIR_ID {\n-            self.error(|| format!(\"HirIdValidator: No HirId assigned for NodeId {}: {:?}\",\n-                                     node_id,\n-                                     self.hir_map.node_to_string(node_id)));\n+        if hir_id == hir::DUMMY_HIR_ID {\n+            self.error(|| format!(\"HirIdValidator: HirId {:?} is invalid\",\n+                                  self.hir_map.hir_to_string(hir_id)));\n             return;\n         }\n \n-        if owner != stable_id.owner {\n+        if owner != hir_id.owner {\n             self.error(|| format!(\n                 \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n-                self.hir_map.node_to_string(node_id),\n-                self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n+                self.hir_map.hir_to_string(hir_id),\n+                self.hir_map.def_path(DefId::local(hir_id.owner)).to_string_no_crate(),\n                 self.hir_map.def_path(DefId::local(owner)).to_string_no_crate()));\n         }\n \n-        if let Some(prev) = self.hir_ids_seen.insert(stable_id.local_id, node_id) {\n-            if prev != node_id {\n-                self.error(|| format!(\n-                    \"HirIdValidator: Same HirId {}/{} assigned for nodes {} and {}\",\n-                    self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n-                    stable_id.local_id.as_usize(),\n-                    self.hir_map.node_to_string(prev),\n-                    self.hir_map.node_to_string(node_id)));\n-            }\n-        }\n+        self.hir_ids_seen.insert(hir_id.local_id);\n     }\n \n     fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {"}, {"sha": "39203208855e0341ac3e103fad046f741ab23115", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -11,7 +11,6 @@ use crate::middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::join;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n@@ -1242,13 +1241,18 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        forest: &'hir Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n-    let ((map, crate_hash), hir_to_node_id) = join(|| {\n+    // Build the reverse mapping of `node_to_hir_id`.\n+    let hir_to_node_id = definitions.node_to_hir_id.iter_enumerated()\n+        .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n+\n+    let (map, crate_hash) = {\n         let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n \n         let mut collector = NodeCollector::root(sess,\n                                                 &forest.krate,\n                                                 &forest.dep_graph,\n                                                 &definitions,\n+                                                &hir_to_node_id,\n                                                 hcx);\n         intravisit::walk_crate(&mut collector, &forest.krate);\n \n@@ -1259,11 +1263,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n             cstore,\n             cmdline_args\n         )\n-    }, || {\n-        // Build the reverse mapping of `node_to_hir_id`.\n-        definitions.node_to_hir_id.iter_enumerated()\n-                    .map(|(node_id, &hir_id)| (hir_id, node_id)).collect()\n-    });\n+    };\n \n     if log_enabled!(::log::Level::Debug) {\n         // This only makes sense for ordered stores; note the"}, {"sha": "dda314429fc8579d1d796000f63f7477b7e11f87", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -519,7 +519,7 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     /// The store of registered lints and the lint levels.\n     lint_sess: LintSession<'tcx, LateLintPassObject>,\n \n-    last_ast_node_with_lint_attrs: ast::NodeId,\n+    last_node_with_lint_attrs: hir::HirId,\n \n     /// Generic type parameters in scope for the item we are in.\n     pub generics: Option<&'tcx hir::Generics>,\n@@ -564,7 +564,6 @@ impl LintPassObject for EarlyLintPassObject {}\n \n impl LintPassObject for LateLintPassObject {}\n \n-\n pub trait LintContext<'tcx>: Sized {\n     type PassObject: LintPassObject;\n \n@@ -725,10 +724,14 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n                                   span: Option<S>,\n                                   msg: &str)\n                                   -> DiagnosticBuilder<'_> {\n-        let id = self.last_ast_node_with_lint_attrs;\n+        let hir_id = self.last_node_with_lint_attrs;\n+\n         match span {\n-            Some(s) => self.tcx.struct_span_lint_node(lint, id, s, msg),\n-            None => self.tcx.struct_lint_node(lint, id, msg),\n+            Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, msg),\n+            None => {\n+                let node_id = self.tcx.hir().hir_to_node_id(hir_id); // FIXME(@ljedrz): remove later\n+                self.tcx.struct_lint_node(lint, node_id, msg)\n+            },\n         }\n     }\n }\n@@ -767,17 +770,17 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n-                          id: ast::NodeId,\n+                          id: hir::HirId,\n                           attrs: &'tcx [ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let prev = self.last_ast_node_with_lint_attrs;\n-        self.last_ast_node_with_lint_attrs = id;\n+        let prev = self.last_node_with_lint_attrs;\n+        self.last_node_with_lint_attrs = id;\n         self.enter_attrs(attrs);\n         f(self);\n         self.exit_attrs(attrs);\n-        self.last_ast_node_with_lint_attrs = prev;\n+        self.last_node_with_lint_attrs = prev;\n     }\n \n     fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n@@ -798,8 +801,8 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         f(self);\n         self.param_env = old_param_env;\n     }\n-    pub fn current_lint_root(&self) -> ast::NodeId {\n-        self.last_ast_node_with_lint_attrs\n+    pub fn current_lint_root(&self) -> hir::HirId {\n+        self.last_node_with_lint_attrs\n     }\n }\n \n@@ -837,7 +840,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let generics = self.generics.take();\n         self.generics = it.node.generics();\n-        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.id, |cx| {\n                 run_lints!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n@@ -848,7 +851,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n-        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.id, |cx| {\n                 run_lints!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n@@ -863,7 +866,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n-        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n+        self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n             run_lints!(cx, check_expr, e);\n             hir_visit::walk_expr(cx, e);\n             run_lints!(cx, check_expr_post, e);\n@@ -881,7 +884,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n+                body_id: hir::BodyId, span: Span, id: hir::HirId) {\n         // Wrap in tables here, not just in visit_nested_body,\n         // in order for `check_fn` to be able to use them.\n         let old_tables = self.tables;\n@@ -897,15 +900,15 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                         s: &'tcx hir::VariantData,\n                         name: ast::Name,\n                         g: &'tcx hir::Generics,\n-                        item_id: ast::NodeId,\n+                        item_id: hir::HirId,\n                         _: Span) {\n         run_lints!(self, check_struct_def, s, name, g, item_id);\n         hir_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, s, name, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n+        self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n@@ -914,8 +917,8 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     fn visit_variant(&mut self,\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n-                     item_id: ast::NodeId) {\n-        self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |cx| {\n+                     item_id: hir::HirId) {\n+        self.with_lint_attrs(v.node.data.hir_id(), &v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -931,14 +934,14 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         run_lints!(self, check_name, sp, name);\n     }\n \n-    fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n         run_lints!(self, check_mod, m, s, n);\n         hir_visit::walk_mod(self, m, n);\n         run_lints!(self, check_mod_post, m, s, n);\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n+        self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n             run_lints!(cx, check_local, l);\n             hir_visit::walk_local(cx, l);\n         })\n@@ -979,7 +982,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         let generics = self.generics.take();\n         self.generics = Some(&trait_item.generics);\n-        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n+        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n             cx.with_param_env(trait_item.id, |cx| {\n                 run_lints!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n@@ -992,7 +995,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         let generics = self.generics.take();\n         self.generics = Some(&impl_item.generics);\n-        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n+        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n             cx.with_param_env(impl_item.id, |cx| {\n                 run_lints!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n@@ -1219,12 +1222,12 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                 passes,\n                 lints: tcx.sess.lint_store.borrow(),\n             },\n-            last_ast_node_with_lint_attrs: ast::CRATE_NODE_ID,\n+            last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n             generics: None,\n         };\n \n         // Visit the whole crate.\n-        cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n+        cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n             // since the root module isn't visited as an item (because it isn't an\n             // item), warn for it here.\n             run_lints!(cx, check_crate, krate);"}, {"sha": "6c60f3f5a80a3de29d435881076fe0111bfe1d41", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -182,8 +182,8 @@ macro_rules! late_lint_methods {\n             fn check_name(a: Span, b: ast::Name);\n             fn check_crate(a: &$hir hir::Crate);\n             fn check_crate_post(a: &$hir hir::Crate);\n-            fn check_mod(a: &$hir hir::Mod, b: Span, c: ast::NodeId);\n-            fn check_mod_post(a: &$hir hir::Mod, b: Span, c: ast::NodeId);\n+            fn check_mod(a: &$hir hir::Mod, b: Span, c: hir::HirId);\n+            fn check_mod_post(a: &$hir hir::Mod, b: Span, c: hir::HirId);\n             fn check_foreign_item(a: &$hir hir::ForeignItem);\n             fn check_foreign_item_post(a: &$hir hir::ForeignItem);\n             fn check_item(a: &$hir hir::Item);\n@@ -206,13 +206,13 @@ macro_rules! late_lint_methods {\n                 b: &$hir hir::FnDecl,\n                 c: &$hir hir::Body,\n                 d: Span,\n-                e: ast::NodeId);\n+                e: hir::HirId);\n             fn check_fn_post(\n                 a: hir::intravisit::FnKind<$hir>,\n                 b: &$hir hir::FnDecl,\n                 c: &$hir hir::Body,\n                 d: Span,\n-                e: ast::NodeId\n+                e: hir::HirId\n             );\n             fn check_trait_item(a: &$hir hir::TraitItem);\n             fn check_trait_item_post(a: &$hir hir::TraitItem);\n@@ -222,13 +222,13 @@ macro_rules! late_lint_methods {\n                 a: &$hir hir::VariantData,\n                 b: ast::Name,\n                 c: &$hir hir::Generics,\n-                d: ast::NodeId\n+                d: hir::HirId\n             );\n             fn check_struct_def_post(\n                 a: &$hir hir::VariantData,\n                 b: ast::Name,\n                 c: &$hir hir::Generics,\n-                d: ast::NodeId\n+                d: hir::HirId\n             );\n             fn check_struct_field(a: &$hir hir::StructField);\n             fn check_variant(a: &$hir hir::Variant, b: &$hir hir::Generics);\n@@ -781,7 +781,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n     fn visit_variant(&mut self,\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n-                     item_id: ast::NodeId) {\n+                     item_id: hir::HirId) {\n         self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })"}, {"sha": "878d93c66cc24ac09fc611a9d7d442eee59cad6c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -211,7 +211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_variant_data(&mut self, def: &'tcx hir::VariantData, _: ast::Name,\n-                          _: &hir::Generics, _: ast::NodeId, _: syntax_pos::Span) {\n+                          _: &hir::Generics, _: hir::HirId, _: syntax_pos::Span) {\n         let has_repr_c = self.repr_has_repr_c;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n         let live_fields = def.fields().iter().filter(|f| {\n@@ -570,7 +570,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     fn visit_variant(&mut self,\n                      variant: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n-                     id: ast::NodeId) {\n+                     id: hir::HirId) {\n         if self.should_warn_about_variant(&variant.node) {\n             self.warn_dead_code(variant.node.data.id(), variant.span, variant.node.ident.name,\n                                 \"variant\", \"constructed\");"}, {"sha": "03e16494b038605b357eba961cd2e0261096736b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::BodyId, s: Span, id: NodeId) {\n+                b: hir::BodyId, s: Span, id: HirId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n \n@@ -358,16 +358,16 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n                           decl: &'tcx hir::FnDecl,\n                           body_id: hir::BodyId,\n                           sp: Span,\n-                          id: ast::NodeId) {\n+                          id: hir::HirId) {\n     debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:\n     let mut fn_maps = IrMaps::new(ir.tcx);\n \n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n-        let parent = ir.tcx.hir().get_parent(id);\n-        if let Some(Node::Item(i)) = ir.tcx.hir().find(parent) {\n+        let parent = ir.tcx.hir().get_parent_item(id);\n+        if let Some(Node::Item(i)) = ir.tcx.hir().find_by_hir_id(parent) {\n             if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n                 return;\n             }"}, {"sha": "707d3484982edd4a8be2c12a831a370f85fe1035", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n         self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnotationKind::Required, |v| {\n             intravisit::walk_variant(v, var, g, item_id);\n         })\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n         intravisit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n         self.check_missing_stability(var.node.data.id(), var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }"}, {"sha": "9a00c43be3fbb0da3f9061993ace43a8b3cb77ef", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -88,8 +88,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            let var_node_id = bccx.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n-            err.span_label(bccx.tcx.hir().span(var_node_id),\n+            err.span_label(bccx.tcx.hir().span_by_hir_id(upvar_id.var_path.hir_id),\n                            \"captured outer variable\");\n         }\n         err.emit();"}, {"sha": "31189a71bba82cf87e2bd1c2e02e7385c4bca74c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -703,20 +703,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         // Get type of value and span where it was previously\n         // moved.\n-        let node_id = self.tcx.hir().hir_to_node_id(hir::HirId {\n+        let hir_id = hir::HirId {\n             owner: self.body.value.hir_id.owner,\n             local_id: the_move.id\n-        });\n+        };\n         let (move_span, move_note) = match the_move.kind {\n             move_data::Declared => {\n                 unreachable!();\n             }\n \n             move_data::MoveExpr |\n-            move_data::MovePat => (self.tcx.hir().span(node_id), \"\"),\n+            move_data::MovePat => (self.tcx.hir().span_by_hir_id(hir_id), \"\"),\n \n             move_data::Captured =>\n-                (match self.tcx.hir().expect_expr(node_id).node {\n+                (match self.tcx.hir().expect_expr_by_hir_id(hir_id).node {\n                     hir::ExprKind::Closure(.., fn_decl_span, _) => fn_decl_span,\n                     ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n@@ -828,8 +828,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     MutabilityViolation => {\n                         let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n                         if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n-                            let node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n-                            let sp = self.tcx.hir().span(node_id);\n+                            let hir_id = upvar_id.var_path.hir_id;\n+                            let sp = self.tcx.hir().span_by_hir_id(hir_id);\n                             let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n                                                   environment for modifications\";\n                             match (self.tcx.sess.source_map().span_to_snippet(sp), &err.cmt.cat) {\n@@ -1120,8 +1120,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n-                let node_id = self.tcx.hir().local_def_id_to_node_id(id);\n-                let help_span = self.tcx.hir().span(node_id);\n+                let hir_id = self.tcx.hir().local_def_id_to_hir_id(id);\n+                let help_span = self.tcx.hir().span_by_hir_id(hir_id);\n                 self.cannot_act_on_capture_in_sharable_fn(span,\n                                                           prefix,\n                                                           (help_span, help_msg),\n@@ -1362,9 +1362,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     _ => bug!()\n                 };\n                 if *kind == ty::ClosureKind::Fn {\n-                    let closure_node_id =\n-                        self.tcx.hir().local_def_id_to_node_id(upvar_id.closure_expr_id);\n-                    db.span_help(self.tcx.hir().span(closure_node_id),\n+                    let closure_hir_id =\n+                        self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id);\n+                    db.span_help(self.tcx.hir().span_by_hir_id(closure_hir_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");\n                 }\n@@ -1397,8 +1397,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                       loan_path: &LoanPath<'tcx>,\n                                       out: &mut String) {\n         match loan_path.kind {\n-            LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id}, closure_expr_id: _ }) => {\n-                out.push_str(&self.tcx.hir().name(self.tcx.hir().hir_to_node_id(id)).as_str());\n+            LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id }, closure_expr_id: _ }) => {\n+                out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n             }\n             LpVar(id) => {\n                 out.push_str(&self.tcx.hir().name(id).as_str());"}, {"sha": "40c9ef3f63cf5abcd5ccc8e49b7dc3068dcaca1c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n-        if method_context(cx, impl_item.id) == MethodLateContext::TraitImpl {\n+        if method_context(cx, impl_item.hir_id) == MethodLateContext::TraitImpl {\n             return;\n         }\n "}, {"sha": "4c4032a36956d3c822146a19d5f1efb6f6b91b66", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -18,8 +18,8 @@ pub enum MethodLateContext {\n     PlainImpl,\n }\n \n-pub fn method_context(cx: &LateContext<'_, '_>, id: ast::NodeId) -> MethodLateContext {\n-    let def_id = cx.tcx.hir().local_def_id(id);\n+pub fn method_context(cx: &LateContext<'_, '_>, id: hir::HirId) -> MethodLateContext {\n+    let def_id = cx.tcx.hir().local_def_id_from_hir_id(id);\n     let item = cx.tcx.associated_item(def_id);\n     match item.container {\n         ty::TraitContainer(..) => MethodLateContext::TraitAutoImpl,\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         _: &hir::FnDecl,\n         _: &hir::Body,\n         _: Span,\n-        id: ast::NodeId,\n+        id: hir::HirId,\n     ) {\n         match &fk {\n             FnKind::Method(ident, ..) => {\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         s: &hir::VariantData,\n         _: ast::Name,\n         _: &hir::Generics,\n-        _: ast::NodeId,\n+        _: hir::HirId,\n     ) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.ident);"}, {"sha": "7e325ecc76c0babd0eb072ba04f7b6544241170f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -1663,7 +1663,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     fn visit_variant(&mut self,\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n-                     id: ast::NodeId) {\n+                     id: hir::HirId) {\n         intravisit::walk_variant(self, v, g, id);\n \n         if let Some(ref discr) = v.node.disr_expr {"}, {"sha": "c30781bf5627e438a38482d4f333ed31f83b2b25", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -78,7 +78,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n                               v: &'tcx hir::VariantData,\n                               _: ast::Name,\n                               _: &'tcx hir::Generics,\n-                              _: ast::NodeId,\n+                              _: hir::HirId,\n                               _: Span) {\n             if let hir::VariantData::Tuple(_, node_id, _) = *v {\n                 self.set.insert(self.tcx.hir().local_def_id(node_id));"}, {"sha": "4071b5902b030efd3e04a1b3066d416527fecb43", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -123,7 +123,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_item(self, i)\n     }\n \n-    fn visit_mod(&mut self, m: &'v hir::Mod, _s: Span, n: NodeId) {\n+    fn visit_mod(&mut self, m: &'v hir::Mod, _s: Span, n: hir::HirId) {\n         self.record(\"Mod\", Id::None, m);\n         hir_visit::walk_mod(self, m, n)\n     }\n@@ -173,7 +173,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n                 fd: &'v hir::FnDecl,\n                 b: hir::BodyId,\n                 s: Span,\n-                id: NodeId) {\n+                id: hir::HirId) {\n         self.record(\"FnDecl\", Id::None, fd);\n         hir_visit::walk_fn(self, fk, fd, b, s, id)\n     }\n@@ -206,7 +206,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_variant(&mut self,\n                      v: &'v hir::Variant,\n                      g: &'v hir::Generics,\n-                     item_id: NodeId) {\n+                     item_id: hir::HirId) {\n         self.record(\"Variant\", Id::None, v);\n         hir_visit::walk_variant(self, v, g, item_id)\n     }"}, {"sha": "894cb4cf11b20d5c379ed86c5db285e4c9588734", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -454,8 +454,8 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         if let Some([module, segment]) = segments.rchunks_exact(2).next() {\n             if let Some(item) = module.def\n                 .and_then(|def| def.mod_def_id())\n-                .and_then(|def_id| self.tcx.hir().as_local_node_id(def_id))\n-                .map(|module_node_id| self.tcx.hir().expect_item(module_node_id))\n+                .and_then(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n+                .map(|module_hir_id| self.tcx.hir().expect_item_by_hir_id(module_hir_id))\n              {\n                 if let hir::ItemKind::Mod(m) = &item.node {\n                     for item_id in m.item_ids.as_ref() {\n@@ -673,11 +673,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_mod(&mut self, m: &'tcx hir::Mod, _sp: Span, id: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod, _sp: Span, id: hir::HirId) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n-            let def_id = self.tcx.hir().local_def_id(id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n                     if export.vis == ty::Visibility::Public {\n@@ -823,7 +823,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_mod(&mut self, _m: &'tcx hir::Mod, _s: Span, _n: ast::NodeId) {\n+    fn visit_mod(&mut self, _m: &'tcx hir::Mod, _s: Span, _n: hir::HirId) {\n         // Don't visit nested modules, since we run a separate visitor walk\n         // for each module in `privacy_access_levels`\n     }\n@@ -963,7 +963,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_mod(&mut self, _m: &'tcx hir::Mod, _s: Span, _n: ast::NodeId) {\n+    fn visit_mod(&mut self, _m: &'tcx hir::Mod, _s: Span, _n: hir::HirId) {\n         // Don't visit nested modules, since we run a separate visitor walk\n         // for each module in `privacy_access_levels`\n     }\n@@ -1461,7 +1461,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn visit_variant(&mut self,\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n-                     item_id: ast::NodeId) {\n+                     item_id: hir::HirId) {\n         if self.access_levels.is_reachable(v.node.data.id()) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n@@ -1769,7 +1769,8 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n         empty_tables: &empty_tables,\n     };\n     let (module, span, node_id) = tcx.hir().get_module(module_def_id);\n-    intravisit::walk_mod(&mut visitor, module, node_id);\n+    let hir_id = tcx.hir().node_to_hir_id(node_id);\n+    intravisit::walk_mod(&mut visitor, module, hir_id);\n \n     // Check privacy of explicitly written types and traits as well as\n     // inferred types of expressions and patterns.\n@@ -1781,7 +1782,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n         span,\n         empty_tables: &empty_tables,\n     };\n-    intravisit::walk_mod(&mut visitor, module, node_id);\n+    intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n \n fn privacy_access_levels<'tcx>("}, {"sha": "ebbde4b581805633ab4581702f03b632510ba645", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               mut msg: String,\n                               candidates: Vec<DefId>) {\n         let module_did = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n-        let module_id = self.tcx.hir().as_local_node_id(module_did).unwrap();\n+        let module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n         if let Some(span) = span {\n@@ -787,7 +787,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n }\n \n struct UsePlacementFinder<'a, 'tcx: 'a, 'gcx: 'tcx> {\n-    target_module: ast::NodeId,\n+    target_module: hir::HirId,\n     span: Option<Span>,\n     found_use: bool,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>\n@@ -797,7 +797,7 @@ impl<'a, 'tcx, 'gcx> UsePlacementFinder<'a, 'tcx, 'gcx> {\n     fn check(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         krate: &'tcx hir::Crate,\n-        target_module: ast::NodeId,\n+        target_module: hir::HirId,\n     ) -> (Option<Span>, bool) {\n         let mut finder = UsePlacementFinder {\n             target_module,\n@@ -815,13 +815,13 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n         &mut self,\n         module: &'tcx hir::Mod,\n         _: Span,\n-        node_id: ast::NodeId,\n+        hir_id: hir::HirId,\n     ) {\n         if self.span.is_some() {\n             return;\n         }\n-        if node_id != self.target_module {\n-            hir::intravisit::walk_mod(self, module, node_id);\n+        if hir_id != self.target_module {\n+            hir::intravisit::walk_mod(self, module, hir_id);\n             return;\n         }\n         // Find a `use` statement."}, {"sha": "6ac0c79b1f2eae87a52f09b83861870d1772fad7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -1024,7 +1024,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                _: hir::BodyId, _: Span, _: ast::NodeId) { }\n+                _: hir::BodyId, _: Span, _: hir::HirId) { }\n }\n \n /// When `check_fn` is invoked on a generator (i.e., a body that"}, {"sha": "08bc861766b8e89fb2f29458f1336aa905541d3d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -456,7 +456,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         _: &'gcx hir::FnDecl,\n         body_id: hir::BodyId,\n         span: Span,\n-        id: ast::NodeId,\n+        hir_id: hir::HirId,\n     ) {\n         assert!(\n             match fk {\n@@ -473,7 +473,6 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n \n         let body = self.tcx.hir().body(body_id);\n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n         self.visit_fn_body(hir_id, body, span);\n \n         // Restore state from previous function."}, {"sha": "cdffbdd540f8c39e21bf343ff0499fce123ed89f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -301,8 +301,8 @@ pub fn build_impl(cx: &DocContext<'_, '_, '_>, did: DefId, ret: &mut Vec<clean::\n         }\n     }\n \n-    let for_ = if let Some(nodeid) = tcx.hir().as_local_node_id(did) {\n-        match tcx.hir().expect_item(nodeid).node {\n+    let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+        match tcx.hir().expect_item_by_hir_id(hir_id).node {\n             hir::ItemKind::Impl(.., ref t, _) => {\n                 t.clean(cx)\n             }\n@@ -323,8 +323,8 @@ pub fn build_impl(cx: &DocContext<'_, '_, '_>, did: DefId, ret: &mut Vec<clean::\n     }\n \n     let predicates = tcx.predicates_of(did);\n-    let (trait_items, generics) = if let Some(nodeid) = tcx.hir().as_local_node_id(did) {\n-        match tcx.hir().expect_item(nodeid).node {\n+    let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+        match tcx.hir().expect_item_by_hir_id(hir_id).node {\n             hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => {\n                 (\n                     item_ids.iter()"}, {"sha": "2b2a116f8ca4db3d2f0006245f08ac8ca4b34be3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -2564,9 +2564,9 @@ impl Clean<Type> for hir::Ty {\n                 let mut alias = None;\n                 if let Def::TyAlias(def_id) = path.def {\n                     // Substitute private type aliases\n-                    if let Some(node_id) = cx.tcx.hir().as_local_node_id(def_id) {\n+                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n-                            alias = Some(&cx.tcx.hir().expect_item(node_id).node);\n+                            alias = Some(&cx.tcx.hir().expect_item_by_hir_id(hir_id).node);\n                         }\n                     }\n                 };"}, {"sha": "3db65205a2dc4b0f26d0c3bc30076fe47a76276c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -899,7 +899,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     fn visit_variant(&mut self,\n                      v: &'hir hir::Variant,\n                      g: &'hir hir::Generics,\n-                     item_id: ast::NodeId) {\n+                     item_id: hir::HirId) {\n         self.visit_testable(v.node.ident.to_string(), &v.node.attrs, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });"}, {"sha": "09aa106ebbd9f4036ef81482cd31b8e3c449f3d5", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f573049729ca7f4a4977e48467156d7fc8b13f62/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -48,11 +48,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n                 _: &'tcx hir::FnDecl,\n                 _: &'tcx hir::Body,\n                 span: source_map::Span,\n-                id: ast::NodeId) {\n+                id: hir::HirId) {\n \n-        let item = match cx.tcx.hir().get(id) {\n+        let item = match cx.tcx.hir().get_by_hir_id(id) {\n             Node::Item(item) => item,\n-            _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent(id)),\n+            _ => cx.tcx.hir().expect_item_by_hir_id(cx.tcx.hir().get_parent_item(id)),\n         };\n \n         if !attr::contains_name(&item.attrs, \"whitelisted_attr\") {"}, {"sha": "1fac38088609747627b07807945224cf1ea642ca", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=f573049729ca7f4a4977e48467156d7fc8b13f62", "patch": "@@ -1 +1 @@\n-Subproject commit d61b25419bec5a3e839fdb16f720cfb12e52ddf1\n+Subproject commit 1fac38088609747627b07807945224cf1ea642ca"}]}