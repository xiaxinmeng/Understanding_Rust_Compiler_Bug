{"sha": "998bf0ab88a372c1b19dd367c1fe6f51728b87eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5OGJmMGFiODhhMzcyYzFiMTlkZDM2N2MxZmU2ZjUxNzI4Yjg3ZWI=", "commit": {"author": {"name": "Daniel Noom", "email": "ggatw@outlook.com", "date": "2021-01-03T13:13:33Z"}, "committer": {"name": "Daniel Noom", "email": "ggatw@outlook.com", "date": "2021-01-03T18:05:23Z"}, "message": "Add note to non-exhaustive match on reference to empty\n\nRust prints \"type `&A` is non-empty\" even is A is empty.\nThis is the intended behavior, but can be confusing.\nThis commit adds a note to non-exhaustive pattern errors if they are a\nreference to something uninhabited.\n\nI did not add tests to check that the note is not shown for\nnon-references or inhabited references, because this is already done\nin other tests.\n\nMaybe the added test is superfluous, because\n`always-inhabited-union-ref` already checks for this case.\n\nThis does not handle &&Void or &&&void etc. I could add those as special\ncases as well and ignore people who need quadruple\nreferences.\n\nFixes #78123", "tree": {"sha": "6114960da123901bbbb3b31606b06692f2df8bd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6114960da123901bbbb3b31606b06692f2df8bd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/998bf0ab88a372c1b19dd367c1fe6f51728b87eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/998bf0ab88a372c1b19dd367c1fe6f51728b87eb", "html_url": "https://github.com/rust-lang/rust/commit/998bf0ab88a372c1b19dd367c1fe6f51728b87eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/comments", "author": null, "committer": null, "parents": [{"sha": "18cb4ad3b9440b3ff2ed16976f56889b23811e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/18cb4ad3b9440b3ff2ed16976f56889b23811e13", "html_url": "https://github.com/rust-lang/rust/commit/18cb4ad3b9440b3ff2ed16976f56889b23811e13"}], "stats": {"total": 29, "additions": 29, "deletions": 0}, "files": [{"sha": "a70c1a28176cd82e7d154e9262cf6084e43b418b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=998bf0ab88a372c1b19dd367c1fe6f51728b87eb", "patch": "@@ -503,6 +503,11 @@ fn non_exhaustive_match<'p, 'tcx>(\n             ));\n         }\n     }\n+    if let ty::Ref(_, sub_ty, _) = scrut_ty.kind() {\n+        if cx.tcx.is_ty_uninhabited_from(cx.module, sub_ty, cx.param_env) {\n+            err.note(\"references are always considered inhabited\");\n+        }\n+    }\n     err.emit();\n }\n "}, {"sha": "2ca774a48b66b73339ca92b4260f8c627334d6ae", "filename": "src/test/ui/pattern/usefulness/always-inhabited-union-ref.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr?ref=998bf0ab88a372c1b19dd367c1fe6f51728b87eb", "patch": "@@ -6,6 +6,7 @@ LL |     match uninhab_ref() {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&!`\n+   = note: references are always considered inhabited\n \n error[E0004]: non-exhaustive patterns: type `Foo` is non-empty\n   --> $DIR/always-inhabited-union-ref.rs:27:11"}, {"sha": "517678560c507844c55b04f70aea11dddbd833f8", "filename": "src/test/ui/pattern/usefulness/issue-78123-non-exhaustive-reference.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs?ref=998bf0ab88a372c1b19dd367c1fe6f51728b87eb", "patch": "@@ -0,0 +1,7 @@\n+enum A {}\n+\n+fn f(a: &A) {\n+    match a {} //~ ERROR non-exhaustive patterns: type `&A` is non-empty\n+}\n+\n+fn main() {}"}, {"sha": "7cd04629aaf487e341228593b789f99e96003a09", "filename": "src/test/ui/pattern/usefulness/issue-78123-non-exhaustive-reference.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/998bf0ab88a372c1b19dd367c1fe6f51728b87eb/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr?ref=998bf0ab88a372c1b19dd367c1fe6f51728b87eb", "patch": "@@ -0,0 +1,16 @@\n+error[E0004]: non-exhaustive patterns: type `&A` is non-empty\n+  --> $DIR/issue-78123-non-exhaustive-reference.rs:4:11\n+   |\n+LL | enum A {}\n+   | --------- `A` defined here\n+...\n+LL |     match a {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&A`\n+   = note: references are always considered inhabited\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}]}