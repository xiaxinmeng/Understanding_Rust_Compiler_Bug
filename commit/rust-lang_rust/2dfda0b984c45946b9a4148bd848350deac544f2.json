{"sha": "2dfda0b984c45946b9a4148bd848350deac544f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZmRhMGI5ODRjNDU5NDZiOWE0MTQ4YmQ4NDgzNTBkZWFjNTQ0ZjI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-29T17:18:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-29T17:18:53Z"}, "message": "Merge #5572\n\n5572: Switch to ungrammar from ast_src r=matklad a=matklad\n\nThe primary advantage of ungrammar is that it (eventually) allows one\nto describe concrete syntax tree structure -- with alternatives and\nspecific sequence of tokens & nodes.\n\nThat should be re-usable for:\n\n* generate `make` calls\n* Rust reference\n* Hypothetical parser's evented API\n\nWe loose doc comments for the time being unfortunately. I don't think\nwe should add support for doc comments to ungrammar -- they'll make\ngrammar file hard to read. We might supply docs as out-of band info,\nor maybe just via a reference, but we'll think about that once things\nare no longer in flux\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "1942eeab995b0bd191c6a998b47cb20a426e5dd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1942eeab995b0bd191c6a998b47cb20a426e5dd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dfda0b984c45946b9a4148bd848350deac544f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfIa99CRBK7hj4Ov3rIwAAdHIIAB6LseCSvUflAovZ/Sj6f5fX\nIrxKOZL4SJSBcinbRImwaSNbGcibg61lHodn9mRozb9FtDzE7IyHl06Uyl1s+foe\nZatlyRUJMmyZrDiLI2USrkqiEGJH/7WaIKOc7WYTG+VX34sdXV0/CJBScVZn6Moq\n49USAdFm0hoSCaK3DA6q/D2rbVI4U6noT3W/CxZqaKZnyVIANLBxsiitBMo7bwM+\nwtfpZwmM6DMPxX17rRjnHV1kzi/q8KTks4iIFoDB7ApvQVtXVhdc+OfZgY/CtLBU\nSBccaSgKS+1Et0JgxVOFIjyJow5Fi2jJ0ApjDVFBNFsIrkpfjKPP0QAd5X06yuE=\n=dWUx\n-----END PGP SIGNATURE-----\n", "payload": "tree 1942eeab995b0bd191c6a998b47cb20a426e5dd3\nparent 525ae706b3e4c0f5f8b80d197e5fede0a9974442\nparent 3d28292157e1b6c9675ef64eddf53786c3e7dc5f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1596043133 +0000\ncommitter GitHub <noreply@github.com> 1596043133 +0000\n\nMerge #5572\n\n5572: Switch to ungrammar from ast_src r=matklad a=matklad\n\nThe primary advantage of ungrammar is that it (eventually) allows one\nto describe concrete syntax tree structure -- with alternatives and\nspecific sequence of tokens & nodes.\n\nThat should be re-usable for:\n\n* generate `make` calls\n* Rust reference\n* Hypothetical parser's evented API\n\nWe loose doc comments for the time being unfortunately. I don't think\nwe should add support for doc comments to ungrammar -- they'll make\ngrammar file hard to read. We might supply docs as out-of band info,\nor maybe just via a reference, but we'll think about that once things\nare no longer in flux\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dfda0b984c45946b9a4148bd848350deac544f2", "html_url": "https://github.com/rust-lang/rust/commit/2dfda0b984c45946b9a4148bd848350deac544f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dfda0b984c45946b9a4148bd848350deac544f2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "525ae706b3e4c0f5f8b80d197e5fede0a9974442", "url": "https://api.github.com/repos/rust-lang/rust/commits/525ae706b3e4c0f5f8b80d197e5fede0a9974442", "html_url": "https://github.com/rust-lang/rust/commit/525ae706b3e4c0f5f8b80d197e5fede0a9974442"}, {"sha": "3d28292157e1b6c9675ef64eddf53786c3e7dc5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d28292157e1b6c9675ef64eddf53786c3e7dc5f", "html_url": "https://github.com/rust-lang/rust/commit/3d28292157e1b6c9675ef64eddf53786c3e7dc5f"}], "stats": {"total": 5793, "additions": 1596, "deletions": 4197}, "files": [{"sha": "b7a9516e3d646e00ea35f59e33c414640218ef0f", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2dfda0b984c45946b9a4148bd848350deac544f2", "patch": "@@ -1749,6 +1749,12 @@ dependencies = [\n  \"tracing-subscriber\",\n ]\n \n+[[package]]\n+name = \"ungrammar\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0ee12e4891ab3acc2d95d5023022ace22020247bb8a8d1ece875a443f7dab37d\"\n+\n [[package]]\n name = \"unicode-bidi\"\n version = \"0.3.4\"\n@@ -1893,5 +1899,6 @@ dependencies = [\n  \"pico-args\",\n  \"proc-macro2\",\n  \"quote\",\n+ \"ungrammar\",\n  \"walkdir\",\n ]"}, {"sha": "970fc9af54e21fe4cc04756a8fcfc7cb5903f177", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=2dfda0b984c45946b9a4148bd848350deac544f2", "patch": "@@ -1,7 +1,7 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n \n-use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n+use ra_syntax::ast::{self, TypeAscriptionOwner};\n \n use crate::{body::LowerCtx, path::Path};\n "}, {"sha": "69c85c809de505014a335257070796548f4f0305", "filename": "crates/ra_syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=2dfda0b984c45946b9a4148bd848350deac544f2", "patch": "@@ -7,6 +7,8 @@ use crate::{\n     SyntaxToken, T,\n };\n \n+impl ast::AttrsOwner for ast::Expr {}\n+\n impl ast::Expr {\n     pub fn is_block_like(&self) -> bool {\n         match self {"}, {"sha": "b2d108a7cab5e91dab594ff55540e63589a6c1c6", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 811, "deletions": 2209, "changes": 3020, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=2dfda0b984c45946b9a4148bd848350deac544f2"}, {"sha": "242900643afdc5a222cb3ab79c46b0f7ab1600a5", "filename": "crates/ra_syntax/src/ast/node_ext.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=2dfda0b984c45946b9a4148bd848350deac544f2", "patch": "@@ -472,3 +472,19 @@ impl ast::TokenTree {\n             .filter(|it| matches!(it.kind(), T!['}'] | T![')'] | T![']']))\n     }\n }\n+\n+impl ast::DocCommentsOwner for ast::SourceFile {}\n+impl ast::DocCommentsOwner for ast::FnDef {}\n+impl ast::DocCommentsOwner for ast::StructDef {}\n+impl ast::DocCommentsOwner for ast::UnionDef {}\n+impl ast::DocCommentsOwner for ast::RecordFieldDef {}\n+impl ast::DocCommentsOwner for ast::TupleFieldDef {}\n+impl ast::DocCommentsOwner for ast::EnumDef {}\n+impl ast::DocCommentsOwner for ast::EnumVariant {}\n+impl ast::DocCommentsOwner for ast::TraitDef {}\n+impl ast::DocCommentsOwner for ast::Module {}\n+impl ast::DocCommentsOwner for ast::StaticDef {}\n+impl ast::DocCommentsOwner for ast::ConstDef {}\n+impl ast::DocCommentsOwner for ast::TypeAliasDef {}\n+impl ast::DocCommentsOwner for ast::ImplDef {}\n+impl ast::DocCommentsOwner for ast::MacroCall {}"}, {"sha": "8140da87f9e80586b8925f94fbc7cb1a7005fd42", "filename": "xtask/Cargo.toml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/xtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/xtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2FCargo.toml?ref=2dfda0b984c45946b9a4148bd848350deac544f2", "patch": "@@ -10,9 +10,10 @@ license = \"MIT OR Apache-2.0\"\n doctest = false\n \n [dependencies]\n-walkdir = \"2.3.1\"\n-pico-args = \"0.3.1\"\n-quote = \"1.0.2\"\n-proc-macro2 = \"1.0.8\"\n anyhow = \"1.0.26\"\n flate2 = \"1.0\"\n+pico-args = \"0.3.1\"\n+proc-macro2 = \"1.0.8\"\n+quote = \"1.0.2\"\n+ungrammar = \"0.1.0\"\n+walkdir = \"2.3.1\""}, {"sha": "83449437bb25808fdbd600f4ae22f5bc6e8f21de", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 5, "deletions": 1979, "changes": 1984, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=2dfda0b984c45946b9a4148bd848350deac544f2", "patch": "@@ -223,2012 +223,38 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n     ],\n };\n \n+#[derive(Default, Debug)]\n pub(crate) struct AstSrc {\n     pub(crate) tokens: Vec<String>,\n     pub(crate) nodes: Vec<AstNodeSrc>,\n     pub(crate) enums: Vec<AstEnumSrc>,\n }\n \n+#[derive(Debug)]\n pub(crate) struct AstNodeSrc {\n     pub(crate) doc: Vec<String>,\n     pub(crate) name: String,\n     pub(crate) traits: Vec<String>,\n     pub(crate) fields: Vec<Field>,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub(crate) enum Field {\n     Token(String),\n     Node { name: String, src: FieldSrc },\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub(crate) enum FieldSrc {\n     Shorthand,\n     Optional(String),\n     Many(String),\n }\n \n+#[derive(Debug)]\n pub(crate) struct AstEnumSrc {\n     pub(crate) doc: Vec<String>,\n     pub(crate) name: String,\n     pub(crate) traits: Vec<String>,\n     pub(crate) variants: Vec<String>,\n }\n-\n-macro_rules! ast_nodes {\n-    ($(\n-        $(#[doc = $doc:expr])+\n-        struct $name:ident$(: $($trait:ident),*)? {\n-            $($field_name:ident $(![$token:tt])? $(: $ty:tt)?),*$(,)?\n-        }\n-    )*) => {\n-        vec![$(\n-            AstNodeSrc {\n-                doc: vec![$($doc.to_string()),*],\n-                name: stringify!($name).to_string(),\n-                traits: vec![$($(stringify!($trait).to_string()),*)?],\n-                fields: vec![\n-                    $(field!($(T![$token])? $field_name $($ty)?)),*\n-                ],\n-\n-            }\n-        ),*]\n-    };\n-}\n-\n-macro_rules! field {\n-    (T![$token:tt] T) => {\n-        Field::Token(stringify!($token).to_string())\n-    };\n-    ($field_name:ident) => {\n-        Field::Node { name: stringify!($field_name).to_string(), src: FieldSrc::Shorthand }\n-    };\n-    ($field_name:ident [$ty:ident]) => {\n-        Field::Node {\n-            name: stringify!($field_name).to_string(),\n-            src: FieldSrc::Many(stringify!($ty).to_string()),\n-        }\n-    };\n-    ($field_name:ident $ty:ident) => {\n-        Field::Node {\n-            name: stringify!($field_name).to_string(),\n-            src: FieldSrc::Optional(stringify!($ty).to_string()),\n-        }\n-    };\n-}\n-\n-macro_rules! ast_enums {\n-    ($(\n-        $(#[doc = $doc:expr])+\n-        enum $name:ident $(: $($trait:ident),*)? {\n-            $($variant:ident),*$(,)?\n-        }\n-    )*) => {\n-        vec![$(\n-            AstEnumSrc {\n-                doc: vec![$($doc.to_string()),*],\n-                name: stringify!($name).to_string(),\n-                traits: vec![$($(stringify!($trait).to_string()),*)?],\n-                variants: vec![$(stringify!($variant).to_string()),*],\n-            }\n-        ),*]\n-    };\n-}\n-\n-pub(crate) fn rust_ast() -> AstSrc {\n-    AstSrc {\n-        tokens: vec![\"Whitespace\".into(), \"Comment\".into(), \"String\".into(), \"RawString\".into()],\n-        nodes: ast_nodes! {\n-            /// The entire Rust source file. Includes all top-level inner attributes and module items.\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/crates-and-source-files.html)\n-            struct SourceFile: ModuleItemOwner, AttrsOwner, DocCommentsOwner {\n-            }\n-\n-            /// Function definition either with body or not.\n-            /// Includes all of its attributes and doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub extern \"C\" fn foo<T>(#[attr] Patern {p}: Pattern) -> u32\n-            ///     where\n-            ///         T: Debug\n-            ///     {\n-            ///         42\n-            ///     }\n-            /// \u2771\n-            ///\n-            /// extern \"C\" {\n-            ///     \u2770 fn fn_decl(also_variadic_ffi: u32, ...) -> u32; \u2771\n-            /// }\n-            /// ```\n-            ///\n-            /// - [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n-            /// - [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html#variadic-functions)\n-            struct FnDef: VisibilityOwner, NameOwner, TypeParamsOwner, DocCommentsOwner, AttrsOwner {\n-                Abi,\n-                T![const],\n-                T![default],\n-                T![async],\n-                T![unsafe],\n-                T![fn],\n-                ParamList,\n-                RetType,\n-                body: BlockExpr,\n-                T![;]\n-            }\n-\n-            /// Return type annotation.\n-            ///\n-            /// ```\n-            /// fn foo(a: u32) \u2770 -> Option<u32> \u2771 { Some(a) }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n-            struct RetType { T![->], TypeRef }\n-\n-            /// Struct definition.\n-            /// Includes all of its attributes and doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     struct Foo<T> where T: Debug {\n-            ///         /// Docs\n-            ///         #[attr]\n-            ///         pub a: u32,\n-            ///         b: T,\n-            ///     }\n-            /// \u2771\n-            ///\n-            /// \u2770 struct Foo; \u2771\n-            /// \u2770 struct Foo<T>(#[attr] T) where T: Debug; \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n-            struct StructDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n-                T![struct],\n-                FieldDefList,\n-                T![;]\n-            }\n-\n-            /// Union definition.\n-            /// Includes all of its attributes and doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub union Foo<T> where T: Debug {\n-            ///         /// Docs\n-            ///         #[attr]\n-            ///         a: T,\n-            ///         b: u32,\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/unions.html)\n-            struct UnionDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n-                T![union],\n-                RecordFieldDefList,\n-            }\n-\n-            /// Record field definition list including enclosing curly braces.\n-            ///\n-            /// ```\n-            /// struct Foo // same for union\n-            /// \u2770\n-            ///     {\n-            ///         a: u32,\n-            ///         b: bool,\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n-            struct RecordFieldDefList { T!['{'], fields: [RecordFieldDef], T!['}'] }\n-\n-            /// Record field definition including its attributes and doc comments.\n-            ///\n-            /// ` ``\n-            /// same for union\n-            /// struct Foo {\n-            ///      \u2770\n-            ///          /// Docs\n-            ///          #[attr]\n-            ///          pub a: u32\n-            ///      \u2771\n-            ///\n-            ///      \u2770 b: bool \u2771\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n-            struct RecordFieldDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner { }\n-\n-            /// Tuple field definition list including enclosing parens.\n-            ///\n-            /// ```\n-            /// struct Foo \u2770 (u32, String, Vec<u32>) \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n-            struct TupleFieldDefList { T!['('], fields: [TupleFieldDef], T![')'] }\n-\n-            /// Tuple field definition including its attributes.\n-            ///\n-            /// ```\n-            /// struct Foo(\u2770 #[attr] u32 \u2771);\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n-            struct TupleFieldDef: VisibilityOwner, AttrsOwner {\n-                TypeRef,\n-            }\n-\n-            /// Enum definition.\n-            /// Includes all of its attributes and doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub enum Foo<T> where T: Debug {\n-            ///         /// Docs\n-            ///         #[attr]\n-            ///         Bar,\n-            ///         Baz(#[attr] u32),\n-            ///         Bruh {\n-            ///             a: u32,\n-            ///             /// Docs\n-            ///             #[attr]\n-            ///             b: T,\n-            ///         }\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n-            struct EnumDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n-                T![enum],\n-                variant_list: EnumVariantList,\n-            }\n-\n-            /// Enum variant definition list including enclosing curly braces.\n-            ///\n-            /// ```\n-            /// enum Foo\n-            /// \u2770\n-            ///     {\n-            ///         Bar,\n-            ///         Baz(u32),\n-            ///         Bruh {\n-            ///             a: u32\n-            ///         }\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n-            struct EnumVariantList {\n-                T!['{'],\n-                variants: [EnumVariant],\n-                T!['}']\n-            }\n-\n-            /// Enum variant definition including its attributes and discriminant value definition.\n-            ///\n-            /// ```\n-            /// enum Foo {\n-            ///     \u2770\n-            ///         /// Docs\n-            ///         #[attr]\n-            ///         Bar\n-            ///     \u2771\n-            ///\n-            ///     // same for tuple and record variants\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n-            struct EnumVariant: VisibilityOwner, NameOwner, DocCommentsOwner, AttrsOwner {\n-                FieldDefList,\n-                T![=],\n-                Expr\n-            }\n-\n-            /// Trait definition.\n-            /// Includes all of its attributes and doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub unsafe trait Foo<T>: Debug where T: Debug {\n-            ///         // ...\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/traits.html)\n-            struct TraitDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeParamsOwner, TypeBoundsOwner {\n-                T![unsafe],\n-                T![auto],\n-                T![trait],\n-                ItemList,\n-            }\n-\n-            /// Module definition either with body or not.\n-            /// Includes all of its inner and outer attributes, module items, doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub mod foo;\n-            /// \u2771\n-            ///\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub mod bar {\n-            ///        //! Inner docs\n-            ///        #![inner_attr]\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/modules.html)\n-            struct Module: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner {\n-                T![mod],\n-                ItemList,\n-                T![;]\n-            }\n-\n-            /// Item defintion list.\n-            /// This is used for both top-level items and impl block items.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     fn foo {}\n-            ///     struct Bar;\n-            ///     enum Baz;\n-            ///     trait Bruh;\n-            ///     const BRUUH: u32 = 42;\n-            /// \u2771\n-            ///\n-            /// impl Foo\n-            /// \u2770\n-            ///     {\n-            ///         fn bar() {}\n-            ///         const BAZ: u32 = 42;\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items.html)\n-            struct ItemList: ModuleItemOwner {\n-                T!['{'],\n-                assoc_items: [AssocItem],\n-                T!['}']\n-            }\n-\n-            /// Constant variable definition.\n-            /// Includes all of its attributes and doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub const FOO: u32 = 42;\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/constant-items.html)\n-            struct ConstDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n-                T![default],\n-                T![const],\n-                T![=],\n-                body: Expr,\n-                T![;]\n-            }\n-\n-\n-            /// Static variable definition.\n-            /// Includes all of its attributes and doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub static mut FOO: u32 = 42;\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/static-items.html)\n-            struct StaticDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n-                T![static],\n-                T![mut],\n-                T![=],\n-                body: Expr,\n-                T![;]\n-            }\n-\n-            /// Type alias definition.\n-            /// Includes associated type clauses with type bounds.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     pub type Foo<T> where T: Debug = T;\n-            /// \u2771\n-            ///\n-            /// trait Bar {\n-            ///     \u2770 type Baz: Debug; \u2771\n-            ///     \u2770 type Bruh = String; \u2771\n-            ///     \u2770 type Bruuh: Debug = u32; \u2771\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/type-aliases.html)\n-            struct TypeAliasDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeBoundsOwner {\n-                T![default],\n-                T![type],\n-                T![=],\n-                TypeRef,\n-                T![;]\n-            }\n-\n-            /// Inherent and trait impl definition.\n-            /// Includes all of its inner and outer attributes.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     #[attr]\n-            ///     unsafe impl<T> const !Foo for Bar where T: Debug {\n-            ///         #![inner_attr]\n-            ///         // ...\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/implementations.html)\n-            struct ImplDef: TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n-                T![default],\n-                T![const],\n-                T![unsafe],\n-                T![impl],\n-                T![!],\n-                T![for],\n-                ItemList,\n-            }\n-\n-\n-            /// Parenthesized type reference.\n-            /// Note: parens are only used for grouping, this is not a tuple type.\n-            ///\n-            /// ```\n-            /// // This is effectively just `u32`.\n-            /// // Single-item tuple must be defined with a trailing comma: `(u32,)`\n-            /// type Foo = \u2770 (u32) \u2771;\n-            ///\n-            /// let bar: &'static \u2770 (dyn Debug) \u2771 = \"bruh\";\n-            /// ```\n-            struct ParenType { T!['('], TypeRef, T![')'] }\n-\n-            /// Unnamed tuple type.\n-            ///\n-            /// ```\n-            /// let foo: \u2770 (u32, bool) \u2771 = (42, true);\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/tuple.html)\n-            struct TupleType { T!['('], fields: [TypeRef], T![')'] }\n-\n-            /// The never type (i.e. the exclamation point).\n-            ///\n-            /// ```\n-            /// type T = \u2770 ! \u2771;\n-            ///\n-            /// fn no_return() -> \u2770 ! \u2771 {\n-            ///     loop {}\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/never.html)\n-            struct NeverType { T![!] }\n-\n-            /// Path to a type.\n-            /// Includes single identifier type names and elaborate paths with\n-            /// generic parameters.\n-            ///\n-            /// ```\n-            /// type Foo = \u2770 String \u2771;\n-            /// type Bar = \u2770 std::vec::Vec<T> \u2771;\n-            /// type Baz = \u2770 ::bruh::<Bruuh as Iterator>::Item \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n-            struct PathType { Path }\n-\n-            /// Raw pointer type.\n-            ///\n-            /// ```\n-            /// type Foo = \u2770 *const u32 \u2771;\n-            /// type Bar = \u2770 *mut u32 \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/pointer.html#raw-pointers-const-and-mut)\n-            struct PointerType { T![*], T![const], T![mut], TypeRef }\n-\n-            /// Array type.\n-            ///\n-            /// ```\n-            /// type Foo = \u2770 [u32; 24 - 3] \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/array.html)\n-            struct ArrayType { T!['['], TypeRef, T![;], Expr, T![']'] }\n-\n-            /// Slice type.\n-            ///\n-            /// ```\n-            /// type Foo = \u2770 [u8] \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/slice.html)\n-            struct SliceType { T!['['], TypeRef, T![']'] }\n-\n-            /// Reference type.\n-            ///\n-            /// ```\n-            /// type Foo = \u2770 &'static str \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/pointer.html)\n-            struct ReferenceType { T![&], T![lifetime], T![mut], TypeRef }\n-\n-            /// Placeholder type (i.e. the underscore).\n-            ///\n-            /// ```\n-            /// let foo: \u2770 _ \u2771 = 42_u32;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/inferred.html)\n-            struct PlaceholderType { T![_] }\n-\n-            /// Function pointer type (not to be confused with `Fn*` family of traits).\n-            ///\n-            /// ```\n-            /// type Foo = \u2770 async fn(#[attr] u32, named: bool) -> u32 \u2771;\n-            ///\n-            /// type Bar = \u2770 extern \"C\" fn(variadic: u32, #[attr] ...) \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/function-pointer.html)\n-            struct FnPointerType { Abi, T![unsafe], T![fn], ParamList, RetType }\n-\n-            /// Higher order type.\n-            ///\n-            /// ```\n-            /// type Foo = \u2770 for<'a> fn(&'a str) \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/nomicon/hrtb.html)\n-            struct ForType { T![for], TypeParamList, TypeRef }\n-\n-            /// Opaque `impl Trait` type.\n-            ///\n-            /// ```\n-            /// fn foo(bar: \u2770 impl Debug + Eq \u2771) {}\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/impl-trait.html)\n-            struct ImplTraitType: TypeBoundsOwner { T![impl] }\n-\n-            /// Trait object type.\n-            ///\n-            /// ```\n-            /// type Foo = \u2770 dyn Debug \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/types/trait-object.html)\n-            struct DynTraitType: TypeBoundsOwner { T![dyn] }\n-\n-            /// Tuple literal.\n-            ///\n-            /// ```\n-            /// \u2770 (42, true) \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/tuple-expr.html)\n-            struct TupleExpr: AttrsOwner { T!['('], exprs: [Expr], T![')'] }\n-\n-            /// Array literal.\n-            ///\n-            /// ```\n-            /// \u2770 [#![inner_attr] true, false, true] \u2771;\n-            ///\n-            /// \u2770 [\"baz\"; 24] \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n-            struct ArrayExpr: AttrsOwner { T!['['], exprs: [Expr], T![;], T![']'] }\n-\n-            /// Parenthesized expression.\n-            /// Note: parens are only used for grouping, this is not a tuple literal.\n-            ///\n-            /// ```\n-            /// \u2770 (#![inner_attr] 2 + 2) \u2771 * 2;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/grouped-expr.html)\n-            struct ParenExpr: AttrsOwner { T!['('], Expr, T![')'] }\n-\n-            /// Path to a symbol in expression context.\n-            /// Includes single identifier variable names and elaborate paths with\n-            /// generic parameters.\n-            ///\n-            /// ```\n-            /// \u2770 Some::<i32> \u2771;\n-            /// \u2770 foo \u2771 + 42;\n-            /// \u2770 Vec::<i32>::push \u2771;\n-            /// \u2770 <[i32]>::reverse \u2771;\n-            /// \u2770 <String as std::borrow::Borrow<str>>::borrow \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/path-expr.html)\n-            struct PathExpr { Path }\n-\n-            /// Anonymous callable object literal a.k.a. closure, lambda or functor.\n-            ///\n-            /// ```\n-            /// \u2770 || 42 \u2771;\n-            /// \u2770 |a: u32| val + 1 \u2771;\n-            /// \u2770 async |#[attr] Pattern(_): Pattern| { bar } \u2771;\n-            /// \u2770 move || baz \u2771;\n-            /// \u2770 || -> u32 { closure_with_ret_type_annotation_requires_block_expr } \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/closure-expr.html)\n-            struct LambdaExpr: AttrsOwner {\n-                T![static], // Note(@matklad): I belive this is (used to be?) syntax for generators\n-                T![async],\n-                T![move],\n-                ParamList,\n-                RetType,\n-                body: Expr,\n-            }\n-\n-            /// If expression. Includes both regular `if` and `if let` forms.\n-            /// Beware that `else if` is a special case syntax sugar, because in general\n-            /// there has to be block expression after `else`.\n-            ///\n-            /// ```\n-            /// \u2770 if bool_cond { 42 } \u2771\n-            /// \u2770 if bool_cond { 42 } else { 24 } \u2771\n-            /// \u2770 if bool_cond { 42 } else if bool_cond2 { 42 } \u2771\n-            ///\n-            /// \u2770\n-            ///     if let Pattern(foo) = bar {\n-            ///         foo\n-            ///     } else {\n-            ///         panic!();\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n-            struct IfExpr: AttrsOwner { T![if], Condition }\n-\n-            /// Unconditional loop expression.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     loop {\n-            ///         // yeah, it's that simple...\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html)\n-            struct LoopExpr: AttrsOwner, LoopBodyOwner { T![loop] }\n-\n-            /// Block expression with an optional prefix (label, try ketword,\n-            /// unsafe keyword, async keyword...).\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     'label: try {\n-            ///         None?\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// - [try block](https://doc.rust-lang.org/unstable-book/language-features/try-blocks.html)\n-            /// - [unsafe block](https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks)\n-            /// - [async block](https://doc.rust-lang.org/reference/expressions/block-expr.html#async-blocks)\n-            struct EffectExpr: AttrsOwner { Label, T![try], T![unsafe], T![async], BlockExpr }\n-\n-\n-            /// For loop expression.\n-            /// Note: record struct literals are not valid as iterable expression\n-            /// due to ambiguity.\n-            ///\n-            /// ```\n-            /// \u2770\n-            /// for i in (0..4) {\n-            ///     dbg!(i);\n-            /// }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops)\n-            struct ForExpr: AttrsOwner, LoopBodyOwner {\n-                T![for],\n-                Pat,\n-                T![in],\n-                iterable: Expr,\n-            }\n-\n-            /// While loop expression. Includes both regular `while` and `while let` forms.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     while bool_cond {\n-            ///         42;\n-            ///     }\n-            /// \u2771\n-            /// \u2770\n-            ///     while let Pattern(foo) = bar {\n-            ///         bar += 1;\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n-            struct WhileExpr: AttrsOwner, LoopBodyOwner { T![while], Condition }\n-\n-            /// Continue expression.\n-            ///\n-            /// ```\n-            /// while bool_cond {\n-            ///     \u2770 continue \u2771;\n-            /// }\n-            ///\n-            /// 'outer: loop {\n-            ///     loop {\n-            ///         \u2770 continue 'outer \u2771;\n-            ///     }\n-            /// }\n-            ///\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)\n-            struct ContinueExpr: AttrsOwner { T![continue], T![lifetime] }\n-\n-            /// Break expression.\n-            ///\n-            /// ```\n-            /// while bool_cond {\n-            ///     \u2770 break \u2771;\n-            /// }\n-            /// 'outer: loop {\n-            ///     for foo in bar {\n-            ///         \u2770 break 'outer \u2771;\n-            ///     }\n-            /// }\n-            /// 'outer: loop {\n-            ///     loop {\n-            ///         \u2770 break 'outer 42 \u2771;\n-            ///     }\n-            /// }\n-            /// ```\n-            ///\n-            /// [Refernce](https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions)\n-            struct BreakExpr: AttrsOwner { T![break], T![lifetime], Expr }\n-\n-            /// Label.\n-            ///\n-            /// ```\n-            /// \u2770 'outer: \u2771 loop {}\n-            ///\n-            /// let foo = \u2770 'bar: \u2771 loop {}\n-            ///\n-            /// \u2770 'baz: \u2771 {\n-            ///     break 'baz;\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html?highlight=label#loop-labels)\n-            /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n-            struct Label { T![lifetime] }\n-\n-            /// Block expression. Includes unsafe blocks and block labels.\n-            ///\n-            /// ```\n-            ///     let foo = \u2770\n-            ///         {\n-            ///             #![inner_attr]\n-            ///             \u2770 { } \u2771\n-            ///\n-            ///             \u2770 'label: { break 'label } \u2771\n-            ///         }\n-            ///     \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/block-expr.html)\n-            /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n-            struct BlockExpr: AttrsOwner, ModuleItemOwner {\n-                Label, T!['{'], statements: [Stmt], Expr, T!['}'],\n-            }\n-\n-            /// Return expression.\n-            ///\n-            /// ```\n-            /// || \u2770 return 42 \u2771;\n-            ///\n-            /// fn bar() {\n-            ///     \u2770 return \u2771;\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/return-expr.html)\n-            struct ReturnExpr: AttrsOwner { Expr }\n-\n-            /// Call expression (not to be confused with method call expression, it is\n-            /// a separate ast node).\n-            ///\n-            /// ```\n-            /// \u2770 foo() \u2771;\n-            /// \u2770 &str::len(\"bar\") \u2771;\n-            /// \u2770 <&str as PartialEq<&str>>::eq(&\"\", &\"\") \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n-            struct CallExpr: ArgListOwner { Expr }\n-\n-            /// Method call expression.\n-            ///\n-            /// ```\n-            /// \u2770 receiver_expr.method() \u2771;\n-            /// \u2770 receiver_expr.method::<T>(42, true) \u2771;\n-            ///\n-            /// \u2770 \u2770 \u2770 foo.bar() \u2771 .baz() \u2771 .bruh() \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)\n-            struct MethodCallExpr: AttrsOwner, ArgListOwner {\n-                Expr, T![.], NameRef, TypeArgList,\n-            }\n-\n-            /// Index expression a.k.a. subscript operator call.\n-            ///\n-            /// ```\n-            /// \u2770 foo[42] \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n-            struct IndexExpr: AttrsOwner { T!['['], T![']'] }\n-\n-            /// Field access expression.\n-            ///\n-            /// ```\n-            /// \u2770 expr.bar \u2771;\n-            ///\n-            /// \u2770 \u2770 \u2770 foo.bar \u2771 .baz \u2771 .bruh \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/field-expr.html)\n-            struct FieldExpr: AttrsOwner { Expr, T![.], NameRef }\n-\n-            /// Await operator call expression.\n-            ///\n-            /// ```\n-            /// \u2770 expr.await \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/await-expr.html)\n-            struct AwaitExpr: AttrsOwner { Expr, T![.], T![await] }\n-\n-            /// The question mark operator call.\n-            ///\n-            /// ```\n-            /// \u2770 expr? \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator)\n-            struct TryExpr: AttrsOwner { Expr, T![?] }\n-\n-            /// Type cast expression.\n-            ///\n-            /// ```\n-            /// \u2770 expr as T \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions)\n-            struct CastExpr: AttrsOwner { Expr, T![as], TypeRef }\n-\n-\n-            /// Borrow operator call.\n-            ///\n-            /// ```\n-            /// \u2770 &foo \u2771;\n-            /// \u2770 &mut bar \u2771;\n-            /// \u2770 &raw const bar \u2771;\n-            /// \u2770 &raw mut bar \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators)\n-            struct RefExpr: AttrsOwner { T![&], T![raw], T![mut], T![const], Expr }\n-\n-            /// Prefix operator call. This is either `!` or `*` or `-`.\n-            ///\n-            /// ```\n-            /// \u2770 !foo \u2771;\n-            /// \u2770 *bar \u2771;\n-            /// \u2770 -42 \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html)\n-            struct PrefixExpr: AttrsOwner { /*PrefixOp,*/ Expr }\n-\n-            /// Box operator call.\n-            ///\n-            /// ```\n-            /// \u2770 box 42 \u2771;\n-            /// ```\n-            ///\n-            /// [RFC](https://github.com/rust-lang/rfcs/blob/0806be4f282144cfcd55b1d20284b43f87cbe1c6/text/0809-box-and-in-for-stdlib.md)\n-            struct BoxExpr: AttrsOwner { T![box], Expr }\n-\n-            /// Range operator call.\n-            ///\n-            /// ```\n-            /// \u2770 0..42 \u2771;\n-            /// \u2770 ..42 \u2771;\n-            /// \u2770 0.. \u2771;\n-            /// \u2770 .. \u2771;\n-            /// \u2770 0..=42 \u2771;\n-            /// \u2770 ..=42 \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/range-expr.html)\n-            struct RangeExpr: AttrsOwner { /*RangeOp*/ }\n-\n-\n-            /// Binary operator call.\n-            /// Includes all arithmetic, logic, bitwise and assignment operators.\n-            ///\n-            /// ```\n-            /// \u2770 2 + \u2770 2 * 2 \u2771 \u2771;\n-            /// \u2770 \u2770 true && false \u2771 || true \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators)\n-            struct BinExpr: AttrsOwner { /*BinOp*/ }\n-\n-\n-            /// [Raw] string, [raw] byte string, char, byte, integer, float or bool literal.\n-            ///\n-            /// ```\n-            /// \u2770 \"str\" \u2771;\n-            /// \u2770 br##\"raw byte str\"## \u2771;\n-            /// \u2770 'c' \u2771;\n-            /// \u2770 b'c' \u2771;\n-            /// \u2770 42 \u2771;\n-            /// \u2770 1e9 \u2771;\n-            /// \u2770 true \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/literal-expr.html)\n-            struct Literal { /*LiteralToken*/ }\n-\n-            /// Match expression.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     match expr {\n-            ///         Pat1 => {}\n-            ///         Pat2(_) => 42,\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n-            struct MatchExpr: AttrsOwner { T![match], Expr, MatchArmList }\n-\n-            /// Match arm list part of match expression. Includes its inner attributes.\n-            ///\n-            /// ```\n-            /// match expr\n-            /// \u2770\n-            ///     {\n-            ///         #![inner_attr]\n-            ///         Pat1 => {}\n-            ///         Pat2(_) => 42,\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n-            struct MatchArmList: AttrsOwner { T!['{'], arms: [MatchArm], T!['}'] }\n-\n-\n-            /// Match arm.\n-            /// Note: record struct literals are not valid as target match expression\n-            /// due to ambiguity.\n-            /// ```\n-            /// match expr {\n-            ///     \u2770 #[attr] Pattern(it) if bool_cond => it \u2771,\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n-            struct MatchArm: AttrsOwner {\n-                pat: Pat,\n-                guard: MatchGuard,\n-                T![=>],\n-                Expr,\n-            }\n-\n-            /// Match guard.\n-            ///\n-            /// ```\n-            /// match expr {\n-            ///     Pattern(it) \u2770 if bool_cond \u2771 => it,\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards)\n-            struct MatchGuard { T![if], Expr }\n-\n-            /// Record literal expression. The same syntax is used for structs,\n-            /// unions and record enum variants.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     foo::Bar {\n-            ///         #![inner_attr]\n-            ///         baz: 42,\n-            ///         bruh: true,\n-            ///         ..spread\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n-            struct RecordLit { Path, RecordFieldList}\n-\n-            /// Record field list including enclosing curly braces.\n-            ///\n-            /// foo::Bar \u2770\n-            ///     {\n-            ///         baz: 42,\n-            ///         ..spread\n-            ///     }\n-            /// \u2771\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n-            struct RecordFieldList {\n-                T!['{'],\n-                fields: [RecordField],\n-                T![..],\n-                spread: Expr,\n-                T!['}']\n-            }\n-\n-            /// Record field.\n-            ///\n-            /// ```\n-            /// foo::Bar {\n-            ///     \u2770 #[attr] baz: 42 \u2771\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n-            struct RecordField: AttrsOwner { NameRef, T![:], Expr }\n-\n-            /// Disjunction of patterns.\n-            ///\n-            /// ```\n-            /// let \u2770 Foo(it) | Bar(it) | Baz(it) \u2771 = bruh;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html)\n-            struct OrPat { pats: [Pat] }\n-\n-            /// Parenthesized pattern.\n-            /// Note: parens are only used for grouping, this is not a tuple pattern.\n-            ///\n-            /// ```\n-            /// if let \u2770 &(0..=42) \u2771 = foo {}\n-            /// ```\n-            ///\n-            /// https://doc.rust-lang.org/reference/patterns.html#grouped-patterns\n-            struct ParenPat { T!['('], Pat, T![')'] }\n-\n-            /// Reference pattern.\n-            /// Note: this has nothing to do with `ref` keyword, the latter is used in bind patterns.\n-            ///\n-            /// ```\n-            /// let \u2770 &mut foo \u2771 = bar;\n-            ///\n-            /// let \u2770 & \u2770 &mut \u2770 &_ \u2771 \u2771 \u2771 = baz;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#reference-patterns)\n-            struct RefPat { T![&], T![mut], Pat }\n-\n-            /// Box pattern.\n-            ///\n-            /// ```\n-            /// let \u2770 box foo \u2771 = box 42;\n-            /// ```\n-            ///\n-            /// [Unstable book](https://doc.rust-lang.org/unstable-book/language-features/box-patterns.html)\n-            struct BoxPat { T![box], Pat }\n-\n-            /// Bind pattern.\n-            ///\n-            /// ```\n-            /// match foo {\n-            ///     Some(\u2770 ref mut bar \u2771) => {}\n-            ///     \u2770 baz @ None \u2771 => {}\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#identifier-patterns)\n-            struct BindPat: AttrsOwner, NameOwner { T![ref], T![mut], T![@], Pat }\n-\n-            /// Placeholder pattern a.k.a. the wildcard pattern or the underscore.\n-            ///\n-            /// ```\n-            /// let \u2770 _ \u2771 = foo;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern)\n-            struct PlaceholderPat { T![_] }\n-\n-            /// Rest-of-the record/tuple pattern.\n-            /// Note: this is not the unbonded range pattern (even more: it doesn't exist).\n-            ///\n-            /// ```\n-            /// let Foo { bar, \u2770 .. \u2771 } = baz;\n-            /// let (\u2770 .. \u2771, bruh) = (42, 24, 42);\n-            /// let Bruuh(\u2770 .. \u2771) = bruuuh;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n-            struct DotDotPat { T![..] }\n-\n-            /// Path pattern.\n-            /// Doesn't include the underscore pattern (it is a special case, namely `PlaceholderPat`).\n-            ///\n-            /// ```\n-            /// let \u2770 foo::bar::Baz \u2771 { .. } = bruh;\n-            /// if let \u2770 CONST \u2771 = 42 {}\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#path-patterns)\n-            struct PathPat { Path }\n-\n-            /// Slice pattern.\n-            ///\n-            /// ```\n-            /// let \u2770 [foo, bar, baz] \u2771 = [1, 2, 3];\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#slice-patterns)\n-            struct SlicePat { T!['['], args: [Pat], T![']'] }\n-\n-            /// Range pattern.\n-            ///\n-            /// ```\n-            /// match foo {\n-            ///     \u2770 0..42 \u2771 => {}\n-            ///     \u2770 0..=42 \u2771 => {}\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#range-patterns)\n-            struct RangePat { } // FIXME(@matklad): here should be T![..], T![..=] I think, if we don't already have an accessor in expresions_ext\n-\n-            /// Literal pattern.\n-            /// Includes only bool, number, char, and string literals.\n-            ///\n-            /// ```\n-            /// match foo {\n-            ///     Number(\u2770 42 \u2771) => {}\n-            ///     String(\u2770 \"42\" \u2771) => {}\n-            ///     Bool(\u2770 true \u2771) => {}\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#literal-patterns)\n-            struct LiteralPat { Literal }\n-\n-            /// Macro invocation in pattern position.\n-            ///\n-            /// ```\n-            /// let \u2770 foo!(my custom syntax) \u2771 = baz;\n-            ///\n-            /// ```\n-            /// [Reference](https://doc.rust-lang.org/reference/macros.html#macro-invocation)\n-            struct MacroPat { MacroCall }\n-\n-            /// Record literal pattern.\n-            ///\n-            /// ```\n-            /// let \u2770 foo::Bar { baz, .. } \u2771 = bruh;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n-            struct RecordPat { RecordFieldPatList, Path }\n-\n-            /// Record literal's field patterns list including enclosing curly braces.\n-            ///\n-            /// ```\n-            /// let foo::Bar \u2770 { baz, bind @ bruh, .. } \u2771 = bruuh;\n-            /// ``\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n-            struct RecordFieldPatList {\n-                T!['{'],\n-                record_field_pats: [RecordFieldPat],\n-                bind_pats: [BindPat],\n-                T![..],\n-                T!['}']\n-            }\n-\n-            /// Record literal's field pattern.\n-            /// Note: record literal can also match tuple structs.\n-            ///\n-            /// ```\n-            /// let Foo { \u2770 bar: _ \u2771 } = baz;\n-            /// let TupleStruct { \u2770 0: _ \u2771 } = bruh;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n-            struct RecordFieldPat: AttrsOwner { NameRef, T![:], Pat }\n-\n-            /// Tuple struct literal pattern.\n-            ///\n-            /// ```\n-            /// let \u2770 foo::Bar(baz, bruh) \u2771 = bruuh;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-struct-patterns)\n-            struct TupleStructPat { Path, T!['('], args: [Pat], T![')'] }\n-\n-            /// Tuple pattern.\n-            /// Note: this doesn't include tuple structs (see `TupleStructPat`)\n-            ///\n-            /// ```\n-            /// let \u2770 (foo, bar, .., baz) \u2771 = bruh;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-patterns)\n-            struct TuplePat { T!['('], args: [Pat], T![')'] }\n-\n-            /// Visibility.\n-            ///\n-            /// ```\n-            /// \u2770 pub mod \u2771 foo;\n-            /// \u2770 pub(crate) \u2771 struct Bar;\n-            /// \u2770 pub(self) \u2771 enum Baz {}\n-            /// \u2770 pub(super) \u2771 fn bruh() {}\n-            /// \u2770 pub(in bruuh::bruuuh) \u2771 type T = u64;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html)\n-            struct Visibility { T![pub], T![super], T![self], T![crate] }\n-\n-            /// Single identifier.\n-            /// Note(@matklad): `Name` is for things that install a new name into the scope,\n-            /// `NameRef` is a usage of a name. Most of the time, this definition/reference\n-            /// distinction can be determined purely syntactically, ie in\n-            /// ```\n-            /// fn foo() { foo() }\n-            /// ```\n-            /// the first foo is `Name`, the second one is `NameRef`.\n-            /// The notable exception are patterns, where in\n-            /// ``\n-            /// let x = 92\n-            /// ```\n-            /// `x` can be semantically either a name or a name ref, depeding on\n-            /// wether there's an `x` constant in scope.\n-            /// We use `Name` for patterns, and disambiguate semantically (see `NameClass` in ide_db).\n-            ///\n-            /// ```\n-            /// let \u2770 foo \u2771 = bar;\n-            /// struct \u2770 Baz \u2771;\n-            /// fn \u2770 bruh \u2771() {}\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n-            struct Name { T![ident] }\n-\n-            /// Reference to a name.\n-            /// See the explanation on the difference between `Name` and `NameRef`\n-            /// in `Name` ast node docs.\n-            ///\n-            /// ```\n-            /// let foo = \u2770 bar \u2771(\u2770 Baz(\u2770 bruh \u2771) \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n-            struct NameRef { }\n-\n-            /// Macro call.\n-            /// Includes all of its attributes and doc comments.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     /// Docs\n-            ///     #[attr]\n-            ///     macro_rules! foo {   // macro rules is also a macro call\n-            ///         ($bar: tt) => {}\n-            ///     }\n-            /// \u2771\n-            ///\n-            /// // semicolon is a part of `MacroCall` when it is used in item positions\n-            /// \u2770 foo!(); \u2771\n-            ///\n-            /// fn main() {\n-            ///     \u2770 foo!() \u2771; // macro call in expression positions doesn't include the semi\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n-            struct MacroCall: NameOwner, AttrsOwner, DocCommentsOwner {\n-                Path, T![!], TokenTree, T![;]\n-            }\n-\n-            /// Attribute.\n-            ///\n-            /// ```\n-            /// \u2770 #![inner_attr] \u2771\n-            ///\n-            /// \u2770 #[attr] \u2771\n-            /// \u2770 #[foo = \"bar\"] \u2771\n-            /// \u2770 #[baz(bruh::bruuh = \"42\")] \u2771\n-            /// struct Foo;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/attributes.html)\n-            struct Attr { T![#], T![!], T!['['], Path, T![=], input: AttrInput, T![']'] }\n-\n-            /// Stores a list of lexer tokens and other `TokenTree`s.\n-            /// It appears in attributes, macro_rules and macro call (foo!)\n-            ///\n-            /// ```\n-            /// macro_call! \u2770 { my syntax here } \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n-            struct TokenTree {}\n-\n-            /// Generic lifetime, type and constants parameters list **declaration**.\n-            ///\n-            /// ```\n-            /// fn foo\u2770 <'a, 'b, T, U, const BAR: u64> \u2771() {}\n-            ///\n-            /// struct Baz\u2770 <T> \u2771(T);\n-            ///\n-            /// impl\u2770 <T> \u2771 Bruh<T> {}\n-            ///\n-            /// type Bruuh = for\u2770 <'a> \u2771 fn(&'a str) -> &'a str;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n-            struct TypeParamList {\n-                T![<],\n-                type_params: [TypeParam],\n-                lifetime_params: [LifetimeParam],\n-                const_params: [ConstParam],\n-                T![>]\n-            }\n-\n-            /// Single type parameter **declaration**.\n-            ///\n-            /// ```\n-            /// fn foo<\u2770 K \u2771, \u2770 I \u2771, \u2770 E: Debug \u2771, \u2770 V = DefaultType \u2771>() {}\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n-            struct TypeParam: NameOwner, AttrsOwner, TypeBoundsOwner {\n-                T![=],\n-                default_type: TypeRef,\n-            }\n-\n-            /// Const generic parameter **declaration**.\n-            /// ```\n-            /// fn foo<T, U, \u2770 const BAR: usize \u2771, \u2770 const BAZ: bool \u2771>() {}\n-            /// ```\n-            ///\n-            /// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n-            struct ConstParam: NameOwner, AttrsOwner, TypeAscriptionOwner {\n-                T![=],\n-                default_val: Expr,\n-            }\n-\n-            /// Lifetime parameter **declaration**.\n-            ///\n-            /// ```\n-            /// fn foo<\u2770 'a \u2771, \u2770 'b \u2771, V, G, D>(bar: &'a str, baz: &'b mut str) {}\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n-            struct LifetimeParam: AttrsOwner { T![lifetime] }\n-\n-            /// Type bound declaration clause.\n-            ///\n-            /// ```\n-            /// fn foo<T: \u2770 ?Sized \u2771 + \u2770 Debug \u2771>() {}\n-            ///\n-            /// trait Bar<T>\n-            /// where\n-            ///     T: \u2770 Send \u2771 + \u2770 Sync \u2771\n-            /// {\n-            ///     type Baz: \u2770 !Sync \u2771 + \u2770 Debug \u2771 + \u2770 ?const Add \u2771;\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n-            struct TypeBound { T![lifetime], /* Question,  */ T![const], /* Question, */ TypeRef }\n-\n-            /// Type bounds list.\n-            ///\n-            /// ```\n-            ///\n-            /// fn foo<T: \u2770 ?Sized + Debug \u2771>() {}\n-            ///\n-            /// trait Bar<T>\n-            /// where\n-            ///     T: \u2770 Send + Sync \u2771\n-            /// {\n-            ///     type Baz: \u2770 !Sync + Debug \u2771;\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n-            struct TypeBoundList { bounds: [TypeBound] }\n-\n-            /// Single where predicate.\n-            ///\n-            /// ```\n-            /// trait Foo<'a, 'b, T>\n-            /// where\n-            ///     \u2770 'a: 'b \u2771,\n-            ///     \u2770 T: IntoIterator \u2771,\n-            ///     \u2770 for<'c> <T as IntoIterator>::Item: Bar<'c> \u2771\n-            /// {}\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n-            struct WherePred: TypeBoundsOwner { T![for], TypeParamList, T![lifetime], TypeRef }\n-\n-            /// Where clause.\n-            ///\n-            /// ```\n-            /// trait Foo<'a, T> \u2770 where 'a: 'static, T: Debug \u2771 {}\n-            ///\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n-            struct WhereClause { T![where], predicates: [WherePred] }\n-\n-            /// Abi declaration.\n-            /// Note: the abi string is optional.\n-            ///\n-            /// ```\n-            /// \u2770 extern \"C\" \u2771 {\n-            ///     fn foo() {}\n-            /// }\n-            ///\n-            /// type Bar = \u2770 extern \u2771 fn() -> u32;\n-            ///\n-            /// type Baz = \u2770 extern r#\"stdcall\"# \u2771 fn() -> bool;\n-            /// ```\n-            ///\n-            /// - [Extern blocks reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n-            /// - [FFI function pointers reference](https://doc.rust-lang.org/reference/items/functions.html#functions)\n-            struct Abi { /*String*/ }\n-\n-            /// Expression statement.\n-            ///\n-            /// ```\n-            /// \u2770 42; \u2771\n-            /// \u2770 foo(); \u2771\n-            /// \u2770 (); \u2771\n-            /// \u2770 {}; \u2771\n-            ///\n-            /// // constructions with trailing curly brace can omit the semicolon\n-            /// // but only when there are satements immediately after them (this is important!)\n-            /// \u2770 if bool_cond { } \u2771\n-            /// \u2770 loop {} \u2771\n-            /// \u2770 somestatment; \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/statements.html)\n-            struct ExprStmt: AttrsOwner { Expr, T![;] }\n-\n-            /// Let statement.\n-            ///\n-            /// ```\n-            /// \u2770 #[attr] let foo; \u2771\n-            /// \u2770 let bar: u64; \u2771\n-            /// \u2770 let baz = 42; \u2771\n-            /// \u2770 let bruh: bool = true; \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/statements.html#let-statements)\n-            struct LetStmt: AttrsOwner, TypeAscriptionOwner {\n-                T![let],\n-                Pat,\n-                T![=],\n-                initializer: Expr,\n-                T![;],\n-            }\n-\n-            /// Condition of `if` or `while` expression.\n-            ///\n-            /// ```\n-            /// if \u2770 true \u2771 {}\n-            /// if \u2770 let Pat(foo) = bar \u2771 {}\n-            ///\n-            /// while \u2770 true \u2771 {}\n-            /// while \u2770 let Pat(baz) = bruh \u2771 {}\n-            /// ```\n-            ///\n-            /// [If expression reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n-            /// [While expression reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n-            struct Condition { T![let], Pat, T![=], Expr }\n-\n-            /// Parameter list **declaration**.\n-            ///\n-            /// ```\n-            /// fn foo\u2770 (a: u32, b: bool) \u2771 -> u32 {}\n-            /// let bar = \u2770 |a, b| \u2771 {};\n-            ///\n-            /// impl Baz {\n-            ///     fn bruh\u2770 (&self, a: u32) \u2771 {}\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)ocs to codegen script\n-            struct ParamList { // FIXME: this node is used by closure expressions too, but hey use pipes instead of parens...\n-                T!['('],\n-                SelfParam,\n-                params: [Param],\n-                T![')']\n-            }\n-\n-            /// Self parameter **declaration**.\n-            ///\n-            /// ```\n-            /// impl Bruh {\n-            ///     fn foo(\u2770 self \u2771) {}\n-            ///     fn bar(\u2770 &self \u2771) {}\n-            ///     fn baz(\u2770 &mut self \u2771) {}\n-            ///     fn blah<'a>(\u2770 &'a self \u2771) {}\n-            ///     fn blin(\u2770 self: Box<Self> \u2771) {}\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n-            struct SelfParam: TypeAscriptionOwner, AttrsOwner { T![&], T![mut], T![lifetime], T![self] }\n-\n-            /// Parameter **declaration**.\n-            ///\n-            /// ```\n-            /// fn foo(\u2770 #[attr] Pat(bar): Pat(u32) \u2771, \u2770 #[attr] _: bool \u2771) {}\n-            ///\n-            /// extern \"C\" {\n-            ///     fn bar(\u2770 baz: u32 \u2771, \u2770 ... \u2771) -> u32;\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n-            struct Param: TypeAscriptionOwner, AttrsOwner {\n-                Pat,\n-                T![...]\n-            }\n-\n-            /// Use declaration.\n-            ///\n-            /// ```\n-            /// \u2770 #[attr] pub use foo; \u2771\n-            /// \u2770 use bar as baz; \u2771\n-            /// \u2770 use bruh::{self, bruuh}; \u2771\n-            /// \u2770 use { blin::blen, blah::* };\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n-            struct UseItem: AttrsOwner, VisibilityOwner {\n-                T![use],\n-                UseTree,\n-            }\n-\n-            /// Use tree.\n-            ///\n-            /// ```\n-            /// pub use \u2770 foo::\u2770 * \u2771 \u2771;\n-            /// use \u2770 bar as baz \u2771;\n-            /// use \u2770 bruh::bruuh::{ \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n-            /// use \u2770 { \u2770 blin::blen \u2771 } \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n-            struct UseTree {\n-                Path, T![*], UseTreeList, Alias\n-            }\n-\n-            /// Item alias.\n-            /// Note: this is not the type alias.\n-            ///\n-            /// ```\n-            /// use foo \u2770 as bar \u2771;\n-            /// use baz::{bruh \u2770 as _ \u2771};\n-            /// extern crate bruuh \u2770 as blin \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n-            struct Alias: NameOwner { T![as] }\n-\n-            /// Sublist of use trees.\n-            ///\n-            /// ```\n-            /// use bruh::bruuh::\u2770 { \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n-            /// use \u2770 { blin::blen::\u2770 {} \u2771 } \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n-            struct UseTreeList { T!['{'], use_trees: [UseTree], T!['}'] }\n-\n-            /// Extern crate item.\n-            ///\n-            /// ```\n-            /// \u2770 #[attr] pub extern crate foo; \u2771\n-            /// \u2770 extern crate self as bar; \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/extern-crates.html)\n-            struct ExternCrateItem: AttrsOwner, VisibilityOwner {\n-                T![extern], T![crate], NameRef, Alias,\n-            }\n-\n-            /// Call site arguments list.\n-            ///\n-            /// ```\n-            /// foo::<T, U>\u2770 (42, true) \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n-            struct ArgList {\n-                T!['('],\n-                args: [Expr],\n-                T![')']\n-            }\n-\n-            /// Path to a symbol. Includes single identifier names and elaborate paths with\n-            /// generic parameters.\n-            ///\n-            /// ```\n-            /// (0..10).\u2770 \u2770 collect \u2771 ::<Vec<_>> \u2771();\n-            /// \u2770 \u2770 \u2770 Vec \u2771 ::<u8> \u2771 ::with_capacity \u2771(1024);\n-            /// \u2770 \u2770 <\u2770 Foo \u2771 as \u2770 \u2770 bar \u2771 ::Bar \u2771> \u2771 ::baz \u2771();\n-            /// \u2770 \u2770 <\u2770 bruh \u2771> \u2771 ::bruuh \u2771();\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n-            struct Path {\n-                segment: PathSegment,\n-                T![::],\n-                qualifier: Path,\n-            }\n-\n-            /// Segment of the path to a symbol.\n-            /// Only path segment of an absolute path holds the `::` token,\n-            /// all other `::` tokens that connect path segments reside under `Path` itself.`\n-            ///\n-            /// ```\n-            /// (0..10).\u2770 collect \u2771 :: \u2770 <Vec<_>> \u2771();\n-            /// \u2770 Vec \u2771 :: \u2770 <u8> \u2771 :: \u2770 with_capacity \u2771(1024);\n-            /// \u2770 <\u2770 Foo \u2771 as \u2770 bar \u2771 :: \u2770 Bar \u2771> \u2771 :: \u2770 baz \u2771();\n-            /// \u2770 <\u2770 bruh \u2771> \u2771 :: \u2770 bruuh \u2771();\n-            ///\n-            /// // Note that only in this case `::` token is inlcuded:\n-            /// \u2770 ::foo \u2771;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n-            struct PathSegment {\n-                T![::], T![crate], T![self], T![super], T![<], NameRef, TypeArgList, ParamList, RetType, PathType, T![>]\n-            }\n-\n-            /// List of type arguments that are passed at generic instantiation site.\n-            ///\n-            /// ```\n-            /// type _ = Foo \u2770 ::<'a, u64, Item = Bar, 42, {true}> \u2771::Bar;\n-            ///\n-            /// Vec\u2770 ::<bool> \u2771::();\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n-            struct TypeArgList {\n-                T![::],\n-                T![<],\n-                generic_args: [GenericArg],\n-                type_args: [TypeArg],\n-                lifetime_args: [LifetimeArg],\n-                assoc_type_args: [AssocTypeArg],\n-                const_args: [ConstArg],\n-                T![>]\n-            }\n-\n-            /// Type argument that is passed at generic instantiation site.\n-            ///\n-            /// ```\n-            /// type _ = Foo::<'a, \u2770 u64 \u2771, \u2770 bool \u2771, Item = Bar, 42>::Baz;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n-            struct TypeArg { TypeRef }\n-\n-            /// Associated type argument that is passed at generic instantiation site.\n-            /// ```\n-            /// type Foo = Bar::<'a, u64, bool, \u2770 Item = Baz \u2771, 42>::Bruh;\n-            ///\n-            /// trait Bruh<T>: Iterator<\u2770 Item: Debug \u2771> {}\n-            /// ```\n-            ///\n-            struct AssocTypeArg : TypeBoundsOwner { NameRef, T![=], TypeRef }\n-\n-            /// Lifetime argument that is passed at generic instantiation site.\n-            ///\n-            /// ```\n-            /// fn foo<'a>(s: &'a str) {\n-            ///     bar::<\u2770 'a \u2771>(s);\n-            /// }\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n-            struct LifetimeArg { T![lifetime] }\n-\n-            /// Constant value argument that is passed at generic instantiation site.\n-            ///\n-            /// ```\n-            /// foo::<u32, \u2770 { true } \u2771>();\n-            ///\n-            /// bar::<\u2770 { 2 + 2} \u2771>();\n-            /// ```\n-            ///\n-            /// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n-            struct ConstArg { Literal, BlockExpr }\n-\n-\n-            /// FIXME: (@edwin0cheng) Remove it to use ItemList instead\n-            /// https://github.com/rust-analyzer/rust-analyzer/pull/4083#discussion_r422666243\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n-            struct MacroItems: ModuleItemOwner { }\n-\n-            /// FIXME: (@edwin0cheng) add some documentation here. As per the writing\n-            /// of this comment this ast node is not used.\n-            ///\n-            /// ```\n-            /// // FIXME: example here\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n-            struct MacroStmts {\n-                statements: [Stmt],\n-                Expr,\n-            }\n-\n-            /// List of items in an extern block.\n-            ///\n-            /// ```\n-            /// extern \"C\" \u2770\n-            ///     {\n-            ///         fn foo();\n-            ///         static var: u32;\n-            ///     }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n-            struct ExternItemList: ModuleItemOwner {\n-                T!['{'],\n-                extern_items: [ExternItem],\n-                T!['}']\n-            }\n-\n-            /// Extern block.\n-            ///\n-            /// ```\n-            /// \u2770\n-            ///     extern \"C\" {\n-            ///         fn foo();\n-            ///     }\n-            /// \u2771\n-            ///\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n-            struct ExternBlock {\n-                Abi,\n-                ExternItemList\n-            }\n-\n-            /// Meta item in an attribute.\n-            ///\n-            /// ```\n-            /// #[\u2770 bar::baz = \"42\" \u2771]\n-            /// #[\u2770 bruh(bruuh(\"true\")) \u2771]\n-            /// struct Foo;\n-            /// ```\n-            ///\n-            /// [Reference](https://doc.rust-lang.org/reference/attributes.html?highlight=meta,item#meta-item-attribute-syntax)\n-            struct MetaItem {\n-                Path, T![=], AttrInput, nested_meta_items: [MetaItem]\n-            }\n-\n-            /// Macro 2.0 definition.\n-            /// Their syntax is still WIP by rustc team...\n-            /// ```\n-            /// \u2770\n-            ///     macro foo { }\n-            /// \u2771\n-            /// ```\n-            ///\n-            /// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md)\n-            struct MacroDef {\n-                Name, TokenTree\n-            }\n-        },\n-        enums: ast_enums! {\n-            /// Any kind of nominal type definition.\n-            enum NominalDef: NameOwner, TypeParamsOwner, AttrsOwner {\n-                StructDef, EnumDef, UnionDef,\n-            }\n-\n-            /// Any kind of generic argument passed at instantiation site\n-            enum GenericArg {\n-                LifetimeArg,\n-                TypeArg,\n-                ConstArg,\n-                AssocTypeArg\n-            }\n-\n-            /// Any kind of construct valid in type context\n-            enum TypeRef {\n-                ParenType,\n-                TupleType,\n-                NeverType,\n-                PathType,\n-                PointerType,\n-                ArrayType,\n-                SliceType,\n-                ReferenceType,\n-                PlaceholderType,\n-                FnPointerType,\n-                ForType,\n-                ImplTraitType,\n-                DynTraitType,\n-            }\n-\n-            /// Any kind of top-level item that may appear in a module\n-            enum ModuleItem: NameOwner, AttrsOwner, VisibilityOwner {\n-                StructDef,\n-                UnionDef,\n-                EnumDef,\n-                FnDef,\n-                TraitDef,\n-                TypeAliasDef,\n-                ImplDef,\n-                UseItem,\n-                ExternCrateItem,\n-                ConstDef,\n-                StaticDef,\n-                Module,\n-                MacroCall,\n-                ExternBlock\n-            }\n-\n-\n-\n-            /// Any kind of item that may appear in an impl block\n-            ///\n-            /// // FIXME: impl blocks can also contain MacroCall\n-            enum AssocItem: NameOwner, AttrsOwner {\n-                FnDef, TypeAliasDef, ConstDef\n-            }\n-\n-            /// Any kind of item that may appear in an extern block\n-            ///\n-            /// // FIXME: extern blocks can also contain MacroCall\n-            enum ExternItem: NameOwner, AttrsOwner, VisibilityOwner {\n-                FnDef, StaticDef\n-            }\n-\n-            /// Any kind of expression\n-            enum Expr: AttrsOwner {\n-                TupleExpr,\n-                ArrayExpr,\n-                ParenExpr,\n-                PathExpr,\n-                LambdaExpr,\n-                IfExpr,\n-                LoopExpr,\n-                ForExpr,\n-                WhileExpr,\n-                ContinueExpr,\n-                BreakExpr,\n-                Label,\n-                BlockExpr,\n-                ReturnExpr,\n-                MatchExpr,\n-                RecordLit,\n-                CallExpr,\n-                IndexExpr,\n-                MethodCallExpr,\n-                FieldExpr,\n-                AwaitExpr,\n-                TryExpr,\n-                EffectExpr,\n-                CastExpr,\n-                RefExpr,\n-                PrefixExpr,\n-                RangeExpr,\n-                BinExpr,\n-                Literal,\n-                MacroCall,\n-                BoxExpr,\n-            }\n-\n-            /// Any kind of pattern\n-            enum Pat {\n-                OrPat,\n-                ParenPat,\n-                RefPat,\n-                BoxPat,\n-                BindPat,\n-                PlaceholderPat,\n-                DotDotPat,\n-                PathPat,\n-                RecordPat,\n-                TupleStructPat,\n-                TuplePat,\n-                SlicePat,\n-                RangePat,\n-                LiteralPat,\n-                MacroPat,\n-            }\n-\n-            /// Any kind of input to an attribute\n-            enum AttrInput { Literal, TokenTree }\n-\n-            /// Any kind of statement\n-            /// Note: there are no empty statements, these are just represented as\n-            /// bare semicolons without a dedicated statement ast node.\n-            enum Stmt {\n-                LetStmt,\n-                ExprStmt,\n-                // macro calls are parsed as expression statements\n-            }\n-\n-            /// Any kind of fields list (record or tuple field lists)\n-            enum FieldDefList {\n-                RecordFieldDefList,\n-                TupleFieldDefList,\n-            }\n-        },\n-    }\n-}"}, {"sha": "24e8be1fbce0f38981d20ed99da5194db4507b1d", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 220, "deletions": 4, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=2dfda0b984c45946b9a4148bd848350deac544f2", "patch": "@@ -3,19 +3,27 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n-use std::{collections::HashSet, fmt::Write};\n+use std::{\n+    collections::{BTreeSet, HashSet},\n+    fmt::Write,\n+};\n \n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n+use ungrammar::{Grammar, Rule};\n \n use crate::{\n-    ast_src::{rust_ast, AstSrc, Field, FieldSrc, KindsSrc, KINDS_SRC},\n+    ast_src::{AstEnumSrc, AstNodeSrc, AstSrc, Field, FieldSrc, KindsSrc, KINDS_SRC},\n     codegen::{self, update, Mode},\n     project_root, Result,\n };\n \n pub fn generate_syntax(mode: Mode) -> Result<()> {\n-    let ast = rust_ast();\n+    let grammar = include_str!(\"rust.ungram\")\n+        .parse::<Grammar>()\n+        .unwrap_or_else(|err| panic!(\"\\n    \\x1b[91merror\\x1b[0m: {}\\n\", err));\n+    let ast = lower(&grammar);\n+\n     let syntax_kinds_file = project_root().join(codegen::SYNTAX_KINDS);\n     let syntax_kinds = generate_syntax_kinds(KINDS_SRC)?;\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n@@ -215,7 +223,9 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> Result<String> {\n         .map(|kind| to_pascal_case(kind))\n         .filter(|name| !defined_nodes.iter().any(|&it| it == name))\n     {\n-        eprintln!(\"Warning: node {} not defined in ast source\", node);\n+        drop(node)\n+        // TODO: restore this\n+        // eprintln!(\"Warning: node {} not defined in ast source\", node);\n     }\n \n     let ast = quote! {\n@@ -414,6 +424,10 @@ fn to_pascal_case(s: &str) -> String {\n     buf\n }\n \n+fn pluralize(s: &str) -> String {\n+    format!(\"{}s\", s)\n+}\n+\n impl Field {\n     fn is_many(&self) -> bool {\n         matches!(self, Field::Node { src: FieldSrc::Many(_), .. })\n@@ -449,6 +463,7 @@ impl Field {\n                     \".\" => \"dot\",\n                     \"..\" => \"dotdot\",\n                     \"...\" => \"dotdotdot\",\n+                    \"..=\" => \"dotdoteq\",\n                     \"=>\" => \"fat_arrow\",\n                     \"@\" => \"at\",\n                     \":\" => \"colon\",\n@@ -475,3 +490,204 @@ impl Field {\n         }\n     }\n }\n+\n+fn lower(grammar: &Grammar) -> AstSrc {\n+    let mut res = AstSrc::default();\n+    res.tokens = vec![\"Whitespace\".into(), \"Comment\".into(), \"String\".into(), \"RawString\".into()];\n+\n+    let nodes = grammar\n+        .iter()\n+        .filter(|&node| match grammar[node].rule {\n+            Rule::Node(it) if it == node => false,\n+            _ => true,\n+        })\n+        .collect::<Vec<_>>();\n+\n+    for &node in &nodes {\n+        let name = grammar[node].name.clone();\n+        let rule = &grammar[node].rule;\n+        match lower_enum(grammar, rule) {\n+            Some(variants) => {\n+                let enum_src = AstEnumSrc { doc: Vec::new(), name, traits: Vec::new(), variants };\n+                res.enums.push(enum_src);\n+            }\n+            None => {\n+                let mut fields = Vec::new();\n+                lower_rule(&mut fields, grammar, rule);\n+                res.nodes.push(AstNodeSrc { doc: Vec::new(), name, traits: Vec::new(), fields });\n+            }\n+        }\n+    }\n+\n+    deduplicate_fields(&mut res);\n+    extract_enums(&mut res);\n+    extract_struct_traits(&mut res);\n+    extract_enum_traits(&mut res);\n+    res\n+}\n+\n+fn lower_enum(grammar: &Grammar, rule: &Rule) -> Option<Vec<String>> {\n+    let alternatives = match rule {\n+        Rule::Alt(it) => it,\n+        _ => return None,\n+    };\n+    let mut variants = Vec::new();\n+    for alternative in alternatives {\n+        match alternative {\n+            Rule::Node(it) => variants.push(grammar[*it].name.clone()),\n+            _ => return None,\n+        }\n+    }\n+    Some(variants)\n+}\n+\n+fn lower_rule(acc: &mut Vec<Field>, grammar: &Grammar, rule: &Rule) {\n+    match rule {\n+        Rule::Node(node) => {\n+            let field = Field::Node { name: grammar[*node].name.clone(), src: FieldSrc::Shorthand };\n+            acc.push(field);\n+        }\n+        Rule::Token(token) => {\n+            let mut name = grammar[*token].name.clone();\n+            if name != \"int_number\" && name != \"string\" {\n+                if \"[]{}()\".contains(&name) {\n+                    name = format!(\"'{}'\", name);\n+                }\n+                let field = Field::Token(name);\n+                acc.push(field);\n+            }\n+        }\n+        Rule::Rep(inner) => {\n+            if let Rule::Node(node) = &**inner {\n+                let name = grammar[*node].name.clone();\n+                let label = pluralize(&to_lower_snake_case(&name));\n+                let field = Field::Node { name: label.clone(), src: FieldSrc::Many(name) };\n+                acc.push(field);\n+                return;\n+            }\n+            todo!(\"{:?}\", rule)\n+        }\n+        Rule::Labeled { label, rule } => {\n+            let node = match &**rule {\n+                Rule::Rep(inner) | Rule::Opt(inner) => match &**inner {\n+                    Rule::Node(node) => node,\n+                    _ => todo!(\"{:?}\", rule),\n+                },\n+                Rule::Node(node) => node,\n+                _ => todo!(\"{:?}\", rule),\n+            };\n+            let field = Field::Node {\n+                name: label.clone(),\n+                src: match &**rule {\n+                    Rule::Rep(_) => FieldSrc::Many(grammar[*node].name.clone()),\n+                    _ => FieldSrc::Optional(grammar[*node].name.clone()),\n+                },\n+            };\n+            acc.push(field);\n+        }\n+        Rule::Seq(rules) | Rule::Alt(rules) => {\n+            for rule in rules {\n+                lower_rule(acc, grammar, rule)\n+            }\n+        }\n+        Rule::Opt(rule) => lower_rule(acc, grammar, rule),\n+    }\n+}\n+\n+fn deduplicate_fields(ast: &mut AstSrc) {\n+    eprintln!();\n+    for node in &mut ast.nodes {\n+        let mut i = 0;\n+        'outer: while i < node.fields.len() {\n+            for j in 0..i {\n+                let f1 = &node.fields[i];\n+                let f2 = &node.fields[j];\n+                if f1 == f2 {\n+                    node.fields.remove(i);\n+                    continue 'outer;\n+                }\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\n+fn extract_enums(ast: &mut AstSrc) {\n+    for node in &mut ast.nodes {\n+        for enm in &ast.enums {\n+            let mut to_remove = Vec::new();\n+            for (i, field) in node.fields.iter().enumerate() {\n+                let ty = field.ty().to_string();\n+                if enm.variants.iter().any(|it| it == &ty) {\n+                    to_remove.push(i);\n+                }\n+            }\n+            if to_remove.len() == enm.variants.len() {\n+                node.remove_field(to_remove);\n+                node.fields.push(Field::Node { name: enm.name.clone(), src: FieldSrc::Shorthand });\n+            }\n+        }\n+    }\n+}\n+\n+fn extract_struct_traits(ast: &mut AstSrc) {\n+    let traits: &[(&str, &[&str])] = &[\n+        (\"AttrsOwner\", &[\"attrs\"]),\n+        (\"NameOwner\", &[\"name\"]),\n+        (\"VisibilityOwner\", &[\"visibility\"]),\n+        (\"TypeParamsOwner\", &[\"type_param_list\", \"where_clause\"]),\n+        (\"TypeBoundsOwner\", &[\"type_bound_list\", \"colon_token\"]),\n+        (\"ModuleItemOwner\", &[\"items\"]),\n+        (\"TypeAscriptionOwner\", &[\"ascribed_type\"]),\n+        (\"LoopBodyOwner\", &[\"label\", \"loop_body\"]),\n+        (\"ArgListOwner\", &[\"arg_list\"]),\n+    ];\n+\n+    for node in &mut ast.nodes {\n+        for (name, methods) in traits {\n+            extract_struct_trait(node, name, methods);\n+        }\n+    }\n+}\n+\n+fn extract_struct_trait(node: &mut AstNodeSrc, trait_name: &str, methods: &[&str]) {\n+    let mut to_remove = Vec::new();\n+    for (i, field) in node.fields.iter().enumerate() {\n+        let method_name = field.method_name().to_string();\n+        if methods.iter().any(|&it| it == &method_name) {\n+            to_remove.push(i);\n+        }\n+    }\n+    if to_remove.len() == methods.len() {\n+        node.traits.push(trait_name.to_string());\n+        node.remove_field(to_remove);\n+    }\n+}\n+\n+fn extract_enum_traits(ast: &mut AstSrc) {\n+    for enm in &mut ast.enums {\n+        let nodes = &ast.nodes;\n+        let mut variant_traits = enm\n+            .variants\n+            .iter()\n+            .map(|var| nodes.iter().find(|it| &it.name == var).unwrap())\n+            .map(|node| node.traits.iter().cloned().collect::<BTreeSet<_>>());\n+\n+        let mut enum_traits = match variant_traits.next() {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+        for traits in variant_traits {\n+            enum_traits = enum_traits.intersection(&traits).cloned().collect();\n+        }\n+        enm.traits = enum_traits.into_iter().collect();\n+    }\n+}\n+\n+impl AstNodeSrc {\n+    fn remove_field(&mut self, to_remove: Vec<usize>) {\n+        to_remove.into_iter().rev().for_each(|idx| {\n+            self.fields.remove(idx);\n+        });\n+    }\n+}"}, {"sha": "8a3eb7b291c0670ea3ffe1891bc0aa6f8b311860", "filename": "xtask/src/codegen/rust.ungram", "status": "added", "additions": 529, "deletions": 0, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/2dfda0b984c45946b9a4148bd848350deac544f2/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/2dfda0b984c45946b9a4148bd848350deac544f2/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=2dfda0b984c45946b9a4148bd848350deac544f2", "patch": "@@ -0,0 +1,529 @@\n+SourceFile =\n+  Attr*\n+  items:ModuleItem*\n+\n+FnDef =\n+ Attr* Visibility? Abi? 'const' 'default' 'async' 'unsafe' 'fn' Name TypeParamList?\n+ ParamList RetType?\n+ WhereClause?\n+ (body:BlockExpr | ';')\n+\n+RetType =\n+  '->' TypeRef\n+\n+StructDef =\n+  Attr* Visibility? 'struct' Name TypeParamList? (\n+    WhereClause?  (RecordFieldDefList | ';')\n+  | TupleFieldDefList WhereClause? ';'\n+  )\n+\n+UnionDef =\n+  Attr* Visibility? 'union' Name TypeParamList? WhereClause?\n+  RecordFieldDefList\n+\n+RecordFieldDefList =\n+ '{' fields:RecordFieldDef* '}'\n+\n+RecordFieldDef =\n+  Attr* Visibility? Name ':' ascribed_type:TypeRef\n+\n+TupleFieldDefList =\n+  '(' fields:TupleFieldDef* ')'\n+\n+TupleFieldDef =\n+  Attr* Visibility? Name TypeRef\n+\n+FieldDefList =\n+  RecordFieldDefList\n+| TupleFieldDefList\n+\n+EnumDef =\n+  Attr* Visibility? 'enum' Name TypeParamList? WhereClause?\n+  variant_list:EnumVariantList\n+\n+EnumVariantList =\n+ '{' variants:EnumVariant* '}'\n+\n+EnumVariant =\n+  Attr* Visibility? Name FieldDefList ('=' Expr)?\n+\n+TraitDef =\n+  Attr* Visibility? 'unsafe'? 'auto'? 'trait' Name TypeParamList\n+  (':' TypeBoundList?)? WhereClause\n+  ItemList\n+\n+Module =\n+  Attr* Visibility? 'mod' Name\n+  (ItemList | ';')\n+\n+ItemList =\n+  '{'\n+    AssocItem*\n+    items:ModuleItem*\n+  '}'\n+\n+ConstDef =\n+  Attr* Visibility? 'default'? 'const' Name ':' ascribed_type:TypeRef\n+  '=' body:Expr ';'\n+\n+StaticDef =\n+  Attr* Visibility? 'static'? 'mut'? 'static' Name ':' ascribed_type:TypeRef\n+  '=' body:Expr ';'\n+\n+TypeAliasDef =\n+  Attr* Visibility? 'default'? 'type' Name TypeParamList? WhereClause? (':' TypeBoundList?)?\n+  '=' TypeRef ';'\n+\n+ImplDef =\n+ Attr* Visibility? 'const'? 'default'? 'unsafe'? 'impl' TypeParamList? '!'? 'for'\n+ WhereClause?\n+ ItemList\n+\n+ParenType =\n+  '(' TypeRef ')'\n+\n+TupleType =\n+  '(' fields:TypeRef* ')'\n+\n+NeverType =\n+  '!'\n+\n+PathType =\n+  Path\n+\n+PointerType =\n+  '*' ('const' | 'mut') TypeRef\n+\n+ArrayType =\n+  '[' TypeRef ';' Expr ']'\n+\n+SliceType =\n+  '[' TypeRef ']'\n+\n+ReferenceType =\n+  '&' 'lifetime'? 'mut'? TypeRef\n+\n+PlaceholderType =\n+   '_'\n+\n+FnPointerType =\n+   Abi 'unsafe'? 'fn' ParamList RetType?\n+\n+ForType =\n+   'for' TypeParamList TypeRef\n+\n+ImplTraitType =\n+  'impl' TypeBoundList\n+\n+DynTraitType =\n+  'dyn' TypeBoundList\n+\n+TupleExpr =\n+  Attr* '(' Expr* ')'\n+\n+ArrayExpr =\n+  Attr* '[' (Expr* | Expr ';' Expr) ']'\n+\n+ParenExpr =\n+  Attr* '(' Expr ')'\n+\n+PathExpr =\n+  Path\n+\n+LambdaExpr =\n+  Attr* 'static'? 'async'? 'move'?  ParamList RetType?\n+  body:Expr\n+\n+IfExpr =\n+  Attr* 'if' Condition\n+\n+Condition =\n+  'let' Pat '=' Expr\n+| Expr\n+\n+EffectExpr =\n+  Attr* Label? ('try' | 'unsafe' | 'async') BlockExpr\n+\n+LoopExpr =\n+  Attr* Label? 'loop'\n+  loop_body:BlockExpr?\n+\n+ForExpr =\n+  Attr* Label? 'for' Pat 'in' iterable:Expr\n+  loop_body:BlockExpr?\n+\n+WhileExpr =\n+  Attr* Label? 'while' Condition\n+  loop_body:BlockExpr?\n+\n+ContinueExpr =\n+  Attr* 'continue' 'lifetime'?\n+\n+BreakExpr =\n+  Attr* 'break' 'lifetime'? Expr?\n+\n+Label =\n+  'lifetime'\n+\n+BlockExpr =\n+  Attr* Label\n+  '{'\n+    items:ModuleItem*\n+    statements:Stmt*\n+    Expr?\n+  '}'\n+\n+ReturnExpr =\n+  Attr* 'return' Expr\n+\n+CallExpr =\n+  Attr* Expr ArgList\n+\n+MethodCallExpr =\n+  Attr* Expr '.' NameRef TypeArgList? ArgList\n+\n+ArgList =\n+  '(' args:Expr* ')'\n+\n+FieldExpr =\n+  Attr* Expr '.' NameRef\n+\n+IndexExpr =\n+  Attr* '[' ']'\n+\n+AwaitExpr =\n+  Attr* Expr '.' 'await'\n+\n+TryExpr =\n+  Attr* Expr '?'\n+\n+CastExpr =\n+  Attr* Expr 'as' TypeRef\n+\n+RefExpr =\n+  Attr* '&' ('raw' | 'mut' | 'const') Expr\n+\n+PrefixExpr =\n+  Attr* Expr\n+\n+BoxExpr =\n+  Attr* 'box' Expr\n+\n+RangeExpr =\n+  Attr*\n+\n+BinExpr =\n+  Attr*\n+\n+Literal =\n+  'int_number'\n+\n+MatchExpr =\n+  Attr* 'match' Expr MatchArmList\n+\n+MatchArmList =\n+  '{' arms:MatchArm* '}'\n+\n+MatchArm =\n+  Attr* Pat guard:MatchGuard? '=>' Expr\n+\n+MatchGuard =\n+  'if' Expr\n+\n+RecordLit =\n+ Path RecordFieldList\n+\n+RecordFieldList =\n+  '{'\n+    fields:RecordField*\n+    ('..' spread:Expr)?\n+  '}'\n+\n+RecordField =\n+  Attr* NameRef (':' Expr)?\n+\n+OrPat =\n+  Pat*\n+\n+ParenPat =\n+  '(' Pat ')'\n+\n+RefPat =\n+  '&' 'mut'? Pat\n+\n+BoxPat =\n+  'box' Path\n+\n+BindPat =\n+  Attr* 'ref'? 'mut'? Name ('@' Pat)?\n+\n+PlaceholderPat =\n+  '_'\n+\n+DotDotPat =\n+  '..'\n+\n+PathPat =\n+  Path\n+\n+SlicePat =\n+  '[' args:Pat* ']'\n+\n+RangePat =\n+  '..' | '..='\n+\n+LiteralPat =\n+  Literal\n+\n+MacroPat =\n+  MacroCall\n+\n+RecordPat =\n+  Path RecordFieldPatList\n+\n+RecordFieldPatList =\n+  '{'\n+    record_field_pats:RecordFieldPat*\n+    BindPat*\n+    '..'?\n+  '}'\n+\n+RecordFieldPat =\n+  Attr* NameRef ':' Pat\n+\n+TupleStructPat =\n+   Path '(' args:Pat* ')'\n+\n+TuplePat =\n+   '(' args:Pat* ')'\n+\n+Visibility =\n+  'pub' ('(' 'super' | 'self' | 'crate' | 'in' Path ')')?\n+\n+Name =\n+  'ident'\n+\n+NameRef =\n+  'ident' | 'int_number'\n+\n+MacroCall =\n+  Attr* Path '!' Name? TokenTree ';'?\n+\n+MacroDef =\n+  Name TokenTree\n+\n+TokenTree =\n+  '(' ')' | '{' '}' | '[' ']'\n+\n+MacroItems =\n+  items:ModuleItem*\n+\n+MacroStmts =\n+  statements:Stmt*\n+  Expr?\n+\n+Attr =\n+  '#' '!'? '[' Path ('=' input:AttrInput)? ']'\n+\n+TypeParamList =\n+  '<'\n+    TypeParam*\n+    LifetimeParam*\n+    ConstParam*\n+  '>'\n+\n+TypeParam =\n+  Attr* Name (':' TypeBoundList?)?\n+  ('=' default_type:TypeRef)?\n+\n+ConstParam =\n+  Attr* 'const' Name ':' ascribed_type:TypeRef\n+  ('=' default_val:Expr)?\n+\n+LifetimeParam =\n+  Attr* 'lifetime'\n+\n+TypeBound =\n+  'lifetime' | 'const'? TypeRef\n+\n+TypeBoundList =\n+   bounds:TypeBound*\n+\n+WherePred =\n+  ('for' TypeParamList)?  ('lifetime' | TypeRef) ':' TypeBoundList\n+\n+WhereClause =\n+  'where' predicates:WherePred*\n+\n+Abi =\n+  'string'\n+\n+ExprStmt =\n+  Attr* Expr ';'\n+\n+LetStmt =\n+  Attr* 'let' Pat (':' ascribed_type:TypeRef)\n+  '=' initializer:Expr ';'\n+\n+ParamList =\n+  '(' SelfParam Param* ')'\n+\n+SelfParam =\n+  Attr* ('&' 'lifetime'?)? 'mut'? 'self' (':' ascribed_type:TypeRef)\n+\n+Param =\n+  Attr* Pat (':' ascribed_type:TypeRef)\n+| '...'\n+\n+UseItem =\n+  Attr* Visibility? 'use' UseTree ';'\n+\n+UseTree =\n+  Path ('::' ('*' | UseTreeList))  Alias?\n+\n+UseTreeList =\n+  '{' UseTree* '}'\n+\n+Alias =\n+  'as' Name\n+\n+ExternCrateItem =\n+  Attr* Visibility? 'extern' 'crate' (NameRef | 'self') Alias? ';'\n+\n+Path =\n+  (qualifier:Path '::')? segment:PathSegment\n+\n+PathSegment =\n+  '::' | 'crate' | 'self' | 'super'\n+| '<' NameRef TypeArgList ParamList RetType PathType '>'\n+\n+TypeArgList =\n+  '::'? '<'\n+    TypeArg*\n+    LifetimeArg*\n+    AssocTypeArg*\n+    ConstArg*\n+  '>'\n+\n+TypeArg =\n+  TypeRef\n+\n+AssocTypeArg =\n+  NameRef (':' TypeBoundList | '=' TypeRef)\n+\n+LifetimeArg =\n+  'lifetime'\n+\n+ConstArg =\n+  Literal | BlockExpr BlockExpr\n+\n+ExternBlock =\n+  Attr* Abi ExternItemList\n+\n+ExternItemList =\n+  '{' extern_items:ExternItem* '}'\n+\n+MetaItem =\n+  Path '=' AttrInput nested_meta_items:MetaItem*\n+\n+NominalDef =\n+  StructDef\n+| EnumDef\n+| UnionDef\n+\n+TypeRef =\n+  ParenType\n+| TupleType\n+| NeverType\n+| PathType\n+| PointerType\n+| ArrayType\n+| SliceType\n+| ReferenceType\n+| PlaceholderType\n+| FnPointerType\n+| ForType\n+| ImplTraitType\n+| DynTraitType\n+\n+AssocItem =\n+  FnDef\n+| TypeAliasDef\n+| ConstDef\n+\n+ExternItem =\n+  FnDef | StaticDef\n+\n+ModuleItem =\n+  StructDef\n+| UnionDef\n+| EnumDef\n+| FnDef\n+| TraitDef\n+| TypeAliasDef\n+| ImplDef\n+| UseItem\n+| ExternCrateItem\n+| ConstDef\n+| StaticDef\n+| Module\n+| MacroCall\n+| ExternBlock\n+\n+AttrInput =\n+  Literal\n+| TokenTree\n+\n+Stmt =\n+  LetStmt\n+| ExprStmt\n+\n+Pat =\n+  OrPat\n+| ParenPat\n+| RefPat\n+| BoxPat\n+| BindPat\n+| PlaceholderPat\n+| DotDotPat\n+| PathPat\n+| RecordPat\n+| TupleStructPat\n+| TuplePat\n+| SlicePat\n+| RangePat\n+| LiteralPat\n+| MacroPat\n+\n+Expr =\n+  TupleExpr\n+| ArrayExpr\n+| ParenExpr\n+| PathExpr\n+| LambdaExpr\n+| IfExpr\n+| LoopExpr\n+| ForExpr\n+| WhileExpr\n+| ContinueExpr\n+| BreakExpr\n+| Label\n+| BlockExpr\n+| ReturnExpr\n+| MatchExpr\n+| RecordLit\n+| CallExpr\n+| IndexExpr\n+| MethodCallExpr\n+| FieldExpr\n+| AwaitExpr\n+| TryExpr\n+| EffectExpr\n+| CastExpr\n+| RefExpr\n+| PrefixExpr\n+| RangeExpr\n+| BinExpr\n+| Literal\n+| MacroCall\n+| BoxExpr"}]}