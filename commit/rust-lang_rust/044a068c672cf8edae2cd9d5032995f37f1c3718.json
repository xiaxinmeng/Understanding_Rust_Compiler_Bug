{"sha": "044a068c672cf8edae2cd9d5032995f37f1c3718", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NGEwNjhjNjcyY2Y4ZWRhZTJjZDlkNTAzMjk5NWYzN2YxYzM3MTg=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-30T21:07:07Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T22:02:54Z"}, "message": "Improve code readability and comments.", "tree": {"sha": "146b22ad9774ea7457b186f51af971aec46ef65c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/146b22ad9774ea7457b186f51af971aec46ef65c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/044a068c672cf8edae2cd9d5032995f37f1c3718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/044a068c672cf8edae2cd9d5032995f37f1c3718", "html_url": "https://github.com/rust-lang/rust/commit/044a068c672cf8edae2cd9d5032995f37f1c3718", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/044a068c672cf8edae2cd9d5032995f37f1c3718/comments", "author": null, "committer": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0de439ac8366afce491250a64b78702fa5d7dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0de439ac8366afce491250a64b78702fa5d7dd6", "html_url": "https://github.com/rust-lang/rust/commit/d0de439ac8366afce491250a64b78702fa5d7dd6"}], "stats": {"total": 91, "additions": 47, "deletions": 44}, "files": [{"sha": "7a6c562e7ca07b76a9a0a6d362a14917afd62f40", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -210,11 +210,11 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                 SchedulingAction::ExecuteStep => {\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n                 }\n-                SchedulingAction::ExecuteCallback => {\n+                SchedulingAction::ExecuteTimeoutCallback => {\n                     assert!(ecx.machine.communicate,\n                         \"scheduler callbacks require disabled isolation, but the code \\\n                         that created the callback did not check it\");\n-                    ecx.run_scheduler_callback()?;\n+                    ecx.run_timeout_callback()?;\n                 }\n                 SchedulingAction::ExecuteDtors => {\n                     // This will either enable the thread again (so we go back"}, {"sha": "f31efe18e1c17a8dd0d0cfb6caee1c4f44f4628d", "filename": "src/shims/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -128,7 +128,7 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n         mutex_set_id(ecx, mutex_op, id.to_u32_scalar())?;\n         Ok(id)\n     } else {\n-        Ok(id.into())\n+        Ok(MutexId::from_u32(id))\n     }\n }\n \n@@ -168,7 +168,7 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n         rwlock_set_id(ecx, rwlock_op, id.to_u32_scalar())?;\n         Ok(id)\n     } else {\n-        Ok(id.into())\n+        Ok(RwLockId::from_u32(id))\n     }\n }\n \n@@ -232,7 +232,7 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n         cond_set_id(ecx, cond_op, id.to_u32_scalar())?;\n         Ok(id)\n     } else {\n-        Ok(id.into())\n+        Ok(CondvarId::from_u32(id))\n     }\n }\n \n@@ -656,7 +656,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let id = cond_get_or_create_id(this, cond_op)?;\n         if let Some((thread, mutex)) = this.condvar_signal(id) {\n             reacquire_cond_mutex(this, thread, mutex)?;\n-            this.unregister_callback_if_exists(thread)?;\n+            this.unregister_timeout_callback_if_exists(thread)?;\n         }\n \n         Ok(0)\n@@ -668,7 +668,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         while let Some((thread, mutex)) = this.condvar_signal(id) {\n             reacquire_cond_mutex(this, thread, mutex)?;\n-            this.unregister_callback_if_exists(thread)?;\n+            this.unregister_timeout_callback_if_exists(thread)?;\n         }\n \n         Ok(0)\n@@ -739,7 +739,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         // Register the timeout callback.\n-        this.register_callback(\n+        this.register_timeout_callback(\n             active_thread,\n             timeout_time,\n             Box::new(move |ecx| {"}, {"sha": "88b5d6c060ddcace5f828363a439df05d2a14804", "filename": "src/sync.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -9,9 +9,18 @@ use crate::*;\n \n macro_rules! declare_id {\n     ($name: ident) => {\n+        /// 0 is used to indicate that the id was not yet assigned and,\n+        /// therefore, is not a valid identifier.\n         #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n         pub struct $name(NonZeroU32);\n \n+        impl $name {\n+            // Panics if `id == 0`.\n+            pub fn from_u32(id: u32) -> Self {\n+                Self(NonZeroU32::new(id).unwrap())\n+            }\n+        }\n+\n         impl Idx for $name {\n             fn new(idx: usize) -> Self {\n                 $name(NonZeroU32::new(u32::try_from(idx).unwrap() + 1).unwrap())\n@@ -21,12 +30,6 @@ macro_rules! declare_id {\n             }\n         }\n \n-        impl From<u32> for $name {\n-            fn from(id: u32) -> Self {\n-                Self(NonZeroU32::new(id).unwrap())\n-            }\n-        }\n-\n         impl $name {\n             pub fn to_u32_scalar<'tcx>(&self) -> Scalar<Tag> {\n                 Scalar::from_u32(self.0.get())"}, {"sha": "f67de48b710dbd558a79615ed352aecfcc7d5657", "filename": "src/thread.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -24,15 +24,17 @@ use crate::*;\n pub enum SchedulingAction {\n     /// Execute step on the active thread.\n     ExecuteStep,\n-    /// Execute a scheduler's callback.\n-    ExecuteCallback,\n+    /// Execute a timeout callback.\n+    ExecuteTimeoutCallback,\n     /// Execute destructors of the active thread.\n     ExecuteDtors,\n     /// Stop the program.\n     Stop,\n }\n \n-type EventCallback<'mir, 'tcx> =\n+/// Timeout timeout_callbacks can be created by synchronization primitives to tell the\n+/// scheduler that they should be called once some period of time passes.\n+type TimeoutCallback<'mir, 'tcx> =\n     Box<dyn FnOnce(&mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>) -> InterpResult<'tcx> + 'tcx>;\n \n /// A thread identifier.\n@@ -161,14 +163,14 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n /// conditional variable with a timeout creates a callback that is called after\n /// the specified time and unblocks the thread. If another thread signals on the\n /// conditional variable, the signal handler deletes the callback.\n-struct CallBackInfo<'mir, 'tcx> {\n+struct TimeoutCallbackInfo<'mir, 'tcx> {\n     /// The callback should be called no earlier than this time.\n     call_time: Instant,\n     /// The called function.\n-    callback: EventCallback<'mir, 'tcx>,\n+    callback: TimeoutCallback<'mir, 'tcx>,\n }\n \n-impl<'mir, 'tcx> std::fmt::Debug for CallBackInfo<'mir, 'tcx> {\n+impl<'mir, 'tcx> std::fmt::Debug for TimeoutCallbackInfo<'mir, 'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         write!(f, \"CallBack({:?})\", self.call_time)\n     }\n@@ -183,17 +185,16 @@ pub struct ThreadManager<'mir, 'tcx> {\n     ///\n     /// Note that this vector also contains terminated threads.\n     threads: IndexVec<ThreadId, Thread<'mir, 'tcx>>,\n-    /// FIXME: make private.\n+    /// This field is pub(crate) because the synchronization primitives\n+    /// (`crate::sync`) need a way to access it.\n     pub(crate) sync: SynchronizationState,\n-    /// A counter used to generate unique identifiers for blocksets.\n-    blockset_counter: u32,\n     /// A mapping from a thread-local static to an allocation id of a thread\n     /// specific allocation.\n     thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), AllocId>>,\n     /// A flag that indicates that we should change the active thread.\n     yield_active_thread: bool,\n     /// Callbacks that are called once the specified time passes.\n-    callbacks: FxHashMap<ThreadId, CallBackInfo<'mir, 'tcx>>,\n+    timeout_callbacks: FxHashMap<ThreadId, TimeoutCallbackInfo<'mir, 'tcx>>,\n }\n \n impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n@@ -208,10 +209,9 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n             active_thread: ThreadId::new(0),\n             threads: threads,\n             sync: SynchronizationState::default(),\n-            blockset_counter: 0,\n             thread_local_alloc_ids: Default::default(),\n             yield_active_thread: false,\n-            callbacks: FxHashMap::default(),\n+            timeout_callbacks: FxHashMap::default(),\n         }\n     }\n }\n@@ -359,28 +359,28 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Register the given `callback` to be called once the `call_time` passes.\n-    fn register_callback(\n+    fn register_timeout_callback(\n         &mut self,\n         thread: ThreadId,\n         call_time: Instant,\n-        callback: EventCallback<'mir, 'tcx>,\n+        callback: TimeoutCallback<'mir, 'tcx>,\n     ) {\n-        self.callbacks\n-            .insert(thread, CallBackInfo { call_time: call_time, callback: callback })\n+        self.timeout_callbacks\n+            .insert(thread, TimeoutCallbackInfo { call_time: call_time, callback: callback })\n             .unwrap_none();\n     }\n \n     /// Unregister the callback for the `thread`.\n-    fn unregister_callback_if_exists(&mut self, thread: ThreadId) {\n-        self.callbacks.remove(&thread);\n+    fn unregister_timeout_callback_if_exists(&mut self, thread: ThreadId) {\n+        self.timeout_callbacks.remove(&thread);\n     }\n \n     /// Get a callback that is ready to be called.\n-    fn get_callback(&mut self) -> Option<(ThreadId, EventCallback<'mir, 'tcx>)> {\n+    fn get_callback(&mut self) -> Option<(ThreadId, TimeoutCallback<'mir, 'tcx>)> {\n         let current_time = Instant::now();\n         // We use a for loop here to make the scheduler more deterministic.\n         for thread in self.threads.indices() {\n-            match self.callbacks.entry(thread) {\n+            match self.timeout_callbacks.entry(thread) {\n                 Entry::Occupied(entry) =>\n                     if current_time >= entry.get().call_time {\n                         return Some((thread, entry.remove().callback));\n@@ -447,17 +447,17 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         if self.threads.iter().all(|thread| thread.state == ThreadState::Terminated) {\n             unreachable!();\n         } else if let Some(next_call_time) =\n-            self.callbacks.values().min_by_key(|info| info.call_time)\n+            self.timeout_callbacks.values().min_by_key(|info| info.call_time)\n         {\n             // All threads are currently blocked, but we have unexecuted\n-            // callbacks, which may unblock some of the threads. Hence,\n+            // timeout_callbacks, which may unblock some of the threads. Hence,\n             // sleep until the first callback.\n             if let Some(sleep_time) =\n                 next_call_time.call_time.checked_duration_since(Instant::now())\n             {\n                 std::thread::sleep(sleep_time);\n             }\n-            Ok(SchedulingAction::ExecuteCallback)\n+            Ok(SchedulingAction::ExecuteTimeoutCallback)\n         } else {\n             throw_machine_stop!(TerminationInfo::Deadlock);\n         }\n@@ -647,27 +647,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn register_callback(\n+    fn register_timeout_callback(\n         &mut self,\n         thread: ThreadId,\n         call_time: Instant,\n-        callback: EventCallback<'mir, 'tcx>,\n+        callback: TimeoutCallback<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.register_callback(thread, call_time, callback);\n+        this.machine.threads.register_timeout_callback(thread, call_time, callback);\n         Ok(())\n     }\n \n     #[inline]\n-    fn unregister_callback_if_exists(&mut self, thread: ThreadId) -> InterpResult<'tcx> {\n+    fn unregister_timeout_callback_if_exists(&mut self, thread: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.unregister_callback_if_exists(thread);\n+        this.machine.threads.unregister_timeout_callback_if_exists(thread);\n         Ok(())\n     }\n \n-    /// Execute the callback on the callback's thread.\n+    /// Execute a timeout callback on the callback's thread.\n     #[inline]\n-    fn run_scheduler_callback(&mut self) -> InterpResult<'tcx> {\n+    fn run_timeout_callback(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (thread, callback) = this.machine.threads.get_callback().expect(\"no callback found\");\n         let old_thread = this.set_active_thread(thread)?;"}]}