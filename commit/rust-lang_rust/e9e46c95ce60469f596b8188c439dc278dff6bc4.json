{"sha": "e9e46c95ce60469f596b8188c439dc278dff6bc4", "node_id": "C_kwDOAAsO6NoAKGU5ZTQ2Yzk1Y2U2MDQ2OWY1OTZiODE4OGM0MzlkYzI3OGRmZjZiYzQ", "commit": {"author": {"name": "Christopher Durham", "email": "cad97@cad97.com", "date": "2022-08-17T11:07:33Z"}, "committer": {"name": "Christopher Durham", "email": "cad97@cad97.com", "date": "2022-08-17T11:07:33Z"}, "message": "Don't treat stashed warnings as errors", "tree": {"sha": "73252c0bd186ac8f240f1ce9480c7fb0db5debad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73252c0bd186ac8f240f1ce9480c7fb0db5debad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9e46c95ce60469f596b8188c439dc278dff6bc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e46c95ce60469f596b8188c439dc278dff6bc4", "html_url": "https://github.com/rust-lang/rust/commit/e9e46c95ce60469f596b8188c439dc278dff6bc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9e46c95ce60469f596b8188c439dc278dff6bc4/comments", "author": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "url": "https://api.github.com/repos/rust-lang/rust/commits/86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "html_url": "https://github.com/rust-lang/rust/commit/86c6ebee8fa0a5ad1e18e375113b06bd2849b634"}], "stats": {"total": 74, "additions": 62, "deletions": 12}, "files": [{"sha": "fe2afdf5a20b86b11ade0a49409ce82cee17661c", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e9e46c95ce60469f596b8188c439dc278dff6bc4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e46c95ce60469f596b8188c439dc278dff6bc4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=e9e46c95ce60469f596b8188c439dc278dff6bc4", "patch": "@@ -625,19 +625,13 @@ impl Handler {\n     /// Stash a given diagnostic with the given `Span` and `StashKey` as the key for later stealing.\n     pub fn stash_diagnostic(&self, span: Span, key: StashKey, diag: Diagnostic) {\n         let mut inner = self.inner.borrow_mut();\n-        // FIXME(Centril, #69537): Consider reintroducing panic on overwriting a stashed diagnostic\n-        // if/when we have a more robust macro-friendly replacement for `(span, key)` as a key.\n-        // See the PR for a discussion.\n-        inner.stashed_diagnostics.insert((span, key), diag);\n+        inner.stash((span, key), diag);\n     }\n \n     /// Steal a previously stashed diagnostic with the given `Span` and `StashKey` as the key.\n     pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_, ()>> {\n-        self.inner\n-            .borrow_mut()\n-            .stashed_diagnostics\n-            .remove(&(span, key))\n-            .map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n+        let mut inner = self.inner.borrow_mut();\n+        inner.steal((span, key)).map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n     }\n \n     /// Emit all stashed diagnostics.\n@@ -1105,13 +1099,31 @@ impl HandlerInner {\n \n     /// Emit all stashed diagnostics.\n     fn emit_stashed_diagnostics(&mut self) -> Option<ErrorGuaranteed> {\n+        let has_errors = self.has_errors();\n         let diags = self.stashed_diagnostics.drain(..).map(|x| x.1).collect::<Vec<_>>();\n         let mut reported = None;\n         for mut diag in diags {\n+            // Decrement the count tracking the stash; emitting will increment it.\n             if diag.is_error() {\n-                reported = Some(ErrorGuaranteed(()));\n+                if matches!(diag.level, Level::Error { lint: true }) {\n+                    self.lint_err_count -= 1;\n+                } else {\n+                    self.err_count -= 1;\n+                }\n+            } else {\n+                if diag.is_force_warn() {\n+                    self.warn_count -= 1;\n+                } else {\n+                    // Unless they're forced, don't flush stashed warnings when\n+                    // there are errors, to avoid causing warning overload. The\n+                    // stash would've been stolen already if it were important.\n+                    if has_errors {\n+                        continue;\n+                    }\n+                }\n             }\n-            self.emit_diagnostic(&mut diag);\n+            let reported_this = self.emit_diagnostic(&mut diag);\n+            reported = reported.or(reported_this);\n         }\n         reported\n     }\n@@ -1301,9 +1313,47 @@ impl HandlerInner {\n         }\n     }\n \n+    fn stash(&mut self, key: (Span, StashKey), diagnostic: Diagnostic) {\n+        // Track the diagnostic for counts, but don't panic-if-treat-err-as-bug\n+        // yet; that happens when we actually emit the diagnostic.\n+        if diagnostic.is_error() {\n+            if matches!(diagnostic.level, Level::Error { lint: true }) {\n+                self.lint_err_count += 1;\n+            } else {\n+                self.err_count += 1;\n+            }\n+        } else {\n+            // Warnings are only automatically flushed if they're forced.\n+            if diagnostic.is_force_warn() {\n+                self.warn_count += 1;\n+            }\n+        }\n+\n+        // FIXME(Centril, #69537): Consider reintroducing panic on overwriting a stashed diagnostic\n+        // if/when we have a more robust macro-friendly replacement for `(span, key)` as a key.\n+        // See the PR for a discussion.\n+        self.stashed_diagnostics.insert(key, diagnostic);\n+    }\n+\n+    fn steal(&mut self, key: (Span, StashKey)) -> Option<Diagnostic> {\n+        let diagnostic = self.stashed_diagnostics.remove(&key)?;\n+        if diagnostic.is_error() {\n+            if matches!(diagnostic.level, Level::Error { lint: true }) {\n+                self.lint_err_count -= 1;\n+            } else {\n+                self.err_count -= 1;\n+            }\n+        } else {\n+            if diagnostic.is_force_warn() {\n+                self.warn_count -= 1;\n+            }\n+        }\n+        Some(diagnostic)\n+    }\n+\n     #[inline]\n     fn err_count(&self) -> usize {\n-        self.err_count + self.stashed_diagnostics.len()\n+        self.err_count\n     }\n \n     fn has_errors(&self) -> bool {"}]}