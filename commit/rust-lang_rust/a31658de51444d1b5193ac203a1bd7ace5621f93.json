{"sha": "a31658de51444d1b5193ac203a1bd7ace5621f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMTY1OGRlNTE0NDRkMWI1MTkzYWMyMDNhMWJkN2FjZTU2MjFmOTM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-24T19:15:16Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-24T19:17:44Z"}, "message": "Rollup merge of #33041 - petrochenkov:path, r=nrc,Manishearth\n\n Paths are mostly parsed without taking whitespaces into account, e.g. `std :: vec :: Vec :: new ()` parses successfully, however, there are some special cases involving keywords `super`, `self` and `Self`. For example, `self::` is considered a path start only if there are no spaces between `self` and `::`. These restrictions probably made sense when `self` and friends weren't keywords, but now they are unnecessary.\n\nThe first two commits remove this special treatment of whitespaces by removing `token::IdentStyle` entirely and therefore fix https://github.com/rust-lang/rust/issues/14109.\nThis change also affects naked `self` and `super` (which are not tightly followed by `::`, obviously) they can now be parsed as paths, however they are still not resolved correctly in imports (cc @jseyfried, see `compile-fail/use-keyword.rs`), so https://github.com/rust-lang/rust/issues/29036 is not completely fixed.\n\nThe third commit also makes `super`, `self`, `Self` and `static` keywords nominally (before this they acted as keywords for all purposes) and removes most of remaining \\\"special idents\\\".\n\nThe last commit (before tests) contains some small improvements - some qualified paths with type parameters are parsed correctly, `parse_path` is not used for parsing single identifiers, imports are sanity checked for absence of type parameters - such type parameters can be generated by syntax extensions or by macros when https://github.com/rust-lang/rust/issues/10415 is fixed (~~soon!~~already!).\n\nThis patch changes some pretty basic things in `libsyntax`, like `token::Token` and the keyword list, so it's a plugin-[breaking-change].\n\nr? @eddyb", "tree": {"sha": "59cd2579150dc1957cf3c2fc75e5ef2b9f38c523", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59cd2579150dc1957cf3c2fc75e5ef2b9f38c523"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a31658de51444d1b5193ac203a1bd7ace5621f93", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXHRvYAAoJEDu/TT4u95+YpwYQAOtzaLk9ZpukpoBYKO9c8obX\nZ/iJ9VqccKjR7ZTbFm8eYiSy2juEgAwjQ5WyowaqfSxxtTtaDt0Czakbg2EIuvYV\ni8d8dzunH5D6+6pXhN+B5IYCZT3ltssJQFvDwEqAlFoL2EK1dLbmEO0ug7ZeOfHI\n/WgPd628+2EipJUxMntPYKkdYRhMUKkEqOxN7OnBgvsd7uEmye8MoBaJJoUZf7UB\nfyafNsK/pp/kCCeZJKY8u5Yq9GjY2TPNKYH3eMnJolclTycOb/XQ/g+c5/WkPsDh\ntUe/lFjiCCk4u2PkwFKWPP7oTCITDJ0Hx7qaZACdpQVHHABKMBiPcNGn2dBtCw5K\nEjOjIJf08Ms3UKQRxx36lddSkqKJAgR/742DFP3HcAYh/KXfFsdviQ8SYJAUcCd8\n8E9x/0bTr14COHdCkaP/vb2zQ2t/J9NoYYuHMxsV/yG25BKGqydxSA3+tt7aEKqn\nFyXGfxdxRBj2UUUcL1QQSYrrwJs8zIDctW+5V5yWY4zSmcb5s8ZiYw/Pne7U+3KK\nHQoPnAFI7jfJ+j/L8VwDfBIV6GVkfP+F7nczIVhJnbTVUjUOg06iVgUq2ZTVpteX\nLgKMfBydqabOsxDObWxOJz7FmG7BfLOCDQxM8QhjIdUo0qWN9W99DSa+Z/3GfLIp\n/jcfM/X9z5SMNGqdXSSt\n=Yqz3\n-----END PGP SIGNATURE-----", "payload": "tree 59cd2579150dc1957cf3c2fc75e5ef2b9f38c523\nparent 17ba11d105937ec980928f292d96f17c1a41fe02\nparent 4bd44be369c883f1fb2b0645f4de4827066cec57\nauthor Manish Goregaokar <manishsmail@gmail.com> 1461525316 +0530\ncommitter Manish Goregaokar <manishsmail@gmail.com> 1461525464 +0530\n\nRollup merge of #33041 - petrochenkov:path, r=nrc,Manishearth\n\n Paths are mostly parsed without taking whitespaces into account, e.g. `std :: vec :: Vec :: new ()` parses successfully, however, there are some special cases involving keywords `super`, `self` and `Self`. For example, `self::` is considered a path start only if there are no spaces between `self` and `::`. These restrictions probably made sense when `self` and friends weren't keywords, but now they are unnecessary.\n\nThe first two commits remove this special treatment of whitespaces by removing `token::IdentStyle` entirely and therefore fix https://github.com/rust-lang/rust/issues/14109.\nThis change also affects naked `self` and `super` (which are not tightly followed by `::`, obviously) they can now be parsed as paths, however they are still not resolved correctly in imports (cc @jseyfried, see `compile-fail/use-keyword.rs`), so https://github.com/rust-lang/rust/issues/29036 is not completely fixed.\n\nThe third commit also makes `super`, `self`, `Self` and `static` keywords nominally (before this they acted as keywords for all purposes) and removes most of remaining \\\"special idents\\\".\n\nThe last commit (before tests) contains some small improvements - some qualified paths with type parameters are parsed correctly, `parse_path` is not used for parsing single identifiers, imports are sanity checked for absence of type parameters - such type parameters can be generated by syntax extensions or by macros when https://github.com/rust-lang/rust/issues/10415 is fixed (~~soon!~~already!).\n\nThis patch changes some pretty basic things in `libsyntax`, like `token::Token` and the keyword list, so it's a plugin-[breaking-change].\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a31658de51444d1b5193ac203a1bd7ace5621f93", "html_url": "https://github.com/rust-lang/rust/commit/a31658de51444d1b5193ac203a1bd7ace5621f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a31658de51444d1b5193ac203a1bd7ace5621f93/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17ba11d105937ec980928f292d96f17c1a41fe02", "url": "https://api.github.com/repos/rust-lang/rust/commits/17ba11d105937ec980928f292d96f17c1a41fe02", "html_url": "https://github.com/rust-lang/rust/commit/17ba11d105937ec980928f292d96f17c1a41fe02"}, {"sha": "4bd44be369c883f1fb2b0645f4de4827066cec57", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd44be369c883f1fb2b0645f4de4827066cec57", "html_url": "https://github.com/rust-lang/rust/commit/4bd44be369c883f1fb2b0645f4de4827066cec57"}], "stats": {"total": 1656, "additions": 798, "deletions": 858}, "files": [{"sha": "e53d6c718c155c4f90ed2d5539145e473781ae80", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -34,15 +34,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py %s'\n \n fn main() {\n-    let %s = \"foo\"; //~ error: ident\n+    let %s = \"foo\"; //~ error: expected pattern, found keyword `%s`\n }\n \"\"\"\n \n test_dir = os.path.abspath(\n-    os.path.join(os.path.dirname(__file__), '../test/compile-fail')\n+    os.path.join(os.path.dirname(__file__), '../test/parse-fail')\n )\n \n for kw in sys.argv[1:]:\n@@ -53,7 +55,7 @@\n         os.chmod(test_file, stat.S_IWUSR)\n \n     with open(test_file, 'wt') as f:\n-        f.write(template % (datetime.datetime.now().year, kw, kw))\n+        f.write(template % (datetime.datetime.now().year, kw, kw, kw))\n \n     # mark file read-only\n     os.chmod(test_file, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)"}, {"sha": "fa391538b9c601ae84cd132d5c3f8460e4558998", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -18,7 +18,7 @@ use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n use syntax::ptr::P;\n-use syntax::parse::token;\n+use syntax::parse::token::keywords;\n use syntax::util::move_map::MoveMap;\n \n pub trait Folder : Sized {\n@@ -867,7 +867,7 @@ pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n     let config = folder.fold_meta_items(config);\n \n     let crate_mod = folder.fold_item(hir::Item {\n-        name: token::special_idents::invalid.name,\n+        name: keywords::Invalid.name(),\n         attrs: attrs,\n         id: DUMMY_NODE_ID,\n         vis: hir::Public,"}, {"sha": "db179c1cc1bf6b232cfee11a788a915408f153e8", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -14,9 +14,8 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n use syntax::errors;\n-use syntax::parse::token::{self, BinOpToken};\n+use syntax::parse::token::{self, keywords, BinOpToken};\n use syntax::parse::lexer::comments;\n-use syntax::parse;\n use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n@@ -2209,9 +2208,8 @@ impl<'a> State<'a> {\n             hir::TyInfer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n                 match input.pat.node {\n-                    PatKind::Ident(_, ref path1, _) if\n-                        path1.node.name ==\n-                            parse::token::special_idents::invalid.name => {\n+                    PatKind::Ident(_, ref path1, _)\n+                            if path1.node.name == keywords::Invalid.name() => {\n                         // Do nothing.\n                     }\n                     _ => {"}, {"sha": "b9b182fd4d0e3e4e0a8fbd1478b35f05173a1389", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -125,7 +125,7 @@ use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n use syntax::codemap::{BytePos, original_sp, Span};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n use syntax::ptr::P;\n \n use hir::Expr;\n@@ -1578,7 +1578,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;\n-                if name != special_idents::self_.name {\n+                if name != keywords::SelfValue.name() {\n                     if !self.warn_about_unused(sp, p_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(p_id, sp, var, true);"}, {"sha": "23eb5a56c8439e4f25469f09bb1c1137d1216d63", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -29,7 +29,7 @@ use std::fmt;\n use std::mem::replace;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n use util::nodemap::NodeMap;\n \n use hir;\n@@ -245,7 +245,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-        if lifetime_ref.name == special_idents::static_lifetime.name {\n+        if lifetime_ref.name == keywords::StaticLifetime.name() {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n@@ -672,9 +672,8 @@ impl<'a> LifetimeContext<'a> {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n-            let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes {\n-                if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n+                if lifetime.lifetime.name == keywords::StaticLifetime.name() {\n                     span_err!(self.sess, lifetime.lifetime.span, E0262,\n                         \"invalid lifetime parameter name: `{}`\", lifetime.lifetime.name);\n                 }"}, {"sha": "9ec05a9b2927caa098e20859914f8bcb9e5cee91", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -200,7 +200,7 @@ pub struct ArgDecl<'tcx> {\n     /// and has to be collected from multiple actual arguments.\n     pub spread: bool,\n \n-    /// Either special_idents::invalid or the name of a single-binding\n+    /// Either keywords::Invalid or the name of a single-binding\n     /// pattern associated with this argument. Useful for debuginfo.\n     pub debug_name: Name\n }"}, {"sha": "5bde6df5123d69545303f4c2205be66332705f51", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -44,7 +44,7 @@ use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::{self, special_idents};\n+use syntax::parse::token::{self, keywords};\n \n use hir;\n \n@@ -1069,7 +1069,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn mk_self_type(&self) -> Ty<'tcx> {\n-        self.mk_param(subst::SelfSpace, 0, special_idents::type_self.name)\n+        self.mk_param(subst::SelfSpace, 0, keywords::SelfType.name())\n     }\n \n     pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {"}, {"sha": "709ec051ddcd6e2abed8270dae6830a280ae1d35", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -24,7 +24,7 @@ use std::ops;\n use std::mem;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n \n use serialize::{Decodable, Decoder};\n \n@@ -533,7 +533,7 @@ impl ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(subst::SelfSpace, 0, special_idents::type_self.name)\n+        ParamTy::new(subst::SelfSpace, 0, keywords::SelfType.name())\n     }\n \n     pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {"}, {"sha": "b088425d58a2a12fb4a7c0a96c1d434fc08c3936", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -18,7 +18,7 @@ use rustc::hir::pat_util::pat_is_binding;\n use std::ops::{Index, IndexMut};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n+use syntax::parse::token::keywords;\n \n pub struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n@@ -238,7 +238,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                 ty::UpvarCapture::ByRef(..) => true\n             });\n             let mut decl = UpvarDecl {\n-                debug_name: token::special_idents::invalid.name,\n+                debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref\n             };\n             if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(fv.def.var_id()) {\n@@ -296,7 +296,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n                                    argument_extent, &lvalue, ty);\n \n-                let mut name = token::special_idents::invalid.name;\n+                let mut name = keywords::Invalid.name();\n                 if let Some(pat) = pattern {\n                     if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n                         if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {"}, {"sha": "ed473da19176b3c1378eff1301c705b7f5335ad4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -112,15 +112,14 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             !segment.parameters.bindings().is_empty()\n         });\n         if found_param {\n-            self.session.span_err(path.span,\n-                                  \"type or lifetime parameter is found in import path\");\n+            self.session.span_err(path.span, \"type or lifetime parameters in import path\");\n         }\n \n         // Checking for special identifiers in path\n         // prevent `self` or `super` at beginning of global path\n         if path.global && path.segments.len() > 0 {\n             let first = path.segments[0].identifier.name;\n-            if first == keywords::Super.to_name() || first == keywords::SelfValue.to_name() {\n+            if first == keywords::Super.name() || first == keywords::SelfValue.name() {\n                 self.session.add_lint(\n                     lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH, id, path.span,\n                     format!(\"expected identifier, found keyword `{}`\", first)"}, {"sha": "293b4de71fac403cb809136d93aaddd00b082149", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -62,7 +62,7 @@ use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::parse::token::{self, special_names, special_idents};\n+use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc::hir::intravisit::{self, FnKind, Visitor};\n@@ -1954,8 +1954,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        let name = special_names::type_self;\n-        self_type_rib.bindings.insert(name, self_def);\n+        self_type_rib.bindings.insert(keywords::SelfType.name(), self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n         if !self.resolved {\n@@ -2195,11 +2194,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             \"type name\"\n                         };\n \n-                        let self_type_name = special_idents::type_self.name;\n                         let is_invalid_self_type_name = path.segments.len() > 0 &&\n                                                         maybe_qself.is_none() &&\n                                                         path.segments[0].identifier.name ==\n-                                                        self_type_name;\n+                                                        keywords::SelfType.name();\n                         if is_invalid_self_type_name {\n                             resolve_error(self,\n                                           ty.span,\n@@ -2643,7 +2641,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                           namespace: Namespace,\n                           record_used: bool)\n                           -> Option<LocalDef> {\n-        if identifier.name == special_idents::invalid.name {\n+        if identifier.unhygienic_name == keywords::Invalid.name() {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n@@ -3074,7 +3072,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope && special_names::self_.as_str() == &path_name[..] {\n+                            if method_scope &&\n+                                    &path_name[..] == keywords::SelfValue.name().as_str() {\n                                 resolve_error(self,\n                                               expr.span,\n                                               ResolutionError::SelfNotAvailableInStaticMethod);\n@@ -3612,7 +3611,7 @@ fn module_to_string(module: Module) -> String {\n             }\n             BlockParentLink(ref module, _) => {\n                 // danger, shouldn't be ident?\n-                names.push(special_idents::opaque.name);\n+                names.push(token::intern(\"<opaque>\"));\n                 collect_mod(names, module);\n             }\n         }"}, {"sha": "4ba66c18e6eba26cab05ba88d61c1ec2544786f7", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1011,7 +1011,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                 span: sub_span.expect(\"No span found for use\"),\n                                 id: item.id,\n                                 mod_id: mod_id,\n-                                name: ident.name.to_string(),\n+                                name: ident.to_string(),\n                                 scope: self.cur_scope\n                             }.normalize(&self.tcx));\n                         }\n@@ -1075,7 +1075,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 if !self.span.filter_generated(alias_span, item.span) {\n                     self.dumper.extern_crate(item.span, ExternCrateData {\n                         id: item.id,\n-                        name: item.ident.name.to_string(),\n+                        name: item.ident.to_string(),\n                         crate_num: cnum,\n                         location: location,\n                         span: alias_span.expect(\"No span found for extern crate\"),"}, {"sha": "7ec3c9345be58fd16bed4092c8bc46d4e257e95f", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -22,7 +22,7 @@ use machine;\n use type_of;\n \n use syntax::codemap::DUMMY_SP;\n-use syntax::parse::token;\n+use syntax::parse::token::keywords;\n \n use std::ops::Deref;\n use std::rc::Rc;\n@@ -286,7 +286,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         alloca: lltemp,\n                         address_operations: &ops\n                     };\n-                    declare_local(bcx, token::special_idents::invalid.name,\n+                    declare_local(bcx, keywords::Invalid.name(),\n                                   tupled_arg_ty, scope, variable_access,\n                                   VariableKind::ArgumentVariable(arg_index + i + 1),\n                                   bcx.fcx().span.unwrap_or(DUMMY_SP));"}, {"sha": "d6e64ccd259e6efb72e67b4d1a90caeebac2a696", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -73,7 +73,7 @@ use syntax::{abi, ast};\n use syntax::codemap::{Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::parse::token;\n+use syntax::parse::token::{self, keywords};\n \n use rustc::hir::print as pprust;\n use rustc::hir;\n@@ -1313,7 +1313,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             let trait_node_id = tcx.map.as_local_node_id(trait_did).unwrap();\n             match find_bound_for_assoc_item(this,\n                                             trait_node_id,\n-                                            token::special_idents::type_self.name,\n+                                            keywords::SelfType.name(),\n                                             assoc_name,\n                                             span) {\n                 Ok(bound) => bound,"}, {"sha": "57f56530009ebc39b092119b3a9ee87a02b857cb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -120,7 +120,7 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Spanned};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::parse::token::{self, InternedString, special_idents};\n+use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -2851,7 +2851,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 method_ty\n             }\n             Err(error) => {\n-                if method_name.node != special_idents::invalid.name {\n+                if method_name.node != keywords::Invalid.name() {\n                     method::report_error(fcx, method_name.span, expr_t,\n                                          method_name.node, Some(rcvr), error);\n                 }\n@@ -2990,7 +2990,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n             fcx.tcx().sess.span_err(expr.span, &msg);\n             fcx.write_ty(expr.id, field_ty);\n-        } else if field.node == special_idents::invalid.name {\n+        } else if field.node == keywords::Invalid.name() {\n             fcx.write_error(expr.id);\n         } else if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n             fcx.type_error_struct(field.span,\n@@ -3780,7 +3780,7 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                     method::MethodError::PrivateMatch(def) => Some(def),\n                     _ => None,\n                 };\n-                if item_name != special_idents::invalid.name {\n+                if item_name != keywords::Invalid.name() {\n                     method::report_error(fcx, span, ty, item_name, None, error);\n                 }\n                 def"}, {"sha": "3bfd53ceadae8db2cfa61f86e78f23ad4d96b924", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -24,7 +24,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::codemap::{Span};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::parse::token::{special_idents};\n+use syntax::parse::token::keywords;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n \n@@ -472,7 +472,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         let name = match space {\n             TypeSpace => ast_generics.ty_params[index].name,\n-            SelfSpace => special_idents::type_self.name,\n+            SelfSpace => keywords::SelfType.name(),\n             FnSpace => bug!(\"Fn space occupied?\"),\n         };\n "}, {"sha": "4a6f7a6a2ef48f9dbaf797c7e6222cfc43b443af", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -93,7 +93,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit;\n@@ -1655,7 +1655,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let def = ty::TypeParameterDef {\n         space: SelfSpace,\n         index: 0,\n-        name: special_idents::type_self.name,\n+        name: keywords::SelfType.name(),\n         def_id: ccx.tcx.map.local_def_id(param_id),\n         default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: None,"}, {"sha": "da792b363f0a5003a5a21bde7b62240e1e3a4298", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -31,7 +31,7 @@ use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap;\n use syntax::codemap::{DUMMY_SP, Pos, Spanned};\n-use syntax::parse::token::{self, InternedString, special_idents};\n+use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n \n use rustc_trans::back::link;\n@@ -2666,7 +2666,7 @@ fn resolve_type(cx: &DocContext,\n             hir::TyFloat(ast::FloatTy::F64) => return Primitive(F64),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(special_idents::type_self.name.to_string());\n+            return Generic(keywords::SelfType.name().to_string());\n         }\n         Def::SelfTy(..) | Def::TyParam(..) => true,\n         _ => false,"}, {"sha": "2f0ae540fbf07c7d1d4a2db33155ac6d253c95d9", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -147,7 +147,7 @@ fn write_source(sess: &parse::ParseSess,\n             }\n \n             // keywords are also included in the identifier set\n-            token::Ident(ident, _is_mod_sep) => {\n+            token::Ident(ident) => {\n                 match &*ident.name.as_str() {\n                     \"ref\" | \"mut\" => \"kw-2\",\n "}, {"sha": "bf1c305e2067439ae911c4630bb508bbdc08b782", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -93,7 +93,7 @@ impl Ident {\n     pub fn new(name: Name, ctxt: SyntaxContext) -> Ident {\n         Ident {name: name, ctxt: ctxt}\n     }\n-    pub fn with_empty_ctxt(name: Name) -> Ident {\n+    pub const fn with_empty_ctxt(name: Name) -> Ident {\n         Ident {name: name, ctxt: EMPTY_CTXT}\n     }\n }\n@@ -248,8 +248,8 @@ impl PathParameters {\n     pub fn none() -> PathParameters {\n         PathParameters::AngleBracketed(AngleBracketedParameterData {\n             lifetimes: Vec::new(),\n-            types: P::empty(),\n-            bindings: P::empty(),\n+            types: P::new(),\n+            bindings: P::new(),\n         })\n     }\n \n@@ -421,7 +421,7 @@ impl Default for Generics {\n     fn default() ->  Generics {\n         Generics {\n             lifetimes: Vec::new(),\n-            ty_params: P::empty(),\n+            ty_params: P::new(),\n             where_clause: WhereClause {\n                 id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n@@ -1208,8 +1208,7 @@ impl TokenTree {\n                 TokenTree::Delimited(sp, Rc::new(Delimited {\n                     delim: token::Bracket,\n                     open_span: sp,\n-                    tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"),\n-                                                                token::Plain)),\n+                    tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"))),\n                               TokenTree::Token(sp, token::Eq),\n                               TokenTree::Token(sp, token::Literal(\n                                   token::StrRaw(token::intern(&stripped), num_of_hashes), None))],\n@@ -1227,14 +1226,13 @@ impl TokenTree {\n             }\n             (&TokenTree::Token(sp, token::SpecialVarNt(var)), _) => {\n                 let v = [TokenTree::Token(sp, token::Dollar),\n-                         TokenTree::Token(sp, token::Ident(token::str_to_ident(var.as_str()),\n-                                                  token::Plain))];\n+                         TokenTree::Token(sp, token::Ident(token::str_to_ident(var.as_str())))];\n                 v[index].clone()\n             }\n-            (&TokenTree::Token(sp, token::MatchNt(name, kind, name_st, kind_st)), _) => {\n-                let v = [TokenTree::Token(sp, token::SubstNt(name, name_st)),\n+            (&TokenTree::Token(sp, token::MatchNt(name, kind)), _) => {\n+                let v = [TokenTree::Token(sp, token::SubstNt(name)),\n                          TokenTree::Token(sp, token::Colon),\n-                         TokenTree::Token(sp, token::Ident(kind, kind_st))];\n+                         TokenTree::Token(sp, token::Ident(kind))];\n                 v[index].clone()\n             }\n             (&TokenTree::Sequence(_, ref seq), _) => {"}, {"sha": "26088b1242e2a326d3eac0ee476148a754d5ee5d", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -54,7 +54,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    token_tree: &[TokenTree])\n                                    -> Box<MacResult+'cx> {\n     let code = match (token_tree.len(), token_tree.get(0)) {\n-        (1, Some(&TokenTree::Token(_, token::Ident(code, _)))) => code,\n+        (1, Some(&TokenTree::Token(_, token::Ident(code)))) => code,\n         _ => unreachable!()\n     };\n \n@@ -92,10 +92,10 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         token_tree.get(1),\n         token_tree.get(2)\n     ) {\n-        (1, Some(&TokenTree::Token(_, token::Ident(ref code, _))), None, None) => {\n+        (1, Some(&TokenTree::Token(_, token::Ident(ref code))), None, None) => {\n             (code, None)\n         },\n-        (3, Some(&TokenTree::Token(_, token::Ident(ref code, _))),\n+        (3, Some(&TokenTree::Token(_, token::Ident(ref code))),\n             Some(&TokenTree::Token(_, token::Comma)),\n             Some(&TokenTree::Token(_, token::Literal(token::StrRaw(description, _), None)))) => {\n             (code, Some(description))\n@@ -160,9 +160,9 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n     let (crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n         (\n             // Crate name.\n-            &TokenTree::Token(_, token::Ident(ref crate_name, _)),\n+            &TokenTree::Token(_, token::Ident(ref crate_name)),\n             // DIAGNOSTICS ident.\n-            &TokenTree::Token(_, token::Ident(ref name, _))\n+            &TokenTree::Token(_, token::Ident(ref name))\n         ) => (*&crate_name, name),\n         _ => unreachable!()\n     };"}, {"sha": "67bce440d4d48213bbdd282bbd3f431c4aa5c720", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -13,9 +13,7 @@ use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n-use parse::token::special_idents;\n-use parse::token::InternedString;\n-use parse::token;\n+use parse::token::{self, keywords, InternedString};\n use ptr::P;\n \n // Transitional reexports so qquote can find the paths it is looking for\n@@ -606,7 +604,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, special_idents::self_)\n+        self.expr_ident(span, keywords::SelfValue.ident())\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n@@ -1153,7 +1151,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item> {\n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: special_idents::invalid,\n+            ident: keywords::Invalid.ident(),\n             attrs: vec![],\n             node: ast::ItemKind::Use(vp),\n             vis: vis,"}, {"sha": "a2c8ae898e17303e659bd8b3788374d77d8f1068", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -25,7 +25,7 @@ use fold;\n use fold::*;\n use util::move_map::MoveMap;\n use parse;\n-use parse::token::{fresh_mark, fresh_name, intern};\n+use parse::token::{fresh_mark, fresh_name, intern, keywords};\n use ptr::P;\n use util::small_vector::SmallVector;\n use visit;\n@@ -383,7 +383,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n \n             Some(rc) => match *rc {\n                 NormalTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name != parse::token::special_idents::invalid.name {\n+                    if ident.name != keywords::Invalid.name() {\n                         fld.cx\n                             .span_err(path_span,\n                                       &format!(\"macro {}! expects no ident argument, given '{}'\",\n@@ -404,7 +404,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     expander.expand(fld.cx, span, &marked_before[..])\n                 }\n                 IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name == parse::token::special_idents::invalid.name {\n+                    if ident.name == keywords::Invalid.name() {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n                                                 extname));\n@@ -423,7 +423,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     expander.expand(fld.cx, span, ident, marked_tts)\n                 }\n                 MacroRulesTT => {\n-                    if ident.name == parse::token::special_idents::invalid.name {\n+                    if ident.name == keywords::Invalid.name() {\n                         fld.cx.span_err(path_span, \"macro_rules! expects an ident argument\");\n                         return SmallVector::zero();\n                     }\n@@ -896,7 +896,7 @@ fn expand_annotatable(a: Annotatable,\n             }\n             ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n                 let valid_ident =\n-                    it.ident.name != parse::token::special_idents::invalid.name;\n+                    it.ident.name != keywords::Invalid.name();\n \n                 if valid_ident {\n                     fld.cx.mod_push(it.ident);\n@@ -1489,7 +1489,7 @@ mod tests {\n     use ext::mtwt;\n     use fold::Folder;\n     use parse;\n-    use parse::token;\n+    use parse::token::{self, keywords};\n     use util::parser_testing::{string_to_parser};\n     use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;\n@@ -1810,7 +1810,7 @@ mod tests {\n \n     // run one of the renaming tests\n     fn run_renaming_test(t: &RenamingTest, test_idx: usize) {\n-        let invalid_name = token::special_idents::invalid.name;\n+        let invalid_name = keywords::Invalid.name();\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n             (ref str,ref conns, bic) => (str.to_string(), conns.clone(), bic)\n         };"}, {"sha": "ee9a197ce56ccb84cc39167d1c2be5974543d5ff", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -13,7 +13,7 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n use ext::build::AstBuilder;\n-use parse::parser::{Parser, PathParsingMode};\n+use parse::parser::{Parser, PathStyle};\n use parse::token::*;\n use parse::token;\n use ptr::P;\n@@ -72,7 +72,7 @@ pub mod rt {\n \n     impl ToTokens for ast::Ident {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Ident(*self, token::Plain))]\n+            vec![TokenTree::Token(DUMMY_SP, token::Ident(*self))]\n         }\n     }\n \n@@ -401,7 +401,7 @@ pub fn parse_meta_item_panic(parser: &mut Parser) -> P<ast::MetaItem> {\n     panictry!(parser.parse_meta_item())\n }\n \n-pub fn parse_path_panic(parser: &mut Parser, mode: PathParsingMode) -> ast::Path {\n+pub fn parse_path_panic(parser: &mut Parser, mode: PathStyle) -> ast::Path {\n     panictry!(parser.parse_path(mode))\n }\n \n@@ -500,7 +500,7 @@ pub fn expand_quote_path(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n                         -> Box<base::MacResult+'static> {\n-    let mode = mk_parser_path(cx, sp, \"LifetimeAndTypesWithoutColons\");\n+    let mode = mk_parser_path(cx, sp, &[\"PathStyle\", \"Type\"]);\n     let expanded = expand_parse_call(cx, sp, \"parse_path_panic\", vec!(mode), tts);\n     base::MacEager::expr(expanded)\n }\n@@ -557,8 +557,9 @@ fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_parser_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n-    let idents = vec!(id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"parser\"), id_ext(name));\n+fn mk_parser_path(cx: &ExtCtxt, sp: Span, names: &[&str]) -> P<ast::Expr> {\n+    let mut idents = vec![id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"parser\")];\n+    idents.extend(names.iter().cloned().map(id_ext));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n@@ -646,14 +647,10 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                            cx.expr_usize(sp, n))\n         }\n \n-        token::Ident(ident, style) => {\n+        token::Ident(ident) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"Ident\"),\n-                                vec![mk_ident(cx, sp, ident),\n-                                     match style {\n-                                        ModName => mk_token_path(cx, sp, \"ModName\"),\n-                                        Plain   => mk_token_path(cx, sp, \"Plain\"),\n-                                     }]);\n+                                vec![mk_ident(cx, sp, ident)]);\n         }\n \n         token::Lifetime(ident) => {\n@@ -668,19 +665,10 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                                 vec!(mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident))));\n         }\n \n-        token::MatchNt(name, kind, namep, kindp) => {\n+        token::MatchNt(name, kind) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"MatchNt\"),\n-                                vec!(mk_ident(cx, sp, name),\n-                                     mk_ident(cx, sp, kind),\n-                                     match namep {\n-                                        ModName => mk_token_path(cx, sp, \"ModName\"),\n-                                        Plain   => mk_token_path(cx, sp, \"Plain\"),\n-                                     },\n-                                     match kindp {\n-                                        ModName => mk_token_path(cx, sp, \"ModName\"),\n-                                        Plain   => mk_token_path(cx, sp, \"Plain\"),\n-                                     }));\n+                                vec![mk_ident(cx, sp, name), mk_ident(cx, sp, kind)]);\n         }\n \n         token::Interpolated(_) => panic!(\"quote! with interpolated token\"),\n@@ -722,7 +710,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n \n fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stmt> {\n     match *tt {\n-        TokenTree::Token(sp, SubstNt(ident, _)) => {\n+        TokenTree::Token(sp, SubstNt(ident)) => {\n             // tt.extend($ident.to_tokens(ext_cx))\n \n             let e_to_toks ="}, {"sha": "89ecf02ee4c92d6894c806919edba00f3e0951c8", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -85,7 +85,7 @@ use codemap;\n use errors::FatalError;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n-use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n+use parse::parser::{PathStyle, Parser};\n use parse::token::{DocComment, MatchNt, SubstNt};\n use parse::token::{Token, Nonterminal};\n use parse::token;\n@@ -216,7 +216,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                     n_rec(p_s, next_m, res, ret_val, idx)?;\n                 }\n             }\n-            TokenTree::Token(sp, MatchNt(bind_name, _, _, _)) => {\n+            TokenTree::Token(sp, MatchNt(bind_name, _)) => {\n                 match ret_val.entry(bind_name.name) {\n                     Vacant(spot) => {\n                         spot.insert(res[*idx].clone());\n@@ -263,7 +263,7 @@ pub type PositionalParseResult = ParseResult<Vec<Rc<NamedMatch>>>;\n /// unhygienic comparison)\n pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     match (t1,t2) {\n-        (&token::Ident(id1,_),&token::Ident(id2,_))\n+        (&token::Ident(id1),&token::Ident(id2))\n         | (&token::Lifetime(id1),&token::Lifetime(id2)) =>\n             id1.name == id2.name,\n         _ => *t1 == *t2\n@@ -451,7 +451,7 @@ pub fn parse(sess: &ParseSess,\n             if (!bb_eis.is_empty() && !next_eis.is_empty())\n                 || bb_eis.len() > 1 {\n                 let nts = bb_eis.iter().map(|ei| match ei.top_elts.get_tt(ei.idx) {\n-                    TokenTree::Token(_, MatchNt(bind, name, _, _)) => {\n+                    TokenTree::Token(_, MatchNt(bind, name)) => {\n                         format!(\"{} ('{}')\", name, bind)\n                     }\n                     _ => panic!()\n@@ -479,7 +479,7 @@ pub fn parse(sess: &ParseSess,\n \n                 let mut ei = bb_eis.pop().unwrap();\n                 match ei.top_elts.get_tt(ei.idx) {\n-                    TokenTree::Token(span, MatchNt(_, ident, _, _)) => {\n+                    TokenTree::Token(span, MatchNt(_, ident)) => {\n                         let match_cur = ei.match_cur;\n                         (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n                             parse_nt(&mut rust_parser, span, &ident.name.as_str()))));\n@@ -534,9 +534,9 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n         \"ident\" => match p.token {\n-            token::Ident(sn,b) => {\n+            token::Ident(sn) => {\n                 p.bump();\n-                token::NtIdent(Box::new(Spanned::<Ident>{node: sn, span: p.span}),b)\n+                token::NtIdent(Box::new(Spanned::<Ident>{node: sn, span: p.span}))\n             }\n             _ => {\n                 let token_str = pprust::token_to_string(&p.token);\n@@ -546,7 +546,7 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             }\n         },\n         \"path\" => {\n-            token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n+            token::NtPath(Box::new(panictry!(p.parse_path(PathStyle::Type))))\n         },\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         _ => {"}, {"sha": "41d3991aee809a4feddf47314a6f486544e41dbf", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -17,7 +17,7 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::parse;\n use parse::lexer::new_tt_reader;\n use parse::parser::{Parser, Restrictions};\n-use parse::token::{self, special_idents, gensym_ident, NtTT, Token};\n+use parse::token::{self, gensym_ident, NtTT, Token};\n use parse::token::Token::*;\n use print;\n use ptr::P;\n@@ -244,8 +244,8 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     // $( $lhs:tt => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n     // These spans won't matter, anyways\n-    let match_lhs_tok = MatchNt(lhs_nm, special_idents::tt, token::Plain, token::Plain);\n-    let match_rhs_tok = MatchNt(rhs_nm, special_idents::tt, token::Plain, token::Plain);\n+    let match_lhs_tok = MatchNt(lhs_nm, token::str_to_ident(\"tt\"));\n+    let match_rhs_tok = MatchNt(rhs_nm, token::str_to_ident(\"tt\"));\n     let argument_gram = vec!(\n         TokenTree::Sequence(DUMMY_SP,\n                    Rc::new(ast::SequenceRepetition {\n@@ -415,7 +415,7 @@ fn check_matcher_old<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token, on_fai\n     let mut tokens = matcher.peekable();\n     while let Some(token) = tokens.next() {\n         last = match *token {\n-            TokenTree::Token(sp, MatchNt(ref name, ref frag_spec, _, _)) => {\n+            TokenTree::Token(sp, MatchNt(ref name, ref frag_spec)) => {\n                 // ii. If T is a simple NT, look ahead to the next token T' in\n                 // M. If T' is in the set FOLLOW(NT), continue. Else; reject.\n                 if can_be_followed_by_any(&frag_spec.name.as_str()) {\n@@ -881,7 +881,7 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n         'each_last: for &(_sp, ref t) in &last.tokens {\n-            if let MatchNt(ref name, ref frag_spec, _, _) = *t {\n+            if let MatchNt(ref name, ref frag_spec) = *t {\n                 for &(sp, ref next_token) in &suffix_first.tokens {\n                     match is_in_follow(cx, next_token, &frag_spec.name.as_str()) {\n                         Err(msg) => {\n@@ -917,9 +917,8 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n     last\n }\n \n-\n fn token_can_be_followed_by_any(tok: &Token) -> bool {\n-    if let &MatchNt(_, ref frag_spec, _, _) = tok {\n+    if let &MatchNt(_, ref frag_spec) = tok {\n         frag_can_be_followed_by_any(&frag_spec.name.as_str())\n     } else {\n         // (Non NT's can always be followed by anthing in matchers.)\n@@ -1005,18 +1004,17 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n             \"pat\" => {\n                 match *tok {\n                     FatArrow | Comma | Eq | BinOp(token::Or) => Ok(true),\n-                    Ident(i, _) if (i.name.as_str() == \"if\" ||\n-                                    i.name.as_str() == \"in\") => Ok(true),\n+                    Ident(i) if (i.name.as_str() == \"if\" ||\n+                                 i.name.as_str() == \"in\") => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n                     OpenDelim(token::DelimToken::Brace) | OpenDelim(token::DelimToken::Bracket) |\n                     Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n-                    MatchNt(_, ref frag, _, _) if frag.name.as_str() == \"block\" => Ok(true),\n-                    Ident(i, _) if (i.name.as_str() == \"as\" ||\n-                                    i.name.as_str() == \"where\") => Ok(true),\n+                    MatchNt(_, ref frag) if frag.name.as_str() == \"block\" => Ok(true),\n+                    Ident(i) if i.name.as_str() == \"as\" || i.name.as_str() == \"where\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n@@ -1036,7 +1034,7 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n \n fn has_legal_fragment_specifier(tok: &Token) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let &MatchNt(_, ref frag_spec, _, _) = tok {\n+    if let &MatchNt(_, ref frag_spec) = tok {\n         let s = &frag_spec.name.as_str();\n         if !is_legal_fragment_specifier(s) {\n             return Err(s.to_string());"}, {"sha": "7f53d0f412cca268cccabc3382e56e64fc0aef82", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -161,7 +161,7 @@ fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n                 size + lockstep_iter_size(tt, r)\n             })\n         },\n-        TokenTree::Token(_, SubstNt(name, _)) | TokenTree::Token(_, MatchNt(name, _, _, _)) =>\n+        TokenTree::Token(_, SubstNt(name)) | TokenTree::Token(_, MatchNt(name, _)) =>\n             match lookup_cur_matched(r, name) {\n                 Some(matched) => match *matched {\n                     MatchedNonterminal(_) => LisUnconstrained,\n@@ -186,7 +186,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             None => (),\n             Some(sp) => {\n                 r.cur_span = sp;\n-                r.cur_tok = token::Ident(r.imported_from.unwrap(), token::Plain);\n+                r.cur_tok = token::Ident(r.imported_from.unwrap());\n                 return ret_val;\n             },\n         }\n@@ -278,12 +278,12 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 }\n             }\n             // FIXME #2887: think about span stuff here\n-            TokenTree::Token(sp, SubstNt(ident, namep)) => {\n+            TokenTree::Token(sp, SubstNt(ident)) => {\n                 r.stack.last_mut().unwrap().idx += 1;\n                 match lookup_cur_matched(r, ident) {\n                     None => {\n                         r.cur_span = sp;\n-                        r.cur_tok = SubstNt(ident, namep);\n+                        r.cur_tok = SubstNt(ident);\n                         return ret_val;\n                         // this can't be 0 length, just like TokenTree::Delimited\n                     }\n@@ -292,9 +292,9 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                             // sidestep the interpolation tricks for ident because\n                             // (a) idents can be in lots of places, so it'd be a pain\n                             // (b) we actually can, since it's a token.\n-                            MatchedNonterminal(NtIdent(ref sn, b)) => {\n+                            MatchedNonterminal(NtIdent(ref sn)) => {\n                                 r.cur_span = sn.span;\n-                                r.cur_tok = token::Ident(sn.node, b);\n+                                r.cur_tok = token::Ident(sn.node);\n                                 return ret_val;\n                             }\n                             MatchedNonterminal(ref other_whole_nt) => {"}, {"sha": "c77671d89f88fc865d8ea65873c41eaf540ecdc7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1168,7 +1168,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_vis(&mut self, vis: &'v ast::Visibility) {\n         let span = match *vis {\n             ast::Visibility::Crate(span) => span,\n-            ast::Visibility::Restricted { ref path, .. } => path.span,\n+            ast::Visibility::Restricted { ref path, .. } => {\n+                // Check for type parameters\n+                let found_param = path.segments.iter().any(|segment| {\n+                    !segment.parameters.types().is_empty() ||\n+                    !segment.parameters.lifetimes().is_empty() ||\n+                    !segment.parameters.bindings().is_empty()\n+                });\n+                if found_param {\n+                    self.context.span_handler.span_err(path.span, \"type or lifetime parameters \\\n+                                                                   in visibility path\");\n+                }\n+                path.span\n+            }\n             _ => return,\n         };\n         self.gate_feature(\"pub_restricted\", span, \"`pub(restricted)` syntax is experimental\");"}, {"sha": "2c325080c0c2681c41447856ead46f4099c1d054", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -22,7 +22,7 @@ use ast::*;\n use ast;\n use attr::{ThinAttributes, ThinAttributesExt};\n use codemap::{respan, Span, Spanned};\n-use parse::token;\n+use parse::token::{self, keywords};\n use ptr::P;\n use util::small_vector::SmallVector;\n use util::move_map::MoveMap;\n@@ -610,17 +610,11 @@ pub fn noop_fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree\n // apply ident folder if it's an ident, apply other folds to interpolated nodes\n pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token {\n     match t {\n-        token::Ident(id, followed_by_colons) => {\n-            token::Ident(fld.fold_ident(id), followed_by_colons)\n-        }\n+        token::Ident(id) => token::Ident(fld.fold_ident(id)),\n         token::Lifetime(id) => token::Lifetime(fld.fold_ident(id)),\n         token::Interpolated(nt) => token::Interpolated(fld.fold_interpolated(nt)),\n-        token::SubstNt(ident, namep) => {\n-            token::SubstNt(fld.fold_ident(ident), namep)\n-        }\n-        token::MatchNt(name, kind, namep, kindp) => {\n-            token::MatchNt(fld.fold_ident(name), fld.fold_ident(kind), namep, kindp)\n-        }\n+        token::SubstNt(ident) => token::SubstNt(fld.fold_ident(ident)),\n+        token::MatchNt(name, kind) => token::MatchNt(fld.fold_ident(name), fld.fold_ident(kind)),\n         _ => t\n     }\n }\n@@ -664,9 +658,8 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(id, is_mod_name) =>\n-            token::NtIdent(Box::new(Spanned::<Ident>{node: fld.fold_ident(id.node), .. *id}),\n-                           is_mod_name),\n+        token::NtIdent(id) =>\n+            token::NtIdent(Box::new(Spanned::<Ident>{node: fld.fold_ident(id.node), ..*id})),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n         token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n         token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&tt))),\n@@ -1022,7 +1015,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n     let config = folder.fold_meta_items(config);\n \n     let mut items = folder.fold_item(P(ast::Item {\n-        ident: token::special_idents::invalid,\n+        ident: keywords::Invalid.ident(),\n         attrs: attrs,\n         id: ast::DUMMY_NODE_ID,\n         vis: ast::Visibility::Public,"}, {"sha": "6cfa1e9847b88cbe3670d3821839148ff0770de0", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -25,6 +25,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(associated_consts)]\n+#![feature(const_fn)]\n #![feature(filling_drop)]\n #![feature(libc)]\n #![feature(rustc_private)]\n@@ -96,7 +97,6 @@ pub mod config;\n pub mod entry;\n pub mod feature_gate;\n pub mod fold;\n-pub mod owned_slice;\n pub mod parse;\n pub mod ptr;\n pub mod show_span;"}, {"sha": "2eda13adcb580f6565584a7ef027907324ed8605", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 14, "deletions": 35, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -13,8 +13,7 @@ use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n use errors::{FatalError, Handler, DiagnosticBuilder};\n use ext::tt::transcribe::tt_next_token;\n-use parse::token::str_to_ident;\n-use parse::token;\n+use parse::token::{self, keywords, str_to_ident};\n use str::char_at;\n use rustc_unicode::property::Pattern_White_Space;\n \n@@ -1039,11 +1038,7 @@ impl<'a> StringReader<'a> {\n                     token::Underscore\n                 } else {\n                     // FIXME: perform NFKC normalization here. (Issue #2253)\n-                    if self.curr_is(':') && self.nextch_is(':') {\n-                        token::Ident(str_to_ident(string), token::ModName)\n-                    } else {\n-                        token::Ident(str_to_ident(string), token::Plain)\n-                    }\n+                    token::Ident(str_to_ident(string))\n                 }\n             });\n         }\n@@ -1231,17 +1226,11 @@ impl<'a> StringReader<'a> {\n                     let keyword_checking_ident = self.with_str_from(start, |lifetime_name| {\n                         str_to_ident(lifetime_name)\n                     });\n-                    let keyword_checking_token = &token::Ident(keyword_checking_ident,\n-                                                               token::Plain);\n+                    let keyword_checking_token = &token::Ident(keyword_checking_ident);\n                     let last_bpos = self.last_pos;\n-                    if keyword_checking_token.is_keyword(token::keywords::SelfValue) {\n-                        self.err_span_(start,\n-                                       last_bpos,\n-                                       \"invalid lifetime name: 'self is no longer a special \\\n-                                        lifetime\");\n-                    } else if keyword_checking_token.is_any_keyword() &&\n-                       !keyword_checking_token.is_keyword(token::keywords::Static) {\n-                        self.err_span_(start, last_bpos, \"invalid lifetime name\");\n+                    if keyword_checking_token.is_any_keyword() &&\n+                       !keyword_checking_token.is_keyword(keywords::Static) {\n+                        self.err_span_(start, last_bpos, \"lifetimes cannot use keyword names\");\n                     }\n \n                     return token::Lifetime(ident);\n@@ -1687,7 +1676,7 @@ mod tests {\n         assert_eq!(string_reader.next_token().tok, token::Whitespace);\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan {\n-            tok: token::Ident(id, token::Plain),\n+            tok: token::Ident(id),\n             sp: Span {\n                 lo: BytePos(21),\n                 hi: BytePos(23),\n@@ -1701,7 +1690,7 @@ mod tests {\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan {\n-            tok: token::Ident(str_to_ident(\"main\"), token::Plain),\n+            tok: token::Ident(str_to_ident(\"main\")),\n             sp: Span {\n                 lo: BytePos(24),\n                 hi: BytePos(28),\n@@ -1722,50 +1711,40 @@ mod tests {\n     }\n \n     // make the identifier by looking up the string in the interner\n-    fn mk_ident(id: &str, style: token::IdentStyle) -> token::Token {\n-        token::Ident(str_to_ident(id), style)\n+    fn mk_ident(id: &str) -> token::Token {\n+        token::Ident(str_to_ident(id))\n     }\n \n     #[test]\n     fn doublecolonparsing() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n-                           vec![mk_ident(\"a\", token::Plain),\n-                                token::Whitespace,\n-                                mk_ident(\"b\", token::Plain)]);\n+                           vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_2() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n-                           vec![mk_ident(\"a\", token::ModName),\n-                                token::ModSep,\n-                                mk_ident(\"b\", token::Plain)]);\n+                           vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_3() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n-                           vec![mk_ident(\"a\", token::Plain),\n-                                token::Whitespace,\n-                                token::ModSep,\n-                                mk_ident(\"b\", token::Plain)]);\n+                           vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_4() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n-                           vec![mk_ident(\"a\", token::ModName),\n-                                token::ModSep,\n-                                token::Whitespace,\n-                                mk_ident(\"b\", token::Plain)]);\n+                           vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n     }\n \n     #[test]"}, {"sha": "c2050d2a8f48b38eecbdd4c366f70226c65c029e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -734,9 +734,9 @@ mod tests {\n         match (tts.len(), tts.get(0), tts.get(1), tts.get(2), tts.get(3)) {\n             (\n                 4,\n-                Some(&TokenTree::Token(_, token::Ident(name_macro_rules, token::Plain))),\n+                Some(&TokenTree::Token(_, token::Ident(name_macro_rules))),\n                 Some(&TokenTree::Token(_, token::Not)),\n-                Some(&TokenTree::Token(_, token::Ident(name_zip, token::Plain))),\n+                Some(&TokenTree::Token(_, token::Ident(name_zip))),\n                 Some(&TokenTree::Delimited(_, ref macro_delimed)),\n             )\n             if name_macro_rules.name.as_str() == \"macro_rules\"\n@@ -755,7 +755,7 @@ mod tests {\n                             (\n                                 2,\n                                 Some(&TokenTree::Token(_, token::Dollar)),\n-                                Some(&TokenTree::Token(_, token::Ident(ident, token::Plain))),\n+                                Some(&TokenTree::Token(_, token::Ident(ident))),\n                             )\n                             if first_delimed.delim == token::Paren\n                             && ident.name.as_str() == \"a\" => {},\n@@ -766,7 +766,7 @@ mod tests {\n                             (\n                                 2,\n                                 Some(&TokenTree::Token(_, token::Dollar)),\n-                                Some(&TokenTree::Token(_, token::Ident(ident, token::Plain))),\n+                                Some(&TokenTree::Token(_, token::Ident(ident))),\n                             )\n                             if second_delimed.delim == token::Paren\n                             && ident.name.as_str() == \"a\" => {},\n@@ -785,26 +785,17 @@ mod tests {\n         let tts = string_to_tts(\"fn a (b : i32) { b; }\".to_string());\n \n         let expected = vec![\n-            TokenTree::Token(sp(0, 2),\n-                         token::Ident(str_to_ident(\"fn\"),\n-                         token::IdentStyle::Plain)),\n-            TokenTree::Token(sp(3, 4),\n-                         token::Ident(str_to_ident(\"a\"),\n-                         token::IdentStyle::Plain)),\n+            TokenTree::Token(sp(0, 2), token::Ident(str_to_ident(\"fn\"))),\n+            TokenTree::Token(sp(3, 4), token::Ident(str_to_ident(\"a\"))),\n             TokenTree::Delimited(\n                 sp(5, 14),\n                 Rc::new(ast::Delimited {\n                     delim: token::DelimToken::Paren,\n                     open_span: sp(5, 6),\n                     tts: vec![\n-                        TokenTree::Token(sp(6, 7),\n-                                     token::Ident(str_to_ident(\"b\"),\n-                                     token::IdentStyle::Plain)),\n-                        TokenTree::Token(sp(8, 9),\n-                                     token::Colon),\n-                        TokenTree::Token(sp(10, 13),\n-                                     token::Ident(str_to_ident(\"i32\"),\n-                                     token::IdentStyle::Plain)),\n+                        TokenTree::Token(sp(6, 7), token::Ident(str_to_ident(\"b\"))),\n+                        TokenTree::Token(sp(8, 9), token::Colon),\n+                        TokenTree::Token(sp(10, 13), token::Ident(str_to_ident(\"i32\"))),\n                     ],\n                     close_span: sp(13, 14),\n                 })),\n@@ -814,11 +805,8 @@ mod tests {\n                     delim: token::DelimToken::Brace,\n                     open_span: sp(15, 16),\n                     tts: vec![\n-                        TokenTree::Token(sp(17, 18),\n-                                     token::Ident(str_to_ident(\"b\"),\n-                                     token::IdentStyle::Plain)),\n-                        TokenTree::Token(sp(18, 19),\n-                                     token::Semi)\n+                        TokenTree::Token(sp(17, 18), token::Ident(str_to_ident(\"b\"))),\n+                        TokenTree::Token(sp(18, 19), token::Semi),\n                     ],\n                     close_span: sp(20, 21),\n                 }))\n@@ -937,7 +925,7 @@ mod tests {\n                                     Abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n-                                        ty_params: P::empty(),\n+                                        ty_params: P::new(),\n                                         where_clause: ast::WhereClause {\n                                             id: ast::DUMMY_NODE_ID,\n                                             predicates: Vec::new(),"}, {"sha": "8722fe9d79d4b2d60e110fd70edf8dc06b1f3c6c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 156, "deletions": 184, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::PathParsingMode::*;\n-\n use abi::{self, Abi};\n use ast::BareFnTy;\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n@@ -51,7 +49,7 @@ use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::{ParserObsoleteMethods, ObsoleteSyntax};\n use parse::token::{self, intern, MatchNt, SubstNt, SpecialVarNt, InternedString};\n-use parse::token::{keywords, special_idents, SpecialMacroVar};\n+use parse::token::{keywords, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n@@ -69,26 +67,24 @@ bitflags! {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n         const NO_NONINLINE_MOD  = 1 << 2,\n-        const ALLOW_MODULE_PATHS = 1 << 3,\n     }\n }\n \n type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n \n-/// How to parse a path. There are four different kinds of paths, all of which\n+/// How to parse a path. There are three different kinds of paths, all of which\n /// are parsed somewhat differently.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum PathParsingMode {\n-    /// A path with no type parameters; e.g. `foo::bar::Baz`\n-    NoTypesAllowed,\n-    /// Same as `NoTypesAllowed`, but may end with `::{` or `::*`, which are left unparsed\n-    ImportPrefix,\n+pub enum PathStyle {\n+    /// A path with no type parameters, e.g. `foo::bar::Baz`, used in imports or visibilities.\n+    Mod,\n     /// A path with a lifetime and type parameters, with no double colons\n-    /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n-    LifetimeAndTypesWithoutColons,\n+    /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`, used in types.\n+    /// Paths using this style can be passed into macros expecting `path` nonterminals.\n+    Type,\n     /// A path with a lifetime and type parameters with double colons before\n-    /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n-    LifetimeAndTypesWithColons,\n+    /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`, used in expressions or patterns.\n+    Expr,\n }\n \n /// How to parse a bound, whether to allow bound modifiers such as `?`.\n@@ -292,13 +288,13 @@ impl TokenType {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n             TokenType::Operator => \"an operator\".to_string(),\n-            TokenType::Keyword(kw) => format!(\"`{}`\", kw.to_name()),\n+            TokenType::Keyword(kw) => format!(\"`{}`\", kw.name()),\n         }\n     }\n }\n \n-fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n-    t.is_plain_ident() || *t == token::Underscore\n+fn is_ident_or_underscore(t: &token::Token) -> bool {\n+    t.is_ident() || *t == token::Underscore\n }\n \n /// Information about the path to a module.\n@@ -398,6 +394,17 @@ impl<'a> Parser<'a> {\n         Parser::token_to_string(&self.token)\n     }\n \n+    pub fn this_token_descr(&self) -> String {\n+        let s = self.this_token_to_string();\n+        if self.token.is_strict_keyword() {\n+            format!(\"keyword `{}`\", s)\n+        } else if self.token.is_reserved_keyword() {\n+            format!(\"reserved keyword `{}`\", s)\n+        } else {\n+            format!(\"`{}`\", s)\n+        }\n+    }\n+\n     pub fn unexpected_last<T>(&self, t: &token::Token) -> PResult<'a, T> {\n         let token_str = Parser::token_to_string(t);\n         let last_span = self.last_span;\n@@ -562,12 +569,10 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        if !self.restrictions.contains(Restrictions::ALLOW_MODULE_PATHS) {\n-            self.check_strict_keywords();\n-        }\n+        self.check_strict_keywords();\n         self.check_reserved_keywords();\n         match self.token {\n-            token::Ident(i, _) => {\n+            token::Ident(i) => {\n                 self.bump();\n                 Ok(i)\n             }\n@@ -585,12 +590,9 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_ident_or_self_type(&mut self) -> PResult<'a, ast::Ident> {\n-        if self.is_self_type_ident() {\n-            self.expect_self_type_ident()\n-        } else {\n-            self.parse_ident()\n-        }\n+    fn parse_ident_into_path(&mut self) -> PResult<'a, ast::Path> {\n+        let ident = self.parse_ident()?;\n+        Ok(ast::Path::from_ident(self.last_span, ident))\n     }\n \n     /// Check if the next token is `tok`, and return `true` if so.\n@@ -637,9 +639,8 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn check_contextual_keyword(&mut self, ident: Ident) -> bool {\n-        let tok = token::Ident(ident, token::Plain);\n-        self.expected_tokens.push(TokenType::Token(tok));\n-        if let token::Ident(ref cur_ident, _) = self.token {\n+        self.expected_tokens.push(TokenType::Token(token::Ident(ident)));\n+        if let token::Ident(ref cur_ident) = self.token {\n             cur_ident.name == ident.name\n         } else {\n             false\n@@ -1159,7 +1160,7 @@ impl<'a> Parser<'a> {\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n                 self.parse_ty_param_bounds(BoundParsingMode::Bare)?\n             } else {\n-                P::empty()\n+                P::new()\n             };\n             let all_bounds =\n                 Some(TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)).into_iter()\n@@ -1170,7 +1171,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ty_path(&mut self) -> PResult<'a, TyKind> {\n-        Ok(TyKind::Path(None, self.parse_path(LifetimeAndTypesWithoutColons)?))\n+        Ok(TyKind::Path(None, self.parse_path(PathStyle::Type)?))\n     }\n \n     /// parse a TyKind::BareFn type:\n@@ -1473,13 +1474,11 @@ impl<'a> Parser<'a> {\n         } else if self.eat_lt() {\n \n             let (qself, path) =\n-                 self.parse_qualified_path(NoTypesAllowed)?;\n+                 self.parse_qualified_path(PathStyle::Type)?;\n \n             TyKind::Path(Some(qself), path)\n-        } else if self.check(&token::ModSep) ||\n-                  self.token.is_ident() ||\n-                  self.token.is_path() {\n-            let path = self.parse_path(LifetimeAndTypesWithoutColons)?;\n+        } else if self.token.is_path_start() {\n+            let path = self.parse_path(PathStyle::Type)?;\n             if self.check(&token::Not) {\n                 // MACRO INVOCATION\n                 self.bump();\n@@ -1497,9 +1496,8 @@ impl<'a> Parser<'a> {\n             // TYPE TO BE INFERRED\n             TyKind::Infer\n         } else {\n-            let this_token_str = self.this_token_to_string();\n-            let msg = format!(\"expected type, found `{}`\", this_token_str);\n-            return Err(self.fatal(&msg[..]));\n+            let msg = format!(\"expected type, found {}\", self.this_token_descr());\n+            return Err(self.fatal(&msg));\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n@@ -1541,10 +1539,10 @@ impl<'a> Parser<'a> {\n         debug!(\"parser is_named_argument offset:{}\", offset);\n \n         if offset == 0 {\n-            is_plain_ident_or_underscore(&self.token)\n+            is_ident_or_underscore(&self.token)\n                 && self.look_ahead(1, |t| *t == token::Colon)\n         } else {\n-            self.look_ahead(offset, |t| is_plain_ident_or_underscore(t))\n+            self.look_ahead(offset, |t| is_ident_or_underscore(t))\n                 && self.look_ahead(offset + 1, |t| *t == token::Colon)\n         }\n     }\n@@ -1564,7 +1562,7 @@ impl<'a> Parser<'a> {\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n             let sp = self.last_span;\n-            let spanned = Spanned { span: sp, node: special_idents::invalid };\n+            let spanned = Spanned { span: sp, node: keywords::Invalid.ident() };\n             P(Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable),\n@@ -1616,12 +1614,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches token_lit = LIT_INTEGER | ...\n-    pub fn lit_from_token(&self, tok: &token::Token) -> PResult<'a, LitKind> {\n-        match *tok {\n+    pub fn parse_lit_token(&mut self) -> PResult<'a, LitKind> {\n+        let out = match self.token {\n             token::Interpolated(token::NtExpr(ref v)) => {\n                 match v.node {\n-                    ExprKind::Lit(ref lit) => { Ok(lit.node.clone()) }\n-                    _ => { return self.unexpected_last(tok); }\n+                    ExprKind::Lit(ref lit) => { lit.node.clone() }\n+                    _ => { return self.unexpected_last(&self.token); }\n                 }\n             }\n             token::Literal(lit, suf) => {\n@@ -1636,13 +1634,13 @@ impl<'a> Parser<'a> {\n                         (false, parse::integer_lit(&s.as_str(),\n                                                    suf.as_ref().map(|s| s.as_str()),\n                                                    &self.sess.span_diagnostic,\n-                                                   self.last_span))\n+                                                   self.span))\n                     }\n                     token::Float(s) => {\n                         (false, parse::float_lit(&s.as_str(),\n                                                  suf.as_ref().map(|s| s.as_str()),\n                                                   &self.sess.span_diagnostic,\n-                                                 self.last_span))\n+                                                 self.span))\n                     }\n \n                     token::Str_(s) => {\n@@ -1664,14 +1662,17 @@ impl<'a> Parser<'a> {\n                 };\n \n                 if suffix_illegal {\n-                    let sp = self.last_span;\n+                    let sp = self.span;\n                     self.expect_no_suffix(sp, &format!(\"{} literal\", lit.short_name()), suf)\n                 }\n \n-                Ok(out)\n+                out\n             }\n-            _ => { return self.unexpected_last(tok); }\n-        }\n+            _ => { return self.unexpected_last(&self.token); }\n+        };\n+\n+        self.bump();\n+        Ok(out)\n     }\n \n     /// Matches lit = true | false | token_lit\n@@ -1682,8 +1683,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::False) {\n             LitKind::Bool(false)\n         } else {\n-            let token = self.bump_and_get();\n-            let lit = self.lit_from_token(&token)?;\n+            let lit = self.parse_lit_token()?;\n             lit\n         };\n         Ok(codemap::Spanned { node: lit, span: mk_sp(lo, self.last_span.hi) })\n@@ -1707,6 +1707,16 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n+        match self.token {\n+            token::Ident(sid) if self.token.is_path_segment_keyword() => {\n+                self.bump();\n+                Ok(sid)\n+            }\n+            _ => self.parse_ident(),\n+         }\n+     }\n+\n     /// Parses qualified path.\n     ///\n     /// Assumes that the leading `<` has been parsed already.\n@@ -1722,12 +1732,12 @@ impl<'a> Parser<'a> {\n     ///\n     /// `<T as U>::a`\n     /// `<T as U>::F::a::<S>`\n-    pub fn parse_qualified_path(&mut self, mode: PathParsingMode)\n+    pub fn parse_qualified_path(&mut self, mode: PathStyle)\n                                 -> PResult<'a, (QSelf, ast::Path)> {\n         let span = self.last_span;\n         let self_type = self.parse_ty_sum()?;\n         let mut path = if self.eat_keyword(keywords::As) {\n-            self.parse_path(LifetimeAndTypesWithoutColons)?\n+            self.parse_path(PathStyle::Type)?\n         } else {\n             ast::Path {\n                 span: span,\n@@ -1745,14 +1755,14 @@ impl<'a> Parser<'a> {\n         self.expect(&token::ModSep)?;\n \n         let segments = match mode {\n-            LifetimeAndTypesWithoutColons => {\n+            PathStyle::Type => {\n                 self.parse_path_segments_without_colons()?\n             }\n-            LifetimeAndTypesWithColons => {\n+            PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n             }\n-            NoTypesAllowed | ImportPrefix => {\n-                self.parse_path_segments_without_types(mode == ImportPrefix)?\n+            PathStyle::Mod => {\n+                self.parse_path_segments_without_types()?\n             }\n         };\n         path.segments.extend(segments);\n@@ -1766,7 +1776,7 @@ impl<'a> Parser<'a> {\n     /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n-    pub fn parse_path(&mut self, mode: PathParsingMode) -> PResult<'a, ast::Path> {\n+    pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n         // Check for a whole path...\n         let found = match self.token {\n             token::Interpolated(token::NtPath(_)) => Some(self.bump_and_get()),\n@@ -1783,14 +1793,14 @@ impl<'a> Parser<'a> {\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n         let segments = match mode {\n-            LifetimeAndTypesWithoutColons => {\n+            PathStyle::Type => {\n                 self.parse_path_segments_without_colons()?\n             }\n-            LifetimeAndTypesWithColons => {\n+            PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n             }\n-            NoTypesAllowed | ImportPrefix => {\n-                self.parse_path_segments_without_types(mode == ImportPrefix)?\n+            PathStyle::Mod => {\n+                self.parse_path_segments_without_types()?\n             }\n         };\n \n@@ -1813,7 +1823,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident_or_self_type()?;\n+            let identifier = self.parse_path_segment_ident()?;\n \n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n@@ -1866,7 +1876,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident_or_self_type()?;\n+            let identifier = self.parse_path_segment_ident()?;\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n@@ -1905,15 +1915,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-\n     /// Examples:\n     /// - `a::b::c`\n-    pub fn parse_path_segments_without_types(&mut self, import_prefix: bool)\n+    pub fn parse_path_segments_without_types(&mut self)\n                                              -> PResult<'a, Vec<ast::PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident_or_self_type()?;\n+            let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n             segments.push(ast::PathSegment {\n@@ -1922,7 +1931,7 @@ impl<'a> Parser<'a> {\n             });\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n-            if !self.check(&token::ModSep) || import_prefix && self.is_import_coupler() {\n+            if !self.check(&token::ModSep) || self.is_import_coupler() {\n                 return Ok(segments);\n             } else {\n                 self.bump();\n@@ -2212,15 +2221,6 @@ impl<'a> Parser<'a> {\n                 let lo = self.span.lo;\n                 return self.parse_lambda_expr(lo, CaptureBy::Ref, attrs);\n             },\n-            token::Ident(id @ ast::Ident {\n-                            name: token::SELF_KEYWORD_NAME,\n-                            ctxt: _\n-                         }, token::Plain) => {\n-                self.bump();\n-                let path = ast::Path::from_ident(mk_sp(lo, hi), id);\n-                ex = ExprKind::Path(None, path);\n-                hi = self.last_span.hi;\n-            }\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n@@ -2263,7 +2263,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 if self.eat_lt() {\n                     let (qself, path) =\n-                        self.parse_qualified_path(LifetimeAndTypesWithColons)?;\n+                        self.parse_qualified_path(PathStyle::Expr)?;\n                     hi = path.span.hi;\n                     return Ok(self.mk_expr(lo, hi, ExprKind::Path(Some(qself), path), attrs));\n                 }\n@@ -2350,12 +2350,8 @@ impl<'a> Parser<'a> {\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n-                } else if self.check(&token::ModSep) ||\n-                        self.token.is_ident() &&\n-                        !self.check_keyword(keywords::True) &&\n-                        !self.check_keyword(keywords::False) {\n-                    let pth =\n-                        self.parse_path(LifetimeAndTypesWithColons)?;\n+                } else if self.token.is_path_start() {\n+                    let pth = self.parse_path(PathStyle::Expr)?;\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.check(&token::Not) {\n@@ -2435,10 +2431,18 @@ impl<'a> Parser<'a> {\n                     hi = pth.span.hi;\n                     ex = ExprKind::Path(None, pth);\n                 } else {\n-                    // other literal expression\n-                    let lit = self.parse_lit()?;\n-                    hi = lit.span.hi;\n-                    ex = ExprKind::Lit(P(lit));\n+                    match self.parse_lit() {\n+                        Ok(lit) => {\n+                            hi = lit.span.hi;\n+                            ex = ExprKind::Lit(P(lit));\n+                        }\n+                        Err(mut err) => {\n+                            err.cancel();\n+                            let msg = format!(\"expected expression, found {}\",\n+                                              self.this_token_descr());\n+                            return Err(self.fatal(&msg));\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -2577,7 +2581,7 @@ impl<'a> Parser<'a> {\n             // expr.f\n             if self.eat(&token::Dot) {\n                 match self.token {\n-                  token::Ident(i, _) => {\n+                  token::Ident(i) => {\n                     let dot_pos = self.last_span.hi;\n                     hi = self.span.hi;\n                     self.bump();\n@@ -2632,7 +2636,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n \n                     let dot_pos = self.last_span.hi;\n-                    e = self.parse_dot_suffix(special_idents::invalid,\n+                    e = self.parse_dot_suffix(keywords::Invalid.ident(),\n                                               mk_sp(dot_pos, dot_pos),\n                                               e, lo)?;\n                   }\n@@ -2674,7 +2678,7 @@ impl<'a> Parser<'a> {\n     // Parse unquoted tokens after a `$` in a token tree\n     fn parse_unquoted(&mut self) -> PResult<'a, TokenTree> {\n         let mut sp = self.span;\n-        let (name, namep) = match self.token {\n+        let name = match self.token {\n             token::Dollar => {\n                 self.bump();\n \n@@ -2694,40 +2698,36 @@ impl<'a> Parser<'a> {\n                                           op: repeat,\n                                           num_captures: name_num\n                                       })));\n-                } else if self.token.is_keyword_allow_following_colon(keywords::Crate) {\n+                } else if self.token.is_keyword(keywords::Crate) {\n                     self.bump();\n                     return Ok(TokenTree::Token(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar)));\n                 } else {\n                     sp = mk_sp(sp.lo, self.span.hi);\n-                    let namep = match self.token { token::Ident(_, p) => p, _ => token::Plain };\n-                    let name = self.parse_ident()?;\n-                    (name, namep)\n+                    self.parse_ident()?\n                 }\n             }\n-            token::SubstNt(name, namep) => {\n+            token::SubstNt(name) => {\n                 self.bump();\n-                (name, namep)\n+                name\n             }\n             _ => unreachable!()\n         };\n         // continue by trying to parse the `:ident` after `$name`\n-        if self.token == token::Colon && self.look_ahead(1, |t| t.is_ident() &&\n-                                                                !t.is_strict_keyword() &&\n-                                                                !t.is_reserved_keyword()) {\n+        if self.token == token::Colon &&\n+                self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword()) {\n             self.bump();\n             sp = mk_sp(sp.lo, self.span.hi);\n-            let kindp = match self.token { token::Ident(_, p) => p, _ => token::Plain };\n             let nt_kind = self.parse_ident()?;\n-            Ok(TokenTree::Token(sp, MatchNt(name, nt_kind, namep, kindp)))\n+            Ok(TokenTree::Token(sp, MatchNt(name, nt_kind)))\n         } else {\n-            Ok(TokenTree::Token(sp, SubstNt(name, namep)))\n+            Ok(TokenTree::Token(sp, SubstNt(name)))\n         }\n     }\n \n     pub fn check_unknown_macro_variable(&mut self) {\n         if self.quote_depth == 0 {\n             match self.token {\n-                token::SubstNt(name, _) =>\n+                token::SubstNt(name) =>\n                     self.fatal(&format!(\"unknown macro variable `{}`\", name)).emit(),\n                 _ => {}\n             }\n@@ -3590,16 +3590,16 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.is_path_start() {\n+        if self.token.is_path_start() {\n             let lo = self.span.lo;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n                 let (qself, path) =\n-                    self.parse_qualified_path(NoTypesAllowed)?;\n+                    self.parse_qualified_path(PathStyle::Expr)?;\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n-                (None, self.parse_path(LifetimeAndTypesWithColons)?)\n+                (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.last_span.hi;\n             Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), None))\n@@ -3608,12 +3608,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_path_start(&self) -> bool {\n-        (self.token == token::Lt || self.token == token::ModSep\n-            || self.token.is_ident() || self.token.is_path())\n-            && !self.token.is_keyword(keywords::True) && !self.token.is_keyword(keywords::False)\n-    }\n-\n     /// Parse a pattern.\n     pub fn parse_pat(&mut self) -> PResult<'a, P<Pat>> {\n         maybe_whole!(self, NtPat);\n@@ -3664,19 +3658,16 @@ impl<'a> Parser<'a> {\n                 // Parse box pat\n                 let subpat = self.parse_pat()?;\n                 pat = PatKind::Box(subpat);\n-            } else if self.is_path_start() {\n+            } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n-                if self.token.is_plain_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n+                if self.token.is_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n                         *t != token::OpenDelim(token::Brace) &&\n                         *t != token::OpenDelim(token::Paren) &&\n-                        // Contrary to its definition, a plain ident can be followed by :: in macros\n                         *t != token::ModSep) {\n                     // Plain idents have some extra abilities here compared to general paths\n                     if self.look_ahead(1, |t| *t == token::Not) {\n                         // Parse macro invocation\n-                        let ident = self.parse_ident()?;\n-                        let ident_span = self.last_span;\n-                        let path = ast::Path::from_ident(ident_span, ident);\n+                        let path = self.parse_ident_into_path()?;\n                         self.bump();\n                         let delim = self.expect_open_delim()?;\n                         let tts = self.parse_seq_to_end(\n@@ -3696,11 +3687,11 @@ impl<'a> Parser<'a> {\n                     let (qself, path) = if self.eat_lt() {\n                         // Parse a qualified path\n                         let (qself, path) =\n-                            self.parse_qualified_path(NoTypesAllowed)?;\n+                            self.parse_qualified_path(PathStyle::Expr)?;\n                         (Some(qself), path)\n                     } else {\n                         // Parse an unqualified path\n-                        (None, self.parse_path(LifetimeAndTypesWithColons)?)\n+                        (None, self.parse_path(PathStyle::Expr)?)\n                     };\n                     match self.token {\n                       token::DotDotDot => {\n@@ -3757,12 +3748,20 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n-                let begin = self.parse_pat_literal_maybe_minus()?;\n-                if self.eat(&token::DotDotDot) {\n-                    let end = self.parse_pat_range_end()?;\n-                    pat = PatKind::Range(begin, end);\n-                } else {\n-                    pat = PatKind::Lit(begin);\n+                match self.parse_pat_literal_maybe_minus() {\n+                    Ok(begin) => {\n+                        if self.eat(&token::DotDotDot) {\n+                            let end = self.parse_pat_range_end()?;\n+                            pat = PatKind::Range(begin, end);\n+                        } else {\n+                            pat = PatKind::Lit(begin);\n+                        }\n+                    }\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        let msg = format!(\"expected pattern, found {}\", self.this_token_descr());\n+                        return Err(self.fatal(&msg));\n+                    }\n                 }\n             }\n           }\n@@ -3959,11 +3958,11 @@ impl<'a> Parser<'a> {\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_path(NoTypesAllowed)?;\n+            let pth = self.parse_ident_into_path()?;\n             self.bump();\n \n             let id = match self.token {\n-                token::OpenDelim(_) => token::special_idents::invalid, // no special identifier\n+                token::OpenDelim(_) => keywords::Invalid.ident(), // no special identifier\n                 _ => self.parse_ident()?,\n             };\n \n@@ -3975,7 +3974,7 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n-                    let ident_str = if id.name == token::special_idents::invalid.name {\n+                    let ident_str = if id.name == keywords::Invalid.name() {\n                         \"identifier, \"\n                     } else {\n                         \"\"\n@@ -4001,7 +4000,7 @@ impl<'a> Parser<'a> {\n                 MacStmtStyle::NoBraces\n             };\n \n-            if id.name == token::special_idents::invalid.name {\n+            if id.name == keywords::Invalid.name() {\n                 let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n                 let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n                 spanned(lo, hi, stmt)\n@@ -4243,7 +4242,7 @@ impl<'a> Parser<'a> {\n                                         -> PResult<'a, TyParamBounds>\n     {\n         if !self.eat(&token::Colon) {\n-            Ok(P::empty())\n+            Ok(P::new())\n         } else {\n             self.parse_ty_param_bounds(mode)\n         }\n@@ -4629,17 +4628,12 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn is_self_ident(&mut self) -> bool {\n-        match self.token {\n-          token::Ident(id, token::Plain) => id.name == special_idents::self_.name,\n-          _ => false\n-        }\n-    }\n-\n     fn expect_self_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(id, token::Plain) if id.name == special_idents::self_.name => {\n+            token::Ident(id) if id.name == keywords::SelfValue.name() => {\n                 self.bump();\n+                // The hygiene context of `id` needs to be preserved here,\n+                // so we can't just return `SelfValue.ident()`.\n                 Ok(id)\n             },\n             _ => {\n@@ -4650,27 +4644,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_self_type_ident(&mut self) -> bool {\n-        match self.token {\n-          token::Ident(id, token::Plain) => id.name == special_idents::type_self.name,\n-          _ => false\n-        }\n-    }\n-\n-    fn expect_self_type_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.token {\n-            token::Ident(id, token::Plain) if id.name == special_idents::type_self.name => {\n-                self.bump();\n-                Ok(id)\n-            },\n-            _ => {\n-                let token_str = self.this_token_to_string();\n-                Err(self.fatal(&format!(\"expected `Self`, found `{}`\",\n-                                   token_str)))\n-            }\n-        }\n-    }\n-\n     /// Parse the argument list and result type of a function\n     /// that may have a self type.\n     fn parse_fn_decl_with_self<F>(&mut self,\n@@ -4739,16 +4712,16 @@ impl<'a> Parser<'a> {\n                 } else {\n                     Mutability::Immutable\n                 };\n-                if self.is_self_ident() {\n+                if self.token.is_keyword(keywords::SelfValue) {\n                     let span = self.span;\n                     self.span_err(span, \"cannot pass self by raw pointer\");\n                     self.bump();\n                 }\n                 // error case, making bogus self ident:\n-                SelfKind::Value(special_idents::self_)\n+                SelfKind::Value(keywords::SelfValue.ident())\n             }\n             token::Ident(..) => {\n-                if self.is_self_ident() {\n+                if self.token.is_keyword(keywords::SelfValue) {\n                     let self_ident = self.expect_self_ident()?;\n \n                     // Determine whether this is the fully explicit form, `self:\n@@ -4972,7 +4945,7 @@ impl<'a> Parser<'a> {\n             Visibility::Inherited => (),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n-                    token::Ident(sid, _) => sid.name == intern(\"macro_rules\"),\n+                    token::Ident(sid) => sid.name == intern(\"macro_rules\"),\n                     _ => false,\n                 };\n                 if is_macro_rules {\n@@ -5005,7 +4978,7 @@ impl<'a> Parser<'a> {\n             self.complain_if_pub_macro(&vis, last_span);\n \n             let lo = self.span.lo;\n-            let pth = self.parse_path(NoTypesAllowed)?;\n+            let pth = self.parse_ident_into_path()?;\n             self.expect(&token::Not)?;\n \n             // eat a matched-delimiter token tree:\n@@ -5020,7 +4993,7 @@ impl<'a> Parser<'a> {\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n-            Ok((token::special_idents::invalid, vec![], ast::ImplItemKind::Macro(m)))\n+            Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(m)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n@@ -5115,7 +5088,7 @@ impl<'a> Parser<'a> {\n \n             self.expect(&token::OpenDelim(token::Brace))?;\n             self.expect(&token::CloseDelim(token::Brace))?;\n-            Ok((special_idents::invalid,\n+            Ok((keywords::Invalid.ident(),\n              ItemKind::DefaultImpl(unsafety, opt_trait.unwrap()), None))\n         } else {\n             if opt_trait.is_some() {\n@@ -5131,7 +5104,7 @@ impl<'a> Parser<'a> {\n                 impl_items.push(self.parse_impl_item()?);\n             }\n \n-            Ok((special_idents::invalid,\n+            Ok((keywords::Invalid.ident(),\n              ItemKind::Impl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n              Some(attrs)))\n         }\n@@ -5140,7 +5113,7 @@ impl<'a> Parser<'a> {\n     /// Parse a::B<String,i32>\n     fn parse_trait_ref(&mut self) -> PResult<'a, TraitRef> {\n         Ok(ast::TraitRef {\n-            path: self.parse_path(LifetimeAndTypesWithoutColons)?,\n+            path: self.parse_path(PathStyle::Type)?,\n             ref_id: ast::DUMMY_NODE_ID,\n         })\n     }\n@@ -5300,16 +5273,15 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Paren))?;\n             Ok(Visibility::Crate(span))\n         } else {\n-            let path = self.with_res(Restrictions::ALLOW_MODULE_PATHS,\n-                                     |this| this.parse_path(NoTypesAllowed))?;\n+            let path = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::CloseDelim(token::Paren))?;\n             Ok(Visibility::Restricted { path: P(path), id: ast::DUMMY_NODE_ID })\n         }\n     }\n \n     /// Parse defaultness: DEFAULT or nothing\n     fn parse_defaultness(&mut self) -> PResult<'a, Defaultness> {\n-        if self.eat_contextual_keyword(special_idents::DEFAULT) {\n+        if self.eat_contextual_keyword(keywords::Default.ident()) {\n             Ok(Defaultness::Default)\n         } else {\n             Ok(Defaultness::Final)\n@@ -5637,7 +5609,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(self.mk_item(lo,\n                      last_span.hi,\n-                     special_idents::invalid,\n+                     keywords::Invalid.ident(),\n                      ItemKind::ForeignMod(m),\n                      visibility,\n                      attrs))\n@@ -5776,7 +5748,7 @@ impl<'a> Parser<'a> {\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n-                                    token::special_idents::invalid,\n+                                    keywords::Invalid.ident(),\n                                     item_,\n                                     visibility,\n                                     attrs);\n@@ -6047,7 +6019,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, Option<P<Item>>> {\n         if macros_allowed && !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n-                && (self.look_ahead(2, |t| t.is_plain_ident())\n+                && (self.look_ahead(2, |t| t.is_ident())\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n             // MACRO INVOCATION ITEM\n@@ -6058,16 +6030,16 @@ impl<'a> Parser<'a> {\n             let mac_lo = self.span.lo;\n \n             // item macro.\n-            let pth = self.parse_path(NoTypesAllowed)?;\n+            let pth = self.parse_ident_into_path()?;\n             self.expect(&token::Not)?;\n \n             // a 'special' identifier (like what `macro_rules!` uses)\n             // is optional. We should eventually unify invoc syntax\n             // and remove this.\n-            let id = if self.token.is_plain_ident() {\n+            let id = if self.token.is_ident() {\n                 self.parse_ident()?\n             } else {\n-                token::special_idents::invalid // no special identifier\n+                keywords::Invalid.ident() // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n             let delim = self.expect_open_delim()?;\n@@ -6164,7 +6136,7 @@ impl<'a> Parser<'a> {\n             let items = self.parse_path_list_items()?;\n             Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n         } else {\n-            let prefix = self.parse_path(ImportPrefix)?;\n+            let prefix = self.parse_path(PathStyle::Mod)?;\n             if self.is_import_coupler() {\n                 // `foo::bar::{a, b}` or `foo::bar::*`\n                 self.bump();"}, {"sha": "fcb6c3539db5931be0219ceee5f7f700c2f8111d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 110, "deletions": 248, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,7 +11,6 @@\n pub use self::BinOpToken::*;\n pub use self::Nonterminal::*;\n pub use self::DelimToken::*;\n-pub use self::IdentStyle::*;\n pub use self::Lit::*;\n pub use self::Token::*;\n \n@@ -26,7 +25,6 @@ use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n \n-#[allow(non_camel_case_types)]\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum BinOpToken {\n     Plus,\n@@ -52,13 +50,6 @@ pub enum DelimToken {\n     Brace,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n-pub enum IdentStyle {\n-    /// `::` follows the identifier with no whitespace in-between.\n-    ModName,\n-    Plain,\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum SpecialMacroVar {\n     /// `$crate` will be filled in with the name of the crate a macro was\n@@ -99,7 +90,6 @@ impl Lit {\n     }\n }\n \n-#[allow(non_camel_case_types)]\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n@@ -141,7 +131,7 @@ pub enum Token {\n     Literal(Lit, Option<ast::Name>),\n \n     /* Name components */\n-    Ident(ast::Ident, IdentStyle),\n+    Ident(ast::Ident),\n     Underscore,\n     Lifetime(ast::Ident),\n \n@@ -151,11 +141,11 @@ pub enum Token {\n     /// Doc comment\n     DocComment(ast::Name),\n     // In left-hand-sides of MBE macros:\n-    /// Parse a nonterminal (name to bind, name of NT, styles of their idents)\n-    MatchNt(ast::Ident, ast::Ident, IdentStyle, IdentStyle),\n+    /// Parse a nonterminal (name to bind, name of NT)\n+    MatchNt(ast::Ident, ast::Ident),\n     // In right-hand-sides of MBE macros:\n     /// A syntactic variable that will be filled in by macro expansion.\n-    SubstNt(ast::Ident, IdentStyle),\n+    SubstNt(ast::Ident),\n     /// A macro variable with special meaning.\n     SpecialVarNt(SpecialMacroVar),\n \n@@ -185,7 +175,7 @@ impl Token {\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n             OpenDelim(_)                => true,\n-            Ident(_, _)                 => true,\n+            Ident(..)                   => true,\n             Underscore                  => true,\n             Tilde                       => true,\n             Literal(_, _)               => true,\n@@ -218,7 +208,7 @@ impl Token {\n     /// Returns `true` if the token is an identifier.\n     pub fn is_ident(&self) -> bool {\n         match *self {\n-            Ident(_, _) => true,\n+            Ident(..)   => true,\n             _           => false,\n         }\n     }\n@@ -239,16 +229,6 @@ impl Token {\n         }\n     }\n \n-    /// Returns `true` if the token is a path that is not followed by a `::`\n-    /// token.\n-    #[allow(non_upper_case_globals)]\n-    pub fn is_plain_ident(&self) -> bool {\n-        match *self {\n-            Ident(_, Plain) => true,\n-            _               => false,\n-        }\n-    }\n-\n     /// Returns `true` if the token is a lifetime.\n     pub fn is_lifetime(&self) -> bool {\n         match *self {\n@@ -263,6 +243,11 @@ impl Token {\n         self.is_keyword(keywords::Const)\n     }\n \n+    pub fn is_path_start(&self) -> bool {\n+        self == &ModSep || self == &Lt || self.is_path() ||\n+        self.is_path_segment_keyword() || self.is_ident() && !self.is_any_keyword()\n+    }\n+\n     /// Maps a token to its corresponding binary operator.\n     pub fn to_binop(&self) -> Option<BinOpKind> {\n         match *self {\n@@ -289,77 +274,41 @@ impl Token {\n     }\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n-    #[allow(non_upper_case_globals)]\n     pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n         match *self {\n-            Ident(sid, Plain) => kw.to_name() == sid.name,\n-            _                      => false,\n+            Ident(id) => id.name == kw.name(),\n+            _ => false,\n         }\n     }\n \n-    pub fn is_keyword_allow_following_colon(&self, kw: keywords::Keyword) -> bool {\n+    pub fn is_path_segment_keyword(&self) -> bool {\n         match *self {\n-            Ident(sid, _) => { kw.to_name() == sid.name }\n-            _ => { false }\n+            Ident(id) => id.name == keywords::Super.name() ||\n+                         id.name == keywords::SelfValue.name() ||\n+                         id.name == keywords::SelfType.name(),\n+            _ => false,\n         }\n     }\n \n-    /// Returns `true` if the token is either a special identifier, or a strict\n-    /// or reserved keyword.\n-    #[allow(non_upper_case_globals)]\n+    /// Returns `true` if the token is either a strict or reserved keyword.\n     pub fn is_any_keyword(&self) -> bool {\n-        match *self {\n-            Ident(sid, Plain) => {\n-                let n = sid.name;\n-\n-                   n == SELF_KEYWORD_NAME\n-                || n == STATIC_KEYWORD_NAME\n-                || n == SUPER_KEYWORD_NAME\n-                || n == SELF_TYPE_KEYWORD_NAME\n-                || STRICT_KEYWORD_START <= n\n-                && n <= RESERVED_KEYWORD_FINAL\n-            },\n-            _ => false\n-        }\n+        self.is_strict_keyword() || self.is_reserved_keyword()\n     }\n \n-    /// Returns `true` if the token may not appear as an identifier.\n-    #[allow(non_upper_case_globals)]\n+    /// Returns `true` if the token is a strict keyword.\n     pub fn is_strict_keyword(&self) -> bool {\n         match *self {\n-            Ident(sid, Plain) => {\n-                let n = sid.name;\n-\n-                   n == SELF_KEYWORD_NAME\n-                || n == STATIC_KEYWORD_NAME\n-                || n == SUPER_KEYWORD_NAME\n-                || n == SELF_TYPE_KEYWORD_NAME\n-                || STRICT_KEYWORD_START <= n\n-                && n <= STRICT_KEYWORD_FINAL\n-            },\n-            Ident(sid, ModName) => {\n-                let n = sid.name;\n-\n-                   n != SELF_KEYWORD_NAME\n-                && n != SUPER_KEYWORD_NAME\n-                && STRICT_KEYWORD_START <= n\n-                && n <= STRICT_KEYWORD_FINAL\n-            }\n+            Ident(id) => id.name >= keywords::As.name() &&\n+                         id.name <= keywords::While.name(),\n             _ => false,\n         }\n     }\n \n-    /// Returns `true` if the token is a keyword that has been reserved for\n-    /// possible future use.\n-    #[allow(non_upper_case_globals)]\n+    /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_reserved_keyword(&self) -> bool {\n         match *self {\n-            Ident(sid, Plain) => {\n-                let n = sid.name;\n-\n-                   RESERVED_KEYWORD_START <= n\n-                && n <= RESERVED_KEYWORD_FINAL\n-            },\n+            Ident(id) => id.name >= keywords::Abstract.name() &&\n+                         id.name <= keywords::Yield.name(),\n             _ => false,\n         }\n     }\n@@ -369,7 +318,7 @@ impl Token {\n     /// See `styntax::ext::mtwt`.\n     pub fn mtwt_eq(&self, other : &Token) -> bool {\n         match (self, other) {\n-            (&Ident(id1,_), &Ident(id2,_)) | (&Lifetime(id1), &Lifetime(id2)) =>\n+            (&Ident(id1), &Ident(id2)) | (&Lifetime(id1), &Lifetime(id2)) =>\n                 mtwt::resolve(id1) == mtwt::resolve(id2),\n             _ => *self == *other\n         }\n@@ -385,7 +334,7 @@ pub enum Nonterminal {\n     NtPat(P<ast::Pat>),\n     NtExpr(P<ast::Expr>),\n     NtTy(P<ast::Ty>),\n-    NtIdent(Box<ast::SpannedIdent>, IdentStyle),\n+    NtIdent(Box<ast::SpannedIdent>),\n     /// Stuff inside brackets for attributes\n     NtMeta(P<ast::MetaItem>),\n     NtPath(Box<ast::Path>),\n@@ -422,191 +371,104 @@ impl fmt::Debug for Nonterminal {\n     }\n }\n \n-\n-// Get the first \"argument\"\n-macro_rules! first {\n-    ( $first:expr, $( $remainder:expr, )* ) => ( $first )\n-}\n-\n-// Get the last \"argument\" (has to be done recursively to avoid phoney local ambiguity error)\n-macro_rules! last {\n-    ( $first:expr, $( $remainder:expr, )+ ) => ( last!( $( $remainder, )+ ) );\n-    ( $first:expr, ) => ( $first )\n-}\n-\n // In this macro, there is the requirement that the name (the number) must be monotonically\n // increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n-// except starting from the next number instead of zero, and with the additional exception that\n-// special identifiers are *also* allowed (they are deduplicated in the important place, the\n-// interner), an exception which is demonstrated by \"static\" and \"self\".\n-macro_rules! declare_special_idents_and_keywords {(\n-    // So now, in these rules, why is each definition parenthesised?\n-    // Answer: otherwise we get a spurious local ambiguity bug on the \"}\"\n-    pub mod special_idents {\n-        $( ($si_name:expr, $si_static:ident, $si_str:expr); )*\n-    }\n-\n-    pub mod keywords {\n-        'strict:\n-        $( ($sk_name:expr, $sk_variant:ident, $sk_str:expr); )*\n-        'reserved:\n-        $( ($rk_name:expr, $rk_variant:ident, $rk_str:expr); )*\n-    }\n+// except starting from the next number instead of zero.\n+macro_rules! declare_keywords {(\n+    $( ($index: expr, $konst: ident, $string: expr) )*\n ) => {\n-    const STRICT_KEYWORD_START: ast::Name = first!($( ast::Name($sk_name), )*);\n-    const STRICT_KEYWORD_FINAL: ast::Name = last!($( ast::Name($sk_name), )*);\n-    const RESERVED_KEYWORD_START: ast::Name = first!($( ast::Name($rk_name), )*);\n-    const RESERVED_KEYWORD_FINAL: ast::Name = last!($( ast::Name($rk_name), )*);\n-\n-    pub mod special_idents {\n-        use ast;\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $si_static: ast::Ident = ast::Ident {\n-                name: ast::Name($si_name),\n-                ctxt: ast::EMPTY_CTXT,\n-            };\n-         )*\n-    }\n-\n-    pub mod special_names {\n-        use ast;\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $si_static: ast::Name = ast::Name($si_name);\n-        )*\n-    }\n-\n-    /// All the valid words that have meaning in the Rust language.\n-    ///\n-    /// Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n-    /// appear as identifiers at all. Reserved keywords are not used anywhere in\n-    /// the language and may not appear as identifiers.\n     pub mod keywords {\n-        pub use self::Keyword::*;\n         use ast;\n-\n-        #[derive(Copy, Clone, PartialEq, Eq)]\n-        pub enum Keyword {\n-            $( $sk_variant, )*\n-            $( $rk_variant, )*\n+        #[derive(Clone, Copy, PartialEq, Eq)]\n+        pub struct Keyword {\n+            ident: ast::Ident,\n         }\n-\n         impl Keyword {\n-            pub fn to_name(&self) -> ast::Name {\n-                match *self {\n-                    $( $sk_variant => ast::Name($sk_name), )*\n-                    $( $rk_variant => ast::Name($rk_name), )*\n-                }\n-            }\n+            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n+            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n         }\n+        $(\n+            #[allow(non_upper_case_globals)]\n+            pub const $konst: Keyword = Keyword {\n+                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n+            };\n+        )*\n     }\n \n     fn mk_fresh_ident_interner() -> IdentInterner {\n-        let mut init_vec = Vec::new();\n-        $(init_vec.push($si_str);)*\n-        $(init_vec.push($sk_str);)*\n-        $(init_vec.push($rk_str);)*\n-        interner::StrInterner::prefill(&init_vec[..])\n+        interner::StrInterner::prefill(&[$($string,)*])\n     }\n }}\n \n-// If the special idents get renumbered, remember to modify these two as appropriate\n-pub const SELF_KEYWORD_NAME: ast::Name = ast::Name(SELF_KEYWORD_NAME_NUM);\n-const STATIC_KEYWORD_NAME: ast::Name = ast::Name(STATIC_KEYWORD_NAME_NUM);\n-pub const SUPER_KEYWORD_NAME: ast::Name = ast::Name(SUPER_KEYWORD_NAME_NUM);\n-const SELF_TYPE_KEYWORD_NAME: ast::Name = ast::Name(SELF_TYPE_KEYWORD_NAME_NUM);\n-\n-pub const SELF_KEYWORD_NAME_NUM: u32 = 1;\n-const STATIC_KEYWORD_NAME_NUM: u32 = 2;\n-const SUPER_KEYWORD_NAME_NUM: u32 = 3;\n-const SELF_TYPE_KEYWORD_NAME_NUM: u32 = 10;\n-\n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n // of the reserved words, and thus tagged as \"reserved\".\n-\n-declare_special_idents_and_keywords! {\n-    pub mod special_idents {\n-        // These ones are statics\n-        (0,                          invalid,                \"\");\n-        (super::SELF_KEYWORD_NAME_NUM,   self_,              \"self\");\n-        (super::STATIC_KEYWORD_NAME_NUM, statik,             \"static\");\n-        (super::SUPER_KEYWORD_NAME_NUM, super_,              \"super\");\n-        (4,                          static_lifetime,        \"'static\");\n-\n-        // for matcher NTs\n-        (5,                          tt,                     \"tt\");\n-        (6,                          matchers,               \"matchers\");\n-\n-        // outside of libsyntax\n-        (7,                          clownshoe_abi,          \"__rust_abi\");\n-        (8,                          opaque,                 \"<opaque>\");\n-        (9,                          __unused1,              \"<__unused1>\");\n-        (super::SELF_TYPE_KEYWORD_NAME_NUM, type_self,       \"Self\");\n-        (11,                         prelude_import,         \"prelude_import\");\n-        (12,                         DEFAULT,                \"default\");\n-    }\n-\n-    pub mod keywords {\n-        // These ones are variants of the Keyword enum\n-\n-        'strict:\n-        (13,                         As,         \"as\");\n-        (14,                         Break,      \"break\");\n-        (15,                         Crate,      \"crate\");\n-        (16,                         Else,       \"else\");\n-        (17,                         Enum,       \"enum\");\n-        (18,                         Extern,     \"extern\");\n-        (19,                         False,      \"false\");\n-        (20,                         Fn,         \"fn\");\n-        (21,                         For,        \"for\");\n-        (22,                         If,         \"if\");\n-        (23,                         Impl,       \"impl\");\n-        (24,                         In,         \"in\");\n-        (25,                         Let,        \"let\");\n-        (26,                         Loop,       \"loop\");\n-        (27,                         Match,      \"match\");\n-        (28,                         Mod,        \"mod\");\n-        (29,                         Move,       \"move\");\n-        (30,                         Mut,        \"mut\");\n-        (31,                         Pub,        \"pub\");\n-        (32,                         Ref,        \"ref\");\n-        (33,                         Return,     \"return\");\n-        // Static and Self are also special idents (prefill de-dupes)\n-        (super::STATIC_KEYWORD_NAME_NUM, Static, \"static\");\n-        (super::SELF_KEYWORD_NAME_NUM, SelfValue, \"self\");\n-        (super::SELF_TYPE_KEYWORD_NAME_NUM, SelfType, \"Self\");\n-        (34,                         Struct,     \"struct\");\n-        (super::SUPER_KEYWORD_NAME_NUM, Super,   \"super\");\n-        (35,                         True,       \"true\");\n-        (36,                         Trait,      \"trait\");\n-        (37,                         Type,       \"type\");\n-        (38,                         Unsafe,     \"unsafe\");\n-        (39,                         Use,        \"use\");\n-        (40,                         While,      \"while\");\n-        (41,                         Continue,   \"continue\");\n-        (42,                         Box,        \"box\");\n-        (43,                         Const,      \"const\");\n-        (44,                         Where,      \"where\");\n-        'reserved:\n-        (45,                         Virtual,    \"virtual\");\n-        (46,                         Proc,       \"proc\");\n-        (47,                         Alignof,    \"alignof\");\n-        (48,                         Become,     \"become\");\n-        (49,                         Offsetof,   \"offsetof\");\n-        (50,                         Priv,       \"priv\");\n-        (51,                         Pure,       \"pure\");\n-        (52,                         Sizeof,     \"sizeof\");\n-        (53,                         Typeof,     \"typeof\");\n-        (54,                         Unsized,    \"unsized\");\n-        (55,                         Yield,      \"yield\");\n-        (56,                         Do,         \"do\");\n-        (57,                         Abstract,   \"abstract\");\n-        (58,                         Final,      \"final\");\n-        (59,                         Override,   \"override\");\n-        (60,                         Macro,      \"macro\");\n-    }\n+// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n+// this should be rarely necessary though if the keywords are kept in alphabetic order.\n+declare_keywords! {\n+    // Invalid identifier\n+    (0,  Invalid,        \"\")\n+\n+    // Strict keywords used in the language.\n+    (1,  As,             \"as\")\n+    (2,  Box,            \"box\")\n+    (3,  Break,          \"break\")\n+    (4,  Const,          \"const\")\n+    (5,  Continue,       \"continue\")\n+    (6,  Crate,          \"crate\")\n+    (7,  Else,           \"else\")\n+    (8,  Enum,           \"enum\")\n+    (9,  Extern,         \"extern\")\n+    (10, False,          \"false\")\n+    (11, Fn,             \"fn\")\n+    (12, For,            \"for\")\n+    (13, If,             \"if\")\n+    (14, Impl,           \"impl\")\n+    (15, In,             \"in\")\n+    (16, Let,            \"let\")\n+    (17, Loop,           \"loop\")\n+    (18, Match,          \"match\")\n+    (19, Mod,            \"mod\")\n+    (20, Move,           \"move\")\n+    (21, Mut,            \"mut\")\n+    (22, Pub,            \"pub\")\n+    (23, Ref,            \"ref\")\n+    (24, Return,         \"return\")\n+    (25, SelfValue,      \"self\")\n+    (26, SelfType,       \"Self\")\n+    (27, Static,         \"static\")\n+    (28, Struct,         \"struct\")\n+    (29, Super,          \"super\")\n+    (30, Trait,          \"trait\")\n+    (31, True,           \"true\")\n+    (32, Type,           \"type\")\n+    (33, Unsafe,         \"unsafe\")\n+    (34, Use,            \"use\")\n+    (35, Where,          \"where\")\n+    (36, While,          \"while\")\n+\n+    // Keywords reserved for future use.\n+    (37, Abstract,       \"abstract\")\n+    (38, Alignof,        \"alignof\")\n+    (39, Become,         \"become\")\n+    (40, Do,             \"do\")\n+    (41, Final,          \"final\")\n+    (42, Macro,          \"macro\")\n+    (43, Offsetof,       \"offsetof\")\n+    (44, Override,       \"override\")\n+    (45, Priv,           \"priv\")\n+    (46, Proc,           \"proc\")\n+    (47, Pure,           \"pure\")\n+    (48, Sizeof,         \"sizeof\")\n+    (49, Typeof,         \"typeof\")\n+    (50, Unsized,        \"unsized\")\n+    (51, Virtual,        \"virtual\")\n+    (52, Yield,          \"yield\")\n+\n+    // Weak keywords, have special meaning only in specific contexts.\n+    (53, Default,        \"default\")\n+    (54, StaticLifetime, \"'static\")\n+    (55, Union,          \"union\")\n }\n \n // looks like we can get rid of this completely...\n@@ -779,6 +641,6 @@ mod tests {\n         assert!(Gt.mtwt_eq(&Gt));\n         let a = str_to_ident(\"bac\");\n         let a1 = mark_ident(a,92);\n-        assert!(Ident(a, ModName).mtwt_eq(&Ident(a1, Plain)));\n+        assert!(Ident(a).mtwt_eq(&Ident(a1)));\n     }\n }"}, {"sha": "7bfc58e85c259ead4a75a1cb4c7b070962957e02", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -20,7 +20,7 @@ use attr;\n use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{self, CodeMap, BytePos};\n use errors;\n-use parse::token::{self, BinOpToken, Token, InternedString};\n+use parse::token::{self, keywords, BinOpToken, Token, InternedString};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n@@ -270,14 +270,14 @@ pub fn token_to_string(tok: &Token) -> String {\n         }\n \n         /* Name components */\n-        token::Ident(s, _)          => s.to_string(),\n+        token::Ident(s)             => s.to_string(),\n         token::Lifetime(s)          => s.to_string(),\n         token::Underscore           => \"_\".to_string(),\n \n         /* Other */\n         token::DocComment(s)        => s.to_string(),\n-        token::SubstNt(s, _)        => format!(\"${}\", s),\n-        token::MatchNt(s, t, _, _)  => format!(\"${}:{}\", s, t),\n+        token::SubstNt(s)           => format!(\"${}\", s),\n+        token::MatchNt(s, t)        => format!(\"${}:{}\", s, t),\n         token::Eof                  => \"<eof>\".to_string(),\n         token::Whitespace           => \" \".to_string(),\n         token::Comment              => \"/* */\".to_string(),\n@@ -294,7 +294,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtBlock(ref e)       => block_to_string(&e),\n             token::NtStmt(ref e)        => stmt_to_string(&e),\n             token::NtPat(ref e)         => pat_to_string(&e),\n-            token::NtIdent(ref e, _)    => ident_to_string(e.node),\n+            token::NtIdent(ref e)       => ident_to_string(e.node),\n             token::NtTT(ref e)          => tt_to_string(&e),\n             token::NtArm(ref e)         => arm_to_string(&e),\n             token::NtImplItem(ref e)    => impl_item_to_string(&e),\n@@ -995,7 +995,7 @@ impl<'a> State<'a> {\n             ast::TyKind::BareFn(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: P::empty(),\n+                    ty_params: P::new(),\n                     where_clause: ast::WhereClause {\n                         id: ast::DUMMY_NODE_ID,\n                         predicates: Vec::new(),\n@@ -1488,20 +1488,11 @@ impl<'a> State<'a> {\n \n     pub fn print_tts(&mut self, tts: &[ast::TokenTree]) -> io::Result<()> {\n         self.ibox(0)?;\n-        let mut suppress_space = false;\n         for (i, tt) in tts.iter().enumerate() {\n-            if i != 0 && !suppress_space {\n+            if i != 0 {\n                 space(&mut self.s)?;\n             }\n             self.print_tt(tt)?;\n-            // There should be no space between the module name and the following `::` in paths,\n-            // otherwise imported macros get re-parsed from crate metadata incorrectly (#20701)\n-            suppress_space = match *tt {\n-                TokenTree::Token(_, token::Ident(_, token::ModName)) |\n-                TokenTree::Token(_, token::MatchNt(_, _, _, token::ModName)) |\n-                TokenTree::Token(_, token::SubstNt(_, token::ModName)) => true,\n-                _ => false\n-            }\n         }\n         self.end()\n     }\n@@ -2966,9 +2957,8 @@ impl<'a> State<'a> {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n                 match input.pat.node {\n-                    PatKind::Ident(_, ref path1, _) if\n-                        path1.node.name ==\n-                            parse::token::special_idents::invalid.name => {\n+                    PatKind::Ident(_, ref path1, _)\n+                            if path1.node.name == keywords::Invalid.name() => {\n                         // Do nothing.\n                     }\n                     _ => {\n@@ -3021,7 +3011,7 @@ impl<'a> State<'a> {\n         }\n         let generics = ast::Generics {\n             lifetimes: Vec::new(),\n-            ty_params: P::empty(),\n+            ty_params: P::new(),\n             where_clause: ast::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),"}, {"sha": "9d04cb75daa0e7c3318d804961a89b65ddaf2c85", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -83,10 +83,10 @@ impl<T: 'static> P<T> {\n     }\n }\n \n-impl<T> Deref for P<T> {\n+impl<T: ?Sized> Deref for P<T> {\n     type Target = T;\n \n-    fn deref<'a>(&'a self) -> &'a T {\n+    fn deref(&self) -> &T {\n         &self.ptr\n     }\n }\n@@ -97,11 +97,12 @@ impl<T: 'static + Clone> Clone for P<T> {\n     }\n }\n \n-impl<T: Debug> Debug for P<T> {\n+impl<T: ?Sized + Debug> Debug for P<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        Debug::fmt(&**self, f)\n+        Debug::fmt(&self.ptr, f)\n     }\n }\n+\n impl<T: Display> Display for P<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         Display::fmt(&**self, f)\n@@ -126,19 +127,8 @@ impl<T: Encodable> Encodable for P<T> {\n     }\n }\n \n-\n-impl<T:fmt::Debug> fmt::Debug for P<[T]> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        self.ptr.fmt(fmt)\n-    }\n-}\n-\n impl<T> P<[T]> {\n     pub fn new() -> P<[T]> {\n-        P::empty()\n-    }\n-\n-    pub fn empty() -> P<[T]> {\n         P { ptr: Default::default() }\n     }\n \n@@ -151,31 +141,11 @@ impl<T> P<[T]> {\n     pub fn into_vec(self) -> Vec<T> {\n         self.ptr.into_vec()\n     }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        &self.ptr\n-    }\n-\n-    pub fn move_iter(self) -> vec::IntoIter<T> {\n-        self.into_vec().into_iter()\n-    }\n-\n-    pub fn map<U, F: FnMut(&T) -> U>(&self, f: F) -> P<[U]> {\n-        self.iter().map(f).collect()\n-    }\n-}\n-\n-impl<T> Deref for P<[T]> {\n-    type Target = [T];\n-\n-    fn deref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n }\n \n impl<T> Default for P<[T]> {\n     fn default() -> P<[T]> {\n-        P::empty()\n+        P::new()\n     }\n }\n "}, {"sha": "84a7b14484828cb754de2202e43acbdbc6719d86", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -14,7 +14,7 @@ use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use codemap;\n use fold::Folder;\n use fold;\n-use parse::token::{intern, InternedString, special_idents};\n+use parse::token::{intern, InternedString, keywords};\n use parse::{token, ParseSess};\n use ptr::P;\n use util::small_vector::SmallVector;\n@@ -148,7 +148,7 @@ impl fold::Folder for PreludeInjector {\n         let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path)));\n         mod_.items.insert(0, P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: special_idents::invalid,\n+            ident: keywords::Invalid.ident(),\n             node: ast::ItemKind::Use(vp),\n             attrs: vec![ast::Attribute {\n                 span: self.span,\n@@ -157,7 +157,9 @@ impl fold::Folder for PreludeInjector {\n                     style: ast::AttrStyle::Outer,\n                     value: P(ast::MetaItem {\n                         span: self.span,\n-                        node: ast::MetaItemKind::Word(special_idents::prelude_import.name.as_str()),\n+                        node: ast::MetaItemKind::Word(\n+                            token::intern_and_get_ident(\"prelude_import\")\n+                        ),\n                     }),\n                     is_sugared_doc: false,\n                 },"}, {"sha": "8eeb61e0de46c3616f0ba6b4b3aeef46d7ef5288", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -31,7 +31,7 @@ use ext::expand::ExpansionConfig;\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n-use parse::token::{intern, InternedString};\n+use parse::token::{intern, keywords, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;\n use ast;\n@@ -116,7 +116,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n     fn fold_item(&mut self, i: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         let ident = i.ident;\n-        if ident.name != token::special_idents::invalid.name {\n+        if ident.name != keywords::Invalid.name() {\n             self.cx.path.push(ident);\n         }\n         debug!(\"current path: {}\", path_name_i(&self.cx.path));\n@@ -160,7 +160,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             ast::ItemKind::Mod(..) => fold::noop_fold_item(i, self),\n             _ => SmallVector::one(i),\n         };\n-        if ident.name != token::special_idents::invalid.name {\n+        if ident.name != keywords::Invalid.name() {\n             self.cx.path.pop();\n         }\n         res\n@@ -453,7 +453,7 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n         (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n                                          path_node(vec!(id_test)))))),\n-         ast::Visibility::Public, token::special_idents::invalid)\n+         ast::Visibility::Public, keywords::Invalid.ident())\n     } else {\n         (ast::ItemKind::ExternCrate(None), ast::Visibility::Inherited, id_test)\n     };\n@@ -545,7 +545,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n \n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: token::special_idents::invalid,\n+            ident: keywords::Invalid.ident(),\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n             vis: ast::Visibility::Inherited,\n@@ -590,7 +590,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n                                                     ecx.ident_of(\"test\"),\n                                                     ecx.ident_of(\"TestDescAndFn\")]));\n-    let static_lt = ecx.lifetime(sp, token::special_idents::static_lifetime.name);\n+    let static_lt = ecx.lifetime(sp, keywords::StaticLifetime.name());\n     // &'static [self::test::TestDescAndFn]\n     let static_type = ecx.ty_rptr(sp,\n                                   ecx.ty(sp, ast::TyKind::Vec(struct_type)),"}, {"sha": "dce808756cf6a0a2ee0a89cb425a00b2ba75d981", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -40,7 +40,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n             }\n         } else {\n             match *e {\n-                TokenTree::Token(_, token::Ident(ident, _)) => {\n+                TokenTree::Token(_, token::Ident(ident)) => {\n                     res_str.push_str(&ident.name.as_str())\n                 },\n                 _ => {"}, {"sha": "5251b0d08d4497abd09794ed32a62b3a55c6c28c", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -201,8 +201,7 @@ use syntax::codemap::{self, DUMMY_SP};\n use syntax::codemap::Span;\n use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{intern, InternedString};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{intern, keywords, InternedString};\n use syntax::ptr::P;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n@@ -526,7 +525,7 @@ impl<'a> TraitDef<'a> {\n                         span: self.span,\n                         bound_lifetimes: wb.bound_lifetimes.clone(),\n                         bounded_ty: wb.bounded_ty.clone(),\n-                        bounds: P::from_vec(wb.bounds.iter().cloned().collect())\n+                        bounds: wb.bounds.iter().cloned().collect(),\n                     })\n                 }\n                 ast::WherePredicate::RegionPredicate(ref rb) => {\n@@ -596,9 +595,9 @@ impl<'a> TraitDef<'a> {\n         let trait_ref = cx.trait_ref(trait_path);\n \n         // Create the type parameters on the `self` path.\n-        let self_ty_params = generics.ty_params.map(|ty_param| {\n+        let self_ty_params = generics.ty_params.iter().map(|ty_param| {\n             cx.ty_ident(self.span, ty_param.ident)\n-        });\n+        }).collect();\n \n         let self_lifetimes: Vec<ast::Lifetime> =\n             generics.lifetimes\n@@ -609,7 +608,7 @@ impl<'a> TraitDef<'a> {\n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n             cx.path_all(self.span, false, vec!( type_ident ), self_lifetimes,\n-                        self_ty_params.into_vec(), Vec::new()));\n+                        self_ty_params, Vec::new()));\n \n         let attr = cx.attribute(\n             self.span,\n@@ -635,7 +634,7 @@ impl<'a> TraitDef<'a> {\n \n         cx.item(\n             self.span,\n-            special_idents::invalid,\n+            keywords::Invalid.ident(),\n             a,\n             ast::ItemKind::Impl(unsafety,\n                                 ast::ImplPolarity::Positive,\n@@ -866,7 +865,7 @@ impl<'a> MethodDef<'a> {\n             // creating fresh self id\n             _ => Some(ast::Arg::new_self(trait_.span,\n                                          ast::Mutability::Immutable,\n-                                         special_idents::self_))\n+                                         keywords::SelfValue.ident()))\n         };\n         let args = {\n             let args = arg_types.into_iter().map(|(name, ty)| {"}, {"sha": "e31d45d91a59f4ef8baf5feb1dad48180ed11b0a", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -19,7 +19,7 @@ use syntax::ast::{Expr,Generics,Ident};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{Span,respan};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n use syntax::ptr::P;\n \n /// The types of pointers\n@@ -169,15 +169,14 @@ impl<'a> Ty<'a> {\n                    -> ast::Path {\n         match *self {\n             Self_ => {\n-                let self_params = self_generics.ty_params.map(|ty_param| {\n+                let self_params = self_generics.ty_params.iter().map(|ty_param| {\n                     cx.ty_ident(span, ty_param.ident)\n-                });\n+                }).collect();\n                 let lifetimes = self_generics.lifetimes.iter()\n                                                        .map(|d| d.lifetime)\n                                                        .collect();\n \n-                cx.path_all(span, false, vec!(self_ty), lifetimes,\n-                            self_params.into_vec(), Vec::new())\n+                cx.path_all(span, false, vec![self_ty], lifetimes, self_params, Vec::new())\n             }\n             Literal(ref p) => {\n                 p.to_path(cx, span, self_ty, self_generics)\n@@ -264,15 +263,15 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfKind::Value(special_idents::self_)))\n+            (self_path, respan(span, ast::SelfKind::Value(keywords::SelfValue.ident())))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        ast::SelfKind::Region(lt, mutbl, special_idents::self_)\n+                        ast::SelfKind::Region(lt, mutbl, keywords::SelfValue.ident())\n                     }\n                     Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\")\n                 });"}, {"sha": "6c61d6b914c5638fdedff38e3f258b9d032000fa", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -19,8 +19,7 @@ use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::fold::Folder;\n-use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n \n use std::collections::HashMap;\n@@ -106,7 +105,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         if named || (p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq)) {\n             named = true;\n             let ident = match p.token {\n-                token::Ident(i, _) => {\n+                token::Ident(i) => {\n                     p.bump();\n                     i\n                 }\n@@ -449,7 +448,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let sp = piece_ty.span;\n         let ty = ecx.ty_rptr(sp,\n             ecx.ty(sp, ast::TyKind::Vec(piece_ty)),\n-            Some(ecx.lifetime(sp, special_idents::static_lifetime.name)),\n+            Some(ecx.lifetime(sp, keywords::StaticLifetime.name())),\n             ast::Mutability::Immutable);\n         let slice = ecx.expr_vec_slice(sp, pieces);\n         // static instead of const to speed up codegen by not requiring this to be inlined\n@@ -475,7 +474,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n-        let static_lifetime = self.ecx.lifetime(self.fmtsp, special_idents::static_lifetime.name);\n+        let static_lifetime = self.ecx.lifetime(self.fmtsp, keywords::StaticLifetime.name());\n         let piece_ty = self.ecx.ty_rptr(\n                 self.fmtsp,\n                 self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),"}, {"sha": "839ece49c3eb5d4c90cf2fea1321e2c98af91890", "filename": "src/test/auxiliary/roman_numerals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Froman_numerals.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -48,7 +48,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n     }\n \n     let text = match args[0] {\n-        TokenTree::Token(_, token::Ident(s, _)) => s.to_string(),\n+        TokenTree::Token(_, token::Ident(s)) => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);"}, {"sha": "e889d35477059c9ac69f501f81a58c271ae03972", "filename": "src/test/compile-fail/fail-simple.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-// error-pattern:unexpected token\n fn main() {\n-  panic!(@);\n+    panic!(@); //~ ERROR expected expression, found `@`\n }"}, {"sha": "7344f31535fba42fabf4850cc312de76c1fa4ccb", "filename": "src/test/compile-fail/import-ty-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -20,6 +20,6 @@ macro_rules! import {\n     ($p: path) => (use $p;);\n }\n \n-import! { a::b::c::S<u8> } //~ERROR type or lifetime parameter is found in import path\n+import! { a::b::c::S<u8> } //~ERROR type or lifetime parameters in import path\n \n fn main() {}"}, {"sha": "beaf9e5059fa232bead2bb0823e178e9f319e3b3", "filename": "src/test/compile-fail/issue-10636-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -15,4 +15,4 @@ pub fn trace_option(option: Option<isize>) {\n     option.map(|some| 42; //~ NOTE: unclosed delimiter\n                           //~^ ERROR: expected one of\n } //~ ERROR: incorrect close delimiter\n-//~^ ERROR: unexpected token\n+//~^ ERROR: expected expression, found `)`"}, {"sha": "cea52b11c5ded3606b350fd4001cc289858c1dbb", "filename": "src/test/compile-fail/issue-31804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -13,4 +13,4 @@\n \n fn main() {\n     let\n-} //~ ERROR unexpected token: `}`\n+} //~ ERROR expected pattern, found `}`"}, {"sha": "e8af94f16b1b906d85c7b380a0c52d81b1f34557", "filename": "src/test/compile-fail/keyword-false-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fkeyword-false-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fkeyword-false-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-false-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test -- FIXME #33010\n-\n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py false'\n-\n fn main() {\n-    let false = \"foo\"; //~ error: ident\n+    let false = \"foo\"; //~ error: mismatched types\n }"}, {"sha": "90414fa912dba7b396bf6b11beb3a92fdafbb688", "filename": "src/test/compile-fail/keyword-true-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fkeyword-true-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fkeyword-true-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-true-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test -- FIXME #33010\n-\n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py true'\n-\n fn main() {\n-    let true = \"foo\"; //~ error: ident\n+    let true = \"foo\"; //~ error: mismatched types\n }"}, {"sha": "5d07f0747ff435316db7367cd4ea210baa74e02d", "filename": "src/test/compile-fail/macro-context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -12,7 +12,7 @@\n \n // (typeof used because it's surprisingly hard to find an unparsed token after a stmt)\n macro_rules! m {\n-    () => ( i ; typeof );   //~ ERROR `typeof` is a reserved keyword\n+    () => ( i ; typeof );   //~ ERROR expected expression, found reserved keyword `typeof`\n                             //~| ERROR macro expansion ignores token `typeof`\n                             //~| ERROR macro expansion ignores token `;`\n                             //~| ERROR macro expansion ignores token `;`"}, {"sha": "8d515622e53ff5aa0f0967d99575c3f3a7c9822e", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -19,7 +19,7 @@ macro_rules! ignored_item {\n }\n \n macro_rules! ignored_expr {\n-    () => ( 1,  //~ ERROR unexpected token: `,`\n+    () => ( 1,  //~ ERROR expected expression, found `,`\n             2 )\n }\n "}, {"sha": "04d8e9833045a27c49987a6f9edf374e72254ae4", "filename": "src/test/compile-fail/privacy/restricted/ty-params.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// A non-growable owned slice.\n-#[unstable(feature = \"rustc_private\", issue = \"0\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"use `ptr::P<[T]>` instead\")]\n-pub type OwnedSlice<T> = ::ptr::P<[T]>;\n+#![feature(pub_restricted)]\n+\n+macro_rules! m {\n+    ($p: path) => (pub($p) struct Z;)\n+}\n+\n+struct S<T>(T);\n+m!{ S<u8> } //~ ERROR type or lifetime parameters in visibility path\n+\n+fn main() {}", "previous_filename": "src/libsyntax/owned_slice.rs"}, {"sha": "5c661bfcdc0c99c99d0c248d40280b72246fc33c", "filename": "src/test/compile-fail/qualified-path-params-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fqualified-path-params-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fqualified-path-params-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params-2.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that qualified paths with type parameters\n+// fail during type checking and not during parsing\n+\n+struct S;\n+\n+trait Tr {\n+    type A;\n+}\n+\n+impl Tr for S {\n+    type A = S;\n+}\n+\n+impl S {\n+    fn f<T>() {}\n+}\n+\n+type A = <S as Tr>::A::f<u8>; //~ ERROR type parameters are not allowed on this type\n+//~^ ERROR ambiguous associated type; specify the type using the syntax `<<S as Tr>::A as Trait>::f`\n+\n+fn main() {}"}, {"sha": "002080f4cb44c09f647d66dae25c395a94952002", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that qualified paths with type parameters\n+// fail during type checking and not during parsing\n+\n+struct S;\n+\n+trait Tr {\n+    type A;\n+}\n+\n+impl Tr for S {\n+    type A = S;\n+}\n+\n+impl S {\n+    fn f<T>() {}\n+}\n+\n+fn main() {\n+    match 10 {\n+        <S as Tr>::A::f::<u8> => {} //~ ERROR `f` is not an associated const\n+        0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n+    }\n+}"}, {"sha": "bcda61e363def603cda29af5e64f29c479caae54", "filename": "src/test/compile-fail/reserved-become.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Freserved-become.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Freserved-become.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freserved-become.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let become = 0;\n-    //~^ ERROR `become` is a reserved keyword\n+    //~^ ERROR expected pattern, found reserved keyword `become`\n }"}, {"sha": "b9c9d7a389b95dd63ef3375310fd0d454354ceed", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -14,7 +14,7 @@ struct Self;\n //~^ ERROR expected identifier, found keyword `Self`\n \n struct Bar<'Self>;\n-//~^ ERROR invalid lifetime name\n+//~^ ERROR lifetimes cannot use keyword names\n \n pub fn main() {\n     let Self = 5;"}, {"sha": "f5fecf3e1740a8197d0d3f3d2386dac38f1f9227", "filename": "src/test/compile-fail/token-error-correct.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -13,8 +13,10 @@\n fn main() {\n     foo(bar(; //~ NOTE: unclosed delimiter\n     //~^ NOTE: unclosed delimiter\n-    //~^^ ERROR: unexpected token: `;`\n+    //~^^ ERROR: expected expression, found `;`\n     //~^^^ ERROR: unresolved name `bar`\n     //~^^^^ ERROR: unresolved name `foo`\n+    //~^^^^^ ERROR: expected one of `)`, `,`, `.`, `<`, `?`\n } //~ ERROR: incorrect close delimiter: `}`\n //~^ ERROR: incorrect close delimiter: `}`\n+//~^^ ERROR: expected expression, found `)`"}, {"sha": "040db0255678d23e53830588314c9d3c861bb926", "filename": "src/test/compile-fail/use-keyword.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fuse-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fuse-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-keyword.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that imports with nakes super and self don't fail during parsing\n+// FIXME: this shouldn't fail during name resolution either\n+\n+mod a {\n+    mod b {\n+        use self as A; //~ ERROR `self` imports are only allowed within a { } list\n+        //~^ ERROR unresolved import `self`. There is no `self` in the crate root\n+        use super as B; //~ ERROR unresolved import `super`. There is no `super` in the crate root\n+        use super::{self as C}; //~ERROR unresolved import `super`. There is no `super` in the crate\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "146d37f41d638fef9c291710587e3e84b08f7b09", "filename": "src/test/compile-fail/use-mod-4.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n-use foo::self;\n-//~^ ERROR expected identifier, found keyword `self`\n+use foo::self; //~ ERROR unresolved import `foo::self`\n+//~^ ERROR `self` imports are only allowed within a { } list\n \n fn main() {}", "previous_filename": "src/test/parse-fail/use-mod-4.rs"}, {"sha": "346cf1ec555d3853776c0e8ff425e058eb69f200", "filename": "src/test/compile-fail/vec-macro-with-comma-only.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    vec!(,); //~ ERROR unexpected token\n+    vec!(,); //~ ERROR expected expression, found `,`\n }"}, {"sha": "fc2598d1e9d2fa9a5bcbfedafcf9f9a86519d526", "filename": "src/test/parse-fail/issue-10412.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-10412.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,17 +11,17 @@\n // compile-flags: -Z parse-only -Z continue-parse-after-error\n \n \n-trait Serializable<'self, T> { //~ ERROR no longer a special lifetime\n-    fn serialize(val : &'self T) -> Vec<u8> ; //~ ERROR no longer a special lifetime\n-    fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR no longer a special lifetime\n+trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n+    fn serialize(val : &'self T) -> Vec<u8> ; //~ ERROR lifetimes cannot use keyword names\n+    fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR lifetimes cannot use keyword names\n }\n \n-impl<'self> Serializable<str> for &'self str { //~ ERROR no longer a special lifetime\n-    //~^ ERROR no longer a special lifetime\n-    fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR no longer a special lifetime\n+impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n+    //~^ ERROR lifetimes cannot use keyword names\n+    fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR lifetimes cannot use keyword names\n         vec!(1)\n     }\n-    fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR no longer a special lifetime\n+    fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR lifetimes cannot use keyword names\n         \"hi\"\n     }\n }"}, {"sha": "431a917c2d9f4cd9f76633c4a4e48f73e4d9d55f", "filename": "src/test/parse-fail/issue-14303-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -12,4 +12,4 @@\n \n fn bar<'a, T>(x: mymodule::X<'a, T, 'b, 'c>) {}\n //~^ ERROR lifetime parameters must be declared prior to type parameters\n-//~^^ ERROR unexpected token\n+//~^^ ERROR expected pattern, found `'c`"}, {"sha": "246941ff2597dace033288dc3ea1fb70d8579ea4", "filename": "src/test/parse-fail/issue-32505.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fissue-32505.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fissue-32505.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-32505.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,7 +11,7 @@\n // compile-flags: -Z parse-only -Z continue-parse-after-error\n \n pub fn test() {\n-    foo(|_|) //~ ERROR unexpected token: `)`\n+    foo(|_|) //~ ERROR expected expression, found `)`\n }\n \n fn main() { }"}, {"sha": "2db5a5c583ac33b55366b22c92d4a78628b2f1b3", "filename": "src/test/parse-fail/keyword-abstract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-abstract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-abstract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-abstract.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,5 +11,5 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let abstract = (); //~ ERROR `abstract` is a reserved keyword\n+    let abstract = (); //~ ERROR expected pattern, found reserved keyword `abstract`\n }"}, {"sha": "c6070c456e8a03aa0c138c5d42b6d20d76c98836", "filename": "src/test/parse-fail/keyword-as-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-as-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-as-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-as-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py as'\n \n fn main() {\n-    let as = \"foo\"; //~ error: ident\n+    let as = \"foo\"; //~ error: expected pattern, found keyword `as`\n }"}, {"sha": "b5abe14dbe872044a9fc82ee16eccccbe18b87a5", "filename": "src/test/parse-fail/keyword-box-as-identifier.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-box-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-box-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-box-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,6 +10,6 @@\n \n // compile-flags: -Z parse-only\n \n-fn baz(a: &'self isize) { } //~ ERROR invalid lifetime name: 'self is no longer a special lifetime\n-\n-fn main() { }\n+fn main() {\n+    let box = \"foo\"; //~ error: expected pattern, found `=`\n+}", "previous_filename": "src/test/parse-fail/lifetime-obsoleted-self.rs"}, {"sha": "65c775fa1b6cc28d56591997789482da1a6a4d7b", "filename": "src/test/parse-fail/keyword-break-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-break-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-break-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-break-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py break'\n \n fn main() {\n-    let break = \"foo\"; //~ error: ident\n+    let break = \"foo\"; //~ error: expected pattern, found keyword `break`\n }"}, {"sha": "6ecf14957e32b3df13fb89019c74d565d07eb0e3", "filename": "src/test/parse-fail/keyword-const-as-identifier.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-const-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-const-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-const-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-tests.py const'\n+\n+fn main() {\n+    let const = \"foo\"; //~ error: expected pattern, found keyword `const`\n+}"}, {"sha": "87377ac83642fa9a5f3a5377ff69babd19315623", "filename": "src/test/parse-fail/keyword-continue-as-identifier.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-continue-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-continue-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-continue-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-tests.py continue'\n+\n+fn main() {\n+    let continue = \"foo\"; //~ error: expected pattern, found keyword `continue`\n+}"}, {"sha": "8a914ca7b178c099e7868aaf3409a4c962c80da4", "filename": "src/test/parse-fail/keyword-crate-as-identifier.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-crate-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-crate-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-crate-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-tests.py crate'\n+\n+fn main() {\n+    let crate = \"foo\"; //~ error: expected pattern, found keyword `crate`\n+}"}, {"sha": "6878f7fea039dd0fb71e73f83fa2f4d739fbaaa0", "filename": "src/test/parse-fail/keyword-else-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-else-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-else-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-else-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py else'\n \n fn main() {\n-    let else = \"foo\"; //~ error: ident\n+    let else = \"foo\"; //~ error: expected pattern, found keyword `else`\n }"}, {"sha": "042a02d79e00368df73307528156a5b587f847b8", "filename": "src/test/parse-fail/keyword-enum-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-enum-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-enum-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-enum-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py enum'\n \n fn main() {\n-    let enum = \"foo\"; //~ error: ident\n+    let enum = \"foo\"; //~ error: expected pattern, found keyword `enum`\n }"}, {"sha": "3bbe24ed56c633574356417fce6bdfe8137e850c", "filename": "src/test/parse-fail/keyword-extern-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-extern-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-extern-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-extern-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py extern'\n \n fn main() {\n-    let extern = \"foo\"; //~ error: ident\n+    let extern = \"foo\"; //~ error: expected pattern, found keyword `extern`\n }"}, {"sha": "be29a739443e60581e793703d66828a44af1326e", "filename": "src/test/parse-fail/keyword-final.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-final.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-final.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-final.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,5 +11,5 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let final = (); //~ ERROR `final` is a reserved keyword\n+    let final = (); //~ ERROR expected pattern, found reserved keyword `final`\n }"}, {"sha": "0d454f67d1c0541a39e0df0bd81b93a6a1b346dd", "filename": "src/test/parse-fail/keyword-fn-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-fn-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-fn-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-fn-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py fn'\n \n fn main() {\n-    let fn = \"foo\"; //~ error: ident\n+    let fn = \"foo\"; //~ error: expected pattern, found keyword `fn`\n }"}, {"sha": "d341669f7272b8aac9edb7f1b30d2dac8696f30a", "filename": "src/test/parse-fail/keyword-for-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-for-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-for-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-for-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py for'\n \n fn main() {\n-    let for = \"foo\"; //~ error: ident\n+    let for = \"foo\"; //~ error: expected pattern, found keyword `for`\n }"}, {"sha": "417e40425e03b60483d0d4f4337aed086da78fb8", "filename": "src/test/parse-fail/keyword-if-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-if-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-if-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-if-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py if'\n \n fn main() {\n-    let if = \"foo\"; //~ error: ident\n+    let if = \"foo\"; //~ error: expected pattern, found keyword `if`\n }"}, {"sha": "fe97c191f683cd0153c3b0ffdd9b42370aacd852", "filename": "src/test/parse-fail/keyword-impl-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-impl-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-impl-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-impl-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py impl'\n \n fn main() {\n-    let impl = \"foo\"; //~ error: ident\n+    let impl = \"foo\"; //~ error: expected pattern, found keyword `impl`\n }"}, {"sha": "c0f9396b9810092c78305b8b3db84245ce826e37", "filename": "src/test/parse-fail/keyword-in-as-identifier.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-in-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-in-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-in-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-tests.py in'\n+\n+fn main() {\n+    let in = \"foo\"; //~ error: expected pattern, found keyword `in`\n+}"}, {"sha": "5d6dca78d78304445acbfc5588b03ac22fac4e5d", "filename": "src/test/parse-fail/keyword-let-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-let-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-let-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-let-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py let'\n \n fn main() {\n-    let let = \"foo\"; //~ error: ident\n+    let let = \"foo\"; //~ error: expected pattern, found keyword `let`\n }"}, {"sha": "7c3d11d67f61c5b8e269c92e874a6023aacec778", "filename": "src/test/parse-fail/keyword-loop-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-loop-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-loop-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-loop-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py loop'\n \n fn main() {\n-    let loop = \"foo\"; //~ error: ident\n+    let loop = \"foo\"; //~ error: expected pattern, found keyword `loop`\n }"}, {"sha": "7c727f44da76404ecf6d3bfd526cf98445395dca", "filename": "src/test/parse-fail/keyword-match-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-match-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-match-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-match-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py match'\n \n fn main() {\n-    let match = \"foo\"; //~ error: ident\n+    let match = \"foo\"; //~ error: expected pattern, found keyword `match`\n }"}, {"sha": "85b4cc2e02c6a9def5a4890599bf676e4f9ad54f", "filename": "src/test/parse-fail/keyword-mod-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-mod-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-mod-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-mod-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py mod'\n \n fn main() {\n-    let mod = \"foo\"; //~ error: ident\n+    let mod = \"foo\"; //~ error: expected pattern, found keyword `mod`\n }"}, {"sha": "b785ac0058ccb6f909a21b2f10cda6e4ce6f29d8", "filename": "src/test/parse-fail/keyword-move-as-identifier.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-move-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-move-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-move-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-tests.py move'\n+\n+fn main() {\n+    let move = \"foo\"; //~ error: expected pattern, found keyword `move`\n+}"}, {"sha": "0aeca9b34ab8c6d8588a97012b5809547ceceb21", "filename": "src/test/parse-fail/keyword-mut-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-mut-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-mut-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-mut-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // compile-flags: -Z parse-only\n \n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py mut'\n-\n fn main() {\n-    let mut = \"foo\"; //~ error: ident\n+    let mut = \"foo\"; //~ error: expected identifier, found `=`\n }"}, {"sha": "60333762b33e087e848de71688c2d6b544c638b5", "filename": "src/test/parse-fail/keyword-override.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-override.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-override.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-override.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,5 +11,5 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let override = (); //~ ERROR `override` is a reserved keyword\n+    let override = (); //~ ERROR expected pattern, found reserved keyword `override`\n }"}, {"sha": "9233728697026bdc7d5ac64229e86bea0f57ad37", "filename": "src/test/parse-fail/keyword-pub-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-pub-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-pub-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-pub-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py pub'\n \n fn main() {\n-    let pub = \"foo\"; //~ error: ident\n+    let pub = \"foo\"; //~ error: expected pattern, found keyword `pub`\n }"}, {"sha": "a689c4eeea4130ca16a01dd04ec3f70a9adc4449", "filename": "src/test/parse-fail/keyword-ref-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-ref-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-ref-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-ref-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // compile-flags: -Z parse-only\n \n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py ref'\n-\n fn main() {\n-    let ref = \"foo\"; //~ error: ident\n+    let ref = \"foo\"; //~ error: expected identifier, found `=`\n }"}, {"sha": "bcf7f13754315609db8fc75d5b61982b189afd99", "filename": "src/test/parse-fail/keyword-return-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-return-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-return-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-return-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py return'\n \n fn main() {\n-    let return = \"foo\"; //~ error: ident\n+    let return = \"foo\"; //~ error: expected pattern, found keyword `return`\n }"}, {"sha": "f8b93a1796bfe1575bfdf626508f31ae36b8420d", "filename": "src/test/parse-fail/keyword-self-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-self-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-self-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-self-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // compile-flags: -Z parse-only\n \n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py self'\n-\n fn main() {\n-    let self = \"foo\"; //~ error: ident\n+    let Self = \"foo\"; //~ error: expected identifier, found keyword `Self`\n }"}, {"sha": "793262266a39f6506348644cad2b1e7e8c577eed", "filename": "src/test/parse-fail/keyword-static-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-static-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-static-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-static-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py static'\n \n fn main() {\n-    let static = \"foo\"; //~ error: ident\n+    let static = \"foo\"; //~ error: expected pattern, found keyword `static`\n }"}, {"sha": "591bd25db65dab984d7e8ec5489d935f509a3abd", "filename": "src/test/parse-fail/keyword-struct-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-struct-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-struct-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-struct-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py struct'\n \n fn main() {\n-    let struct = \"foo\"; //~ error: ident\n+    let struct = \"foo\"; //~ error: expected pattern, found keyword `struct`\n }"}, {"sha": "a48683a4f54dc19ba3243fffbc5bc3c4939b9083", "filename": "src/test/parse-fail/keyword-super-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-super-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-super-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-super-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // compile-flags: -Z parse-only\n \n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py super'\n-\n fn main() {\n-    let super = \"foo\"; //~ error: ident\n+    let super = \"foo\"; //~ error: expected identifier, found keyword `super`\n }"}, {"sha": "bdb5d264b031e7993836382bf97ab70922ab805b", "filename": "src/test/parse-fail/keyword-trait-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-trait-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-trait-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-trait-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py trait'\n \n fn main() {\n-    let trait = \"foo\"; //~ error: ident\n+    let trait = \"foo\"; //~ error: expected pattern, found keyword `trait`\n }"}, {"sha": "2ba99d098deefaa3b73dbc6adfa637b9c487fc20", "filename": "src/test/parse-fail/keyword-type-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-type-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-type-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-type-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py type'\n \n fn main() {\n-    let type = \"foo\"; //~ error: ident\n+    let type = \"foo\"; //~ error: expected pattern, found keyword `type`\n }"}, {"sha": "40e26bd375ae50b8efe12a52af0fe0832bb3a972", "filename": "src/test/parse-fail/keyword-typeof.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-typeof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-typeof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-typeof.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,5 +11,5 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let typeof = (); //~ ERROR `typeof` is a reserved keyword\n+    let typeof = (); //~ ERROR expected pattern, found reserved keyword `typeof`\n }"}, {"sha": "a72723e566ddedb109ef95f24aeafb883ca9c303", "filename": "src/test/parse-fail/keyword-unsafe-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-unsafe-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-unsafe-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-unsafe-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py unsafe'\n \n fn main() {\n-    let unsafe = \"foo\"; //~ error: ident\n+    let unsafe = \"foo\"; //~ error: expected pattern, found keyword `unsafe`\n }"}, {"sha": "de74907ff2097f62e0309e632aafed578353d269", "filename": "src/test/parse-fail/keyword-use-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-use-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-use-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-use-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py use'\n \n fn main() {\n-    let use = \"foo\"; //~ error: ident\n+    let use = \"foo\"; //~ error: expected pattern, found keyword `use`\n }"}, {"sha": "4b7c8920b13cadffcdb407c4f2315cd19fb59a6b", "filename": "src/test/parse-fail/keyword-where-as-identifier.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-where-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-where-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-where-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-tests.py where'\n+\n+fn main() {\n+    let where = \"foo\"; //~ error: expected pattern, found keyword `where`\n+}"}, {"sha": "01793caa38a8ae5132f31ee062dd3dc038d7dd8e", "filename": "src/test/parse-fail/keyword-while-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-while-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeyword-while-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-while-as-identifier.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,5 +13,5 @@\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py while'\n \n fn main() {\n-    let while = \"foo\"; //~ error: ident\n+    let while = \"foo\"; //~ error: expected pattern, found keyword `while`\n }"}, {"sha": "bb8a1dfdb19063485201351b6b11250080446486", "filename": "src/test/parse-fail/keywords-followed-by-double-colon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeywords-followed-by-double-colon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fkeywords-followed-by-double-colon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeywords-followed-by-double-colon.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     struct::foo();  //~ ERROR expected identifier\n-    mut::baz(); //~ ERROR expected identifier\n+    mut::baz(); //~ ERROR expected expression, found keyword `mut`\n }"}, {"sha": "9ca81d9918ef32c68255697f9e2a23c81a8ac9bd", "filename": "src/test/parse-fail/lifetime-no-keyword.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -12,6 +12,7 @@\n \n fn foo<'a>(a: &'a isize) { }\n fn bar(a: &'static isize) { }\n-fn baz(a: &'let isize) { } //~ ERROR invalid lifetime name\n+fn baz(a: &'let isize) { } //~ ERROR lifetimes cannot use keyword names\n+fn zab(a: &'self isize) { } //~ ERROR lifetimes cannot use keyword names\n \n fn main() { }"}, {"sha": "e8cfb77f059634aa77b584cf2c08b6883e7dd4fd", "filename": "src/test/parse-fail/match-arrows-block-then-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fmatch-arrows-block-then-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fmatch-arrows-block-then-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmatch-arrows-block-then-binop.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -14,6 +14,6 @@ fn main() {\n \n     match 0 {\n       0 => {\n-      } + 5 //~ ERROR unexpected token: `+`\n+      } + 5 //~ ERROR expected pattern, found `+`\n     }\n }"}, {"sha": "648c46d246cbcb026f7734392a5544cfcad8b6c3", "filename": "src/test/parse-fail/obsolete-proc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fobsolete-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fobsolete-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fobsolete-proc.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -12,9 +12,8 @@\n \n // Test that we generate obsolete syntax errors around usages of `proc`.\n \n-fn foo(p: proc()) { } //~ ERROR `proc` is a reserved keyword\n+fn foo(p: proc()) { } //~ ERROR expected type, found reserved keyword `proc`\n \n-fn bar() { proc() 1; } //~ ERROR `proc` is a reserved keyword\n-                       //~^ ERROR expected\n+fn bar() { proc() 1; } //~ ERROR expected expression, found reserved keyword `proc`\n \n fn main() { }"}, {"sha": "6e99f8b3eeadc74f693c108b270c61fa06fdb36c", "filename": "src/test/parse-fail/removed-syntax-mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mode.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-fn f(+x: isize) {} //~ ERROR unexpected token: `+`\n+fn f(+x: isize) {} //~ ERROR expected pattern, found `+`"}, {"sha": "7e5bd27b497cbe1eabba462dc65ac1269246c806", "filename": "src/test/parse-fail/removed-syntax-mut-vec-expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mut-vec-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mut-vec-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mut-vec-expr.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,7 +11,5 @@\n // compile-flags: -Z parse-only\n \n fn f() {\n-    let v = [mut 1, 2, 3, 4];\n-    //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected one of `!`, `,`, `.`, `::`, `;`, `?`, `]`, `{`, or an operator, found `1`\n+    let v = [mut 1, 2, 3, 4]; //~ ERROR expected expression, found keyword `mut`\n }"}, {"sha": "0cdf1981a231bd82759aa7785db4b78bf3dd31ba", "filename": "src/test/parse-fail/removed-syntax-mut-vec-ty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mut-vec-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mut-vec-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-mut-vec-ty.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -10,6 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-type v = [mut isize];\n-    //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `isize`\n+type v = [mut isize]; //~ ERROR expected type, found keyword `mut`"}, {"sha": "b16c77ab6b5befbe10505abf556f2773758d0389", "filename": "src/test/parse-fail/removed-syntax-uniq-mut-expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-expr.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -11,7 +11,5 @@\n // compile-flags: -Z parse-only\n \n fn f() {\n-    let a_box = box mut 42;\n-    //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `42`\n+    let a_box = box mut 42; //~ ERROR expected expression, found keyword `mut`\n }"}, {"sha": "9bd8dc9b11b216cf9074e55b656095c23988cfd7", "filename": "src/test/parse-fail/removed-syntax-uniq-mut-ty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-ty.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -10,6 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-type mut_box = Box<mut isize>;\n-    //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected one of `!`, `(`, `+`, `,`, `::`, `<`, or `>`, found `isize`\n+type mut_box = Box<mut isize>; //~ ERROR expected type, found keyword `mut`"}, {"sha": "f3af8740be9483f23a73254f3e56838107e67725", "filename": "src/test/parse-fail/unsized2.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Fparse-fail%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Funsized2.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -15,8 +15,5 @@\n fn f<X>() {}\n \n pub fn main() {\n-    f<type>();\n-    //~^ ERROR expected identifier, found keyword `type`\n-    //~^^ ERROR: chained comparison\n-    //~^^^ HELP: use `::<\n+    f<type>(); //~ ERROR expected expression, found keyword `type`\n }"}, {"sha": "60016f59594696aefa4b5b6abcf2cf0d2224c84f", "filename": "src/test/run-pass/use-keyword-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Frun-pass%2Fuse-keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31658de51444d1b5193ac203a1bd7ace5621f93/src%2Ftest%2Frun-pass%2Fuse-keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-keyword-2.rs?ref=a31658de51444d1b5193ac203a1bd7ace5621f93", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct A;\n+\n+mod test {\n+    pub use super :: A;\n+\n+    pub use self :: A as B;\n+}\n+\n+impl A {\n+    fn f() {}\n+    fn g() {\n+        Self :: f()\n+    }\n+}\n+\n+fn main() {\n+    let a: A = test::A;\n+    let b: A = test::B;\n+    let c: () = A::g();\n+}"}]}