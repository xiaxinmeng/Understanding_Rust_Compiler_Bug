{"sha": "e199790bacb7a8a89065eff52b10b9eba78f0279", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxOTk3OTBiYWNiN2E4YTg5MDY1ZWZmNTJiMTBiOWViYTc4ZjAyNzk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-17T02:27:09Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-18T22:30:41Z"}, "message": "rustpkg: Make crates, not packages, the unit of rustpkg dependencies\n\nTreating a package as the thing that can have other packages depend on it,\nand depends on other packages, was wrong if a package has more than one\ncrate. Now, rustpkg knows about dependencies between crates in the same\npackage. This solves the problem reported in #7879 where rustpkg wrongly\ndiscovered a circular dependency between thhe package and itself, and\nrecursed infinitely.\n\nCloses #7879", "tree": {"sha": "825134015133e4850aad232a806862f0a08ffebe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/825134015133e4850aad232a806862f0a08ffebe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e199790bacb7a8a89065eff52b10b9eba78f0279", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e199790bacb7a8a89065eff52b10b9eba78f0279", "html_url": "https://github.com/rust-lang/rust/commit/e199790bacb7a8a89065eff52b10b9eba78f0279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e199790bacb7a8a89065eff52b10b9eba78f0279/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c6bf4872012c010f84dc7fa2cdfe87522533f89", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c6bf4872012c010f84dc7fa2cdfe87522533f89", "html_url": "https://github.com/rust-lang/rust/commit/4c6bf4872012c010f84dc7fa2cdfe87522533f89"}], "stats": {"total": 658, "additions": 409, "deletions": 249}, "files": [{"sha": "e1092458ffaae85e4a6f3d05a1282b89cfe72380", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -12,6 +12,7 @@ use context::*;\n use crate::*;\n use package_id::*;\n use package_source::*;\n+use target::*;\n use version::Version;\n use workcache_support::*;\n \n@@ -63,56 +64,40 @@ pub fn new_workcache_context(p: &Path) -> workcache::Context {\n pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n                  lib: Path) {\n     let cx = default_context(sysroot);\n-    let subroot = root.clone();\n-    let subversion = version.clone();\n-    let sublib = lib.clone();\n-    do cx.workcache_context.with_prep(name) |prep| {\n-        let pkg_src = PkgSrc {\n-            workspace: subroot.clone(),\n-            start_dir: subroot.push(\"src\").push(name),\n-            id: PkgId{ version: subversion.clone(), ..PkgId::new(name)},\n-            libs: ~[mk_crate(sublib.clone())],\n+    let pkg_src = PkgSrc {\n+            workspace: root.clone(),\n+            start_dir: root.push(\"src\").push(name),\n+            id: PkgId{ version: version, ..PkgId::new(name)},\n+            // n.b. This assumes the package only has one crate\n+            libs: ~[mk_crate(lib)],\n             mains: ~[],\n             tests: ~[],\n             benchs: ~[]\n         };\n-        pkg_src.declare_inputs(prep);\n-        let subcx = cx.clone();\n-        let subsrc = pkg_src.clone();\n-        do prep.exec |exec| {\n-            subsrc.build(exec, &subcx.clone(), ~[]);\n-        }\n-    };\n+    pkg_src.build(&cx, ~[]);\n }\n \n pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n                  main: Path) {\n     let cx = default_context(sysroot);\n-    let subroot = root.clone();\n-    let submain = main.clone();\n-    do cx.workcache_context.with_prep(name) |prep| {\n-        let pkg_src = PkgSrc {\n-            workspace: subroot.clone(),\n-            start_dir: subroot.push(\"src\").push(name),\n-            id: PkgId{ version: version.clone(), ..PkgId::new(name)},\n-            libs: ~[],\n-            mains: ~[mk_crate(submain.clone())],\n-            tests: ~[],\n-            benchs: ~[]\n-        };\n-        pkg_src.declare_inputs(prep);\n-        let subsrc = pkg_src.clone();\n-        let subcx = cx.clone();\n-        do prep.exec |exec| {\n-            subsrc.clone().build(exec, &subcx.clone(), ~[]);\n-        }\n-    }\n+    let pkg_src = PkgSrc {\n+        workspace: root.clone(),\n+        start_dir: root.push(\"src\").push(name),\n+        id: PkgId{ version: version, ..PkgId::new(name)},\n+        libs: ~[],\n+        // n.b. This assumes the package only has one crate\n+        mains: ~[mk_crate(main)],\n+        tests: ~[],\n+        benchs: ~[]\n+    };\n+\n+    pkg_src.build(&cx, ~[]);\n }\n \n pub fn install_pkg(sysroot: Path, workspace: Path, name: ~str, version: Version) {\n     let cx = default_context(sysroot);\n     let pkgid = PkgId{ version: version, ..PkgId::new(name)};\n-    cx.install(PkgSrc::new(workspace, false, pkgid));\n+    cx.install(PkgSrc::new(workspace, false, pkgid), &Everything);\n }\n \n fn mk_crate(p: Path) -> Crate {"}, {"sha": "484f6bdcaec4c8483d68f7ead34f549c6c9008e4", "filename": "src/librustpkg/exit_codes.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fexit_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fexit_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fexit_codes.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub static copy_failed_code: int = 65;"}, {"sha": "52b986cb6e7e6cad12a205dd360501958f201402", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -108,6 +108,12 @@ impl PkgId {\n         }\n     }\n \n+    // This is the workcache function name for the *installed*\n+    // binaries for this package (as opposed to the built ones,\n+    // which are per-crate).\n+    pub fn install_tag(&self) -> ~str {\n+        fmt!(\"install(%s)\", self.to_str())\n+    }\n }\n \n struct Prefixes {"}, {"sha": "4bf647b011d9dbc3b7cf24ae872b6e0ec21439a8", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -22,6 +22,7 @@ use path_util::{find_dir_using_rust_path_hack, default_workspace, make_dir_rwx_r\n use util::compile_crate;\n use workspace::is_workspace;\n use workcache_support;\n+use workcache_support::crate_tag;\n use extra::workcache;\n \n // An enumeration of the unpacked source of a package workspace.\n@@ -231,7 +232,7 @@ impl PkgSrc {\n         p.filestem().map_default(false, |p| { p == &self.id.short_name.as_slice() })\n     }\n \n-    fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n+    pub fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n         assert!(p.components.len() > prefix);\n         let mut sub = Path(\"\");\n         for c in p.components.slice(prefix, p.components.len()).iter() {\n@@ -286,7 +287,6 @@ impl PkgSrc {\n \n     fn build_crates(&self,\n                     ctx: &BuildContext,\n-                    exec: &mut workcache::Exec,\n                     destination_dir: &Path,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n@@ -297,25 +297,40 @@ impl PkgSrc {\n             let path_str = path.to_str();\n             let cfgs = crate.cfgs + cfgs;\n \n-            let result =\n-                // compile_crate should return the path of the output artifact\n-                compile_crate(ctx,\n-                              exec,\n-                              &self.id,\n-                              &path,\n-                              destination_dir,\n-                              crate.flags,\n-                              cfgs,\n-                              false,\n-                              what).to_str();\n-            debug!(\"Result of compiling %s was %s\", path_str, result);\n+            do ctx.workcache_context.with_prep(crate_tag(&path)) |prep| {\n+                debug!(\"Building crate %s, declaring it as an input\", path.to_str());\n+                prep.declare_input(\"file\", path.to_str(),\n+                                   workcache_support::digest_file_with_date(&path));\n+                let subpath = path.clone();\n+                let subcfgs = cfgs.clone();\n+                let subpath_str = path_str.clone();\n+                let subcx = ctx.clone();\n+                let id = self.id.clone();\n+                let sub_dir = destination_dir.clone();\n+                let sub_flags = crate.flags.clone();\n+                do prep.exec |exec| {\n+                    let result = compile_crate(&subcx,\n+                                               exec,\n+                                               &id,\n+                                               &subpath,\n+                                               &sub_dir,\n+                                               sub_flags,\n+                                               subcfgs,\n+                                               false,\n+                                               what).to_str();\n+                    debug!(\"Result of compiling %s was %s\", subpath_str, result);\n+                    result\n+                }\n+            };\n         }\n     }\n \n     /// Declare all the crate files in the package source as inputs\n+    /// (to the package)\n     pub fn declare_inputs(&self, prep: &mut workcache::Prep) {\n         let to_do = ~[self.libs.clone(), self.mains.clone(),\n                       self.tests.clone(), self.benchs.clone()];\n+        debug!(\"In declare inputs, self = %s\", self.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n                 let path = self.start_dir.push_rel(&c.file).normalize();\n@@ -330,7 +345,6 @@ impl PkgSrc {\n     // It would be better if build returned a Path, but then Path would have to derive\n     // Encodable.\n     pub fn build(&self,\n-                 exec: &mut workcache::Exec,\n                  build_context: &BuildContext,\n                  cfgs: ~[~str]) -> ~str {\n         use conditions::not_a_workspace::cond;\n@@ -360,13 +374,23 @@ impl PkgSrc {\n         let benchs = self.benchs.clone();\n         debug!(\"Building libs in %s, destination = %s\",\n                destination_workspace.to_str(), destination_workspace.to_str());\n-        self.build_crates(build_context, exec, &destination_workspace, libs, cfgs, Lib);\n+        self.build_crates(build_context, &destination_workspace, libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(build_context, exec, &destination_workspace, mains, cfgs, Main);\n+        self.build_crates(build_context, &destination_workspace, mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(build_context, exec, &destination_workspace, tests, cfgs, Test);\n+        self.build_crates(build_context, &destination_workspace, tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(build_context, exec, &destination_workspace, benchs, cfgs, Bench);\n+        self.build_crates(build_context, &destination_workspace, benchs, cfgs, Bench);\n         destination_workspace.to_str()\n     }\n+\n+    /// Debugging\n+    pub fn dump_crates(&self) {\n+        let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n+        for crate_set in crate_sets.iter() {\n+            for c in crate_set.iter() {\n+                debug!(\"Built crate: %s\", c.file.to_str())\n+            }\n+        }\n+    }\n }"}, {"sha": "7cd30c7af9e142b0056a37b08600bf61dfcffa9a", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 171, "deletions": 112, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -22,11 +22,10 @@ extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use std::{io, os, result, run, str};\n+use std::{io, os, result, run, str, task};\n pub use std::path::Path;\n \n use extra::workcache;\n-use extra::arc::RWArc;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n@@ -45,12 +44,16 @@ use context::{Context, BuildContext,\n                        LLVMAssemble, LLVMCompileBitcode};\n use package_id::PkgId;\n use package_source::PkgSrc;\n-use workcache_support::{discover_outputs, digest_only_date};\n+use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n+// use workcache_support::{discover_outputs, digest_only_date};\n+use workcache_support::digest_only_date;\n+use exit_codes::copy_failed_code;\n \n pub mod api;\n mod conditions;\n mod context;\n mod crate;\n+mod exit_codes;\n mod installed_packages;\n mod messages;\n mod package_id;\n@@ -172,19 +175,18 @@ impl<'self> PkgScript<'self> {\n pub trait CtxMethods {\n     fn run(&self, cmd: &str, args: ~[~str]);\n     fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n-    fn build_from_src(&self, pkg_src: PkgSrc);\n     /// Returns the destination workspace\n-    fn build(&self, exec: &mut workcache::Exec, pkg_src: PkgSrc) -> Path;\n+    fn build(&self, pkg_src: &mut PkgSrc, what: &WhatToBuild) -> Path;\n     fn clean(&self, workspace: &Path, id: &PkgId);\n     fn info(&self);\n     /// Returns a pair. First component is a list of installed paths,\n     /// second is a list of declared and discovered inputs\n-    fn install(&self, src: PkgSrc) -> (~[Path], ~[(~str, ~str)]);\n+    fn install(&self, src: PkgSrc, what: &WhatToBuild) -> (~[Path], ~[(~str, ~str)]);\n     /// Returns a list of installed files\n     fn install_no_build(&self,\n                         source_workspace: &Path,\n                         target_workspace: &Path,\n-                        id: &PkgId) -> ~[Path];\n+                        id: &PkgId) -> ~[~str];\n     fn prefer(&self, _id: &str, _vers: Option<~str>);\n     fn test(&self);\n     fn uninstall(&self, _id: &str, _vers: Option<~str>);\n@@ -193,20 +195,6 @@ pub trait CtxMethods {\n }\n \n impl CtxMethods for BuildContext {\n-    fn build_from_src(&self, pkg_src: PkgSrc) {\n-        let tag = pkg_src.id.to_str();\n-        debug!(\"package source = %s\", pkg_src.to_str());\n-        do self.workcache_context.with_prep(tag) |prep| {\n-            let subsrc = pkg_src.clone();\n-            let subself = self.clone();\n-            declare_package_script_dependency(prep, &subsrc);\n-            pkg_src.declare_inputs(prep);\n-            do prep.exec |exec| {\n-                subself.build(exec, subsrc.clone());\n-            }\n-        }\n-    }\n-\n     fn run(&self, cmd: &str, args: ~[~str]) {\n         match cmd {\n             \"build\" => {\n@@ -215,11 +203,13 @@ impl CtxMethods for BuildContext {\n                         None if self.context.use_rust_path_hack => {\n                             let cwd = os::getcwd();\n                             let pkgid = PkgId::new(cwd.components[cwd.components.len() - 1]);\n-                            self.build_from_src(PkgSrc::new(cwd, true, pkgid));\n+                            let mut pkg_src = PkgSrc::new(cwd, true, pkgid);\n+                            self.build(&mut pkg_src, &Everything);\n                         }\n                         None => { usage::build(); return; }\n                         Some((ws, pkgid)) => {\n-                            self.build_from_src(PkgSrc::new(ws, false, pkgid));\n+                            let mut pkg_src = PkgSrc::new(ws, false, pkgid);\n+                            self.build(&mut pkg_src, &Everything);\n                         }\n                     }\n                 }\n@@ -230,8 +220,8 @@ impl CtxMethods for BuildContext {\n                     do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                         debug!(\"found pkg %s in workspace %s, trying to build\",\n                                pkgid.to_str(), workspace.to_str());\n-                        let pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n-                        self.build_from_src(pkg_src);\n+                        let mut pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n+                        self.build(&mut pkg_src, &Everything);\n                         true\n                     };\n                 }\n@@ -271,12 +261,12 @@ impl CtxMethods for BuildContext {\n                             let cwd = os::getcwd();\n                             let inferred_pkgid =\n                                 PkgId::new(cwd.components[cwd.components.len() - 1]);\n-                            self.install(PkgSrc::new(cwd, true, inferred_pkgid));\n+                            self.install(PkgSrc::new(cwd, true, inferred_pkgid), &Everything);\n                         }\n                         None  => { usage::install(); return; }\n                         Some((ws, pkgid))                => {\n                             let pkg_src = PkgSrc::new(ws, false, pkgid);\n-                            self.install(pkg_src);\n+                            self.install(pkg_src, &Everything);\n                       }\n                   }\n                 }\n@@ -291,14 +281,14 @@ impl CtxMethods for BuildContext {\n                         let rp = rust_path();\n                         assert!(!rp.is_empty());\n                         let src = PkgSrc::new(rp[0].clone(), false, pkgid.clone());\n-                        self.install(src);\n+                        self.install(src, &Everything);\n                     }\n                     else {\n                         for workspace in workspaces.iter() {\n                             let src = PkgSrc::new(workspace.clone(),\n                                                   self.context.use_rust_path_hack,\n                                                   pkgid.clone());\n-                            self.install(src);\n+                            self.install(src, &Everything);\n                         };\n                     }\n                 }\n@@ -366,7 +356,9 @@ impl CtxMethods for BuildContext {\n \n     /// Returns the destination workspace\n     /// In the case of a custom build, we don't know, so we just return the source workspace\n-    fn build(&self, exec: &mut workcache::Exec, mut pkg_src: PkgSrc) -> Path {\n+    /// what_to_build says: \"Just build the lib.rs file in one subdirectory,\n+    /// don't walk anything recursively.\" Or else, everything.\n+    fn build(&self, pkg_src: &mut PkgSrc, what_to_build: &WhatToBuild) -> Path {\n         let workspace = pkg_src.workspace.clone();\n         let pkgid = pkg_src.id.clone();\n \n@@ -384,7 +376,7 @@ impl CtxMethods for BuildContext {\n             let default_ws = default_workspace();\n             debug!(\"Calling build recursively with %? and %?\", default_ws.to_str(),\n                    pkgid.to_str());\n-            return self.build(exec, PkgSrc::new(default_ws, false, pkgid.clone()));\n+            return self.build(&mut PkgSrc::new(default_ws, false, pkgid.clone()), what_to_build);\n         }\n \n         // Is there custom build logic? If so, use it\n@@ -395,12 +387,21 @@ impl CtxMethods for BuildContext {\n         let cfgs = match pkg_src.package_script_option() {\n             Some(package_script_path) => {\n                 let sysroot = self.sysroot_to_use();\n-                let (cfgs, hook_result) = {\n-                    let pscript = PkgScript::parse(@sysroot.clone(),\n-                                                   package_script_path.clone(),\n-                                                   &workspace.clone(),\n-                                                   &pkgid);\n-                    pscript.run_custom(exec, &sysroot)\n+                let (cfgs, hook_result) =\n+                    do self.workcache_context.with_prep(package_script_path.to_str()) |prep| {\n+                    let sub_sysroot = sysroot.clone();\n+                    let package_script_path_clone = package_script_path.clone();\n+                    let sub_ws = workspace.clone();\n+                    let sub_id = pkgid.clone();\n+                    declare_package_script_dependency(prep, &*pkg_src);\n+                    do prep.exec |exec| {\n+                        let pscript = PkgScript::parse(@sub_sysroot.clone(),\n+                                                       package_script_path_clone.clone(),\n+                                                       &sub_ws,\n+                                                       &sub_id);\n+\n+                        pscript.run_custom(exec, &sub_sysroot)\n+                    }\n                 };\n                 debug!(\"Command return code = %?\", hook_result);\n                 if hook_result != 0 {\n@@ -419,10 +420,31 @@ impl CtxMethods for BuildContext {\n         // If there was a package script, it should have finished\n         // the build already. Otherwise...\n         if !custom {\n-            // Find crates inside the workspace\n-            pkg_src.find_crates();\n+            match what_to_build {\n+                // Find crates inside the workspace\n+                &Everything => pkg_src.find_crates(),\n+                // Don't infer any crates -- just build the one that was requested\n+                &JustOne(ref p) => {\n+                    // We expect that p is relative to the package source's start directory,\n+                    // so check that assumption\n+                    debug!(\"JustOne: p = %s\", p.to_str());\n+                    assert!(os::path_exists(&pkg_src.start_dir.push_rel(p)));\n+                    if is_lib(p) {\n+                        PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n+                    } else if is_main(p) {\n+                        PkgSrc::push_crate(&mut pkg_src.mains, 0, p);\n+                    } else if is_test(p) {\n+                        PkgSrc::push_crate(&mut pkg_src.tests, 0, p);\n+                    } else if is_bench(p) {\n+                        PkgSrc::push_crate(&mut pkg_src.benchs, 0, p);\n+                    } else {\n+                        warn(fmt!(\"Not building any crates for dependency %s\", p.to_str()));\n+                        return workspace.clone();\n+                    }\n+                }\n+            }\n             // Build it!\n-            let rs_path = pkg_src.build(exec, self, cfgs);\n+            let rs_path = pkg_src.build(self, cfgs);\n             Path(rs_path)\n         }\n         else {\n@@ -452,56 +474,54 @@ impl CtxMethods for BuildContext {\n         fail!(\"info not yet implemented\");\n     }\n \n-    fn install(&self, pkg_src: PkgSrc) -> (~[Path], ~[(~str, ~str)]) {\n-\n-        let id = &pkg_src.id;\n-\n-        let installed_files = RWArc::new(~[]);\n-        let inputs = RWArc::new(~[]);\n-        // FIXME #7402: Use RUST_PATH to determine target dir\n-        self.workcache_context.with_prep(id.to_str(), |p| pkg_src.declare_inputs(p));\n-        do self.workcache_context.with_prep(id.to_str()) |prep| {\n-            let sub_inputs = inputs.clone();\n-            let sub_files  = installed_files.clone();\n-            let subsrc = pkg_src.clone();\n-            let subself = self.clone();\n-            let id_str = id.to_str();\n-            let sub_id = id.clone();\n-            sub_inputs.write(|r| *r = prep.lookup_declared_inputs().map(|v|\n-                                          { (~\"file\", (*v).clone()) }));\n-            do prep.exec |exec| {\n-                let destination_workspace = subself.build(exec, subsrc.clone()).to_str();\n-                // See #7402: This still isn't quite right yet; we want to\n-                // install to the first workspace in the RUST_PATH if there's\n-                // a non-default RUST_PATH. This code installs to the same\n-                // workspace the package was built in.\n-                let actual_workspace = if path_util::user_set_rust_path() {\n-                    default_workspace()\n-                }\n-                else {\n-                    Path(destination_workspace)\n-                };\n-                debug!(\"install: destination workspace = %s, id = %s, installing to %s\",\n-                       destination_workspace, id_str, actual_workspace.to_str());\n-                let result = subself.install_no_build(&Path(destination_workspace),\n-                                                      &actual_workspace,\n-                                                      &sub_id);\n-                debug!(\"install: id = %s, about to call discover_outputs, %?\",\n-                       id_str, result.to_str());\n-\n-                discover_outputs(exec, result.clone());\n-                sub_files.write(|r| { *r = result.clone(); });\n-                sub_inputs.write(|r| { *r = *r + exec.lookup_discovered_inputs() });\n-                note(fmt!(\"Installed package %s to %s\", id_str, actual_workspace.to_str()));\n+    fn install(&self, mut pkg_src: PkgSrc, what: &WhatToBuild) -> (~[Path], ~[(~str, ~str)]) {\n+\n+        let id = pkg_src.id.clone();\n+\n+        let mut installed_files = ~[];\n+        let inputs = ~[];\n+\n+        // workcache only knows about *crates*. Building a package\n+        // just means inferring all the crates in it, then building each one.\n+        let destination_workspace = self.build(&mut pkg_src, what).to_str();\n+\n+        let to_do = ~[pkg_src.libs.clone(), pkg_src.mains.clone(),\n+                      pkg_src.tests.clone(), pkg_src.benchs.clone()];\n+        debug!(\"In declare inputs for %s\", id.to_str());\n+        for cs in to_do.iter() {\n+            for c in cs.iter() {\n+                let path = pkg_src.start_dir.push_rel(&c.file).normalize();\n+                debug!(\"Recording input: %s\", path.to_str());\n+                installed_files.push(path);\n             }\n+        }\n+        // See #7402: This still isn't quite right yet; we want to\n+        // install to the first workspace in the RUST_PATH if there's\n+        // a non-default RUST_PATH. This code installs to the same\n+        // workspace the package was built in.\n+        let actual_workspace = if path_util::user_set_rust_path() {\n+            default_workspace()\n+        }\n+            else {\n+            Path(destination_workspace)\n         };\n-        (installed_files.unwrap(), inputs.unwrap())\n+        debug!(\"install: destination workspace = %s, id = %s, installing to %s\",\n+               destination_workspace, id.to_str(), actual_workspace.to_str());\n+        let result = self.install_no_build(&Path(destination_workspace),\n+                                           &actual_workspace,\n+                                           &id).map(|s| Path(*s));\n+        debug!(\"install: id = %s, about to call discover_outputs, %?\",\n+               id.to_str(), result.to_str());\n+        installed_files = installed_files + result;\n+        note(fmt!(\"Installed package %s to %s\", id.to_str(), actual_workspace.to_str()));\n+        (installed_files, inputs)\n     }\n \n+    // again, working around lack of Encodable for Path\n     fn install_no_build(&self,\n                         source_workspace: &Path,\n                         target_workspace: &Path,\n-                        id: &PkgId) -> ~[Path] {\n+                        id: &PkgId) -> ~[~str] {\n         use conditions::copy_failed::cond;\n \n         // Now copy stuff into the install dirs\n@@ -511,32 +531,59 @@ impl CtxMethods for BuildContext {\n         let target_lib = maybe_library.map(|_p| target_library_in_workspace(id, target_workspace));\n \n         debug!(\"target_exec = %s target_lib = %? \\\n-                maybe_executable = %? maybe_library = %?\",\n+               maybe_executable = %? maybe_library = %?\",\n                target_exec.to_str(), target_lib,\n                maybe_executable, maybe_library);\n \n-        let mut outputs = ~[];\n-\n-        for exec in maybe_executable.iter() {\n-            debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n-            if !(os::mkdir_recursive(&target_exec.dir_path(), U_RWX) &&\n-                 os::copy_file(exec, &target_exec)) {\n-                cond.raise(((*exec).clone(), target_exec.clone()));\n+        do self.workcache_context.with_prep(id.install_tag()) |prep| {\n+            for ee in maybe_executable.iter() {\n+                prep.declare_input(\"binary\",\n+                                   ee.to_str(),\n+                                   workcache_support::digest_only_date(ee));\n             }\n-            outputs.push(target_exec.clone());\n-        }\n-        for lib in maybe_library.iter() {\n-            let target_lib = target_lib.clone().expect(fmt!(\"I built %s but apparently \\\n-                                                didn't install it!\", lib.to_str()));\n-            let target_lib = target_lib.pop().push(lib.filename().expect(\"weird target lib\"));\n-            debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n-            if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n-                 os::copy_file(lib, &target_lib)) {\n-                cond.raise(((*lib).clone(), target_lib.clone()));\n+            for ll in maybe_library.iter() {\n+                prep.declare_input(\"binary\",\n+                                   ll.to_str(),\n+                                   workcache_support::digest_only_date(ll));\n+            }\n+            let subex = maybe_executable.clone();\n+            let sublib = maybe_library.clone();\n+            let sub_target_ex = target_exec.clone();\n+            let sub_target_lib = target_lib.clone();\n+\n+            do prep.exec |exe_thing| {\n+                let mut outputs = ~[];\n+\n+                for exec in subex.iter() {\n+                    debug!(\"Copying: %s -> %s\", exec.to_str(), sub_target_ex.to_str());\n+                    if !(os::mkdir_recursive(&sub_target_ex.dir_path(), U_RWX) &&\n+                         os::copy_file(exec, &sub_target_ex)) {\n+                        cond.raise(((*exec).clone(), sub_target_ex.clone()));\n+                    }\n+                    exe_thing.discover_output(\"binary\",\n+                        sub_target_ex.to_str(),\n+                        workcache_support::digest_only_date(&sub_target_ex));\n+                    outputs.push(sub_target_ex.to_str());\n+                }\n+                for lib in sublib.iter() {\n+                    let target_lib = sub_target_lib\n+                        .clone().expect(fmt!(\"I built %s but apparently \\\n+                                             didn't install it!\", lib.to_str()));\n+                    let target_lib = target_lib\n+                        .pop().push(lib.filename().expect(\"weird target lib\"));\n+                    debug!(\"Copying: %s -> %s\", lib.to_str(), sub_target_lib.to_str());\n+                    if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n+                         os::copy_file(lib, &target_lib)) {\n+                        cond.raise(((*lib).clone(), target_lib.clone()));\n+                    }\n+                    exe_thing.discover_output(\"binary\",\n+                                              target_lib.to_str(),\n+                                              workcache_support::digest_only_date(&target_lib));\n+                    outputs.push(target_lib.to_str());\n+                }\n+                outputs\n             }\n-            outputs.push(target_lib.clone());\n         }\n-        outputs\n     }\n \n     fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n@@ -726,15 +773,27 @@ pub fn main_args(args: &[~str]) {\n \n     debug!(\"Using sysroot: %s\", sroot.to_str());\n     debug!(\"Will store workcache in %s\", default_workspace().to_str());\n-    BuildContext {\n-        context: Context {\n-        cfgs: cfgs,\n-        rustc_flags: rustc_flags,\n-        use_rust_path_hack: use_rust_path_hack,\n-        sysroot: sroot, // Currently, only tests override this\n-    },\n-        workcache_context: api::default_context(default_workspace()).workcache_context\n-    }.run(*cmd, remaining_args)\n+\n+    let rm_args = remaining_args.clone();\n+    let sub_cmd = cmd.clone();\n+    // Wrap the rest in task::try in case of a condition failure in a task\n+    let result = do task::try {\n+        BuildContext {\n+            context: Context {\n+                cfgs: cfgs.clone(),\n+                rustc_flags: rustc_flags.clone(),\n+                use_rust_path_hack: use_rust_path_hack,\n+                sysroot: sroot.clone(), // Currently, only tests override this\n+            },\n+            workcache_context: api::default_context(default_workspace()).workcache_context\n+        }.run(sub_cmd, rm_args.clone())\n+    };\n+    // FIXME #9262: This is using the same error code for all errors,\n+    // and at least one test case succeeds if rustpkg returns copy_failed_code,\n+    // when actually, it might set the exit code for that even if a different\n+    // unhandled condition got raised.\n+    if result.is_err() { os::set_exit_status(copy_failed_code); }\n+\n }\n \n /**"}, {"sha": "9d3ad1f39a74ac0cd6c9fece12a46e6be37cc48b", "filename": "src/librustpkg/target.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -16,8 +16,45 @@ pub enum OutputType { Main, Lib, Bench, Test }\n \n #[deriving(Eq)]\n pub enum Target {\n-    // In-place build\n+    /// In-place build\n     Build,\n-    // Install to bin/ or lib/ dir\n+    /// Install to bin/ or lib/ dir\n     Install\n }\n+\n+#[deriving(Eq, Clone)]\n+pub enum WhatToBuild {\n+    /// Build just one lib.rs file in `path`, which is relative to the active workspace's src/ dir\n+    JustOne(Path),\n+    /// Build everything\n+    Everything\n+}\n+\n+pub fn is_lib(p: &Path) -> bool {\n+    file_is(p, \"lib\")\n+}\n+\n+pub fn is_main(p: &Path) -> bool {\n+    file_is(p, \"main\")\n+}\n+\n+pub fn is_test(p: &Path) -> bool {\n+    file_is(p, \"test\")\n+}\n+\n+pub fn is_bench(p: &Path) -> bool {\n+    file_is(p, \"bench\")\n+}\n+\n+fn file_is(p: &Path, stem: &str) -> bool {\n+    match p.filestem() {\n+        Some(s) if s == stem => true,\n+        _ => false\n+    }\n+}\n+\n+pub fn lib_name_of(p: &Path) -> Path {\n+    p.push(\"lib.rs\")\n+}\n+\n+pub static lib_crate_filename: &'static str = \"lib.rs\";"}, {"sha": "918cc366799780cfe23867d28bac01084a4094e2", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 91, "deletions": 44, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -34,11 +34,7 @@ use rustc::driver::driver::{build_session, build_session_options, host_triple, o\n use syntax::diagnostic;\n use target::*;\n use package_source::PkgSrc;\n-\n-/// Returns the last-modified date as an Option\n-fn datestamp(p: &Path) -> Option<libc::time_t> {\n-    p.stat().map(|stat| stat.st_mtime)\n-}\n+use util::datestamp;\n \n fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n     let context = workcache::Context::new(\n@@ -224,18 +220,26 @@ fn rustpkg_exec() -> Path {\n }\n \n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n-    command_line_test_with_env(args, cwd, None).expect(\"Command line test failed\")\n+    match command_line_test_with_env(args, cwd, None) {\n+        Success(r) => r,\n+        _ => fail!(\"Command line test failed\")\n+    }\n }\n \n-fn command_line_test_partial(args: &[~str], cwd: &Path) -> Option<ProcessOutput> {\n+fn command_line_test_partial(args: &[~str], cwd: &Path) -> ProcessResult {\n     command_line_test_with_env(args, cwd, None)\n }\n \n+enum ProcessResult {\n+    Success(ProcessOutput),\n+    Fail(int) // exit code\n+}\n+\n /// Runs `rustpkg` (based on the directory that this executable was\n /// invoked from) with the given arguments, in the given working directory.\n /// Returns the process's output.\n fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~str)]>)\n-    -> Option<ProcessOutput> {\n+    -> ProcessResult {\n     let cmd = rustpkg_exec().to_str();\n     let env_str = match env {\n         Some(ref pairs) => pairs.map(|&(ref k, ref v)| { fmt!(\"%s=%s\", *k, *v) }).connect(\",\"),\n@@ -266,10 +270,10 @@ to make sure the command succeeded\n         debug!(\"Command %s %? failed with exit code %?; its output was {{{ %s }}}\",\n               cmd, args, output.status,\n               str::from_utf8(output.output) + str::from_utf8(output.error));\n-        None\n+        Fail(output.status)\n     }\n     else {\n-        Some(output)\n+        Success(output)\n     }\n }\n \n@@ -410,8 +414,11 @@ fn command_line_test_output(args: &[~str]) -> ~[~str] {\n \n fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~str] {\n     let mut result = ~[];\n-    let p_output = command_line_test_with_env(args,\n-        &os::getcwd(), Some(env)).expect(\"Command-line test failed\");\n+    let p_output = match command_line_test_with_env(args,\n+        &os::getcwd(), Some(env)) {\n+        Fail(_) => fail!(\"Command-line test failed\"),\n+        Success(r) => r\n+    };\n     let test_output = str::from_utf8(p_output.output);\n     for s in test_output.split_iter('\\n') {\n         result.push(s.to_owned());\n@@ -420,9 +427,9 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n }\n \n // assumes short_name and path are one and the same -- I should fix\n-fn lib_output_file_name(workspace: &Path, parent: &str, short_name: &str) -> Path {\n-    debug!(\"lib_output_file_name: given %s and parent %s and short name %s\",\n-           workspace.to_str(), parent, short_name);\n+fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n+    debug!(\"lib_output_file_name: given %s and short name %s\",\n+           workspace.to_str(), short_name);\n     library_in_workspace(&Path(short_name),\n                          short_name,\n                          Build,\n@@ -450,19 +457,18 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n }\n \n /// Add a comment at the end\n-fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n+fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.push_many([~\"src\", pkgid.to_str()]);\n-    let contents = os::list_dir_path(&pkg_src_dir);\n     let mut maybe_p = None;\n-    for p in contents.iter() {\n-        if p.filetype() == Some(\".rs\") {\n-            maybe_p = Some(p);\n-            break;\n-        }\n+    let maybe_file = pkg_src_dir.push(filename);\n+    debug!(\"Trying to frob %s -- %s\", pkg_src_dir.to_str(), filename);\n+    if os::path_exists(&maybe_file) {\n+        maybe_p = Some(maybe_file);\n     }\n+    debug!(\"Frobbed? %?\", maybe_p);\n     match maybe_p {\n-        Some(p) => {\n+        Some(ref p) => {\n             let w = io::file_writer(p, &[io::Append]);\n             match w {\n                 Err(s) => { let _ = cond.raise((p.clone(), fmt!(\"Bad path: %s\", s))); }\n@@ -499,7 +505,7 @@ fn test_install_valid() {\n     debug!(\"temp_workspace = %s\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n     let src = PkgSrc::new(temp_workspace.clone(), false, temp_pkg_id.clone());\n-    ctxt.install(src);\n+    ctxt.install(src, &Everything);\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n     debug!(\"exec = %s\", exec.to_str());\n@@ -528,7 +534,7 @@ fn test_install_invalid() {\n     // Uses task::try because of #9001\n     let result = do task::try {\n         let pkg_src = PkgSrc::new(temp_workspace.clone(), false, pkgid.clone());\n-        ctxt.install(pkg_src);\n+        ctxt.install(pkg_src, &Everything);\n     };\n     // Not the best test -- doesn't test that we failed in the right way.\n     // Best we can do for now.\n@@ -939,26 +945,28 @@ fn no_rebuilding() {\n }\n \n #[test]\n-#[ignore]\n fn no_rebuilding_dep() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let bar_date_1 = datestamp(&lib_output_file_name(&workspace,\n-                                                  \".rust\",\n-                                                  \"bar\"));\n-    let foo_date_1 = datestamp(&output_file_name(&workspace, ~\"foo\"));\n+    let bar_lib = lib_output_file_name(&workspace, \"bar\");\n+    let bar_date_1 = datestamp(&bar_lib);\n+\n+    frob_source_file(&workspace, &p_id, \"main.rs\");\n+\n+    // Now make `bar` read-only so that subsequent rebuilds of it will fail\n+    assert!(chmod_read_only(&bar_lib));\n+\n+    match command_line_test_partial([~\"build\", ~\"foo\"], &workspace) {\n+        Success(*) => (), // ok\n+        Fail(status) if status == 65 => fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n+        Fail(_) => fail!(\"no_rebuilding_dep failed for some other reason\")\n+    }\n \n-    frob_source_file(&workspace, &p_id);\n-    command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date_2 = datestamp(&lib_output_file_name(&workspace,\n-                                                  \".rust\",\n-                                                  \"bar\"));\n-    let foo_date_2 = datestamp(&output_file_name(&workspace, ~\"foo\"));\n+                                                   \"bar\"));\n     assert_eq!(bar_date_1, bar_date_2);\n-    assert!(foo_date_1 < foo_date_2);\n-    assert!(foo_date_1 > bar_date_1);\n }\n \n #[test]\n@@ -967,7 +975,7 @@ fn do_rebuild_dep_dates_change() {\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let bar_lib_name = lib_output_file_name(&workspace, \"build\", \"bar\");\n+    let bar_lib_name = lib_output_file_name(&workspace, \"bar\");\n     let bar_date = datestamp(&bar_lib_name);\n     debug!(\"Datestamp on %s is %?\", bar_lib_name.to_str(), bar_date);\n     touch_source_file(&workspace, &dep_id);\n@@ -983,11 +991,11 @@ fn do_rebuild_dep_only_contents_change() {\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n-    frob_source_file(&workspace, &dep_id);\n+    let bar_date = datestamp(&lib_output_file_name(&workspace, \"bar\"));\n+    frob_source_file(&workspace, &dep_id, \"lib.rs\");\n     // should adjust the datestamp\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let new_bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n+    let new_bar_date = datestamp(&lib_output_file_name(&workspace, \"bar\"));\n     assert!(new_bar_date > bar_date);\n }\n \n@@ -1309,7 +1317,6 @@ fn rust_path_hack_build_no_arg() {\n }\n \n #[test]\n-#[ignore (reason = \"#7402 not yet implemented\")]\n fn rust_path_install_target() {\n     let dir_for_path = mkdtemp(&os::tmpdir(),\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n@@ -1464,10 +1471,13 @@ fn test_cfg_fail() {\n     let workspace = create_local_package(&p_id);\n     writeFile(&workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n-    assert!(command_line_test_partial([test_sysroot().to_str(),\n+    match command_line_test_partial([test_sysroot().to_str(),\n                        ~\"build\",\n                        ~\"foo\"],\n-                      &workspace).is_none());\n+                      &workspace) {\n+        Success(*) => fail!(\"test_cfg_fail failed\"),\n+        _          => ()\n+    }\n }\n \n \n@@ -1680,6 +1690,21 @@ fn test_target_specific_install_dir() {\n     assert_executable_exists(&workspace, \"foo\");\n }\n \n+#[test]\n+fn test_dependencies_terminate() {\n+ //   let a_id = PkgId::new(\"a\");\n+    let b_id = PkgId::new(\"b\");\n+//    let workspace = create_local_package_with_dep(&b_id, &a_id);\n+    let workspace = create_local_package(&b_id);\n+    let b_dir = workspace.push_many([~\"src\", ~\"b-0.1\"]);\n+  //  writeFile(&b_dir.push(\"lib.rs\"), \"extern mod a; pub fn f() {}\");\n+    let b_subdir = b_dir.push(\"test\");\n+    assert!(os::mkdir_recursive(&b_subdir, U_RWX));\n+    writeFile(&b_subdir.push(\"test.rs\"),\n+              \"extern mod b; use b::f; #[test] fn g() { f() }\");\n+    command_line_test([~\"install\", ~\"b\"], &workspace);\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};\n@@ -1689,3 +1714,25 @@ fn is_executable(p: &Path) -> bool {\n         Some(mode) => mode & S_IXUSR as uint == S_IXUSR as uint\n     }\n }\n+\n+#[cfg(target_os = \"win32\")]\n+fn chmod_read_only(p: &Path) -> bool {\n+    #[fixed_stack_segment];\n+    unsafe {\n+        do p.to_str().with_c_str |src_buf| {\n+            libc::chmod(src_buf, libc::consts::os::posix88::S_IRUSR as c_int) == 0 as libc::c_int\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_os = \"win32\"))]\n+fn chmod_read_only(p: &Path) -> bool {\n+    #[fixed_stack_segment];\n+    unsafe {\n+        do p.to_str().with_c_str |src_buf| {\n+            libc::chmod(src_buf,\n+                        libc::consts::os::posix88::S_IRUSR as libc::mode_t) == 0\n+                as libc::c_int\n+        }\n+    }\n+}"}, {"sha": "64f76dcdc605d25d9d51c5300ca3cdfaea07ea7d", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::libc;\n use std::os;\n use extra::workcache;\n use rustc::driver::{driver, session};\n@@ -26,7 +27,7 @@ use workspace::pkg_parent_workspaces;\n use path_util::{installed_library_in_workspace, U_RWX, rust_path, system_library, target_build_dir};\n use messages::error;\n \n-pub use target::{OutputType, Main, Lib, Bench, Test};\n+pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n use workcache_support::{digest_file_with_date, digest_only_date};\n \n // It would be nice to have the list of commands in just one place -- for example,\n@@ -171,6 +172,8 @@ pub fn compile_input(context: &BuildContext,\n     // not sure if we should support anything else\n \n     let out_dir = target_build_dir(workspace).push_rel(&pkg_id.path);\n+    // Make the output directory if it doesn't exist already\n+    assert!(os::mkdir_recursive(&out_dir, U_RWX));\n \n     let binary = os::args()[0].to_managed();\n \n@@ -220,7 +223,7 @@ pub fn compile_input(context: &BuildContext,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n         maybe_sysroot: Some(sysroot_to_use),\n-        addl_lib_search_paths: @mut (~[out_dir.clone()]),\n+        addl_lib_search_paths: @mut (~[]),\n         output_type: output_type,\n         .. (*driver::build_session_options(binary, &matches, diagnostic::emit)).clone()\n     };\n@@ -329,6 +332,9 @@ pub fn compile_crate_from_input(input: &Path,\n     // Register dependency on the source file\n     exec.discover_input(\"file\", input.to_str(), digest_file_with_date(input));\n \n+    debug!(\"Built %s, date = %?\", outputs.out_filename.to_str(),\n+           datestamp(&outputs.out_filename));\n+\n     Some(outputs.out_filename)\n }\n \n@@ -409,7 +415,8 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                             workspaces[0]\n                         };\n                         let (outputs_disc, inputs_disc) =\n-                            context.install(PkgSrc::new(dep_workspace.clone(), false, pkg_id));\n+                            context.install(PkgSrc::new(dep_workspace.clone(),\n+                                false, pkg_id), &JustOne(Path(lib_crate_filename)));\n                         debug!(\"Installed %s, returned %? dependencies and \\\n                                %? transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n@@ -435,10 +442,11 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                         debug!(\"Adding additional search path: %s\", lib_name);\n                         let installed_library =\n                             installed_library_in_workspace(&Path(lib_name), &dep_workspace)\n-                                .expect( fmt!(\"rustpkg failed to install dependency %s\",\n+                                .expect(fmt!(\"rustpkg failed to install dependency %s\",\n                                               lib_name));\n                         let install_dir = installed_library.pop();\n-                        debug!(\"Installed %s into %s\", lib_name, install_dir.to_str());\n+                        debug!(\"Installed %s into %s [%?]\", lib_name, install_dir.to_str(),\n+                               datestamp(&installed_library));\n                         save(install_dir);\n                     }\n                 }}\n@@ -449,37 +457,6 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n     };\n }\n \n-#[cfg(windows)]\n-pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    /* FIXME (#1768): Investigate how to do this on win32\n-       Node wraps symlinks by having a .bat,\n-       but that won't work with minGW. */\n-\n-    false\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"macos\")]\n-pub fn link_exe(src: &Path, dest: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    use std::c_str::ToCStr;\n-    use std::libc;\n-\n-    unsafe {\n-        do src.with_c_str |src_buf| {\n-            do dest.with_c_str |dest_buf| {\n-                libc::link(src_buf, dest_buf) == 0 as libc::c_int &&\n-                    libc::chmod(dest_buf, 755) == 0 as libc::c_int\n-            }\n-        }\n-    }\n-}\n-\n pub fn mk_string_lit(s: @str) -> ast::lit {\n     Spanned {\n         node: ast::lit_str(s),\n@@ -516,3 +493,12 @@ pub fn option_to_vec<T>(x: Option<T>) -> ~[T] {\n // tjc: cheesy\n fn debug_flags() -> ~[~str] { ~[] }\n // static DEBUG_FLAGS: ~[~str] = ~[~\"-Z\", ~\"time-passes\"];\n+\n+\n+/// Returns the last-modified date as an Option\n+pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n+    debug!(\"Scrutinizing datestamp for %s - does it exist? %?\", p.to_str(), os::path_exists(p));\n+    let out = p.stat().map(|stat| stat.st_mtime);\n+    debug!(\"Date = %?\", out);\n+    out.map(|t| { *t as libc::time_t })\n+}"}, {"sha": "daf35c988c823861f7237e86841ea6e0d9de0eef", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e199790bacb7a8a89065eff52b10b9eba78f0279/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=e199790bacb7a8a89065eff52b10b9eba78f0279", "patch": "@@ -56,3 +56,8 @@ pub fn discover_outputs(e: &mut workcache::Exec, outputs: ~[Path]) {\n         e.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n     }\n }\n+\n+/// Returns the function name for building a crate\n+pub fn crate_tag(p: &Path) -> ~str {\n+    p.to_str() // implicitly, it's \"build(p)\"...\n+}"}]}