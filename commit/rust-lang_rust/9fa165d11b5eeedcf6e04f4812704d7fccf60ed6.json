{"sha": "9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "node_id": "C_kwDOAAsO6NoAKDlmYTE2NWQxMWI1ZWVlZGNmNmUwNGY0ODEyNzA0ZDdmY2NmNjBlZDY", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-10-13T14:28:28Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-11-20T19:19:33Z"}, "message": "Point at `impl` blocks when they introduce unmet obligations\n\nGroup obligations by `impl` block that introduced them.", "tree": {"sha": "d719094389b9b651646d2cb822f179ffa95e8bc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d719094389b9b651646d2cb822f179ffa95e8bc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "html_url": "https://github.com/rust-lang/rust/commit/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f433adf75c9e3f1befea5115d7e84531b3668ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f433adf75c9e3f1befea5115d7e84531b3668ad", "html_url": "https://github.com/rust-lang/rust/commit/8f433adf75c9e3f1befea5115d7e84531b3668ad"}], "stats": {"total": 243, "additions": 184, "deletions": 59}, "files": [{"sha": "dbc1d4ec193772ffea2c3cdf8d430278c860a13c", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -12,6 +12,7 @@ pub use self::CandidateSource::*;\n pub use self::MethodError::*;\n \n use crate::check::FnCtxt;\n+use crate::ObligationCause;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -71,7 +72,8 @@ pub enum MethodError<'tcx> {\n #[derive(Debug)]\n pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n-    pub unsatisfied_predicates: Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)>,\n+    pub unsatisfied_predicates:\n+        Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n     pub out_of_scope_traits: Vec<DefId>,\n     pub lev_candidate: Option<ty::AssocItem>,\n     pub mode: probe::Mode,\n@@ -80,7 +82,11 @@ pub struct NoMatchData<'tcx> {\n impl<'tcx> NoMatchData<'tcx> {\n     pub fn new(\n         static_candidates: Vec<CandidateSource>,\n-        unsatisfied_predicates: Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)>,\n+        unsatisfied_predicates: Vec<(\n+            ty::Predicate<'tcx>,\n+            Option<ty::Predicate<'tcx>>,\n+            Option<ObligationCause<'tcx>>,\n+        )>,\n         out_of_scope_traits: Vec<DefId>,\n         lev_candidate: Option<ty::AssocItem>,\n         mode: probe::Mode,"}, {"sha": "9fd7e8c4daa2043c0ea4cfde26934575a84be8a0", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -78,7 +78,8 @@ struct ProbeContext<'a, 'tcx> {\n \n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n-    unsatisfied_predicates: Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)>,\n+    unsatisfied_predicates:\n+        Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n \n     is_suggestion: IsSuggestion,\n \n@@ -1351,6 +1352,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         possibly_unsatisfied_predicates: &mut Vec<(\n             ty::Predicate<'tcx>,\n             Option<ty::Predicate<'tcx>>,\n+            Option<ObligationCause<'tcx>>,\n         )>,\n         unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>>\n@@ -1497,6 +1499,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         possibly_unsatisfied_predicates: &mut Vec<(\n             ty::Predicate<'tcx>,\n             Option<ty::Predicate<'tcx>>,\n+            Option<ObligationCause<'tcx>>,\n         )>,\n     ) -> ProbeResult {\n         debug!(\"consider_probe: self_ty={:?} probe={:?}\", self_ty, probe);\n@@ -1508,8 +1511,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 .sup(probe.xform_self_ty, self_ty)\n             {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n-                Err(_) => {\n-                    debug!(\"--> cannot relate self-types\");\n+                Err(err) => {\n+                    debug!(\"--> cannot relate self-types {:?}\", err);\n                     return ProbeResult::NoMatch;\n                 }\n             };\n@@ -1558,7 +1561,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         let o = self.resolve_vars_if_possible(o);\n                         if !self.predicate_may_hold(&o) {\n                             result = ProbeResult::NoMatch;\n-                            possibly_unsatisfied_predicates.push((o.predicate, None));\n+                            possibly_unsatisfied_predicates.push((\n+                                o.predicate,\n+                                None,\n+                                Some(o.cause),\n+                            ));\n                         }\n                     }\n                 }\n@@ -1604,16 +1611,19 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                             } else {\n                                                 Some(predicate)\n                                             };\n-                                            possibly_unsatisfied_predicates\n-                                                .push((nested_predicate, p));\n+                                            possibly_unsatisfied_predicates.push((\n+                                                nested_predicate,\n+                                                p,\n+                                                Some(obligation.cause.clone()),\n+                                            ));\n                                         }\n                                     }\n                                 }\n                                 _ => {\n                                     // Some nested subobligation of this predicate\n                                     // failed.\n                                     let predicate = self.resolve_vars_if_possible(predicate);\n-                                    possibly_unsatisfied_predicates.push((predicate, None));\n+                                    possibly_unsatisfied_predicates.push((predicate, None, None));\n                                 }\n                             }\n                             false\n@@ -1632,7 +1642,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let o = self.resolve_vars_if_possible(o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n-                    possibly_unsatisfied_predicates.push((o.predicate, None));\n+                    possibly_unsatisfied_predicates.push((o.predicate, None, Some(o.cause)));\n                 }\n             }\n "}, {"sha": "b4508368e2684ce5b2cbec351e27057f9d6e2ce0", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 105, "deletions": 11, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -17,7 +17,9 @@ use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, MultiSpan, Span, Symbol};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-use rustc_trait_selection::traits::{FulfillmentError, Obligation};\n+use rustc_trait_selection::traits::{\n+    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode,\n+};\n \n use std::cmp::Ordering;\n use std::iter;\n@@ -791,9 +793,88 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => None,\n                         }\n                     };\n+\n+                    // Find all the requirements that come from a local `impl` block.\n+                    let mut skip_list: FxHashSet<_> = Default::default();\n+                    let mut spanned_predicates: FxHashMap<MultiSpan, _> = Default::default();\n+                    for (data, p, parent_p) in unsatisfied_predicates\n+                        .iter()\n+                        .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n+                        .filter_map(|(p, parent, c)| match c.code {\n+                            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                                Some((data, p, parent))\n+                            }\n+                            _ => None,\n+                        })\n+                    {\n+                        let parent_trait_ref = data.parent_trait_ref;\n+                        let parent_def_id = parent_trait_ref.def_id();\n+                        let path = parent_trait_ref.print_only_trait_path();\n+                        let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n+                        let mut candidates = vec![];\n+                        self.tcx.for_each_relevant_impl(\n+                            parent_def_id,\n+                            parent_trait_ref.self_ty().skip_binder(),\n+                            |impl_def_id| match self.tcx.hir().get_if_local(impl_def_id) {\n+                                Some(Node::Item(hir::Item {\n+                                    kind: hir::ItemKind::Impl(hir::Impl { .. }),\n+                                    ..\n+                                })) => {\n+                                    candidates.push(impl_def_id);\n+                                }\n+                                _ => {}\n+                            },\n+                        );\n+                        if let [def_id] = &candidates[..] {\n+                            match self.tcx.hir().get_if_local(*def_id) {\n+                                Some(Node::Item(hir::Item {\n+                                    kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n+                                    ..\n+                                })) => {\n+                                    if let Some(pred) = parent_p {\n+                                        // Done to add the \"doesn't satisfy\" `span_label`.\n+                                        let _ = format_pred(*pred);\n+                                    }\n+                                    skip_list.insert(p);\n+                                    let mut spans = Vec::with_capacity(2);\n+                                    if let Some(trait_ref) = of_trait {\n+                                        spans.push(trait_ref.path.span);\n+                                    }\n+                                    spans.push(self_ty.span);\n+                                    let entry = spanned_predicates.entry(spans.into());\n+                                    entry\n+                                        .or_insert_with(|| (path, tr_self_ty, Vec::new()))\n+                                        .2\n+                                        .push(p);\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+                    for (span, (path, self_ty, preds)) in spanned_predicates {\n+                        err.span_note(\n+                            span,\n+                            &format!(\n+                                \"the following trait bounds were not satisfied because of the \\\n+                                 requirements of the implementation of `{}` for `{}`:\\n{}\",\n+                                path,\n+                                self_ty,\n+                                preds\n+                                    .into_iter()\n+                                    // .map(|pred| format!(\"{:?}\", pred))\n+                                    .filter_map(|pred| format_pred(*pred))\n+                                    .map(|(p, _)| format!(\"`{}`\", p))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"\\n\"),\n+                            ),\n+                        );\n+                    }\n+\n+                    // The requirements that didn't have an `impl` span to show.\n                     let mut bound_list = unsatisfied_predicates\n                         .iter()\n-                        .filter_map(|(pred, parent_pred)| {\n+                        .filter(|(pred, _, _parent_pred)| !skip_list.contains(&pred))\n+                        .filter_map(|(pred, parent_pred, _cause)| {\n                             format_pred(*pred).map(|(p, self_ty)| match parent_pred {\n                                 None => format!(\"`{}`\", &p),\n                                 Some(parent_pred) => match format_pred(*parent_pred) {\n@@ -836,7 +917,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     for (span, msg) in bound_spans.into_iter() {\n                         err.span_label(span, &msg);\n                     }\n-                    if !bound_list.is_empty() {\n+                    if !bound_list.is_empty() || !skip_list.is_empty() {\n                         let bound_list = bound_list\n                             .into_iter()\n                             .map(|(_, path)| path)\n@@ -846,9 +927,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.set_primary_message(&format!(\n                             \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n                         ));\n-                        err.note(&format!(\n-                            \"the following trait bounds were not satisfied:\\n{bound_list}\"\n-                        ));\n+                        if !bound_list.is_empty() {\n+                            err.note(&format!(\n+                                \"the following trait bounds were not satisfied:\\n{bound_list}\"\n+                            ));\n+                        }\n                         self.suggest_derive(&mut err, &unsatisfied_predicates);\n \n                         unsatisfied_bounds = true;\n@@ -1062,18 +1145,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.span_note(spans, &msg);\n         }\n \n-        let preds: Vec<_> = errors.iter().map(|e| (e.obligation.predicate, None)).collect();\n+        let preds: Vec<_> = errors\n+            .iter()\n+            .map(|e| (e.obligation.predicate, None, Some(e.obligation.cause.clone())))\n+            .collect();\n         self.suggest_derive(err, &preds);\n     }\n \n     fn suggest_derive(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        unsatisfied_predicates: &Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)>,\n+        unsatisfied_predicates: &Vec<(\n+            ty::Predicate<'tcx>,\n+            Option<ty::Predicate<'tcx>>,\n+            Option<ObligationCause<'tcx>>,\n+        )>,\n     ) {\n         let mut derives = Vec::<(String, Span, String)>::new();\n         let mut traits = Vec::<Span>::new();\n-        for (pred, _) in unsatisfied_predicates {\n+        for (pred, _, _) in unsatisfied_predicates {\n             let trait_pred = match pred.kind().skip_binder() {\n                 ty::PredicateKind::Trait(trait_pred) => trait_pred,\n                 _ => continue,\n@@ -1264,7 +1354,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         item_name: Ident,\n         source: SelfSource<'tcx>,\n         valid_out_of_scope_traits: Vec<DefId>,\n-        unsatisfied_predicates: &[(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)],\n+        unsatisfied_predicates: &[(\n+            ty::Predicate<'tcx>,\n+            Option<ty::Predicate<'tcx>>,\n+            Option<ObligationCause<'tcx>>,\n+        )],\n         unsatisfied_bounds: bool,\n     ) {\n         let mut alt_rcvr_sugg = false;\n@@ -1380,7 +1474,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                unsatisfied_predicates.iter().all(|(p, _)| {\n+                unsatisfied_predicates.iter().all(|(p, _, _)| {\n                     match p.kind().skip_binder() {\n                         // Hide traits if they are present in predicates as they can be fixed without\n                         // having to implement them."}, {"sha": "45a906a39475bd863047bb54a6b3f264e54ba89e", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -13,12 +13,16 @@ LL | struct NotClone;\n LL |     Bar::<NotClone> { x: 1 }.clone();\n    |                              ^^^^^ method cannot be called on `Bar<NotClone>` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `NotClone: Clone`\n-           which is required by `Bar<NotClone>: Clone`\n+note: the following trait bounds were not satisfied because of the requirements of the implementation of `Clone` for `_`:\n+      `NotClone: Clone`\n+  --> $DIR/derive-assoc-type-not-impl.rs:6:10\n+   |\n+LL | #[derive(Clone)]\n+   |          ^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `NotClone` with `#[derive(Clone)]`\n    |\n LL | #[derive(Clone)]"}, {"sha": "8b6f7c41a7c66833de3a3a9081f97fd942d0b058", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -12,6 +12,7 @@ trait M {\n }\n \n impl<T: X<Y<i32> = i32>> M for T {}\n+//~^ NOTE the following trait bounds were not satisfied\n \n struct S;\n //~^ NOTE method `f` not found for this\n@@ -26,7 +27,6 @@ fn f(a: S) {\n     a.f();\n     //~^ ERROR the method `f` exists for struct `S`, but its trait bounds were not satisfied\n     //~| NOTE method cannot be called on `S` due to unsatisfied trait bounds\n-    //~| NOTE the following trait bounds were not satisfied:\n }\n \n fn main() {}"}, {"sha": "3eeb9540e73513440ba56bd48ec36ee0516a7708", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -1,5 +1,5 @@\n error[E0599]: the method `f` exists for struct `S`, but its trait bounds were not satisfied\n-  --> $DIR/method-unsatified-assoc-type-predicate.rs:26:7\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:27:7\n    |\n LL | struct S;\n    | ---------\n@@ -11,9 +11,12 @@ LL | struct S;\n LL |     a.f();\n    |       ^ method cannot be called on `S` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `<S as X>::Y<i32> = i32`\n-           which is required by `S: M`\n+note: the following trait bounds were not satisfied because of the requirements of the implementation of `M` for `_`:\n+      `<S as X>::Y<i32> = i32`\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:14:26\n+   |\n+LL | impl<T: X<Y<i32> = i32>> M for T {}\n+   |                          ^     ^\n \n error: aborting due to previous error\n "}, {"sha": "a497c6257dab65226de295274c21664eabc767e6", "filename": "src/test/ui/hrtb/issue-30786.migrate.stderr", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -10,13 +10,14 @@ LL | pub struct Map<S, F> {\n LL |     let filter = map.filterx(|x: &_| true);\n    |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-           which is required by `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n-           `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-           which is required by `&Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n-           `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-           which is required by `&mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n+note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n+      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+      `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+      `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+  --> $DIR/issue-30786.rs:106:9\n+   |\n+LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n+   |         ^^^^^^^^^     ^\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:141:24\n@@ -30,13 +31,14 @@ LL | pub struct Filter<S, F> {\n LL |     let count = filter.countx();\n    |                        ^^^^^^ method cannot be called on `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-           which is required by `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n-           `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-           which is required by `&Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n-           `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-           which is required by `&mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n+note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n+      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+      `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+      `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+  --> $DIR/issue-30786.rs:106:9\n+   |\n+LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n+   |         ^^^^^^^^^     ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a497c6257dab65226de295274c21664eabc767e6", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -10,13 +10,14 @@ LL | pub struct Map<S, F> {\n LL |     let filter = map.filterx(|x: &_| true);\n    |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-           which is required by `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n-           `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-           which is required by `&Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n-           `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-           which is required by `&mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n+note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n+      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+      `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+      `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+  --> $DIR/issue-30786.rs:106:9\n+   |\n+LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n+   |         ^^^^^^^^^     ^\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:141:24\n@@ -30,13 +31,14 @@ LL | pub struct Filter<S, F> {\n LL |     let count = filter.countx();\n    |                        ^^^^^^ method cannot be called on `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-           which is required by `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n-           `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-           which is required by `&Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n-           `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-           which is required by `&mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n+note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n+      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+      `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+      `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+  --> $DIR/issue-30786.rs:106:9\n+   |\n+LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n+   |         ^^^^^^^^^     ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "81e2a9a1ffcc7f44d743159ff907bd2b335123c1", "filename": "src/test/ui/specialization/defaultimpl/specialization-trait-not-implemented.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa165d11b5eeedcf6e04f4812704d7fccf60ed6/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr?ref=9fa165d11b5eeedcf6e04f4812704d7fccf60ed6", "patch": "@@ -20,8 +20,12 @@ LL | struct MyStruct;\n LL |     println!(\"{}\", MyStruct.foo_one());\n    |                             ^^^^^^^ method cannot be called on `MyStruct` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `MyStruct: Foo`\n+note: the following trait bounds were not satisfied because of the requirements of the implementation of `Foo` for `_`:\n+      `MyStruct: Foo`\n+  --> $DIR/specialization-trait-not-implemented.rs:14:17\n+   |\n+LL | default impl<T> Foo for T {\n+   |                 ^^^     ^\n note: the following trait must be implemented\n   --> $DIR/specialization-trait-not-implemented.rs:7:1\n    |"}]}