{"sha": "30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZTdlNmU4YjAzODlkNDA3ZjhiNDZhYjYwNWE5ZTM0NzVhODUxZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-08T15:59:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-08T15:59:10Z"}, "message": "Auto merge of #24195 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #24143, #24149, #24167, #24178\n- Failed merges:", "tree": {"sha": "bef1b94b366cc2e11d50864953ebc504e54f9257", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bef1b94b366cc2e11d50864953ebc504e54f9257"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "html_url": "https://github.com/rust-lang/rust/commit/30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "url": "https://api.github.com/repos/rust-lang/rust/commits/9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "html_url": "https://github.com/rust-lang/rust/commit/9266d599f4f2367bbc3a5a76a9ce3251da8a1736"}, {"sha": "12e9d7ced01ddb4d293fceedbd20d232cf78a8ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e9d7ced01ddb4d293fceedbd20d232cf78a8ca", "html_url": "https://github.com/rust-lang/rust/commit/12e9d7ced01ddb4d293fceedbd20d232cf78a8ca"}], "stats": {"total": 3002, "additions": 970, "deletions": 2032}, "files": [{"sha": "0f2c37a5abf8346b9c102262b20075adfe825efa", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -163,13 +163,17 @@ This is to make the language easier to parse for humans, especially in the face\n of higher-order functions. `fn foo<T>(f: fn(int): int, fn(T): U): U` is not\n particularly easy to read.\n \n-## `let` is used to introduce variables\n+## Why is `let` used to introduce variables?\n \n-`let` not only defines variables, but can do pattern matching. One can also\n-redeclare immutable variables with `let`. This is useful to avoid unnecessary\n-`mut` annotations. An interesting historical note is that Rust comes,\n-syntactically, most closely from ML, which also uses `let` to introduce\n-bindings.\n+We don't use the term \"variable\", instead, we use \"variable bindings\". The\n+simplest way for binding is the `let` syntax, other ways including `if let`,\n+`while let` and `match`. Bindings also exist in function arguments positions.\n+\n+Bindings always happen in pattern matching positions, and it's also Rust's way\n+to declare mutability. One can also redeclare mutability of a binding in\n+pattern matching. This is useful to avoid unnecessary `mut` annotations. An\n+interesting historical note is that Rust comes, syntactically, most closely\n+from ML, which also uses `let` to introduce bindings.\n \n See also [a long thread][alt] on renaming `let mut` to `var`.\n "}, {"sha": "d894e1c47253b7d12c2740df13dc4958f2db3788", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -1,48 +1,69 @@\n # Summary\n \n-* [The Basics](basic.md)\n+* [Getting Started](getting-started.md)\n     * [Installing Rust](installing-rust.md)\n     * [Hello, world!](hello-world.md)\n     * [Hello, Cargo!](hello-cargo.md)\n+* [Learn Rust](learn-rust.md)\n+* [Effective Rust](effective-rust.md)\n+    * [The Stack and the Heap](the-stack-and-the-heap.md)\n+    * [`Debug` and `Display`](debug-and-display.md)\n+    * [Testing](testing.md)\n+    * [Documentation](documentation.md)\n+    * [Iterators](iterators.md)\n+    * [Concurrency](concurrency.md)\n+    * [Error Handling](error-handling.md)\n+    * [FFI](ffi.md)\n+    * [`Deref` coercions](deref-coercions.md)\n+* [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n-    * [If](if.md)\n+    * [Primitive Types](primitive-types.md)\n     * [Functions](functions.md)\n     * [Comments](comments.md)\n-    * [Compound Data Types](compound-data-types.md)\n+    * [Structs](structs.md)\n+    * [Mutability](mutability.md)\n+    * [Method Syntax](method-syntax.md)\n+    * [Enums](enums.md)\n+    * [`if`](if.md)\n     * [Match](match.md)\n-    * [Looping](looping.md)\n+    * [Patterns](patterns.md)\n+    * [`for` loops](for-loops.md)\n+    * [`while` loops](while-loops.md)\n+    * [Ownership](ownership.md)\n+    * [References and Borrowing](references-and-borrowing.md)\n+    * [Lifetimes](lifetimes.md)\n+    * [Move semantics](move-semantics.md)\n+    * [Drop](drop.md)\n+    * [Vectors](vectors.md)\n+    * [Arrays](arrays.md)\n+    * [Slices](slices.md)\n     * [Strings](strings.md)\n-    * [Arrays, Vectors, and Slices](arrays-vectors-and-slices.md)\n-* [Intermediate Rust](intermediate.md)\n+    * [Traits](traits.md)\n+    * [Operators and Overloading](operators-and-overloading.md)\n+    * [Generics](generics.md)\n+    * [Trait Objects](trait-objects.md)\n+    * [Closures](closures.md)\n+    * [Universal Function Call Syntax](ufcs.md)\n     * [Crates and Modules](crates-and-modules.md)\n-    * [Testing](testing.md)\n-    * [Pointers](pointers.md)\n-    * [Ownership](ownership.md)\n-    * [More Strings](more-strings.md)\n-    * [Patterns](patterns.md)\n-    * [Method Syntax](method-syntax.md)\n+    * [`static`](static.md)\n+    * [`const`](const.md)\n+    * [Tuples](tuples.md)\n+    * [Tuple Structs](tuple-structs.md)\n+    * [Attributes](attributes.md)\n+    * [Conditional Compilation](conditional-compilation.md)\n+    * [`type` aliases](type-aliases.md)\n+    * [Casting between types](casting-between-types.md)\n     * [Associated Types](associated-types.md)\n-    * [Closures](closures.md)\n-    * [Iterators](iterators.md)\n-    * [Generics](generics.md)\n-    * [Traits](traits.md)\n-    * [Static and Dynamic Dispatch](static-and-dynamic-dispatch.md)\n+    * [Unsized Types](unsized-types.md)\n     * [Macros](macros.md)\n-    * [Concurrency](concurrency.md)\n-    * [Error Handling](error-handling.md)\n-    * [Documentation](documentation.md)\n-* [Advanced Topics](advanced.md)\n-    * [FFI](ffi.md)\n-    * [Unsafe Code](unsafe.md)\n-    * [Advanced Macros](advanced-macros.md)\n-* [Unstable Rust](unstable.md)\n-    * [Compiler Plugins](plugins.md)\n+    * [`unsafe` Code](unsafe-code.md)\n+* [Nightly Rust](nightly-rust.md)\n+    * [Compiler Plugins](compiler-plugins.md)\n     * [Inline Assembly](inline-assembly.md)\n     * [No stdlib](no-stdlib.md)\n     * [Intrinsics](intrinsics.md)\n     * [Lang items](lang-items.md)\n     * [Link args](link-args.md)\n     * [Benchmark Tests](benchmark-tests.md)\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n-* [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "fef458caaaf3343a1aa2e198888d005bc2ba8221", "filename": "src/doc/trpl/advanced-macros.md", "status": "removed", "additions": 0, "deletions": 242, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,242 +0,0 @@\n-% Advanced macros\n-\n-This chapter picks up where the [introductory macro chapter](macros.html) left\n-off.\n-\n-# Syntactic requirements\n-\n-Even when Rust code contains un-expanded macros, it can be parsed as a full\n-[syntax tree][ast]. This property can be very useful for editors and other\n-tools that process code. It also has a few consequences for the design of\n-Rust's macro system.\n-\n-[ast]: glossary.html#abstract-syntax-tree\n-\n-One consequence is that Rust must determine, when it parses a macro invocation,\n-whether the macro stands in for\n-\n-* zero or more items,\n-* zero or more methods,\n-* an expression,\n-* a statement, or\n-* a pattern.\n-\n-A macro invocation within a block could stand for some items, or for an\n-expression / statement. Rust uses a simple rule to resolve this ambiguity. A\n-macro invocation that stands for items must be either\n-\n-* delimited by curly braces, e.g. `foo! { ... }`, or\n-* terminated by a semicolon, e.g. `foo!(...);`\n-\n-Another consequence of pre-expansion parsing is that the macro invocation must\n-consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces\n-must be balanced within a macro invocation. For example, `foo!([)` is\n-forbidden. This allows Rust to know where the macro invocation ends.\n-\n-More formally, the macro invocation body must be a sequence of *token trees*.\n-A token tree is defined recursively as either\n-\n-* a sequence of token trees surrounded by matching `()`, `[]`, or `{}`, or\n-* any other single token.\n-\n-Within a matcher, each metavariable has a *fragment specifier*, identifying\n-which syntactic form it matches.\n-\n-* `ident`: an identifier. Examples: `x`; `foo`.\n-* `path`: a qualified name. Example: `T::SpecialA`.\n-* `expr`: an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`; `f(42)`.\n-* `ty`: a type. Examples: `i32`; `Vec<(char, String)>`; `&T`.\n-* `pat`: a pattern. Examples: `Some(t)`; `(17, 'a')`; `_`.\n-* `stmt`: a single statement. Example: `let x = 3`.\n-* `block`: a brace-delimited sequence of statements. Example:\n-  `{ log(error, \"hi\"); return 12; }`.\n-* `item`: an [item][]. Examples: `fn foo() { }`; `struct Bar;`.\n-* `meta`: a \"meta item\", as found in attributes. Example: `cfg(target_os = \"windows\")`.\n-* `tt`: a single token tree.\n-\n-There are additional rules regarding the next token after a metavariable:\n-\n-* `expr` variables must be followed by one of: `=> , ;`\n-* `ty` and `path` variables must be followed by one of: `=> , : = > as`\n-* `pat` variables must be followed by one of: `=> , =`\n-* Other variables may be followed by any token.\n-\n-These rules provide some flexibility for Rust's syntax to evolve without\n-breaking existing macros.\n-\n-The macro system does not deal with parse ambiguity at all. For example, the\n-grammar `$($t:ty)* $e:expr` will always fail to parse, because the parser would\n-be forced to choose between parsing `$t` and parsing `$e`. Changing the\n-invocation syntax to put a distinctive token in front can solve the problem. In\n-this case, you can write `$(T $t:ty)* E $e:exp`.\n-\n-[item]: ../reference.html#items\n-\n-# Scoping and macro import/export\n-\n-Macros are expanded at an early stage in compilation, before name resolution.\n-One downside is that scoping works differently for macros, compared to other\n-constructs in the language.\n-\n-Definition and expansion of macros both happen in a single depth-first,\n-lexical-order traversal of a crate's source. So a macro defined at module scope\n-is visible to any subsequent code in the same module, which includes the body\n-of any subsequent child `mod` items.\n-\n-A macro defined within the body of a single `fn`, or anywhere else not at\n-module scope, is visible only within that item.\n-\n-If a module has the `macro_use` attribute, its macros are also visible in its\n-parent module after the child's `mod` item. If the parent also has `macro_use`\n-then the macros will be visible in the grandparent after the parent's `mod`\n-item, and so forth.\n-\n-The `macro_use` attribute can also appear on `extern crate`. In this context\n-it controls which macros are loaded from the external crate, e.g.\n-\n-```rust,ignore\n-#[macro_use(foo, bar)]\n-extern crate baz;\n-```\n-\n-If the attribute is given simply as `#[macro_use]`, all macros are loaded. If\n-there is no `#[macro_use]` attribute then no macros are loaded. Only macros\n-defined with the `#[macro_export]` attribute may be loaded.\n-\n-To load a crate's macros *without* linking it into the output, use `#[no_link]`\n-as well.\n-\n-An example:\n-\n-```rust\n-macro_rules! m1 { () => (()) }\n-\n-// visible here: m1\n-\n-mod foo {\n-    // visible here: m1\n-\n-    #[macro_export]\n-    macro_rules! m2 { () => (()) }\n-\n-    // visible here: m1, m2\n-}\n-\n-// visible here: m1\n-\n-macro_rules! m3 { () => (()) }\n-\n-// visible here: m1, m3\n-\n-#[macro_use]\n-mod bar {\n-    // visible here: m1, m3\n-\n-    macro_rules! m4 { () => (()) }\n-\n-    // visible here: m1, m3, m4\n-}\n-\n-// visible here: m1, m3, m4\n-# fn main() { }\n-```\n-\n-When this library is loaded with `#[macro_use] extern crate`, only `m2` will\n-be imported.\n-\n-The Rust Reference has a [listing of macro-related\n-attributes](../reference.html#macro--and-plugin-related-attributes).\n-\n-# The variable `$crate`\n-\n-A further difficulty occurs when a macro is used in multiple crates. Say that\n-`mylib` defines\n-\n-```rust\n-pub fn increment(x: u32) -> u32 {\n-    x + 1\n-}\n-\n-#[macro_export]\n-macro_rules! inc_a {\n-    ($x:expr) => ( ::increment($x) )\n-}\n-\n-#[macro_export]\n-macro_rules! inc_b {\n-    ($x:expr) => ( ::mylib::increment($x) )\n-}\n-# fn main() { }\n-```\n-\n-`inc_a` only works within `mylib`, while `inc_b` only works outside the\n-library. Furthermore, `inc_b` will break if the user imports `mylib` under\n-another name.\n-\n-Rust does not (yet) have a hygiene system for crate references, but it does\n-provide a simple workaround for this problem. Within a macro imported from a\n-crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n-By contrast, when a macro is defined and then used in the same crate, `$crate`\n-will expand to nothing. This means we can write\n-\n-```rust\n-#[macro_export]\n-macro_rules! inc {\n-    ($x:expr) => ( $crate::increment($x) )\n-}\n-# fn main() { }\n-```\n-\n-to define a single macro that works both inside and outside our library. The\n-function name will expand to either `::increment` or `::mylib::increment`.\n-\n-To keep this system simple and correct, `#[macro_use] extern crate ...` may\n-only appear at the root of your crate, not inside `mod`. This ensures that\n-`$crate` is a single identifier.\n-\n-# The deep end\n-\n-The introductory chapter mentioned recursive macros, but it did not give the\n-full story. Recursive macros are useful for another reason: Each recursive\n-invocation gives you another opportunity to pattern-match the macro's\n-arguments.\n-\n-As an extreme example, it is possible, though hardly advisable, to implement\n-the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n-within Rust's macro system.\n-\n-```rust\n-macro_rules! bct {\n-    // cmd 0:  d ... => ...\n-    (0, $($ps:tt),* ; $_d:tt)\n-        => (bct!($($ps),*, 0 ; ));\n-    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n-        => (bct!($($ps),*, 0 ; $($ds),*));\n-\n-    // cmd 1p:  1 ... => 1 ... p\n-    (1, $p:tt, $($ps:tt),* ; 1)\n-        => (bct!($($ps),*, 1, $p ; 1, $p));\n-    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n-\n-    // cmd 1p:  0 ... => 0 ...\n-    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; $($ds),*));\n-\n-    // halt on empty data string\n-    ( $($ps:tt),* ; )\n-        => (());\n-}\n-```\n-\n-Exercise: use macros to reduce duplication in the above definition of the\n-`bct!` macro.\n-\n-# Procedural macros\n-\n-If Rust's macro system can't do what you need, you may want to write a\n-[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n-macros, this is significantly more work, the interfaces are much less stable,\n-and bugs can be much harder to track down. In exchange you get the\n-flexibility of running arbitrary Rust code within the compiler. Syntax\n-extension plugins are sometimes called *procedural macros* for this reason."}, {"sha": "447a8a614bf564c9116fe99bdbd04c2b438b932d", "filename": "src/doc/trpl/advanced.md", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fadvanced.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fadvanced.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,8 +0,0 @@\n-% Advanced\n-\n-In a similar fashion to \"Intermediate,\" this section is full of individual,\n-deep-dive chapters, which stand alone and can be read in any order. These\n-chapters focus on the most complex features, as well as some things that\n-are only available in upcoming versions of Rust.\n-\n-After reading \"Advanced,\" you'll be a Rust expert!"}, {"sha": "2916dca2c06b01ac863415456de556f289ca44a5", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,102 +0,0 @@\n-% Arrays, Vectors, and Slices\n-\n-Like many programming languages, Rust has list types to represent a sequence of\n-things. The most basic is the *array*, a fixed-size list of elements of the\n-same type. By default, arrays are immutable.\n-\n-```{rust}\n-let a = [1, 2, 3]; // a: [i32; 3]\n-let mut m = [1, 2, 3]; // mut m: [i32; 3]\n-```\n-\n-There's a shorthand for initializing each element of an array to the same\n-value. In this example, each element of `a` will be initialized to `0`:\n-\n-```{rust}\n-let a = [0; 20]; // a: [i32; 20]\n-```\n-\n-Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we\n-cover generics.\n-\n-You can get the number of elements in an array `a` with `a.len()`, and use\n-`a.iter()` to iterate over them with a for loop. This code will print each\n-number in order:\n-\n-```{rust}\n-let a = [1, 2, 3];\n-\n-println!(\"a has {} elements\", a.len());\n-for e in a.iter() {\n-    println!(\"{}\", e);\n-}\n-```\n-\n-You can access a particular element of an array with *subscript notation*:\n-\n-```{rust}\n-let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n-\n-println!(\"The second name is: {}\", names[1]);\n-```\n-\n-Subscripts start at zero, like in most programming languages, so the first name\n-is `names[0]` and the second name is `names[1]`. The above example prints\n-`The second name is: Brian`. If you try to use a subscript that is not in the\n-array, you will get an error: array access is bounds-checked at run-time. Such\n-errant access is the source of many bugs in other systems programming\n-languages.\n-\n-A *vector* is a dynamic or \"growable\" array, implemented as the standard\n-library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n-later). Vectors always allocate their data on the heap. Vectors are to slices\n-what `String` is to `&str`. You can create them with the `vec!` macro:\n-\n-```{rust}\n-let v = vec![1, 2, 3]; // v: Vec<i32>\n-```\n-\n-(Notice that unlike the `println!` macro we've used in the past, we use square\n-brackets `[]` with `vec!`. Rust allows you to use either in either situation,\n-this is just convention.)\n-\n-There's an alternate form of `vec!` for repeating an initial value:\n-\n-```\n-let v = vec![0; 10]; // ten zeroes\n-```\n-\n-You can get the length of, iterate over, and subscript vectors just like\n-arrays. In addition, (mutable) vectors can grow automatically:\n-\n-```{rust}\n-let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>\n-\n-nums.push(4);\n-\n-println!(\"The length of nums is now {}\", nums.len()); // Prints 4\n-```\n-\n-Vectors have many more useful methods.\n-\n-A *slice* is a reference to (or \"view\" into) an array. They are useful for\n-allowing safe, efficient access to a portion of an array without copying. For\n-example, you might want to reference just one line of a file read into memory.\n-By nature, a slice is not created directly, but from an existing variable.\n-Slices have a length, can be mutable or not, and in many ways behave like\n-arrays:\n-\n-```{rust}\n-let a = [0, 1, 2, 3, 4];\n-let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n-\n-for e in middle.iter() {\n-    println!(\"{}\", e); // Prints 1, 2, 3\n-}\n-```\n-\n-You can also take a slice of a vector, `String`, or `&str`, because they are\n-backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover\n-generics.\n-\n-We have now learned all of the most basic Rust concepts."}, {"sha": "a6ecac962d60de4acb58795e19bcb03b0a98ec7e", "filename": "src/doc/trpl/arrays.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Farrays.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Farrays.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,48 @@\n+% Arrays\n+\n+Like many programming languages, Rust has list types to represent a sequence of\n+things. The most basic is the *array*, a fixed-size list of elements of the\n+same type. By default, arrays are immutable.\n+\n+```{rust}\n+let a = [1, 2, 3]; // a: [i32; 3]\n+let mut m = [1, 2, 3]; // mut m: [i32; 3]\n+```\n+\n+There's a shorthand for initializing each element of an array to the same\n+value. In this example, each element of `a` will be initialized to `0`:\n+\n+```{rust}\n+let a = [0; 20]; // a: [i32; 20]\n+```\n+\n+Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we\n+cover generics.\n+\n+You can get the number of elements in an array `a` with `a.len()`, and use\n+`a.iter()` to iterate over them with a for loop. This code will print each\n+number in order:\n+\n+```{rust}\n+let a = [1, 2, 3];\n+\n+println!(\"a has {} elements\", a.len());\n+for e in a.iter() {\n+    println!(\"{}\", e);\n+}\n+```\n+\n+You can access a particular element of an array with *subscript notation*:\n+\n+```{rust}\n+let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n+\n+println!(\"The second name is: {}\", names[1]);\n+```\n+\n+Subscripts start at zero, like in most programming languages, so the first name\n+is `names[0]` and the second name is `names[1]`. The above example prints\n+`The second name is: Brian`. If you try to use a subscript that is not in the\n+array, you will get an error: array access is bounds-checked at run-time. Such\n+errant access is the source of many bugs in other systems programming\n+languages."}, {"sha": "e699bd85f6ed7309dadf4889ade054d54e493682", "filename": "src/doc/trpl/attributes.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fattributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fattributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fattributes.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Attributes\n+\n+Coming Soon!"}, {"sha": "c267830e6e0d0c5e0fc700713abb67ad205ef7d4", "filename": "src/doc/trpl/basic.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fbasic.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fbasic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbasic.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,7 +0,0 @@\n-% Basics\n-\n-This section is a linear introduction to the basic syntax and semantics of\n-Rust. It has individual sections on each part of Rust's syntax.\n-\n-After reading \"Basics,\" you will have a good foundation to learn more about\n-Rust, and can write very simple programs."}, {"sha": "8bb0ec6db0256c12b44471258313449b972d2f55", "filename": "src/doc/trpl/casting-between-types.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Casting Between Types\n+\n+Coming Soon"}, {"sha": "9eb22a7f6985a51bb6e026aaf73896f1a630135a", "filename": "src/doc/trpl/compiler-plugins.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "previous_filename": "src/doc/trpl/plugins.md"}, {"sha": "e44d2edd667a1ea822cde1798278bbc8b1fe3b55", "filename": "src/doc/trpl/compound-data-types.md", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,364 +0,0 @@\n-% Compound Data Types\n-\n-Rust, like many programming languages, has a number of different data types\n-that are built-in. You've already done some simple work with integers and\n-strings, but next, let's talk about some more complicated ways of storing data.\n-\n-## Tuples\n-\n-The first compound data type we're going to talk about is called the *tuple*.\n-A tuple is an ordered list of fixed size. Like this:\n-\n-```rust\n-let x = (1, \"hello\");\n-```\n-\n-The parentheses and commas form this two-length tuple. Here's the same code, but\n-with the type annotated:\n-\n-```rust\n-let x: (i32, &str) = (1, \"hello\");\n-```\n-\n-As you can see, the type of a tuple looks just like the tuple, but with each\n-position having a type name rather than the value. Careful readers will also\n-note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n-You have briefly seen `&str` used as a type before, and we'll discuss the\n-details of strings later. In systems programming languages, strings are a bit\n-more complex than in other languages. For now, just read `&str` as a *string\n-slice*, and we'll learn more soon.\n-\n-You can access the fields in a tuple through a *destructuring let*. Here's\n-an example:\n-\n-```rust\n-let (x, y, z) = (1, 2, 3);\n-\n-println!(\"x is {}\", x);\n-```\n-\n-Remember before when I said the left-hand side of a `let` statement was more\n-powerful than just assigning a binding? Here we are. We can put a pattern on\n-the left-hand side of the `let`, and if it matches up to the right-hand side,\n-we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n-or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n-\n-This pattern is very powerful, and we'll see it repeated more later.\n-\n-There are also a few things you can do with a tuple as a whole, without\n-destructuring. You can assign one tuple into another, if they have the same\n-contained types and [arity]. Tuples have the same arity when they have the same\n-length.\n-\n-```rust\n-let mut x = (1, 2); // x: (i32, i32)\n-let y = (2, 3); // y: (i32, i32)\n-\n-x = y;\n-```\n-\n-You can also check for equality with `==`. Again, this will only compile if the\n-tuples have the same type.\n-\n-```rust\n-let x = (1, 2, 3);\n-let y = (2, 2, 4);\n-\n-if x == y {\n-    println!(\"yes\");\n-} else {\n-    println!(\"no\");\n-}\n-```\n-\n-This will print `no`, because some of the values aren't equal.\n-\n-Note that the order of the values is considered when checking for equality,\n-so the following example will also print `no`.\n-\n-```rust\n-let x = (1, 2, 3);\n-let y = (2, 1, 3);\n-\n-if x == y {\n-    println!(\"yes\");\n-} else {\n-    println!(\"no\");\n-}\n-```\n-\n-One other use of tuples is to return multiple values from a function:\n-\n-```rust\n-fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }\n-\n-fn main() {\n-    let (x, y) = next_two(5);\n-    println!(\"x, y = {}, {}\", x, y);\n-}\n-```\n-\n-Even though Rust functions can only return one value, a tuple *is* one value,\n-that happens to be made up of more than one value. You can also see in this\n-example how you can destructure a pattern returned by a function, as well.\n-\n-Tuples are a very simple data structure, and so are not often what you want.\n-Let's move on to their bigger sibling, structs.\n-\n-## Structs\n-\n-A struct is another form of a *record type*, just like a tuple. There's a\n-difference: structs give each element that they contain a name, called a\n-*field* or a *member*. Check it out:\n-\n-```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-fn main() {\n-    let origin = Point { x: 0, y: 0 }; // origin: Point\n-\n-    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n-}\n-```\n-\n-There's a lot going on here, so let's break it down. We declare a struct with\n-the `struct` keyword, and then with a name. By convention, structs begin with a\n-capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n-\n-We can create an instance of our struct via `let`, as usual, but we use a `key:\n-value` style syntax to set each field. The order doesn't need to be the same as\n-in the original declaration.\n-\n-Finally, because fields have names, we can access the field through dot\n-notation: `origin.x`.\n-\n-The values in structs are immutable by default, like other bindings in Rust.\n-Use `mut` to make them mutable:\n-\n-```{rust}\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-fn main() {\n-    let mut point = Point { x: 0, y: 0 };\n-\n-    point.x = 5;\n-\n-    println!(\"The point is at ({}, {})\", point.x, point.y);\n-}\n-```\n-\n-This will print `The point is at (5, 0)`.\n-\n-## Tuple Structs and Newtypes\n-\n-Rust has another data type that's like a hybrid between a tuple and a struct,\n-called a *tuple struct*. Tuple structs do have a name, but their fields don't:\n-\n-\n-```{rust}\n-struct Color(i32, i32, i32);\n-struct Point(i32, i32, i32);\n-```\n-\n-These two will not be equal, even if they have the same values:\n-\n-```{rust}\n-# struct Color(i32, i32, i32);\n-# struct Point(i32, i32, i32);\n-let black = Color(0, 0, 0);\n-let origin = Point(0, 0, 0);\n-```\n-\n-It is almost always better to use a struct than a tuple struct. We would write\n-`Color` and `Point` like this instead:\n-\n-```{rust}\n-struct Color {\n-    red: i32,\n-    blue: i32,\n-    green: i32,\n-}\n-\n-struct Point {\n-    x: i32,\n-    y: i32,\n-    z: i32,\n-}\n-```\n-\n-Now, we have actual names, rather than positions. Good names are important,\n-and with a struct, we have actual names.\n-\n-There _is_ one case when a tuple struct is very useful, though, and that's a\n-tuple struct with only one element. We call this the *newtype* pattern, because\n-it allows you to create a new type, distinct from that of its contained value\n-and expressing its own semantic meaning:\n-\n-```{rust}\n-struct Inches(i32);\n-\n-let length = Inches(10);\n-\n-let Inches(integer_length) = length;\n-println!(\"length is {} inches\", integer_length);\n-```\n-\n-As you can see here, you can extract the inner integer type through a\n-destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n-`let Inches(integer_length)` assigns `10` to `integer_length`.\n-\n-## Enums\n-\n-Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n-feature of Rust, and are used throughout the standard library. An `enum` is\n-a type which relates a set of alternates to a specific name. For example, below\n-we define `Character` to be either a `Digit` or something else. These\n-can be used via their fully scoped names: `Character::Other` (more about `::`\n-below).\n-\n-```rust\n-enum Character {\n-    Digit(i32),\n-    Other,\n-}\n-```\n-\n-Most normal types are allowed as the variant components of an `enum`. Here are\n-some examples:\n-\n-```rust\n-struct Empty;\n-struct Color(i32, i32, i32);\n-struct Length(i32);\n-struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n-struct HeightDatabase(Vec<i32>);\n-```\n-\n-You see that, depending on its type, an `enum` variant may or may not hold data.\n-In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n-value, where `Other` is only a name. However, the fact that they represent\n-distinct categories of `Character` is a very useful property.\n-\n-As with structures, the variants of an enum by default are not comparable with\n-equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n-support other binary operations such as `*` and `+`. As such, the following code\n-is invalid for the example `Character` type:\n-\n-```{rust,ignore}\n-// These assignments both succeed\n-let ten  = Character::Digit(10);\n-let four = Character::Digit(4);\n-\n-// Error: `*` is not implemented for type `Character`\n-let forty = ten * four;\n-\n-// Error: `<=` is not implemented for type `Character`\n-let four_is_smaller = four <= ten;\n-\n-// Error: `==` is not implemented for type `Character`\n-let four_equals_ten = four == ten;\n-```\n-\n-This may seem rather limiting, but it's a limitation which we can overcome.\n-There are two ways: by implementing equality ourselves, or by pattern matching\n-variants with [`match`][match] expressions, which you'll learn in the next\n-chapter. We don't know enough about Rust to implement equality yet, but we can\n-use the `Ordering` enum from the standard library, which does:\n-\n-```\n-enum Ordering {\n-    Less,\n-    Equal,\n-    Greater,\n-}\n-```\n-\n-Because `Ordering` has already been defined for us, we will import it with the\n-`use` keyword. Here's an example of how it is used:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives\n-in the `cmp` submodule of the `std` module. We'll talk more about modules later\n-in the guide. For now, all you need to know is that you can `use` things from\n-the standard library if you need them.\n-\n-Okay, let's talk about the actual code in the example. `cmp` is a function that\n-compares two things, and returns an `Ordering`. We return either\n-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n-whether the first value is less than, greater than, or equal to the second. Note\n-that each variant of the `enum` is namespaced under the `enum` itself: it's\n-`Ordering::Greater`, not `Greater`.\n-\n-The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We then do a bunch of `if`/`else` comparisons to check which\n-one it is.\n-\n-This `Ordering::Greater` notation is too long. Let's use another form of `use`\n-to import the `enum` variants instead. This will avoid full scoping:\n-\n-```{rust}\n-use std::cmp::Ordering::{self, Equal, Less, Greater};\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Less { println!(\"less\"); }\n-    else if ordering == Greater { println!(\"greater\"); }\n-    else if ordering == Equal { println!(\"equal\"); }\n-}\n-```\n-\n-Importing variants is convenient and compact, but can also cause name conflicts,\n-so do this with caution. For this reason, it's normally considered better style\n-to `use` an enum rather than its variants directly.\n-\n-As you can see, `enum`s are quite a powerful tool for data representation, and\n-are even more useful when they're [generic][generics] across types. Before we\n-get to generics, though, let's talk about how to use enums with pattern\n-matching, a tool that will let us deconstruct sum types (the type theory term\n-for enums) like `Ordering` in a very elegant way that avoids all these messy\n-and brittle `if`/`else`s.\n-\n-\n-[arity]: ./glossary.html#arity\n-[match]: ./match.html\n-[generics]: ./generics.html"}, {"sha": "9afddb11314fe9dd0da67ca9e2a6c232fec0280b", "filename": "src/doc/trpl/conclusion.md", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fconclusion.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fconclusion.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconclusion.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,11 +0,0 @@\n-% Conclusion\n-\n-We covered a lot of ground here. When you've mastered everything in this Guide,\n-you will have a firm grasp of Rust development. There's a whole lot more\n-out there, though, we've just covered the surface. There's tons of topics that\n-you can dig deeper into, e.g. by reading the API documentation of the\n-[standard library](http://doc.rust-lang.org/std/), by discovering solutions for\n-common problems on [Rust by Example](http://rustbyexample.com/), or by browsing\n-crates written by the community on [crates.io](https://crates.io/).\n-\n-Happy hacking!"}, {"sha": "40367fa844d2ebceae3e5c9874fa1ca094d22779", "filename": "src/doc/trpl/conditional-compilation.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fconditional-compilation.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fconditional-compilation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconditional-compilation.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Conditional Compilation\n+\n+Coming Soon!"}, {"sha": "9234c4fc2f9e1fce636e1e0a762f651d8eb9bc38", "filename": "src/doc/trpl/const.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fconst.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fconst.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconst.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% `const`\n+\n+Coming soon!"}, {"sha": "6c8d788b5ae3bad1fcf04e29402e2a00c7256a2e", "filename": "src/doc/trpl/debug-and-display.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% `Debug` and `Display`\n+\n+Coming soon!"}, {"sha": "afacd3040552175b17eaed7b74d87697150ae917", "filename": "src/doc/trpl/deref-coercions.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fderef-coercions.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% `Deref` coercions\n+\n+Coming soon!"}, {"sha": "af58e23561c3625cbba8140ac462b863f60d9030", "filename": "src/doc/trpl/drop.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fdrop.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fdrop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdrop.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% `Drop`\n+\n+Coming soon!"}, {"sha": "6ea0759e99d7b7a07dfae6fe9b7d9e621cd9aee7", "filename": "src/doc/trpl/effective-rust.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Feffective-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Feffective-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Feffective-rust.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1 @@\n+% Effective Rust"}, {"sha": "cbb74d97c35558822007cf734b1e61c3597086aa", "filename": "src/doc/trpl/enums.md", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,149 @@\n+% Enums\n+\n+Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n+feature of Rust, and are used throughout the standard library. An `enum` is\n+a type which relates a set of alternates to a specific name. For example, below\n+we define `Character` to be either a `Digit` or something else. These\n+can be used via their fully scoped names: `Character::Other` (more about `::`\n+below).\n+\n+```rust\n+enum Character {\n+    Digit(i32),\n+    Other,\n+}\n+```\n+\n+Most normal types are allowed as the variant components of an `enum`. Here are\n+some examples:\n+\n+```rust\n+struct Empty;\n+struct Color(i32, i32, i32);\n+struct Length(i32);\n+struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n+struct HeightDatabase(Vec<i32>);\n+```\n+\n+You see that, depending on its type, an `enum` variant may or may not hold data.\n+In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n+value, where `Other` is only a name. However, the fact that they represent\n+distinct categories of `Character` is a very useful property.\n+\n+As with structures, the variants of an enum by default are not comparable with\n+equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n+support other binary operations such as `*` and `+`. As such, the following code\n+is invalid for the example `Character` type:\n+\n+```{rust,ignore}\n+// These assignments both succeed\n+let ten  = Character::Digit(10);\n+let four = Character::Digit(4);\n+\n+// Error: `*` is not implemented for type `Character`\n+let forty = ten * four;\n+\n+// Error: `<=` is not implemented for type `Character`\n+let four_is_smaller = four <= ten;\n+\n+// Error: `==` is not implemented for type `Character`\n+let four_equals_ten = four == ten;\n+```\n+\n+This may seem rather limiting, but it's a limitation which we can overcome.\n+There are two ways: by implementing equality ourselves, or by pattern matching\n+variants with [`match`][match] expressions, which you'll learn in the next\n+chapter. We don't know enough about Rust to implement equality yet, but we can\n+use the `Ordering` enum from the standard library, which does:\n+\n+```\n+enum Ordering {\n+    Less,\n+    Equal,\n+    Greater,\n+}\n+```\n+\n+Because `Ordering` has already been defined for us, we will import it with the\n+`use` keyword. Here's an example of how it is used:\n+\n+```{rust}\n+use std::cmp::Ordering;\n+\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = 10;\n+\n+    let ordering = cmp(x, y); // ordering: Ordering\n+\n+    if ordering == Ordering::Less {\n+        println!(\"less\");\n+    } else if ordering == Ordering::Greater {\n+        println!(\"greater\");\n+    } else if ordering == Ordering::Equal {\n+        println!(\"equal\");\n+    }\n+}\n+```\n+\n+The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives\n+in the `cmp` submodule of the `std` module. We'll talk more about modules later\n+in the guide. For now, all you need to know is that you can `use` things from\n+the standard library if you need them.\n+\n+Okay, let's talk about the actual code in the example. `cmp` is a function that\n+compares two things, and returns an `Ordering`. We return either\n+`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n+whether the first value is less than, greater than, or equal to the second. Note\n+that each variant of the `enum` is namespaced under the `enum` itself: it's\n+`Ordering::Greater`, not `Greater`.\n+\n+The `ordering` variable has the type `Ordering`, and so contains one of the\n+three values. We then do a bunch of `if`/`else` comparisons to check which\n+one it is.\n+\n+This `Ordering::Greater` notation is too long. Let's use another form of `use`\n+to import the `enum` variants instead. This will avoid full scoping:\n+\n+```{rust}\n+use std::cmp::Ordering::{self, Equal, Less, Greater};\n+\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = 10;\n+\n+    let ordering = cmp(x, y); // ordering: Ordering\n+\n+    if ordering == Less { println!(\"less\"); }\n+    else if ordering == Greater { println!(\"greater\"); }\n+    else if ordering == Equal { println!(\"equal\"); }\n+}\n+```\n+\n+Importing variants is convenient and compact, but can also cause name conflicts,\n+so do this with caution. For this reason, it's normally considered better style\n+to `use` an enum rather than its variants directly.\n+\n+As you can see, `enum`s are quite a powerful tool for data representation, and\n+are even more useful when they're [generic][generics] across types. Before we\n+get to generics, though, let's talk about how to use enums with pattern\n+matching, a tool that will let us deconstruct sum types (the type theory term\n+for enums) like `Ordering` in a very elegant way that avoids all these messy\n+and brittle `if`/`else`s.\n+\n+\n+[arity]: ./glossary.html#arity\n+[match]: ./match.html\n+[generics]: ./generics.html"}, {"sha": "45ae5a2e2dd9a01d3279491a9203e177be467005", "filename": "src/doc/trpl/for-loops.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffor-loops.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,44 @@\n+% `for` Loops\n+\n+The `for` loop is used to loop a particular number of times. Rust's `for` loops\n+work a bit differently than in other systems languages, however. Rust's `for`\n+loop doesn't look like this \"C-style\" `for` loop:\n+\n+```{c}\n+for (x = 0; x < 10; x++) {\n+    printf( \"%d\\n\", x );\n+}\n+```\n+\n+Instead, it looks like this:\n+\n+```{rust}\n+for x in 0..10 {\n+    println!(\"{}\", x); // x: i32\n+}\n+```\n+\n+In slightly more abstract terms,\n+\n+```{ignore}\n+for var in expression {\n+    code\n+}\n+```\n+\n+The expression is an iterator, which we will discuss in more depth later in the\n+guide. The iterator gives back a series of elements. Each element is one\n+iteration of the loop. That value is then bound to the name `var`, which is\n+valid for the loop body. Once the body is over, the next value is fetched from\n+the iterator, and we loop another time. When there are no more values, the\n+`for` loop is over.\n+\n+In our example, `0..10` is an expression that takes a start and an end position,\n+and gives an iterator over those values. The upper bound is exclusive, though,\n+so our loop will print `0` through `9`, not `10`.\n+\n+Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n+each element of the loop is complicated and error prone, even for experienced C\n+developers.\n+\n+We'll talk more about `for` when we cover *iterators*, later in the Guide."}, {"sha": "a164def516b93d90c34ef5a993190634a3d72e3c", "filename": "src/doc/trpl/getting-started.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgetting-started.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1 @@\n+% Getting Started"}, {"sha": "92f95341f814940fde7d73a72e4c8e22a9ae2862", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -1,4 +1,4 @@\n-% If\n+% `if`\n \n Rust's take on `if` is not particularly complex, but it's much more like the\n `if` you'll find in a dynamically typed language than in a more traditional\n@@ -153,3 +153,5 @@ instead.\n \n There's one more time in which you won't see a semicolon at the end of a line\n of Rust code. For that, we'll need our next concept: functions.\n+\n+TODO: `if let`"}, {"sha": "73370a32231ebec4d452ed56f65343959ccf6891", "filename": "src/doc/trpl/intermediate.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fintermediate.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fintermediate.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintermediate.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,7 +0,0 @@\n-% Intermediate\n-\n-This section contains individual chapters, which are self-contained. They focus\n-on specific topics, and can be read in any order.\n-\n-After reading \"Intermediate,\" you will have a solid understanding of Rust,\n-and will be able to understand most Rust code and write more complex programs."}, {"sha": "e5482d3fb968185515661fe5f0486b32b8a803fd", "filename": "src/doc/trpl/learn-rust.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flearn-rust.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1 @@\n+% Learn Rust"}, {"sha": "c6eee97dc6a61a5dfc7e531a4b6107f42e98396f", "filename": "src/doc/trpl/lifetimes.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Lifetimes\n+\n+Coming soon!"}, {"sha": "6d21cb59383c73beb6bfd62e34f81f9c9717ee71", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 235, "deletions": 4, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -424,9 +424,240 @@ they are unstable and require feature gates.\n * `trace_macros!(true)` will enable a compiler message every time a macro is\n   expanded. Use `trace_macros!(false)` later in expansion to turn it off.\n \n-# Further reading\n+# Syntactic requirements\n \n-The [advanced macros chapter][] goes into more detail about macro syntax. It\n-also describes how to share macros between different modules or crates.\n+Even when Rust code contains un-expanded macros, it can be parsed as a full\n+[syntax tree][ast]. This property can be very useful for editors and other\n+tools that process code. It also has a few consequences for the design of\n+Rust's macro system.\n \n-[advanced macros chapter]: advanced-macros.html\n+[ast]: glossary.html#abstract-syntax-tree\n+\n+One consequence is that Rust must determine, when it parses a macro invocation,\n+whether the macro stands in for\n+\n+* zero or more items,\n+* zero or more methods,\n+* an expression,\n+* a statement, or\n+* a pattern.\n+\n+A macro invocation within a block could stand for some items, or for an\n+expression / statement. Rust uses a simple rule to resolve this ambiguity. A\n+macro invocation that stands for items must be either\n+\n+* delimited by curly braces, e.g. `foo! { ... }`, or\n+* terminated by a semicolon, e.g. `foo!(...);`\n+\n+Another consequence of pre-expansion parsing is that the macro invocation must\n+consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces\n+must be balanced within a macro invocation. For example, `foo!([)` is\n+forbidden. This allows Rust to know where the macro invocation ends.\n+\n+More formally, the macro invocation body must be a sequence of *token trees*.\n+A token tree is defined recursively as either\n+\n+* a sequence of token trees surrounded by matching `()`, `[]`, or `{}`, or\n+* any other single token.\n+\n+Within a matcher, each metavariable has a *fragment specifier*, identifying\n+which syntactic form it matches.\n+\n+* `ident`: an identifier. Examples: `x`; `foo`.\n+* `path`: a qualified name. Example: `T::SpecialA`.\n+* `expr`: an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`; `f(42)`.\n+* `ty`: a type. Examples: `i32`; `Vec<(char, String)>`; `&T`.\n+* `pat`: a pattern. Examples: `Some(t)`; `(17, 'a')`; `_`.\n+* `stmt`: a single statement. Example: `let x = 3`.\n+* `block`: a brace-delimited sequence of statements. Example:\n+  `{ log(error, \"hi\"); return 12; }`.\n+* `item`: an [item][]. Examples: `fn foo() { }`; `struct Bar;`.\n+* `meta`: a \"meta item\", as found in attributes. Example: `cfg(target_os = \"windows\")`.\n+* `tt`: a single token tree.\n+\n+There are additional rules regarding the next token after a metavariable:\n+\n+* `expr` variables must be followed by one of: `=> , ;`\n+* `ty` and `path` variables must be followed by one of: `=> , : = > as`\n+* `pat` variables must be followed by one of: `=> , =`\n+* Other variables may be followed by any token.\n+\n+These rules provide some flexibility for Rust's syntax to evolve without\n+breaking existing macros.\n+\n+The macro system does not deal with parse ambiguity at all. For example, the\n+grammar `$($t:ty)* $e:expr` will always fail to parse, because the parser would\n+be forced to choose between parsing `$t` and parsing `$e`. Changing the\n+invocation syntax to put a distinctive token in front can solve the problem. In\n+this case, you can write `$(T $t:ty)* E $e:exp`.\n+\n+[item]: ../reference.html#items\n+\n+# Scoping and macro import/export\n+\n+Macros are expanded at an early stage in compilation, before name resolution.\n+One downside is that scoping works differently for macros, compared to other\n+constructs in the language.\n+\n+Definition and expansion of macros both happen in a single depth-first,\n+lexical-order traversal of a crate's source. So a macro defined at module scope\n+is visible to any subsequent code in the same module, which includes the body\n+of any subsequent child `mod` items.\n+\n+A macro defined within the body of a single `fn`, or anywhere else not at\n+module scope, is visible only within that item.\n+\n+If a module has the `macro_use` attribute, its macros are also visible in its\n+parent module after the child's `mod` item. If the parent also has `macro_use`\n+then the macros will be visible in the grandparent after the parent's `mod`\n+item, and so forth.\n+\n+The `macro_use` attribute can also appear on `extern crate`. In this context\n+it controls which macros are loaded from the external crate, e.g.\n+\n+```rust,ignore\n+#[macro_use(foo, bar)]\n+extern crate baz;\n+```\n+\n+If the attribute is given simply as `#[macro_use]`, all macros are loaded. If\n+there is no `#[macro_use]` attribute then no macros are loaded. Only macros\n+defined with the `#[macro_export]` attribute may be loaded.\n+\n+To load a crate's macros *without* linking it into the output, use `#[no_link]`\n+as well.\n+\n+An example:\n+\n+```rust\n+macro_rules! m1 { () => (()) }\n+\n+// visible here: m1\n+\n+mod foo {\n+    // visible here: m1\n+\n+    #[macro_export]\n+    macro_rules! m2 { () => (()) }\n+\n+    // visible here: m1, m2\n+}\n+\n+// visible here: m1\n+\n+macro_rules! m3 { () => (()) }\n+\n+// visible here: m1, m3\n+\n+#[macro_use]\n+mod bar {\n+    // visible here: m1, m3\n+\n+    macro_rules! m4 { () => (()) }\n+\n+    // visible here: m1, m3, m4\n+}\n+\n+// visible here: m1, m3, m4\n+# fn main() { }\n+```\n+\n+When this library is loaded with `#[macro_use] extern crate`, only `m2` will\n+be imported.\n+\n+The Rust Reference has a [listing of macro-related\n+attributes](../reference.html#macro--and-plugin-related-attributes).\n+\n+# The variable `$crate`\n+\n+A further difficulty occurs when a macro is used in multiple crates. Say that\n+`mylib` defines\n+\n+```rust\n+pub fn increment(x: u32) -> u32 {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! inc_a {\n+    ($x:expr) => ( ::increment($x) )\n+}\n+\n+#[macro_export]\n+macro_rules! inc_b {\n+    ($x:expr) => ( ::mylib::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+`inc_a` only works within `mylib`, while `inc_b` only works outside the\n+library. Furthermore, `inc_b` will break if the user imports `mylib` under\n+another name.\n+\n+Rust does not (yet) have a hygiene system for crate references, but it does\n+provide a simple workaround for this problem. Within a macro imported from a\n+crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n+By contrast, when a macro is defined and then used in the same crate, `$crate`\n+will expand to nothing. This means we can write\n+\n+```rust\n+#[macro_export]\n+macro_rules! inc {\n+    ($x:expr) => ( $crate::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+to define a single macro that works both inside and outside our library. The\n+function name will expand to either `::increment` or `::mylib::increment`.\n+\n+To keep this system simple and correct, `#[macro_use] extern crate ...` may\n+only appear at the root of your crate, not inside `mod`. This ensures that\n+`$crate` is a single identifier.\n+\n+# The deep end\n+\n+The introductory chapter mentioned recursive macros, but it did not give the\n+full story. Recursive macros are useful for another reason: Each recursive\n+invocation gives you another opportunity to pattern-match the macro's\n+arguments.\n+\n+As an extreme example, it is possible, though hardly advisable, to implement\n+the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n+within Rust's macro system.\n+\n+```rust\n+macro_rules! bct {\n+    // cmd 0:  d ... => ...\n+    (0, $($ps:tt),* ; $_d:tt)\n+        => (bct!($($ps),*, 0 ; ));\n+    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n+        => (bct!($($ps),*, 0 ; $($ds),*));\n+\n+    // cmd 1p:  1 ... => 1 ... p\n+    (1, $p:tt, $($ps:tt),* ; 1)\n+        => (bct!($($ps),*, 1, $p ; 1, $p));\n+    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n+\n+    // cmd 1p:  0 ... => 0 ...\n+    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; $($ds),*));\n+\n+    // halt on empty data string\n+    ( $($ps:tt),* ; )\n+        => (());\n+}\n+```\n+\n+Exercise: use macros to reduce duplication in the above definition of the\n+`bct!` macro.\n+\n+# Procedural macros\n+\n+If Rust's macro system can't do what you need, you may want to write a\n+[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n+macros, this is significantly more work, the interfaces are much less stable,\n+and bugs can be much harder to track down. In exchange you get the\n+flexibility of running arbitrary Rust code within the compiler. Syntax\n+extension plugins are sometimes called *procedural macros* for this reason."}, {"sha": "17a463842e71c39fa24c4d9935667a6362b47229", "filename": "src/doc/trpl/more-strings.md", "status": "removed", "additions": 0, "deletions": 325, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,325 +0,0 @@\n-% More Strings\n-\n-Strings are an important concept to master in any programming language. If you\n-come from a managed language background, you may be surprised at the complexity\n-of string handling in a systems programming language. Efficient access and\n-allocation of memory for a dynamically sized structure involves a lot of\n-details. Luckily, Rust has lots of tools to help us here.\n-\n-A **string** is a sequence of unicode scalar values encoded as a stream of\n-UTF-8 bytes. All strings are guaranteed to be validly-encoded UTF-8 sequences.\n-Additionally, strings are not null-terminated and can contain null bytes.\n-\n-Rust has two main types of strings: `&str` and `String`.\n-\n-# `&str`\n-\n-The first kind is a `&str`. This is pronounced a 'string slice'.\n-String literals are of the type `&str`:\n-\n-```\n-let string = \"Hello there.\";\n-```\n-\n-Like any Rust reference, string slices have an associated lifetime. A string\n-literal is a `&'static str`.  A string slice can be written without an explicit\n-lifetime in many cases, such as in function arguments. In these cases the\n-lifetime will be inferred:\n-\n-```\n-fn takes_slice(slice: &str) {\n-    println!(\"Got: {}\", slice);\n-}\n-```\n-\n-Like vector slices, string slices are simply a pointer plus a length. This\n-means that they're a 'view' into an already-allocated string, such as a\n-string literal or a `String`.\n-\n-## `str`\n-\n-You may occasionally see references to a `str` type, without the `&`. While\n-this type does exist, it\u2019s not something you want to use yourself. Sometimes,\n-people confuse `str` for `String`, and write this:\n-\n-```rust\n-struct S {\n-    s: str,\n-}\n-```\n-\n-This leads to ugly errors:\n-\n-```text\n-error: the trait `core::marker::Sized` is not implemented for the type `str` [E0277]\n-note: `str` does not have a constant size known at compile-time\n-```\n-\n-Instead, this `struct` should be\n-\n-```rust\n-struct S {\n-    s: String,\n-}\n-```\n-\n-So let\u2019s talk about `String`s.\n-\n-# `String`\n-\n-A `String` is a heap-allocated string. This string is growable, and is\n-also guaranteed to be UTF-8. `String`s are commonly created by\n-converting from a string slice using the `to_string` method.\n-\n-```\n-let mut s = \"Hello\".to_string();\n-println!(\"{}\", s);\n-\n-s.push_str(\", world.\");\n-println!(\"{}\", s);\n-```\n-\n-A reference to a `String` will automatically coerce to a string slice:\n-\n-```\n-fn takes_slice(slice: &str) {\n-    println!(\"Got: {}\", slice);\n-}\n-\n-fn main() {\n-    let s = \"Hello\".to_string();\n-    takes_slice(&s);\n-}\n-```\n-\n-You can also get a `&str` from a stack-allocated array of bytes:\n-\n-```\n-use std::str;\n-\n-let x: &[u8] = &[b'a', b'b'];\n-let stack_str: &str = str::from_utf8(x).unwrap();\n-```\n-\n-# Best Practices\n-\n-## `String` vs. `&str`\n-\n-In general, you should prefer `String` when you need ownership, and `&str` when\n-you just need to borrow a string. This is very similar to using `Vec<T>` vs. `&[T]`,\n-and `T` vs `&T` in general.\n-\n-This means starting off with this:\n-\n-```{rust,ignore}\n-fn foo(s: &str) {\n-```\n-\n-and only moving to this:\n-\n-```{rust,ignore}\n-fn foo(s: String) {\n-```\n-\n-if you have good reason. It's not polite to hold on to ownership you don't\n-need, and it can make your lifetimes more complex.\n-\n-## Generic functions\n-\n-To write a function that's generic over types of strings, use `&str`.\n-\n-```\n-fn some_string_length(x: &str) -> usize {\n-    x.len()\n-}\n-\n-fn main() {\n-    let s = \"Hello, world\";\n-\n-    println!(\"{}\", some_string_length(s));\n-\n-    let s = \"Hello, world\".to_string();\n-\n-    println!(\"{}\", some_string_length(&s));\n-}\n-```\n-\n-Both of these lines will print `12`.\n-\n-## Indexing strings\n-\n-You may be tempted to try to access a certain character of a `String`, like\n-this:\n-\n-```{rust,ignore}\n-let s = \"hello\".to_string();\n-\n-println!(\"{}\", s[0]);\n-```\n-\n-This does not compile. This is on purpose. In the world of UTF-8, direct\n-indexing is basically never what you want to do. The reason is that each\n-character can be a variable number of bytes. This means that you have to iterate\n-through the characters anyway, which is an O(n) operation.\n-\n-There's 3 basic levels of unicode (and its encodings):\n-\n-- code units, the underlying data type used to store everything\n-- code points/unicode scalar values (char)\n-- graphemes (visible characters)\n-\n-Rust provides iterators for each of these situations:\n-\n-- `.bytes()` will iterate over the underlying bytes\n-- `.chars()` will iterate over the code points\n-- `.graphemes()` will iterate over each grapheme\n-\n-Usually, the `graphemes()` method on `&str` is what you want:\n-\n-```\n-# #![feature(unicode)]\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.graphemes(true) {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This prints:\n-\n-```text\n-u\u0354\n-n\u030e\u0348\u0330\n-i\u0319\u032e\u035a\u0326\n-c\u0309\u035a\n-o\u0357\u033c\u0329\u0330\n-d\u0306\u0343\u0365\u0354\n-e\u0301\n-```\n-\n-Note that `l` has the type `&str` here, since a single grapheme can consist of\n-multiple codepoints, so a `char` wouldn't be appropriate.\n-\n-This will print out each visible character in turn, as you'd expect: first `u\u0354`, then\n-`n\u030e\u0348\u0330`, etc. If you wanted each individual codepoint of each grapheme, you can use `.chars()`:\n-\n-```\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.chars() {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This prints:\n-\n-```text\n-u\n-\u0354\n-n\n-\u030e\n-\u0348\n-\u0330\n-i\n-\u0319\n-\u032e\n-\u035a\n-\u0326\n-c\n-\u0309\n-\u035a\n-o\n-\u0357\n-\u033c\n-\u0329\n-\u0330\n-d\n-\u0306\n-\u0343\n-\u0365\n-\u0354\n-e\n-\u0301\n-```\n-\n-You can see how some of them are combining characters, and therefore the output\n-looks a bit odd.\n-\n-If you want the individual byte representation of each codepoint, you can use\n-`.bytes()`:\n-\n-```\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.bytes() {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This will print:\n-\n-```text\n-117\n-205\n-148\n-110\n-204\n-142\n-205\n-136\n-204\n-176\n-105\n-204\n-153\n-204\n-174\n-205\n-154\n-204\n-166\n-99\n-204\n-137\n-205\n-154\n-111\n-205\n-151\n-204\n-188\n-204\n-169\n-204\n-176\n-100\n-204\n-134\n-205\n-131\n-205\n-165\n-205\n-148\n-101\n-204\n-129\n-```\n-\n-Many more bytes than graphemes!\n-\n-# `Deref` coercions\n-\n-References to `String`s will automatically coerce into `&str`s. Like this:\n-\n-```\n-fn hello(s: &str) {\n-   println!(\"Hello, {}!\", s);\n-}\n-\n-let slice = \"Steve\";\n-let string = \"Steve\".to_string();\n-\n-hello(slice);\n-hello(&string);\n-```"}, {"sha": "6917d7f8b8e0ff6e42bfc2c8de2863c8e6281159", "filename": "src/doc/trpl/move-semantics.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmove-semantics.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Move Semantics\n+\n+Coming Soon"}, {"sha": "ccb03c7f85f693a873d4d91a566b929c18d49426", "filename": "src/doc/trpl/mutability.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Mutability\n+\n+Coming Soon"}, {"sha": "1b58b73994dc93d763166638917ce00c91bf71cc", "filename": "src/doc/trpl/nightly-rust.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fnightly-rust.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -1,4 +1,4 @@\n-% Unstable Rust\n+% Nightly Rust\n \n Rust provides three distribution channels for Rust: nightly, beta, and stable.\n Unstable features are only available on nightly Rust. For more details on this", "previous_filename": "src/doc/trpl/unstable.md"}, {"sha": "f6f9d5cae19213d54ae53a5559e3ec5c2684a4ef", "filename": "src/doc/trpl/operators-and-overloading.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Operators and Overloading\n+\n+Coming soon!"}, {"sha": "1b3f2a5b7734cc2dcdc44fd10e678dea53f5817b", "filename": "src/doc/trpl/pointers.md", "status": "removed", "additions": 0, "deletions": 699, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,699 +0,0 @@\n-% Pointers\n-\n-Rust's pointers are one of its more unique and compelling features. Pointers\n-are also one of the more confusing topics for newcomers to Rust. They can also\n-be confusing for people coming from other languages that support pointers, such\n-as C++. This guide will help you understand this important topic.\n-\n-Be sceptical of non-reference pointers in Rust: use them for a deliberate\n-purpose, not just to make the compiler happy. Each pointer type comes with an\n-explanation about when they are appropriate to use. Default to references\n-unless you're in one of those specific situations.\n-\n-You may be interested in the [cheat sheet](#cheat-sheet), which gives a quick\n-overview of the types, names, and purpose of the various pointers.\n-\n-# An introduction\n-\n-If you aren't familiar with the concept of pointers, here's a short\n-introduction.  Pointers are a very fundamental concept in systems programming\n-languages, so it's important to understand them.\n-\n-## Pointer Basics\n-\n-When you create a new variable binding, you're giving a name to a value that's\n-stored at a particular location on the stack. (If you're not familiar with the\n-*heap* vs. *stack*, please check out [this Stack Overflow\n-question](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap),\n-as the rest of this guide assumes you know the difference.) Like this:\n-\n-```{rust}\n-let x = 5;\n-let y = 8;\n-```\n-\n-| location | value |\n-|----------|-------|\n-| 0xd3e030 | 5\t   |\n-| 0xd3e028 | 8     |\n-\n-We're making up memory locations here, they're just sample values. Anyway, the\n-point is that `x`, the name we're using for our variable, corresponds to the\n-memory location `0xd3e030`, and the value at that location is `5`. When we\n-refer to `x`, we get the corresponding value. Hence, `x` is `5`.\n-\n-Let's introduce a pointer. In some languages, there is just one type of\n-'pointer,' but in Rust, we have many types. In this case, we'll use a Rust\n-*reference*, which is the simplest kind of pointer.\n-\n-```{rust}\n-let x = 5;\n-let y = 8;\n-let z = &y;\n-```\n-\n-|location | value    |\n-|-------- |----------|\n-|0xd3e030 | 5        |\n-|0xd3e028 | 8        |\n-|0xd3e020 | 0xd3e028 |\n-\n-See the difference? Rather than contain a value, the value of a pointer is a\n-location in memory. In this case, the location of `y`. `x` and `y` have the\n-type `i32`, but `z` has the type `&i32`. We can print this location using the\n-`{:p}` format string:\n-\n-```{rust}\n-let x = 5;\n-let y = 8;\n-let z = &y;\n-\n-println!(\"{:p}\", z);\n-```\n-\n-This would print `0xd3e028`, with our fictional memory addresses.\n-\n-Because `i32` and `&i32` are different types, we can't, for example, add them\n-together:\n-\n-```{rust,ignore}\n-let x = 5;\n-let y = 8;\n-let z = &y;\n-\n-println!(\"{}\", x + z);\n-```\n-\n-This gives us an error:\n-\n-```text\n-hello.rs:6:24: 6:25 error: mismatched types: expected `_`, found `&_` (expected integral variable, found &-ptr)\n-hello.rs:6     println!(\"{}\", x + z);\n-                                  ^\n-```\n-\n-We can *dereference* the pointer by using the `*` operator. Dereferencing a\n-pointer means accessing the value at the location stored in the pointer. This\n-will work:\n-\n-```{rust}\n-let x = 5;\n-let y = 8;\n-let z = &y;\n-\n-println!(\"{}\", x + *z);\n-```\n-\n-It prints `13`.\n-\n-That's it! That's all pointers are: they point to some memory location. Not\n-much else to them. Now that we've discussed the *what* of pointers, let's\n-talk about the *why*.\n-\n-## Pointer uses\n-\n-Rust's pointers are quite useful, but in different ways than in other systems\n-languages. We'll talk about best practices for Rust pointers later in\n-the guide, but here are some ways that pointers are useful in other languages:\n-\n-In C, strings are a pointer to a list of `char`s, ending with a null byte.\n-The only way to use strings is to get quite familiar with pointers.\n-\n-Pointers are useful to point to memory locations that are not on the stack. For\n-example, our example used two stack variables, so we were able to give them\n-names. But if we allocated some heap memory, we wouldn't have that name\n-available.  In C, `malloc` is used to allocate heap memory, and it returns a\n-pointer.\n-\n-As a more general variant of the previous two points, any time you have a\n-structure that can change in size, you need a pointer. You can't tell at\n-compile time how much memory to allocate, so you've gotta use a pointer to\n-point at the memory where it will be allocated, and deal with it at run time.\n-\n-Pointers are useful in languages that are pass-by-value, rather than\n-pass-by-reference. Basically, languages can make two choices (this is made\n-up syntax, it's not Rust):\n-\n-```text\n-func foo(x) {\n-    x = 5\n-}\n-\n-func main() {\n-    i = 1\n-    foo(i)\n-    // what is the value of i here?\n-}\n-```\n-\n-In languages that are pass-by-value, `foo` will get a copy of `i`, and so\n-the original version of `i` is not modified. At the comment, `i` will still be\n-`1`. In a language that is pass-by-reference, `foo` will get a reference to `i`,\n-and therefore, can change its value. At the comment, `i` will be `5`.\n-\n-So what do pointers have to do with this? Well, since pointers point to a\n-location in memory...\n-\n-```text\n-func foo(&i32 x) {\n-    *x = 5\n-}\n-\n-func main() {\n-    i = 1\n-    foo(&i)\n-    // what is the value of i here?\n-}\n-```\n-\n-Even in a language which is pass by value, `i` will be `5` at the comment. You\n-see, because the argument `x` is a pointer, we do send a copy over to `foo`,\n-but because it points at a memory location, which we then assign to, the\n-original value is still changed. This pattern is called\n-*pass-reference-by-value*. Tricky!\n-\n-## Common pointer problems\n-\n-We've talked about pointers, and we've sung their praises. So what's the\n-downside? Well, Rust attempts to mitigate each of these kinds of problems,\n-but here are problems with pointers in other languages:\n-\n-Uninitialized pointers can cause a problem. For example, what does this program\n-do?\n-\n-```{ignore}\n-&int x;\n-*x = 5; // whoops!\n-```\n-\n-Who knows? We just declare a pointer, but don't point it at anything, and then\n-set the memory location that it points at to be `5`. But which location? Nobody\n-knows. This might be harmless, and it might be catastrophic.\n-\n-When you combine pointers and functions, it's easy to accidentally invalidate\n-the memory the pointer is pointing to. For example:\n-\n-```text\n-func make_pointer(): &int {\n-    x = 5;\n-\n-    return &x;\n-}\n-\n-func main() {\n-    &int i = make_pointer();\n-    *i = 5; // uh oh!\n-}\n-```\n-\n-`x` is local to the `make_pointer` function, and therefore, is invalid as soon\n-as `make_pointer` returns. But we return a pointer to its memory location, and\n-so back in `main`, we try to use that pointer, and it's a very similar\n-situation to our first one. Setting invalid memory locations is bad.\n-\n-As one last example of a big problem with pointers, *aliasing* can be an\n-issue. Two pointers are said to alias when they point at the same location\n-in memory. Like this:\n-\n-```text\n-func mutate(&int i, int j) {\n-    *i = j;\n-}\n-\n-func main() {\n-  x = 5;\n-  y = &x;\n-  z = &x; //y and z are aliased\n-\n-\n-  run_in_new_thread(mutate, y, 1);\n-  run_in_new_thread(mutate, z, 100);\n-\n-  // what is the value of x here?\n-}\n-```\n-\n-In this made-up example, `run_in_new_thread` spins up a new thread, and calls\n-the given function name with its arguments. Since we have two threads, and\n-they're both operating on aliases to `x`, we can't tell which one finishes\n-first, and therefore, the value of `x` is actually non-deterministic. Worse,\n-what if one of them had invalidated the memory location they pointed to? We'd\n-have the same problem as before, where we'd be setting an invalid location.\n-\n-## Conclusion\n-\n-That's a basic overview of pointers as a general concept. As we alluded to\n-before, Rust has different kinds of pointers, rather than just one, and\n-mitigates all of the problems that we talked about, too. This does mean that\n-Rust pointers are slightly more complicated than in other languages, but\n-it's worth it to not have the problems that simple pointers have.\n-\n-# References\n-\n-The most basic type of pointer that Rust has is called a *reference*. Rust\n-references look like this:\n-\n-```{rust}\n-let x = 5;\n-let y = &x;\n-\n-println!(\"{}\", *y);\n-println!(\"{:p}\", y);\n-println!(\"{}\", y);\n-```\n-\n-We'd say \"`y` is a reference to `x`.\" The first `println!` prints out the\n-value of `y`'s referent by using the dereference operator, `*`. The second\n-one prints out the memory location that `y` points to, by using the pointer\n-format string. The third `println!` *also* prints out the value of `y`'s\n-referent, because `println!` will automatically dereference it for us.\n-\n-Here's a function that takes a reference:\n-\n-```{rust}\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-```\n-\n-You can also use `&` as an operator to create a reference, so we can\n-call this function in two different ways:\n-\n-```{rust}\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-\n-fn main() {\n-\n-    let x = 5;\n-    let y = &x;\n-\n-    println!(\"{}\", succ(y));\n-    println!(\"{}\", succ(&x));\n-}\n-```\n-\n-Both of these `println!`s will print out `6`.\n-\n-Of course, if this were real code, we wouldn't bother with the reference, and\n-just write:\n-\n-```{rust}\n-fn succ(x: i32) -> i32 { x + 1 }\n-```\n-\n-References are immutable by default:\n-\n-```{rust,ignore}\n-let x = 5;\n-let y = &x;\n-\n-*y = 5; // error: cannot assign to immutable borrowed content `*y`\n-```\n-\n-They can be made mutable with `mut`, but only if its referent is also mutable.\n-This works:\n-\n-```{rust}\n-let mut x = 5;\n-let y = &mut x;\n-```\n-\n-This does not:\n-\n-```{rust,ignore}\n-let x = 5;\n-let y = &mut x; // error: cannot borrow immutable local variable `x` as mutable\n-```\n-\n-Immutable pointers are allowed to alias:\n-\n-```{rust}\n-let x = 5;\n-let y = &x;\n-let z = &x;\n-```\n-\n-Mutable ones, however, are not:\n-\n-```{rust,ignore}\n-let mut x = 5;\n-let y = &mut x;\n-let z = &mut x; // error: cannot borrow `x` as mutable more than once at a time\n-```\n-\n-Despite their complete safety, a reference's representation at runtime is the\n-same as that of an ordinary pointer in a C program. They introduce zero\n-overhead. The compiler does all safety checks at compile time. The theory that\n-allows for this was originally called *region pointers*. Region pointers\n-evolved into what we know today as *lifetimes*.\n-\n-Here's the simple explanation: would you expect this code to compile?\n-\n-```{rust,ignore}\n-fn main() {\n-    println!(\"{}\", x);\n-    let x = 5;\n-}\n-```\n-\n-Probably not. That's because you know that the name `x` is valid from where\n-it's declared to when it goes out of scope. In this case, that's the end of\n-the `main` function. So you know this code will cause an error. We call this\n-duration a *lifetime*. Let's try a more complex example:\n-\n-```{rust}\n-fn main() {\n-    let mut x = 5;\n-\n-    if x < 10 {\n-        let y = &x;\n-\n-        println!(\"Oh no: {}\", y);\n-        return;\n-    }\n-\n-    x -= 1;\n-\n-    println!(\"Oh no: {}\", x);\n-}\n-```\n-\n-Here, we're borrowing a pointer to `x` inside of the `if`. The compiler, however,\n-is able to determine that that pointer will go out of scope without `x` being\n-mutated, and therefore, lets us pass. This wouldn't work:\n-\n-```{rust,ignore}\n-fn main() {\n-    let mut x = 5;\n-\n-    if x < 10 {\n-        let y = &x;\n-\n-        x -= 1;\n-\n-        println!(\"Oh no: {}\", y);\n-        return;\n-    }\n-\n-    x -= 1;\n-\n-    println!(\"Oh no: {}\", x);\n-}\n-```\n-\n-It gives this error:\n-\n-```text\n-test.rs:7:9: 7:15 error: cannot assign to `x` because it is borrowed\n-test.rs:7         x -= 1;\n-                  ^~~~~~\n-test.rs:5:18: 5:19 note: borrow of `x` occurs here\n-test.rs:5         let y = &x;\n-                           ^\n-```\n-\n-As you might guess, this kind of analysis is complex for a human, and therefore\n-hard for a computer, too! There is an entire [guide devoted to references, ownership,\n-and lifetimes](ownership.html) that goes into this topic in\n-great detail, so if you want the full details, check that out.\n-\n-## Best practices\n-\n-In general, prefer stack allocation over heap allocation. Using references to\n-stack allocated information is preferred whenever possible. Therefore,\n-references are the default pointer type you should use, unless you have a\n-specific reason to use a different type. The other types of pointers cover when\n-they're appropriate to use in their own best practices sections.\n-\n-Use references when you want to use a pointer, but do not want to take ownership.\n-References just borrow ownership, which is more polite if you don't need the\n-ownership. In other words, prefer:\n-\n-```{rust}\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-```\n-\n-to\n-\n-```{rust}\n-fn succ(x: Box<i32>) -> i32 { *x + 1 }\n-```\n-\n-As a corollary to that rule, references allow you to accept a wide variety of\n-other pointers, and so are useful so that you don't have to write a number\n-of variants per pointer. In other words, prefer:\n-\n-```{rust}\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-```\n-\n-to\n-\n-```{rust}\n-use std::rc::Rc;\n-\n-fn box_succ(x: Box<i32>) -> i32 { *x + 1 }\n-\n-fn rc_succ(x: Rc<i32>) -> i32 { *x + 1 }\n-```\n-\n-Note that the caller of your function will have to modify their calls slightly:\n-\n-```{rust}\n-use std::rc::Rc;\n-\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-\n-let ref_x = &5;\n-let box_x = Box::new(5);\n-let rc_x = Rc::new(5);\n-\n-succ(ref_x);\n-succ(&*box_x);\n-succ(&*rc_x);\n-```\n-\n-The initial `*` dereferences the pointer, and then `&` takes a reference to\n-those contents.\n-\n-# Boxes\n-\n-`Box<T>` is Rust's *boxed pointer* type. Boxes provide the simplest form of\n-heap allocation in Rust. Creating a box looks like this:\n-\n-```{rust}\n-let x = Box::new(5);\n-```\n-\n-Boxes are heap allocated and they are deallocated automatically by Rust when\n-they go out of scope:\n-\n-```{rust}\n-{\n-    let x = Box::new(5);\n-\n-    // stuff happens\n-\n-} // x is destructed and its memory is free'd here\n-```\n-\n-However, boxes do _not_ use reference counting or garbage collection. Boxes are\n-what's called an *affine type*. This means that the Rust compiler, at compile\n-time, determines when the box comes into and goes out of scope, and inserts the\n-appropriate calls there.\n-\n-You don't need to fully grok the theory of affine types to grok boxes, though.\n-As a rough approximation, you can treat this Rust code:\n-\n-```{rust}\n-{\n-    let x = Box::new(5);\n-\n-    // stuff happens\n-}\n-```\n-\n-As being similar to this C code:\n-\n-```c\n-{\n-    int *x;\n-    x = (int *)malloc(sizeof(int));\n-    *x = 5;\n-\n-    // stuff happens\n-\n-    free(x);\n-}\n-```\n-\n-Of course, this is a 10,000 foot view. It leaves out destructors, for example.\n-But the general idea is correct: you get the semantics of `malloc`/`free`, but\n-with some improvements:\n-\n-1. It's impossible to allocate the incorrect amount of memory, because Rust\n-   figures it out from the types.\n-2. You cannot forget to `free` memory you've allocated, because Rust does it\n-   for you.\n-3. Rust ensures that this `free` happens at the right time, when it is truly\n-   not used. Use-after-free is not possible.\n-4. Rust enforces that no other writeable pointers alias to this heap memory,\n-   which means writing to an invalid pointer is not possible.\n-\n-See the section on references or the [ownership guide](ownership.html)\n-for more detail on how lifetimes work.\n-\n-Using boxes and references together is very common. For example:\n-\n-```{rust}\n-fn add_one(x: &i32) -> i32 {\n-    *x + 1\n-}\n-\n-fn main() {\n-    let x = Box::new(5);\n-\n-    println!(\"{}\", add_one(&*x));\n-}\n-```\n-\n-In this case, Rust knows that `x` is being *borrowed* by the `add_one()`\n-function, and since it's only reading the value, allows it.\n-\n-We can borrow `x` as read-only multiple times, even simultaneously:\n-\n-```{rust}\n-fn add(x: &i32, y: &i32) -> i32 {\n-    *x + *y\n-}\n-\n-fn main() {\n-    let x = Box::new(5);\n-\n-    println!(\"{}\", add(&*x, &*x));\n-    println!(\"{}\", add(&*x, &*x));\n-}\n-```\n-\n-We can mutably borrow `x` multiple times, but only if x itself is mutable, and\n-it may not be *simultaneously* borrowed:\n-\n-```{rust,ignore}\n-fn increment(x: &mut i32) {\n-    *x += 1;\n-}\n-\n-fn main() {\n-    // If variable x is not \"mut\", this will not compile\n-    let mut x = Box::new(5);\n-\n-    increment(&mut x);\n-    increment(&mut x);\n-    println!(\"{}\", x);\n-}\n-```\n-\n-Notice the signature of `increment()` requests a mutable reference.\n-\n-## Best practices\n-\n-Boxes are most appropriate to use when defining recursive data structures.\n-\n-### Recursive data structures\n-\n-Sometimes, you need a recursive data structure. The simplest is known as a\n-*cons list*:\n-\n-\n-```{rust}\n-#[derive(Debug)]\n-enum List<T> {\n-    Cons(T, Box<List<T>>),\n-    Nil,\n-}\n-\n-fn main() {\n-    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));\n-    println!(\"{:?}\", list);\n-}\n-```\n-\n-This prints:\n-\n-```text\n-Cons(1, Box(Cons(2, Box(Cons(3, Box(Nil))))))\n-```\n-\n-The reference to another `List` inside of the `Cons` enum variant must be a box,\n-because we don't know the length of the list. Because we don't know the length,\n-we don't know the size, and therefore, we need to heap allocate our list.\n-\n-Working with recursive or other unknown-sized data structures is the primary\n-use-case for boxes.\n-\n-# Rc and Arc\n-\n-This part is coming soon.\n-\n-## Best practices\n-\n-This part is coming soon.\n-\n-# Raw Pointers\n-\n-This part is coming soon.\n-\n-## Best practices\n-\n-This part is coming soon.\n-\n-# Creating your own Pointers\n-\n-This part is coming soon.\n-\n-## Best practices\n-\n-This part is coming soon.\n-\n-# Patterns and `ref`\n-\n-When you're trying to match something that's stored in a pointer, there may be\n-a situation where matching directly isn't the best option available. Let's see\n-how to properly handle this:\n-\n-```{rust,ignore}\n-fn possibly_print(x: &Option<String>) {\n-    match *x {\n-        // BAD: cannot move out of a `&`\n-        Some(s) => println!(\"{}\", s)\n-\n-        // GOOD: instead take a reference into the memory of the `Option`\n-        Some(ref s) => println!(\"{}\", *s),\n-        None => {}\n-    }\n-}\n-```\n-\n-The `ref s` here means that `s` will be of type `&String`, rather than type\n-`String`.\n-\n-This is important when the type you're trying to get access to has a destructor\n-and you don't want to move it, you just want a reference to it.\n-\n-# Cheat Sheet\n-\n-Here's a quick rundown of Rust's pointer types:\n-\n-| Type         | Name                | Summary                                                             |\n-|--------------|---------------------|---------------------------------------------------------------------|\n-| `&T`         | Reference           | Allows one or more references to read `T`                           |\n-| `&mut T`     | Mutable Reference   | Allows a single reference to read and write `T`                     |\n-| `Box<T>`     | Box                 | Heap allocated `T` with a single owner that may read and write `T`. |\n-| `Rc<T>`      | \"arr cee\" pointer   | Heap allocated `T` with many readers                                |\n-| `Arc<T>`     | Arc pointer         | Same as above, but safe sharing across threads                      |\n-| `*const T`   | Raw pointer         | Unsafe read access to `T`                                           |\n-| `*mut T`     | Mutable raw pointer | Unsafe read and write access to `T`                                 |\n-\n-# Related resources\n-\n-* [API documentation for Box](../std/boxed/index.html)\n-* [Ownership guide](ownership.html)\n-* [Cyclone paper on regions](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf), which inspired Rust's lifetime system"}, {"sha": "2878e7ce4754e6a51c6320710bae59039e0fcb14", "filename": "src/doc/trpl/primitive-types.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Primitive Types\n+\n+Coming Soon!"}, {"sha": "6acb326958d31ff5d69bf207014039e51ce93aa4", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% References and Borrowing\n+\n+Coming Soon!"}, {"sha": "a31c0ac3c4e69f5dfc5829571feceed4ddd2688d", "filename": "src/doc/trpl/slices.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fslices.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fslices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslices.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,21 @@\n+% Slices\n+\n+A *slice* is a reference to (or \"view\" into) an array. They are useful for\n+allowing safe, efficient access to a portion of an array without copying. For\n+example, you might want to reference just one line of a file read into memory.\n+By nature, a slice is not created directly, but from an existing variable.\n+Slices have a length, can be mutable or not, and in many ways behave like\n+arrays:\n+\n+```{rust}\n+let a = [0, 1, 2, 3, 4];\n+let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n+\n+for e in middle.iter() {\n+    println!(\"{}\", e); // Prints 1, 2, 3\n+}\n+```\n+\n+You can also take a slice of a vector, `String`, or `&str`, because they are\n+backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover\n+generics."}, {"sha": "b29c4952c94e3ada8c33cd46421779b189cfc2d7", "filename": "src/doc/trpl/static.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fstatic.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fstatic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% `static`\n+\n+Coming soon!"}, {"sha": "eff1a47761d609420756e5b5fb5ac9137a6bee98", "filename": "src/doc/trpl/structs.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,49 @@\n+% Structs\n+\n+A struct is another form of a *record type*, just like a tuple. There's a\n+difference: structs give each element that they contain a name, called a\n+*field* or a *member*. Check it out:\n+\n+```rust\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let origin = Point { x: 0, y: 0 }; // origin: Point\n+\n+    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n+}\n+```\n+\n+There's a lot going on here, so let's break it down. We declare a struct with\n+the `struct` keyword, and then with a name. By convention, structs begin with a\n+capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n+\n+We can create an instance of our struct via `let`, as usual, but we use a `key:\n+value` style syntax to set each field. The order doesn't need to be the same as\n+in the original declaration.\n+\n+Finally, because fields have names, we can access the field through dot\n+notation: `origin.x`.\n+\n+The values in structs are immutable by default, like other bindings in Rust.\n+Use `mut` to make them mutable:\n+\n+```{rust}\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut point = Point { x: 0, y: 0 };\n+\n+    point.x = 5;\n+\n+    println!(\"The point is at ({}, {})\", point.x, point.y);\n+}\n+```\n+\n+This will print `The point is at (5, 0)`."}, {"sha": "6f992cf6887362ac5b0b653311808f13038381db", "filename": "src/doc/trpl/syntax-and-semantics.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1 @@\n+% Syntax and Semantics"}, {"sha": "cc0941bc025aa55caa09d83c0b6874604648d8d1", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% The Stack and the Heap\n+\n+Coming Soon"}, {"sha": "6226ea9f3e75a21e067909c49155bad69e03bb4b", "filename": "src/doc/trpl/tracing-macros.md", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Ftracing-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Fdoc%2Ftrpl%2Ftracing-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftracing-macros.md?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -1,91 +0,0 @@\n-% Tracing Macros\n-\n-The `trace_macros` feature allows you to use a special feature: tracing macro\n-invocations.\n-\n-In the advanced macros chapter, we defined a `bct` macro:\n-\n-```rust\n-macro_rules! bct {\n-    // cmd 0:  d ... => ...\n-    (0, $($ps:tt),* ; $_d:tt)\n-        => (bct!($($ps),*, 0 ; ));\n-    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n-        => (bct!($($ps),*, 0 ; $($ds),*));\n-\n-    // cmd 1p:  1 ... => 1 ... p\n-    (1, $p:tt, $($ps:tt),* ; 1)\n-        => (bct!($($ps),*, 1, $p ; 1, $p));\n-    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n-\n-    // cmd 1p:  0 ... => 0 ...\n-    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; $($ds),*));\n-\n-    // halt on empty data string\n-    ( $($ps:tt),* ; )\n-        => (());\n-}\n-```\n-\n-This is pretty complex! we can see the output\n-\n-```rust,ignore\n-#![feature(trace_macros)]\n-\n-macro_rules! bct {\n-    // cmd 0:  d ... => ...\n-    (0, $($ps:tt),* ; $_d:tt)\n-        => (bct!($($ps),*, 0 ; ));\n-    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n-        => (bct!($($ps),*, 0 ; $($ds),*));\n-\n-    // cmd 1p:  1 ... => 1 ... p\n-    (1, $p:tt, $($ps:tt),* ; 1)\n-        => (bct!($($ps),*, 1, $p ; 1, $p));\n-    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n-\n-    // cmd 1p:  0 ... => 0 ...\n-    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; $($ds),*));\n-\n-    // halt on empty data string\n-    ( $($ps:tt),* ; )\n-        => (());\n-}\n-\n-fn main() {\n-    trace_macros!(true);\n-\n-    bct!(0, 0, 1, 1, 1 ; 1, 0, 1);\n-}\n-```\n-\n-This will print out a wall of text:\n-\n-```text\n-bct! { 0 , 0 , 1 , 1 , 1 ; 1 , 0 , 1 }\n-bct! { 0 , 1 , 1 , 1 , 0 ; 0 , 1 }\n-bct! { 1 , 1 , 1 , 0 , 0 ; 1 }\n-bct! { 1 , 0 , 0 , 1 , 1 ; 1 , 1 }\n-bct! { 0 , 1 , 1 , 1 , 0 ; 1 , 1 , 0 }\n-bct! { 1 , 1 , 1 , 0 , 0 ; 1 , 0 }\n-bct! { 1 , 0 , 0 , 1 , 1 ; 1 , 0 , 1 }\n-bct! { 0 , 1 , 1 , 1 , 0 ; 1 , 0 , 1 , 0 }\n-bct! { 1 , 1 , 1 , 0 , 0 ; 0 , 1 , 0 }\n-bct! { 1 , 0 , 0 , 1 , 1 ; 0 , 1 , 0 }\n-bct! { 0 , 1 , 1 , 1 , 0 ; 0 , 1 , 0 }\n-```\n-\n-And eventually, error:\n-\n-```text\n-18:45 error: recursion limit reached while expanding the macro `bct`\n-    => (bct!($($ps),*, 1, $p ; $($ds),*));\n-        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-```\n-\n-The `trace_macros!` call is what produces this output, showing how we match\n-each time."}, {"sha": "d008d30597fea82e1add2e94ea410b8df6cf4096", "filename": "src/doc/trpl/trait-objects.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftrait-objects.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -1,4 +1,4 @@\n-% Static and Dynamic Dispatch\n+% Trait Objects\n \n When code involves polymorphism, there needs to be a mechanism to determine\n which specific version is actually run. This is called 'dispatch.' There are", "previous_filename": "src/doc/trpl/static-and-dynamic-dispatch.md"}, {"sha": "8fba658fba2cd028ab15ce33b86a095c6cdc0d97", "filename": "src/doc/trpl/tuple-structs.md", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuple-structs.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,56 @@\n+% Tuple Structs\n+\n+Rust has another data type that's like a hybrid between a tuple and a struct,\n+called a *tuple struct*. Tuple structs do have a name, but their fields don't:\n+\n+```{rust}\n+struct Color(i32, i32, i32);\n+struct Point(i32, i32, i32);\n+```\n+\n+These two will not be equal, even if they have the same values:\n+\n+```{rust}\n+# struct Color(i32, i32, i32);\n+# struct Point(i32, i32, i32);\n+let black = Color(0, 0, 0);\n+let origin = Point(0, 0, 0);\n+```\n+\n+It is almost always better to use a struct than a tuple struct. We would write\n+`Color` and `Point` like this instead:\n+\n+```{rust}\n+struct Color {\n+    red: i32,\n+    blue: i32,\n+    green: i32,\n+}\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+```\n+\n+Now, we have actual names, rather than positions. Good names are important,\n+and with a struct, we have actual names.\n+\n+There _is_ one case when a tuple struct is very useful, though, and that's a\n+tuple struct with only one element. We call this the *newtype* pattern, because\n+it allows you to create a new type, distinct from that of its contained value\n+and expressing its own semantic meaning:\n+\n+```{rust}\n+struct Inches(i32);\n+\n+let length = Inches(10);\n+\n+let Inches(integer_length) = length;\n+println!(\"length is {} inches\", integer_length);\n+```\n+\n+As you can see here, you can extract the inner integer type through a\n+destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n+`let Inches(integer_length)` assigns `10` to `integer_length`."}, {"sha": "dd526d05b671e1d8904aa072a9b0273ad56c70c4", "filename": "src/doc/trpl/tuples.md", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ftuples.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ftuples.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuples.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,97 @@\n+% Tuples\n+\n+The first compound data type we're going to talk about is called the *tuple*.\n+A tuple is an ordered list of fixed size. Like this:\n+\n+```rust\n+let x = (1, \"hello\");\n+```\n+\n+The parentheses and commas form this two-length tuple. Here's the same code, but\n+with the type annotated:\n+\n+```rust\n+let x: (i32, &str) = (1, \"hello\");\n+```\n+\n+As you can see, the type of a tuple looks just like the tuple, but with each\n+position having a type name rather than the value. Careful readers will also\n+note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n+You have briefly seen `&str` used as a type before, and we'll discuss the\n+details of strings later. In systems programming languages, strings are a bit\n+more complex than in other languages. For now, just read `&str` as a *string\n+slice*, and we'll learn more soon.\n+\n+You can access the fields in a tuple through a *destructuring let*. Here's\n+an example:\n+\n+```rust\n+let (x, y, z) = (1, 2, 3);\n+\n+println!(\"x is {}\", x);\n+```\n+\n+Remember before when I said the left-hand side of a `let` statement was more\n+powerful than just assigning a binding? Here we are. We can put a pattern on\n+the left-hand side of the `let`, and if it matches up to the right-hand side,\n+we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n+or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n+\n+This pattern is very powerful, and we'll see it repeated more later.\n+\n+There are also a few things you can do with a tuple as a whole, without\n+destructuring. You can assign one tuple into another, if they have the same\n+contained types and [arity]. Tuples have the same arity when they have the same\n+length.\n+\n+```rust\n+let mut x = (1, 2); // x: (i32, i32)\n+let y = (2, 3); // y: (i32, i32)\n+\n+x = y;\n+```\n+\n+You can also check for equality with `==`. Again, this will only compile if the\n+tuples have the same type.\n+\n+```rust\n+let x = (1, 2, 3);\n+let y = (2, 2, 4);\n+\n+if x == y {\n+    println!(\"yes\");\n+} else {\n+    println!(\"no\");\n+}\n+```\n+\n+This will print `no`, because some of the values aren't equal.\n+\n+Note that the order of the values is considered when checking for equality,\n+so the following example will also print `no`.\n+\n+```rust\n+let x = (1, 2, 3);\n+let y = (2, 1, 3);\n+\n+if x == y {\n+    println!(\"yes\");\n+} else {\n+    println!(\"no\");\n+}\n+```\n+\n+One other use of tuples is to return multiple values from a function:\n+\n+```rust\n+fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }\n+\n+fn main() {\n+    let (x, y) = next_two(5);\n+    println!(\"x, y = {}, {}\", x, y);\n+}\n+```\n+\n+Even though Rust functions can only return one value, a tuple *is* one value,\n+that happens to be made up of more than one value. You can also see in this\n+example how you can destructure a pattern returned by a function, as well."}, {"sha": "fffa0ae1383c29ad4fa1f233b8ae9fb43f0de5de", "filename": "src/doc/trpl/type-aliases.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ftype-aliases.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Ftype-aliases.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftype-aliases.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% `type` Aliases\n+\n+Coming soon"}, {"sha": "6b9a417c43944ae883642c8642a3a5081d2617bf", "filename": "src/doc/trpl/ufcs.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fufcs.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fufcs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fufcs.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Universal Function Call Syntax\n+\n+Coming soon"}, {"sha": "b641f2b104a726b25b05293535e92fcbeb8fc8c0", "filename": "src/doc/trpl/unsafe-code.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe-code.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -1,4 +1,4 @@\n-% Unsafe and Low-Level Code\n+% Unsafe Code\n \n # Introduction\n ", "previous_filename": "src/doc/trpl/unsafe.md"}, {"sha": "f307f23f0116a8479f6d532e09219ca2b542118a", "filename": "src/doc/trpl/unsized-types.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Funsized-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Funsized-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsized-types.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,3 @@\n+% Unsized Types\n+\n+Coming Soon!"}, {"sha": "cba435233fab87829e1cc3b2c3de169d50601b14", "filename": "src/doc/trpl/vectors.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvectors.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -0,0 +1,33 @@\n+% Vectors\n+\n+A *vector* is a dynamic or \"growable\" array, implemented as the standard\n+library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n+later). Vectors always allocate their data on the heap. Vectors are to slices\n+what `String` is to `&str`. You can create them with the `vec!` macro:\n+\n+```{rust}\n+let v = vec![1, 2, 3]; // v: Vec<i32>\n+```\n+\n+(Notice that unlike the `println!` macro we've used in the past, we use square\n+brackets `[]` with `vec!`. Rust allows you to use either in either situation,\n+this is just convention.)\n+\n+There's an alternate form of `vec!` for repeating an initial value:\n+\n+```\n+let v = vec![0; 10]; // ten zeroes\n+```\n+\n+You can get the length of, iterate over, and subscript vectors just like\n+arrays. In addition, (mutable) vectors can grow automatically:\n+\n+```{rust}\n+let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>\n+\n+nums.push(4);\n+\n+println!(\"The length of nums is now {}\", nums.len()); // Prints 4\n+```\n+\n+Vectors have many more useful methods."}, {"sha": "508c4ee117a5f2ae57d8a24a78ac3d7faa522d11", "filename": "src/doc/trpl/while-loops.md", "status": "renamed", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -1,54 +1,4 @@\n-% Looping\n-\n-Looping is the last basic construct that we haven't learned yet in Rust. Rust has\n-two main looping constructs: `for` and `while`.\n-\n-## `for`\n-\n-The `for` loop is used to loop a particular number of times. Rust's `for` loops\n-work a bit differently than in other systems languages, however. Rust's `for`\n-loop doesn't look like this \"C-style\" `for` loop:\n-\n-```{c}\n-for (x = 0; x < 10; x++) {\n-    printf( \"%d\\n\", x );\n-}\n-```\n-\n-Instead, it looks like this:\n-\n-```{rust}\n-for x in 0..10 {\n-    println!(\"{}\", x); // x: i32\n-}\n-```\n-\n-In slightly more abstract terms,\n-\n-```{ignore}\n-for var in expression {\n-    code\n-}\n-```\n-\n-The expression is an iterator, which we will discuss in more depth later in the\n-guide. The iterator gives back a series of elements. Each element is one\n-iteration of the loop. That value is then bound to the name `var`, which is\n-valid for the loop body. Once the body is over, the next value is fetched from\n-the iterator, and we loop another time. When there are no more values, the\n-`for` loop is over.\n-\n-In our example, `0..10` is an expression that takes a start and an end position,\n-and gives an iterator over those values. The upper bound is exclusive, though,\n-so our loop will print `0` through `9`, not `10`.\n-\n-Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n-each element of the loop is complicated and error prone, even for experienced C\n-developers.\n-\n-We'll talk more about `for` when we cover *iterators*, later in the Guide.\n-\n-## `while`\n+% `while` loops\n \n The other kind of looping construct in Rust is the `while` loop. It looks like\n this:", "previous_filename": "src/doc/trpl/looping.md"}, {"sha": "b15304d6dc50c5c5ce646efff5a4700306e39c35", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 113, "deletions": 31, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -10,51 +10,134 @@\n \n #![allow(non_snake_case)]\n \n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80 characters.\n+// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n-    E0001: r##\"\n-    This error suggests that the expression arm corresponding to the noted pattern\n-    will never be reached as for all possible values of the expression being matched,\n-    one of the preceding patterns will match.\n \n-    This means that perhaps some of the preceding patterns are too general, this\n-    one is too specific or the ordering is incorrect.\n+E0001: r##\"\n+This error suggests that the expression arm corresponding to the noted pattern\n+will never be reached as for all possible values of the expression being\n+matched, one of the preceding patterns will match.\n+\n+This means that perhaps some of the preceding patterns are too general, this one\n+is too specific or the ordering is incorrect.\n+\"##,\n+\n+E0002: r##\"\n+This error indicates that an empty match expression is illegal because the type\n+it is matching on is non-empty (there exist values of this type). In safe code\n+it is impossible to create an instance of an empty type, so empty match\n+expressions are almost never desired.  This error is typically fixed by adding\n+one or more cases to the match expression.\n+\n+An example of an empty type is `enum Empty { }`.\n \"##,\n \n-    E0003: r##\"\n-    Not-a-Number (NaN) values can not be compared for equality and hence can never match\n-    the input to a match expression. To match against NaN values, you should instead use\n-    the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n+E0003: r##\"\n+Not-a-Number (NaN) values cannot be compared for equality and hence can never\n+match the input to a match expression. To match against NaN values, you should\n+instead use the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n \"##,\n \n-    E0004: r##\"\n-    This error indicates that the compiler can not guarantee a matching pattern for one\n-    or more possible inputs to a match expression. Guaranteed matches are required in order\n-    to assign values to match expressions, or alternatively, determine the flow of execution.\n+E0004: r##\"\n+This error indicates that the compiler cannot guarantee a matching pattern for\n+one or more possible inputs to a match expression. Guaranteed matches are\n+required in order to assign values to match expressions, or alternatively,\n+determine the flow of execution.\n \n-    If you encounter this error you must alter your patterns so that every possible value of\n-    the input type is matched. For types with a small number of variants (like enums) you\n-    should probably cover all cases explicitly. Alternatively, the underscore `_` wildcard\n-    pattern can be added after all other patterns to match \"anything else\".\n+If you encounter this error you must alter your patterns so that every possible\n+value of the input type is matched. For types with a small number of variants\n+(like enums) you should probably cover all cases explicitly. Alternatively, the\n+underscore `_` wildcard pattern can be added after all other patterns to match\n+\"anything else\".\n \"##,\n \n-    // FIXME: Remove duplication here?\n-    E0005: r##\"\n-    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n-    name will be extracted in all cases. If you encounter this error you probably need\n-    to use a `match` or `if let` to deal with the possibility of failure.\n+// FIXME: Remove duplication here?\n+E0005: r##\"\n+Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+name will be extracted in all cases. If you encounter this error you probably need\n+to use a `match` or `if let` to deal with the possibility of failure.\n \"##,\n \n-    E0006: r##\"\n-    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n-    name will be extracted in all cases. If you encounter this error you probably need\n-    to use a `match` or `if let` to deal with the possibility of failure.\n+E0006: r##\"\n+Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+name will be extracted in all cases. If you encounter this error you probably need\n+to use a `match` or `if let` to deal with the possibility of failure.\n+\"##,\n+\n+E0007: r##\"\n+This error indicates that the bindings in a match arm would require a value to\n+be moved into more than one location, thus violating unique ownership. Code like\n+the following is invalid as it requires the entire Option<String> to be moved\n+into a variable called `op_string` while simultaneously requiring the inner\n+String to be moved into a variable called `s`.\n+\n+let x = Some(\"s\".to_string());\n+match x {\n+    op_string @ Some(s) => ...\n+    None => ...\n+}\n+\n+See also Error 303.\n+\"##,\n+\n+E0008: r##\"\n+Names bound in match arms retain their type in pattern guards. As such, if a\n+name is bound by move in a pattern, it should also be moved to wherever it is\n+referenced in the pattern guard code. Doing so however would prevent the name\n+from being available in the body of the match arm. Consider the following:\n+\n+match Some(\"hi\".to_string()) {\n+    Some(s) if s.len() == 0 => // use s.\n+    ...\n+}\n+\n+The variable `s` has type String, and its use in the guard is as a variable of\n+type String. The guard code effectively executes in a separate scope to the body\n+of the arm, so the value would be moved into this anonymous scope and therefore\n+become unavailable in the body of the arm. Although this example seems\n+innocuous, the problem is most clear when considering functions that take their\n+argument by value.\n+\n+match Some(\"hi\".to_string()) {\n+    Some(s) if { drop(s); false } => (),\n+    Some(s) => // use s.\n+    ...\n+}\n+\n+The value would be dropped in the guard then become unavailable not only in the\n+body of that arm but also in all subsequent arms! The solution is to bind by\n+reference when using guards or refactor the entire expression, perhaps by\n+putting the condition inside the body of the arm.\n+\"##,\n+\n+E0303: r##\"\n+In certain cases it is possible for sub-bindings to violate memory safety.\n+Updates to the borrow checker in a future version of Rust may remove this\n+restriction, but for now patterns must be rewritten without sub-bindings.\n+\n+// Code like this...\n+match Some(5) {\n+    ref op_num @ Some(num) => ...\n+    None => ...\n+}\n+\n+// ... should be updated to code like this.\n+match Some(5) {\n+    Some(num) => {\n+        let op_num = &Some(num);\n+        ...\n+    }\n+    None => ...\n+}\n+\n+See also https://github.com/rust-lang/rust/issues/14587\n \"##\n+\n }\n \n register_diagnostics! {\n-    E0002,\n-    E0007,\n-    E0008,\n     E0009,\n     E0010,\n     E0011,\n@@ -117,7 +200,6 @@ register_diagnostics! {\n     E0300, // unexpanded macro\n     E0301, // cannot mutable borrow in a pattern guard\n     E0302, // cannot assign in a pattern guard\n-    E0303, // pattern bindings are not allowed after an `@`\n     E0304, // expected signed integer constant\n     E0305, // expected constant\n     E0306, // expected positive integer for repeat count"}, {"sha": "89c19cfb0b02a8d714676eec12a1921f9dfad349", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -277,7 +277,8 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             Some(ref code) => {\n                 match descriptions.find_description(&code[..]) {\n                     Some(ref description) => {\n-                        println!(\"{}\", description);\n+                        // Slice off the leading newline and print.\n+                        print!(\"{}\", &description[1..]);\n                     }\n                     None => {\n                         early_error(&format!(\"no extended information for {}\", code));"}, {"sha": "e5444843516008bcfd66df49d7d19dab513f86cb", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e6e8b0389d407f8b46ab605a9e3475a851d5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "patch": "@@ -112,58 +112,6 @@\n //! });\n //! rx.recv().unwrap();\n //! ```\n-//!\n-//! Reading from a channel with a timeout requires to use a Timer together\n-//! with the channel. You can use the `select!` macro to select either and\n-//! handle the timeout case. This first example will break out of the loop\n-//! after 10 seconds no matter what:\n-//!\n-//! ```no_run\n-//! # #![feature(std_misc, old_io)]\n-//! use std::sync::mpsc::channel;\n-//! use std::old_io::timer::Timer;\n-//! use std::time::Duration;\n-//!\n-//! let (tx, rx) = channel::<i32>();\n-//! let mut timer = Timer::new().unwrap();\n-//! let timeout = timer.oneshot(Duration::seconds(10));\n-//!\n-//! loop {\n-//!     select! {\n-//!         val = rx.recv() => println!(\"Received {}\", val.unwrap()),\n-//!         _ = timeout.recv() => {\n-//!             println!(\"timed out, total time was more than 10 seconds\");\n-//!             break;\n-//!         }\n-//!     }\n-//! }\n-//! ```\n-//!\n-//! This second example is more costly since it allocates a new timer every\n-//! time a message is received, but it allows you to timeout after the channel\n-//! has been inactive for 5 seconds:\n-//!\n-//! ```no_run\n-//! # #![feature(std_misc, old_io)]\n-//! use std::sync::mpsc::channel;\n-//! use std::old_io::timer::Timer;\n-//! use std::time::Duration;\n-//!\n-//! let (tx, rx) = channel::<i32>();\n-//! let mut timer = Timer::new().unwrap();\n-//!\n-//! loop {\n-//!     let timeout = timer.oneshot(Duration::seconds(5));\n-//!\n-//!     select! {\n-//!         val = rx.recv() => println!(\"Received {}\", val.unwrap()),\n-//!         _ = timeout.recv() => {\n-//!             println!(\"timed out, no message received in 5 seconds\");\n-//!             break;\n-//!         }\n-//!     }\n-//! }\n-//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}