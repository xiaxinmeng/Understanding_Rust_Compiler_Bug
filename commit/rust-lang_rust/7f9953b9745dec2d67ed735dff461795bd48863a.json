{"sha": "7f9953b9745dec2d67ed735dff461795bd48863a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOTk1M2I5NzQ1ZGVjMmQ2N2VkNzM1ZGZmNDYxNzk1YmQ0ODg2M2E=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-07-24T16:07:52Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-07-24T20:46:57Z"}, "message": "refactor has_dtor_of_interest", "tree": {"sha": "dd40e788503a904b847061375ff1585f97ca473b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd40e788503a904b847061375ff1585f97ca473b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f9953b9745dec2d67ed735dff461795bd48863a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9953b9745dec2d67ed735dff461795bd48863a", "html_url": "https://github.com/rust-lang/rust/commit/7f9953b9745dec2d67ed735dff461795bd48863a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f9953b9745dec2d67ed735dff461795bd48863a/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "html_url": "https://github.com/rust-lang/rust/commit/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544"}], "stats": {"total": 205, "additions": 75, "deletions": 130}, "files": [{"sha": "95c22c98c8038a7bec646283171d52f298d5fbe0", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 75, "deletions": 130, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/7f9953b9745dec2d67ed735dff461795bd48863a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9953b9745dec2d67ed735dff461795bd48863a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=7f9953b9745dec2d67ed735dff461795bd48863a", "patch": "@@ -258,16 +258,20 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n            typ, scope);\n \n-    // types that have been traversed so far by `traverse_type_if_unseen`\n-    let mut breadcrumbs: Vec<Ty<'tcx>> = Vec::new();\n+    let parent_scope = rcx.tcx().region_maps.opt_encl_scope(scope).unwrap_or_else(|| {\n+        rcx.tcx().sess.span_bug(\n+            span, &format!(\"no enclosing scope found for scope: {:?}\", scope))\n+    });\n \n     let result = iterate_over_potentially_unsafe_regions_in_type(\n-        rcx,\n-        &mut breadcrumbs,\n+        &mut DropckContext {\n+            rcx: rcx,\n+            span: span,\n+            parent_scope: parent_scope,\n+            breadcrumbs: vec![]\n+        },\n         TypeContext::Root,\n         typ,\n-        span,\n-        scope,\n         0);\n     match result {\n         Ok(()) => {}\n@@ -324,55 +328,49 @@ enum TypeContext {\n     }\n }\n \n-// The `depth` counts the number of calls to this function;\n-// the `xref_depth` counts the subset of such calls that go\n-// across a `Box<T>` or `PhantomData<T>`.\n-fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n-    rcx: &mut Rcx<'a, 'tcx>,\n-    breadcrumbs: &mut Vec<Ty<'tcx>>,\n+struct DropckContext<'a, 'b: 'a, 'tcx: 'b> {\n+    rcx: &'a mut Rcx<'b, 'tcx>,\n+    /// types that have already been traversed\n+    breadcrumbs: Vec<Ty<'tcx>>,\n+    /// span for error reporting\n+    span: Span,\n+    /// the scope reachable dtorck types must outlive\n+    parent_scope: region::CodeExtent\n+}\n+\n+// `context` is used for reporting overflow errors\n+fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n+    cx: &mut DropckContext<'a, 'b, 'tcx>,\n     context: TypeContext,\n     ty: Ty<'tcx>,\n-    span: Span,\n-    scope: region::CodeExtent,\n     depth: usize) -> Result<(), Error<'tcx>>\n {\n+    let tcx = cx.rcx.tcx();\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems.\n-    let recursion_limit = rcx.tcx().sess.recursion_limit.get();\n+    let recursion_limit = tcx.sess.recursion_limit.get();\n     if depth / 4 >= recursion_limit {\n+        // This can get into rather deep recursion, especially in the\n+        // presence of things like Vec<T> -> Unique<T> -> PhantomData<T> -> T.\n+        // use a higher recursion limit to avoid errors.\n         return Err(Error::Overflow(context, ty))\n     }\n \n-    let opt_phantom_data_def_id = rcx.tcx().lang_items.phantom_data();\n+    let opt_phantom_data_def_id = tcx.lang_items.phantom_data();\n \n     // FIXME(arielb1): don't be O(n^2)\n-    if breadcrumbs.contains(&ty) {\n+    if cx.breadcrumbs.contains(&ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                {}ty: {} scope: {:?} - cached\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               ty, scope);\n+               ty, cx.parent_scope);\n         return Ok(()); // we already visited this type\n     }\n-    breadcrumbs.push(ty);\n+    cx.breadcrumbs.push(ty);\n     debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n            {}ty: {} scope: {:?}\",\n            (0..depth).map(|_| ' ').collect::<String>(),\n-           ty, scope);\n-\n-    // FIXME(arielb1): move into has_dtor_of_interest\n-    let dtor_kind = match ty.sty {\n-        ty::TyEnum(def_id, _) |\n-        ty::TyStruct(def_id, _) => {\n-            let destructor_for_type = rcx.tcx().destructor_for_type.borrow();\n-            match destructor_for_type.get(&def_id) {\n-                Some(def_id) => DtorKind::KnownDropMethod(*def_id),\n-                None => DtorKind::PureRecur,\n-            }\n-        }\n-        ty::TyTrait(..) | ty::TyProjection(..) => DtorKind::Unknown,\n-        _ => DtorKind::PureRecur,\n-    };\n-\n+           ty, cx.parent_scope);\n \n     // If `typ` has a destructor, then we must ensure that all\n     // borrowed data reachable via `typ` must outlive the parent\n@@ -402,38 +400,24 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n     // type parameters are unbounded.  If both conditions hold, we\n     // simply skip the `type_must_outlive` call entirely (but\n     // resume the recursive checking of the type-substructure).\n-    if has_dtor_of_interest(rcx.tcx(), dtor_kind, ty, span) {\n+    if has_dtor_of_interest(tcx, ty, cx.span) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}ty: {} - is a dtorck type!\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n                ty);\n \n-        // If `ty` is a dtorck type, then we must ensure that all\n-        // borrowed data reachable via `ty` must outlive the\n-        // parent of `scope`. (It does not suffice for it to\n-        // outlive `scope` because that could imply that the\n-        // borrowed data is torn down in between the end of\n-        // `scope` and when the destructor itself actually runs.)\n-        let parent_region =\n-            match rcx.tcx().region_maps.opt_encl_scope(scope) {\n-                Some(parent_scope) => ty::ReScope(parent_scope),\n-                None => rcx.tcx().sess.span_bug(\n-                    span, &format!(\"no enclosing scope found for scope: {:?}\",\n-                                   scope)),\n-            };\n-\n-        regionck::type_must_outlive(rcx,\n-                                    infer::SubregionOrigin::SafeDestructor(span),\n+        regionck::type_must_outlive(cx.rcx,\n+                                    infer::SubregionOrigin::SafeDestructor(cx.span),\n                                     ty,\n-                                    parent_region);\n+                                    ty::ReScope(cx.parent_scope));\n \n         return Ok(());\n     }\n \n     debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n            {}ty: {} scope: {:?} - checking interior\",\n            (0..depth).map(|_| ' ').collect::<String>(),\n-           ty, scope);\n+           ty, cx.parent_scope);\n \n     // We still need to ensure all referenced data is safe.\n     match ty.sty {\n@@ -446,55 +430,48 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         ty::TyBox(ity) | ty::TyArray(ity, _) | ty::TySlice(ity) => {\n             // single-element containers, behave like their element\n             iterate_over_potentially_unsafe_regions_in_type(\n-                rcx, breadcrumbs, context, ity, span, scope, depth+1)\n+                cx, context, ity, depth+1)\n         }\n \n         ty::TyStruct(did, substs) if Some(did) == opt_phantom_data_def_id => {\n             // PhantomData<T> - behaves identically to T\n             let ity = *substs.types.get(subst::TypeSpace, 0);\n             iterate_over_potentially_unsafe_regions_in_type(\n-                rcx, breadcrumbs, context, ity, span, scope, depth+1)\n+                cx, context, ity, depth+1)\n         }\n \n         ty::TyStruct(did, substs) => {\n-            let fields = rcx.tcx().lookup_struct_fields(did);\n+            let fields = tcx.lookup_struct_fields(did);\n             for field in &fields {\n-                let field_type = rcx.tcx().lookup_field_type(did,\n-                                                             field.id,\n-                                                             substs);\n+                let fty = tcx.lookup_field_type(did, field.id, substs);\n+                let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n+                    cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n                 try!(iterate_over_potentially_unsafe_regions_in_type(\n-                    rcx,\n-                    breadcrumbs,\n+                    cx,\n                     TypeContext::Struct {\n                         def_id: did,\n                         field: field.name,\n                     },\n-                    rcx.fcx.resolve_type_vars_if_possible(\n-                        rcx.fcx.normalize_associated_types_in(span, &field_type)),\n-                    span,\n-                    scope,\n+                    fty,\n                     depth+1))\n             }\n             Ok(())\n         }\n \n         ty::TyEnum(did, substs) => {\n-            let all_variant_info =\n-                rcx.tcx().substd_enum_variants(did, substs);\n+            let all_variant_info = tcx.substd_enum_variants(did, substs);\n             for variant_info in &all_variant_info {\n-                for (i, arg_type) in variant_info.args.iter().enumerate() {\n+                for (i, fty) in variant_info.args.iter().enumerate() {\n+                    let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n+                        cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n                     try!(iterate_over_potentially_unsafe_regions_in_type(\n-                        rcx,\n-                        breadcrumbs,\n+                        cx,\n                         TypeContext::EnumVariant {\n                             def_id: did,\n                             variant: variant_info.name,\n                             arg_index: i,\n                         },\n-                        rcx.fcx.resolve_type_vars_if_possible(\n-                            rcx.fcx.normalize_associated_types_in(span, arg_type)),\n-                        span,\n-                        scope,\n+                        fty,\n                         depth+1));\n                 }\n             }\n@@ -505,7 +482,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) => {\n             for ty in tys {\n                 try!(iterate_over_potentially_unsafe_regions_in_type(\n-                    rcx, breadcrumbs, context, ty, span, scope, depth+1))\n+                    cx, context, ty, depth+1))\n             }\n             Ok(())\n         }\n@@ -524,7 +501,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         }\n \n         ty::TyInfer(..) | ty::TyError => {\n-            rcx.tcx().sess.delay_span_bug(span, \"unresolved type in regionck\");\n+            tcx.sess.delay_span_bug(cx.span, \"unresolved type in regionck\");\n             Ok(())\n         }\n \n@@ -533,53 +510,18 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n     }\n }\n \n-enum DtorKind {\n-    // Type has an associated drop method with this def id\n-    KnownDropMethod(ast::DefId),\n-\n-    // Type has no destructor (or its dtor is known to be pure\n-    // with respect to lifetimes), though its *substructure*\n-    // may carry a destructor.\n-    PureRecur,\n-\n-    // Type may have impure destructor that is unknown;\n-    // e.g. `Box<Trait+'a>`\n-    Unknown,\n-}\n-\n fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              dtor_kind: DtorKind,\n-                              typ: ty::Ty<'tcx>,\n+                              ty: ty::Ty<'tcx>,\n                               span: Span) -> bool {\n-    let has_dtor_of_interest: bool;\n-\n-    match dtor_kind {\n-        DtorKind::PureRecur => {\n-            has_dtor_of_interest = false;\n-            debug!(\"typ: {:?} has no dtor, and thus is uninteresting\",\n-                   typ);\n-        }\n-        DtorKind::Unknown => {\n-            debug!(\"trait: {:?} is interesting\", typ);\n-            has_dtor_of_interest = true;\n-/*\n-            match bounds.region_bound {\n-                ty::ReStatic => {\n-                    debug!(\"trait: {:?} has 'static bound, and thus is uninteresting\",\n-                           typ);\n-                    has_dtor_of_interest = false;\n-                }\n-                ty::ReEmpty => {\n-                    debug!(\"trait: {:?} has empty region bound, and thus is uninteresting\",\n-                           typ);\n-                    has_dtor_of_interest = false;\n-                }\n-                r => {\n+    match ty.sty {\n+        ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) => {\n+            let dtor_method_did = match tcx.destructor_for_type.borrow().get(&def_id) {\n+                Some(def_id) => *def_id,\n+                None => {\n+                    debug!(\"ty: {:?} has no dtor, and thus isn't a dropck type\", ty);\n+                    return false;\n                 }\n-            }\n-*/\n-        }\n-        DtorKind::KnownDropMethod(dtor_method_did) => {\n+            };\n             let impl_did = tcx.impl_of_method(dtor_method_did)\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_bug(\n@@ -631,8 +573,8 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n                     if result {\n                         has_pred_of_interest = true;\n-                        debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n-                               typ, pred);\n+                        debug!(\"ty: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n+                               ty, pred);\n                         break 'items;\n                     }\n                 }\n@@ -651,22 +593,25 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n             let has_region_param_of_interest =\n                 dtor_generics.has_region_params(subst::TypeSpace);\n \n-            has_dtor_of_interest =\n+            let has_dtor_of_interest =\n                 has_region_param_of_interest ||\n                 has_pred_of_interest;\n \n             if has_dtor_of_interest {\n-                debug!(\"typ: {:?} has interesting dtor, due to \\\n+                debug!(\"ty: {:?} has interesting dtor, due to \\\n                         region params: {} or pred: {}\",\n-                       typ,\n+                       ty,\n                        has_region_param_of_interest,\n                        has_pred_of_interest);\n             } else {\n-                debug!(\"typ: {:?} has dtor, but it is uninteresting\",\n-                       typ);\n+                debug!(\"ty: {:?} has dtor, but it is uninteresting\", ty);\n             }\n+            has_dtor_of_interest\n         }\n+        ty::TyTrait(..) | ty::TyProjection(..) => {\n+            debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n+            true\n+        },\n+        _ => false\n     }\n-\n-    return has_dtor_of_interest;\n }"}]}